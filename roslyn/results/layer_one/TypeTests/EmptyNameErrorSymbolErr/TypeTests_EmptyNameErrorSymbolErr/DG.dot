digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 349232"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 349233"];
3 [label="param TypeTests(this) 349234"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 349235"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 349236"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 349237"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 349238"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 349239"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 349240"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 349241"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 349242"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 349243"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 349244"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 349245"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 349246"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 349247"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 349248"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 349249"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 349250"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 349251"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 349252"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 349253"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 349254"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 349255"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 349256"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 349257"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 349258"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 349259"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 349260"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 349261"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 349262"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 349263"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 349264"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 349265"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 349266"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 349267"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 349268"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 349269"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 349270"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 349271"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 349272"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 349273"];
43 [label="LazyThreadSafetyMode.PublicationOnly 349274"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 349275"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 349276"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 349277"];
47 [label="LazyThreadSafetyMode.PublicationOnly 349278"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 349279"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 349280"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 349281"];
51 [label="'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 349282"];
52 [label="new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 349283"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 349284"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 349285"];
55 [label="LazyThreadSafetyMode.PublicationOnly 349286"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 349287"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 349288"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 349289"];
59 [label="LazyThreadSafetyMode.PublicationOnly 349290"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 349291"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 349292"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 349293"];
63 [label="LazyThreadSafetyMode.PublicationOnly 349294"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 349295"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 349296"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 349297"];
67 [label="LazyThreadSafetyMode.PublicationOnly 349298"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349299"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349300"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 349301"];
71 [label="LazyThreadSafetyMode.PublicationOnly 349302"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349303"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349304"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 349305"];
75 [label="LazyThreadSafetyMode.PublicationOnly 349306"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349307"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349308"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 349309"];
79 [label="LazyThreadSafetyMode.PublicationOnly 349310"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349311"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349312"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 349313"];
83 [label="LazyThreadSafetyMode.PublicationOnly 349314"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349315"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349316"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 349317"];
87 [label="LazyThreadSafetyMode.PublicationOnly 349318"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349319"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349320"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 349321"];
91 [label="LazyThreadSafetyMode.PublicationOnly 349322"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349323"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349324"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 349325"];
95 [label="LazyThreadSafetyMode.PublicationOnly 349326"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 349327"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 349328"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 349329"];
99 [label="LazyThreadSafetyMode.PublicationOnly 349330"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 349331"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 349332"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 349333"];
103 [label="LazyThreadSafetyMode.PublicationOnly 349334"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349335"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349336"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 349337"];
107 [label="LazyThreadSafetyMode.PublicationOnly 349338"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349339"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349340"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 349341"];
111 [label="LazyThreadSafetyMode.PublicationOnly 349342"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349343"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349344"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 349345"];
115 [label="LazyThreadSafetyMode.PublicationOnly 349346"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349347"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349348"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 349349"];
119 [label="LazyThreadSafetyMode.PublicationOnly 349350"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 349351"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 349352"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 349353"];
123 [label="LazyThreadSafetyMode.PublicationOnly 349354"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349355"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349356"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 349357"];
127 [label="LazyThreadSafetyMode.PublicationOnly 349358"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349359"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349360"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 349361"];
131 [label="LazyThreadSafetyMode.PublicationOnly 349362"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349363"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349364"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 349365"];
135 [label="LazyThreadSafetyMode.PublicationOnly 349366"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349367"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349368"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 349369"];
139 [label="LazyThreadSafetyMode.PublicationOnly 349370"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349371"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349372"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 349373"];
143 [label="LazyThreadSafetyMode.PublicationOnly 349374"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349375"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349376"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 349377"];
147 [label="LazyThreadSafetyMode.PublicationOnly 349378"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349379"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349380"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 349381"];
151 [label="LazyThreadSafetyMode.PublicationOnly 349382"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349383"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349384"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 349385"];
155 [label="LazyThreadSafetyMode.PublicationOnly 349386"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349387"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349388"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 349389"];
159 [label="LazyThreadSafetyMode.PublicationOnly 349390"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349391"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349392"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 349393"];
163 [label="LazyThreadSafetyMode.PublicationOnly 349394"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349395"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349396"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 349397"];
167 [label="LazyThreadSafetyMode.PublicationOnly 349398"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349399"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349400"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 349401"];
171 [label="LazyThreadSafetyMode.PublicationOnly 349402"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349403"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 349404"];
174 [label="@'R:\\Invalid.dll' 349405"];
175 [label="fullPath: @'R:\\Invalid.dll' 349406"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 349407"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 349408"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 349409"];
179 [label="MscorlibRef_v4_0_30316_17626 349410"];
180 [label="Net451.mscorlib 349411"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 349412"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 349413"];
183 [label="'/*<bind>*/' 349414"];
184 [label="StartString = '/*<bind>*/' 349415"];
185 [label="'/*</bind>*/' 349416"];
186 [label="EndString = '/*</bind>*/' 349417"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 349418"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 349419"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 349420"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 349421"];
191 [label="param CSharpTestBase(this) 349422"];
192 [label="param CommonTestBase(this) 349423"];
193 [label="param TestBase(this) 349424"];
194 [label="_temp 349425"];
195 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 349426"];
196 [label="param EmptyNameErrorSymbolErr(this) 349427"];
197 [label="var text = @'\nnamespace NS\n{\n  class A { }\n  class B : A[] {}\n}\n'; 349428"];
198 [label="var comp = CreateCompilation(text); 349429"];
199 [label="text 349430"];
200 [label="param operator(string source) 349431"];
201 [label="source 349432"];
202 [label="new CSharpTestSource(source) 349433"];
203 [label="param CSharpTestSource(object value) 349434"];
204 [label="param CSharpTestSource(this) 349435"];
205 [label="Value 349436"];
206 [label="var comp = CreateCompilation(text); 349437"];
207 [label="var comp = CreateCompilation(text); 349438"];
208 [label="CreateCompilation(text) 349439"];
209 [label="param CreateCompilation(CSharpTestSource source) 349440"];
210 [label="param CreateCompilation(IEnumerable<MetadataReference> references = null) 349441"];
211 [label="param CreateCompilation(CSharpCompilationOptions options = null) 349442"];
212 [label="param CreateCompilation(CSharpParseOptions parseOptions = null) 349443"];
213 [label="param CreateCompilation(TargetFramework targetFramework = TargetFramework.Standard) 349444"];
214 [label="param CreateCompilation(string assemblyName = '') 349445"];
215 [label="param CreateCompilation(string sourceFileName = '') 349446"];
216 [label="param CreateCompilation(bool skipUsesIsNullable = false) 349447"];
217 [label="source 349448"];
218 [label="targetFramework 349449"];
219 [label="references 349450"];
220 [label="TargetFrameworkUtil.GetReferences(targetFramework, references) 349451"];
221 [label="param GetReferences(TargetFramework tf) 349452"];
222 [label="param GetReferences(IEnumerable<MetadataReference> additionalReferences) 349453"];
223 [label="var references = GetReferences(tf); 349454"];
224 [label="GetReferences(tf) 349455"];
225 [label="param GetReferences(TargetFramework targetFramework) 349456"];
226 [label="targetFramework switch\n        {\n            TargetFramework.Empty => ImmutableArray<MetadataReference>.Empty,\n            TargetFramework.Mscorlib40 => Mscorlib40References,\n            TargetFramework.Mscorlib40Extended => Mscorlib40ExtendedReferences,\n            TargetFramework.Mscorlib40AndSystemCore => Mscorlib40andSystemCoreReferences,\n            TargetFramework.Mscorlib40AndVBRuntime => Mscorlib40andVBRuntimeReferences,\n            TargetFramework.Mscorlib45 => Mscorlib45References,\n            TargetFramework.Mscorlib45Extended => Mscorlib45ExtendedReferences,\n            TargetFramework.Mscorlib45AndCSharp => Mscorlib45AndCSharpReferences,\n            TargetFramework.Mscorlib45AndVBRuntime => Mscorlib45AndVBRuntimeReferences,\n            TargetFramework.Mscorlib46 => Mscorlib46References,\n            TargetFramework.Mscorlib46Extended => Mscorlib46ExtendedReferences,\n            TargetFramework.Mscorlib461 => Mscorlib46References,\n            TargetFramework.Mscorlib461Extended => Mscorlib461ExtendedReferences,\n            TargetFramework.NetStandard20 => NetStandard20References,\n            TargetFramework.NetCoreApp => NetCoreAppReferences,\n            TargetFramework.WinRT => WinRTReferences,\n            TargetFramework.Standard => StandardReferences,\n            TargetFramework.StandardLatest => StandardLatestReferences,\n            TargetFramework.StandardAndCSharp => StandardAndCSharpReferences,\n            TargetFramework.StandardAndVBRuntime => StandardAndVBRuntimeReferences,\n            TargetFramework.StandardCompat => StandardCompatReferences,\n            TargetFramework.DefaultVb => DefaultVbReferences,\n            TargetFramework.Minimal => MinimalReferences,\n            TargetFramework.MinimalAsync => MinimalAsyncReferences,\n            _ => throw new InvalidOperationException($'Unexpected target framework {targetFramework}'),\n        } 349457"];
227 [label="StandardReferences 349458"];
228 [label="RuntimeUtilities.IsCoreClrRuntime 349459"];
229 [label="Mscorlib46ExtendedReferences 349460"];
230 [label="ImmutableArray.Create<MetadataReference>(Net461.mscorlib, Net461.System, TestMetadata.Net461.SystemCore, TestBase.ValueTupleRef, Net461.SystemRuntime) 349461"];
231 [label="TestBase.ValueTupleRef 349462"];
232 [label="TestReferences.NetFx.ValueTuple.tuplelib 349463"];
233 [label="ImmutableArray.Create<MetadataReference>(Net461.mscorlib, Net461.System, TestMetadata.Net461.SystemCore, TestBase.ValueTupleRef, Net461.SystemRuntime) 349464"];
234 [label="RuntimeUtilities.IsCoreClrRuntime ? NetStandard20References : Mscorlib46ExtendedReferences 349465"];
235 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 349466"];
236 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 349467"];
237 [label="return references; 349468"];
238 [label="options 349469"];
239 [label="parseOptions 349470"];
240 [label="assemblyName 349471"];
241 [label="sourceFileName 349472"];
242 [label="skipUsesIsNullable 349473"];
243 [label="CreateEmptyCompilation(source, TargetFrameworkUtil.GetReferences(targetFramework, references), options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable) 349474"];
244 [label="param CreateEmptyCompilation(CSharpTestSource source) 349475"];
245 [label="param CreateEmptyCompilation(IEnumerable<MetadataReference> references = null) 349476"];
246 [label="param CreateEmptyCompilation(CSharpCompilationOptions options = null) 349477"];
247 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 349478"];
248 [label="param CreateEmptyCompilation(string assemblyName = '') 349479"];
249 [label="param CreateEmptyCompilation(string sourceFileName = '') 349480"];
250 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 349481"];
251 [label="source 349482"];
252 [label="references 349483"];
253 [label="options 349484"];
254 [label="parseOptions 349485"];
255 [label="assemblyName 349486"];
256 [label="sourceFileName 349487"];
257 [label="skipUsesIsNullable 349488"];
258 [label="null 349489"];
259 [label="experimentalFeature: null 349490"];
260 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 349491"];
261 [label="param CreateCompilationCore(CSharpTestSource source) 349492"];
262 [label="param CreateCompilationCore(IEnumerable<MetadataReference> references) 349493"];
263 [label="param CreateCompilationCore(CSharpCompilationOptions options) 349494"];
264 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 349495"];
265 [label="param CreateCompilationCore(string assemblyName) 349496"];
266 [label="param CreateCompilationCore(string sourceFileName) 349497"];
267 [label="param CreateCompilationCore(bool skipUsesIsNullable) 349498"];
268 [label="param CreateCompilationCore(MessageID? experimentalFeature) 349499"];
269 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 349500"];
270 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 349501"];
271 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 349502"];
272 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 349503"];
273 [label="param GetSyntaxTrees(string sourceFileName = '') 349504"];
274 [label="param GetSyntaxTrees(this) 349505"];
275 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 349506"];
276 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 349507"];
277 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 349508"];
278 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 349509"];
279 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 349510"];
280 [label="param Parse(string text) 349511"];
281 [label="param Parse(string filename = '') 349512"];
282 [label="param Parse(CSharpParseOptions options = null) 349513"];
283 [label="param Parse(Encoding encoding = null) 349514"];
284 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 349515"];
285 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 349516"];
286 [label="kind: SourceCodeKind.Regular 349517"];
287 [label="documentationMode: DocumentationMode.Parse 349518"];
288 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 349519"];
289 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 349520"];
290 [label="Regular = new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 349521"];
291 [label="SourceCodeKind.Script 349522"];
292 [label="Regular.WithKind(SourceCodeKind.Script) 349523"];
293 [label="Script = Regular.WithKind(SourceCodeKind.Script) 349524"];
294 [label="LanguageVersion.CSharp6 349525"];
295 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp6) 349526"];
296 [label="Regular6 = Regular.WithLanguageVersion(LanguageVersion.CSharp6) 349527"];
297 [label="LanguageVersion.CSharp7 349528"];
298 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7) 349529"];
299 [label="Regular7 = Regular.WithLanguageVersion(LanguageVersion.CSharp7) 349530"];
300 [label="LanguageVersion.CSharp7_1 349531"];
301 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 349532"];
302 [label="Regular7_1 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 349533"];
303 [label="LanguageVersion.CSharp7_2 349534"];
304 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 349535"];
305 [label="Regular7_2 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 349536"];
306 [label="LanguageVersion.CSharp7_3 349537"];
307 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 349538"];
308 [label="Regular7_3 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 349539"];
309 [label="LanguageVersion.Default 349540"];
310 [label="Regular.WithLanguageVersion(LanguageVersion.Default) 349541"];
311 [label="RegularDefault = Regular.WithLanguageVersion(LanguageVersion.Default) 349542"];
312 [label="LanguageVersion.Preview 349543"];
313 [label="Regular.WithLanguageVersion(LanguageVersion.Preview) 349544"];
314 [label="RegularPreview = Regular.WithLanguageVersion(LanguageVersion.Preview) 349545"];
315 [label="LanguageVersion.CSharp8 349546"];
316 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 349547"];
317 [label="Regular8 = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 349548"];
318 [label="LanguageVersion.CSharp9 349549"];
319 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp9) 349550"];
320 [label="Regular9 = Regular.WithLanguageVersion(LanguageVersion.CSharp9) 349551"];
321 [label="DocumentationMode.Diagnose 349552"];
322 [label="Regular.WithDocumentationMode(DocumentationMode.Diagnose) 349553"];
323 [label="RegularWithDocumentationComments = Regular.WithDocumentationMode(DocumentationMode.Diagnose) 349554"];
324 [label="Regular 349555"];
325 [label="'UseLegacyStrongNameProvider' 349556"];
326 [label="Regular.WithFeature('UseLegacyStrongNameProvider') 349557"];
327 [label="param WithFeature(this CSharpParseOptions options) 349558"];
328 [label="param WithFeature(string feature) 349559"];
329 [label="param WithFeature(string value = 'true') 349560"];
330 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 349561"];
331 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 349562"];
332 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 349563"];
333 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 349564"];
334 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 349565"];
335 [label="new[] { new KeyValuePair<string, string>(feature, value) } 349566"];
336 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 349567"];
337 [label="RegularWithLegacyStrongName = Regular.WithFeature('UseLegacyStrongNameProvider') 349568"];
338 [label="MessageID.IDS_FeatureImprovedOverloadCandidates 349569"];
339 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() 349570"];
340 [label="1 349571"];
341 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1 349572"];
342 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 349573"];
343 [label="WithoutImprovedOverloadCandidates = Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 349574"];
344 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides 349575"];
345 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion() 349576"];
346 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 349577"];
347 [label="WithCovariantReturns = Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 349578"];
348 [label="LanguageVersion.CSharp8 349579"];
349 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 349580"];
350 [label="WithoutCovariantReturns = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 349581"];
351 [label="RegularWithExtendedPartialMethods = RegularPreview 349582"];
352 [label="new SmallDictionary<string, string> { } 349583"];
353 [label="s_experimentalFeatures = new SmallDictionary<string, string> { } 349584"];
354 [label="kind: SourceCodeKind.Regular 349585"];
355 [label="documentationMode: DocumentationMode.None 349586"];
356 [label="languageVersion: LanguageVersion.Preview 349587"];
357 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 349588"];
358 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 349589"];
359 [label="s_experimentalFeatures 349590"];
360 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 349591"];
361 [label="ExperimentalParseOptions =\n            new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 349592"];
362 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 349593"];
363 [label="'testV7SwitchBinder' 349594"];
364 [label="'true' 349595"];
365 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 349596"];
366 [label="Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 349597"];
367 [label="Regular6WithV7SwitchBinder = Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 349598"];
368 [label="RegularWithoutRecursivePatterns = Regular7_3 349599"];
369 [label="RegularWithRecursivePatterns = Regular8 349600"];
370 [label="RegularWithoutPatternCombinators = Regular8 349601"];
371 [label="RegularWithPatternCombinators = RegularPreview 349602"];
372 [label="OutputKind.DynamicallyLinkedLibrary 349603"];
373 [label="OptimizationLevel.Release 349604"];
374 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 349605"];
375 [label="param CreateTestOptions(OutputKind outputKind) 349606"];
376 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 349607"];
377 [label="param CreateTestOptions(bool allowUnsafe = false) 349608"];
378 [label="outputKind 349609"];
379 [label="optimizationLevel: optimizationLevel 349610"];
380 [label="warningLevel: Diagnostic.MaxWarningLevel 349611"];
381 [label="allowUnsafe: allowUnsafe 349612"];
382 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349613"];
383 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349614"];
384 [label="ReleaseDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 349615"];
385 [label="OutputKind.ConsoleApplication 349616"];
386 [label="OptimizationLevel.Release 349617"];
387 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 349618"];
388 [label="param CreateTestOptions(OutputKind outputKind) 349619"];
389 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 349620"];
390 [label="param CreateTestOptions(bool allowUnsafe = false) 349621"];
391 [label="outputKind 349622"];
392 [label="optimizationLevel: optimizationLevel 349623"];
393 [label="warningLevel: Diagnostic.MaxWarningLevel 349624"];
394 [label="allowUnsafe: allowUnsafe 349625"];
395 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349626"];
396 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349627"];
397 [label="ReleaseExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 349628"];
398 [label="true 349629"];
399 [label="ReleaseDll.WithDebugPlusMode(true) 349630"];
400 [label="ReleaseDebugDll = ReleaseDll.WithDebugPlusMode(true) 349631"];
401 [label="true 349632"];
402 [label="ReleaseExe.WithDebugPlusMode(true) 349633"];
403 [label="ReleaseDebugExe = ReleaseExe.WithDebugPlusMode(true) 349634"];
404 [label="OutputKind.DynamicallyLinkedLibrary 349635"];
405 [label="OptimizationLevel.Debug 349636"];
406 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 349637"];
407 [label="param CreateTestOptions(OutputKind outputKind) 349638"];
408 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 349639"];
409 [label="param CreateTestOptions(bool allowUnsafe = false) 349640"];
410 [label="outputKind 349641"];
411 [label="optimizationLevel: optimizationLevel 349642"];
412 [label="warningLevel: Diagnostic.MaxWarningLevel 349643"];
413 [label="allowUnsafe: allowUnsafe 349644"];
414 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349645"];
415 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349646"];
416 [label="DebugDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 349647"];
417 [label="OutputKind.ConsoleApplication 349648"];
418 [label="OptimizationLevel.Debug 349649"];
419 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 349650"];
420 [label="param CreateTestOptions(OutputKind outputKind) 349651"];
421 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 349652"];
422 [label="param CreateTestOptions(bool allowUnsafe = false) 349653"];
423 [label="outputKind 349654"];
424 [label="optimizationLevel: optimizationLevel 349655"];
425 [label="warningLevel: Diagnostic.MaxWarningLevel 349656"];
426 [label="allowUnsafe: allowUnsafe 349657"];
427 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349658"];
428 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349659"];
429 [label="DebugExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 349660"];
430 [label="OutputKind.WindowsRuntimeMetadata 349661"];
431 [label="OptimizationLevel.Release 349662"];
432 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 349663"];
433 [label="param CreateTestOptions(OutputKind outputKind) 349664"];
434 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 349665"];
435 [label="param CreateTestOptions(bool allowUnsafe = false) 349666"];
436 [label="outputKind 349667"];
437 [label="optimizationLevel: optimizationLevel 349668"];
438 [label="warningLevel: Diagnostic.MaxWarningLevel 349669"];
439 [label="allowUnsafe: allowUnsafe 349670"];
440 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349671"];
441 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349672"];
442 [label="ReleaseWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 349673"];
443 [label="OutputKind.WindowsRuntimeMetadata 349674"];
444 [label="OptimizationLevel.Debug 349675"];
445 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 349676"];
446 [label="param CreateTestOptions(OutputKind outputKind) 349677"];
447 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 349678"];
448 [label="param CreateTestOptions(bool allowUnsafe = false) 349679"];
449 [label="outputKind 349680"];
450 [label="optimizationLevel: optimizationLevel 349681"];
451 [label="warningLevel: Diagnostic.MaxWarningLevel 349682"];
452 [label="allowUnsafe: allowUnsafe 349683"];
453 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349684"];
454 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349685"];
455 [label="DebugWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 349686"];
456 [label="OutputKind.NetModule 349687"];
457 [label="OptimizationLevel.Release 349688"];
458 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 349689"];
459 [label="param CreateTestOptions(OutputKind outputKind) 349690"];
460 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 349691"];
461 [label="param CreateTestOptions(bool allowUnsafe = false) 349692"];
462 [label="outputKind 349693"];
463 [label="optimizationLevel: optimizationLevel 349694"];
464 [label="warningLevel: Diagnostic.MaxWarningLevel 349695"];
465 [label="allowUnsafe: allowUnsafe 349696"];
466 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349697"];
467 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349698"];
468 [label="ReleaseModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 349699"];
469 [label="OutputKind.NetModule 349700"];
470 [label="OptimizationLevel.Debug 349701"];
471 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 349702"];
472 [label="param CreateTestOptions(OutputKind outputKind) 349703"];
473 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 349704"];
474 [label="param CreateTestOptions(bool allowUnsafe = false) 349705"];
475 [label="outputKind 349706"];
476 [label="optimizationLevel: optimizationLevel 349707"];
477 [label="warningLevel: Diagnostic.MaxWarningLevel 349708"];
478 [label="allowUnsafe: allowUnsafe 349709"];
479 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349710"];
480 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 349711"];
481 [label="DebugModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 349712"];
482 [label="true 349713"];
483 [label="ReleaseDll.WithAllowUnsafe(true) 349714"];
484 [label="UnsafeReleaseDll = ReleaseDll.WithAllowUnsafe(true) 349715"];
485 [label="true 349716"];
486 [label="ReleaseExe.WithAllowUnsafe(true) 349717"];
487 [label="UnsafeReleaseExe = ReleaseExe.WithAllowUnsafe(true) 349718"];
488 [label="true 349719"];
489 [label="DebugDll.WithAllowUnsafe(true) 349720"];
490 [label="UnsafeDebugDll = DebugDll.WithAllowUnsafe(true) 349721"];
491 [label="true 349722"];
492 [label="DebugExe.WithAllowUnsafe(true) 349723"];
493 [label="UnsafeDebugExe = DebugExe.WithAllowUnsafe(true) 349724"];
494 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 349725"];
495 [label="ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 349726"];
496 [label="SigningReleaseDll = ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 349727"];
497 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 349728"];
498 [label="ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 349729"];
499 [label="SigningReleaseExe = ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 349730"];
500 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 349731"];
501 [label="ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 349732"];
502 [label="SigningReleaseModule = ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 349733"];
503 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 349734"];
504 [label="DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 349735"];
505 [label="SigningDebugDll = DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 349736"];
506 [label="DebugInformationFormat.Pdb 349737"];
507 [label="EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 349738"];
508 [label="NativePdbEmit = EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 349739"];
509 [label="options = TestOptions.Regular; 349740"];
510 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 349741"];
511 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 349742"];
512 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 349743"];
513 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 349744"];
514 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 349745"];
515 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 349746"];
516 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 349747"];
517 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 349748"];
518 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 349749"];
519 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 349750"];
520 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 349751"];
521 [label="param CheckSerializable(SyntaxTree tree) 349752"];
522 [label="var stream = new MemoryStream(); 349753"];
523 [label="var root = tree.GetRoot(); 349754"];
524 [label="var root = tree.GetRoot(); 349755"];
525 [label="root.SerializeTo(stream); 349756"];
526 [label="root.SerializeTo(stream); 349757"];
527 [label="root.SerializeTo(stream); 349758"];
528 [label="stream.Position = 0; 349759"];
529 [label="stream.Position 349760"];
530 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 349761"];
531 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 349762"];
532 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 349763"];
533 [label="return tree; 349764"];
534 [label="new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) } 349765"];
535 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 349766"];
536 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 349767"];
537 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 349768"];
538 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 349769"];
539 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 349770"];
540 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 349771"];
541 [label="hasTopLevelStatements 349772"];
542 [label="options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll; 349773"];
543 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 349774"];
544 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 349775"];
545 [label="Func<CSharpCompilation> createCompilationLambda = () => CSharpCompilation.Create(\n                assemblyName == '' ? GetUniqueName() : assemblyName,\n                syntaxTrees,\n                references,\n                options); 349776"];
546 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 349777"];
547 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 349778"];
548 [label="param ValidateIOperations(Func<Compilation> createCompilation) 349779"];
549 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 349780"];
550 [label="return; 349781"];
551 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 349782"];
552 [label="var compilation = createCompilationLambda(); 349783"];
553 [label="var compilation = createCompilationLambda(); 349784"];
554 [label="return Guid.NewGuid().ToString('D'); 349785"];
555 [label="var compilation = createCompilationLambda(); 349786"];
556 [label="OutputKind.ConsoleApplication 349787"];
557 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 349788"];
558 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 349789"];
559 [label="s_defaultOptions = new CSharpCompilationOptions(OutputKind.ConsoleApplication) 349790"];
560 [label="OutputKind.DynamicallyLinkedLibrary 349791"];
561 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 349792"];
562 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 349793"];
563 [label="true 349794"];
564 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 349795"];
565 [label="s_defaultSubmissionOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 349796"];
566 [label="param Create(string? assemblyName) 349797"];
567 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees = null) 349798"];
568 [label="param Create(IEnumerable<MetadataReference>? references = null) 349799"];
569 [label="param Create(CSharpCompilationOptions? options = null) 349800"];
570 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 349801"];
571 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 349802"];
572 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 349803"];
573 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 349804"];
574 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 349805"];
575 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 349806"];
576 [label="param Create(string? assemblyName) 349807"];
577 [label="param Create(CSharpCompilationOptions options) 349808"];
578 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees) 349809"];
579 [label="param Create(IEnumerable<MetadataReference>? references) 349810"];
580 [label="param Create(CSharpCompilation? previousSubmission) 349811"];
581 [label="param Create(Type? returnType) 349812"];
582 [label="param Create(Type? hostObjectType) 349813"];
583 [label="param Create(bool isSubmission) 349814"];
584 [label="RoslynDebug.Assert(options != null); 349815"];
585 [label="RoslynDebug.Assert(options != null); 349816"];
586 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 349817"];
587 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 349818"];
588 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 349819"];
589 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 349820"];
590 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 349821"];
591 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 349822"];
592 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 349823"];
593 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 349824"];
594 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 349825"];
595 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 349826"];
596 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 349827"];
597 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 349828"];
598 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 349829"];
599 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 349830"];
600 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 349831"];
601 [label="param CSharpCompilation(string? assemblyName) 349832"];
602 [label="param CSharpCompilation(CSharpCompilationOptions options) 349833"];
603 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 349834"];
604 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 349835"];
605 [label="param CSharpCompilation(Type? submissionReturnType) 349836"];
606 [label="param CSharpCompilation(Type? hostObjectType) 349837"];
607 [label="param CSharpCompilation(bool isSubmission) 349838"];
608 [label="param CSharpCompilation(ReferenceManager? referenceManager) 349839"];
609 [label="param CSharpCompilation(bool reuseReferenceManager) 349840"];
610 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 349841"];
611 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 349842"];
612 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 349843"];
613 [label="param CSharpCompilation(this) 349844"];
614 [label="assemblyName 349845"];
615 [label="options 349846"];
616 [label="references 349847"];
617 [label="previousSubmission 349848"];
618 [label="submissionReturnType 349849"];
619 [label="hostObjectType 349850"];
620 [label="isSubmission 349851"];
621 [label="referenceManager 349852"];
622 [label="reuseReferenceManager 349853"];
623 [label="syntaxAndDeclarations 349854"];
624 [label="syntaxAndDeclarations.ExternalSyntaxTrees 349855"];
625 [label="SyntaxTreeCommonFeatures(syntaxAndDeclarations.ExternalSyntaxTrees) 349856"];
626 [label="semanticModelProvider 349857"];
627 [label="eventQueue 349858"];
628 [label="param CSharpCompilation(this) 349859"];
629 [label="param CSharpCompilation(string? assemblyName) 349860"];
630 [label="param CSharpCompilation(CSharpCompilationOptions options) 349861"];
631 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 349862"];
632 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 349863"];
633 [label="param CSharpCompilation(Type? submissionReturnType) 349864"];
634 [label="param CSharpCompilation(Type? hostObjectType) 349865"];
635 [label="param CSharpCompilation(bool isSubmission) 349866"];
636 [label="param CSharpCompilation(ReferenceManager? referenceManager) 349867"];
637 [label="param CSharpCompilation(bool reuseReferenceManager) 349868"];
638 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 349869"];
639 [label="param CSharpCompilation(IReadOnlyDictionary<string, string> features) 349870"];
640 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 349871"];
641 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 349872"];
642 [label="param CSharpCompilation(this) 349873"];
643 [label="assemblyName 349874"];
644 [label="references 349875"];
645 [label="features 349876"];
646 [label="isSubmission 349877"];
647 [label="semanticModelProvider 349878"];
648 [label="eventQueue 349879"];
649 [label="param CSharpCompilation(this) 349880"];
650 [label="param CSharpCompilation(this) 349881"];
651 [label="_options 349882"];
652 [label="_globalImports 349883"];
653 [label="_previousSubmissionImports 349884"];
654 [label="_globalNamespaceAlias 349885"];
655 [label="_scriptClass 349886"];
656 [label="_lazyHostObjectTypeSymbol 349887"];
657 [label="_lazyImportInfos 349888"];
658 [label="_conversions 349889"];
659 [label="_anonymousTypeManager 349890"];
660 [label="_lazyGlobalNamespace 349891"];
661 [label="builtInOperators 349892"];
662 [label="_lazyAssemblySymbol 349893"];
663 [label="_referenceManager 349894"];
664 [label="_syntaxAndDeclarations 349895"];
665 [label="_lazyEntryPoint 349896"];
666 [label="_lazyEmitNullablePublicOnly 349897"];
667 [label="_lazyCompilationUnitCompletedTrees 349898"];
668 [label="NullableAnalysisData 349899"];
669 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 349900"];
670 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 349901"];
671 [label="_externAliasTargets 349902"];
672 [label="_moduleInitializerMethods 349903"];
673 [label="_binderFactories 349904"];
674 [label="_ignoreAccessibilityBinderFactories 349905"];
675 [label="_lazyDeclarationDiagnostics 349906"];
676 [label="_declarationDiagnosticsFrozen 349907"];
677 [label="new DiagnosticBag() 349908"];
678 [label="_additionalCodegenWarnings = new DiagnosticBag() 349909"];
679 [label="WellKnownMemberSignatureComparer 349910"];
680 [label="_lazyWellKnownTypes 349911"];
681 [label="_lazyWellKnownTypeMembers 349912"];
682 [label="_usesNullableAttributes 349913"];
683 [label="_needsGeneratedAttributes 349914"];
684 [label="_needsGeneratedAttributes_IsFrozen 349915"];
685 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 349916"];
686 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 349917"];
687 [label="new WellKnownMembersSignatureComparer(this) 349918"];
688 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 349919"];
689 [label="param WellKnownMembersSignatureComparer(this) 349920"];
690 [label="new SpecialMembersSignatureComparer() 349921"];
691 [label="param SpecialMembersSignatureComparer(this) 349922"];
692 [label="Instance = new SpecialMembersSignatureComparer() 349923"];
693 [label="param WellKnownMembersSignatureComparer(this) 349924"];
694 [label="param SpecialMembersSignatureComparer(this) 349925"];
695 [label="param SpecialMembersSignatureComparer(this) 349926"];
696 [label="_compilation 349927"];
697 [label="_compilation 349928"];
698 [label="WellKnownMemberSignatureComparer 349929"];
699 [label="_options 349930"];
700 [label="this.builtInOperators = new BuiltInOperators(this); 349931"];
701 [label="this.builtInOperators = new BuiltInOperators(this); 349932"];
702 [label="this.builtInOperators 349933"];
703 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 349934"];
704 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 349935"];
705 [label="_scriptClass 349936"];
706 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 349937"];
707 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 349938"];
708 [label="_globalImports 349939"];
709 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 349940"];
710 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 349941"];
711 [label="_previousSubmissionImports 349942"];
712 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 349943"];
713 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 349944"];
714 [label="_globalNamespaceAlias 349945"];
715 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 349946"];
716 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 349947"];
717 [label="new AnonymousTypeManager(this) 349948"];
718 [label="param AnonymousTypeManager(CSharpCompilation compilation) 349949"];
719 [label="param AnonymousTypeManager(this) 349950"];
720 [label="param AnonymousTypeManager(this) 349951"];
721 [label="public CSharpCompilation Compilation { get; } 349952"];
722 [label="_lazyAnonymousTypeTemplates 349953"];
723 [label="_lazySynthesizedDelegates 349954"];
724 [label="new ConcurrentDictionary<Location, bool>() 349955"];
725 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 349956"];
726 [label="Debug.Assert(compilation != null); 349957"];
727 [label="Debug.Assert(compilation != null); 349958"];
728 [label="this.Compilation 349959"];
729 [label="_anonymousTypeManager 349960"];
730 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 349961"];
731 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 349962"];
732 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 349963"];
733 [label="LanguageVersion? result = null; 349964"];
734 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 349965"];
735 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 349966"];
736 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 349967"];
737 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 349968"];
738 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 349969"];
739 [label="this.LanguageVersion 349970"];
740 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 349971"];
741 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 349972"];
742 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 349973"];
743 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 349974"];
744 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 349975"];
745 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 349976"];
746 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 349977"];
747 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 349978"];
748 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 349979"];
749 [label="this.Options 349980"];
750 [label="get\n            {\n                return _options;\n            } 349981"];
751 [label="return _options; 349982"];
752 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 349983"];
753 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 349984"];
754 [label="new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata) 349985"];
755 [label="param ReferenceManager(string simpleAssemblyName) 349986"];
756 [label="param ReferenceManager(AssemblyIdentityComparer identityComparer) 349987"];
757 [label="param ReferenceManager(Dictionary<MetadataReference, MetadataOrDiagnostic>? observedMetadata) 349988"];
758 [label="param ReferenceManager(this) 349989"];
759 [label="simpleAssemblyName 349990"];
760 [label="identityComparer 349991"];
761 [label="observedMetadata 349992"];
762 [label="param ReferenceManager(this) 349993"];
763 [label="param ReferenceManager(this) 349994"];
764 [label="_referenceManager 349995"];
765 [label="_syntaxAndDeclarations 349996"];
766 [label="Debug.Assert(_lazyAssemblySymbol is null); 349997"];
767 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 349998"];
768 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 349999"];
769 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 350000"];
770 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 350001"];
771 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 350002"];
772 [label="compilation.AddSyntaxTrees(syntaxTrees) 350003"];
773 [label="param AddSyntaxTrees(IEnumerable<SyntaxTree> trees) 350004"];
774 [label="param AddSyntaxTrees(this) 350005"];
775 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 350006"];
776 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 350007"];
777 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 350008"];
778 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 350009"];
779 [label="var externalSyntaxTrees = PooledHashSet<SyntaxTree>.GetInstance(); 350010"];
780 [label="var syntaxAndDeclarations = _syntaxAndDeclarations; 350011"];
781 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 350012"];
782 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 350013"];
783 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 350014"];
784 [label="bool reuseReferenceManager = true; 350015"];
785 [label="int i = 0; 350016"];
786 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 350017"];
787 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 350018"];
788 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 350019"];
789 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 350020"];
790 [label="if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                } 350021"];
791 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 350022"];
792 [label="externalSyntaxTrees.Add(tree); 350023"];
793 [label="externalSyntaxTrees.Add(tree); 350024"];
794 [label="reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives; 350025"];
795 [label="i++; 350026"];
796 [label="externalSyntaxTrees.Free(); 350027"];
797 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 350028"];
798 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 350029"];
799 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 350030"];
800 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 350031"];
801 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 350032"];
802 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 350033"];
803 [label="Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations) 350034"];
804 [label="param Update(ReferenceManager referenceManager) 350035"];
805 [label="param Update(bool reuseReferenceManager) 350036"];
806 [label="param Update(SyntaxAndDeclarationManager syntaxAndDeclarations) 350037"];
807 [label="param Update(this) 350038"];
808 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 350039"];
809 [label="this.PreviousSubmission 350040"];
810 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 350041"];
811 [label="ScriptCompilationInfo 350042"];
812 [label="ScriptCompilationInfo?.PreviousScriptCompilation 350043"];
813 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 350044"];
814 [label="this.SubmissionReturnType 350045"];
815 [label="=> ScriptCompilationInfo 350046"];
816 [label="ScriptCompilationInfo 350047"];
817 [label="this.HostObjectType 350048"];
818 [label="=> ScriptCompilationInfo 350049"];
819 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 350050"];
820 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 350051"];
821 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 350052"];
822 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 350053"];
823 [label="new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider) 350054"];
824 [label="param CSharpCompilation(string? assemblyName) 350055"];
825 [label="param CSharpCompilation(CSharpCompilationOptions options) 350056"];
826 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 350057"];
827 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 350058"];
828 [label="param CSharpCompilation(Type? submissionReturnType) 350059"];
829 [label="param CSharpCompilation(Type? hostObjectType) 350060"];
830 [label="param CSharpCompilation(bool isSubmission) 350061"];
831 [label="param CSharpCompilation(ReferenceManager? referenceManager) 350062"];
832 [label="param CSharpCompilation(bool reuseReferenceManager) 350063"];
833 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 350064"];
834 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 350065"];
835 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 350066"];
836 [label="param CSharpCompilation(this) 350067"];
837 [label="previousSubmission 350068"];
838 [label="submissionReturnType 350069"];
839 [label="hostObjectType 350070"];
840 [label="syntaxAndDeclarations.ExternalSyntaxTrees 350071"];
841 [label="eventQueue 350072"];
842 [label="param CSharpCompilation(this) 350073"];
843 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 350074"];
844 [label="param CSharpCompilation(Type? submissionReturnType) 350075"];
845 [label="param CSharpCompilation(Type? hostObjectType) 350076"];
846 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 350077"];
847 [label="param CSharpCompilation(this) 350078"];
848 [label="eventQueue 350079"];
849 [label="param CSharpCompilation(this) 350080"];
850 [label="_options 350081"];
851 [label="_globalImports 350082"];
852 [label="_previousSubmissionImports 350083"];
853 [label="_globalNamespaceAlias 350084"];
854 [label="_scriptClass 350085"];
855 [label="_lazyHostObjectTypeSymbol 350086"];
856 [label="_lazyImportInfos 350087"];
857 [label="_conversions 350088"];
858 [label="_anonymousTypeManager 350089"];
859 [label="_lazyGlobalNamespace 350090"];
860 [label="builtInOperators 350091"];
861 [label="_lazyAssemblySymbol 350092"];
862 [label="_referenceManager 350093"];
863 [label="_syntaxAndDeclarations 350094"];
864 [label="_lazyEntryPoint 350095"];
865 [label="_lazyEmitNullablePublicOnly 350096"];
866 [label="_lazyCompilationUnitCompletedTrees 350097"];
867 [label="NullableAnalysisData 350098"];
868 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 350099"];
869 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 350100"];
870 [label="_externAliasTargets 350101"];
871 [label="_moduleInitializerMethods 350102"];
872 [label="_binderFactories 350103"];
873 [label="_ignoreAccessibilityBinderFactories 350104"];
874 [label="_lazyDeclarationDiagnostics 350105"];
875 [label="_declarationDiagnosticsFrozen 350106"];
876 [label="new DiagnosticBag() 350107"];
877 [label="_additionalCodegenWarnings = new DiagnosticBag() 350108"];
878 [label="WellKnownMemberSignatureComparer 350109"];
879 [label="_lazyWellKnownTypes 350110"];
880 [label="_lazyWellKnownTypeMembers 350111"];
881 [label="_usesNullableAttributes 350112"];
882 [label="_needsGeneratedAttributes 350113"];
883 [label="_needsGeneratedAttributes_IsFrozen 350114"];
884 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 350115"];
885 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 350116"];
886 [label="new WellKnownMembersSignatureComparer(this) 350117"];
887 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 350118"];
888 [label="param WellKnownMembersSignatureComparer(this) 350119"];
889 [label="param WellKnownMembersSignatureComparer(this) 350120"];
890 [label="param SpecialMembersSignatureComparer(this) 350121"];
891 [label="param SpecialMembersSignatureComparer(this) 350122"];
892 [label="_compilation 350123"];
893 [label="_compilation 350124"];
894 [label="WellKnownMemberSignatureComparer 350125"];
895 [label="this.builtInOperators = new BuiltInOperators(this); 350126"];
896 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 350127"];
897 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 350128"];
898 [label="new AnonymousTypeManager(this) 350129"];
899 [label="param AnonymousTypeManager(CSharpCompilation compilation) 350130"];
900 [label="param AnonymousTypeManager(this) 350131"];
901 [label="param AnonymousTypeManager(this) 350132"];
902 [label="public CSharpCompilation Compilation { get; } 350133"];
903 [label="_lazyAnonymousTypeTemplates 350134"];
904 [label="_lazySynthesizedDelegates 350135"];
905 [label="new ConcurrentDictionary<Location, bool>() 350136"];
906 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 350137"];
907 [label="Debug.Assert(compilation != null); 350138"];
908 [label="Debug.Assert(compilation != null); 350139"];
909 [label="this.Compilation 350140"];
910 [label="_anonymousTypeManager 350141"];
911 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 350142"];
912 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 350143"];
913 [label="LanguageVersion? result = null; 350144"];
914 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 350145"];
915 [label="var version = ((CSharpParseOptions)tree.Options).LanguageVersion; 350146"];
916 [label="if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                } 350147"];
917 [label="result = version; 350148"];
918 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 350149"];
919 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 350150"];
920 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 350151"];
921 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 350152"];
922 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 350153"];
923 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 350154"];
924 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 350155"];
925 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 350156"];
926 [label="referenceManager.AssertCanReuseForCompilation(this); 350157"];
927 [label="referenceManager.AssertCanReuseForCompilation(this); 350158"];
928 [label="_referenceManager 350159"];
929 [label="Debug.Assert(_lazyAssemblySymbol is null); 350160"];
930 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 350161"];
931 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 350162"];
932 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 350163"];
933 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 350164"];
934 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 350165"];
935 [label="return compilation; 350166"];
936 [label="var compilation = createCompilationLambda(); 350167"];
937 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 350168"];
938 [label="IsNullableEnabled(compilation) 350169"];
939 [label="param IsNullableEnabled(CSharpCompilation compilation) 350170"];
940 [label="compilation.SyntaxTrees 350171"];
941 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 350172"];
942 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 350173"];
943 [label="var trees = compilation.SyntaxTrees; 350174"];
944 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 350175"];
945 [label="var options = (CSharpParseOptions)trees[0].Options; 350176"];
946 [label="var options = (CSharpParseOptions)trees[0].Options; 350177"];
947 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 350178"];
948 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 350179"];
949 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 350180"];
950 [label="return compilation; 350181"];
951 [label="comp.GlobalNamespace 350182"];
952 [label="get\n            {\n                if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                }\n\n                return _lazyGlobalNamespace;\n            } 350183"];
953 [label="if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                } 350184"];
954 [label="var modules = ArrayBuilder<ModuleSymbol>.GetInstance(); 350185"];
955 [label="GetAllUnaliasedModules(modules); 350186"];
956 [label="GetAllUnaliasedModules(modules) 350187"];
957 [label="param GetAllUnaliasedModules(ArrayBuilder<ModuleSymbol> modules) 350188"];
958 [label="param GetAllUnaliasedModules(this) 350189"];
959 [label="Assembly 350190"];
960 [label="get\n            {\n                return SourceAssembly;\n            } 350191"];
961 [label="SourceAssembly 350192"];
962 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 350193"];
963 [label="GetBoundReferenceManager() 350194"];
964 [label="param GetBoundReferenceManager(this) 350195"];
965 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 350196"];
966 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 350197"];
967 [label="_referenceManager.CreateSourceAssemblyForCompilation(this) 350198"];
968 [label="param CreateSourceAssemblyForCompilation(CSharpCompilation compilation) 350199"];
969 [label="param CreateSourceAssemblyForCompilation(this) 350200"];
970 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 350201"];
971 [label="CreateAndSetSourceAssemblyFullBind(compilation) 350202"];
972 [label="param CreateAndSetSourceAssemblyFullBind(CSharpCompilation compilation) 350203"];
973 [label="param CreateAndSetSourceAssemblyFullBind(this) 350204"];
974 [label="var resolutionDiagnostics = DiagnosticBag.GetInstance(); 350205"];
975 [label="var assemblyReferencesBySimpleName = PooledDictionary<string, List<ReferencedAssemblyIdentity>>.GetInstance(); 350206"];
976 [label="compilation.Options 350207"];
977 [label="get\n            {\n                return _options;\n            } 350208"];
978 [label="bool supersedeLowerVersions = compilation.Options.ReferencesSupersedeLowerVersions; 350209"];
979 [label="IDictionary<(string, string), MetadataReference>? boundReferenceDirectiveMap; 350210"];
980 [label="ImmutableArray<MetadataReference> boundReferenceDirectives; 350211"];
981 [label="boundReferenceDirectives 350212"];
982 [label="ImmutableArray<AssemblyData> referencedAssemblies; 350213"];
983 [label="referencedAssemblies 350214"];
984 [label="ImmutableArray<PEModule> modules; 350215"];
985 [label="modules 350216"];
986 [label="ImmutableArray<MetadataReference> explicitReferences; 350217"];
987 [label="explicitReferences 350218"];
988 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 350219"];
989 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 350220"];
990 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 350221"];
991 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 350222"];
992 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 350223"];
993 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 350224"];
994 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 350225"];
995 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 350226"];
996 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 350227"];
997 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 350228"];
998 [label="get { return this.Declarations.ReferenceDirectives; } 350229"];
999 [label="this.Declarations 350230"];
1000 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 350231"];
1001 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 350232"];
1002 [label="return this.Declarations.ReferenceDirectives; 350233"];
1003 [label="SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 350234"];
1004 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 350235"];
1005 [label="SymbolDisplayCompilerInternalOptions.None 350236"];
1006 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 350237"];
1007 [label="s_debuggerDisplayFormat =\n            SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 350238"];
1008 [label="this.Declarations.ReferenceDirectives 350239"];
1009 [label="param ReportErrorIfHasConstraints(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) 350240"];
1010 [label="param ReportErrorIfHasConstraints(DiagnosticBag diagnostics) 350241"];
1011 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 350242"];
1012 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 350243"];
1013 [label="param ToDeclarationModifiers(this SyntaxTokenList modifiers) 350244"];
1014 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 350245"];
1015 [label="var result = DeclarationModifiers.None; 350246"];
1016 [label="bool seenNoDuplicates = true; 350247"];
1017 [label="bool seenNoAccessibilityDuplicates = true; 350248"];
1018 [label="foreach (var modifier in modifiers)\n            {\n                DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind());\n\n                ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics);\n\n                result |= one;\n            } 350249"];
1019 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 350250"];
1020 [label="return result; 350251"];
1021 [label="return this.Declarations.ReferenceDirectives; 350252"];
1022 [label="return this.Declarations.ReferenceDirectives; 350253"];
1023 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 350254"];
1024 [label="foreach (var modifier in modifiers)\n            {\n                DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind());\n\n                ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics);\n\n                result |= one;\n            } 350255"];
1025 [label="get { return _options; } 350256"];
1026 [label="return _options; 350257"];
1027 [label="get { return CSharp.MessageProvider.Instance; } 350258"];
1028 [label="return CSharp.MessageProvider.Instance; 350259"];
1029 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 350260"];
1030 [label="param CreateAssemblyDataForFile(PEAssembly assembly) 350261"];
1031 [label="param CreateAssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 350262"];
1032 [label="param CreateAssemblyDataForFile(DocumentationProvider documentationProvider) 350263"];
1033 [label="param CreateAssemblyDataForFile(string sourceAssemblySimpleName) 350264"];
1034 [label="param CreateAssemblyDataForFile(MetadataImportOptions importOptions) 350265"];
1035 [label="param CreateAssemblyDataForFile(bool embedInteropTypes) 350266"];
1036 [label="param CreateAssemblyDataForFile(this) 350267"];
1037 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 350268"];
1038 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 350269"];
1039 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 350270"];
1040 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 350271"];
1041 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 350272"];
1042 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 350273"];
1043 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 350274"];
1044 [label="new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions) 350275"];
1045 [label="param AssemblyDataForFile(PEAssembly assembly) 350276"];
1046 [label="param AssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 350277"];
1047 [label="param AssemblyDataForFile(bool embedInteropTypes) 350278"];
1048 [label="param AssemblyDataForFile(DocumentationProvider documentationProvider) 350279"];
1049 [label="param AssemblyDataForFile(string sourceAssemblySimpleName) 350280"];
1050 [label="param AssemblyDataForFile(MetadataImportOptions compilationImportOptions) 350281"];
1051 [label="param AssemblyDataForFile(this) 350282"];
1052 [label="assembly.Identity 350283"];
1053 [label="assembly.AssemblyReferences 350284"];
1054 [label="embedInteropTypes 350285"];
1055 [label="param AssemblyDataForFile(this) 350286"];
1056 [label="param AssemblyDataForMetadataOrCompilation(AssemblyIdentity identity) 350287"];
1057 [label="param AssemblyDataForMetadataOrCompilation(ImmutableArray<AssemblyIdentity> referencedAssemblies) 350288"];
1058 [label="param AssemblyDataForMetadataOrCompilation(bool embedInteropTypes) 350289"];
1059 [label="param AssemblyDataForMetadataOrCompilation(this) 350290"];
1060 [label="param AssemblyDataForMetadataOrCompilation(this) 350291"];
1061 [label="_assemblies 350292"];
1062 [label="_identity 350293"];
1063 [label="_embedInteropTypes 350294"];
1064 [label="RoslynDebug.Assert(identity != null); 350295"];
1065 [label="RoslynDebug.Assert(identity != null); 350296"];
1066 [label="Debug.Assert(!referencedAssemblies.IsDefault); 350297"];
1067 [label="_embedInteropTypes 350298"];
1068 [label="_identity 350299"];
1069 [label="_referencedAssemblies 350300"];
1070 [label="Assembly 350301"];
1071 [label="CachedSymbols 350302"];
1072 [label="DocumentationProvider 350303"];
1073 [label="_compilationImportOptions 350304"];
1074 [label="_sourceAssemblySimpleName 350305"];
1075 [label="_internalsVisibleComputed 350306"];
1076 [label="_internalsPotentiallyVisibleToCompilation 350307"];
1077 [label="RoslynDebug.Assert(documentationProvider != null); 350308"];
1078 [label="RoslynDebug.Assert(documentationProvider != null); 350309"];
1079 [label="RoslynDebug.Assert(cachedSymbols != null); 350310"];
1080 [label="RoslynDebug.Assert(cachedSymbols != null); 350311"];
1081 [label="CachedSymbols 350312"];
1082 [label="Assembly 350313"];
1083 [label="DocumentationProvider 350314"];
1084 [label="_compilationImportOptions 350315"];
1085 [label="_sourceAssemblySimpleName 350316"];
1086 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 350317"];
1087 [label="RoslynDebug.Assert(identity != null); 350318"];
1088 [label="Debug.Assert(!referencedAssemblies.IsDefault); 350319"];
1089 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 350320"];
1090 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 350321"];
1091 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 350322"];
1092 [label="get\n                    {\n                        return _identity;\n                    } 350323"];
1093 [label="return _identity; 350324"];
1094 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 350325"];
1095 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 350326"];
1096 [label="bool hasCircularReference; 350327"];
1097 [label="int corLibraryIndex; 350328"];
1098 [label="ImmutableArray<MetadataReference> implicitlyResolvedReferences; 350329"];
1099 [label="implicitlyResolvedReferences 350330"];
1100 [label="ImmutableArray<ResolvedReference> implicitlyResolvedReferenceMap; 350331"];
1101 [label="implicitlyResolvedReferenceMap 350332"];
1102 [label="ImmutableArray<AssemblyData> allAssemblyData; 350333"];
1103 [label="allAssemblyData 350334"];
1104 [label="var temp1 = compilation.ScriptCompilationInfo; 350335"];
1105 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 350336"];
1106 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 350337"];
1107 [label="temp1 != null 350338"];
1108 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 350339"];
1109 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 350340"];
1110 [label="temp2 != null 350341"];
1111 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 350342"];
1112 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 350343"];
1113 [label="temp3 != null 350344"];
1114 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 350345"];
1115 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 350346"];
1116 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350347"];
1117 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350348"];
1118 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350349"];
1119 [label="compilation.Options 350350"];
1120 [label="get\n            {\n                return _options;\n            } 350351"];
1121 [label="return _options; 350352"];
1122 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350353"];
1123 [label="compilation.Options 350354"];
1124 [label="get\n            {\n                return _options;\n            } 350355"];
1125 [label="return _options; 350356"];
1126 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350357"];
1127 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350358"];
1128 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350359"];
1129 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350360"];
1130 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350361"];
1131 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350362"];
1132 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350363"];
1133 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350364"];
1134 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350365"];
1135 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350366"];
1136 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350367"];
1137 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 350368"];
1138 [label="param BindAssemblyReferences(ImmutableArray<AssemblyData> assemblies) 350369"];
1139 [label="param BindAssemblyReferences(AssemblyIdentityComparer assemblyIdentityComparer) 350370"];
1140 [label="param BindAssemblyReferences(this) 350371"];
1141 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 350372"];
1142 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 350373"];
1143 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 350374"];
1144 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 350375"];
1145 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 350376"];
1146 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 350377"];
1147 [label="return _embedInteropTypes; 350378"];
1148 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 350379"];
1149 [label="return _referencedAssemblies; 350380"];
1150 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 350381"];
1151 [label="return Assembly.ContainsNoPiaLocalTypes(); 350382"];
1152 [label="get\n                    {\n                        return Assembly.DeclaresTheObjectClass;\n                    } 350383"];
1153 [label="return Assembly.DeclaresTheObjectClass; 350384"];
1154 [label="get\n                    {\n                        if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        }\n\n                        return _assemblies;\n                    } 350385"];
1155 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 350386"];
1156 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 350387"];
1157 [label="_assemblies = new List<AssemblySymbol>(); 350388"];
1158 [label="_assemblies 350389"];
1159 [label="AddAvailableSymbols(_assemblies); 350390"];
1160 [label="AddAvailableSymbols(_assemblies) 350391"];
1161 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 350392"];
1162 [label="param AddAvailableSymbols(this) 350393"];
1163 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 350394"];
1164 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 350395"];
1165 [label="AddAvailableSymbols(_assemblies); 350396"];
1166 [label="return _assemblies; 350397"];
1167 [label="AddAvailableSymbols(_assemblies); 350398"];
1168 [label="AddAvailableSymbols(_assemblies) 350399"];
1169 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 350400"];
1170 [label="param AddAvailableSymbols(this) 350401"];
1171 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 350402"];
1172 [label="AddAvailableSymbols(_assemblies); 350403"];
1173 [label="Debug.Assert(bindingResult.Length == allAssemblyData.Length); 350404"];
1174 [label="var references = explicitReferences.AddRange(implicitlyResolvedReferences); 350405"];
1175 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 350406"];
1176 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 350407"];
1177 [label="Dictionary<MetadataReference, int> referencedAssembliesMap, referencedModulesMap; 350408"];
1178 [label="ImmutableArray<ImmutableArray<string>> aliasesOfReferencedAssemblies; 350409"];
1179 [label="aliasesOfReferencedAssemblies 350410"];
1180 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 350411"];
1181 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 350412"];
1182 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 350413"];
1183 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 350414"];
1184 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 350415"];
1185 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 350416"];
1186 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 350417"];
1187 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 350418"];
1188 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 350419"];
1189 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 350420"];
1190 [label="var newSymbols = new List<int>(); 350421"];
1191 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 350422"];
1192 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 350423"];
1193 [label="ref BoundInputAssembly bound = ref bindingResult[i]; 350424"];
1194 [label="if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        } 350425"];
1195 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 350426"];
1196 [label="((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol() 350427"];
1197 [label="param CreateAssemblySymbol(this) 350428"];
1198 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 350429"];
1199 [label="this.IsLinked 350430"];
1200 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 350431"];
1201 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 350432"];
1202 [label="this.EffectiveImportOptions 350433"];
1203 [label="get\n                    {\n                        // We need to import internal members if they might be visible to the compilation being compiled:\n                        if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        }\n\n                        return _compilationImportOptions;\n                    } 350434"];
1204 [label="InternalsMayBeVisibleToCompilation 350435"];
1205 [label="get\n                    {\n                        if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        }\n\n                        return _internalsPotentiallyVisibleToCompilation;\n                    } 350436"];
1206 [label="if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        } 350437"];
1207 [label="_internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly); 350438"];
1208 [label="_internalsPotentiallyVisibleToCompilation 350439"];
1209 [label="_internalsVisibleComputed = true; 350440"];
1210 [label="_internalsVisibleComputed 350441"];
1211 [label="return _internalsPotentiallyVisibleToCompilation; 350442"];
1212 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 350443"];
1213 [label="return _compilationImportOptions; 350444"];
1214 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 350445"];
1215 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 350446"];
1216 [label="new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions) 350447"];
1217 [label="param PEAssemblySymbol(PEAssembly assembly) 350448"];
1218 [label="param PEAssemblySymbol(DocumentationProvider documentationProvider) 350449"];
1219 [label="param PEAssemblySymbol(bool isLinked) 350450"];
1220 [label="param PEAssemblySymbol(MetadataImportOptions importOptions) 350451"];
1221 [label="param PEAssemblySymbol(this) 350452"];
1222 [label="param PEAssemblySymbol(this) 350453"];
1223 [label="param MetadataOrSourceAssemblySymbol(this) 350454"];
1224 [label="param MetadataOrSourceAssemblySymbol(this) 350455"];
1225 [label="param NonMissingAssemblySymbol(this) 350456"];
1226 [label="new char[] { '+' } 350457"];
1227 [label="'+' 350458"];
1228 [label="new char[] { '+' } 350459"];
1229 [label="s_nestedTypeNameSeparators = new char[] { '+' } 350460"];
1230 [label="param NonMissingAssemblySymbol(this) 350461"];
1231 [label="param AssemblySymbol(this) 350462"];
1232 [label="param AssemblySymbol(this) 350463"];
1233 [label="param Symbol(this) 350464"];
1234 [label="_lazyISymbol 350465"];
1235 [label="_corLibrary 350466"];
1236 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 350467"];
1237 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 350468"];
1238 [label="_globalNamespace 350469"];
1239 [label="_lazySpecialTypes 350470"];
1240 [label="_cachedSpecialTypes 350471"];
1241 [label="_lazyNativeIntegerTypes 350472"];
1242 [label="_lazyTypeNames 350473"];
1243 [label="_lazyNamespaceNames 350474"];
1244 [label="_lazySpecialTypeMembers 350475"];
1245 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 350476"];
1246 [label="_assembly 350477"];
1247 [label="_documentationProvider 350478"];
1248 [label="_isLinked 350479"];
1249 [label="Debug.Assert(assembly != null); 350480"];
1250 [label="Debug.Assert(assembly != null); 350481"];
1251 [label="Debug.Assert(documentationProvider != null); 350482"];
1252 [label="Debug.Assert(documentationProvider != null); 350483"];
1253 [label="_assembly 350484"];
1254 [label="_documentationProvider 350485"];
1255 [label="var modules = new ModuleSymbol[assembly.Modules.Length]; 350486"];
1256 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 350487"];
1257 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 350488"];
1258 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 350489"];
1259 [label="31 350490"];
1260 [label="DefaultTypeMapCapacity = 31 350491"];
1261 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 350492"];
1262 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 350493"];
1263 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 350494"];
1264 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 350495"];
1265 [label="new PEModuleSymbol(this, assembly.Modules[i], importOptions, i) 350496"];
1266 [label="param PEModuleSymbol(PEAssemblySymbol assemblySymbol) 350497"];
1267 [label="param PEModuleSymbol(PEModule module) 350498"];
1268 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 350499"];
1269 [label="param PEModuleSymbol(int ordinal) 350500"];
1270 [label="param PEModuleSymbol(this) 350501"];
1271 [label="assemblySymbol 350502"];
1272 [label="module 350503"];
1273 [label="importOptions 350504"];
1274 [label="ordinal 350505"];
1275 [label="param PEModuleSymbol(this) 350506"];
1276 [label="param PEModuleSymbol(AssemblySymbol assemblySymbol) 350507"];
1277 [label="param PEModuleSymbol(PEModule module) 350508"];
1278 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 350509"];
1279 [label="param PEModuleSymbol(int ordinal) 350510"];
1280 [label="param PEModuleSymbol(this) 350511"];
1281 [label="param PEModuleSymbol(this) 350512"];
1282 [label="param NonMissingModuleSymbol(this) 350513"];
1283 [label="param NonMissingModuleSymbol(this) 350514"];
1284 [label="param ModuleSymbol(this) 350515"];
1285 [label="param ModuleSymbol(this) 350516"];
1286 [label="param Symbol(this) 350517"];
1287 [label="_lazyISymbol 350518"];
1288 [label="_moduleReferences 350519"];
1289 [label="_assemblySymbol 350520"];
1290 [label="_ordinal 350521"];
1291 [label="_module 350522"];
1292 [label="_globalNamespace 350523"];
1293 [label="_lazySystemTypeSymbol 350524"];
1294 [label="_lazyEventRegistrationTokenSymbol 350525"];
1295 [label="_lazyEventRegistrationTokenTableSymbol 350526"];
1296 [label="2 350527"];
1297 [label="concurrencyLevel: 2 350528"];
1298 [label="capacity: DefaultTypeMapCapacity 350529"];
1299 [label="new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 350530"];
1300 [label="TypeHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 350531"];
1301 [label="2 350532"];
1302 [label="concurrencyLevel: 2 350533"];
1303 [label="capacity: DefaultTypeMapCapacity 350534"];
1304 [label="new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 350535"];
1305 [label="TypeRefHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 350536"];
1306 [label="ImportOptions 350537"];
1307 [label="_lazyTypeNames 350538"];
1308 [label="_lazyNamespaceNames 350539"];
1309 [label="_lazyNullableMemberMetadata 350540"];
1310 [label="Debug.Assert((object)assemblySymbol != null); 350541"];
1311 [label="Debug.Assert((object)assemblySymbol != null); 350542"];
1312 [label="Debug.Assert(module != null); 350543"];
1313 [label="Debug.Assert(module != null); 350544"];
1314 [label="_assemblySymbol 350545"];
1315 [label="_ordinal 350546"];
1316 [label="_module 350547"];
1317 [label="this.ImportOptions 350548"];
1318 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 350549"];
1319 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 350550"];
1320 [label="new PEGlobalNamespaceSymbol(this) 350551"];
1321 [label="param PEGlobalNamespaceSymbol(PEModuleSymbol moduleSymbol) 350552"];
1322 [label="param PEGlobalNamespaceSymbol(this) 350553"];
1323 [label="param PEGlobalNamespaceSymbol(this) 350554"];
1324 [label="param PENamespaceSymbol(this) 350555"];
1325 [label="param PENamespaceSymbol(this) 350556"];
1326 [label="param NamespaceSymbol(this) 350557"];
1327 [label="param NamespaceSymbol(this) 350558"];
1328 [label="param NamespaceOrTypeSymbol(this) 350559"];
1329 [label="param NamespaceOrTypeSymbol(this) 350560"];
1330 [label="param Symbol(this) 350561"];
1331 [label="_lazyISymbol 350562"];
1332 [label="_lazyAdapter 350563"];
1333 [label="_lazyQualifiedName 350564"];
1334 [label="lazyNamespaces 350565"];
1335 [label="lazyTypes 350566"];
1336 [label="_lazyNoPiaLocalTypes 350567"];
1337 [label="_moduleSymbol 350568"];
1338 [label="Debug.Assert((object)moduleSymbol != null); 350569"];
1339 [label="Debug.Assert((object)moduleSymbol != null); 350570"];
1340 [label="_moduleSymbol 350571"];
1341 [label="_globalNamespace 350572"];
1342 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 350573"];
1343 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 350574"];
1344 [label="this.MetadataLocation 350575"];
1345 [label="Debug.Assert(ordinal >= 0); 350576"];
1346 [label="Debug.Assert(ordinal >= 0); 350577"];
1347 [label="modules[i] 350578"];
1348 [label="_modules = modules.AsImmutableOrNull(); 350579"];
1349 [label="_modules = modules.AsImmutableOrNull(); 350580"];
1350 [label="_modules 350581"];
1351 [label="_isLinked 350582"];
1352 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 350583"];
1353 [label="bound.AssemblySymbol 350584"];
1354 [label="newSymbols.Add(i); 350585"];
1355 [label="newSymbols.Add(i); 350586"];
1356 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 350587"];
1357 [label="allAssemblyData[i].IsLinked 350588"];
1358 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 350589"];
1359 [label="bound.AssemblySymbol.IsLinked 350590"];
1360 [label="get\n            {\n                return _isLinked;\n            } 350591"];
1361 [label="return _isLinked; 350592"];
1362 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 350593"];
1363 [label="return _internalsPotentiallyVisibleToCompilation; 350594"];
1364 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 350595"];
1365 [label="_assembly 350596"];
1366 [label="_documentationProvider 350597"];
1367 [label="Debug.Assert(assembly != null); 350598"];
1368 [label="Debug.Assert(documentationProvider != null); 350599"];
1369 [label="_assemblySymbol 350600"];
1370 [label="_ordinal 350601"];
1371 [label="_module 350602"];
1372 [label="_globalNamespace 350603"];
1373 [label="ImportOptions 350604"];
1374 [label="Debug.Assert((object)assemblySymbol != null); 350605"];
1375 [label="Debug.Assert(module != null); 350606"];
1376 [label="_moduleSymbol 350607"];
1377 [label="Debug.Assert((object)moduleSymbol != null); 350608"];
1378 [label="Debug.Assert(ordinal >= 0); 350609"];
1379 [label="bound.AssemblySymbol 350610"];
1380 [label="newSymbols.Add(i); 350611"];
1381 [label="newSymbols.Add(i); 350612"];
1382 [label="allAssemblyData[i].IsLinked 350613"];
1383 [label="bound.AssemblySymbol.IsLinked 350614"];
1384 [label="get\n            {\n                return _isLinked;\n            } 350615"];
1385 [label="return _isLinked; 350616"];
1386 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 350617"];
1387 [label="_assembly 350618"];
1388 [label="_documentationProvider 350619"];
1389 [label="_assemblySymbol 350620"];
1390 [label="_ordinal 350621"];
1391 [label="_module 350622"];
1392 [label="_globalNamespace 350623"];
1393 [label="ImportOptions 350624"];
1394 [label="Debug.Assert((object)assemblySymbol != null); 350625"];
1395 [label="Debug.Assert(module != null); 350626"];
1396 [label="_moduleSymbol 350627"];
1397 [label="Debug.Assert((object)moduleSymbol != null); 350628"];
1398 [label="Debug.Assert(ordinal >= 0); 350629"];
1399 [label="bound.AssemblySymbol 350630"];
1400 [label="newSymbols.Add(i); 350631"];
1401 [label="get\n            {\n                return _isLinked;\n            } 350632"];
1402 [label="return _isLinked; 350633"];
1403 [label="return _internalsPotentiallyVisibleToCompilation; 350634"];
1404 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 350635"];
1405 [label="_assembly 350636"];
1406 [label="_documentationProvider 350637"];
1407 [label="Debug.Assert(assembly != null); 350638"];
1408 [label="Debug.Assert(documentationProvider != null); 350639"];
1409 [label="Debug.Assert(ordinal >= 0); 350640"];
1410 [label="bound.AssemblySymbol 350641"];
1411 [label="newSymbols.Add(i); 350642"];
1412 [label="newSymbols.Add(i); 350643"];
1413 [label="bound.AssemblySymbol.IsLinked 350644"];
1414 [label="get\n            {\n                return _isLinked;\n            } 350645"];
1415 [label="return _isLinked; 350646"];
1416 [label="newSymbols.Add(i); 350647"];
1417 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 350648"];
1418 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 350649"];
1419 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 350650"];
1420 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 350651"];
1421 [label="t_assemblyForWhichCurrentThreadIsComputingKeys 350652"];
1422 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 350653"];
1423 [label="new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules) 350654"];
1424 [label="param SourceAssemblySymbol(CSharpCompilation compilation) 350655"];
1425 [label="param SourceAssemblySymbol(string assemblySimpleName) 350656"];
1426 [label="param SourceAssemblySymbol(string moduleName) 350657"];
1427 [label="param SourceAssemblySymbol(ImmutableArray<PEModule> netModules) 350658"];
1428 [label="param SourceAssemblySymbol(this) 350659"];
1429 [label="param SourceAssemblySymbol(this) 350660"];
1430 [label="param MetadataOrSourceAssemblySymbol(this) 350661"];
1431 [label="param MetadataOrSourceAssemblySymbol(this) 350662"];
1432 [label="param NonMissingAssemblySymbol(this) 350663"];
1433 [label="param NonMissingAssemblySymbol(this) 350664"];
1434 [label="param AssemblySymbol(this) 350665"];
1435 [label="param AssemblySymbol(this) 350666"];
1436 [label="param Symbol(this) 350667"];
1437 [label="_lazyISymbol 350668"];
1438 [label="_corLibrary 350669"];
1439 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 350670"];
1440 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 350671"];
1441 [label="_globalNamespace 350672"];
1442 [label="_lazySpecialTypes 350673"];
1443 [label="_cachedSpecialTypes 350674"];
1444 [label="_lazyNativeIntegerTypes 350675"];
1445 [label="_lazyTypeNames 350676"];
1446 [label="_lazyNamespaceNames 350677"];
1447 [label="_lazySpecialTypeMembers 350678"];
1448 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 350679"];
1449 [label="_compilation 350680"];
1450 [label="lazyAssemblyIdentity 350681"];
1451 [label="_assemblySimpleName 350682"];
1452 [label="_lazyStrongNameKeys 350683"];
1453 [label="_lazySourceAttributesBag 350684"];
1454 [label="_lazyNetModuleAttributesBag 350685"];
1455 [label="_lazyForwardedTypesFromSource 350686"];
1456 [label="_lazyOmittedAttributeIndices 350687"];
1457 [label="_lazyContainsExtensionMethods 350688"];
1458 [label="new ConcurrentDictionary<FieldSymbol, bool>() 350689"];
1459 [label="_unassignedFieldsMap = new ConcurrentDictionary<FieldSymbol, bool>() 350690"];
1460 [label="new ConcurrentSet<FieldSymbol>() 350691"];
1461 [label="_unreadFields = new ConcurrentSet<FieldSymbol>() 350692"];
1462 [label="new ConcurrentSet<TypeSymbol>() 350693"];
1463 [label="TypesReferencedInExternalMethods = new ConcurrentSet<TypeSymbol>() 350694"];
1464 [label="_optimisticallyGrantedInternalsAccess 350695"];
1465 [label="_lazyInternalsVisibleToMap 350696"];
1466 [label="Debug.Assert(compilation != null); 350697"];
1467 [label="Debug.Assert(compilation != null); 350698"];
1468 [label="Debug.Assert(assemblySimpleName != null); 350699"];
1469 [label="Debug.Assert(assemblySimpleName != null); 350700"];
1470 [label="Debug.Assert(!String.IsNullOrWhiteSpace(moduleName)); 350701"];
1471 [label="Debug.Assert(!netModules.IsDefault); 350702"];
1472 [label="_compilation 350703"];
1473 [label="_assemblySimpleName 350704"];
1474 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 350705"];
1475 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 350706"];
1476 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 350707"];
1477 [label="compilation.Declarations 350708"];
1478 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 350709"];
1479 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 350710"];
1480 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 350711"];
1481 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 350712"];
1482 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 350713"];
1483 [label="new SourceModuleSymbol(this, compilation.Declarations, moduleName) 350714"];
1484 [label="param SourceModuleSymbol(SourceAssemblySymbol assemblySymbol) 350715"];
1485 [label="param SourceModuleSymbol(DeclarationTable declarations) 350716"];
1486 [label="param SourceModuleSymbol(string moduleName) 350717"];
1487 [label="param SourceModuleSymbol(this) 350718"];
1488 [label="param SourceModuleSymbol(this) 350719"];
1489 [label="param NonMissingModuleSymbol(this) 350720"];
1490 [label="param NonMissingModuleSymbol(this) 350721"];
1491 [label="param ModuleSymbol(this) 350722"];
1492 [label="param ModuleSymbol(this) 350723"];
1493 [label="param Symbol(this) 350724"];
1494 [label="_lazyISymbol 350725"];
1495 [label="_moduleReferences 350726"];
1496 [label="_assemblySymbol 350727"];
1497 [label="_lazyContainsExplicitDefinitionOfNoPiaLocalTypes = ThreeState.Unknown 350728"];
1498 [label="_sources 350729"];
1499 [label="_lazyCustomAttributesBag 350730"];
1500 [label="_globalNamespace 350731"];
1501 [label="_hasBadAttributes 350732"];
1502 [label="_name 350733"];
1503 [label="Debug.Assert((object)assemblySymbol != null); 350734"];
1504 [label="Debug.Assert((object)assemblySymbol != null); 350735"];
1505 [label="_assemblySymbol 350736"];
1506 [label="_sources 350737"];
1507 [label="_name 350738"];
1508 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 350739"];
1509 [label="compilation.Options 350740"];
1510 [label="get\n            {\n                return _options;\n            } 350741"];
1511 [label="return _options; 350742"];
1512 [label="var importOptions = (compilation.Options.MetadataImportOptions == MetadataImportOptions.All) ?\n                MetadataImportOptions.All : MetadataImportOptions.Internal; 350743"];
1513 [label="(compilation.Options.MetadataImportOptions == MetadataImportOptions.All) 350744"];
1514 [label="foreach (PEModule netModule in netModules)\n            {\n                moduleBuilder.Add(new PEModuleSymbol(this, netModule, importOptions, moduleBuilder.Count));\n                // SetReferences will be called later by the ReferenceManager (in CreateSourceAssemblyFullBind for \n                // a fresh manager, in CreateSourceAssemblyReuseData for a reused one).\n            } 350745"];
1515 [label="_modules = moduleBuilder.ToImmutableAndFree(); 350746"];
1516 [label="_modules 350747"];
1517 [label="compilation.Options 350748"];
1518 [label="get\n            {\n                return _options;\n            } 350749"];
1519 [label="return _options; 350750"];
1520 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 350751"];
1521 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 350752"];
1522 [label="AssemblySymbol? corLibrary; 350753"];
1523 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 350754"];
1524 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 350755"];
1525 [label="if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 350756"];
1526 [label="corLibrary = bindingResult[corLibraryIndex].AssemblySymbol; 350757"];
1527 [label="assemblySymbol.SetCorLibrary(corLibrary); 350758"];
1528 [label="assemblySymbol.SetCorLibrary(corLibrary) 350759"];
1529 [label="param SetCorLibrary(AssemblySymbol corLibrary) 350760"];
1530 [label="param SetCorLibrary(this) 350761"];
1531 [label="Debug.Assert((object)_corLibrary == null); 350762"];
1532 [label="Debug.Assert((object)_corLibrary == null); 350763"];
1533 [label="_corLibrary 350764"];
1534 [label="assemblySymbol.SetCorLibrary(corLibrary); 350765"];
1535 [label="Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies = null; 350766"];
1536 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 350767"];
1537 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 350768"];
1538 [label="ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences; 350769"];
1539 [label="moduleReferences 350770"];
1540 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 350771"];
1541 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 350772"];
1542 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 350773"];
1543 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 350774"];
1544 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 350775"];
1545 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 350776"];
1546 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences) 350777"];
1547 [label="param SetupReferencesForSourceAssembly(SourceAssemblySymbol sourceAssembly) 350778"];
1548 [label="param SetupReferencesForSourceAssembly(ImmutableArray<PEModule> modules) 350779"];
1549 [label="param SetupReferencesForSourceAssembly(int totalReferencedAssemblyCount) 350780"];
1550 [label="param SetupReferencesForSourceAssembly(BoundInputAssembly[] bindingResult) 350781"];
1551 [label="param SetupReferencesForSourceAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 350782"];
1552 [label="param SetupReferencesForSourceAssembly(out ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences) 350783"];
1553 [label="sourceAssembly.Modules 350784"];
1554 [label="get\n            {\n                return _modules;\n            } 350785"];
1555 [label="return _modules; 350786"];
1556 [label="var moduleSymbols = sourceAssembly.Modules; 350787"];
1557 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 350788"];
1558 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 350789"];
1559 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 350790"];
1560 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 350791"];
1561 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 350792"];
1562 [label="(moduleSymbols.Length > 1) 350793"];
1563 [label="int refsUsed = 0; 350794"];
1564 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 350795"];
1565 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 350796"];
1566 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 350797"];
1567 [label="(moduleIndex == 0) 350798"];
1568 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 350799"];
1569 [label="var identities = new AssemblyIdentity[refsCount]; 350800"];
1570 [label="var symbols = new AssemblySymbol[refsCount]; 350801"];
1571 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 350802"];
1572 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 350803"];
1573 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 350804"];
1574 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 350805"];
1575 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 350806"];
1576 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 350807"];
1577 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 350808"];
1578 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 350809"];
1579 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 350810"];
1580 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 350811"];
1581 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 350812"];
1582 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 350813"];
1583 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 350814"];
1584 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 350815"];
1585 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 350816"];
1586 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 350817"];
1587 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 350818"];
1588 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 350819"];
1589 [label="Debug.Assert(referenceBinding.IsBound); 350820"];
1590 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 350821"];
1591 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 350822"];
1592 [label="Debug.Assert(assembly is object); 350823"];
1593 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 350824"];
1594 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 350825"];
1595 [label="return assembly; 350826"];
1596 [label="symbols[k] 350827"];
1597 [label="identities[k] 350828"];
1598 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 350829"];
1599 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 350830"];
1600 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 350831"];
1601 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 350832"];
1602 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 350833"];
1603 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 350834"];
1604 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 350835"];
1605 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 350836"];
1606 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 350837"];
1607 [label="Debug.Assert(referenceBinding.IsBound); 350838"];
1608 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 350839"];
1609 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 350840"];
1610 [label="Debug.Assert(assembly is object); 350841"];
1611 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 350842"];
1612 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 350843"];
1613 [label="return assembly; 350844"];
1614 [label="symbols[k] 350845"];
1615 [label="identities[k] 350846"];
1616 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 350847"];
1617 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 350848"];
1618 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 350849"];
1619 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 350850"];
1620 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 350851"];
1621 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 350852"];
1622 [label="if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    } 350853"];
1623 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 350854"];
1624 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 350855"];
1625 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 350856"];
1626 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly) 350857"];
1627 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 350858"];
1628 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 350859"];
1629 [label="param SetReferences(this) 350860"];
1630 [label="Debug.Assert(moduleReferences != null); 350861"];
1631 [label="Debug.Assert(moduleReferences != null); 350862"];
1632 [label="AssertReferencesUninitialized() 350863"];
1633 [label="param AssertReferencesUninitialized(this) 350864"];
1634 [label="Debug.Assert(_moduleReferences == null); 350865"];
1635 [label="Debug.Assert(_moduleReferences == null); 350866"];
1636 [label="AssertReferencesUninitialized(); 350867"];
1637 [label="_moduleReferences 350868"];
1638 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 350869"];
1639 [label="refsUsed += refsCount; 350870"];
1640 [label="moduleReferences = moduleReferencesBuilder.ToImmutableOrEmptyAndFree(); 350871"];
1641 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 350872"];
1642 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 350873"];
1643 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 350874"];
1644 [label="if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        } 350875"];
1645 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 350876"];
1646 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 350877"];
1647 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 350878"];
1648 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 350879"];
1649 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies) 350880"];
1650 [label="param InitializeNewSymbols(List<int> newSymbols) 350881"];
1651 [label="param InitializeNewSymbols(SourceAssemblySymbol sourceAssembly) 350882"];
1652 [label="param InitializeNewSymbols(ImmutableArray<AssemblyData> assemblies) 350883"];
1653 [label="param InitializeNewSymbols(BoundInputAssembly[] bindingResult) 350884"];
1654 [label="param InitializeNewSymbols(Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 350885"];
1655 [label="Debug.Assert(newSymbols.Count > 0); 350886"];
1656 [label="Debug.Assert(newSymbols.Count > 0); 350887"];
1657 [label="sourceAssembly.CorLibrary 350888"];
1658 [label="get\n            {\n                return _corLibrary;\n            } 350889"];
1659 [label="return _corLibrary; 350890"];
1660 [label="var corLibrary = sourceAssembly.CorLibrary; 350891"];
1661 [label="RoslynDebug.Assert((object)corLibrary != null); 350892"];
1662 [label="RoslynDebug.Assert((object)corLibrary != null); 350893"];
1663 [label="foreach (int i in newSymbols)\n                {\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n\n                    if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                } 350894"];
1664 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 350895"];
1665 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 350896"];
1666 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 350897"];
1667 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 350898"];
1668 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 350899"];
1669 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 350900"];
1670 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 350901"];
1671 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 350902"];
1672 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 350903"];
1673 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly) 350904"];
1674 [label="param SetupReferencesForFileAssembly(AssemblyDataForFile fileData) 350905"];
1675 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 350906"];
1676 [label="param SetupReferencesForFileAssembly(ref BoundInputAssembly currentBindingResult) 350907"];
1677 [label="param SetupReferencesForFileAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 350908"];
1678 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 350909"];
1679 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 350910"];
1680 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 350911"];
1681 [label="var portableExecutableAssemblySymbol = (PEAssemblySymbol)currentBindingResult.AssemblySymbol; 350912"];
1682 [label="portableExecutableAssemblySymbol.Modules 350913"];
1683 [label="get\n            {\n                return _modules;\n            } 350914"];
1684 [label="return _modules; 350915"];
1685 [label="ImmutableArray<ModuleSymbol> modules = portableExecutableAssemblySymbol.Modules; 350916"];
1686 [label="int moduleCount = modules.Length; 350917"];
1687 [label="int refsUsed = 0; 350918"];
1688 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 350919"];
1689 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 350920"];
1690 [label="int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j]; 350921"];
1691 [label="var identities = new AssemblyIdentity[moduleReferenceCount]; 350922"];
1692 [label="var symbols = new AssemblySymbol[moduleReferenceCount]; 350923"];
1693 [label="fileData.AssemblyReferences 350924"];
1694 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 350925"];
1695 [label="return _referencedAssemblies; 350926"];
1696 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 350927"];
1697 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 350928"];
1698 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 350929"];
1699 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 350930"];
1700 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 350931"];
1701 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 350932"];
1702 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 350933"];
1703 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 350934"];
1704 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 350935"];
1705 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 350936"];
1706 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 350937"];
1707 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 350938"];
1708 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 350939"];
1709 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 350940"];
1710 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 350941"];
1711 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 350942"];
1712 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 350943"];
1713 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly) 350944"];
1714 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 350945"];
1715 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 350946"];
1716 [label="param SetReferences(this) 350947"];
1717 [label="Debug.Assert(moduleReferences != null); 350948"];
1718 [label="Debug.Assert(moduleReferences != null); 350949"];
1719 [label="AssertReferencesUninitialized() 350950"];
1720 [label="param AssertReferencesUninitialized(this) 350951"];
1721 [label="Debug.Assert(_moduleReferences == null); 350952"];
1722 [label="Debug.Assert(_moduleReferences == null); 350953"];
1723 [label="AssertReferencesUninitialized(); 350954"];
1724 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 350955"];
1725 [label="refsUsed += moduleReferenceCount; 350956"];
1726 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 350957"];
1727 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 350958"];
1728 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 350959"];
1729 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 350960"];
1730 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 350961"];
1731 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 350962"];
1732 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 350963"];
1733 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 350964"];
1734 [label="var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k]; 350965"];
1735 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        } 350966"];
1736 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 350967"];
1737 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 350968"];
1738 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 350969"];
1739 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 350970"];
1740 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 350971"];
1741 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 350972"];
1742 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 350973"];
1743 [label="Debug.Assert(referenceBinding.IsBound); 350974"];
1744 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 350975"];
1745 [label="Debug.Assert(assembly is object); 350976"];
1746 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 350977"];
1747 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 350978"];
1748 [label="symbols[k] 350979"];
1749 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 350980"];
1750 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 350981"];
1751 [label="GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies) 350982"];
1752 [label="param GetOrAddMissingAssemblySymbol(AssemblyIdentity assemblyIdentity) 350983"];
1753 [label="param GetOrAddMissingAssemblySymbol(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 350984"];
1754 [label="MissingAssemblySymbol? missingAssembly; 350985"];
1755 [label="if (missingAssemblies == null)\n                {\n                    missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>();\n                }\n                else if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 350986"];
1756 [label="if (missingAssemblies == null)\n                {\n                    missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>();\n                }\n                else if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 350987"];
1757 [label="missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>(); 350988"];
1758 [label="missingAssembly = new MissingAssemblySymbol(assemblyIdentity); 350989"];
1759 [label="missingAssembly = new MissingAssemblySymbol(assemblyIdentity); 350990"];
1760 [label="new MissingAssemblySymbol(assemblyIdentity) 350991"];
1761 [label="param MissingAssemblySymbol(AssemblyIdentity identity) 350992"];
1762 [label="param MissingAssemblySymbol(this) 350993"];
1763 [label="param MissingAssemblySymbol(this) 350994"];
1764 [label="identity 350995"];
1765 [label="moduleSymbol 350996"];
1766 [label="Debug.Assert(identity != null); 350997"];
1767 [label="Debug.Assert(identity != null); 350998"];
1768 [label="this.identity 350999"];
1769 [label="moduleSymbol = new MissingModuleSymbol(this, 0); 351000"];
1770 [label="moduleSymbol = new MissingModuleSymbol(this, 0); 351001"];
1771 [label="new MissingModuleSymbol(this, 0) 351002"];
1772 [label="param MissingModuleSymbol(AssemblySymbol assembly) 351003"];
1773 [label="param MissingModuleSymbol(int ordinal) 351004"];
1774 [label="param MissingModuleSymbol(this) 351005"];
1775 [label="param MissingModuleSymbol(this) 351006"];
1776 [label="assembly 351007"];
1777 [label="ordinal 351008"];
1778 [label="globalNamespace 351009"];
1779 [label="Debug.Assert((object)assembly != null); 351010"];
1780 [label="Debug.Assert((object)assembly != null); 351011"];
1781 [label="Debug.Assert(ordinal >= -1); 351012"];
1782 [label="Debug.Assert(ordinal >= -1); 351013"];
1783 [label="this.assembly 351014"];
1784 [label="this.ordinal 351015"];
1785 [label="globalNamespace = new MissingNamespaceSymbol(this); 351016"];
1786 [label="globalNamespace = new MissingNamespaceSymbol(this); 351017"];
1787 [label="new MissingNamespaceSymbol(this) 351018"];
1788 [label="param MissingNamespaceSymbol(MissingModuleSymbol containingModule) 351019"];
1789 [label="param MissingNamespaceSymbol(this) 351020"];
1790 [label="param MissingNamespaceSymbol(this) 351021"];
1791 [label="_name 351022"];
1792 [label="_containingSymbol 351023"];
1793 [label="Debug.Assert((object)containingModule != null); 351024"];
1794 [label="Debug.Assert((object)containingModule != null); 351025"];
1795 [label="_containingSymbol 351026"];
1796 [label="_name 351027"];
1797 [label="globalNamespace 351028"];
1798 [label="moduleSymbol 351029"];
1799 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 351030"];
1800 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 351031"];
1801 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 351032"];
1802 [label="return missingAssembly; 351033"];
1803 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 351034"];
1804 [label="symbols[k] 351035"];
1805 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 351036"];
1806 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 351037"];
1807 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 351038"];
1808 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 351039"];
1809 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 351040"];
1810 [label="Debug.Assert(moduleReferences != null); 351041"];
1811 [label="Debug.Assert(moduleReferences != null); 351042"];
1812 [label="AssertReferencesUninitialized() 351043"];
1813 [label="param AssertReferencesUninitialized(this) 351044"];
1814 [label="Debug.Assert(_moduleReferences == null); 351045"];
1815 [label="Debug.Assert(_moduleReferences == null); 351046"];
1816 [label="AssertReferencesUninitialized(); 351047"];
1817 [label="refsUsed += moduleReferenceCount; 351048"];
1818 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 351049"];
1819 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 351050"];
1820 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 351051"];
1821 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 351052"];
1822 [label="Debug.Assert(referenceBinding.IsBound); 351053"];
1823 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 351054"];
1824 [label="Debug.Assert(assembly is object); 351055"];
1825 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 351056"];
1826 [label="return missingAssembly; 351057"];
1827 [label="identity 351058"];
1828 [label="moduleSymbol 351059"];
1829 [label="Debug.Assert(identity != null); 351060"];
1830 [label="Debug.Assert(identity != null); 351061"];
1831 [label="assembly 351062"];
1832 [label="ordinal 351063"];
1833 [label="globalNamespace 351064"];
1834 [label="Debug.Assert((object)assembly != null); 351065"];
1835 [label="Debug.Assert((object)assembly != null); 351066"];
1836 [label="Debug.Assert(ordinal >= -1); 351067"];
1837 [label="Debug.Assert(ordinal >= -1); 351068"];
1838 [label="_name 351069"];
1839 [label="_containingSymbol 351070"];
1840 [label="Debug.Assert((object)containingModule != null); 351071"];
1841 [label="Debug.Assert((object)containingModule != null); 351072"];
1842 [label="identity 351073"];
1843 [label="moduleSymbol 351074"];
1844 [label="Debug.Assert(identity != null); 351075"];
1845 [label="assembly 351076"];
1846 [label="ordinal 351077"];
1847 [label="globalNamespace 351078"];
1848 [label="Debug.Assert((object)assembly != null); 351079"];
1849 [label="Debug.Assert(ordinal >= -1); 351080"];
1850 [label="_name 351081"];
1851 [label="_containingSymbol 351082"];
1852 [label="Debug.Assert((object)containingModule != null); 351083"];
1853 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 351084"];
1854 [label="Debug.Assert(moduleReferences != null); 351085"];
1855 [label="Debug.Assert(moduleReferences != null); 351086"];
1856 [label="AssertReferencesUninitialized() 351087"];
1857 [label="param AssertReferencesUninitialized(this) 351088"];
1858 [label="Debug.Assert(_moduleReferences == null); 351089"];
1859 [label="Debug.Assert(_moduleReferences == null); 351090"];
1860 [label="AssertReferencesUninitialized(); 351091"];
1861 [label="refsUsed += moduleReferenceCount; 351092"];
1862 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 351093"];
1863 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 351094"];
1864 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 351095"];
1865 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 351096"];
1866 [label="Debug.Assert(referenceBinding.IsBound); 351097"];
1867 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 351098"];
1868 [label="Debug.Assert(assembly is object); 351099"];
1869 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 351100"];
1870 [label="if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    } 351101"];
1871 [label="unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>(); 351102"];
1872 [label="unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity)); 351103"];
1873 [label="unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity)); 351104"];
1874 [label="identity 351105"];
1875 [label="moduleSymbol 351106"];
1876 [label="Debug.Assert(identity != null); 351107"];
1877 [label="assembly 351108"];
1878 [label="ordinal 351109"];
1879 [label="globalNamespace 351110"];
1880 [label="Debug.Assert((object)assembly != null); 351111"];
1881 [label="Debug.Assert(ordinal >= -1); 351112"];
1882 [label="_name 351113"];
1883 [label="_containingSymbol 351114"];
1884 [label="Debug.Assert((object)containingModule != null); 351115"];
1885 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 351116"];
1886 [label="Debug.Assert(moduleReferences != null); 351117"];
1887 [label="Debug.Assert(moduleReferences != null); 351118"];
1888 [label="AssertReferencesUninitialized() 351119"];
1889 [label="param AssertReferencesUninitialized(this) 351120"];
1890 [label="Debug.Assert(_moduleReferences == null); 351121"];
1891 [label="Debug.Assert(_moduleReferences == null); 351122"];
1892 [label="AssertReferencesUninitialized(); 351123"];
1893 [label="refsUsed += moduleReferenceCount; 351124"];
1894 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 351125"];
1895 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 351126"];
1896 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 351127"];
1897 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 351128"];
1898 [label="Debug.Assert(referenceBinding.IsBound); 351129"];
1899 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 351130"];
1900 [label="Debug.Assert(assembly is object); 351131"];
1901 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 351132"];
1902 [label="Debug.Assert(moduleReferences != null); 351133"];
1903 [label="AssertReferencesUninitialized() 351134"];
1904 [label="param AssertReferencesUninitialized(this) 351135"];
1905 [label="Debug.Assert(_moduleReferences == null); 351136"];
1906 [label="Debug.Assert(_moduleReferences == null); 351137"];
1907 [label="AssertReferencesUninitialized(); 351138"];
1908 [label="refsUsed += moduleReferenceCount; 351139"];
1909 [label="var linkedReferencedAssembliesBuilder = ArrayBuilder<AssemblySymbol>.GetInstance(); 351140"];
1910 [label="sourceAssembly.Modules 351141"];
1911 [label="get\n            {\n                return _modules;\n            } 351142"];
1912 [label="return _modules; 351143"];
1913 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 351144"];
1914 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 351145"];
1915 [label="sourceAssembly.Modules[0].GetReferencedAssemblySymbols() 351146"];
1916 [label="param GetReferencedAssemblySymbols(this) 351147"];
1917 [label="AssertReferencesInitialized() 351148"];
1918 [label="param AssertReferencesInitialized(this) 351149"];
1919 [label="Debug.Assert(_moduleReferences != null); 351150"];
1920 [label="Debug.Assert(_moduleReferences != null); 351151"];
1921 [label="AssertReferencesInitialized(); 351152"];
1922 [label="return _moduleReferences.Symbols; 351153"];
1923 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly currentBindingResult = ref bindingResult[i];\n                    Debug.Assert(currentBindingResult.AssemblySymbol is object);\n                    Debug.Assert(currentBindingResult.ReferenceBinding is object);\n\n                    if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    }\n\n                    // Setup linked referenced assemblies.\n                    linkedReferencedAssembliesBuilder.Clear();\n\n                    if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    }\n\n                    foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    }\n\n                    if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    }\n\n                    currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary);\n                } 351154"];
1924 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 351155"];
1925 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 351156"];
1926 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 351157"];
1927 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 351158"];
1928 [label="assemblies[i].ContainsNoPiaLocalTypes 351159"];
1929 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 351160"];
1930 [label="linkedReferencedAssembliesBuilder.Clear(); 351161"];
1931 [label="if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    } 351162"];
1932 [label="assemblies[i].IsLinked 351163"];
1933 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 351164"];
1934 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 351165"];
1935 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 351166"];
1936 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 351167"];
1937 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 351168"];
1938 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 351169"];
1939 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary) 351170"];
1940 [label="param SetCorLibrary(AssemblySymbol corLibrary) 351171"];
1941 [label="param SetCorLibrary(this) 351172"];
1942 [label="Debug.Assert((object)_corLibrary == null); 351173"];
1943 [label="Debug.Assert((object)_corLibrary == null); 351174"];
1944 [label="_corLibrary 351175"];
1945 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 351176"];
1946 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 351177"];
1947 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 351178"];
1948 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 351179"];
1949 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 351180"];
1950 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 351181"];
1951 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 351182"];
1952 [label="if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        } 351183"];
1953 [label="assemblies[referenceBinding.DefinitionIndex].IsLinked 351184"];
1954 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 351185"];
1955 [label="Debug.Assert((object)_corLibrary == null); 351186"];
1956 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 351187"];
1957 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 351188"];
1958 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 351189"];
1959 [label="assemblies[referenceBinding.DefinitionIndex].IsLinked 351190"];
1960 [label="Debug.Assert((object)_corLibrary == null); 351191"];
1961 [label="linkedReferencedAssembliesBuilder.Free(); 351192"];
1962 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 351193"];
1963 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 351194"];
1964 [label="foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    } 351195"];
1965 [label="missingAssembly.SetCorLibrary(corLibrary); 351196"];
1966 [label="missingAssembly.SetCorLibrary(corLibrary) 351197"];
1967 [label="param SetCorLibrary(AssemblySymbol corLibrary) 351198"];
1968 [label="Debug.Assert((object)_corLibrary == null); 351199"];
1969 [label="missingAssembly.SetCorLibrary(corLibrary); 351200"];
1970 [label="Debug.Assert((object)_corLibrary == null); 351201"];
1971 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 351202"];
1972 [label="if (compilation._lazyAssemblySymbol is null)\n                    {\n                        lock (SymbolCacheAndReferenceManagerStateGuard)\n                        {\n                            if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            }\n                        }\n                    } 351203"];
1973 [label="if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            } 351204"];
1974 [label="if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                } 351205"];
1975 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 351206"];
1976 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 351207"];
1977 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult) 351208"];
1978 [label="param UpdateSymbolCacheNoLock(List<int> newSymbols) 351209"];
1979 [label="param UpdateSymbolCacheNoLock(ImmutableArray<AssemblyData> assemblies) 351210"];
1980 [label="param UpdateSymbolCacheNoLock(BoundInputAssembly[] bindingResult) 351211"];
1981 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly current = ref bindingResult[i];\n                    Debug.Assert(current.AssemblySymbol is object);\n\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n                    if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    }\n                } 351212"];
1982 [label="ref BoundInputAssembly current = ref bindingResult[i]; 351213"];
1983 [label="Debug.Assert(current.AssemblySymbol is object); 351214"];
1984 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 351215"];
1985 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 351216"];
1986 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 351217"];
1987 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 351218"];
1988 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 351219"];
1989 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 351220"];
1990 [label="Debug.Assert(current.AssemblySymbol is object); 351221"];
1991 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 351222"];
1992 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 351223"];
1993 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 351224"];
1994 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 351225"];
1995 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 351226"];
1996 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 351227"];
1997 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 351228"];
1998 [label="ReferenceEquals(corLibrary, assemblySymbol) 351229"];
1999 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 351230"];
2000 [label="assemblySymbol.SourceModule 351231"];
2001 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 351232"];
2002 [label="this.Modules 351233"];
2003 [label="get\n            {\n                return _modules;\n            } 351234"];
2004 [label="return _modules; 351235"];
2005 [label="return (SourceModuleSymbol)this.Modules[0]; 351236"];
2006 [label="return (SourceModuleSymbol)this.Modules[0]; 351237"];
2007 [label="assemblySymbol.SourceModule.GetReferencedAssemblySymbols() 351238"];
2008 [label="param GetReferencedAssemblySymbols(this) 351239"];
2009 [label="AssertReferencesInitialized() 351240"];
2010 [label="param AssertReferencesInitialized(this) 351241"];
2011 [label="Debug.Assert(_moduleReferences != null); 351242"];
2012 [label="Debug.Assert(_moduleReferences != null); 351243"];
2013 [label="AssertReferencesInitialized(); 351244"];
2014 [label="return _moduleReferences.Symbols; 351245"];
2015 [label="assemblySymbol.SourceModule 351246"];
2016 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 351247"];
2017 [label="this.Modules 351248"];
2018 [label="get\n            {\n                return _modules;\n            } 351249"];
2019 [label="return _modules; 351250"];
2020 [label="return (SourceModuleSymbol)this.Modules[0]; 351251"];
2021 [label="assemblySymbol.SourceModule.GetUnifiedAssemblies() 351252"];
2022 [label="param GetUnifiedAssemblies(this) 351253"];
2023 [label="AssertReferencesInitialized() 351254"];
2024 [label="param AssertReferencesInitialized(this) 351255"];
2025 [label="Debug.Assert(_moduleReferences != null); 351256"];
2026 [label="Debug.Assert(_moduleReferences != null); 351257"];
2027 [label="AssertReferencesInitialized(); 351258"];
2028 [label="return _moduleReferences.UnifiedAssemblies; 351259"];
2029 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 351260"];
2030 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 351261"];
2031 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 351262"];
2032 [label="compilation._referenceManager 351263"];
2033 [label="compilation._lazyAssemblySymbol 351264"];
2034 [label="return true; 351265"];
2035 [label="resolutionDiagnostics.Free(); 351266"];
2036 [label="assemblyReferencesBySimpleName.Free(); 351267"];
2037 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 351268"];
2038 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 351269"];
2039 [label="AssertBound(); 351270"];
2040 [label="Debug.Assert(compilation._lazyAssemblySymbol is object); 351271"];
2041 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 351272"];
2042 [label="Debug.Assert(_lazyAssemblySymbol is object); 351273"];
2043 [label="return _referenceManager; 351274"];
2044 [label="GetBoundReferenceManager(); 351275"];
2045 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 351276"];
2046 [label="return _lazyAssemblySymbol; 351277"];
2047 [label="return SourceAssembly; 351278"];
2048 [label="modules.AddRange(Assembly.Modules); 351279"];
2049 [label="Assembly.Modules 351280"];
2050 [label="get\n            {\n                return _modules;\n            } 351281"];
2051 [label="modules.AddRange(Assembly.Modules); 351282"];
2052 [label="GetBoundReferenceManager() 351283"];
2053 [label="param GetBoundReferenceManager(this) 351284"];
2054 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 351285"];
2055 [label="return _referenceManager; 351286"];
2056 [label="var referenceManager = GetBoundReferenceManager(); 351287"];
2057 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 351288"];
2058 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 351289"];
2059 [label="if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                } 351290"];
2060 [label="modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules); 351291"];
2061 [label="referenceManager.ReferencedAssemblies[i].Modules 351292"];
2062 [label="get\n            {\n                return _modules;\n            } 351293"];
2063 [label="GetAllUnaliasedModules(modules); 351294"];
2064 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 351295"];
2065 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 351296"];
2066 [label="new NamespaceExtent(this) 351297"];
2067 [label="param NamespaceExtent(CSharpCompilation compilation) 351298"];
2068 [label="param NamespaceExtent(this) 351299"];
2069 [label="_kind 351300"];
2070 [label="_symbolOrCompilation 351301"];
2071 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 351302"];
2072 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 351303"];
2073 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 351304"];
2074 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 351305"];
2075 [label="var diagnostics = DiagnosticBag.GetInstance(); 351306"];
2076 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 351307"];
2077 [label="DeclaringCompilation 351308"];
2078 [label="get\n            {\n                return _assemblySymbol.DeclaringCompilation;\n            } 351309"];
2079 [label="_assemblySymbol.DeclaringCompilation 351310"];
2080 [label="get\n            {\n                return _compilation;\n            } 351311"];
2081 [label="return _compilation; 351312"];
2082 [label="return _assemblySymbol.DeclaringCompilation; 351313"];
2083 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 351314"];
2084 [label="DeclaringCompilation.MergedRootDeclaration 351315"];
2085 [label="get\n            {\n                return Declarations.GetMergedRoot(this);\n            } 351316"];
2086 [label="Declarations 351317"];
2087 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 351318"];
2088 [label="return Declarations.GetMergedRoot(this); 351319"];
2089 [label="return Declarations.GetMergedRoot(this); 351320"];
2090 [label="return Declarations.GetMergedRoot(this); 351321"];
2091 [label="0x1 351322"];
2092 [label="LazyAllMembersIsSorted = 0x1 351323"];
2093 [label="d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 351324"];
2094 [label="s_declaringSyntaxReferencesSelector = d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 351325"];
2095 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 351326"];
2096 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 351327"];
2097 [label="new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics) 351328"];
2098 [label="param SourceNamespaceSymbol(SourceModuleSymbol module) 351329"];
2099 [label="param SourceNamespaceSymbol(Symbol container) 351330"];
2100 [label="param SourceNamespaceSymbol(MergedNamespaceDeclaration mergedDeclaration) 351331"];
2101 [label="param SourceNamespaceSymbol(DiagnosticBag diagnostics) 351332"];
2102 [label="param SourceNamespaceSymbol(this) 351333"];
2103 [label="param SourceNamespaceSymbol(this) 351334"];
2104 [label="_module 351335"];
2105 [label="_container 351336"];
2106 [label="_mergedDeclaration 351337"];
2107 [label="_nameToMembersMap 351338"];
2108 [label="_nameToTypeMembersMap 351339"];
2109 [label="_flags 351340"];
2110 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 351341"];
2111 [label="1 351342"];
2112 [label="_treeOrdinal 351343"];
2113 [label="0 351344"];
2114 [label="_position 351345"];
2115 [label="NotInSource = new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 351346"];
2116 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 351347"];
2117 [label="1 351348"];
2118 [label="_treeOrdinal 351349"];
2119 [label="1 351350"];
2120 [label="_position 351351"];
2121 [label="NotInitialized = new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 351352"];
2122 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 351353"];
2123 [label="_treeOrdinal 351354"];
2124 [label="1 351355"];
2125 [label="int.MaxValue - 1 351356"];
2126 [label="_position 351357"];
2127 [label="SynthesizedCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 351358"];
2128 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 351359"];
2129 [label="_treeOrdinal 351360"];
2130 [label="_position 351361"];
2131 [label="SynthesizedCCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 351362"];
2132 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 351363"];
2133 [label="Debug.Assert(mergedDeclaration != null); 351364"];
2134 [label="Debug.Assert(mergedDeclaration != null); 351365"];
2135 [label="_module 351366"];
2136 [label="_container 351367"];
2137 [label="_mergedDeclaration 351368"];
2138 [label="foreach (var singleDeclaration in mergedDeclaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 351369"];
2139 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 351370"];
2140 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 351371"];
2141 [label="Debug.Assert(diagnostics.IsEmptyWithoutResolution); 351372"];
2142 [label="diagnostics.Free(); 351373"];
2143 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 351374"];
2144 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 351375"];
2145 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 351376"];
2146 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 351377"];
2147 [label="return _globalNamespace; 351378"];
2148 [label="param GetHashCode(this) 351379"];
2149 [label="return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(this); 351380"];
2150 [label="return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(this); 351381"];
2151 [label="get { return _globalNamespace; } 351382"];
2152 [label="return _globalNamespace; 351383"];
2153 [label="MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)) 351384"];
2154 [label="param Create(NamespaceExtent extent) 351385"];
2155 [label="param Create(NamespaceSymbol containingNamespace) 351386"];
2156 [label="param Create(ImmutableArray<NamespaceSymbol> namespacesToMerge) 351387"];
2157 [label="param Create(string nameOpt = null) 351388"];
2158 [label="Debug.Assert(namespacesToMerge.Length != 0); 351389"];
2159 [label="Debug.Assert(namespacesToMerge.Length != 0); 351390"];
2160 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 351391"];
2161 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 351392"];
2162 [label="(namespacesToMerge.Length == 1 && nameOpt == null) 351393"];
2163 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 351394"];
2164 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 351395"];
2165 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 351396"];
2166 [label="new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt) 351397"];
2167 [label="param MergedNamespaceSymbol(NamespaceExtent extent) 351398"];
2168 [label="param MergedNamespaceSymbol(NamespaceSymbol containingNamespace) 351399"];
2169 [label="param MergedNamespaceSymbol(ImmutableArray<NamespaceSymbol> namespacesToMerge) 351400"];
2170 [label="param MergedNamespaceSymbol(string nameOpt) 351401"];
2171 [label="param MergedNamespaceSymbol(this) 351402"];
2172 [label="param MergedNamespaceSymbol(this) 351403"];
2173 [label="_containingNamespace 351404"];
2174 [label="_nameOpt 351405"];
2175 [label="_cachedLookup 351406"];
2176 [label="_extent 351407"];
2177 [label="_namespacesToMerge 351408"];
2178 [label="_containingNamespace 351409"];
2179 [label="_cachedLookup = new CachingDictionary<string, Symbol>(SlowGetChildrenOfName, SlowGetChildNames, EqualityComparer<string>.Default); 351410"];
2180 [label="_cachedLookup = new CachingDictionary<string, Symbol>(SlowGetChildrenOfName, SlowGetChildNames, EqualityComparer<string>.Default); 351411"];
2181 [label="_cachedLookup 351412"];
2182 [label="_nameOpt 351413"];
2183 [label="foreach (NamespaceSymbol ns in namespacesToMerge)\n            {\n                Debug.Assert(ns.ConstituentNamespaces.Length == 1);\n            } 351414"];
2184 [label="ns.ConstituentNamespaces 351415"];
2185 [label="get\n            {\n                return ImmutableArray.Create(this);\n            } 351416"];
2186 [label="return ImmutableArray.Create(this); 351417"];
2187 [label="Debug.Assert(ns.ConstituentNamespaces.Length == 1); 351418"];
2188 [label="Debug.Assert(ns.ConstituentNamespaces.Length == 1); 351419"];
2189 [label="modules.Free(); 351420"];
2190 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 351421"];
2191 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 351422"];
2192 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 351423"];
2193 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 351424"];
2194 [label="return _lazyGlobalNamespace; 351425"];
2195 [label="var global = comp.GlobalNamespace; 351426"];
2196 [label="var ns1 = global.GetMembers('NS').Single() as NamespaceSymbol; 351427"];
2197 [label="global.GetMembers('NS') 351428"];
2198 [label="param GetMembers(string name) 351429"];
2199 [label="param GetMembers(this) 351430"];
2200 [label="return _cachedLookup[name]; 351431"];
2201 [label="_cachedLookup 351432"];
2202 [label="param SlowGetChildrenOfName(string name) 351433"];
2203 [label="param SlowGetChildrenOfName(this) 351434"];
2204 [label="ArrayBuilder<NamespaceSymbol> namespaceSymbols = null; 351435"];
2205 [label="var otherSymbols = ArrayBuilder<Symbol>.GetInstance(); 351436"];
2206 [label="foreach (NamespaceSymbol namespaceSymbol in _namespacesToMerge)\n            {\n                foreach (Symbol childSymbol in namespaceSymbol.GetMembers(name))\n                {\n                    if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    }\n                }\n            } 351437"];
2207 [label="foreach (Symbol childSymbol in namespaceSymbol.GetMembers(name))\n                {\n                    if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    }\n                } 351438"];
2208 [label="namespaceSymbol.GetMembers(name) 351439"];
2209 [label="param GetMembers(string name) 351440"];
2210 [label="param GetMembers(this) 351441"];
2211 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 351442"];
2212 [label="members 351443"];
2213 [label="this.GetNameToMembersMap() 351444"];
2214 [label="param GetNameToMembersMap(this) 351445"];
2215 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 351446"];
2216 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 351447"];
2217 [label="var diagnostics = DiagnosticBag.GetInstance(); 351448"];
2218 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 351449"];
2219 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 351450"];
2220 [label="MakeNameToMembersMap(diagnostics) 351451"];
2221 [label="param MakeNameToMembersMap(DiagnosticBag diagnostics) 351452"];
2222 [label="param MakeNameToMembersMap(this) 351453"];
2223 [label="var builder = new NameToSymbolMapBuilder(_mergedDeclaration.Children.Length); 351454"];
2224 [label="_mergedDeclaration.Children 351455"];
2225 [label="param NameToSymbolMapBuilder(int capacity) 351456"];
2226 [label="param NameToSymbolMapBuilder(this) 351457"];
2227 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 351458"];
2228 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 351459"];
2229 [label="_dictionary 351460"];
2230 [label="foreach (var declaration in _mergedDeclaration.Children)\n            {\n                builder.Add(BuildSymbol(declaration, diagnostics));\n            } 351461"];
2231 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 351462"];
2232 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 351463"];
2233 [label="BuildSymbol(declaration, diagnostics) 351464"];
2234 [label="param BuildSymbol(MergedNamespaceOrTypeDeclaration declaration) 351465"];
2235 [label="param BuildSymbol(DiagnosticBag diagnostics) 351466"];
2236 [label="param BuildSymbol(this) 351467"];
2237 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Namespace:\n                    return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Script:\n                case DeclarationKind.Submission:\n                case DeclarationKind.ImplicitClass:\n                    return new ImplicitNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.SimpleProgram:\n                    return new SimpleProgramNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(declaration.Kind);\n            } 351468"];
2238 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 351469"];
2239 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 351470"];
2240 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 351471"];
2241 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 351472"];
2242 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 351473"];
2243 [label="new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics) 351474"];
2244 [label="param SourceNamespaceSymbol(SourceModuleSymbol module) 351475"];
2245 [label="param SourceNamespaceSymbol(Symbol container) 351476"];
2246 [label="param SourceNamespaceSymbol(MergedNamespaceDeclaration mergedDeclaration) 351477"];
2247 [label="param SourceNamespaceSymbol(DiagnosticBag diagnostics) 351478"];
2248 [label="param SourceNamespaceSymbol(this) 351479"];
2249 [label="_module 351480"];
2250 [label="_container 351481"];
2251 [label="_mergedDeclaration 351482"];
2252 [label="Debug.Assert(mergedDeclaration != null); 351483"];
2253 [label="Debug.Assert(mergedDeclaration != null); 351484"];
2254 [label="builder.Add(BuildSymbol(declaration, diagnostics)) 351485"];
2255 [label="param Add(NamespaceOrTypeSymbol symbol) 351486"];
2256 [label="param Add(this) 351487"];
2257 [label="symbol.Name 351488"];
2258 [label="=> _mergedDeclaration.Name 351489"];
2259 [label="_mergedDeclaration.Name 351490"];
2260 [label="string name = symbol.Name; 351491"];
2261 [label="object item; 351492"];
2262 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 351493"];
2263 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 351494"];
2264 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 351495"];
2265 [label="_dictionary 351496"];
2266 [label="builder.CreateMap() 351497"];
2267 [label="param CreateMap(this) 351498"];
2268 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 351499"];
2269 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 351500"];
2270 [label="foreach (var kvp in _dictionary)\n                {\n                    object value = kvp.Value;\n                    ImmutableArray<NamespaceOrTypeSymbol> members;\n\n                    var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    }\n\n                    result.Add(kvp.Key, members);\n                } 351501"];
2271 [label="object value = kvp.Value; 351502"];
2272 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 351503"];
2273 [label="members 351504"];
2274 [label="var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>; 351505"];
2275 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 351506"];
2276 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 351507"];
2277 [label="NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value; 351508"];
2278 [label="symbol.Kind 351509"];
2279 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 351510"];
2280 [label="return SymbolKind.Namespace; 351511"];
2281 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 351512"];
2282 [label="symbol.Kind == SymbolKind.Namespace 351513"];
2283 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 351514"];
2284 [label="result.Add(kvp.Key, members); 351515"];
2285 [label="result.Add(kvp.Key, members); 351516"];
2286 [label="result.Add(kvp.Key, members); 351517"];
2287 [label="return result; 351518"];
2288 [label="var result = builder.CreateMap(); 351519"];
2289 [label="CheckMembers(this, result, diagnostics); 351520"];
2290 [label="CheckMembers(this, result, diagnostics); 351521"];
2291 [label="CheckMembers(this, result, diagnostics); 351522"];
2292 [label="CheckMembers(this, result, diagnostics) 351523"];
2293 [label="param CheckMembers(NamespaceSymbol @namespace) 351524"];
2294 [label="param CheckMembers(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> result) 351525"];
2295 [label="param CheckMembers(DiagnosticBag diagnostics) 351526"];
2296 [label="var memberOfArity = new Symbol[10]; 351527"];
2297 [label="MergedNamespaceSymbol mergedAssemblyNamespace = null; 351528"];
2298 [label="@namespace.ContainingAssembly 351529"];
2299 [label="=> _module.ContainingAssembly 351530"];
2300 [label="_module.ContainingAssembly 351531"];
2301 [label="get\n            {\n                return _assemblySymbol;\n            } 351532"];
2302 [label="return _assemblySymbol; 351533"];
2303 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 351534"];
2304 [label="@namespace.ContainingAssembly.Modules 351535"];
2305 [label="get\n            {\n                return _modules;\n            } 351536"];
2306 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 351537"];
2307 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 351538"];
2308 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 351539"];
2309 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 351540"];
2310 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 351541"];
2311 [label="foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                } 351542"];
2312 [label="var nts = symbol as NamedTypeSymbol; 351543"];
2313 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 351544"];
2314 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 351545"];
2315 [label="((object)nts != null) 351546"];
2316 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 351547"];
2317 [label="var other = memberOfArity[arity]; 351548"];
2318 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 351549"];
2319 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 351550"];
2320 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 351551"];
2321 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 351552"];
2322 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 351553"];
2323 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 351554"];
2324 [label="memberOfArity[arity] 351555"];
2325 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 351556"];
2326 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 351557"];
2327 [label="CheckMembers(this, result, diagnostics); 351558"];
2328 [label="return result; 351559"];
2329 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 351560"];
2330 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 351561"];
2331 [label="this.DeclaringCompilation 351562"];
2332 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 351563"];
2333 [label="this.Kind 351564"];
2334 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 351565"];
2335 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 351566"];
2336 [label="this.ContainingModule 351567"];
2337 [label="get\n            {\n                return _module;\n            } 351568"];
2338 [label="return _module; 351569"];
2339 [label="var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol; 351570"];
2340 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 351571"];
2341 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 351572"];
2342 [label="(object)sourceModuleSymbol == null 351573"];
2343 [label="sourceModuleSymbol.DeclaringCompilation 351574"];
2344 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 351575"];
2345 [label="this.DeclaringCompilation.DeclarationDiagnostics 351576"];
2346 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 351577"];
2347 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 351578"];
2348 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 351579"];
2349 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 351580"];
2350 [label="var diagnostics = new DiagnosticBag(); 351581"];
2351 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 351582"];
2352 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 351583"];
2353 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 351584"];
2354 [label="return _lazyDeclarationDiagnostics; 351585"];
2355 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 351586"];
2356 [label="RegisterDeclaredCorTypes() 351587"];
2357 [label="param RegisterDeclaredCorTypes(this) 351588"];
2358 [label="ContainingAssembly 351589"];
2359 [label="=> _module.ContainingAssembly 351590"];
2360 [label="_module.ContainingAssembly 351591"];
2361 [label="get\n            {\n                return _assemblySymbol;\n            } 351592"];
2362 [label="return _assemblySymbol; 351593"];
2363 [label="AssemblySymbol containingAssembly = ContainingAssembly; 351594"];
2364 [label="containingAssembly.KeepLookingForDeclaredSpecialTypes 351595"];
2365 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 351596"];
2366 [label="this.CorLibrary 351597"];
2367 [label="get\n            {\n                return _corLibrary;\n            } 351598"];
2368 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 351599"];
2369 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 351600"];
2370 [label="if (containingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                // Register newly declared COR types\n                foreach (var array in _nameToMembersMap.Values)\n                {\n                    foreach (var member in array)\n                    {\n                        var type = member as NamedTypeSymbol;\n\n                        if ((object)type != null && type.SpecialType != SpecialType.None)\n                        {\n                            containingAssembly.RegisterDeclaredSpecialType(type);\n\n                            if (!containingAssembly.KeepLookingForDeclaredSpecialTypes)\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n            } 351601"];
2371 [label="RegisterDeclaredCorTypes(); 351602"];
2372 [label="DeclaringCompilation 351603"];
2373 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 351604"];
2374 [label="this.Kind 351605"];
2375 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 351606"];
2376 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 351607"];
2377 [label="this.ContainingModule 351608"];
2378 [label="get\n            {\n                return _module;\n            } 351609"];
2379 [label="return _module; 351610"];
2380 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 351611"];
2381 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 351612"];
2382 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 351613"];
2383 [label="DeclaringCompilation.SymbolDeclaredEvent(this) 351614"];
2384 [label="param SymbolDeclaredEvent(Symbol symbol) 351615"];
2385 [label="param SymbolDeclaredEvent(this) 351616"];
2386 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 351617"];
2387 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 351618"];
2388 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 351619"];
2389 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 351620"];
2390 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 351621"];
2391 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 351622"];
2392 [label="var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap); 351623"];
2393 [label="_state.NotePartComplete(CompletionPart.NameToMembersMap) 351624"];
2394 [label="param NotePartComplete(CompletionPart part) 351625"];
2395 [label="param NotePartComplete(this) 351626"];
2396 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 351627"];
2397 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 351628"];
2398 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 351629"];
2399 [label="Debug.Assert(wasSetThisThread); 351630"];
2400 [label="diagnostics.Free(); 351631"];
2401 [label="return _nameToMembersMap; 351632"];
2402 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 351633"];
2403 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 351634"];
2404 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 351635"];
2405 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 351636"];
2406 [label="this.GetNameToMembersMap().TryGetValue(name, out members) 351637"];
2407 [label="childSymbol.Kind 351638"];
2408 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 351639"];
2409 [label="if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    } 351640"];
2410 [label="namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance(); 351641"];
2411 [label="namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance(); 351642"];
2412 [label="namespaceSymbols.Add((NamespaceSymbol)childSymbol); 351643"];
2413 [label="namespaceSymbols.Add((NamespaceSymbol)childSymbol); 351644"];
2414 [label="param GetMembers(string name) 351645"];
2415 [label="param GetMembers(this) 351646"];
2416 [label="EnsureAllMembersLoaded() 351647"];
2417 [label="param EnsureAllMembersLoaded(this) 351648"];
2418 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 351649"];
2419 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 351650"];
2420 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 351651"];
2421 [label="_moduleSymbol.Module 351652"];
2422 [label="get\n            {\n                return _module;\n            } 351653"];
2423 [label="return _module; 351654"];
2424 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 351655"];
2425 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 351656"];
2426 [label="LoadAllMembers(groups); 351657"];
2427 [label="LoadAllMembers(groups) 351658"];
2428 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 351659"];
2429 [label="param LoadAllMembers(this) 351660"];
2430 [label="Debug.Assert(typesByNS != null); 351661"];
2431 [label="Debug.Assert(typesByNS != null); 351662"];
2432 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> nestedTypes = null; 351663"];
2433 [label="IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> nestedNamespaces = null; 351664"];
2434 [label="this.IsGlobalNamespace 351665"];
2435 [label="get\n            {\n                return true;\n            } 351666"];
2436 [label="return true; 351667"];
2437 [label="bool isGlobalNamespace = this.IsGlobalNamespace; 351668"];
2438 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 351669"];
2439 [label="isGlobalNamespace 351670"];
2440 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 351671"];
2441 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 351672"];
2442 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 351673"];
2443 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 351674"];
2444 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 351675"];
2445 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 351676"];
2446 [label="LazyInitializeNamespaces(nestedNamespaces); 351677"];
2447 [label="LazyInitializeNamespaces(nestedNamespaces) 351678"];
2448 [label="param LazyInitializeNamespaces(IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> childNamespaces) 351679"];
2449 [label="param LazyInitializeNamespaces(this) 351680"];
2450 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 351681"];
2451 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 351682"];
2452 [label="var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance); 351683"];
2453 [label="foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                } 351684"];
2454 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 351685"];
2455 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 351686"];
2456 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 351687"];
2457 [label="new PENestedNamespaceSymbol(child.Key, this, child.Value) 351688"];
2458 [label="param PENestedNamespaceSymbol(string name) 351689"];
2459 [label="param PENestedNamespaceSymbol(PENamespaceSymbol containingNamespace) 351690"];
2460 [label="param PENestedNamespaceSymbol(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 351691"];
2461 [label="param PENestedNamespaceSymbol(this) 351692"];
2462 [label="param PENestedNamespaceSymbol(this) 351693"];
2463 [label="_containingNamespaceSymbol 351694"];
2464 [label="_name 351695"];
2465 [label="_typesByNS 351696"];
2466 [label="Debug.Assert(name != null); 351697"];
2467 [label="Debug.Assert(name != null); 351698"];
2468 [label="Debug.Assert((object)containingNamespace != null); 351699"];
2469 [label="Debug.Assert((object)containingNamespace != null); 351700"];
2470 [label="Debug.Assert(typesByNS != null); 351701"];
2471 [label="Debug.Assert(typesByNS != null); 351702"];
2472 [label="_containingNamespaceSymbol 351703"];
2473 [label="_name 351704"];
2474 [label="_typesByNS 351705"];
2475 [label="c.Name 351706"];
2476 [label="get\n            {\n                return _name;\n            } 351707"];
2477 [label="return _name; 351708"];
2478 [label="namespaces.Add(c.Name, c); 351709"];
2479 [label="namespaces.Add(c.Name, c); 351710"];
2480 [label="namespaces.Add(c.Name, c); 351711"];
2481 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 351712"];
2482 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 351713"];
2483 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 351714"];
2484 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 351715"];
2485 [label="LazyInitializeNamespaces(nestedNamespaces); 351716"];
2486 [label="LazyInitializeTypes(nestedTypes); 351717"];
2487 [label="LazyInitializeTypes(nestedTypes) 351718"];
2488 [label="param LazyInitializeTypes(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typeGroups) 351719"];
2489 [label="param LazyInitializeTypes(this) 351720"];
2490 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 351721"];
2491 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 351722"];
2492 [label="ContainingPEModule 351723"];
2493 [label="get\n            {\n                return _moduleSymbol;\n            } 351724"];
2494 [label="return _moduleSymbol; 351725"];
2495 [label="var moduleSymbol = ContainingPEModule; 351726"];
2496 [label="var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance(); 351727"];
2497 [label="moduleSymbol.Module 351728"];
2498 [label="get\n            {\n                return _module;\n            } 351729"];
2499 [label="var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes(); 351730"];
2500 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 351731"];
2501 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 351732"];
2502 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 351733"];
2503 [label="foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    } 351734"];
2504 [label="if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        } 351735"];
2505 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 351736"];
2506 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 351737"];
2507 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 351738"];
2508 [label="EmptyComparer.Instance 351739"];
2509 [label="new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 351740"];
2510 [label="s_emptyNestedTypes = new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 351741"];
2511 [label="new UncommonProperties() 351742"];
2512 [label="param UncommonProperties(this) 351743"];
2513 [label="lazyEnumUnderlyingType 351744"];
2514 [label="lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 351745"];
2515 [label="lazyAttributeUsageInfo = AttributeUsageInfo.Null 351746"];
2516 [label="lazyContainsExtensionMethods 351747"];
2517 [label="lazyIsByRefLike 351748"];
2518 [label="lazyIsReadOnly 351749"];
2519 [label="lazyDefaultMemberName 351750"];
2520 [label="new UnsupportedMetadataTypeSymbol() 351751"];
2521 [label="param UnsupportedMetadataTypeSymbol(BadImageFormatException? mrEx = null) 351752"];
2522 [label="param UnsupportedMetadataTypeSymbol(this) 351753"];
2523 [label="param ErrorTypeSymbol(this) 351754"];
2524 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 351755"];
2525 [label="symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 351756"];
2526 [label="IsInstanceFieldOrEvent = symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 351757"];
2527 [label="type => !type.HasType 351758"];
2528 [label="TypeWithAnnotationsIsNullFunction = type => !type.HasType 351759"];
2529 [label="type => type.HasType && type.Type.IsErrorType() 351760"];
2530 [label="TypeWithAnnotationsIsErrorType = type => type.HasType && type.Type.IsErrorType() 351761"];
2531 [label="8 351762"];
2532 [label="ValueTupleRestPosition = 8 351763"];
2533 [label="1 351764"];
2534 [label="ValueTupleRestPosition - 1 351765"];
2535 [label="ValueTupleRestIndex = ValueTupleRestPosition - 1 351766"];
2536 [label="'ValueTuple' 351767"];
2537 [label="ValueTupleTypeName = 'ValueTuple' 351768"];
2538 [label="'Rest' 351769"];
2539 [label="ValueTupleRestFieldName = 'Rest' 351770"];
2540 [label="{\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 351771"];
2541 [label="tupleTypes = {\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 351772"];
2542 [label="{\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 351773"];
2543 [label="tupleCtors = {\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 351774"];
2544 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 351775"];
2545 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 } 351776"];
2546 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 } 351777"];
2547 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 } 351778"];
2548 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 } 351779"];
2549 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 } 351780"];
2550 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 } 351781"];
2551 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 } 351782"];
2552 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest } 351783"];
2553 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 351784"];
2554 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 351785"];
2555 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 351786"];
2556 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 351787"];
2557 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 351788"];
2558 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 351789"];
2559 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 351790"];
2560 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 351791"];
2561 [label="tupleMembers = new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 351792"];
2562 [label="tupleData 351793"];
2563 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 351794"];
2564 [label="param NamedTypeSymbol(this) 351795"];
2565 [label="'<invalid-global-code>' 351796"];
2566 [label="ImplicitTypeName = '<invalid-global-code>' 351797"];
2567 [label="0 351798"];
2568 [label="TypeCompareKind.ConsiderEverything 351799"];
2569 [label="new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 351800"];
2570 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 351801"];
2571 [label="param SymbolEqualityComparer(this) 351802"];
2572 [label="_comparison 351803"];
2573 [label="_comparison 351804"];
2574 [label="ConsiderEverything = new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 351805"];
2575 [label="TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 351806"];
2576 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 351807"];
2577 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 351808"];
2578 [label="param SymbolEqualityComparer(this) 351809"];
2579 [label="_comparison 351810"];
2580 [label="_comparison 351811"];
2581 [label="IgnoringTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 351812"];
2582 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 351813"];
2583 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 351814"];
2584 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 351815"];
2585 [label="param SymbolEqualityComparer(this) 351816"];
2586 [label="_comparison 351817"];
2587 [label="_comparison 351818"];
2588 [label="IgnoringDynamicTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 351819"];
2589 [label="TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 351820"];
2590 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 351821"];
2591 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 351822"];
2592 [label="param SymbolEqualityComparer(this) 351823"];
2593 [label="_comparison 351824"];
2594 [label="_comparison 351825"];
2595 [label="IgnoringNullable = new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 351826"];
2596 [label="TypeCompareKind.ObliviousNullableModifierMatchesAny 351827"];
2597 [label="new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 351828"];
2598 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 351829"];
2599 [label="param SymbolEqualityComparer(this) 351830"];
2600 [label="_comparison 351831"];
2601 [label="_comparison 351832"];
2602 [label="ObliviousNullableModifierMatchesAny = new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 351833"];
2603 [label="TypeCompareKind.AllIgnoreOptions 351834"];
2604 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 351835"];
2605 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 351836"];
2606 [label="param SymbolEqualityComparer(this) 351837"];
2607 [label="_comparison 351838"];
2608 [label="_comparison 351839"];
2609 [label="AllIgnoreOptions = new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 351840"];
2610 [label="TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 351841"];
2611 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 351842"];
2612 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 351843"];
2613 [label="param SymbolEqualityComparer(this) 351844"];
2614 [label="_comparison 351845"];
2615 [label="_comparison 351846"];
2616 [label="AllIgnoreOptionsPlusNullableWithUnknownMatchesAny =\n                                                                  new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 351847"];
2617 [label="TypeCompareKind.CLRSignatureCompareOptions 351848"];
2618 [label="new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 351849"];
2619 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 351850"];
2620 [label="param SymbolEqualityComparer(this) 351851"];
2621 [label="_comparison 351852"];
2622 [label="_comparison 351853"];
2623 [label="CLRSignature = new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 351854"];
2624 [label="SymbolEqualityComparer.CLRSignature 351855"];
2625 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 351856"];
2626 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 351857"];
2627 [label="EmptyInterfacesAndTheirBaseInterfaces =\n                                                new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 351858"];
2628 [label="new InterfaceInfo() 351859"];
2629 [label="param InterfaceInfo(this) 351860"];
2630 [label="interfacesAndTheirBaseInterfaces 351861"];
2631 [label="_implementationForInterfaceMemberMap 351862"];
2632 [label="explicitInterfaceImplementationMap 351863"];
2633 [label="s_noInterfaces = new InterfaceInfo() 351864"];
2634 [label="(type) => type.SetUnknownNullabilityForReferenceTypes() 351865"];
2635 [label="s_setUnknownNullability =\n            (type) => type.SetUnknownNullabilityForReferenceTypes() 351866"];
2636 [label="param TypeSymbol(this) 351867"];
2637 [label="param NamespaceOrTypeSymbol(this) 351868"];
2638 [label="param Symbol(this) 351869"];
2639 [label="_lazyISymbol 351870"];
2640 [label="_lazyAbstractMembers 351871"];
2641 [label="_lazyInterfaceInfo 351872"];
2642 [label="_lazyAdapter 351873"];
2643 [label="_hasNoBaseCycles 351874"];
2644 [label="_lazyTupleData 351875"];
2645 [label="_lazyTupleData 351876"];
2646 [label="_mrEx 351877"];
2647 [label="_mrEx 351878"];
2648 [label="UnknownResultType = new UnsupportedMetadataTypeSymbol() 351879"];
2649 [label="lazyComImportCoClassType = ErrorTypeSymbol.UnknownResultType 351880"];
2650 [label="lazyHasEmbeddedAttribute = ThreeState.Unknown 351881"];
2651 [label="s_noUncommonProperties = new UncommonProperties() 351882"];
2652 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 351883"];
2653 [label="PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key) 351884"];
2654 [label="param Create(PEModuleSymbol moduleSymbol) 351885"];
2655 [label="param Create(PENamespaceSymbol containingNamespace) 351886"];
2656 [label="param Create(TypeDefinitionHandle handle) 351887"];
2657 [label="param Create(string emittedNamespaceName) 351888"];
2658 [label="GenericParameterHandleCollection genericParameterHandles; 351889"];
2659 [label="genericParameterHandles 351890"];
2660 [label="ushort arity; 351891"];
2661 [label="BadImageFormatException mrEx = null; 351892"];
2662 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 351893"];
2663 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 351894"];
2664 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 351895"];
2665 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 351896"];
2666 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 351897"];
2667 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx) 351898"];
2668 [label="param GetGenericInfo(PEModuleSymbol moduleSymbol) 351899"];
2669 [label="param GetGenericInfo(TypeDefinitionHandle handle) 351900"];
2670 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 351901"];
2671 [label="param GetGenericInfo(out ushort arity) 351902"];
2672 [label="param GetGenericInfo(out BadImageFormatException mrEx) 351903"];
2673 [label="moduleSymbol.Module 351904"];
2674 [label="get\n            {\n                return _module;\n            } 351905"];
2675 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 351906"];
2676 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 351907"];
2677 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 351908"];
2678 [label="arity = (ushort)genericParameterHandles.Count; 351909"];
2679 [label="mrEx = null; 351910"];
2680 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 351911"];
2681 [label="bool mangleName; 351912"];
2682 [label="PENamedTypeSymbol result; 351913"];
2683 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 351914"];
2684 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 351915"];
2685 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 351916"];
2686 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 351917"];
2687 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 351918"];
2688 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 351919"];
2689 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 351920"];
2690 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 351921"];
2691 [label="new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName) 351922"];
2692 [label="param PENamedTypeSymbolNonGeneric(PEModuleSymbol moduleSymbol) 351923"];
2693 [label="param PENamedTypeSymbolNonGeneric(NamespaceOrTypeSymbol container) 351924"];
2694 [label="param PENamedTypeSymbolNonGeneric(TypeDefinitionHandle handle) 351925"];
2695 [label="param PENamedTypeSymbolNonGeneric(string emittedNamespaceName) 351926"];
2696 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 351927"];
2697 [label="param PENamedTypeSymbolNonGeneric(this) 351928"];
2698 [label="moduleSymbol 351929"];
2699 [label="container 351930"];
2700 [label="handle 351931"];
2701 [label="emittedNamespaceName 351932"];
2702 [label="0 351933"];
2703 [label="mangleName 351934"];
2704 [label="param PENamedTypeSymbolNonGeneric(this) 351935"];
2705 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 351936"];
2706 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 351937"];
2707 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 351938"];
2708 [label="param PENamedTypeSymbol(string emittedNamespaceName) 351939"];
2709 [label="param PENamedTypeSymbol(ushort arity) 351940"];
2710 [label="param PENamedTypeSymbol(out bool mangleName) 351941"];
2711 [label="param PENamedTypeSymbol(this) 351942"];
2712 [label="param PENamedTypeSymbol(this) 351943"];
2713 [label="param NamedTypeSymbol(this) 351944"];
2714 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 351945"];
2715 [label="param NamedTypeSymbol(this) 351946"];
2716 [label="param TypeSymbol(this) 351947"];
2717 [label="param TypeSymbol(this) 351948"];
2718 [label="_lazyAbstractMembers 351949"];
2719 [label="_lazyInterfaceInfo 351950"];
2720 [label="_lazyAdapter 351951"];
2721 [label="_hasNoBaseCycles 351952"];
2722 [label="_lazyTupleData 351953"];
2723 [label="_lazyTupleData 351954"];
2724 [label="_container 351955"];
2725 [label="_name 351956"];
2726 [label="_flags 351957"];
2727 [label="_corTypeId 351958"];
2728 [label="_lazyMemberNames 351959"];
2729 [label="_lazyMembersByName 351960"];
2730 [label="_lazyNestedTypes 351961"];
2731 [label="_lazyKind 351962"];
2732 [label="_lazyNullableContextValue 351963"];
2733 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 351964"];
2734 [label="default(ImmutableArray<NamedTypeSymbol>) 351965"];
2735 [label="_lazyInterfaces = default(ImmutableArray<NamedTypeSymbol>) 351966"];
2736 [label="_lazyDeclaredBaseType = ErrorTypeSymbol.UnknownResultType 351967"];
2737 [label="default(ImmutableArray<NamedTypeSymbol>) 351968"];
2738 [label="_lazyDeclaredInterfaces = default(ImmutableArray<NamedTypeSymbol>) 351969"];
2739 [label="_lazyDocComment 351970"];
2740 [label="_lazyUseSiteDiagnostic = CSDiagnosticInfo.EmptyErrorInfo 351971"];
2741 [label="_lazyUncommonProperties 351972"];
2742 [label="public IEnumerable<object> fieldDefs { get; set; } 351973"];
2743 [label="Debug.Assert(!handle.IsNil); 351974"];
2744 [label="Debug.Assert((object)container != null); 351975"];
2745 [label="Debug.Assert((object)container != null); 351976"];
2746 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 351977"];
2747 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 351978"];
2748 [label="string metadataName; 351979"];
2749 [label="bool makeBad = false; 351980"];
2750 [label="moduleSymbol.Module 351981"];
2751 [label="get\n            {\n                return _module;\n            } 351982"];
2752 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 351983"];
2753 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 351984"];
2754 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 351985"];
2755 [label="_handle 351986"];
2756 [label="_container 351987"];
2757 [label="moduleSymbol.Module 351988"];
2758 [label="get\n            {\n                return _module;\n            } 351989"];
2759 [label="return _module; 351990"];
2760 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 351991"];
2761 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 351992"];
2762 [label="_flags 351993"];
2763 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 351994"];
2764 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 351995"];
2765 [label="_name 351996"];
2766 [label="mangleName = false; 351997"];
2767 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 351998"];
2768 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 351999"];
2769 [label="moduleSymbol.ContainingAssembly 352000"];
2770 [label="get\n            {\n                return _assemblySymbol;\n            } 352001"];
2771 [label="return _assemblySymbol; 352002"];
2772 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 352003"];
2773 [label="moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 352004"];
2774 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 352005"];
2775 [label="this.CorLibrary 352006"];
2776 [label="get\n            {\n                return _corLibrary;\n            } 352007"];
2777 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 352008"];
2778 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 352009"];
2779 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 352010"];
2780 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 352011"];
2781 [label="this.DeclaredAccessibility 352012"];
2782 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 352013"];
2783 [label="Accessibility access = Accessibility.Private; 352014"];
2784 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 352015"];
2785 [label="access = Accessibility.Internal; 352016"];
2786 [label="return access; 352017"];
2787 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 352018"];
2788 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 352019"];
2789 [label="_corTypeId 352020"];
2790 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 352021"];
2791 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352022"];
2792 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352023"];
2793 [label="return result; 352024"];
2794 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 352025"];
2795 [label="GenericParameterHandleCollection genericParameterHandles; 352026"];
2796 [label="genericParameterHandles 352027"];
2797 [label="ushort arity; 352028"];
2798 [label="BadImageFormatException mrEx = null; 352029"];
2799 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 352030"];
2800 [label="param GetGenericInfo(out ushort arity) 352031"];
2801 [label="param GetGenericInfo(out BadImageFormatException mrEx) 352032"];
2802 [label="mrEx = null; 352033"];
2803 [label="bool mangleName; 352034"];
2804 [label="PENamedTypeSymbol result; 352035"];
2805 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 352036"];
2806 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 352037"];
2807 [label="new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName) 352038"];
2808 [label="param PENamedTypeSymbolGeneric(PEModuleSymbol moduleSymbol) 352039"];
2809 [label="param PENamedTypeSymbolGeneric(NamespaceOrTypeSymbol container) 352040"];
2810 [label="param PENamedTypeSymbolGeneric(TypeDefinitionHandle handle) 352041"];
2811 [label="param PENamedTypeSymbolGeneric(string emittedNamespaceName) 352042"];
2812 [label="param PENamedTypeSymbolGeneric(GenericParameterHandleCollection genericParameterHandles) 352043"];
2813 [label="param PENamedTypeSymbolGeneric(ushort arity) 352044"];
2814 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 352045"];
2815 [label="param PENamedTypeSymbolGeneric(this) 352046"];
2816 [label="moduleSymbol 352047"];
2817 [label="container 352048"];
2818 [label="handle 352049"];
2819 [label="emittedNamespaceName 352050"];
2820 [label="arity 352051"];
2821 [label="mangleName 352052"];
2822 [label="param PENamedTypeSymbolGeneric(this) 352053"];
2823 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 352054"];
2824 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 352055"];
2825 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 352056"];
2826 [label="param PENamedTypeSymbol(string emittedNamespaceName) 352057"];
2827 [label="param PENamedTypeSymbol(ushort arity) 352058"];
2828 [label="param PENamedTypeSymbol(out bool mangleName) 352059"];
2829 [label="_lazyTupleData 352060"];
2830 [label="_container 352061"];
2831 [label="_name 352062"];
2832 [label="_flags 352063"];
2833 [label="_corTypeId 352064"];
2834 [label="Debug.Assert(!handle.IsNil); 352065"];
2835 [label="Debug.Assert((object)container != null); 352066"];
2836 [label="Debug.Assert((object)container != null); 352067"];
2837 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 352068"];
2838 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 352069"];
2839 [label="string metadataName; 352070"];
2840 [label="bool makeBad = false; 352071"];
2841 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 352072"];
2842 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 352073"];
2843 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 352074"];
2844 [label="_name 352075"];
2845 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 352076"];
2846 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 352077"];
2847 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 352078"];
2848 [label="mangleName = !ReferenceEquals(_name, metadataName); 352079"];
2849 [label="mangleName = !ReferenceEquals(_name, metadataName); 352080"];
2850 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 352081"];
2851 [label="Accessibility access = Accessibility.Private; 352082"];
2852 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 352083"];
2853 [label="_arity 352084"];
2854 [label="_mangleName 352085"];
2855 [label="Debug.Assert(genericParameterHandles.Count > 0); 352086"];
2856 [label="Debug.Assert(genericParameterHandles.Count > 0); 352087"];
2857 [label="_arity 352088"];
2858 [label="_genericParameterHandles 352089"];
2859 [label="_mangleName 352090"];
2860 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352091"];
2861 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352092"];
2862 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 352093"];
2863 [label="GenericParameterHandleCollection genericParameterHandles; 352094"];
2864 [label="genericParameterHandles 352095"];
2865 [label="ushort arity; 352096"];
2866 [label="BadImageFormatException mrEx = null; 352097"];
2867 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 352098"];
2868 [label="param GetGenericInfo(out ushort arity) 352099"];
2869 [label="param GetGenericInfo(out BadImageFormatException mrEx) 352100"];
2870 [label="mrEx = null; 352101"];
2871 [label="bool mangleName; 352102"];
2872 [label="PENamedTypeSymbol result; 352103"];
2873 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 352104"];
2874 [label="mangleName 352105"];
2875 [label="param PENamedTypeSymbol(out bool mangleName) 352106"];
2876 [label="_lazyTupleData 352107"];
2877 [label="_container 352108"];
2878 [label="_name 352109"];
2879 [label="_flags 352110"];
2880 [label="_corTypeId 352111"];
2881 [label="Debug.Assert(!handle.IsNil); 352112"];
2882 [label="Debug.Assert((object)container != null); 352113"];
2883 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 352114"];
2884 [label="string metadataName; 352115"];
2885 [label="bool makeBad = false; 352116"];
2886 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 352117"];
2887 [label="Accessibility access = Accessibility.Private; 352118"];
2888 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 352119"];
2889 [label="_arity 352120"];
2890 [label="_mangleName 352121"];
2891 [label="Debug.Assert(genericParameterHandles.Count > 0); 352122"];
2892 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352123"];
2893 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352124"];
2894 [label="GenericParameterHandleCollection genericParameterHandles; 352125"];
2895 [label="genericParameterHandles 352126"];
2896 [label="ushort arity; 352127"];
2897 [label="BadImageFormatException mrEx = null; 352128"];
2898 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 352129"];
2899 [label="param GetGenericInfo(out ushort arity) 352130"];
2900 [label="param GetGenericInfo(out BadImageFormatException mrEx) 352131"];
2901 [label="mrEx = null; 352132"];
2902 [label="PENamedTypeSymbol result; 352133"];
2903 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 352134"];
2904 [label="mangleName 352135"];
2905 [label="param PENamedTypeSymbol(out bool mangleName) 352136"];
2906 [label="Debug.Assert(!handle.IsNil); 352137"];
2907 [label="mangleName = false; 352138"];
2908 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352139"];
2909 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352140"];
2910 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 352141"];
2911 [label="mangleName 352142"];
2912 [label="param PENamedTypeSymbol(out bool mangleName) 352143"];
2913 [label="_lazyTupleData 352144"];
2914 [label="_container 352145"];
2915 [label="_name 352146"];
2916 [label="_flags 352147"];
2917 [label="_corTypeId 352148"];
2918 [label="Debug.Assert(!handle.IsNil); 352149"];
2919 [label="Debug.Assert((object)container != null); 352150"];
2920 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 352151"];
2921 [label="string metadataName; 352152"];
2922 [label="bool makeBad = false; 352153"];
2923 [label="mangleName = false; 352154"];
2924 [label="Accessibility access = Accessibility.Private; 352155"];
2925 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 352156"];
2926 [label="genericParameterHandles 352157"];
2927 [label="ushort arity; 352158"];
2928 [label="BadImageFormatException mrEx = null; 352159"];
2929 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 352160"];
2930 [label="param GetGenericInfo(out ushort arity) 352161"];
2931 [label="param GetGenericInfo(out BadImageFormatException mrEx) 352162"];
2932 [label="mrEx = null; 352163"];
2933 [label="PENamedTypeSymbol result; 352164"];
2934 [label="Debug.Assert(!handle.IsNil); 352165"];
2935 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352166"];
2936 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352167"];
2937 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 352168"];
2938 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 352169"];
2939 [label="mangleName 352170"];
2940 [label="param PENamedTypeSymbol(out bool mangleName) 352171"];
2941 [label="_lazyTupleData 352172"];
2942 [label="_container 352173"];
2943 [label="_name 352174"];
2944 [label="_flags 352175"];
2945 [label="_corTypeId 352176"];
2946 [label="Debug.Assert(!handle.IsNil); 352177"];
2947 [label="Debug.Assert((object)container != null); 352178"];
2948 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 352179"];
2949 [label="string metadataName; 352180"];
2950 [label="bool makeBad = false; 352181"];
2951 [label="mangleName = false; 352182"];
2952 [label="Accessibility access = Accessibility.Private; 352183"];
2953 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 352184"];
2954 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 352185"];
2955 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 352186"];
2956 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 352187"];
2957 [label="get\n            {\n                return _name;\n            } 352188"];
2958 [label="return _name; 352189"];
2959 [label="children.Free(); 352190"];
2960 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 352191"];
2961 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 352192"];
2962 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 352193"];
2963 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 352194"];
2964 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 352195"];
2965 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 352196"];
2966 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 352197"];
2967 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 352198"];
2968 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict) 352199"];
2969 [label="param OnNewTypeDeclarationsLoaded(Dictionary<string, ImmutableArray<PENamedTypeSymbol>> typesDict) 352200"];
2970 [label="param OnNewTypeDeclarationsLoaded(this) 352201"];
2971 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 352202"];
2972 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 352203"];
2973 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 352204"];
2974 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 352205"];
2975 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 352206"];
2976 [label="foreach (var types in typesDict.Values)\n            {\n                foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                }\n            } 352207"];
2977 [label="foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                } 352208"];
2978 [label="bool added; 352209"];
2979 [label="type.Handle 352210"];
2980 [label="get\n            {\n                return _handle;\n            } 352211"];
2981 [label="return _handle; 352212"];
2982 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 352213"];
2983 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 352214"];
2984 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 352215"];
2985 [label="Debug.Assert(added); 352216"];
2986 [label="type.SpecialType 352217"];
2987 [label="get\n            {\n                return _corTypeId;\n            } 352218"];
2988 [label="return _corTypeId; 352219"];
2989 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 352220"];
2990 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 352221"];
2991 [label="bool added; 352222"];
2992 [label="Debug.Assert(added); 352223"];
2993 [label="type.SpecialType 352224"];
2994 [label="get\n            {\n                return _corTypeId;\n            } 352225"];
2995 [label="return _corTypeId; 352226"];
2996 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 352227"];
2997 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 352228"];
2998 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 352229"];
2999 [label="LazyInitializeTypes(nestedTypes); 352230"];
3000 [label="LoadAllMembers(groups); 352231"];
3001 [label="EnsureAllMembersLoaded(); 352232"];
3002 [label="PENestedNamespaceSymbol ns = null; 352233"];
3003 [label="ImmutableArray<PENamedTypeSymbol> t; 352234"];
3004 [label="t 352235"];
3005 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 352236"];
3006 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 352237"];
3007 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 352238"];
3008 [label="if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 352239"];
3009 [label="if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 352240"];
3010 [label="if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 352241"];
3011 [label="return ImmutableArray<Symbol>.Empty; 352242"];
3012 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 352243"];
3013 [label="Debug.Assert(typesByNS != null); 352244"];
3014 [label="get\n            {\n                return true;\n            } 352245"];
3015 [label="_containingNamespaceSymbol 352246"];
3016 [label="_name 352247"];
3017 [label="_typesByNS 352248"];
3018 [label="Debug.Assert(name != null); 352249"];
3019 [label="Debug.Assert((object)containingNamespace != null); 352250"];
3020 [label="Debug.Assert(typesByNS != null); 352251"];
3021 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 352252"];
3022 [label="genericParameterHandles 352253"];
3023 [label="BadImageFormatException mrEx = null; 352254"];
3024 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 352255"];
3025 [label="param GetGenericInfo(out ushort arity) 352256"];
3026 [label="param GetGenericInfo(out BadImageFormatException mrEx) 352257"];
3027 [label="mrEx = null; 352258"];
3028 [label="PENamedTypeSymbol result; 352259"];
3029 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 352260"];
3030 [label="mangleName 352261"];
3031 [label="param PENamedTypeSymbol(out bool mangleName) 352262"];
3032 [label="_lazyTupleData 352263"];
3033 [label="_container 352264"];
3034 [label="_name 352265"];
3035 [label="_flags 352266"];
3036 [label="_corTypeId 352267"];
3037 [label="Debug.Assert(!handle.IsNil); 352268"];
3038 [label="Debug.Assert((object)container != null); 352269"];
3039 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 352270"];
3040 [label="string metadataName; 352271"];
3041 [label="bool makeBad = false; 352272"];
3042 [label="mangleName = false; 352273"];
3043 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 352274"];
3044 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352275"];
3045 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352276"];
3046 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 352277"];
3047 [label="param GetGenericInfo(out ushort arity) 352278"];
3048 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 352279"];
3049 [label="mangleName 352280"];
3050 [label="param PENamedTypeSymbol(out bool mangleName) 352281"];
3051 [label="_lazyTupleData 352282"];
3052 [label="_container 352283"];
3053 [label="_name 352284"];
3054 [label="_flags 352285"];
3055 [label="_corTypeId 352286"];
3056 [label="Debug.Assert(!handle.IsNil); 352287"];
3057 [label="Debug.Assert((object)container != null); 352288"];
3058 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 352289"];
3059 [label="string metadataName; 352290"];
3060 [label="bool makeBad = false; 352291"];
3061 [label="mangleName = false; 352292"];
3062 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 352293"];
3063 [label="genericParameterHandles 352294"];
3064 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 352295"];
3065 [label="param GetGenericInfo(out ushort arity) 352296"];
3066 [label="param GetGenericInfo(out BadImageFormatException mrEx) 352297"];
3067 [label="mrEx = null; 352298"];
3068 [label="PENamedTypeSymbol result; 352299"];
3069 [label="Debug.Assert(!handle.IsNil); 352300"];
3070 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352301"];
3071 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352302"];
3072 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 352303"];
3073 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 352304"];
3074 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 352305"];
3075 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 352306"];
3076 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 352307"];
3077 [label="bool added; 352308"];
3078 [label="Debug.Assert(added); 352309"];
3079 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 352310"];
3080 [label="EnsureAllMembersLoaded(); 352311"];
3081 [label="return ImmutableArray<Symbol>.Empty; 352312"];
3082 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 352313"];
3083 [label="Debug.Assert(typesByNS != null); 352314"];
3084 [label="get\n            {\n                return true;\n            } 352315"];
3085 [label="_containingNamespaceSymbol 352316"];
3086 [label="_name 352317"];
3087 [label="_typesByNS 352318"];
3088 [label="Debug.Assert(name != null); 352319"];
3089 [label="Debug.Assert((object)containingNamespace != null); 352320"];
3090 [label="Debug.Assert(typesByNS != null); 352321"];
3091 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 352322"];
3092 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 352323"];
3093 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 352324"];
3094 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 352325"];
3095 [label="bool added; 352326"];
3096 [label="Debug.Assert(added); 352327"];
3097 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 352328"];
3098 [label="EnsureAllMembersLoaded(); 352329"];
3099 [label="return ImmutableArray<Symbol>.Empty; 352330"];
3100 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 352331"];
3101 [label="Debug.Assert(typesByNS != null); 352332"];
3102 [label="get\n            {\n                return true;\n            } 352333"];
3103 [label="_containingNamespaceSymbol 352334"];
3104 [label="_name 352335"];
3105 [label="_typesByNS 352336"];
3106 [label="Debug.Assert(name != null); 352337"];
3107 [label="Debug.Assert((object)containingNamespace != null); 352338"];
3108 [label="Debug.Assert(typesByNS != null); 352339"];
3109 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 352340"];
3110 [label="genericParameterHandles 352341"];
3111 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 352342"];
3112 [label="param GetGenericInfo(out ushort arity) 352343"];
3113 [label="param GetGenericInfo(out BadImageFormatException mrEx) 352344"];
3114 [label="mrEx = null; 352345"];
3115 [label="PENamedTypeSymbol result; 352346"];
3116 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 352347"];
3117 [label="mangleName 352348"];
3118 [label="param PENamedTypeSymbol(out bool mangleName) 352349"];
3119 [label="_lazyTupleData 352350"];
3120 [label="_container 352351"];
3121 [label="_name 352352"];
3122 [label="_flags 352353"];
3123 [label="_corTypeId 352354"];
3124 [label="Debug.Assert(!handle.IsNil); 352355"];
3125 [label="Debug.Assert((object)container != null); 352356"];
3126 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 352357"];
3127 [label="string metadataName; 352358"];
3128 [label="bool makeBad = false; 352359"];
3129 [label="mangleName = false; 352360"];
3130 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 352361"];
3131 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352362"];
3132 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 352363"];
3133 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 352364"];
3134 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 352365"];
3135 [label="EnsureAllMembersLoaded(); 352366"];
3136 [label="return ImmutableArray<Symbol>.Empty; 352367"];
3137 [label="if (namespaceSymbols != null)\n            {\n                otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()));\n            } 352368"];
3138 [label="if (namespaceSymbols != null)\n            {\n                otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()));\n            } 352369"];
3139 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 352370"];
3140 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 352371"];
3141 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 352372"];
3142 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 352373"];
3143 [label="MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()) 352374"];
3144 [label="param Create(NamespaceExtent extent) 352375"];
3145 [label="param Create(NamespaceSymbol containingNamespace) 352376"];
3146 [label="param Create(ImmutableArray<NamespaceSymbol> namespacesToMerge) 352377"];
3147 [label="param Create(string nameOpt = null) 352378"];
3148 [label="Debug.Assert(namespacesToMerge.Length != 0); 352379"];
3149 [label="Debug.Assert(namespacesToMerge.Length != 0); 352380"];
3150 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 352381"];
3151 [label="return otherSymbols.ToImmutableAndFree(); 352382"];
3152 [label="var syma = ns1.GetMembers('A').Single() as NamedTypeSymbol; 352383"];
3153 [label="ns1.GetMembers('A') 352384"];
3154 [label="param GetMembers(string name) 352385"];
3155 [label="param GetMembers(this) 352386"];
3156 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 352387"];
3157 [label="members 352388"];
3158 [label="this.GetNameToMembersMap() 352389"];
3159 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 352390"];
3160 [label="param BuildSymbol(this) 352391"];
3161 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 352392"];
3162 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 352393"];
3163 [label="new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics) 352394"];
3164 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 352395"];
3165 [label="param SourceNamedTypeSymbol(MergedTypeDeclaration declaration) 352396"];
3166 [label="param SourceNamedTypeSymbol(DiagnosticBag diagnostics) 352397"];
3167 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 352398"];
3168 [label="param SourceNamedTypeSymbol(this) 352399"];
3169 [label="false 352400"];
3170 [label="considerName: false 352401"];
3171 [label="false 352402"];
3172 [label="considerExplicitlyImplementedInterfaces: false 352403"];
3173 [label="true 352404"];
3174 [label="considerReturnType: true 352405"];
3175 [label="false 352406"];
3176 [label="considerTypeConstraints: false 352407"];
3177 [label="true 352408"];
3178 [label="considerRefKindDifferences: true 352409"];
3179 [label="true 352410"];
3180 [label="considerCallingConvention: true 352411"];
3181 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 352412"];
3182 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352413"];
3183 [label="param MemberSignatureComparer(bool considerName) 352414"];
3184 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352415"];
3185 [label="param MemberSignatureComparer(bool considerReturnType) 352416"];
3186 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352417"];
3187 [label="param MemberSignatureComparer(bool considerCallingConvention) 352418"];
3188 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352419"];
3189 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352420"];
3190 [label="param MemberSignatureComparer(this) 352421"];
3191 [label="_considerName 352422"];
3192 [label="_considerExplicitlyImplementedInterfaces 352423"];
3193 [label="_considerReturnType 352424"];
3194 [label="_considerTypeConstraints 352425"];
3195 [label="_considerCallingConvention 352426"];
3196 [label="_considerRefKindDifferences 352427"];
3197 [label="_typeComparison 352428"];
3198 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352429"];
3199 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352430"];
3200 [label="_considerName 352431"];
3201 [label="_considerExplicitlyImplementedInterfaces 352432"];
3202 [label="_considerReturnType 352433"];
3203 [label="_considerTypeConstraints 352434"];
3204 [label="_considerCallingConvention 352435"];
3205 [label="_considerRefKindDifferences 352436"];
3206 [label="_typeComparison 352437"];
3207 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352438"];
3208 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352439"];
3209 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352440"];
3210 [label="ExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352441"];
3211 [label="true 352442"];
3212 [label="considerName: true 352443"];
3213 [label="true 352444"];
3214 [label="considerExplicitlyImplementedInterfaces: true 352445"];
3215 [label="true 352446"];
3216 [label="considerReturnType: true 352447"];
3217 [label="false 352448"];
3218 [label="considerTypeConstraints: false 352449"];
3219 [label="true 352450"];
3220 [label="considerCallingConvention: true 352451"];
3221 [label="true 352452"];
3222 [label="considerRefKindDifferences: true 352453"];
3223 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 352454"];
3224 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352455"];
3225 [label="param MemberSignatureComparer(bool considerName) 352456"];
3226 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352457"];
3227 [label="param MemberSignatureComparer(bool considerReturnType) 352458"];
3228 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352459"];
3229 [label="param MemberSignatureComparer(bool considerCallingConvention) 352460"];
3230 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352461"];
3231 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352462"];
3232 [label="param MemberSignatureComparer(this) 352463"];
3233 [label="_considerName 352464"];
3234 [label="_considerExplicitlyImplementedInterfaces 352465"];
3235 [label="_considerReturnType 352466"];
3236 [label="_considerTypeConstraints 352467"];
3237 [label="_considerCallingConvention 352468"];
3238 [label="_considerRefKindDifferences 352469"];
3239 [label="_typeComparison 352470"];
3240 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352471"];
3241 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352472"];
3242 [label="_considerName 352473"];
3243 [label="_considerExplicitlyImplementedInterfaces 352474"];
3244 [label="_considerReturnType 352475"];
3245 [label="_considerTypeConstraints 352476"];
3246 [label="_considerCallingConvention 352477"];
3247 [label="_considerRefKindDifferences 352478"];
3248 [label="_typeComparison 352479"];
3249 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352480"];
3250 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352481"];
3251 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352482"];
3252 [label="CSharpImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352483"];
3253 [label="true 352484"];
3254 [label="considerName: true 352485"];
3255 [label="true 352486"];
3256 [label="considerExplicitlyImplementedInterfaces: true 352487"];
3257 [label="false 352488"];
3258 [label="considerReturnType: false 352489"];
3259 [label="false 352490"];
3260 [label="considerTypeConstraints: false 352491"];
3261 [label="false 352492"];
3262 [label="considerCallingConvention: false 352493"];
3263 [label="true 352494"];
3264 [label="considerRefKindDifferences: true 352495"];
3265 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 352496"];
3266 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352497"];
3267 [label="param MemberSignatureComparer(bool considerName) 352498"];
3268 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352499"];
3269 [label="param MemberSignatureComparer(bool considerReturnType) 352500"];
3270 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352501"];
3271 [label="param MemberSignatureComparer(bool considerCallingConvention) 352502"];
3272 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352503"];
3273 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352504"];
3274 [label="param MemberSignatureComparer(this) 352505"];
3275 [label="_considerName 352506"];
3276 [label="_considerExplicitlyImplementedInterfaces 352507"];
3277 [label="_considerReturnType 352508"];
3278 [label="_considerTypeConstraints 352509"];
3279 [label="_considerCallingConvention 352510"];
3280 [label="_considerRefKindDifferences 352511"];
3281 [label="_typeComparison 352512"];
3282 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352513"];
3283 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352514"];
3284 [label="_considerName 352515"];
3285 [label="_considerExplicitlyImplementedInterfaces 352516"];
3286 [label="_considerReturnType 352517"];
3287 [label="_considerTypeConstraints 352518"];
3288 [label="_considerCallingConvention 352519"];
3289 [label="_considerRefKindDifferences 352520"];
3290 [label="_typeComparison 352521"];
3291 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352522"];
3292 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352523"];
3293 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352524"];
3294 [label="CSharpCloseImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352525"];
3295 [label="true 352526"];
3296 [label="considerName: true 352527"];
3297 [label="true 352528"];
3298 [label="considerExplicitlyImplementedInterfaces: true 352529"];
3299 [label="false 352530"];
3300 [label="considerReturnType: false 352531"];
3301 [label="false 352532"];
3302 [label="considerTypeConstraints: false 352533"];
3303 [label="false 352534"];
3304 [label="considerCallingConvention: false 352535"];
3305 [label="false 352536"];
3306 [label="considerRefKindDifferences: false 352537"];
3307 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 352538"];
3308 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352539"];
3309 [label="param MemberSignatureComparer(bool considerName) 352540"];
3310 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352541"];
3311 [label="param MemberSignatureComparer(bool considerReturnType) 352542"];
3312 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352543"];
3313 [label="param MemberSignatureComparer(bool considerCallingConvention) 352544"];
3314 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352545"];
3315 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352546"];
3316 [label="param MemberSignatureComparer(this) 352547"];
3317 [label="_considerName 352548"];
3318 [label="_considerExplicitlyImplementedInterfaces 352549"];
3319 [label="_considerReturnType 352550"];
3320 [label="_considerTypeConstraints 352551"];
3321 [label="_considerCallingConvention 352552"];
3322 [label="_considerRefKindDifferences 352553"];
3323 [label="_typeComparison 352554"];
3324 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352555"];
3325 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352556"];
3326 [label="_considerName 352557"];
3327 [label="_considerExplicitlyImplementedInterfaces 352558"];
3328 [label="_considerReturnType 352559"];
3329 [label="_considerTypeConstraints 352560"];
3330 [label="_considerCallingConvention 352561"];
3331 [label="_considerRefKindDifferences 352562"];
3332 [label="_typeComparison 352563"];
3333 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352564"];
3334 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352565"];
3335 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352566"];
3336 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 352567"];
3337 [label="_typeComparison 352568"];
3338 [label="DuplicateSourceComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352569"];
3339 [label="true 352570"];
3340 [label="considerName: true 352571"];
3341 [label="true 352572"];
3342 [label="considerExplicitlyImplementedInterfaces: true 352573"];
3343 [label="false 352574"];
3344 [label="considerReturnType: false 352575"];
3345 [label="false 352576"];
3346 [label="considerTypeConstraints: false 352577"];
3347 [label="false 352578"];
3348 [label="considerCallingConvention: false 352579"];
3349 [label="true 352580"];
3350 [label="considerRefKindDifferences: true 352581"];
3351 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 352582"];
3352 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352583"];
3353 [label="param MemberSignatureComparer(bool considerName) 352584"];
3354 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352585"];
3355 [label="param MemberSignatureComparer(bool considerReturnType) 352586"];
3356 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352587"];
3357 [label="param MemberSignatureComparer(bool considerCallingConvention) 352588"];
3358 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352589"];
3359 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352590"];
3360 [label="param MemberSignatureComparer(this) 352591"];
3361 [label="_considerName 352592"];
3362 [label="_considerExplicitlyImplementedInterfaces 352593"];
3363 [label="_considerReturnType 352594"];
3364 [label="_considerTypeConstraints 352595"];
3365 [label="_considerCallingConvention 352596"];
3366 [label="_considerRefKindDifferences 352597"];
3367 [label="_typeComparison 352598"];
3368 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352599"];
3369 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352600"];
3370 [label="_considerName 352601"];
3371 [label="_considerExplicitlyImplementedInterfaces 352602"];
3372 [label="_considerReturnType 352603"];
3373 [label="_considerTypeConstraints 352604"];
3374 [label="_considerCallingConvention 352605"];
3375 [label="_considerRefKindDifferences 352606"];
3376 [label="_typeComparison 352607"];
3377 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352608"];
3378 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352609"];
3379 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352610"];
3380 [label="RecordAPISignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352611"];
3381 [label="true 352612"];
3382 [label="considerName: true 352613"];
3383 [label="true 352614"];
3384 [label="considerExplicitlyImplementedInterfaces: true 352615"];
3385 [label="false 352616"];
3386 [label="considerReturnType: false 352617"];
3387 [label="false 352618"];
3388 [label="considerTypeConstraints: false 352619"];
3389 [label="false 352620"];
3390 [label="considerCallingConvention: false 352621"];
3391 [label="true 352622"];
3392 [label="considerRefKindDifferences: true 352623"];
3393 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 352624"];
3394 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352625"];
3395 [label="param MemberSignatureComparer(bool considerName) 352626"];
3396 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352627"];
3397 [label="param MemberSignatureComparer(bool considerReturnType) 352628"];
3398 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352629"];
3399 [label="param MemberSignatureComparer(bool considerCallingConvention) 352630"];
3400 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352631"];
3401 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352632"];
3402 [label="param MemberSignatureComparer(this) 352633"];
3403 [label="_considerName 352634"];
3404 [label="_considerExplicitlyImplementedInterfaces 352635"];
3405 [label="_considerReturnType 352636"];
3406 [label="_considerTypeConstraints 352637"];
3407 [label="_considerCallingConvention 352638"];
3408 [label="_considerRefKindDifferences 352639"];
3409 [label="_typeComparison 352640"];
3410 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352641"];
3411 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352642"];
3412 [label="_considerName 352643"];
3413 [label="_considerExplicitlyImplementedInterfaces 352644"];
3414 [label="_considerReturnType 352645"];
3415 [label="_considerTypeConstraints 352646"];
3416 [label="_considerCallingConvention 352647"];
3417 [label="_considerRefKindDifferences 352648"];
3418 [label="_typeComparison 352649"];
3419 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352650"];
3420 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352651"];
3421 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352652"];
3422 [label="PartialMethodsComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352653"];
3423 [label="true 352654"];
3424 [label="considerName: true 352655"];
3425 [label="false 352656"];
3426 [label="considerExplicitlyImplementedInterfaces: false 352657"];
3427 [label="false 352658"];
3428 [label="considerReturnType: false 352659"];
3429 [label="false 352660"];
3430 [label="considerTypeConstraints: false 352661"];
3431 [label="false 352662"];
3432 [label="considerCallingConvention: false 352663"];
3433 [label="true 352664"];
3434 [label="considerRefKindDifferences: true 352665"];
3435 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 352666"];
3436 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352667"];
3437 [label="param MemberSignatureComparer(bool considerName) 352668"];
3438 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352669"];
3439 [label="param MemberSignatureComparer(bool considerReturnType) 352670"];
3440 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352671"];
3441 [label="param MemberSignatureComparer(bool considerCallingConvention) 352672"];
3442 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352673"];
3443 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352674"];
3444 [label="param MemberSignatureComparer(this) 352675"];
3445 [label="_considerName 352676"];
3446 [label="_considerExplicitlyImplementedInterfaces 352677"];
3447 [label="_considerReturnType 352678"];
3448 [label="_considerTypeConstraints 352679"];
3449 [label="_considerCallingConvention 352680"];
3450 [label="_considerRefKindDifferences 352681"];
3451 [label="_typeComparison 352682"];
3452 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352683"];
3453 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352684"];
3454 [label="_considerName 352685"];
3455 [label="_considerExplicitlyImplementedInterfaces 352686"];
3456 [label="_considerReturnType 352687"];
3457 [label="_considerTypeConstraints 352688"];
3458 [label="_considerCallingConvention 352689"];
3459 [label="_considerRefKindDifferences 352690"];
3460 [label="_typeComparison 352691"];
3461 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352692"];
3462 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352693"];
3463 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352694"];
3464 [label="CSharpOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352695"];
3465 [label="true 352696"];
3466 [label="considerName: true 352697"];
3467 [label="false 352698"];
3468 [label="considerExplicitlyImplementedInterfaces: false 352699"];
3469 [label="true 352700"];
3470 [label="considerReturnType: true 352701"];
3471 [label="false 352702"];
3472 [label="considerTypeConstraints: false 352703"];
3473 [label="false 352704"];
3474 [label="considerCallingConvention: false 352705"];
3475 [label="false 352706"];
3476 [label="considerRefKindDifferences: false 352707"];
3477 [label="TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 352708"];
3478 [label="typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 352709"];
3479 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 352710"];
3480 [label="param MemberSignatureComparer(bool considerName) 352711"];
3481 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352712"];
3482 [label="param MemberSignatureComparer(bool considerReturnType) 352713"];
3483 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352714"];
3484 [label="param MemberSignatureComparer(bool considerCallingConvention) 352715"];
3485 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352716"];
3486 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352717"];
3487 [label="param MemberSignatureComparer(this) 352718"];
3488 [label="_considerName 352719"];
3489 [label="_considerExplicitlyImplementedInterfaces 352720"];
3490 [label="_considerReturnType 352721"];
3491 [label="_considerTypeConstraints 352722"];
3492 [label="_considerCallingConvention 352723"];
3493 [label="_considerRefKindDifferences 352724"];
3494 [label="_typeComparison 352725"];
3495 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352726"];
3496 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352727"];
3497 [label="_considerName 352728"];
3498 [label="_considerExplicitlyImplementedInterfaces 352729"];
3499 [label="_considerReturnType 352730"];
3500 [label="_considerTypeConstraints 352731"];
3501 [label="_considerCallingConvention 352732"];
3502 [label="_considerRefKindDifferences 352733"];
3503 [label="_typeComparison 352734"];
3504 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352735"];
3505 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352736"];
3506 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352737"];
3507 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 352738"];
3508 [label="_typeComparison 352739"];
3509 [label="CSharpWithTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 352740"];
3510 [label="true 352741"];
3511 [label="considerName: true 352742"];
3512 [label="false 352743"];
3513 [label="considerExplicitlyImplementedInterfaces: false 352744"];
3514 [label="true 352745"];
3515 [label="considerReturnType: true 352746"];
3516 [label="false 352747"];
3517 [label="considerTypeConstraints: false 352748"];
3518 [label="false 352749"];
3519 [label="considerCallingConvention: false 352750"];
3520 [label="false 352751"];
3521 [label="considerRefKindDifferences: false 352752"];
3522 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 352753"];
3523 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352754"];
3524 [label="param MemberSignatureComparer(bool considerName) 352755"];
3525 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352756"];
3526 [label="param MemberSignatureComparer(bool considerReturnType) 352757"];
3527 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352758"];
3528 [label="param MemberSignatureComparer(bool considerCallingConvention) 352759"];
3529 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352760"];
3530 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352761"];
3531 [label="param MemberSignatureComparer(this) 352762"];
3532 [label="_considerName 352763"];
3533 [label="_considerExplicitlyImplementedInterfaces 352764"];
3534 [label="_considerReturnType 352765"];
3535 [label="_considerTypeConstraints 352766"];
3536 [label="_considerCallingConvention 352767"];
3537 [label="_considerRefKindDifferences 352768"];
3538 [label="_typeComparison 352769"];
3539 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352770"];
3540 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352771"];
3541 [label="_considerName 352772"];
3542 [label="_considerExplicitlyImplementedInterfaces 352773"];
3543 [label="_considerReturnType 352774"];
3544 [label="_considerTypeConstraints 352775"];
3545 [label="_considerCallingConvention 352776"];
3546 [label="_considerRefKindDifferences 352777"];
3547 [label="_typeComparison 352778"];
3548 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352779"];
3549 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352780"];
3550 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352781"];
3551 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 352782"];
3552 [label="_typeComparison 352783"];
3553 [label="CSharpWithoutTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352784"];
3554 [label="false 352785"];
3555 [label="considerName: false 352786"];
3556 [label="false 352787"];
3557 [label="considerExplicitlyImplementedInterfaces: false 352788"];
3558 [label="false 352789"];
3559 [label="considerReturnType: false 352790"];
3560 [label="false 352791"];
3561 [label="considerTypeConstraints: false 352792"];
3562 [label="false 352793"];
3563 [label="considerCallingConvention: false 352794"];
3564 [label="true 352795"];
3565 [label="considerRefKindDifferences: true 352796"];
3566 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 352797"];
3567 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352798"];
3568 [label="param MemberSignatureComparer(bool considerName) 352799"];
3569 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352800"];
3570 [label="param MemberSignatureComparer(bool considerReturnType) 352801"];
3571 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352802"];
3572 [label="param MemberSignatureComparer(bool considerCallingConvention) 352803"];
3573 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352804"];
3574 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352805"];
3575 [label="param MemberSignatureComparer(this) 352806"];
3576 [label="_considerName 352807"];
3577 [label="_considerExplicitlyImplementedInterfaces 352808"];
3578 [label="_considerReturnType 352809"];
3579 [label="_considerTypeConstraints 352810"];
3580 [label="_considerCallingConvention 352811"];
3581 [label="_considerRefKindDifferences 352812"];
3582 [label="_typeComparison 352813"];
3583 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352814"];
3584 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352815"];
3585 [label="_considerName 352816"];
3586 [label="_considerExplicitlyImplementedInterfaces 352817"];
3587 [label="_considerReturnType 352818"];
3588 [label="_considerTypeConstraints 352819"];
3589 [label="_considerCallingConvention 352820"];
3590 [label="_considerRefKindDifferences 352821"];
3591 [label="_typeComparison 352822"];
3592 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352823"];
3593 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352824"];
3594 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352825"];
3595 [label="CSharpAccessorOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 352826"];
3596 [label="true 352827"];
3597 [label="considerName: true 352828"];
3598 [label="false 352829"];
3599 [label="considerExplicitlyImplementedInterfaces: false 352830"];
3600 [label="true 352831"];
3601 [label="considerReturnType: true 352832"];
3602 [label="false 352833"];
3603 [label="considerTypeConstraints: false 352834"];
3604 [label="false 352835"];
3605 [label="considerCallingConvention: false 352836"];
3606 [label="true 352837"];
3607 [label="considerRefKindDifferences: true 352838"];
3608 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 352839"];
3609 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 352840"];
3610 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 352841"];
3611 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 352842"];
3612 [label="param MemberSignatureComparer(bool considerName) 352843"];
3613 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352844"];
3614 [label="param MemberSignatureComparer(bool considerReturnType) 352845"];
3615 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352846"];
3616 [label="param MemberSignatureComparer(bool considerCallingConvention) 352847"];
3617 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352848"];
3618 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352849"];
3619 [label="param MemberSignatureComparer(this) 352850"];
3620 [label="_considerName 352851"];
3621 [label="_considerExplicitlyImplementedInterfaces 352852"];
3622 [label="_considerReturnType 352853"];
3623 [label="_considerTypeConstraints 352854"];
3624 [label="_considerCallingConvention 352855"];
3625 [label="_considerRefKindDifferences 352856"];
3626 [label="_typeComparison 352857"];
3627 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352858"];
3628 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352859"];
3629 [label="_considerName 352860"];
3630 [label="_considerExplicitlyImplementedInterfaces 352861"];
3631 [label="_considerReturnType 352862"];
3632 [label="_considerTypeConstraints 352863"];
3633 [label="_considerCallingConvention 352864"];
3634 [label="_considerRefKindDifferences 352865"];
3635 [label="_typeComparison 352866"];
3636 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352867"];
3637 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352868"];
3638 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352869"];
3639 [label="CSharpCustomModifierOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 352870"];
3640 [label="false 352871"];
3641 [label="considerName: false 352872"];
3642 [label="false 352873"];
3643 [label="considerExplicitlyImplementedInterfaces: false 352874"];
3644 [label="false 352875"];
3645 [label="considerReturnType: false 352876"];
3646 [label="false 352877"];
3647 [label="considerTypeConstraints: false 352878"];
3648 [label="false 352879"];
3649 [label="considerCallingConvention: false 352880"];
3650 [label="false 352881"];
3651 [label="considerRefKindDifferences: false 352882"];
3652 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 352883"];
3653 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 352884"];
3654 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 352885"];
3655 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 352886"];
3656 [label="param MemberSignatureComparer(bool considerName) 352887"];
3657 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352888"];
3658 [label="param MemberSignatureComparer(bool considerReturnType) 352889"];
3659 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352890"];
3660 [label="param MemberSignatureComparer(bool considerCallingConvention) 352891"];
3661 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352892"];
3662 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352893"];
3663 [label="param MemberSignatureComparer(this) 352894"];
3664 [label="_considerName 352895"];
3665 [label="_considerExplicitlyImplementedInterfaces 352896"];
3666 [label="_considerReturnType 352897"];
3667 [label="_considerTypeConstraints 352898"];
3668 [label="_considerCallingConvention 352899"];
3669 [label="_considerRefKindDifferences 352900"];
3670 [label="_typeComparison 352901"];
3671 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352902"];
3672 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352903"];
3673 [label="_considerName 352904"];
3674 [label="_considerExplicitlyImplementedInterfaces 352905"];
3675 [label="_considerReturnType 352906"];
3676 [label="_considerTypeConstraints 352907"];
3677 [label="_considerCallingConvention 352908"];
3678 [label="_considerRefKindDifferences 352909"];
3679 [label="_typeComparison 352910"];
3680 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352911"];
3681 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352912"];
3682 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352913"];
3683 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 352914"];
3684 [label="_typeComparison 352915"];
3685 [label="SloppyOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 352916"];
3686 [label="true 352917"];
3687 [label="considerName: true 352918"];
3688 [label="false 352919"];
3689 [label="considerExplicitlyImplementedInterfaces: false 352920"];
3690 [label="true 352921"];
3691 [label="considerReturnType: true 352922"];
3692 [label="false 352923"];
3693 [label="considerTypeConstraints: false 352924"];
3694 [label="true 352925"];
3695 [label="considerCallingConvention: true 352926"];
3696 [label="false 352927"];
3697 [label="considerRefKindDifferences: false 352928"];
3698 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 352929"];
3699 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 352930"];
3700 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 352931"];
3701 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 352932"];
3702 [label="param MemberSignatureComparer(bool considerName) 352933"];
3703 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352934"];
3704 [label="param MemberSignatureComparer(bool considerReturnType) 352935"];
3705 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352936"];
3706 [label="param MemberSignatureComparer(bool considerCallingConvention) 352937"];
3707 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352938"];
3708 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352939"];
3709 [label="param MemberSignatureComparer(this) 352940"];
3710 [label="_considerName 352941"];
3711 [label="_considerExplicitlyImplementedInterfaces 352942"];
3712 [label="_considerReturnType 352943"];
3713 [label="_considerTypeConstraints 352944"];
3714 [label="_considerCallingConvention 352945"];
3715 [label="_considerRefKindDifferences 352946"];
3716 [label="_typeComparison 352947"];
3717 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352948"];
3718 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352949"];
3719 [label="_considerName 352950"];
3720 [label="_considerExplicitlyImplementedInterfaces 352951"];
3721 [label="_considerReturnType 352952"];
3722 [label="_considerTypeConstraints 352953"];
3723 [label="_considerCallingConvention 352954"];
3724 [label="_considerRefKindDifferences 352955"];
3725 [label="_typeComparison 352956"];
3726 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352957"];
3727 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 352958"];
3728 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 352959"];
3729 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 352960"];
3730 [label="_typeComparison 352961"];
3731 [label="RuntimeSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 352962"];
3732 [label="true 352963"];
3733 [label="considerName: true 352964"];
3734 [label="false 352965"];
3735 [label="considerExplicitlyImplementedInterfaces: false 352966"];
3736 [label="true 352967"];
3737 [label="considerReturnType: true 352968"];
3738 [label="false 352969"];
3739 [label="considerTypeConstraints: false 352970"];
3740 [label="true 352971"];
3741 [label="considerCallingConvention: true 352972"];
3742 [label="true 352973"];
3743 [label="considerRefKindDifferences: true 352974"];
3744 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 352975"];
3745 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 352976"];
3746 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 352977"];
3747 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 352978"];
3748 [label="param MemberSignatureComparer(bool considerName) 352979"];
3749 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 352980"];
3750 [label="param MemberSignatureComparer(bool considerReturnType) 352981"];
3751 [label="param MemberSignatureComparer(bool considerTypeConstraints) 352982"];
3752 [label="param MemberSignatureComparer(bool considerCallingConvention) 352983"];
3753 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 352984"];
3754 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 352985"];
3755 [label="param MemberSignatureComparer(this) 352986"];
3756 [label="_considerName 352987"];
3757 [label="_considerExplicitlyImplementedInterfaces 352988"];
3758 [label="_considerReturnType 352989"];
3759 [label="_considerTypeConstraints 352990"];
3760 [label="_considerCallingConvention 352991"];
3761 [label="_considerRefKindDifferences 352992"];
3762 [label="_typeComparison 352993"];
3763 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352994"];
3764 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 352995"];
3765 [label="_considerName 352996"];
3766 [label="_considerExplicitlyImplementedInterfaces 352997"];
3767 [label="_considerReturnType 352998"];
3768 [label="_considerTypeConstraints 352999"];
3769 [label="_considerCallingConvention 353000"];
3770 [label="_considerRefKindDifferences 353001"];
3771 [label="_typeComparison 353002"];
3772 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 353003"];
3773 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 353004"];
3774 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 353005"];
3775 [label="RuntimePlusRefOutSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 353006"];
3776 [label="true 353007"];
3777 [label="considerName: true 353008"];
3778 [label="true 353009"];
3779 [label="considerExplicitlyImplementedInterfaces: true 353010"];
3780 [label="true 353011"];
3781 [label="considerReturnType: true 353012"];
3782 [label="false 353013"];
3783 [label="considerTypeConstraints: false 353014"];
3784 [label="true 353015"];
3785 [label="considerCallingConvention: true 353016"];
3786 [label="false 353017"];
3787 [label="considerRefKindDifferences: false 353018"];
3788 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 353019"];
3789 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 353020"];
3790 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 353021"];
3791 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 353022"];
3792 [label="param MemberSignatureComparer(bool considerName) 353023"];
3793 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 353024"];
3794 [label="param MemberSignatureComparer(bool considerReturnType) 353025"];
3795 [label="param MemberSignatureComparer(bool considerTypeConstraints) 353026"];
3796 [label="param MemberSignatureComparer(bool considerCallingConvention) 353027"];
3797 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 353028"];
3798 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 353029"];
3799 [label="param MemberSignatureComparer(this) 353030"];
3800 [label="_considerName 353031"];
3801 [label="_considerExplicitlyImplementedInterfaces 353032"];
3802 [label="_considerReturnType 353033"];
3803 [label="_considerTypeConstraints 353034"];
3804 [label="_considerCallingConvention 353035"];
3805 [label="_considerRefKindDifferences 353036"];
3806 [label="_typeComparison 353037"];
3807 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 353038"];
3808 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 353039"];
3809 [label="_considerName 353040"];
3810 [label="_considerExplicitlyImplementedInterfaces 353041"];
3811 [label="_considerReturnType 353042"];
3812 [label="_considerTypeConstraints 353043"];
3813 [label="_considerCallingConvention 353044"];
3814 [label="_considerRefKindDifferences 353045"];
3815 [label="_typeComparison 353046"];
3816 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 353047"];
3817 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 353048"];
3818 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 353049"];
3819 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 353050"];
3820 [label="_typeComparison 353051"];
3821 [label="RuntimeImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 353052"];
3822 [label="true 353053"];
3823 [label="considerName: true 353054"];
3824 [label="true 353055"];
3825 [label="considerExplicitlyImplementedInterfaces: true 353056"];
3826 [label="true 353057"];
3827 [label="considerReturnType: true 353058"];
3828 [label="true 353059"];
3829 [label="considerTypeConstraints: true 353060"];
3830 [label="true 353061"];
3831 [label="considerCallingConvention: true 353062"];
3832 [label="true 353063"];
3833 [label="considerRefKindDifferences: true 353064"];
3834 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 353065"];
3835 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 353066"];
3836 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 353067"];
3837 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 353068"];
3838 [label="param MemberSignatureComparer(bool considerName) 353069"];
3839 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 353070"];
3840 [label="param MemberSignatureComparer(bool considerReturnType) 353071"];
3841 [label="param MemberSignatureComparer(bool considerTypeConstraints) 353072"];
3842 [label="param MemberSignatureComparer(bool considerCallingConvention) 353073"];
3843 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 353074"];
3844 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 353075"];
3845 [label="param MemberSignatureComparer(this) 353076"];
3846 [label="_considerName 353077"];
3847 [label="_considerExplicitlyImplementedInterfaces 353078"];
3848 [label="_considerReturnType 353079"];
3849 [label="_considerTypeConstraints 353080"];
3850 [label="_considerCallingConvention 353081"];
3851 [label="_considerRefKindDifferences 353082"];
3852 [label="_typeComparison 353083"];
3853 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 353084"];
3854 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 353085"];
3855 [label="_considerName 353086"];
3856 [label="_considerExplicitlyImplementedInterfaces 353087"];
3857 [label="_considerReturnType 353088"];
3858 [label="_considerTypeConstraints 353089"];
3859 [label="_considerCallingConvention 353090"];
3860 [label="_considerRefKindDifferences 353091"];
3861 [label="_typeComparison 353092"];
3862 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 353093"];
3863 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 353094"];
3864 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 353095"];
3865 [label="CSharpSignatureAndConstraintsAndReturnTypeComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 353096"];
3866 [label="true 353097"];
3867 [label="considerName: true 353098"];
3868 [label="false 353099"];
3869 [label="considerExplicitlyImplementedInterfaces: false 353100"];
3870 [label="true 353101"];
3871 [label="considerReturnType: true 353102"];
3872 [label="false 353103"];
3873 [label="considerTypeConstraints: false 353104"];
3874 [label="true 353105"];
3875 [label="considerCallingConvention: true 353106"];
3876 [label="true 353107"];
3877 [label="considerRefKindDifferences: true 353108"];
3878 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 353109"];
3879 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 353110"];
3880 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 353111"];
3881 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 353112"];
3882 [label="param MemberSignatureComparer(bool considerName) 353113"];
3883 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 353114"];
3884 [label="param MemberSignatureComparer(bool considerReturnType) 353115"];
3885 [label="param MemberSignatureComparer(bool considerTypeConstraints) 353116"];
3886 [label="param MemberSignatureComparer(bool considerCallingConvention) 353117"];
3887 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 353118"];
3888 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 353119"];
3889 [label="param MemberSignatureComparer(this) 353120"];
3890 [label="_considerName 353121"];
3891 [label="_considerExplicitlyImplementedInterfaces 353122"];
3892 [label="_considerReturnType 353123"];
3893 [label="_considerTypeConstraints 353124"];
3894 [label="_considerCallingConvention 353125"];
3895 [label="_considerRefKindDifferences 353126"];
3896 [label="_typeComparison 353127"];
3897 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 353128"];
3898 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 353129"];
3899 [label="_considerName 353130"];
3900 [label="_considerExplicitlyImplementedInterfaces 353131"];
3901 [label="_considerReturnType 353132"];
3902 [label="_considerTypeConstraints 353133"];
3903 [label="_considerCallingConvention 353134"];
3904 [label="_considerRefKindDifferences 353135"];
3905 [label="_typeComparison 353136"];
3906 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 353137"];
3907 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 353138"];
3908 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 353139"];
3909 [label="RetargetedExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 353140"];
3910 [label="false 353141"];
3911 [label="considerName: false 353142"];
3912 [label="false 353143"];
3913 [label="considerExplicitlyImplementedInterfaces: false 353144"];
3914 [label="false 353145"];
3915 [label="considerReturnType: false 353146"];
3916 [label="false 353147"];
3917 [label="considerTypeConstraints: false 353148"];
3918 [label="false 353149"];
3919 [label="considerCallingConvention: false 353150"];
3920 [label="true 353151"];
3921 [label="considerRefKindDifferences: true 353152"];
3922 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 353153"];
3923 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 353154"];
3924 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 353155"];
3925 [label="new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 353156"];
3926 [label="param MemberSignatureComparer(bool considerName) 353157"];
3927 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 353158"];
3928 [label="param MemberSignatureComparer(bool considerReturnType) 353159"];
3929 [label="param MemberSignatureComparer(bool considerTypeConstraints) 353160"];
3930 [label="param MemberSignatureComparer(bool considerCallingConvention) 353161"];
3931 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 353162"];
3932 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 353163"];
3933 [label="param MemberSignatureComparer(this) 353164"];
3934 [label="_considerName 353165"];
3935 [label="_considerExplicitlyImplementedInterfaces 353166"];
3936 [label="_considerReturnType 353167"];
3937 [label="_considerTypeConstraints 353168"];
3938 [label="_considerCallingConvention 353169"];
3939 [label="_considerRefKindDifferences 353170"];
3940 [label="_typeComparison 353171"];
3941 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 353172"];
3942 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 353173"];
3943 [label="_considerName 353174"];
3944 [label="_considerExplicitlyImplementedInterfaces 353175"];
3945 [label="_considerReturnType 353176"];
3946 [label="_considerTypeConstraints 353177"];
3947 [label="_considerCallingConvention 353178"];
3948 [label="_considerRefKindDifferences 353179"];
3949 [label="_typeComparison 353180"];
3950 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 353181"];
3951 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 353182"];
3952 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 353183"];
3953 [label="CrefComparer = new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 353184"];
3954 [label="MemberSignatureComparer.RecordAPISignatureComparer 353185"];
3955 [label="PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 353186"];
3956 [label="s_duplicateRecordMemberSignatureDictionary =\n            PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 353187"];
3957 [label="EmptyComparer.Instance 353188"];
3958 [label="new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 353189"];
3959 [label="s_emptyTypeMembers = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 353190"];
3960 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 353191"];
3961 [label="ReportBadReturn =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 353192"];
3962 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 353193"];
3963 [label="ReportBadParameter =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 353194"];
3964 [label="containingSymbol 353195"];
3965 [label="declaration 353196"];
3966 [label="diagnostics 353197"];
3967 [label="tupleData 353198"];
3968 [label="param SourceNamedTypeSymbol(this) 353199"];
3969 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 353200"];
3970 [label="param SourceMemberContainerTypeSymbol(MergedTypeDeclaration declaration) 353201"];
3971 [label="param SourceMemberContainerTypeSymbol(DiagnosticBag diagnostics) 353202"];
3972 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 353203"];
3973 [label="param SourceMemberContainerTypeSymbol(this) 353204"];
3974 [label="tupleData 353205"];
3975 [label="param SourceMemberContainerTypeSymbol(this) 353206"];
3976 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 353207"];
3977 [label="_lazyTupleData 353208"];
3978 [label="_declModifiers 353209"];
3979 [label="_containingSymbol 353210"];
3980 [label="declaration 353211"];
3981 [label="new DeclaredMembersAndInitializers() 353212"];
3982 [label="param DeclaredMembersAndInitializers(this) 353213"];
3983 [label="HaveIndexers 353214"];
3984 [label="RecordDeclarationWithParameters 353215"];
3985 [label="RecordPrimaryConstructor 353216"];
3986 [label="InstanceInitializersIndexForRecordDeclarationWithParameters 353217"];
3987 [label="IsNullableEnabledForInstanceConstructorsAndFields 353218"];
3988 [label="IsNullableEnabledForStaticConstructorsAndFields 353219"];
3989 [label="UninitializedSentinel = new DeclaredMembersAndInitializers() 353220"];
3990 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 353221"];
3991 [label="_lazyMembersAndInitializers 353222"];
3992 [label="_lazyMembersDictionary 353223"];
3993 [label="_lazyEarlyAttributeDecodingMembersDictionary 353224"];
3994 [label="_lazyTypeMembers 353225"];
3995 [label="_lazyKnownCircularStruct 353226"];
3996 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 353227"];
3997 [label="_lazyContainsExtensionMethods 353228"];
3998 [label="_lazyAnyMemberHasAttributes 353229"];
3999 [label="_containingSymbol 353230"];
4000 [label="this.declaration 353231"];
4001 [label="TypeKind typeKind = declaration.Kind.ToTypeKind(); 353232"];
4002 [label="declaration.Kind.ToTypeKind() 353233"];
4003 [label="param ToTypeKind(this DeclarationKind kind) 353234"];
4004 [label="switch (kind)\n            {\n                case DeclarationKind.Class:\n                case DeclarationKind.Script:\n                case DeclarationKind.ImplicitClass:\n                case DeclarationKind.SimpleProgram:\n                case DeclarationKind.Record:\n                    return TypeKind.Class;\n\n                case DeclarationKind.Submission:\n                    return TypeKind.Submission;\n\n                case DeclarationKind.Delegate:\n                    return TypeKind.Delegate;\n\n                case DeclarationKind.Enum:\n                    return TypeKind.Enum;\n\n                case DeclarationKind.Interface:\n                    return TypeKind.Interface;\n\n                case DeclarationKind.Struct:\n                    return TypeKind.Struct;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 353235"];
4005 [label="return TypeKind.Class; 353236"];
4006 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 353237"];
4007 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 353238"];
4008 [label="MakeModifiers(typeKind, diagnostics) 353239"];
4009 [label="param MakeModifiers(TypeKind typeKind) 353240"];
4010 [label="param MakeModifiers(DiagnosticBag diagnostics) 353241"];
4011 [label="param MakeModifiers(this) 353242"];
4012 [label="this.ContainingSymbol 353243"];
4013 [label="get\n            {\n                return _containingSymbol;\n            } 353244"];
4014 [label="return _containingSymbol; 353245"];
4015 [label="Symbol containingSymbol = this.ContainingSymbol; 353246"];
4016 [label="DeclarationModifiers defaultAccess; 353247"];
4017 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 353248"];
4018 [label="containingSymbol.Kind 353249"];
4019 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 353250"];
4020 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 353251"];
4021 [label="defaultAccess = DeclarationModifiers.Internal; 353252"];
4022 [label="switch (typeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Submission:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe;\n\n                    if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    }\n\n                    break;\n                case TypeKind.Struct:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Ref | DeclarationModifiers.ReadOnly | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Interface:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Delegate:\n                    allowedModifiers |= DeclarationModifiers.Unsafe;\n                    break;\n            } 353253"];
4023 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 353254"];
4024 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 353255"];
4025 [label="this.IsRecord 353256"];
4026 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.Record;\n            } 353257"];
4027 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 353258"];
4028 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 353259"];
4029 [label="if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    } 353260"];
4030 [label="allowedModifiers |= DeclarationModifiers.Static; 353261"];
4031 [label="bool modifierErrors; 353262"];
4032 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 353263"];
4033 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 353264"];
4034 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 353265"];
4035 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 353266"];
4036 [label="MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors) 353267"];
4037 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 353268"];
4038 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 353269"];
4039 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 353270"];
4040 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 353271"];
4041 [label="param MakeAndCheckTypeModifiers(this) 353272"];
4042 [label="modifierErrors = false; 353273"];
4043 [label="var result = DeclarationModifiers.Unset; 353274"];
4044 [label="var partCount = declaration.Declarations.Length; 353275"];
4045 [label="var missingPartial = false; 353276"];
4046 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 353277"];
4047 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 353278"];
4048 [label="var decl = declaration.Declarations[i]; 353279"];
4049 [label="var mods = decl.Modifiers; 353280"];
4050 [label="if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                } 353281"];
4051 [label="if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                } 353282"];
4052 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 353283"];
4053 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 353284"];
4054 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 353285"];
4055 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 353286"];
4056 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 353287"];
4057 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 353288"];
4058 [label="ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors) 353289"];
4059 [label="param CheckModifiers(DeclarationModifiers modifiers) 353290"];
4060 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 353291"];
4061 [label="param CheckModifiers(Location errorLocation) 353292"];
4062 [label="param CheckModifiers(DiagnosticBag diagnostics) 353293"];
4063 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 353294"];
4064 [label="param CheckModifiers(out bool modifierErrors) 353295"];
4065 [label="modifierErrors = false; 353296"];
4066 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 353297"];
4067 [label="DeclarationModifiers result = modifiers & allowedModifiers; 353298"];
4068 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 353299"];
4069 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 353300"];
4070 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 353301"];
4071 [label="return result; 353302"];
4072 [label="if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    } 353303"];
4073 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 353304"];
4074 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 353305"];
4075 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 353306"];
4076 [label="ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false) 353307"];
4077 [label="param CheckAccessibility(DeclarationModifiers modifiers) 353308"];
4078 [label="param CheckAccessibility(Symbol symbol) 353309"];
4079 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 353310"];
4080 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 353311"];
4081 [label="IsValidAccessibility(modifiers) 353312"];
4082 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 353313"];
4083 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 353314"];
4084 [label="return true; 353315"];
4085 [label="symbol.Kind 353316"];
4086 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 353317"];
4087 [label="return SymbolKind.NamedType; 353318"];
4088 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 353319"];
4089 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 353320"];
4090 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 353321"];
4091 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 353322"];
4092 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 353323"];
4093 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 353324"];
4094 [label="return null; 353325"];
4095 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 353326"];
4096 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 353327"];
4097 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 353328"];
4098 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 353329"];
4099 [label="result = mods; 353330"];
4100 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 353331"];
4101 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 353332"];
4102 [label="result |= defaultAccess; 353333"];
4103 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 353334"];
4104 [label="this.Name 353335"];
4105 [label="get\n            {\n                return declaration.Name;\n            } 353336"];
4106 [label="return declaration.Name; 353337"];
4107 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 353338"];
4108 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 353339"];
4109 [label="return result; 353340"];
4110 [label="(type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 353341"];
4111 [label="s_hasInvalidTypeParameterFunc =\n            (type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 353342"];
4112 [label="this.CheckUnsafeModifier(mods, diagnostics); 353343"];
4113 [label="this.CheckUnsafeModifier(mods, diagnostics); 353344"];
4114 [label="this.CheckUnsafeModifier(mods, diagnostics); 353345"];
4115 [label="this.CheckUnsafeModifier(mods, diagnostics) 353346"];
4116 [label="param CheckUnsafeModifier(this Symbol symbol) 353347"];
4117 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 353348"];
4118 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 353349"];
4119 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 353350"];
4120 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 353351"];
4121 [label="symbol.Locations 353352"];
4122 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 353353"];
4123 [label="return declaration.NameLocations.Cast<SourceLocation, Location>(); 353354"];
4124 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 353355"];
4125 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 353356"];
4126 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 353357"];
4127 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 353358"];
4128 [label="param CheckUnsafeModifier(this Symbol symbol) 353359"];
4129 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 353360"];
4130 [label="param CheckUnsafeModifier(Location errorLocation) 353361"];
4131 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 353362"];
4132 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 353363"];
4133 [label="this.CheckUnsafeModifier(mods, diagnostics); 353364"];
4134 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 353365"];
4135 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 353366"];
4136 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 353367"];
4137 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 353368"];
4138 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 353369"];
4139 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 353370"];
4140 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 353371"];
4141 [label="return mods; 353372"];
4142 [label="foreach (var singleDeclaration in declaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 353373"];
4143 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 353374"];
4144 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 353375"];
4145 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 353376"];
4146 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 353377"];
4147 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 353378"];
4148 [label="_declModifiers 353379"];
4149 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 353380"];
4150 [label="access == (int)DeclarationModifiers.Public 353381"];
4151 [label="0 353382"];
4152 [label="SpecialTypeOffset = 0 353383"];
4153 [label="6 353384"];
4154 [label="SpecialTypeSize = 6 353385"];
4155 [label="SpecialTypeOffset + SpecialTypeSize 353386"];
4156 [label="ManagedKindOffset = SpecialTypeOffset + SpecialTypeSize 353387"];
4157 [label="2 353388"];
4158 [label="ManagedKindSize = 2 353389"];
4159 [label="ManagedKindOffset + ManagedKindSize 353390"];
4160 [label="FieldDefinitionsNotedOffset = ManagedKindOffset + ManagedKindSize 353391"];
4161 [label="1 353392"];
4162 [label="FieldDefinitionsNotedSize = 1 353393"];
4163 [label="FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 353394"];
4164 [label="FlattenedMembersIsSortedOffset = FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 353395"];
4165 [label="1 353396"];
4166 [label="FlattenedMembersIsSortedSize = 1 353397"];
4167 [label="FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 353398"];
4168 [label="TypeKindOffset = FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 353399"];
4169 [label="4 353400"];
4170 [label="TypeKindSize = 4 353401"];
4171 [label="TypeKindOffset + TypeKindSize 353402"];
4172 [label="NullableContextOffset = TypeKindOffset + TypeKindSize 353403"];
4173 [label="3 353404"];
4174 [label="NullableContextSize = 3 353405"];
4175 [label="1 353406"];
4176 [label="1 << SpecialTypeSize 353407"];
4177 [label="1 353408"];
4178 [label="(1 << SpecialTypeSize) - 1 353409"];
4179 [label="SpecialTypeMask = (1 << SpecialTypeSize) - 1 353410"];
4180 [label="1 353411"];
4181 [label="1 << ManagedKindSize 353412"];
4182 [label="1 353413"];
4183 [label="(1 << ManagedKindSize) - 1 353414"];
4184 [label="ManagedKindMask = (1 << ManagedKindSize) - 1 353415"];
4185 [label="1 353416"];
4186 [label="1 << TypeKindSize 353417"];
4187 [label="1 353418"];
4188 [label="(1 << TypeKindSize) - 1 353419"];
4189 [label="TypeKindMask = (1 << TypeKindSize) - 1 353420"];
4190 [label="1 353421"];
4191 [label="1 << NullableContextSize 353422"];
4192 [label="1 353423"];
4193 [label="(1 << NullableContextSize) - 1 353424"];
4194 [label="NullableContextMask = (1 << NullableContextSize) - 1 353425"];
4195 [label="1 353426"];
4196 [label="1 << FieldDefinitionsNotedOffset 353427"];
4197 [label="FieldDefinitionsNotedBit = 1 << FieldDefinitionsNotedOffset 353428"];
4198 [label="1 353429"];
4199 [label="1 << FlattenedMembersIsSortedOffset 353430"];
4200 [label="FlattenedMembersIsSortedBit = 1 << FlattenedMembersIsSortedOffset 353431"];
4201 [label="Debug.Assert(EnumUtilities.ContainsAllValues<SpecialType>(SpecialTypeMask)); 353432"];
4202 [label="Debug.Assert(EnumUtilities.ContainsAllValues<NullableContextKind>(NullableContextMask)); 353433"];
4203 [label="_flags = new Flags(specialType, typeKind); 353434"];
4204 [label="_flags = new Flags(specialType, typeKind); 353435"];
4205 [label="_flags = new Flags(specialType, typeKind); 353436"];
4206 [label="new Flags(specialType, typeKind) 353437"];
4207 [label="param Flags(SpecialType specialType) 353438"];
4208 [label="param Flags(TypeKind typeKind) 353439"];
4209 [label="param Flags(this) 353440"];
4210 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 353441"];
4211 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 353442"];
4212 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 353443"];
4213 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 353444"];
4214 [label="_flags = specialTypeInt | typeKindInt; 353445"];
4215 [label="_flags 353446"];
4216 [label="_flags 353447"];
4217 [label="this.ContainingType 353448"];
4218 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 353449"];
4219 [label="return _containingSymbol as NamedTypeSymbol; 353450"];
4220 [label="var containingType = this.ContainingType; 353451"];
4221 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 353452"];
4222 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 353453"];
4223 [label="state.NotePartComplete(CompletionPart.TypeArguments); 353454"];
4224 [label="state.NotePartComplete(CompletionPart.TypeArguments) 353455"];
4225 [label="param NotePartComplete(CompletionPart part) 353456"];
4226 [label="param NotePartComplete(this) 353457"];
4227 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 353458"];
4228 [label="_lazyCustomAttributesBag 353459"];
4229 [label="_lazyDocComment 353460"];
4230 [label="_lazyExpandedDocComment 353461"];
4231 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 353462"];
4232 [label="_lazyDeclaredBases 353463"];
4233 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 353464"];
4234 [label="_lazyEnumValueField 353465"];
4235 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 353466"];
4236 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 353467"];
4237 [label="containingSymbol.Kind 353468"];
4238 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 353469"];
4239 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 353470"];
4240 [label="get\n            {\n                return declaration.Name;\n            } 353471"];
4241 [label="return declaration.Name; 353472"];
4242 [label="param BuildSymbol(this) 353473"];
4243 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 353474"];
4244 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 353475"];
4245 [label="containingSymbol 353476"];
4246 [label="tupleData 353477"];
4247 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 353478"];
4248 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 353479"];
4249 [label="tupleData 353480"];
4250 [label="_lazyTupleData 353481"];
4251 [label="_declModifiers 353482"];
4252 [label="_containingSymbol 353483"];
4253 [label="declaration 353484"];
4254 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 353485"];
4255 [label="_lazyMembersAndInitializers 353486"];
4256 [label="_lazyMembersDictionary 353487"];
4257 [label="_lazyEarlyAttributeDecodingMembersDictionary 353488"];
4258 [label="_lazyTypeMembers 353489"];
4259 [label="_lazyKnownCircularStruct 353490"];
4260 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 353491"];
4261 [label="_lazyContainsExtensionMethods 353492"];
4262 [label="_lazyAnyMemberHasAttributes 353493"];
4263 [label="_containingSymbol 353494"];
4264 [label="param MakeModifiers(DiagnosticBag diagnostics) 353495"];
4265 [label="this.ContainingSymbol 353496"];
4266 [label="get\n            {\n                return _containingSymbol;\n            } 353497"];
4267 [label="return _containingSymbol; 353498"];
4268 [label="Symbol containingSymbol = this.ContainingSymbol; 353499"];
4269 [label="DeclarationModifiers defaultAccess; 353500"];
4270 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 353501"];
4271 [label="containingSymbol.Kind 353502"];
4272 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 353503"];
4273 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 353504"];
4274 [label="defaultAccess = DeclarationModifiers.Internal; 353505"];
4275 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 353506"];
4276 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 353507"];
4277 [label="if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    } 353508"];
4278 [label="allowedModifiers |= DeclarationModifiers.Static; 353509"];
4279 [label="bool modifierErrors; 353510"];
4280 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 353511"];
4281 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 353512"];
4282 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 353513"];
4283 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 353514"];
4284 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 353515"];
4285 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 353516"];
4286 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 353517"];
4287 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 353518"];
4288 [label="var result = DeclarationModifiers.Unset; 353519"];
4289 [label="var missingPartial = false; 353520"];
4290 [label="var mods = decl.Modifiers; 353521"];
4291 [label="if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                } 353522"];
4292 [label="ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors) 353523"];
4293 [label="param CheckModifiers(DeclarationModifiers modifiers) 353524"];
4294 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 353525"];
4295 [label="param CheckModifiers(Location errorLocation) 353526"];
4296 [label="param CheckModifiers(DiagnosticBag diagnostics) 353527"];
4297 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 353528"];
4298 [label="param CheckModifiers(out bool modifierErrors) 353529"];
4299 [label="modifierErrors = false; 353530"];
4300 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 353531"];
4301 [label="DeclarationModifiers result = modifiers & allowedModifiers; 353532"];
4302 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 353533"];
4303 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 353534"];
4304 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 353535"];
4305 [label="return result; 353536"];
4306 [label="if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    } 353537"];
4307 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 353538"];
4308 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 353539"];
4309 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 353540"];
4310 [label="ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false) 353541"];
4311 [label="param CheckAccessibility(DeclarationModifiers modifiers) 353542"];
4312 [label="param CheckAccessibility(Symbol symbol) 353543"];
4313 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 353544"];
4314 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 353545"];
4315 [label="IsValidAccessibility(modifiers) 353546"];
4316 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 353547"];
4317 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 353548"];
4318 [label="return true; 353549"];
4319 [label="symbol.Kind 353550"];
4320 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 353551"];
4321 [label="return SymbolKind.NamedType; 353552"];
4322 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 353553"];
4323 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 353554"];
4324 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 353555"];
4325 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 353556"];
4326 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 353557"];
4327 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 353558"];
4328 [label="return null; 353559"];
4329 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 353560"];
4330 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 353561"];
4331 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 353562"];
4332 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 353563"];
4333 [label="result = mods; 353564"];
4334 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 353565"];
4335 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 353566"];
4336 [label="result |= defaultAccess; 353567"];
4337 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 353568"];
4338 [label="this.Name 353569"];
4339 [label="get\n            {\n                return declaration.Name;\n            } 353570"];
4340 [label="return declaration.Name; 353571"];
4341 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 353572"];
4342 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 353573"];
4343 [label="return result; 353574"];
4344 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 353575"];
4345 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 353576"];
4346 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 353577"];
4347 [label="param CheckUnsafeModifier(this Symbol symbol) 353578"];
4348 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 353579"];
4349 [label="param CheckUnsafeModifier(Location errorLocation) 353580"];
4350 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 353581"];
4351 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 353582"];
4352 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 353583"];
4353 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 353584"];
4354 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 353585"];
4355 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 353586"];
4356 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 353587"];
4357 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 353588"];
4358 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 353589"];
4359 [label="return mods; 353590"];
4360 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 353591"];
4361 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 353592"];
4362 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 353593"];
4363 [label="_declModifiers 353594"];
4364 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 353595"];
4365 [label="access == (int)DeclarationModifiers.Public 353596"];
4366 [label="_flags = new Flags(specialType, typeKind); 353597"];
4367 [label="_flags = new Flags(specialType, typeKind); 353598"];
4368 [label="new Flags(specialType, typeKind) 353599"];
4369 [label="param Flags(SpecialType specialType) 353600"];
4370 [label="param Flags(TypeKind typeKind) 353601"];
4371 [label="param Flags(this) 353602"];
4372 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 353603"];
4373 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 353604"];
4374 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 353605"];
4375 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 353606"];
4376 [label="_flags = specialTypeInt | typeKindInt; 353607"];
4377 [label="_flags 353608"];
4378 [label="_flags 353609"];
4379 [label="this.ContainingType 353610"];
4380 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 353611"];
4381 [label="return _containingSymbol as NamedTypeSymbol; 353612"];
4382 [label="var containingType = this.ContainingType; 353613"];
4383 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 353614"];
4384 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 353615"];
4385 [label="state.NotePartComplete(CompletionPart.TypeArguments); 353616"];
4386 [label="state.NotePartComplete(CompletionPart.TypeArguments) 353617"];
4387 [label="param NotePartComplete(CompletionPart part) 353618"];
4388 [label="_lazyCustomAttributesBag 353619"];
4389 [label="_lazyDocComment 353620"];
4390 [label="_lazyExpandedDocComment 353621"];
4391 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 353622"];
4392 [label="_lazyDeclaredBases 353623"];
4393 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 353624"];
4394 [label="_lazyEnumValueField 353625"];
4395 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 353626"];
4396 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 353627"];
4397 [label="containingSymbol.Kind 353628"];
4398 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 353629"];
4399 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 353630"];
4400 [label="get\n            {\n                return declaration.Name;\n            } 353631"];
4401 [label="return declaration.Name; 353632"];
4402 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 353633"];
4403 [label="members 353634"];
4404 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 353635"];
4405 [label="return SymbolKind.NamedType; 353636"];
4406 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 353637"];
4407 [label="members 353638"];
4408 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 353639"];
4409 [label="param CheckMembers(NamespaceSymbol @namespace) 353640"];
4410 [label="param CheckMembers(DiagnosticBag diagnostics) 353641"];
4411 [label="var memberOfArity = new Symbol[10]; 353642"];
4412 [label="MergedNamespaceSymbol mergedAssemblyNamespace = null; 353643"];
4413 [label="@namespace.ContainingAssembly 353644"];
4414 [label="=> _module.ContainingAssembly 353645"];
4415 [label="_module.ContainingAssembly 353646"];
4416 [label="get\n            {\n                return _assemblySymbol;\n            } 353647"];
4417 [label="return _assemblySymbol; 353648"];
4418 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 353649"];
4419 [label="@namespace.ContainingAssembly.Modules 353650"];
4420 [label="get\n            {\n                return _modules;\n            } 353651"];
4421 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 353652"];
4422 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 353653"];
4423 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 353654"];
4424 [label="var nts = symbol as NamedTypeSymbol; 353655"];
4425 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 353656"];
4426 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 353657"];
4427 [label="((object)nts != null) 353658"];
4428 [label="nts.Arity 353659"];
4429 [label="get\n            {\n                return declaration.Arity;\n            } 353660"];
4430 [label="return declaration.Arity; 353661"];
4431 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 353662"];
4432 [label="var other = memberOfArity[arity]; 353663"];
4433 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 353664"];
4434 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 353665"];
4435 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 353666"];
4436 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 353667"];
4437 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 353668"];
4438 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 353669"];
4439 [label="memberOfArity[arity] 353670"];
4440 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 353671"];
4441 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 353672"];
4442 [label="nts.DeclaredAccessibility 353673"];
4443 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 353674"];
4444 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 353675"];
4445 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 353676"];
4446 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 353677"];
4447 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 353678"];
4448 [label="return Accessibility.Internal; 353679"];
4449 [label="Accessibility declaredAccessibility = nts.DeclaredAccessibility; 353680"];
4450 [label="if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        } 353681"];
4451 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 353682"];
4452 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 353683"];
4453 [label="var other = memberOfArity[arity]; 353684"];
4454 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 353685"];
4455 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 353686"];
4456 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 353687"];
4457 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 353688"];
4458 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 353689"];
4459 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 353690"];
4460 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 353691"];
4461 [label="nts.DeclaredAccessibility 353692"];
4462 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 353693"];
4463 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 353694"];
4464 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 353695"];
4465 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 353696"];
4466 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 353697"];
4467 [label="return Accessibility.Internal; 353698"];
4468 [label="Accessibility declaredAccessibility = nts.DeclaredAccessibility; 353699"];
4469 [label="if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        } 353700"];
4470 [label="this.Kind 353701"];
4471 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 353702"];
4472 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 353703"];
4473 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 353704"];
4474 [label="RegisterDeclaredCorTypes() 353705"];
4475 [label="param RegisterDeclaredCorTypes(this) 353706"];
4476 [label="ContainingAssembly 353707"];
4477 [label="=> _module.ContainingAssembly 353708"];
4478 [label="_module.ContainingAssembly 353709"];
4479 [label="get\n            {\n                return _assemblySymbol;\n            } 353710"];
4480 [label="return _assemblySymbol; 353711"];
4481 [label="AssemblySymbol containingAssembly = ContainingAssembly; 353712"];
4482 [label="containingAssembly.KeepLookingForDeclaredSpecialTypes 353713"];
4483 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 353714"];
4484 [label="if (containingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                // Register newly declared COR types\n                foreach (var array in _nameToMembersMap.Values)\n                {\n                    foreach (var member in array)\n                    {\n                        var type = member as NamedTypeSymbol;\n\n                        if ((object)type != null && type.SpecialType != SpecialType.None)\n                        {\n                            containingAssembly.RegisterDeclaredSpecialType(type);\n\n                            if (!containingAssembly.KeepLookingForDeclaredSpecialTypes)\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n            } 353715"];
4485 [label="RegisterDeclaredCorTypes(); 353716"];
4486 [label="Debug.Assert(wasSetThisThread); 353717"];
4487 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 353718"];
4488 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 353719"];
4489 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 353720"];
4490 [label="var bt = (ns1.GetMembers('B').FirstOrDefault() as NamedTypeSymbol).BaseType(); 353721"];
4491 [label="ns1.GetMembers('B') 353722"];
4492 [label="param GetMembers(string name) 353723"];
4493 [label="param GetMembers(this) 353724"];
4494 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 353725"];
4495 [label="members 353726"];
4496 [label="this.GetNameToMembersMap() 353727"];
4497 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 353728"];
4498 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 353729"];
4499 [label="return _nameToMembersMap; 353730"];
4500 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 353731"];
4501 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 353732"];
4502 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 353733"];
4503 [label="(ns1.GetMembers('B').FirstOrDefault() as NamedTypeSymbol).BaseType() 353734"];
4504 [label="param BaseType(this TypeSymbol symbol) 353735"];
4505 [label="symbol.BaseTypeNoUseSiteDiagnostics 353736"];
4506 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 353737"];
4507 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 353738"];
4508 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 353739"];
4509 [label="ContainingType 353740"];
4510 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 353741"];
4511 [label="return _containingSymbol as NamedTypeSymbol; 353742"];
4512 [label="if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    } 353743"];
4513 [label="if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    } 353744"];
4514 [label="var diagnostics = DiagnosticBag.GetInstance(); 353745"];
4515 [label="var acyclicBase = this.MakeAcyclicBaseType(diagnostics); 353746"];
4516 [label="this.MakeAcyclicBaseType(diagnostics) 353747"];
4517 [label="param MakeAcyclicBaseType(DiagnosticBag diagnostics) 353748"];
4518 [label="param MakeAcyclicBaseType(this) 353749"];
4519 [label="this.TypeKind 353750"];
4520 [label="get\n            {\n                return _flags.TypeKind;\n            } 353751"];
4521 [label="_flags.TypeKind 353752"];
4522 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 353753"];
4523 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 353754"];
4524 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 353755"];
4525 [label="return _flags.TypeKind; 353756"];
4526 [label="var typeKind = this.TypeKind; 353757"];
4527 [label="this.DeclaringCompilation 353758"];
4528 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 353759"];
4529 [label="this.Kind 353760"];
4530 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 353761"];
4531 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 353762"];
4532 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 353763"];
4533 [label="this.ContainingSymbol 353764"];
4534 [label="get\n            {\n                return _containingSymbol;\n            } 353765"];
4535 [label="return _containingSymbol; 353766"];
4536 [label="var container = this.ContainingSymbol; 353767"];
4537 [label="return (object)container != null ? container.ContainingModule : null; 353768"];
4538 [label="return (object)container != null ? container.ContainingModule : null; 353769"];
4539 [label="(object)container != null 353770"];
4540 [label="container.ContainingModule 353771"];
4541 [label="var compilation = this.DeclaringCompilation; 353772"];
4542 [label="NamedTypeSymbol declaredBase; 353773"];
4543 [label="if (typeKind == TypeKind.Enum)\n            {\n                Debug.Assert((object)GetDeclaredBaseType(basesBeingResolved: null) == null, 'Computation skipped for enums');\n                declaredBase = compilation.GetSpecialType(SpecialType.System_Enum);\n            }\n            else\n            {\n                declaredBase = GetDeclaredBaseType(basesBeingResolved: null);\n            } 353774"];
4544 [label="declaredBase = GetDeclaredBaseType(basesBeingResolved: null); 353775"];
4545 [label="GetDeclaredBaseType(basesBeingResolved: null) 353776"];
4546 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 353777"];
4547 [label="param GetDeclaredBaseType(this) 353778"];
4548 [label="return GetDeclaredBases(basesBeingResolved).Item1; 353779"];
4549 [label="GetDeclaredBases(basesBeingResolved) 353780"];
4550 [label="param GetDeclaredBases(ConsList<TypeSymbol> basesBeingResolved) 353781"];
4551 [label="param GetDeclaredBases(this) 353782"];
4552 [label="if (ReferenceEquals(_lazyDeclaredBases, null))\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 353783"];
4553 [label="if (ReferenceEquals(_lazyDeclaredBases, null))\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 353784"];
4554 [label="var diagnostics = DiagnosticBag.GetInstance(); 353785"];
4555 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 353786"];
4556 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 353787"];
4557 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 353788"];
4558 [label="MakeDeclaredBases(basesBeingResolved, diagnostics) 353789"];
4559 [label="param MakeDeclaredBases(ConsList<TypeSymbol> basesBeingResolved) 353790"];
4560 [label="param MakeDeclaredBases(DiagnosticBag diagnostics) 353791"];
4561 [label="param MakeDeclaredBases(this) 353792"];
4562 [label="this.TypeKind 353793"];
4563 [label="get\n            {\n                return _flags.TypeKind;\n            } 353794"];
4564 [label="if (this.TypeKind == TypeKind.Enum)\n            {\n                // Handled by GetEnumUnderlyingType().\n                return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(null, ImmutableArray<NamedTypeSymbol>.Empty);\n            } 353795"];
4565 [label="var reportedPartialConflict = false; 353796"];
4566 [label="Debug.Assert(basesBeingResolved == null || !basesBeingResolved.ContainsReference(this.OriginalDefinition)); 353797"];
4567 [label="Debug.Assert(basesBeingResolved == null || !basesBeingResolved.ContainsReference(this.OriginalDefinition)); 353798"];
4568 [label="var newBasesBeingResolved = basesBeingResolved.Prepend(this.OriginalDefinition); 353799"];
4569 [label="this.OriginalDefinition 353800"];
4570 [label="get\n            {\n                return this;\n            } 353801"];
4571 [label="return this; 353802"];
4572 [label="var newBasesBeingResolved = basesBeingResolved.Prepend(this.OriginalDefinition); 353803"];
4573 [label="var newBasesBeingResolved = basesBeingResolved.Prepend(this.OriginalDefinition); 353804"];
4574 [label="var baseInterfaces = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 353805"];
4575 [label="NamedTypeSymbol baseType = null; 353806"];
4576 [label="SourceLocation baseTypeLocation = null; 353807"];
4577 [label="SpecializedSymbolCollections.GetPooledSymbolDictionaryInstance<NamedTypeSymbol, SourceLocation>() 353808"];
4578 [label="SymbolEqualityComparer.ConsiderEverything 353809"];
4579 [label="PooledDictionary<TSymbol, V>.CreatePool(SymbolEqualityComparer.ConsiderEverything) 353810"];
4580 [label="s_poolInstance = PooledDictionary<TSymbol, V>.CreatePool(SymbolEqualityComparer.ConsiderEverything) 353811"];
4581 [label="var instance = PooledSymbolDictionary<KSymbol, V>.s_poolInstance.Allocate(); 353812"];
4582 [label="Debug.Assert(instance.Count == 0); 353813"];
4583 [label="Debug.Assert(instance.Count == 0); 353814"];
4584 [label="return instance; 353815"];
4585 [label="var interfaceLocations = SpecializedSymbolCollections.GetPooledSymbolDictionaryInstance<NamedTypeSymbol, SourceLocation>(); 353816"];
4586 [label="foreach (var decl in this.declaration.Declarations)\n            {\n                Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics);\n                if ((object)one == null) continue;\n\n                var partBase = one.Item1;\n                var partInterfaces = one.Item2;\n                if (!reportedPartialConflict)\n                {\n                    if ((object)baseType == null)\n                    {\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if (baseType.TypeKind == TypeKind.Error && (object)partBase != null)\n                    {\n                        // if the old base was an error symbol, copy it to the interfaces list so it doesn't get lost\n                        partInterfaces = partInterfaces.Add(baseType);\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if ((object)partBase != null && !TypeSymbol.Equals(partBase, baseType, TypeCompareKind.ConsiderEverything2) && partBase.TypeKind != TypeKind.Error)\n                    {\n                        // the parts do not agree\n                        var info = diagnostics.Add(ErrorCode.ERR_PartialMultipleBases, Locations[0], this);\n                        baseType = new ExtendedErrorTypeSymbol(baseType, LookupResultKind.Ambiguous, info);\n                        baseTypeLocation = decl.NameLocation;\n                        reportedPartialConflict = true;\n                    }\n                }\n\n                foreach (var t in partInterfaces)\n                {\n                    if (!interfaceLocations.ContainsKey(t))\n                    {\n                        baseInterfaces.Add(t);\n                        interfaceLocations.Add(t, decl.NameLocation);\n                    }\n                }\n            } 353817"];
4587 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 353818"];
4588 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 353819"];
4589 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 353820"];
4590 [label="MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics) 353821"];
4591 [label="param MakeOneDeclaredBases(ConsList<TypeSymbol> newBasesBeingResolved) 353822"];
4592 [label="param MakeOneDeclaredBases(SingleTypeDeclaration decl) 353823"];
4593 [label="param MakeOneDeclaredBases(DiagnosticBag diagnostics) 353824"];
4594 [label="param MakeOneDeclaredBases(this) 353825"];
4595 [label="BaseListSyntax bases = GetBaseListOpt(decl); 353826"];
4596 [label="GetBaseListOpt(decl) 353827"];
4597 [label="param GetBaseListOpt(SingleTypeDeclaration decl) 353828"];
4598 [label="if (decl.HasBaseDeclarations)\n            {\n                var typeDeclaration = (BaseTypeDeclarationSyntax)decl.SyntaxReference.GetSyntax();\n                return typeDeclaration.BaseList;\n            } 353829"];
4599 [label="var typeDeclaration = (BaseTypeDeclarationSyntax)decl.SyntaxReference.GetSyntax(); 353830"];
4600 [label="return typeDeclaration.BaseList; 353831"];
4601 [label="if (bases == null)\n            {\n                return null;\n            } 353832"];
4602 [label="if (bases == null)\n            {\n                return null;\n            } 353833"];
4603 [label="NamedTypeSymbol localBase = null; 353834"];
4604 [label="var localInterfaces = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 353835"];
4605 [label="this.DeclaringCompilation 353836"];
4606 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 353837"];
4607 [label="this.Kind 353838"];
4608 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 353839"];
4609 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 353840"];
4610 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 353841"];
4611 [label="this.ContainingSymbol 353842"];
4612 [label="get\n            {\n                return _containingSymbol;\n            } 353843"];
4613 [label="return _containingSymbol; 353844"];
4614 [label="var container = this.ContainingSymbol; 353845"];
4615 [label="return (object)container != null ? container.ContainingModule : null; 353846"];
4616 [label="return (object)container != null ? container.ContainingModule : null; 353847"];
4617 [label="(object)container != null 353848"];
4618 [label="container.ContainingModule 353849"];
4619 [label="var baseBinder = this.DeclaringCompilation.GetBinder(bases); 353850"];
4620 [label="var baseBinder = this.DeclaringCompilation.GetBinder(bases); 353851"];
4621 [label="this.DeclaringCompilation.GetBinder(bases) 353852"];
4622 [label="param GetBinder(CSharpSyntaxNode syntax) 353853"];
4623 [label="param GetBinder(this) 353854"];
4624 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 353855"];
4625 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 353856"];
4626 [label="GetBinderFactory(syntax.SyntaxTree) 353857"];
4627 [label="param GetBinderFactory(SyntaxTree syntaxTree) 353858"];
4628 [label="param GetBinderFactory(bool ignoreAccessibility = false) 353859"];
4629 [label="param GetBinderFactory(this) 353860"];
4630 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 353861"];
4631 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 353862"];
4632 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 353863"];
4633 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 353864"];
4634 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 353865"];
4635 [label="param GetBinderFactory(SyntaxTree syntaxTree) 353866"];
4636 [label="param GetBinderFactory(bool ignoreAccessibility) 353867"];
4637 [label="param GetBinderFactory(ref WeakReference<BinderFactory>[]? cachedBinderFactories) 353868"];
4638 [label="param GetBinderFactory(this) 353869"];
4639 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 353870"];
4640 [label="ignoreAccessibility 353871"];
4641 [label="_binderFactories 353872"];
4642 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 353873"];
4643 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 353874"];
4644 [label="var treeNum = GetSyntaxTreeOrdinal(syntaxTree); 353875"];
4645 [label="GetSyntaxTreeOrdinal(syntaxTree) 353876"];
4646 [label="param GetSyntaxTreeOrdinal(SyntaxTree tree) 353877"];
4647 [label="param GetSyntaxTreeOrdinal(this) 353878"];
4648 [label="Debug.Assert(this.ContainsSyntaxTree(tree)); 353879"];
4649 [label="this.ContainsSyntaxTree(tree) 353880"];
4650 [label="param ContainsSyntaxTree(SyntaxTree? syntaxTree) 353881"];
4651 [label="param ContainsSyntaxTree(this) 353882"];
4652 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 353883"];
4653 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 353884"];
4654 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 353885"];
4655 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 353886"];
4656 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 353887"];
4657 [label="return _syntaxAndDeclarations.GetLazyState().OrdinalMap[tree]; 353888"];
4658 [label="WeakReference<BinderFactory>[]? binderFactories = cachedBinderFactories; 353889"];
4659 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 353890"];
4660 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 353891"];
4661 [label="this.SyntaxTrees 353892"];
4662 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 353893"];
4663 [label="binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length]; 353894"];
4664 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 353895"];
4665 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 353896"];
4666 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 353897"];
4667 [label="BinderFactory? previousFactory; 353898"];
4668 [label="var previousWeakReference = binderFactories[treeNum]; 353899"];
4669 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 353900"];
4670 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 353901"];
4671 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 353902"];
4672 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 353903"];
4673 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 353904"];
4674 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 353905"];
4675 [label="param AddNewFactory(SyntaxTree syntaxTree) 353906"];
4676 [label="param AddNewFactory(bool ignoreAccessibility) 353907"];
4677 [label="param AddNewFactory([NotNull] ref WeakReference<BinderFactory>? slot) 353908"];
4678 [label="param AddNewFactory(this) 353909"];
4679 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 353910"];
4680 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 353911"];
4681 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 353912"];
4682 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 353913"];
4683 [label="new BinderFactory(this, syntaxTree, ignoreAccessibility) 353914"];
4684 [label="param BinderFactory(CSharpCompilation compilation) 353915"];
4685 [label="param BinderFactory(SyntaxTree syntaxTree) 353916"];
4686 [label="param BinderFactory(bool ignoreAccessibility) 353917"];
4687 [label="param BinderFactory(this) 353918"];
4688 [label="_binderCache 353919"];
4689 [label="_compilation 353920"];
4690 [label="_syntaxTree 353921"];
4691 [label="_buckStopsHereBinder 353922"];
4692 [label="_ignoreAccessibility 353923"];
4693 [label="_binderFactoryVisitorPool 353924"];
4694 [label="_compilation 353925"];
4695 [label="_syntaxTree 353926"];
4696 [label="_ignoreAccessibility 353927"];
4697 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 353928"];
4698 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 353929"];
4699 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 353930"];
4700 [label="_binderFactoryVisitorPool 353931"];
4701 [label="_binderCache = new ConcurrentCache<BinderCacheKey, Binder>(50); 353932"];
4702 [label="_binderCache 353933"];
4703 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 353934"];
4704 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 353935"];
4705 [label="new BuckStopsHereBinder(compilation) 353936"];
4706 [label="param BuckStopsHereBinder(CSharpCompilation compilation) 353937"];
4707 [label="param BuckStopsHereBinder(this) 353938"];
4708 [label="0 353939"];
4709 [label="ExternalScope = 0 353940"];
4710 [label="1 353941"];
4711 [label="TopLevelScope = 1 353942"];
4712 [label="2 353943"];
4713 [label="ValueKindInsignificantBits = 2 353944"];
4714 [label="ValueKindSignificantBitsMask = unchecked((BindValueKind)~((1 << ValueKindInsignificantBits) - 1)) 353945"];
4715 [label="property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 353946"];
4716 [label="s_isIndexedPropertyWithNonOptionalArguments = property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 353947"];
4717 [label="globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted 353948"];
4718 [label="memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType 353949"];
4719 [label="SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 353950"];
4720 [label="miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 353951"];
4721 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 353952"];
4722 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 353953"];
4723 [label="s_propertyGroupFormat =\n            new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 353954"];
4724 [label="10 353955"];
4725 [label="MaxParameterListsForErrorRecovery = 10 353956"];
4726 [label="'<>h__TransparentIdentifier' 353957"];
4727 [label="transparentIdentifierPrefix = '<>h__TransparentIdentifier' 353958"];
4728 [label="s => (MethodSymbol)s 353959"];
4729 [label="s_toMethodSymbolFunc = s => (MethodSymbol)s 353960"];
4730 [label="s => (PropertySymbol)s 353961"];
4731 [label="s_toPropertySymbolFunc = s => (PropertySymbol)s 353962"];
4732 [label="compilation 353963"];
4733 [label="param BuckStopsHereBinder(this) 353964"];
4734 [label="param Binder(CSharpCompilation compilation) 353965"];
4735 [label="param Binder(this) 353966"];
4736 [label="internal CSharpCompilation Compilation { get; } 353967"];
4737 [label="Flags 353968"];
4738 [label="protected internal Binder? Next { get; } 353969"];
4739 [label="_lazyConversions 353970"];
4740 [label="_lazyOverloadResolution 353971"];
4741 [label="RoslynDebug.Assert(compilation != null); 353972"];
4742 [label="RoslynDebug.Assert(compilation != null); 353973"];
4743 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 353974"];
4744 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 353975"];
4745 [label="compilation.Options 353976"];
4746 [label="get\n            {\n                return _options;\n            } 353977"];
4747 [label="return _options; 353978"];
4748 [label="this.Flags = compilation.Options.TopLevelBinderFlags; 353979"];
4749 [label="this.Flags 353980"];
4750 [label="this.Compilation 353981"];
4751 [label="_buckStopsHereBinder 353982"];
4752 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 353983"];
4753 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 353984"];
4754 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 353985"];
4755 [label="BinderFactory? previousFactory; 353986"];
4756 [label="WeakReference<BinderFactory>? previousWeakReference = slot; 353987"];
4757 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 353988"];
4758 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 353989"];
4759 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 353990"];
4760 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 353991"];
4761 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 353992"];
4762 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 353993"];
4763 [label="return newFactory; 353994"];
4764 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 353995"];
4765 [label="GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax) 353996"];
4766 [label="param GetBinder(SyntaxNode node) 353997"];
4767 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 353998"];
4768 [label="param GetBinder(Symbol memberOpt = null) 353999"];
4769 [label="param GetBinder(this) 354000"];
4770 [label="int position = node.SpanStart; 354001"];
4771 [label="InScript 354002"];
4772 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 354003"];
4773 [label="return _syntaxTree.Options.Kind == SourceCodeKind.Script; 354004"];
4774 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 354005"];
4775 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 354006"];
4776 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 354007"];
4777 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 354008"];
4778 [label="node = node.Parent; 354009"];
4779 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 354010"];
4780 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 354011"];
4781 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 354012"];
4782 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 354013"];
4783 [label="GetBinder(node, position, memberDeclarationOpt, memberOpt) 354014"];
4784 [label="param GetBinder(SyntaxNode node) 354015"];
4785 [label="param GetBinder(int position) 354016"];
4786 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 354017"];
4787 [label="param GetBinder(Symbol memberOpt = null) 354018"];
4788 [label="param GetBinder(this) 354019"];
4789 [label="Debug.Assert(node != null); 354020"];
4790 [label="Debug.Assert(node != null); 354021"];
4791 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 354022"];
4792 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 354023"];
4793 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 354024"];
4794 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 354025"];
4795 [label="param BinderFactoryVisitor(BinderFactory factory) 354026"];
4796 [label="param BinderFactoryVisitor(this) 354027"];
4797 [label="param BinderFactoryVisitor(this) 354028"];
4798 [label="_position 354029"];
4799 [label="_memberDeclarationOpt 354030"];
4800 [label="_memberOpt 354031"];
4801 [label="_factory 354032"];
4802 [label="_factory 354033"];
4803 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 354034"];
4804 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 354035"];
4805 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 354036"];
4806 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 354037"];
4807 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt) 354038"];
4808 [label="param Initialize(int position) 354039"];
4809 [label="param Initialize(CSharpSyntaxNode memberDeclarationOpt) 354040"];
4810 [label="param Initialize(Symbol memberOpt) 354041"];
4811 [label="param Initialize(this) 354042"];
4812 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 354043"];
4813 [label="memberDeclarationOpt == null 354044"];
4814 [label="param ==(Symbol left) 354045"];
4815 [label="param ==(Symbol right) 354046"];
4816 [label="if (right is null)\n            {\n                return left is null;\n            } 354047"];
4817 [label="return left is null; 354048"];
4818 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 354049"];
4819 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 354050"];
4820 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 354051"];
4821 [label="_position 354052"];
4822 [label="_memberDeclarationOpt 354053"];
4823 [label="_memberOpt 354054"];
4824 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 354055"];
4825 [label="Binder result = visitor.Visit(node); 354056"];
4826 [label="visitor.Visit(node) 354057"];
4827 [label="param Visit(SyntaxNode node) 354058"];
4828 [label="param Visit(this) 354059"];
4829 [label="return VisitCore(node); 354060"];
4830 [label="VisitCore(node) 354061"];
4831 [label="param VisitCore(SyntaxNode node) 354062"];
4832 [label="param VisitCore(this) 354063"];
4833 [label="return ((CSharpSyntaxNode)node).Accept(this); 354064"];
4834 [label="return ((CSharpSyntaxNode)node).Accept(this); 354065"];
4835 [label="return ((CSharpSyntaxNode)node).Accept(this); 354066"];
4836 [label="param VisitClassDeclaration(ClassDeclarationSyntax node) 354067"];
4837 [label="param VisitClassDeclaration(this) 354068"];
4838 [label="return VisitTypeDeclarationCore(node); 354069"];
4839 [label="VisitTypeDeclarationCore(node) 354070"];
4840 [label="param VisitTypeDeclarationCore(TypeDeclarationSyntax parent) 354071"];
4841 [label="param VisitTypeDeclarationCore(this) 354072"];
4842 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 354073"];
4843 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 354074"];
4844 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 354075"];
4845 [label="NodeUsage extraInfo = NodeUsage.Normal; 354076"];
4846 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 354077"];
4847 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 354078"];
4848 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 354079"];
4849 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 354080"];
4850 [label="if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 354081"];
4851 [label="if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 354082"];
4852 [label="if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 354083"];
4853 [label="if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 354084"];
4854 [label="extraInfo = NodeUsage.NamedTypeBaseListOrParameterList; 354085"];
4855 [label="return VisitTypeDeclarationCore(parent, extraInfo); 354086"];
4856 [label="return VisitTypeDeclarationCore(parent, extraInfo); 354087"];
4857 [label="VisitTypeDeclarationCore(parent, extraInfo) 354088"];
4858 [label="param VisitTypeDeclarationCore(TypeDeclarationSyntax parent) 354089"];
4859 [label="param VisitTypeDeclarationCore(NodeUsage extraInfo) 354090"];
4860 [label="param VisitTypeDeclarationCore(this) 354091"];
4861 [label="var key = CreateBinderCacheKey(parent, extraInfo); 354092"];
4862 [label="var key = CreateBinderCacheKey(parent, extraInfo); 354093"];
4863 [label="CreateBinderCacheKey(parent, extraInfo) 354094"];
4864 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 354095"];
4865 [label="param CreateBinderCacheKey(NodeUsage usage) 354096"];
4866 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 354097"];
4867 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 354098"];
4868 [label="return new BinderCacheKey(node, usage); 354099"];
4869 [label="return new BinderCacheKey(node, usage); 354100"];
4870 [label="return new BinderCacheKey(node, usage); 354101"];
4871 [label="new BinderCacheKey(node, usage) 354102"];
4872 [label="param BinderCacheKey(CSharpSyntaxNode syntaxNode) 354103"];
4873 [label="param BinderCacheKey(NodeUsage usage) 354104"];
4874 [label="param BinderCacheKey(this) 354105"];
4875 [label="this.syntaxNode 354106"];
4876 [label="this.usage 354107"];
4877 [label="var key = CreateBinderCacheKey(parent, extraInfo); 354108"];
4878 [label="Binder resultBinder; 354109"];
4879 [label="binderCache 354110"];
4880 [label="get\n                {\n                    return _factory._binderCache;\n                } 354111"];
4881 [label="return _factory._binderCache; 354112"];
4882 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 354113"];
4883 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 354114"];
4884 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 354115"];
4885 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 354116"];
4886 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 354117"];
4887 [label="param GetHashCode(this) 354118"];
4888 [label="return Hash.Combine(syntaxNode.GetHashCode(), (int)usage); 354119"];
4889 [label="resultBinder = VisitCore(parent.Parent); 354120"];
4890 [label="VisitCore(parent.Parent) 354121"];
4891 [label="param VisitCore(SyntaxNode node) 354122"];
4892 [label="param VisitNamespaceDeclaration(NamespaceDeclarationSyntax parent) 354123"];
4893 [label="param VisitNamespaceDeclaration(this) 354124"];
4894 [label="if (!LookupPosition.IsInNamespaceDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 354125"];
4895 [label="if (!LookupPosition.IsInNamespaceDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 354126"];
4896 [label="if (!LookupPosition.IsInNamespaceDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 354127"];
4897 [label="bool inBody = LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken); 354128"];
4898 [label="bool inBody = LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken); 354129"];
4899 [label="bool inUsing = IsInUsing(parent); 354130"];
4900 [label="IsInUsing(parent) 354131"];
4901 [label="param IsInUsing(CSharpSyntaxNode containingNode) 354132"];
4902 [label="param IsInUsing(this) 354133"];
4903 [label="TextSpan containingSpan = containingNode.Span; 354134"];
4904 [label="SyntaxToken token; 354135"];
4905 [label="token 354136"];
4906 [label="if (containingNode.Kind() != SyntaxKind.CompilationUnit && _position == containingSpan.End)\n                {\n                    // This occurs at EOF\n                    token = containingNode.GetLastToken();\n                    Debug.Assert(token == this.syntaxTree.GetRoot().GetLastToken());\n                }\n                else if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 354137"];
4907 [label="if (containingNode.Kind() != SyntaxKind.CompilationUnit && _position == containingSpan.End)\n                {\n                    // This occurs at EOF\n                    token = containingNode.GetLastToken();\n                    Debug.Assert(token == this.syntaxTree.GetRoot().GetLastToken());\n                }\n                else if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 354138"];
4908 [label="if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 354139"];
4909 [label="token = containingNode.FindToken(_position); 354140"];
4910 [label="token = containingNode.FindToken(_position); 354141"];
4911 [label="var node = token.Parent; 354142"];
4912 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 354143"];
4913 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 354144"];
4914 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 354145"];
4915 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 354146"];
4916 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 354147"];
4917 [label="node = node.Parent; 354148"];
4918 [label="return false; 354149"];
4919 [label="bool inUsing = IsInUsing(parent); 354150"];
4920 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 354151"];
4921 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 354152"];
4922 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 354153"];
4923 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 354154"];
4924 [label="VisitNamespaceDeclaration(parent, _position, inBody, inUsing) 354155"];
4925 [label="param VisitNamespaceDeclaration(NamespaceDeclarationSyntax parent) 354156"];
4926 [label="param VisitNamespaceDeclaration(int position) 354157"];
4927 [label="param VisitNamespaceDeclaration(bool inBody) 354158"];
4928 [label="param VisitNamespaceDeclaration(bool inUsing) 354159"];
4929 [label="param VisitNamespaceDeclaration(this) 354160"];
4930 [label="Debug.Assert(!inUsing || inBody, 'inUsing => inBody'); 354161"];
4931 [label="Debug.Assert(!inUsing || inBody, 'inUsing => inBody'); 354162"];
4932 [label="inUsing 354163"];
4933 [label="inBody 354164"];
4934 [label="var extraInfo = inUsing ? NodeUsage.NamespaceUsings : (inBody ? NodeUsage.NamespaceBody : NodeUsage.Normal); 354165"];
4935 [label="var key = CreateBinderCacheKey(parent, extraInfo); 354166"];
4936 [label="var key = CreateBinderCacheKey(parent, extraInfo); 354167"];
4937 [label="CreateBinderCacheKey(parent, extraInfo) 354168"];
4938 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 354169"];
4939 [label="param CreateBinderCacheKey(NodeUsage usage) 354170"];
4940 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 354171"];
4941 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 354172"];
4942 [label="var key = CreateBinderCacheKey(parent, extraInfo); 354173"];
4943 [label="Binder result; 354174"];
4944 [label="binderCache 354175"];
4945 [label="get\n                {\n                    return _factory._binderCache;\n                } 354176"];
4946 [label="return _factory._binderCache; 354177"];
4947 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 354178"];
4948 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 354179"];
4949 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 354180"];
4950 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 354181"];
4951 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 354182"];
4952 [label="Binder outer; 354183"];
4953 [label="var container = parent.Parent; 354184"];
4954 [label="InScript 354185"];
4955 [label="get\n                {\n                    return _factory.InScript;\n                } 354186"];
4956 [label="_factory.InScript 354187"];
4957 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 354188"];
4958 [label="return _factory.InScript; 354189"];
4959 [label="if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    } 354190"];
4960 [label="outer = _factory.GetBinder(parent.Parent, position); 354191"];
4961 [label="outer = _factory.GetBinder(parent.Parent, position); 354192"];
4962 [label="outer = _factory.GetBinder(parent.Parent, position); 354193"];
4963 [label="_factory.GetBinder(parent.Parent, position) 354194"];
4964 [label="param GetBinder(SyntaxNode node) 354195"];
4965 [label="param GetBinder(int position) 354196"];
4966 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 354197"];
4967 [label="param GetBinder(Symbol memberOpt = null) 354198"];
4968 [label="Debug.Assert(node != null); 354199"];
4969 [label="Debug.Assert(node != null); 354200"];
4970 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 354201"];
4971 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 354202"];
4972 [label="memberDeclarationOpt == null 354203"];
4973 [label="param ==(Symbol left) 354204"];
4974 [label="param ==(Symbol right) 354205"];
4975 [label="if (right is null)\n            {\n                return left is null;\n            } 354206"];
4976 [label="return left is null; 354207"];
4977 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 354208"];
4978 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 354209"];
4979 [label="param VisitCompilationUnit(CompilationUnitSyntax parent) 354210"];
4980 [label="param VisitCompilationUnit(this) 354211"];
4981 [label="return VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript); 354212"];
4982 [label="IsInUsing(parent) 354213"];
4983 [label="param IsInUsing(CSharpSyntaxNode containingNode) 354214"];
4984 [label="param IsInUsing(this) 354215"];
4985 [label="SyntaxToken token; 354216"];
4986 [label="token 354217"];
4987 [label="if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 354218"];
4988 [label="return VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript); 354219"];
4989 [label="InScript 354220"];
4990 [label="get\n                {\n                    return _factory.InScript;\n                } 354221"];
4991 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 354222"];
4992 [label="VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript) 354223"];
4993 [label="param VisitCompilationUnit(CompilationUnitSyntax compilationUnit) 354224"];
4994 [label="param VisitCompilationUnit(bool inUsing) 354225"];
4995 [label="param VisitCompilationUnit(bool inScript) 354226"];
4996 [label="param VisitCompilationUnit(this) 354227"];
4997 [label="syntaxTree 354228"];
4998 [label="get\n                {\n                    return _factory._syntaxTree;\n                } 354229"];
4999 [label="return _factory._syntaxTree; 354230"];
5000 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 354231"];
5001 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 354232"];
5002 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 354233"];
5003 [label="inUsing 354234"];
5004 [label="inScript 354235"];
5005 [label="var extraInfo = inUsing\n                    ? (inScript ? NodeUsage.CompilationUnitScriptUsings : NodeUsage.CompilationUnitUsings)\n                    : (inScript ? NodeUsage.CompilationUnitScript : NodeUsage.Normal); 354236"];
5006 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 354237"];
5007 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 354238"];
5008 [label="CreateBinderCacheKey(compilationUnit, extraInfo) 354239"];
5009 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 354240"];
5010 [label="param CreateBinderCacheKey(NodeUsage usage) 354241"];
5011 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 354242"];
5012 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 354243"];
5013 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 354244"];
5014 [label="Binder result; 354245"];
5015 [label="binderCache 354246"];
5016 [label="get\n                {\n                    return _factory._binderCache;\n                } 354247"];
5017 [label="return _factory._binderCache; 354248"];
5018 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 354249"];
5019 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 354250"];
5020 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 354251"];
5021 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 354252"];
5022 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 354253"];
5023 [label="this.buckStopsHereBinder 354254"];
5024 [label="get\n                {\n                    return _factory._buckStopsHereBinder;\n                } 354255"];
5025 [label="return _factory._buckStopsHereBinder; 354256"];
5026 [label="result = this.buckStopsHereBinder; 354257"];
5027 [label="if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    } 354258"];
5028 [label="compilation 354259"];
5029 [label="get\n                {\n                    return _factory._compilation;\n                } 354260"];
5030 [label="return _factory._compilation; 354261"];
5031 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 354262"];
5032 [label="compilation.GlobalNamespace 354263"];
5033 [label="get\n            {\n                if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                }\n\n                return _lazyGlobalNamespace;\n            } 354264"];
5034 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 354265"];
5035 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 354266"];
5036 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 354267"];
5037 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 354268"];
5038 [label="new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing) 354269"];
5039 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 354270"];
5040 [label="param InContainerBinder(Binder next) 354271"];
5041 [label="param InContainerBinder(CSharpSyntaxNode declarationSyntax) 354272"];
5042 [label="param InContainerBinder(bool inUsing) 354273"];
5043 [label="param InContainerBinder(this) 354274"];
5044 [label="next 354275"];
5045 [label="param InContainerBinder(this) 354276"];
5046 [label="param Binder(Binder next) 354277"];
5047 [label="param Binder(this) 354278"];
5048 [label="param Binder(Conversions? conversions = null) 354279"];
5049 [label="RoslynDebug.Assert(next != null); 354280"];
5050 [label="RoslynDebug.Assert(next != null); 354281"];
5051 [label="Next 354282"];
5052 [label="this.Flags 354283"];
5053 [label="this.Compilation 354284"];
5054 [label="_lazyConversions 354285"];
5055 [label="_container 354286"];
5056 [label="_computeImports 354287"];
5057 [label="_lazyImports 354288"];
5058 [label="_lazyImportChain 354289"];
5059 [label="_lazyQuickAttributeChecker 354290"];
5060 [label="Debug.Assert((object)container != null); 354291"];
5061 [label="Debug.Assert((object)container != null); 354292"];
5062 [label="Debug.Assert(declarationSyntax != null); 354293"];
5063 [label="Debug.Assert(declarationSyntax != null); 354294"];
5064 [label="_container 354295"];
5065 [label="_computeImports = basesBeingResolved => Imports.FromSyntax(declarationSyntax, this, basesBeingResolved, inUsing); 354296"];
5066 [label="_computeImports 354297"];
5067 [label="if (!inUsing)\n            {\n                if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                }\n            } 354298"];
5068 [label="if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                } 354299"];
5069 [label="var compilationUnit = (CompilationUnitSyntax)declarationSyntax; 354300"];
5070 [label="_usingsSyntax 354301"];
5071 [label="compilation 354302"];
5072 [label="get\n                {\n                    return _factory._compilation;\n                } 354303"];
5073 [label="return _factory._compilation; 354304"];
5074 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 354305"];
5075 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 354306"];
5076 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 354307"];
5077 [label="SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) 354308"];
5078 [label="param GetSimpleProgramEntryPoint(CSharpCompilation compilation) 354309"];
5079 [label="param GetSimpleProgramEntryPoint(CompilationUnitSyntax compilationUnit) 354310"];
5080 [label="param GetSimpleProgramEntryPoint(bool fallbackToMainEntryPoint) 354311"];
5081 [label="var type = GetSimpleProgramNamedTypeSymbol(compilation); 354312"];
5082 [label="GetSimpleProgramNamedTypeSymbol(compilation) 354313"];
5083 [label="param GetSimpleProgramNamedTypeSymbol(CSharpCompilation compilation) 354314"];
5084 [label="compilation.SourceModule 354315"];
5085 [label="get\n            {\n                return Assembly.Modules[0];\n            } 354316"];
5086 [label="Assembly 354317"];
5087 [label="get\n            {\n                return SourceAssembly;\n            } 354318"];
5088 [label="GetBoundReferenceManager(); 354319"];
5089 [label="return Assembly.Modules[0]; 354320"];
5090 [label="Assembly.Modules 354321"];
5091 [label="get\n            {\n                return _modules;\n            } 354322"];
5092 [label="return Assembly.Modules[0]; 354323"];
5093 [label="return compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName).OfType<SimpleProgramNamedTypeSymbol>().SingleOrDefault(); 354324"];
5094 [label="compilation.SourceModule.GlobalNamespace 354325"];
5095 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 354326"];
5096 [label="return compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName).OfType<SimpleProgramNamedTypeSymbol>().SingleOrDefault(); 354327"];
5097 [label="compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName) 354328"];
5098 [label="param GetTypeMembers(string name) 354329"];
5099 [label="param GetTypeMembers(this) 354330"];
5100 [label="ImmutableArray<NamedTypeSymbol> members; 354331"];
5101 [label="members 354332"];
5102 [label="this.GetNameToTypeMembersMap() 354333"];
5103 [label="param GetNameToTypeMembersMap(this) 354334"];
5104 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 354335"];
5105 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 354336"];
5106 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 354337"];
5107 [label="GetNameToMembersMap() 354338"];
5108 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 354339"];
5109 [label="GetTypesFromMemberMap(GetNameToMembersMap()) 354340"];
5110 [label="param GetTypesFromMemberMap(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> map) 354341"];
5111 [label="var dictionary = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(StringOrdinalComparer.Instance); 354342"];
5112 [label="foreach (var kvp in map)\n            {\n                ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value;\n\n                bool hasType = false;\n                bool hasNamespace = false;\n\n                foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                }\n            } 354343"];
5113 [label="ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value; 354344"];
5114 [label="bool hasType = false; 354345"];
5115 [label="bool hasNamespace = false; 354346"];
5116 [label="foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                } 354347"];
5117 [label="symbol.Kind 354348"];
5118 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 354349"];
5119 [label="if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    } 354350"];
5120 [label="symbol.Kind 354351"];
5121 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 354352"];
5122 [label="Debug.Assert(symbol.Kind == SymbolKind.Namespace); 354353"];
5123 [label="hasNamespace = true; 354354"];
5124 [label="if (hasType)\n                        {\n                            break;\n                        } 354355"];
5125 [label="if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                } 354356"];
5126 [label="return dictionary; 354357"];
5127 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 354358"];
5128 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 354359"];
5129 [label="return _nameToTypeMembersMap; 354360"];
5130 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 354361"];
5131 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 354362"];
5132 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 354363"];
5133 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 354364"];
5134 [label="this.GetNameToTypeMembersMap().TryGetValue(name, out members) 354365"];
5135 [label="if (type is null)\n            {\n                return null;\n            } 354366"];
5136 [label="return null; 354367"];
5137 [label="binderCache 354368"];
5138 [label="return _factory._binderCache; 354369"];
5139 [label="binderCache.TryAdd(key, result); 354370"];
5140 [label="binderCache.TryAdd(key, result); 354371"];
5141 [label="binderCache.TryAdd(key, result); 354372"];
5142 [label="binderCache.TryAdd(key, result); 354373"];
5143 [label="binderCache.TryAdd(key, result); 354374"];
5144 [label="return result; 354375"];
5145 [label="return ((CSharpSyntaxNode)node).Accept(this); 354376"];
5146 [label="_binderFactoryVisitorPool.Free(visitor); 354377"];
5147 [label="_binderFactoryVisitorPool.Free(visitor); 354378"];
5148 [label="return result; 354379"];
5149 [label="if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    } 354380"];
5150 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 354381"];
5151 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 354382"];
5152 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 354383"];
5153 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 354384"];
5154 [label="MakeNamespaceBinder(parent, parent.Name, outer, inUsing) 354385"];
5155 [label="param MakeNamespaceBinder(CSharpSyntaxNode node) 354386"];
5156 [label="param MakeNamespaceBinder(NameSyntax name) 354387"];
5157 [label="param MakeNamespaceBinder(Binder outer) 354388"];
5158 [label="param MakeNamespaceBinder(bool inUsing) 354389"];
5159 [label="param MakeNamespaceBinder(this) 354390"];
5160 [label="QualifiedNameSyntax dotted; 354391"];
5161 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 354392"];
5162 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 354393"];
5163 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 354394"];
5164 [label="NamespaceOrTypeSymbol container; 354395"];
5165 [label="if (outer is InContainerBinder inContainerBinder)\n                {\n                    container = inContainerBinder.Container;\n                }\n                else\n                {\n                    Debug.Assert(outer is SimpleProgramUnitBinder);\n                    container = outer.Compilation.GlobalNamespace;\n                } 354396"];
5166 [label="inContainerBinder.Container 354397"];
5167 [label="get\n            {\n                return _container;\n            } 354398"];
5168 [label="return _container; 354399"];
5169 [label="container = inContainerBinder.Container; 354400"];
5170 [label="NamespaceSymbol ns = ((NamespaceSymbol)container).GetNestedNamespace(name); 354401"];
5171 [label="((NamespaceSymbol)container).GetNestedNamespace(name) 354402"];
5172 [label="param GetNestedNamespace(NameSyntax name) 354403"];
5173 [label="param GetNestedNamespace(this) 354404"];
5174 [label="switch (name.Kind())\n            {\n                case SyntaxKind.GenericName: // DeclarationTreeBuilder.VisitNamespace uses the PlainName, even for generic names\n                case SyntaxKind.IdentifierName:\n                    return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText);\n\n                case SyntaxKind.QualifiedName:\n                    var qn = (QualifiedNameSyntax)name;\n                    var leftNs = this.GetNestedNamespace(qn.Left);\n                    if ((object)leftNs != null)\n                    {\n                        return leftNs.GetNestedNamespace(qn.Right);\n                    }\n\n                    break;\n\n                case SyntaxKind.AliasQualifiedName:\n                    // This is an error scenario, but we should still handle it.\n                    // We recover in the same way as DeclarationTreeBuilder.VisitNamespaceDeclaration.\n                    return this.GetNestedNamespace(name.GetUnqualifiedName().Identifier.ValueText);\n            } 354405"];
5175 [label="return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText); 354406"];
5176 [label="((SimpleNameSyntax)name).Identifier 354407"];
5177 [label="param GetNestedNamespace(string name) 354408"];
5178 [label="param GetNestedNamespace(this) 354409"];
5179 [label="foreach (var sym in this.GetMembers(name))\n            {\n                if (sym.Kind == SymbolKind.Namespace)\n                {\n                    return (NamespaceSymbol)sym;\n                }\n            } 354410"];
5180 [label="this.GetMembers(name) 354411"];
5181 [label="param GetMembers(string name) 354412"];
5182 [label="param GetMembers(this) 354413"];
5183 [label="return _cachedLookup[name]; 354414"];
5184 [label="sym.Kind 354415"];
5185 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 354416"];
5186 [label="if (sym.Kind == SymbolKind.Namespace)\n                {\n                    return (NamespaceSymbol)sym;\n                } 354417"];
5187 [label="return (NamespaceSymbol)sym; 354418"];
5188 [label="return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText); 354419"];
5189 [label="if ((object)ns == null) return outer; 354420"];
5190 [label="if ((object)ns == null) return outer; 354421"];
5191 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 354422"];
5192 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 354423"];
5193 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 354424"];
5194 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 354425"];
5195 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 354426"];
5196 [label="new InContainerBinder(ns, outer, node, inUsing: inUsing) 354427"];
5197 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 354428"];
5198 [label="param InContainerBinder(Binder next) 354429"];
5199 [label="param InContainerBinder(CSharpSyntaxNode declarationSyntax) 354430"];
5200 [label="param InContainerBinder(bool inUsing) 354431"];
5201 [label="param InContainerBinder(this) 354432"];
5202 [label="param InContainerBinder(this) 354433"];
5203 [label="param Binder(this) 354434"];
5204 [label="param Binder(Conversions? conversions = null) 354435"];
5205 [label="RoslynDebug.Assert(next != null); 354436"];
5206 [label="RoslynDebug.Assert(next != null); 354437"];
5207 [label="this.Flags 354438"];
5208 [label="this.Compilation 354439"];
5209 [label="_lazyConversions 354440"];
5210 [label="_container 354441"];
5211 [label="_computeImports 354442"];
5212 [label="_lazyImports 354443"];
5213 [label="_lazyImportChain 354444"];
5214 [label="_lazyQuickAttributeChecker 354445"];
5215 [label="Debug.Assert((object)container != null); 354446"];
5216 [label="Debug.Assert((object)container != null); 354447"];
5217 [label="Debug.Assert(declarationSyntax != null); 354448"];
5218 [label="Debug.Assert(declarationSyntax != null); 354449"];
5219 [label="_computeImports = basesBeingResolved => Imports.FromSyntax(declarationSyntax, this, basesBeingResolved, inUsing); 354450"];
5220 [label="_computeImports 354451"];
5221 [label="if (!inUsing)\n            {\n                if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                }\n            } 354452"];
5222 [label="if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                } 354453"];
5223 [label="if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                } 354454"];
5224 [label="var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax; 354455"];
5225 [label="_usingsSyntax 354456"];
5226 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 354457"];
5227 [label="binderCache 354458"];
5228 [label="return _factory._binderCache; 354459"];
5229 [label="binderCache.TryAdd(key, result); 354460"];
5230 [label="binderCache.TryAdd(key, result); 354461"];
5231 [label="binderCache.TryAdd(key, result); 354462"];
5232 [label="binderCache.TryAdd(key, result); 354463"];
5233 [label="binderCache.TryAdd(key, result); 354464"];
5234 [label="return result; 354465"];
5235 [label="return ((CSharpSyntaxNode)node).Accept(this); 354466"];
5236 [label="if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    } 354467"];
5237 [label="resultBinder.ContainingMemberOrLambda 354468"];
5238 [label="get\n            {\n                var merged = _container as MergedNamespaceSymbol;\n                return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container;\n            } 354469"];
5239 [label="var merged = _container as MergedNamespaceSymbol; 354470"];
5240 [label="return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container; 354471"];
5241 [label="return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container; 354472"];
5242 [label="((object)merged != null) 354473"];
5243 [label="_container 354474"];
5244 [label="var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent); 354475"];
5245 [label="var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent); 354476"];
5246 [label="((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent) 354477"];
5247 [label="param GetSourceTypeMember(TypeDeclarationSyntax syntax) 354478"];
5248 [label="param GetSourceTypeMember(this) 354479"];
5249 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 354480"];
5250 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 354481"];
5251 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 354482"];
5252 [label="GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax) 354483"];
5253 [label="param GetSourceTypeMember(string name) 354484"];
5254 [label="param GetSourceTypeMember(int arity) 354485"];
5255 [label="param GetSourceTypeMember(SyntaxKind kind) 354486"];
5256 [label="param GetSourceTypeMember(CSharpSyntaxNode syntax) 354487"];
5257 [label="param GetSourceTypeMember(this) 354488"];
5258 [label="TypeKind typeKind = kind.ToDeclarationKind().ToTypeKind(); 354489"];
5259 [label="kind.ToDeclarationKind().ToTypeKind() 354490"];
5260 [label="param ToTypeKind(this DeclarationKind kind) 354491"];
5261 [label="foreach (var member in GetTypeMembers(name, arity))\n            {\n                var memberT = member as SourceNamedTypeSymbol;\n                if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                }\n            } 354492"];
5262 [label="foreach (var member in GetTypeMembers(name, arity))\n            {\n                var memberT = member as SourceNamedTypeSymbol;\n                if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                }\n            } 354493"];
5263 [label="GetTypeMembers(name, arity) 354494"];
5264 [label="param GetTypeMembers(string name) 354495"];
5265 [label="param GetTypeMembers(int arity) 354496"];
5266 [label="param GetTypeMembers(this) 354497"];
5267 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 354498"];
5268 [label="GetTypeMembers(name) 354499"];
5269 [label="param GetTypeMembers(string name) 354500"];
5270 [label="param GetTypeMembers(this) 354501"];
5271 [label="ImmutableArray<NamedTypeSymbol> members; 354502"];
5272 [label="members 354503"];
5273 [label="this.GetNameToTypeMembersMap() 354504"];
5274 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 354505"];
5275 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 354506"];
5276 [label="GetNameToMembersMap() 354507"];
5277 [label="param GetTypesFromMemberMap(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> map) 354508"];
5278 [label="foreach (var kvp in map)\n            {\n                ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value;\n\n                bool hasType = false;\n                bool hasNamespace = false;\n\n                foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                }\n            } 354509"];
5279 [label="ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value; 354510"];
5280 [label="bool hasType = false; 354511"];
5281 [label="bool hasNamespace = false; 354512"];
5282 [label="foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                } 354513"];
5283 [label="symbol.Kind 354514"];
5284 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 354515"];
5285 [label="if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    } 354516"];
5286 [label="hasType = true; 354517"];
5287 [label="if (hasNamespace)\n                        {\n                            break;\n                        } 354518"];
5288 [label="if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                } 354519"];
5289 [label="if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    } 354520"];
5290 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 354521"];
5291 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 354522"];
5292 [label="bool hasType = false; 354523"];
5293 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 354524"];
5294 [label="if (hasNamespace)\n                        {\n                            break;\n                        } 354525"];
5295 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 354526"];
5296 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 354527"];
5297 [label="this.GetNameToTypeMembersMap().TryGetValue(name, out members) 354528"];
5298 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 354529"];
5299 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 354530"];
5300 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 354531"];
5301 [label="var memberT = member as SourceNamedTypeSymbol; 354532"];
5302 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 354533"];
5303 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 354534"];
5304 [label="memberT.TypeKind 354535"];
5305 [label="get\n            {\n                return _flags.TypeKind;\n            } 354536"];
5306 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 354537"];
5307 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 354538"];
5308 [label="if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    } 354539"];
5309 [label="if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    } 354540"];
5310 [label="memberT.Locations 354541"];
5311 [label="foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        } 354542"];
5312 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 354543"];
5313 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 354544"];
5314 [label="return memberT; 354545"];
5315 [label="if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        } 354546"];
5316 [label="resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder); 354547"];
5317 [label="resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder); 354548"];
5318 [label="resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder); 354549"];
5319 [label="new WithClassTypeParametersBinder(typeSymbol, resultBinder) 354550"];
5320 [label="param WithClassTypeParametersBinder(NamedTypeSymbol container) 354551"];
5321 [label="param WithClassTypeParametersBinder(Binder next) 354552"];
5322 [label="param WithClassTypeParametersBinder(this) 354553"];
5323 [label="next 354554"];
5324 [label="param WithClassTypeParametersBinder(this) 354555"];
5325 [label="param WithTypeParametersBinder(Binder next) 354556"];
5326 [label="param WithTypeParametersBinder(this) 354557"];
5327 [label="next 354558"];
5328 [label="param WithTypeParametersBinder(this) 354559"];
5329 [label="param Binder(Binder next) 354560"];
5330 [label="param Binder(this) 354561"];
5331 [label="param Binder(Conversions? conversions = null) 354562"];
5332 [label="RoslynDebug.Assert(next != null); 354563"];
5333 [label="RoslynDebug.Assert(next != null); 354564"];
5334 [label="this.Flags 354565"];
5335 [label="this.Compilation 354566"];
5336 [label="_lazyConversions 354567"];
5337 [label="_namedType 354568"];
5338 [label="_lazyTypeParameterMap 354569"];
5339 [label="Debug.Assert((object)container != null); 354570"];
5340 [label="Debug.Assert((object)container != null); 354571"];
5341 [label="_namedType 354572"];
5342 [label="resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers); 354573"];
5343 [label="resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers) 354574"];
5344 [label="param WithUnsafeRegionIfNecessary(SyntaxTokenList modifiers) 354575"];
5345 [label="param WithUnsafeRegionIfNecessary(this) 354576"];
5346 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 354577"];
5347 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 354578"];
5348 [label="this.Flags.Includes(BinderFlags.UnsafeRegion) 354579"];
5349 [label="param Includes(this BinderFlags self) 354580"];
5350 [label="param Includes(BinderFlags other) 354581"];
5351 [label="return (self & other) == other; 354582"];
5352 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 354583"];
5353 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 354584"];
5354 [label="(this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword)) 354585"];
5355 [label="binderCache 354586"];
5356 [label="return _factory._binderCache; 354587"];
5357 [label="binderCache.TryAdd(key, resultBinder); 354588"];
5358 [label="binderCache.TryAdd(key, resultBinder); 354589"];
5359 [label="binderCache.TryAdd(key, resultBinder); 354590"];
5360 [label="binderCache.TryAdd(key, resultBinder); 354591"];
5361 [label="binderCache.TryAdd(key, resultBinder); 354592"];
5362 [label="return resultBinder; 354593"];
5363 [label="return ((CSharpSyntaxNode)node).Accept(this); 354594"];
5364 [label="_binderFactoryVisitorPool.Free(visitor); 354595"];
5365 [label="baseBinder = baseBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 354596"];
5366 [label="baseBinder = baseBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 354597"];
5367 [label="baseBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this) 354598"];
5368 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags flags) 354599"];
5369 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(Symbol containing) 354600"];
5370 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(this) 354601"];
5371 [label="Debug.Assert((object)containing != null); 354602"];
5372 [label="Debug.Assert((object)containing != null); 354603"];
5373 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 354604"];
5374 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 354605"];
5375 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 354606"];
5376 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 354607"];
5377 [label="new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing) 354608"];
5378 [label="param BinderWithContainingMemberOrLambda(Binder next) 354609"];
5379 [label="param BinderWithContainingMemberOrLambda(BinderFlags flags) 354610"];
5380 [label="param BinderWithContainingMemberOrLambda(Symbol containingMemberOrLambda) 354611"];
5381 [label="param BinderWithContainingMemberOrLambda(this) 354612"];
5382 [label="next 354613"];
5383 [label="flags 354614"];
5384 [label="param BinderWithContainingMemberOrLambda(this) 354615"];
5385 [label="param Binder(Binder next) 354616"];
5386 [label="param Binder(BinderFlags flags) 354617"];
5387 [label="param Binder(this) 354618"];
5388 [label="internal CSharpCompilation Compilation { get; } 354619"];
5389 [label="Flags 354620"];
5390 [label="protected internal Binder? Next { get; } 354621"];
5391 [label="_lazyConversions 354622"];
5392 [label="_lazyOverloadResolution 354623"];
5393 [label="RoslynDebug.Assert(next != null); 354624"];
5394 [label="RoslynDebug.Assert(next != null); 354625"];
5395 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 354626"];
5396 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 354627"];
5397 [label="flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion) 354628"];
5398 [label="param Includes(this BinderFlags self) 354629"];
5399 [label="param Includes(BinderFlags other) 354630"];
5400 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 354631"];
5401 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 354632"];
5402 [label="flags.Includes(BinderFlags.InNestedFinallyBlock) 354633"];
5403 [label="param Includes(this BinderFlags self) 354634"];
5404 [label="param Includes(BinderFlags other) 354635"];
5405 [label="Next 354636"];
5406 [label="this.Flags 354637"];
5407 [label="this.Compilation 354638"];
5408 [label="_containingMemberOrLambda 354639"];
5409 [label="Debug.Assert(containingMemberOrLambda != null); 354640"];
5410 [label="containingMemberOrLambda != null 354641"];
5411 [label="param !=(Symbol left) 354642"];
5412 [label="param !=(Symbol right) 354643"];
5413 [label="if (right is null)\n            {\n                return left is object;\n            } 354644"];
5414 [label="return left is object; 354645"];
5415 [label="Debug.Assert(containingMemberOrLambda != null); 354646"];
5416 [label="_containingMemberOrLambda 354647"];
5417 [label="baseBinder = baseBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 354648"];
5418 [label="int i = -1; 354649"];
5419 [label="foreach (var baseTypeSyntax in bases.Types)\n            {\n                i++;\n                var typeSyntax = baseTypeSyntax.Type;\n                if (typeSyntax.Kind() != SyntaxKind.PredefinedType && !SyntaxFacts.IsName(typeSyntax.Kind()))\n                {\n                    diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation());\n                }\n\n                var location = new SourceLocation(typeSyntax);\n\n                TypeSymbol baseType;\n\n                if (i == 0 && TypeKind == TypeKind.Class) // allow class in the first position\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n\n                    SpecialType baseSpecialType = baseType.SpecialType;\n                    if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    }\n\n                    if (baseType.IsSealed && !this.IsStatic) // Give precedence to ERR_StaticDerivedFromNonObject\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CantDeriveFromSealedType, location, this, baseType);\n                        continue;\n                    }\n\n                    bool baseTypeIsErrorWithoutInterfaceGuess = false;\n\n                    // If baseType is an error symbol and our best guess is that the desired symbol\n                    // is an interface, then put baseType in the interfaces list, rather than the\n                    // base type slot, to avoid the frustrating scenario where an error message\n                    // indicates that the symbol being returned as the base type was elsewhere\n                    // interpreted as an interface.\n                    if (baseType.TypeKind == TypeKind.Error)\n                    {\n                        baseTypeIsErrorWithoutInterfaceGuess = true;\n\n                        TypeKind guessTypeKind = baseType.GetNonErrorTypeKindGuess();\n                        if (guessTypeKind == TypeKind.Interface)\n                        {\n                            //base type is an error *with* a guessed interface\n                            baseTypeIsErrorWithoutInterfaceGuess = false;\n                        }\n                    }\n\n                    if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    }\n                }\n                else\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n                }\n\n                switch (baseType.TypeKind)\n                {\n                    case TypeKind.Interface:\n                        foreach (var t in localInterfaces)\n                        {\n                            if (t.Equals(baseType, TypeCompareKind.ConsiderEverything))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateInterfaceInBaseList, location, baseType);\n                            }\n                            else if (t.Equals(baseType, TypeCompareKind.ObliviousNullableModifierMatchesAny))\n                            {\n                                // duplicates with ?/! differences are reported later, we report local differences between oblivious and ?/! here\n                                diagnostics.Add(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, location, baseType, this);\n                            }\n                        }\n\n                        if (this.IsStatic)\n                        {\n                            // '{0}': static classes cannot implement interfaces\n                            diagnostics.Add(ErrorCode.ERR_StaticClassInterfaceImpl, location, this, baseType);\n                        }\n\n                        if (this.IsRefLikeType)\n                        {\n                            // '{0}': ref structs cannot implement interfaces\n                            diagnostics.Add(ErrorCode.ERR_RefStructInterfaceImpl, location, this, baseType);\n                        }\n\n                        if (baseType.ContainsDynamic())\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromConstructedDynamic, location, this, baseType);\n                        }\n\n                        localInterfaces.Add((NamedTypeSymbol)baseType);\n                        continue;\n\n                    case TypeKind.Class:\n                        if (TypeKind == TypeKind.Class)\n                        {\n                            if ((object)localBase == null)\n                            {\n                                localBase = (NamedTypeSymbol)baseType;\n                                diagnostics.Add(ErrorCode.ERR_BaseClassMustBeFirst, location, baseType);\n                                continue;\n                            }\n                            else\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NoMultipleInheritance, location, this, localBase, baseType);\n                                continue;\n                            }\n                        }\n                        goto default;\n\n                    case TypeKind.TypeParameter:\n                        diagnostics.Add(ErrorCode.ERR_DerivingFromATyVar, location, baseType);\n                        continue;\n\n                    case TypeKind.Error:\n                        // put the error type in the interface list so we don't lose track of it\n                        localInterfaces.Add((NamedTypeSymbol)baseType);\n                        continue;\n\n                    case TypeKind.Dynamic:\n                        diagnostics.Add(ErrorCode.ERR_DeriveFromDynamic, location, this);\n                        continue;\n\n                    case TypeKind.Submission:\n                        throw ExceptionUtilities.UnexpectedValue(baseType.TypeKind);\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType);\n                        continue;\n                }\n            } 354650"];
5420 [label="i++; 354651"];
5421 [label="var typeSyntax = baseTypeSyntax.Type; 354652"];
5422 [label="if (typeSyntax.Kind() != SyntaxKind.PredefinedType && !SyntaxFacts.IsName(typeSyntax.Kind()))\n                {\n                    diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation());\n                } 354653"];
5423 [label="diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation()); 354654"];
5424 [label="diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation()); 354655"];
5425 [label="diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation()); 354656"];
5426 [label="var location = new SourceLocation(typeSyntax); 354657"];
5427 [label="var location = new SourceLocation(typeSyntax); 354658"];
5428 [label="TypeSymbol baseType; 354659"];
5429 [label="if (i == 0 && TypeKind == TypeKind.Class) // allow class in the first position\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n\n                    SpecialType baseSpecialType = baseType.SpecialType;\n                    if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    }\n\n                    if (baseType.IsSealed && !this.IsStatic) // Give precedence to ERR_StaticDerivedFromNonObject\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CantDeriveFromSealedType, location, this, baseType);\n                        continue;\n                    }\n\n                    bool baseTypeIsErrorWithoutInterfaceGuess = false;\n\n                    // If baseType is an error symbol and our best guess is that the desired symbol\n                    // is an interface, then put baseType in the interfaces list, rather than the\n                    // base type slot, to avoid the frustrating scenario where an error message\n                    // indicates that the symbol being returned as the base type was elsewhere\n                    // interpreted as an interface.\n                    if (baseType.TypeKind == TypeKind.Error)\n                    {\n                        baseTypeIsErrorWithoutInterfaceGuess = true;\n\n                        TypeKind guessTypeKind = baseType.GetNonErrorTypeKindGuess();\n                        if (guessTypeKind == TypeKind.Interface)\n                        {\n                            //base type is an error *with* a guessed interface\n                            baseTypeIsErrorWithoutInterfaceGuess = false;\n                        }\n                    }\n\n                    if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    }\n                }\n                else\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n                } 354660"];
5430 [label="if (i == 0 && TypeKind == TypeKind.Class) // allow class in the first position\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n\n                    SpecialType baseSpecialType = baseType.SpecialType;\n                    if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    }\n\n                    if (baseType.IsSealed && !this.IsStatic) // Give precedence to ERR_StaticDerivedFromNonObject\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CantDeriveFromSealedType, location, this, baseType);\n                        continue;\n                    }\n\n                    bool baseTypeIsErrorWithoutInterfaceGuess = false;\n\n                    // If baseType is an error symbol and our best guess is that the desired symbol\n                    // is an interface, then put baseType in the interfaces list, rather than the\n                    // base type slot, to avoid the frustrating scenario where an error message\n                    // indicates that the symbol being returned as the base type was elsewhere\n                    // interpreted as an interface.\n                    if (baseType.TypeKind == TypeKind.Error)\n                    {\n                        baseTypeIsErrorWithoutInterfaceGuess = true;\n\n                        TypeKind guessTypeKind = baseType.GetNonErrorTypeKindGuess();\n                        if (guessTypeKind == TypeKind.Interface)\n                        {\n                            //base type is an error *with* a guessed interface\n                            baseTypeIsErrorWithoutInterfaceGuess = false;\n                        }\n                    }\n\n                    if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    }\n                }\n                else\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n                } 354661"];
5431 [label="TypeKind 354662"];
5432 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 354663"];
5433 [label="if (i == 0 && TypeKind == TypeKind.Class) // allow class in the first position\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n\n                    SpecialType baseSpecialType = baseType.SpecialType;\n                    if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    }\n\n                    if (baseType.IsSealed && !this.IsStatic) // Give precedence to ERR_StaticDerivedFromNonObject\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CantDeriveFromSealedType, location, this, baseType);\n                        continue;\n                    }\n\n                    bool baseTypeIsErrorWithoutInterfaceGuess = false;\n\n                    // If baseType is an error symbol and our best guess is that the desired symbol\n                    // is an interface, then put baseType in the interfaces list, rather than the\n                    // base type slot, to avoid the frustrating scenario where an error message\n                    // indicates that the symbol being returned as the base type was elsewhere\n                    // interpreted as an interface.\n                    if (baseType.TypeKind == TypeKind.Error)\n                    {\n                        baseTypeIsErrorWithoutInterfaceGuess = true;\n\n                        TypeKind guessTypeKind = baseType.GetNonErrorTypeKindGuess();\n                        if (guessTypeKind == TypeKind.Interface)\n                        {\n                            //base type is an error *with* a guessed interface\n                            baseTypeIsErrorWithoutInterfaceGuess = false;\n                        }\n                    }\n\n                    if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    }\n                }\n                else\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n                } 354664"];
5434 [label="if (i == 0 && TypeKind == TypeKind.Class) // allow class in the first position\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n\n                    SpecialType baseSpecialType = baseType.SpecialType;\n                    if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    }\n\n                    if (baseType.IsSealed && !this.IsStatic) // Give precedence to ERR_StaticDerivedFromNonObject\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CantDeriveFromSealedType, location, this, baseType);\n                        continue;\n                    }\n\n                    bool baseTypeIsErrorWithoutInterfaceGuess = false;\n\n                    // If baseType is an error symbol and our best guess is that the desired symbol\n                    // is an interface, then put baseType in the interfaces list, rather than the\n                    // base type slot, to avoid the frustrating scenario where an error message\n                    // indicates that the symbol being returned as the base type was elsewhere\n                    // interpreted as an interface.\n                    if (baseType.TypeKind == TypeKind.Error)\n                    {\n                        baseTypeIsErrorWithoutInterfaceGuess = true;\n\n                        TypeKind guessTypeKind = baseType.GetNonErrorTypeKindGuess();\n                        if (guessTypeKind == TypeKind.Interface)\n                        {\n                            //base type is an error *with* a guessed interface\n                            baseTypeIsErrorWithoutInterfaceGuess = false;\n                        }\n                    }\n\n                    if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    }\n                }\n                else\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n                } 354665"];
5435 [label="baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type; 354666"];
5436 [label="baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type; 354667"];
5437 [label="baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type; 354668"];
5438 [label="baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type; 354669"];
5439 [label="baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved) 354670"];
5440 [label="param BindType(ExpressionSyntax syntax) 354671"];
5441 [label="param BindType(DiagnosticBag diagnostics) 354672"];
5442 [label="param BindType(ConsList<TypeSymbol> basesBeingResolved = null) 354673"];
5443 [label="param BindType(bool suppressUseSiteDiagnostics = false) 354674"];
5444 [label="param BindType(this) 354675"];
5445 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 354676"];
5446 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 354677"];
5447 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 354678"];
5448 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 354679"];
5449 [label="BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics) 354680"];
5450 [label="param BindTypeOrAlias(ExpressionSyntax syntax) 354681"];
5451 [label="param BindTypeOrAlias(DiagnosticBag diagnostics) 354682"];
5452 [label="param BindTypeOrAlias(ConsList<TypeSymbol> basesBeingResolved = null) 354683"];
5453 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 354684"];
5454 [label="param BindTypeOrAlias(this) 354685"];
5455 [label="Debug.Assert(diagnostics != null); 354686"];
5456 [label="Debug.Assert(diagnostics != null); 354687"];
5457 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 354688"];
5458 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 354689"];
5459 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 354690"];
5460 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 354691"];
5461 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 354692"];
5462 [label="BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics) 354693"];
5463 [label="param BindNamespaceOrTypeOrAliasSymbol(ExpressionSyntax syntax) 354694"];
5464 [label="param BindNamespaceOrTypeOrAliasSymbol(DiagnosticBag diagnostics) 354695"];
5465 [label="param BindNamespaceOrTypeOrAliasSymbol(ConsList<TypeSymbol> basesBeingResolved) 354696"];
5466 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 354697"];
5467 [label="param BindNamespaceOrTypeOrAliasSymbol(this) 354698"];
5468 [label="switch (syntax.Kind())\n            {\n                case SyntaxKind.NullableType:\n                    return bindNullable(syntax, diagnostics, basesBeingResolved);\n\n                case SyntaxKind.PredefinedType:\n                    return bindPredefined(syntax, diagnostics);\n\n                case SyntaxKind.IdentifierName:\n                    return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null);\n\n                case SyntaxKind.GenericName:\n                    return BindGenericSimpleNamespaceOrTypeOrAliasSymbol((GenericNameSyntax)syntax, diagnostics, basesBeingResolved, qualifierOpt: null);\n\n                case SyntaxKind.AliasQualifiedName:\n                    return bindAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n\n                case SyntaxKind.QualifiedName:\n                    {\n                        var node = (QualifiedNameSyntax)syntax;\n                        return BindQualifiedName(node.Left, node.Right, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                case SyntaxKind.SimpleMemberAccessExpression:\n                    {\n                        var node = (MemberAccessExpressionSyntax)syntax;\n                        return BindQualifiedName(node.Expression, node.Name, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                case SyntaxKind.ArrayType:\n                    {\n                        return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true);\n                    }\n\n                case SyntaxKind.PointerType:\n                    return bindPointer(syntax, diagnostics, basesBeingResolved);\n\n                case SyntaxKind.FunctionPointerType:\n                    var functionPointerTypeSyntax = (FunctionPointerTypeSyntax)syntax;\n                    if (GetUnsafeDiagnosticInfo(sizeOfTypeOpt: null) is CSDiagnosticInfo info)\n                    {\n                        var @delegate = functionPointerTypeSyntax.DelegateKeyword;\n                        var asterisk = functionPointerTypeSyntax.AsteriskToken;\n                        RoslynDebug.Assert(@delegate.SyntaxTree is object);\n                        diagnostics.Add(info, Location.Create(@delegate.SyntaxTree, TextSpan.FromBounds(@delegate.SpanStart, asterisk.Span.End)));\n                    }\n\n                    return TypeWithAnnotations.Create(\n                        FunctionPointerTypeSymbol.CreateFromSource(\n                            functionPointerTypeSyntax,\n                            this,\n                            diagnostics,\n                            basesBeingResolved,\n                            suppressUseSiteDiagnostics));\n\n                case SyntaxKind.OmittedTypeArgument:\n                    {\n                        return BindTypeArgument((TypeSyntax)syntax, diagnostics, basesBeingResolved);\n                    }\n\n                case SyntaxKind.TupleType:\n                    {\n                        var tupleTypeSyntax = (TupleTypeSyntax)syntax;\n                        return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(tupleTypeSyntax.CloseParenToken), BindTupleType(tupleTypeSyntax, diagnostics, basesBeingResolved));\n                    }\n\n                case SyntaxKind.RefType:\n                    {\n                        // ref needs to be handled by the caller\n                        var refTypeSyntax = (RefTypeSyntax)syntax;\n                        var refToken = refTypeSyntax.RefKeyword;\n                        if (!syntax.HasErrors)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_UnexpectedToken, refToken.GetLocation(), refToken.ToString());\n                        }\n\n                        return BindNamespaceOrTypeOrAliasSymbol(refTypeSyntax.Type, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                default:\n                    {\n                        // This is invalid syntax for a type.  This arises when a constant pattern that fails to bind\n                        // is attempted to be bound as a type pattern.\n                        return createErrorType(syntax);\n                    }\n            } 354699"];
5469 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 354700"];
5470 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 354701"];
5471 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 354702"];
5472 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 354703"];
5473 [label="BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true) 354704"];
5474 [label="param BindArrayType(ArrayTypeSyntax node) 354705"];
5475 [label="param BindArrayType(DiagnosticBag diagnostics) 354706"];
5476 [label="param BindArrayType(bool permitDimensions) 354707"];
5477 [label="param BindArrayType(ConsList<TypeSymbol> basesBeingResolved) 354708"];
5478 [label="param BindArrayType(bool disallowRestrictedTypes) 354709"];
5479 [label="param BindArrayType(this) 354710"];
5480 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 354711"];
5481 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 354712"];
5482 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 354713"];
5483 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 354714"];
5484 [label="BindType(node.ElementType, diagnostics, basesBeingResolved) 354715"];
5485 [label="param BindType(ExpressionSyntax syntax) 354716"];
5486 [label="param BindType(DiagnosticBag diagnostics) 354717"];
5487 [label="param BindType(ConsList<TypeSymbol> basesBeingResolved = null) 354718"];
5488 [label="param BindType(bool suppressUseSiteDiagnostics = false) 354719"];
5489 [label="param BindType(this) 354720"];
5490 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 354721"];
5491 [label="Debug.Assert(diagnostics != null); 354722"];
5492 [label="Debug.Assert(diagnostics != null); 354723"];
5493 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 354724"];
5494 [label="return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null); 354725"];
5495 [label="return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null); 354726"];
5496 [label="return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null); 354727"];
5497 [label="return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null); 354728"];
5498 [label="BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null) 354729"];
5499 [label="param BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(IdentifierNameSyntax node) 354730"];
5500 [label="param BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(DiagnosticBag diagnostics) 354731"];
5501 [label="param BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(ConsList<TypeSymbol> basesBeingResolved) 354732"];
5502 [label="param BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 354733"];
5503 [label="param BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(NamespaceOrTypeSymbol qualifierOpt) 354734"];
5504 [label="param BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(this) 354735"];
5505 [label="var identifierValueText = node.Identifier.ValueText; 354736"];
5506 [label="if (string.IsNullOrWhiteSpace(identifierValueText))\n            {\n                return TypeWithAnnotations.Create(new ExtendedErrorTypeSymbol(\n                    Compilation.Assembly.GlobalNamespace, identifierValueText, 0,\n                    new CSDiagnosticInfo(ErrorCode.ERR_SingleTypeNameNotFound)));\n            } 354737"];
5507 [label="var errorResult = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics); 354738"];
5508 [label="var errorResult = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics); 354739"];
5509 [label="var errorResult = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics); 354740"];
5510 [label="var errorResult = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics); 354741"];
5511 [label="var errorResult = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics); 354742"];
5512 [label="CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics) 354743"];
5513 [label="param CreateErrorIfLookupOnTypeParameter(CSharpSyntaxNode node) 354744"];
5514 [label="param CreateErrorIfLookupOnTypeParameter(NamespaceOrTypeSymbol qualifierOpt) 354745"];
5515 [label="param CreateErrorIfLookupOnTypeParameter(string name) 354746"];
5516 [label="param CreateErrorIfLookupOnTypeParameter(int arity) 354747"];
5517 [label="param CreateErrorIfLookupOnTypeParameter(DiagnosticBag diagnostics) 354748"];
5518 [label="param CreateErrorIfLookupOnTypeParameter(this) 354749"];
5519 [label="if (((object)qualifierOpt != null) && (qualifierOpt.Kind == SymbolKind.TypeParameter))\n            {\n                var diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_LookupInTypeVariable, qualifierOpt);\n                diagnostics.Add(diagnosticInfo, node.Location);\n                return new ExtendedErrorTypeSymbol(this.Compilation, name, arity, diagnosticInfo, unreported: false);\n            } 354750"];
5520 [label="if (((object)qualifierOpt != null) && (qualifierOpt.Kind == SymbolKind.TypeParameter))\n            {\n                var diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_LookupInTypeVariable, qualifierOpt);\n                diagnostics.Add(diagnosticInfo, node.Location);\n                return new ExtendedErrorTypeSymbol(this.Compilation, name, arity, diagnosticInfo, unreported: false);\n            } 354751"];
5521 [label="return null; 354752"];
5522 [label="var errorResult = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics); 354753"];
5523 [label="if ((object)errorResult != null)\n            {\n                return TypeWithAnnotations.Create(errorResult);\n            } 354754"];
5524 [label="if ((object)errorResult != null)\n            {\n                return TypeWithAnnotations.Create(errorResult);\n            } 354755"];
5525 [label="CreatePool() 354756"];
5526 [label="ObjectPool<LookupResult> pool = null; 354757"];
5527 [label="pool = new ObjectPool<LookupResult>(() => new LookupResult(pool), 128); 354758"];
5528 [label="pool = new ObjectPool<LookupResult>(() => new LookupResult(pool), 128); 354759"];
5529 [label="return pool; 354760"];
5530 [label="s_poolInstance = CreatePool() 354761"];
5531 [label="LookupResult.GetInstance() 354762"];
5532 [label="var instance = s_poolInstance.Allocate(); 354763"];
5533 [label="var instance = s_poolInstance.Allocate(); 354764"];
5534 [label="var instance = s_poolInstance.Allocate(); 354765"];
5535 [label="param LookupResult(ObjectPool<LookupResult> pool) 354766"];
5536 [label="param LookupResult(this) 354767"];
5537 [label="_kind 354768"];
5538 [label="_symbolList 354769"];
5539 [label="_error 354770"];
5540 [label="_pool 354771"];
5541 [label="_pool 354772"];
5542 [label="_kind 354773"];
5543 [label="_symbolList = new ArrayBuilder<Symbol>(); 354774"];
5544 [label="_symbolList 354775"];
5545 [label="_error = null; 354776"];
5546 [label="_error 354777"];
5547 [label="var instance = s_poolInstance.Allocate(); 354778"];
5548 [label="instance.IsClear 354779"];
5549 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 354780"];
5550 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354781"];
5551 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354782"];
5552 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354783"];
5553 [label="Debug.Assert(instance.IsClear); 354784"];
5554 [label="return instance; 354785"];
5555 [label="var result = LookupResult.GetInstance(); 354786"];
5556 [label="LookupOptions options = GetSimpleNameLookupOptions(node, node.Identifier.IsVerbatimIdentifier()); 354787"];
5557 [label="LookupOptions options = GetSimpleNameLookupOptions(node, node.Identifier.IsVerbatimIdentifier()); 354788"];
5558 [label="GetSimpleNameLookupOptions(node, node.Identifier.IsVerbatimIdentifier()) 354789"];
5559 [label="param GetSimpleNameLookupOptions(NameSyntax node) 354790"];
5560 [label="param GetSimpleNameLookupOptions(bool isVerbatimIdentifier) 354791"];
5561 [label="if (SyntaxFacts.IsAttributeName(node))\n            {\n                //  SPEC:   By convention, attribute classes are named with a suffix of Attribute.\n                //  SPEC:   An attribute-name of the form type-name may either include or omit this suffix.\n                //  SPEC:   If an attribute class is found both with and without this suffix, an ambiguity\n                //  SPEC:   is present, and a compile-time error results. If the attribute-name is spelled\n                //  SPEC:   such that its right-most identifier is a verbatim identifier (§2.4.2), then only\n                //  SPEC:   an attribute without a suffix is matched, thus enabling such an ambiguity to be resolved.\n\n                return isVerbatimIdentifier ? LookupOptions.VerbatimNameAttributeTypeOnly : LookupOptions.AttributeTypeOnly;\n            }\n            else\n            {\n                return LookupOptions.NamespacesOrTypesOnly;\n            } 354792"];
5562 [label="return LookupOptions.NamespacesOrTypesOnly; 354793"];
5563 [label="HashSet<DiagnosticInfo> useSiteDiagnostics = null; 354794"];
5564 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 354795"];
5565 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 354796"];
5566 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 354797"];
5567 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 354798"];
5568 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 354799"];
5569 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 354800"];
5570 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 354801"];
5571 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics) 354802"];
5572 [label="param LookupSymbolsSimpleName(LookupResult result) 354803"];
5573 [label="param LookupSymbolsSimpleName(NamespaceOrTypeSymbol qualifierOpt) 354804"];
5574 [label="param LookupSymbolsSimpleName(string plainName) 354805"];
5575 [label="param LookupSymbolsSimpleName(int arity) 354806"];
5576 [label="param LookupSymbolsSimpleName(ConsList<TypeSymbol> basesBeingResolved) 354807"];
5577 [label="param LookupSymbolsSimpleName(LookupOptions options) 354808"];
5578 [label="param LookupSymbolsSimpleName(bool diagnose) 354809"];
5579 [label="param LookupSymbolsSimpleName(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 354810"];
5580 [label="param LookupSymbolsSimpleName(this) 354811"];
5581 [label="if (options.IsAttributeTypeLookup())\n            {\n                this.LookupAttributeType(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics);\n            }\n            else\n            {\n                this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics);\n            } 354812"];
5582 [label="options.IsAttributeTypeLookup() 354813"];
5583 [label="param IsAttributeTypeLookup(this LookupOptions options) 354814"];
5584 [label="return (options & LookupOptions.AttributeTypeOnly) == LookupOptions.AttributeTypeOnly; 354815"];
5585 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354816"];
5586 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354817"];
5587 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354818"];
5588 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354819"];
5589 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354820"];
5590 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354821"];
5591 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354822"];
5592 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354823"];
5593 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics) 354824"];
5594 [label="param LookupSymbolsOrMembersInternal(LookupResult result) 354825"];
5595 [label="param LookupSymbolsOrMembersInternal(NamespaceOrTypeSymbol qualifierOpt) 354826"];
5596 [label="param LookupSymbolsOrMembersInternal(string name) 354827"];
5597 [label="param LookupSymbolsOrMembersInternal(int arity) 354828"];
5598 [label="param LookupSymbolsOrMembersInternal(ConsList<TypeSymbol> basesBeingResolved) 354829"];
5599 [label="param LookupSymbolsOrMembersInternal(LookupOptions options) 354830"];
5600 [label="param LookupSymbolsOrMembersInternal(bool diagnose) 354831"];
5601 [label="param LookupSymbolsOrMembersInternal(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 354832"];
5602 [label="param LookupSymbolsOrMembersInternal(this) 354833"];
5603 [label="if ((object)qualifierOpt == null)\n            {\n                this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics);\n            }\n            else\n            {\n                this.LookupMembersInternal(result, qualifierOpt, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n            } 354834"];
5604 [label="if ((object)qualifierOpt == null)\n            {\n                this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics);\n            }\n            else\n            {\n                this.LookupMembersInternal(result, qualifierOpt, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n            } 354835"];
5605 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354836"];
5606 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354837"];
5607 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354838"];
5608 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354839"];
5609 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354840"];
5610 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354841"];
5611 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 354842"];
5612 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics) 354843"];
5613 [label="param LookupSymbolsInternal(LookupResult result) 354844"];
5614 [label="param LookupSymbolsInternal(string name) 354845"];
5615 [label="param LookupSymbolsInternal(int arity) 354846"];
5616 [label="param LookupSymbolsInternal(ConsList<TypeSymbol> basesBeingResolved) 354847"];
5617 [label="param LookupSymbolsInternal(LookupOptions options) 354848"];
5618 [label="param LookupSymbolsInternal(bool diagnose) 354849"];
5619 [label="param LookupSymbolsInternal(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 354850"];
5620 [label="param LookupSymbolsInternal(this) 354851"];
5621 [label="result.IsClear 354852"];
5622 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 354853"];
5623 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354854"];
5624 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354855"];
5625 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354856"];
5626 [label="Debug.Assert(result.IsClear); 354857"];
5627 [label="Debug.Assert(options.AreValid()); 354858"];
5628 [label="options.AreValid() 354859"];
5629 [label="param AreValid(this LookupOptions options) 354860"];
5630 [label="if (options == LookupOptions.Default)\n            {\n                return true;\n            } 354861"];
5631 [label="if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return options == LookupOptions.LabelsOnly;\n            } 354862"];
5632 [label="if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return options == LookupOptions.LabelsOnly;\n            } 354863"];
5633 [label="LookupOptions mustBeAndNotBeInstance = (LookupOptions.MustBeInstance | LookupOptions.MustNotBeInstance); 354864"];
5634 [label="if ((options & mustBeAndNotBeInstance) == mustBeAndNotBeInstance)\n            {\n                return false;\n            } 354865"];
5635 [label="if ((options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustNotBeMethodTypeParameter)) != 0 &&\n                (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) != 0)\n            {\n                return false;\n            } 354866"];
5636 [label="if ((options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustNotBeMethodTypeParameter)) != 0 &&\n                (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) != 0)\n            {\n                return false;\n            } 354867"];
5637 [label="if ((options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustNotBeMethodTypeParameter)) != 0 &&\n                (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) != 0)\n            {\n                return false;\n            } 354868"];
5638 [label="LookupOptions onlyOptions = options &\n                (LookupOptions.NamespaceAliasesOnly\n                 | LookupOptions.NamespacesOrTypesOnly\n                 | LookupOptions.AllMethodsOnArityZero); 354869"];
5639 [label="LookupOptions onlyOptions = options &\n                (LookupOptions.NamespaceAliasesOnly\n                 | LookupOptions.NamespacesOrTypesOnly\n                 | LookupOptions.AllMethodsOnArityZero); 354870"];
5640 [label="return OnlyOneBitSet(onlyOptions); 354871"];
5641 [label="OnlyOneBitSet(onlyOptions) 354872"];
5642 [label="param OnlyOneBitSet(LookupOptions o) 354873"];
5643 [label="return (o & (o - 1)) == 0; 354874"];
5644 [label="return (o & (o - 1)) == 0; 354875"];
5645 [label="Binder binder = null; 354876"];
5646 [label="for (var scope = this; scope != null && !result.IsMultiViable; scope = scope.Next)\n            {\n                if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                }\n\n                if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                }\n            } 354877"];
5647 [label="for (var scope = this; scope != null && !result.IsMultiViable; scope = scope.Next)\n            {\n                if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                }\n\n                if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                }\n            } 354878"];
5648 [label="result.IsMultiViable 354879"];
5649 [label="get\n            {\n                return Kind == LookupResultKind.Viable;\n            } 354880"];
5650 [label="Kind 354881"];
5651 [label="get\n            {\n                return _kind;\n            } 354882"];
5652 [label="return _kind; 354883"];
5653 [label="return Kind == LookupResultKind.Viable; 354884"];
5654 [label="for (var scope = this; scope != null && !result.IsMultiViable; scope = scope.Next)\n            {\n                if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                }\n\n                if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                }\n            } 354885"];
5655 [label="for (var scope = this; scope != null && !result.IsMultiViable; scope = scope.Next)\n            {\n                if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                }\n\n                if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                }\n            } 354886"];
5656 [label="if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                } 354887"];
5657 [label="if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                } 354888"];
5658 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354889"];
5659 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354890"];
5660 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354891"];
5661 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354892"];
5662 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354893"];
5663 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354894"];
5664 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354895"];
5665 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354896"];
5666 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics) 354897"];
5667 [label="param LookupSymbolsInSingleBinder(LookupResult result) 354898"];
5668 [label="param LookupSymbolsInSingleBinder(string name) 354899"];
5669 [label="param LookupSymbolsInSingleBinder(int arity) 354900"];
5670 [label="param LookupSymbolsInSingleBinder(ConsList<TypeSymbol> basesBeingResolved) 354901"];
5671 [label="param LookupSymbolsInSingleBinder(LookupOptions options) 354902"];
5672 [label="param LookupSymbolsInSingleBinder(Binder originalBinder) 354903"];
5673 [label="param LookupSymbolsInSingleBinder(bool diagnose) 354904"];
5674 [label="param LookupSymbolsInSingleBinder(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 354905"];
5675 [label="param LookupSymbolsInSingleBinder(this) 354906"];
5676 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354907"];
5677 [label="result.IsClear 354908"];
5678 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 354909"];
5679 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354910"];
5680 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354911"];
5681 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354912"];
5682 [label="if (!result.IsClear)\n                    {\n                        binder = scope;\n                    } 354913"];
5683 [label="if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                } 354914"];
5684 [label="if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                } 354915"];
5685 [label="for (var scope = this; scope != null && !result.IsMultiViable; scope = scope.Next)\n            {\n                if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                }\n\n                if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                }\n            } 354916"];
5686 [label="if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                } 354917"];
5687 [label="if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                } 354918"];
5688 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354919"];
5689 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354920"];
5690 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354921"];
5691 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354922"];
5692 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354923"];
5693 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354924"];
5694 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354925"];
5695 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354926"];
5696 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics) 354927"];
5697 [label="param LookupSymbolsInSingleBinder(LookupResult result) 354928"];
5698 [label="param LookupSymbolsInSingleBinder(string name) 354929"];
5699 [label="param LookupSymbolsInSingleBinder(int arity) 354930"];
5700 [label="param LookupSymbolsInSingleBinder(ConsList<TypeSymbol> basesBeingResolved) 354931"];
5701 [label="param LookupSymbolsInSingleBinder(LookupOptions options) 354932"];
5702 [label="param LookupSymbolsInSingleBinder(Binder originalBinder) 354933"];
5703 [label="param LookupSymbolsInSingleBinder(bool diagnose) 354934"];
5704 [label="param LookupSymbolsInSingleBinder(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 354935"];
5705 [label="param LookupSymbolsInSingleBinder(this) 354936"];
5706 [label="result.IsClear 354937"];
5707 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 354938"];
5708 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354939"];
5709 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354940"];
5710 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354941"];
5711 [label="Debug.Assert(result.IsClear); 354942"];
5712 [label="LookupMask 354943"];
5713 [label="get\n            {\n                return LookupOptions.NamespaceAliasesOnly | LookupOptions.MustBeInvocableIfMember;\n            } 354944"];
5714 [label="return LookupOptions.NamespaceAliasesOnly | LookupOptions.MustBeInvocableIfMember; 354945"];
5715 [label="if ((options & LookupMask) != 0)\n            {\n                return;\n            } 354946"];
5716 [label="if ((options & LookupMask) != 0)\n            {\n                return;\n            } 354947"];
5717 [label="if ((options & LookupMask) != 0)\n            {\n                return;\n            } 354948"];
5718 [label="TypeParameterMap 354949"];
5719 [label="get\n            {\n                if (_lazyTypeParameterMap == null)\n                {\n                    var result = new MultiDictionary<string, TypeParameterSymbol>();\n                    foreach (TypeParameterSymbol tps in _namedType.TypeParameters)\n                    {\n                        result.Add(tps.Name, tps);\n                    }\n                    Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null);\n                }\n                return _lazyTypeParameterMap;\n            } 354950"];
5720 [label="if (_lazyTypeParameterMap == null)\n                {\n                    var result = new MultiDictionary<string, TypeParameterSymbol>();\n                    foreach (TypeParameterSymbol tps in _namedType.TypeParameters)\n                    {\n                        result.Add(tps.Name, tps);\n                    }\n                    Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null);\n                } 354951"];
5721 [label="if (_lazyTypeParameterMap == null)\n                {\n                    var result = new MultiDictionary<string, TypeParameterSymbol>();\n                    foreach (TypeParameterSymbol tps in _namedType.TypeParameters)\n                    {\n                        result.Add(tps.Name, tps);\n                    }\n                    Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null);\n                } 354952"];
5722 [label="var result = new MultiDictionary<string, TypeParameterSymbol>(); 354953"];
5723 [label="_namedType.TypeParameters 354954"];
5724 [label="get\n            {\n                if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                }\n\n                return _lazyTypeParameters;\n            } 354955"];
5725 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                } 354956"];
5726 [label="var diagnostics = DiagnosticBag.GetInstance(); 354957"];
5727 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 354958"];
5728 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 354959"];
5729 [label="AddDeclarationDiagnostics(diagnostics); 354960"];
5730 [label="AddDeclarationDiagnostics(diagnostics) 354961"];
5731 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 354962"];
5732 [label="param AddDeclarationDiagnostics(this) 354963"];
5733 [label="ContainingSymbol 354964"];
5734 [label="get\n            {\n                return _containingSymbol;\n            } 354965"];
5735 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 354966"];
5736 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 354967"];
5737 [label="AddDeclarationDiagnostics(diagnostics); 354968"];
5738 [label="diagnostics.Free(); 354969"];
5739 [label="return _lazyTypeParameters; 354970"];
5740 [label="foreach (TypeParameterSymbol tps in _namedType.TypeParameters)\n                    {\n                        result.Add(tps.Name, tps);\n                    } 354971"];
5741 [label="Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null); 354972"];
5742 [label="Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null); 354973"];
5743 [label="Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null); 354974"];
5744 [label="Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null); 354975"];
5745 [label="return _lazyTypeParameterMap; 354976"];
5746 [label="foreach (var typeParameter in TypeParameterMap[name])\n            {\n                result.MergeEqual(originalBinder.CheckViability(typeParameter, arity, options, null, diagnose, ref useSiteDiagnostics));\n            } 354977"];
5747 [label="foreach (var typeParameter in TypeParameterMap[name])\n            {\n                result.MergeEqual(originalBinder.CheckViability(typeParameter, arity, options, null, diagnose, ref useSiteDiagnostics));\n            } 354978"];
5748 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354979"];
5749 [label="result.IsClear 354980"];
5750 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 354981"];
5751 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354982"];
5752 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354983"];
5753 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 354984"];
5754 [label="if (!result.IsClear)\n                    {\n                        binder = scope;\n                    } 354985"];
5755 [label="if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                } 354986"];
5756 [label="if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                } 354987"];
5757 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354988"];
5758 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354989"];
5759 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354990"];
5760 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354991"];
5761 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 354992"];
5762 [label="param LookupSymbolsInSingleBinder(LookupResult result) 354993"];
5763 [label="param LookupSymbolsInSingleBinder(string name) 354994"];
5764 [label="param LookupSymbolsInSingleBinder(int arity) 354995"];
5765 [label="param LookupSymbolsInSingleBinder(ConsList<TypeSymbol> basesBeingResolved) 354996"];
5766 [label="param LookupSymbolsInSingleBinder(LookupOptions options) 354997"];
5767 [label="param LookupSymbolsInSingleBinder(Binder originalBinder) 354998"];
5768 [label="param LookupSymbolsInSingleBinder(bool diagnose) 354999"];
5769 [label="param LookupSymbolsInSingleBinder(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 355000"];
5770 [label="param LookupSymbolsInSingleBinder(this) 355001"];
5771 [label="result.IsClear 355002"];
5772 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 355003"];
5773 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 355004"];
5774 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 355005"];
5775 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 355006"];
5776 [label="Debug.Assert(result.IsClear); 355007"];
5777 [label="IsSubmissionClass 355008"];
5778 [label="get { return (_container?.Kind == SymbolKind.NamedType) && ((NamedTypeSymbol)_container).IsSubmissionClass; } 355009"];
5779 [label=".Kind 355010"];
5780 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 355011"];
5781 [label="return (_container?.Kind == SymbolKind.NamedType) && ((NamedTypeSymbol)_container).IsSubmissionClass; 355012"];
5782 [label="if (IsSubmissionClass)\n            {\n                this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics);\n                return;\n            } 355013"];
5783 [label="var imports = GetImports(basesBeingResolved); 355014"];
5784 [label="GetImports(basesBeingResolved) 355015"];
5785 [label="param GetImports(ConsList<TypeSymbol> basesBeingResolved) 355016"];
5786 [label="param GetImports(this) 355017"];
5787 [label="Debug.Assert(_lazyImports != null || _computeImports != null, 'Have neither imports nor a way to compute them.'); 355018"];
5788 [label="Debug.Assert(_lazyImports != null || _computeImports != null, 'Have neither imports nor a way to compute them.'); 355019"];
5789 [label="if (_lazyImports == null)\n            {\n                Interlocked.CompareExchange(ref _lazyImports, _computeImports(basesBeingResolved), null);\n            } 355020"];
5790 [label="if (_lazyImports == null)\n            {\n                Interlocked.CompareExchange(ref _lazyImports, _computeImports(basesBeingResolved), null);\n            } 355021"];
5791 [label="null 355022"];
5792 [label="ImmutableDictionary<string, AliasAndUsingDirective>.Empty 355023"];
5793 [label="ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty 355024"];
5794 [label="ImmutableArray<AliasAndExternAliasDirective>.Empty 355025"];
5795 [label="null 355026"];
5796 [label="new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 355027"];
5797 [label="param Imports(CSharpCompilation compilation) 355028"];
5798 [label="param Imports(ImmutableDictionary<string, AliasAndUsingDirective> usingAliases) 355029"];
5799 [label="param Imports(ImmutableArray<NamespaceOrTypeAndUsingDirective> usings) 355030"];
5800 [label="param Imports(ImmutableArray<AliasAndExternAliasDirective> externs) 355031"];
5801 [label="param Imports(DiagnosticBag diagnostics) 355032"];
5802 [label="param Imports(this) 355033"];
5803 [label="_compilation 355034"];
5804 [label="_diagnostics 355035"];
5805 [label="UsingAliases 355036"];
5806 [label="Debug.Assert(usingAliases != null); 355037"];
5807 [label="Debug.Assert(usingAliases != null); 355038"];
5808 [label="Debug.Assert(!usings.IsDefault); 355039"];
5809 [label="Debug.Assert(!externs.IsDefault); 355040"];
5810 [label="_compilation 355041"];
5811 [label="this.UsingAliases 355042"];
5812 [label="this.Usings 355043"];
5813 [label="_diagnostics 355044"];
5814 [label="this.ExternAliases 355045"];
5815 [label="Empty = new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 355046"];
5816 [label="Interlocked.CompareExchange(ref _lazyImports, _computeImports(basesBeingResolved), null); 355047"];
5817 [label="Interlocked.CompareExchange(ref _lazyImports, _computeImports(basesBeingResolved), null); 355048"];
5818 [label="Interlocked.CompareExchange(ref _lazyImports, _computeImports(basesBeingResolved), null); 355049"];
5819 [label="param FromSyntax(CSharpSyntaxNode declarationSyntax) 355050"];
5820 [label="param FromSyntax(InContainerBinder binder) 355051"];
5821 [label="param FromSyntax(ConsList<TypeSymbol> basesBeingResolved) 355052"];
5822 [label="param FromSyntax(bool inUsing) 355053"];
5823 [label="SyntaxList<UsingDirectiveSyntax> usingDirectives; 355054"];
5824 [label="usingDirectives 355055"];
5825 [label="SyntaxList<ExternAliasDirectiveSyntax> externAliasDirectives; 355056"];
5826 [label="externAliasDirectives 355057"];
5827 [label="if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n            {\n                var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                // using directives are not in scope within using directives\n                usingDirectives = inUsing ? default(SyntaxList<UsingDirectiveSyntax>) : compilationUnit.Usings;\n                externAliasDirectives = compilationUnit.Externs;\n            }\n            else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n            {\n                var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                // using directives are not in scope within using directives\n                usingDirectives = inUsing ? default(SyntaxList<UsingDirectiveSyntax>) : namespaceDecl.Usings;\n                externAliasDirectives = namespaceDecl.Externs;\n            }\n            else\n            {\n                return Empty;\n            } 355058"];
5828 [label="if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n            {\n                var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                // using directives are not in scope within using directives\n                usingDirectives = inUsing ? default(SyntaxList<UsingDirectiveSyntax>) : namespaceDecl.Usings;\n                externAliasDirectives = namespaceDecl.Externs;\n            }\n            else\n            {\n                return Empty;\n            } 355059"];
5829 [label="var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax; 355060"];
5830 [label="inUsing 355061"];
5831 [label="namespaceDecl.Usings 355062"];
5832 [label="usingDirectives = inUsing ? default(SyntaxList<UsingDirectiveSyntax>) : namespaceDecl.Usings; 355063"];
5833 [label="externAliasDirectives = namespaceDecl.Externs; 355064"];
5834 [label="if (usingDirectives.Count == 0 && externAliasDirectives.Count == 0)\n            {\n                return Empty;\n            } 355065"];
5835 [label="if (usingDirectives.Count == 0 && externAliasDirectives.Count == 0)\n            {\n                return Empty;\n            } 355066"];
5836 [label="if (usingDirectives.Count == 0 && externAliasDirectives.Count == 0)\n            {\n                return Empty;\n            } 355067"];
5837 [label="if (usingDirectives.Count == 0 && externAliasDirectives.Count == 0)\n            {\n                return Empty;\n            } 355068"];
5838 [label="return Empty; 355069"];
5839 [label="Interlocked.CompareExchange(ref _lazyImports, _computeImports(basesBeingResolved), null); 355070"];
5840 [label="return _lazyImports; 355071"];
5841 [label="if ((options & LookupOptions.NamespaceAliasesOnly) == 0 && _container != null)\n            {\n                this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics);\n\n                if (result.IsMultiViable)\n                {\n                    // symbols cannot conflict with using alias names\n                    if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    }\n\n                    return;\n                }\n            } 355072"];
5842 [label="if ((options & LookupOptions.NamespaceAliasesOnly) == 0 && _container != null)\n            {\n                this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics);\n\n                if (result.IsMultiViable)\n                {\n                    // symbols cannot conflict with using alias names\n                    if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    }\n\n                    return;\n                }\n            } 355073"];
5843 [label="_container != null 355074"];
5844 [label="param !=(Symbol left) 355075"];
5845 [label="param !=(Symbol right) 355076"];
5846 [label="if (right is null)\n            {\n                return left is object;\n            } 355077"];
5847 [label="return left is object; 355078"];
5848 [label="if ((options & LookupOptions.NamespaceAliasesOnly) == 0 && _container != null)\n            {\n                this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics);\n\n                if (result.IsMultiViable)\n                {\n                    // symbols cannot conflict with using alias names\n                    if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    }\n\n                    return;\n                }\n            } 355079"];
5849 [label="if ((options & LookupOptions.NamespaceAliasesOnly) == 0 && _container != null)\n            {\n                this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics);\n\n                if (result.IsMultiViable)\n                {\n                    // symbols cannot conflict with using alias names\n                    if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    }\n\n                    return;\n                }\n            } 355080"];
5850 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 355081"];
5851 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 355082"];
5852 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 355083"];
5853 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 355084"];
5854 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 355085"];
5855 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 355086"];
5856 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 355087"];
5857 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 355088"];
5858 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 355089"];
5859 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics) 355090"];
5860 [label="param LookupMembersInternal(LookupResult result) 355091"];
5861 [label="param LookupMembersInternal(NamespaceOrTypeSymbol nsOrType) 355092"];
5862 [label="param LookupMembersInternal(string name) 355093"];
5863 [label="param LookupMembersInternal(int arity) 355094"];
5864 [label="param LookupMembersInternal(ConsList<TypeSymbol> basesBeingResolved) 355095"];
5865 [label="param LookupMembersInternal(LookupOptions options) 355096"];
5866 [label="param LookupMembersInternal(Binder originalBinder) 355097"];
5867 [label="param LookupMembersInternal(bool diagnose) 355098"];
5868 [label="param LookupMembersInternal(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 355099"];
5869 [label="param LookupMembersInternal(this) 355100"];
5870 [label="Debug.Assert(options.AreValid()); 355101"];
5871 [label="options.AreValid() 355102"];
5872 [label="param AreValid(this LookupOptions options) 355103"];
5873 [label="if (options == LookupOptions.Default)\n            {\n                return true;\n            } 355104"];
5874 [label="if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return options == LookupOptions.LabelsOnly;\n            } 355105"];
5875 [label="if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return options == LookupOptions.LabelsOnly;\n            } 355106"];
5876 [label="LookupOptions mustBeAndNotBeInstance = (LookupOptions.MustBeInstance | LookupOptions.MustNotBeInstance); 355107"];
5877 [label="if ((options & mustBeAndNotBeInstance) == mustBeAndNotBeInstance)\n            {\n                return false;\n            } 355108"];
5878 [label="if ((options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustNotBeMethodTypeParameter)) != 0 &&\n                (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) != 0)\n            {\n                return false;\n            } 355109"];
5879 [label="if ((options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustNotBeMethodTypeParameter)) != 0 &&\n                (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) != 0)\n            {\n                return false;\n            } 355110"];
5880 [label="if ((options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustNotBeMethodTypeParameter)) != 0 &&\n                (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) != 0)\n            {\n                return false;\n            } 355111"];
5881 [label="LookupOptions onlyOptions = options &\n                (LookupOptions.NamespaceAliasesOnly\n                 | LookupOptions.NamespacesOrTypesOnly\n                 | LookupOptions.AllMethodsOnArityZero); 355112"];
5882 [label="LookupOptions onlyOptions = options &\n                (LookupOptions.NamespaceAliasesOnly\n                 | LookupOptions.NamespacesOrTypesOnly\n                 | LookupOptions.AllMethodsOnArityZero); 355113"];
5883 [label="return OnlyOneBitSet(onlyOptions); 355114"];
5884 [label="OnlyOneBitSet(onlyOptions) 355115"];
5885 [label="param OnlyOneBitSet(LookupOptions o) 355116"];
5886 [label="return (o & (o - 1)) == 0; 355117"];
5887 [label="return (o & (o - 1)) == 0; 355118"];
5888 [label="Debug.Assert(arity >= 0); 355119"];
5889 [label="Debug.Assert(arity >= 0); 355120"];
5890 [label="nsOrType.IsNamespace 355121"];
5891 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 355122"];
5892 [label="Kind 355123"];
5893 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 355124"];
5894 [label="return Kind == SymbolKind.Namespace; 355125"];
5895 [label="if (nsOrType.IsNamespace)\n            {\n                LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics);\n            }\n            else\n            {\n                this.LookupMembersInType(result, (TypeSymbol)nsOrType, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics);\n            } 355126"];
5896 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 355127"];
5897 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 355128"];
5898 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 355129"];
5899 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 355130"];
5900 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 355131"];
5901 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 355132"];
5902 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 355133"];
5903 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 355134"];
5904 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics) 355135"];
5905 [label="param LookupMembersInNamespace(LookupResult result) 355136"];
5906 [label="param LookupMembersInNamespace(NamespaceSymbol ns) 355137"];
5907 [label="param LookupMembersInNamespace(string name) 355138"];
5908 [label="param LookupMembersInNamespace(int arity) 355139"];
5909 [label="param LookupMembersInNamespace(LookupOptions options) 355140"];
5910 [label="param LookupMembersInNamespace(Binder originalBinder) 355141"];
5911 [label="param LookupMembersInNamespace(bool diagnose) 355142"];
5912 [label="param LookupMembersInNamespace(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 355143"];
5913 [label="var members = GetCandidateMembers(ns, name, options, originalBinder); 355144"];
5914 [label="var members = GetCandidateMembers(ns, name, options, originalBinder); 355145"];
5915 [label="var members = GetCandidateMembers(ns, name, options, originalBinder); 355146"];
5916 [label="var members = GetCandidateMembers(ns, name, options, originalBinder); 355147"];
5917 [label="GetCandidateMembers(ns, name, options, originalBinder) 355148"];
5918 [label="param GetCandidateMembers(NamespaceOrTypeSymbol nsOrType) 355149"];
5919 [label="param GetCandidateMembers(string name) 355150"];
5920 [label="param GetCandidateMembers(LookupOptions options) 355151"];
5921 [label="param GetCandidateMembers(Binder originalBinder) 355152"];
5922 [label="if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && nsOrType is TypeSymbol)\n            {\n                return nsOrType.GetTypeMembers(name).Cast<NamedTypeSymbol, Symbol>();\n            }\n            else if (nsOrType.Kind == SymbolKind.NamedType && originalBinder.IsEarlyAttributeBinder)\n            {\n                return ((NamedTypeSymbol)nsOrType).GetEarlyAttributeDecodingMembers(name);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return ImmutableArray<Symbol>.Empty;\n            }\n            else\n            {\n                return nsOrType.GetMembers(name);\n            } 355153"];
5923 [label="if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && nsOrType is TypeSymbol)\n            {\n                return nsOrType.GetTypeMembers(name).Cast<NamedTypeSymbol, Symbol>();\n            }\n            else if (nsOrType.Kind == SymbolKind.NamedType && originalBinder.IsEarlyAttributeBinder)\n            {\n                return ((NamedTypeSymbol)nsOrType).GetEarlyAttributeDecodingMembers(name);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return ImmutableArray<Symbol>.Empty;\n            }\n            else\n            {\n                return nsOrType.GetMembers(name);\n            } 355154"];
5924 [label="if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && nsOrType is TypeSymbol)\n            {\n                return nsOrType.GetTypeMembers(name).Cast<NamedTypeSymbol, Symbol>();\n            }\n            else if (nsOrType.Kind == SymbolKind.NamedType && originalBinder.IsEarlyAttributeBinder)\n            {\n                return ((NamedTypeSymbol)nsOrType).GetEarlyAttributeDecodingMembers(name);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return ImmutableArray<Symbol>.Empty;\n            }\n            else\n            {\n                return nsOrType.GetMembers(name);\n            } 355155"];
5925 [label="nsOrType.Kind 355156"];
5926 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 355157"];
5927 [label="if (nsOrType.Kind == SymbolKind.NamedType && originalBinder.IsEarlyAttributeBinder)\n            {\n                return ((NamedTypeSymbol)nsOrType).GetEarlyAttributeDecodingMembers(name);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return ImmutableArray<Symbol>.Empty;\n            }\n            else\n            {\n                return nsOrType.GetMembers(name);\n            } 355158"];
5928 [label="if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return ImmutableArray<Symbol>.Empty;\n            }\n            else\n            {\n                return nsOrType.GetMembers(name);\n            } 355159"];
5929 [label="if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return ImmutableArray<Symbol>.Empty;\n            }\n            else\n            {\n                return nsOrType.GetMembers(name);\n            } 355160"];
5930 [label="return nsOrType.GetMembers(name); 355161"];
5931 [label="nsOrType.GetMembers(name) 355162"];
5932 [label="param GetMembers(string name) 355163"];
5933 [label="foreach (Symbol member in members)\n            {\n                SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics);\n                result.MergeEqual(resultOfThisMember);\n            } 355164"];
5934 [label="SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics); 355165"];
5935 [label="SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics); 355166"];
5936 [label="SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics); 355167"];
5937 [label="SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics); 355168"];
5938 [label="SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics); 355169"];
5939 [label="originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics) 355170"];
5940 [label="param CheckViability(Symbol symbol) 355171"];
5941 [label="param CheckViability(int arity) 355172"];
5942 [label="param CheckViability(LookupOptions options) 355173"];
5943 [label="param CheckViability(TypeSymbol accessThroughType) 355174"];
5944 [label="param CheckViability(bool diagnose) 355175"];
5945 [label="param CheckViability(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 355176"];
5946 [label="param CheckViability(ConsList<TypeSymbol> basesBeingResolved = null) 355177"];
5947 [label="param CheckViability(this) 355178"];
5948 [label="bool inaccessibleViaQualifier; 355179"];
5949 [label="DiagnosticInfo diagInfo; 355180"];
5950 [label="symbol.Kind 355181"];
5951 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355182"];
5952 [label="var unwrappedSymbol = symbol.Kind == SymbolKind.Alias\n                ? ((AliasSymbol)symbol).GetAliasTarget(basesBeingResolved)\n                : symbol; 355183"];
5953 [label="symbol.Kind == SymbolKind.Alias 355184"];
5954 [label="var unwrappedSymbol = symbol.Kind == SymbolKind.Alias\n                ? ((AliasSymbol)symbol).GetAliasTarget(basesBeingResolved)\n                : symbol; 355185"];
5955 [label="this.Compilation.SourceModule 355186"];
5956 [label="get\n            {\n                return Assembly.Modules[0];\n            } 355187"];
5957 [label="GetBoundReferenceManager(); 355188"];
5958 [label="if (!this.Compilation.SourceModule.Equals(unwrappedSymbol.ContainingModule) && unwrappedSymbol.IsHiddenByCodeAnalysisEmbeddedAttribute())\n            {\n                return LookupResult.Empty();\n            }\n            else if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355189"];
5959 [label="unwrappedSymbol.ContainingModule 355190"];
5960 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 355191"];
5961 [label="return _containingSymbol; 355192"];
5962 [label="if (!this.Compilation.SourceModule.Equals(unwrappedSymbol.ContainingModule) && unwrappedSymbol.IsHiddenByCodeAnalysisEmbeddedAttribute())\n            {\n                return LookupResult.Empty();\n            }\n            else if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355193"];
5963 [label="this.Compilation.SourceModule.Equals(unwrappedSymbol.ContainingModule) 355194"];
5964 [label="param Equals(object obj) 355195"];
5965 [label="param Equals(this) 355196"];
5966 [label="return this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind); 355197"];
5967 [label="return this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind); 355198"];
5968 [label="this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind) 355199"];
5969 [label="param Equals(Symbol other) 355200"];
5970 [label="param Equals(TypeCompareKind compareKind) 355201"];
5971 [label="param Equals(this) 355202"];
5972 [label="return (object)this == other; 355203"];
5973 [label="if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355204"];
5974 [label="if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355205"];
5975 [label="if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355206"];
5976 [label="if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355207"];
5977 [label="if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355208"];
5978 [label="WrongArity(symbol, arity, diagnose, options, out diagInfo) 355209"];
5979 [label="param WrongArity(Symbol symbol) 355210"];
5980 [label="param WrongArity(int arity) 355211"];
5981 [label="param WrongArity(bool diagnose) 355212"];
5982 [label="param WrongArity(LookupOptions options) 355213"];
5983 [label="param WrongArity(out DiagnosticInfo diagInfo) 355214"];
5984 [label="symbol.Kind 355215"];
5985 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355216"];
5986 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                    if (arity != 0 || (options & LookupOptions.AllNamedTypesOnArityZero) == 0)\n                    {\n                        NamedTypeSymbol namedType = (NamedTypeSymbol)symbol;\n                        // non-declared types only appear as using aliases (aliases are arity 0)\n                        Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType));\n                        if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        }\n                    }\n                    break;\n\n                case SymbolKind.Method:\n                    if (arity != 0 || (options & LookupOptions.AllMethodsOnArityZero) == 0)\n                    {\n                        MethodSymbol method = (MethodSymbol)symbol;\n                        if (method.Arity != arity)\n                        {\n                            if (method.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, method, MessageID.IDS_SK_METHOD.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, method, MessageID.IDS_SK_METHOD.Localize(), method.Arity) : null;\n                            }\n                            return true;\n                        }\n                    }\n                    break;\n\n                default:\n                    if (arity != 0)\n                    {\n                        diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_TypeArgsNotAllowed, symbol, symbol.Kind.Localize()) : null;\n                        return true;\n                    }\n                    break;\n            } 355217"];
5987 [label="if (arity != 0 || (options & LookupOptions.AllNamedTypesOnArityZero) == 0)\n                    {\n                        NamedTypeSymbol namedType = (NamedTypeSymbol)symbol;\n                        // non-declared types only appear as using aliases (aliases are arity 0)\n                        Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType));\n                        if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        }\n                    } 355218"];
5988 [label="if (arity != 0 || (options & LookupOptions.AllNamedTypesOnArityZero) == 0)\n                    {\n                        NamedTypeSymbol namedType = (NamedTypeSymbol)symbol;\n                        // non-declared types only appear as using aliases (aliases are arity 0)\n                        Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType));\n                        if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        }\n                    } 355219"];
5989 [label="if (arity != 0 || (options & LookupOptions.AllNamedTypesOnArityZero) == 0)\n                    {\n                        NamedTypeSymbol namedType = (NamedTypeSymbol)symbol;\n                        // non-declared types only appear as using aliases (aliases are arity 0)\n                        Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType));\n                        if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        }\n                    } 355220"];
5990 [label="if (arity != 0 || (options & LookupOptions.AllNamedTypesOnArityZero) == 0)\n                    {\n                        NamedTypeSymbol namedType = (NamedTypeSymbol)symbol;\n                        // non-declared types only appear as using aliases (aliases are arity 0)\n                        Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType));\n                        if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        }\n                    } 355221"];
5991 [label="NamedTypeSymbol namedType = (NamedTypeSymbol)symbol; 355222"];
5992 [label="namedType.ConstructedFrom 355223"];
5993 [label="get { return this; } 355224"];
5994 [label="return this; 355225"];
5995 [label="Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType)); 355226"];
5996 [label="Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType)); 355227"];
5997 [label="namedType.Arity 355228"];
5998 [label="get\n            {\n                return declaration.Arity;\n            } 355229"];
5999 [label="if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        } 355230"];
6000 [label="if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        } 355231"];
6001 [label="options.IsAttributeTypeLookup() 355232"];
6002 [label="param IsAttributeTypeLookup(this LookupOptions options) 355233"];
6003 [label="if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        } 355234"];
6004 [label="diagInfo = null; 355235"];
6005 [label="return false; 355236"];
6006 [label="if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355237"];
6007 [label="InCref 355238"];
6008 [label="get { return this.Flags.Includes(BinderFlags.Cref); } 355239"];
6009 [label="return this.Flags.Includes(BinderFlags.Cref); 355240"];
6010 [label="return this.Flags.Includes(BinderFlags.Cref); 355241"];
6011 [label="this.Flags.Includes(BinderFlags.Cref) 355242"];
6012 [label="param Includes(this BinderFlags self) 355243"];
6013 [label="param Includes(BinderFlags other) 355244"];
6014 [label="if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355245"];
6015 [label="unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters 355246"];
6016 [label="get\n            {\n                if (this.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)this;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Ordinary:\n                        case MethodKind.LocalFunction:\n                        case MethodKind.DelegateInvoke:\n                        case MethodKind.Destructor: // See comment in CanBeReferencedByName.\n                            return true;\n                        case MethodKind.PropertyGet:\n                        case MethodKind.PropertySet:\n                            return ((PropertySymbol)method.AssociatedSymbol).CanCallMethodsDirectly();\n                        default:\n                            return false;\n                    }\n                }\n                return true;\n            } 355247"];
6017 [label="this.Kind 355248"];
6018 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355249"];
6019 [label="if (this.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)this;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Ordinary:\n                        case MethodKind.LocalFunction:\n                        case MethodKind.DelegateInvoke:\n                        case MethodKind.Destructor: // See comment in CanBeReferencedByName.\n                            return true;\n                        case MethodKind.PropertyGet:\n                        case MethodKind.PropertySet:\n                            return ((PropertySymbol)method.AssociatedSymbol).CanCallMethodsDirectly();\n                        default:\n                            return false;\n                    }\n                } 355250"];
6020 [label="return true; 355251"];
6021 [label="if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355252"];
6022 [label="if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355253"];
6023 [label="if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355254"];
6024 [label="if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355255"];
6025 [label="if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355256"];
6026 [label="if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355257"];
6027 [label="InCref 355258"];
6028 [label="if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355259"];
6029 [label="InCref 355260"];
6030 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355261"];
6031 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355262"];
6032 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355263"];
6033 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355264"];
6034 [label="RefineAccessThroughType(options, accessThroughType) 355265"];
6035 [label="param RefineAccessThroughType(LookupOptions options) 355266"];
6036 [label="param RefineAccessThroughType(TypeSymbol accessThroughType) 355267"];
6037 [label="return ((options & LookupOptions.UseBaseReferenceAccessibility) != 0)\n                ? null\n                : accessThroughType; 355268"];
6038 [label="return ((options & LookupOptions.UseBaseReferenceAccessibility) != 0)\n                ? null\n                : accessThroughType; 355269"];
6039 [label="((options & LookupOptions.UseBaseReferenceAccessibility) != 0) 355270"];
6040 [label="return ((options & LookupOptions.UseBaseReferenceAccessibility) != 0)\n                ? null\n                : accessThroughType; 355271"];
6041 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355272"];
6042 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355273"];
6043 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355274"];
6044 [label="this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved) 355275"];
6045 [label="param IsAccessible(Symbol symbol) 355276"];
6046 [label="param IsAccessible(TypeSymbol accessThroughType) 355277"];
6047 [label="param IsAccessible(out bool failedThroughTypeCheck) 355278"];
6048 [label="param IsAccessible(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 355279"];
6049 [label="param IsAccessible(ConsList<TypeSymbol> basesBeingResolved = null) 355280"];
6050 [label="param IsAccessible(this) 355281"];
6051 [label="if (this.Flags.Includes(BinderFlags.IgnoreAccessibility))\n            {\n                failedThroughTypeCheck = false;\n                return true;\n            } 355282"];
6052 [label="if (this.Flags.Includes(BinderFlags.IgnoreAccessibility))\n            {\n                failedThroughTypeCheck = false;\n                return true;\n            } 355283"];
6053 [label="this.Flags.Includes(BinderFlags.IgnoreAccessibility) 355284"];
6054 [label="param Includes(this BinderFlags self) 355285"];
6055 [label="param Includes(BinderFlags other) 355286"];
6056 [label="return IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355287"];
6057 [label="return IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355288"];
6058 [label="return IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355289"];
6059 [label="return IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355290"];
6060 [label="return IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355291"];
6061 [label="IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved) 355292"];
6062 [label="param IsAccessibleHelper(Symbol symbol) 355293"];
6063 [label="param IsAccessibleHelper(TypeSymbol accessThroughType) 355294"];
6064 [label="param IsAccessibleHelper(out bool failedThroughTypeCheck) 355295"];
6065 [label="param IsAccessibleHelper(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 355296"];
6066 [label="param IsAccessibleHelper(ConsList<TypeSymbol> basesBeingResolved) 355297"];
6067 [label="param IsAccessibleHelper(this) 355298"];
6068 [label="return Next.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355299"];
6069 [label="return Next.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355300"];
6070 [label="return Next.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355301"];
6071 [label="return Next.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355302"];
6072 [label="return Next.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355303"];
6073 [label="Next.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved) 355304"];
6074 [label="param IsAccessibleHelper(Symbol symbol) 355305"];
6075 [label="param IsAccessibleHelper(TypeSymbol accessThroughType) 355306"];
6076 [label="param IsAccessibleHelper(out bool failedThroughTypeCheck) 355307"];
6077 [label="param IsAccessibleHelper(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 355308"];
6078 [label="param IsAccessibleHelper(ConsList<TypeSymbol> basesBeingResolved) 355309"];
6079 [label="param IsAccessibleHelper(this) 355310"];
6080 [label="return this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355311"];
6081 [label="return this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355312"];
6082 [label="return this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355313"];
6083 [label="return this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355314"];
6084 [label="return this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355315"];
6085 [label="return this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355316"];
6086 [label="this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved) 355317"];
6087 [label="param IsSymbolAccessibleConditional(Symbol symbol) 355318"];
6088 [label="param IsSymbolAccessibleConditional(NamedTypeSymbol within) 355319"];
6089 [label="param IsSymbolAccessibleConditional(TypeSymbol throughTypeOpt) 355320"];
6090 [label="param IsSymbolAccessibleConditional(out bool failedThroughTypeCheck) 355321"];
6091 [label="param IsSymbolAccessibleConditional(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 355322"];
6092 [label="param IsSymbolAccessibleConditional(ConsList<TypeSymbol>? basesBeingResolved = null) 355323"];
6093 [label="param IsSymbolAccessibleConditional(this) 355324"];
6094 [label="if (this.Flags.Includes(BinderFlags.IgnoreAccessibility))\n            {\n                failedThroughTypeCheck = false;\n                return true;\n            } 355325"];
6095 [label="if (this.Flags.Includes(BinderFlags.IgnoreAccessibility))\n            {\n                failedThroughTypeCheck = false;\n                return true;\n            } 355326"];
6096 [label="this.Flags.Includes(BinderFlags.IgnoreAccessibility) 355327"];
6097 [label="param Includes(this BinderFlags self) 355328"];
6098 [label="param Includes(BinderFlags other) 355329"];
6099 [label="return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355330"];
6100 [label="return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355331"];
6101 [label="return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355332"];
6102 [label="return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355333"];
6103 [label="return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355334"];
6104 [label="return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 355335"];
6105 [label="AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved) 355336"];
6106 [label="param IsSymbolAccessible(Symbol symbol) 355337"];
6107 [label="param IsSymbolAccessible(NamedTypeSymbol within) 355338"];
6108 [label="param IsSymbolAccessible(TypeSymbol throughTypeOpt) 355339"];
6109 [label="param IsSymbolAccessible(out bool failedThroughTypeCheck) 355340"];
6110 [label="param IsSymbolAccessible(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 355341"];
6111 [label="param IsSymbolAccessible(ConsList<TypeSymbol> basesBeingResolved = null) 355342"];
6112 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 355343"];
6113 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 355344"];
6114 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 355345"];
6115 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 355346"];
6116 [label="within.DeclaringCompilation 355347"];
6117 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 355348"];
6118 [label="this.Kind 355349"];
6119 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355350"];
6120 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 355351"];
6121 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 355352"];
6122 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 355353"];
6123 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 355354"];
6124 [label="IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved) 355355"];
6125 [label="param IsSymbolAccessibleCore(Symbol symbol) 355356"];
6126 [label="param IsSymbolAccessibleCore(Symbol within) 355357"];
6127 [label="param IsSymbolAccessibleCore(TypeSymbol throughTypeOpt) 355358"];
6128 [label="param IsSymbolAccessibleCore(out bool failedThroughTypeCheck) 355359"];
6129 [label="param IsSymbolAccessibleCore(CSharpCompilation compilation) 355360"];
6130 [label="param IsSymbolAccessibleCore(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 355361"];
6131 [label="param IsSymbolAccessibleCore(ConsList<TypeSymbol> basesBeingResolved = null) 355362"];
6132 [label="Debug.Assert((object)symbol != null); 355363"];
6133 [label="Debug.Assert((object)symbol != null); 355364"];
6134 [label="Debug.Assert((object)within != null); 355365"];
6135 [label="Debug.Assert((object)within != null); 355366"];
6136 [label="within.IsDefinition 355367"];
6137 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 355368"];
6138 [label="OriginalDefinition 355369"];
6139 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 355370"];
6140 [label="OriginalSymbolDefinition 355371"];
6141 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 355372"];
6142 [label="this.OriginalTypeSymbolDefinition 355373"];
6143 [label="get\n            {\n                return this.OriginalDefinition;\n            } 355374"];
6144 [label="this.OriginalDefinition 355375"];
6145 [label="get\n            {\n                return this;\n            } 355376"];
6146 [label="return this.OriginalDefinition; 355377"];
6147 [label="return this.OriginalTypeSymbolDefinition; 355378"];
6148 [label="return OriginalSymbolDefinition; 355379"];
6149 [label="return (object)this == (object)OriginalDefinition; 355380"];
6150 [label="Debug.Assert(within.IsDefinition); 355381"];
6151 [label="Debug.Assert(within is NamedTypeSymbol || within is AssemblySymbol); 355382"];
6152 [label="failedThroughTypeCheck = false; 355383"];
6153 [label="symbol.Kind 355384"];
6154 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355385"];
6155 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.ArrayType:\n                    return IsSymbolAccessibleCore(((ArrayTypeSymbol)symbol).ElementType, within, null, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics, basesBeingResolved);\n\n                case SymbolKind.PointerType:\n                    return IsSymbolAccessibleCore(((PointerTypeSymbol)symbol).PointedAtType, within, null, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics, basesBeingResolved);\n\n                case SymbolKind.NamedType:\n                    return IsNamedTypeAccessible((NamedTypeSymbol)symbol, within, ref useSiteDiagnostics, basesBeingResolved);\n\n                case SymbolKind.Alias:\n                    return IsSymbolAccessibleCore(((AliasSymbol)symbol).Target, within, null, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics, basesBeingResolved);\n\n                case SymbolKind.Discard:\n                    return IsSymbolAccessibleCore(((DiscardSymbol)symbol).TypeWithAnnotations.Type, within, null, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics, basesBeingResolved);\n\n                case SymbolKind.FunctionPointerType:\n                    var funcPtr = (FunctionPointerTypeSymbol)symbol;\n                    if (!IsSymbolAccessibleCore(funcPtr.Signature.ReturnType, within, throughTypeOpt: null, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics, basesBeingResolved))\n                    {\n                        return false;\n                    }\n\n                    foreach (var param in funcPtr.Signature.Parameters)\n                    {\n                        if (!IsSymbolAccessibleCore(param.Type, within, throughTypeOpt: null, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics, basesBeingResolved))\n                        {\n                            return false;\n                        }\n                    }\n\n                    return true;\n\n                case SymbolKind.ErrorType:\n                    // Always assume that error types are accessible.\n                    return true;\n\n                case SymbolKind.TypeParameter:\n                case SymbolKind.Parameter:\n                case SymbolKind.Local:\n                case SymbolKind.Label:\n                case SymbolKind.Namespace:\n                case SymbolKind.DynamicType:\n                case SymbolKind.Assembly:\n                case SymbolKind.NetModule:\n                case SymbolKind.RangeVariable:\n                case SymbolKind.Method when ((MethodSymbol)symbol).MethodKind == MethodKind.LocalFunction:\n                    // These types of symbols are always accessible (if visible).\n                    return true;\n\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                    if (!symbol.RequiresInstanceReceiver())\n                    {\n                        // static members aren't accessed 'through' an 'instance' of any type.  So we\n                        // null out the 'through' instance here.  This ensures that we'll understand\n                        // accessing protected statics properly.\n                        throughTypeOpt = null;\n                    }\n\n                    return IsMemberAccessible(symbol.ContainingType, symbol.DeclaredAccessibility, within, throughTypeOpt, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 355386"];
6156 [label="return IsNamedTypeAccessible((NamedTypeSymbol)symbol, within, ref useSiteDiagnostics, basesBeingResolved); 355387"];
6157 [label="return IsNamedTypeAccessible((NamedTypeSymbol)symbol, within, ref useSiteDiagnostics, basesBeingResolved); 355388"];
6158 [label="return IsNamedTypeAccessible((NamedTypeSymbol)symbol, within, ref useSiteDiagnostics, basesBeingResolved); 355389"];
6159 [label="return IsNamedTypeAccessible((NamedTypeSymbol)symbol, within, ref useSiteDiagnostics, basesBeingResolved); 355390"];
6160 [label="IsNamedTypeAccessible((NamedTypeSymbol)symbol, within, ref useSiteDiagnostics, basesBeingResolved) 355391"];
6161 [label="param IsNamedTypeAccessible(NamedTypeSymbol type) 355392"];
6162 [label="param IsNamedTypeAccessible(Symbol within) 355393"];
6163 [label="param IsNamedTypeAccessible(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 355394"];
6164 [label="param IsNamedTypeAccessible(ConsList<TypeSymbol> basesBeingResolved = null) 355395"];
6165 [label="Debug.Assert(within is NamedTypeSymbol || within is AssemblySymbol); 355396"];
6166 [label="Debug.Assert((object)type != null); 355397"];
6167 [label="Debug.Assert((object)type != null); 355398"];
6168 [label="within.DeclaringCompilation 355399"];
6169 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 355400"];
6170 [label="this.Kind 355401"];
6171 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355402"];
6172 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 355403"];
6173 [label="var compilation = within.DeclaringCompilation; 355404"];
6174 [label="bool unused; 355405"];
6175 [label="type.IsDefinition 355406"];
6176 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 355407"];
6177 [label="OriginalDefinition 355408"];
6178 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 355409"];
6179 [label="OriginalSymbolDefinition 355410"];
6180 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 355411"];
6181 [label="this.OriginalTypeSymbolDefinition 355412"];
6182 [label="get\n            {\n                return this.OriginalDefinition;\n            } 355413"];
6183 [label="this.OriginalDefinition 355414"];
6184 [label="get\n            {\n                return this;\n            } 355415"];
6185 [label="return this.OriginalDefinition; 355416"];
6186 [label="return this.OriginalTypeSymbolDefinition; 355417"];
6187 [label="return OriginalSymbolDefinition; 355418"];
6188 [label="return (object)this == (object)OriginalDefinition; 355419"];
6189 [label="if (!type.IsDefinition)\n            {\n                // All type argument must be accessible.\n                var typeArgs = type.TypeArgumentsWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics);\n                foreach (var typeArg in typeArgs)\n                {\n                    // type parameters are always accessible, so don't check those (so common it's\n                    // worth optimizing this).\n                    if (typeArg.Type.Kind != SymbolKind.TypeParameter && !IsSymbolAccessibleCore(typeArg.Type, within, null, out unused, compilation, ref useSiteDiagnostics, basesBeingResolved))\n                    {\n                        return false;\n                    }\n                }\n            } 355420"];
6190 [label="type.ContainingType 355421"];
6191 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 355422"];
6192 [label="return _containingSymbol as NamedTypeSymbol; 355423"];
6193 [label="var containingType = type.ContainingType; 355424"];
6194 [label="return (object)containingType == null\n                ? IsNonNestedTypeAccessible(type.ContainingAssembly, type.DeclaredAccessibility, within)\n                : IsMemberAccessible(containingType, type.DeclaredAccessibility, within, null, out unused, compilation, ref useSiteDiagnostics, basesBeingResolved); 355425"];
6195 [label="return (object)containingType == null\n                ? IsNonNestedTypeAccessible(type.ContainingAssembly, type.DeclaredAccessibility, within)\n                : IsMemberAccessible(containingType, type.DeclaredAccessibility, within, null, out unused, compilation, ref useSiteDiagnostics, basesBeingResolved); 355426"];
6196 [label="(object)containingType == null 355427"];
6197 [label="type.ContainingAssembly 355428"];
6198 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 355429"];
6199 [label="this.ContainingSymbol 355430"];
6200 [label="get\n            {\n                return _containingSymbol;\n            } 355431"];
6201 [label="var container = this.ContainingSymbol; 355432"];
6202 [label="return (object)container != null ? container.ContainingAssembly : null; 355433"];
6203 [label="return (object)container != null ? container.ContainingAssembly : null; 355434"];
6204 [label="(object)container != null 355435"];
6205 [label="container.ContainingAssembly 355436"];
6206 [label="=> _module.ContainingAssembly 355437"];
6207 [label="_module.ContainingAssembly 355438"];
6208 [label="get\n            {\n                return _assemblySymbol;\n            } 355439"];
6209 [label="return _assemblySymbol; 355440"];
6210 [label="type.DeclaredAccessibility 355441"];
6211 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 355442"];
6212 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 355443"];
6213 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 355444"];
6214 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 355445"];
6215 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 355446"];
6216 [label="return Accessibility.Internal; 355447"];
6217 [label="return (object)containingType == null\n                ? IsNonNestedTypeAccessible(type.ContainingAssembly, type.DeclaredAccessibility, within)\n                : IsMemberAccessible(containingType, type.DeclaredAccessibility, within, null, out unused, compilation, ref useSiteDiagnostics, basesBeingResolved); 355448"];
6218 [label="IsNonNestedTypeAccessible(type.ContainingAssembly, type.DeclaredAccessibility, within) 355449"];
6219 [label="param IsNonNestedTypeAccessible(AssemblySymbol assembly) 355450"];
6220 [label="param IsNonNestedTypeAccessible(Accessibility declaredAccessibility) 355451"];
6221 [label="param IsNonNestedTypeAccessible(Symbol within) 355452"];
6222 [label="Debug.Assert(within is NamedTypeSymbol || within is AssemblySymbol); 355453"];
6223 [label="Debug.Assert((object)assembly != null); 355454"];
6224 [label="Debug.Assert((object)assembly != null); 355455"];
6225 [label="switch (declaredAccessibility)\n            {\n                case Accessibility.NotApplicable:\n                case Accessibility.Public:\n                    // Public symbols are always accessible from any context\n                    return true;\n\n                case Accessibility.Private:\n                case Accessibility.Protected:\n                case Accessibility.ProtectedAndInternal:\n                    // Shouldn't happen except in error cases.\n                    return false;\n\n                case Accessibility.Internal:\n                case Accessibility.ProtectedOrInternal:\n\n                    // within is typically a type\n                    var withinType = within as NamedTypeSymbol;\n                    var withinAssembly = (object)withinType != null ? withinType.ContainingAssembly : (AssemblySymbol)within;\n\n                    // An internal type is accessible if we're in the same assembly or we have\n                    // friend access to the assembly it was defined in.\n                    return (object)withinAssembly == (object)assembly || withinAssembly.HasInternalAccessTo(assembly);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(declaredAccessibility);\n            } 355456"];
6226 [label="var withinType = within as NamedTypeSymbol; 355457"];
6227 [label="var withinAssembly = (object)withinType != null ? withinType.ContainingAssembly : (AssemblySymbol)within; 355458"];
6228 [label="var withinAssembly = (object)withinType != null ? withinType.ContainingAssembly : (AssemblySymbol)within; 355459"];
6229 [label="(object)withinType != null 355460"];
6230 [label="withinType.ContainingAssembly 355461"];
6231 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 355462"];
6232 [label="this.ContainingSymbol 355463"];
6233 [label="get\n            {\n                return _containingSymbol;\n            } 355464"];
6234 [label="var container = this.ContainingSymbol; 355465"];
6235 [label="return (object)container != null ? container.ContainingAssembly : null; 355466"];
6236 [label="return (object)container != null ? container.ContainingAssembly : null; 355467"];
6237 [label="(object)container != null 355468"];
6238 [label="container.ContainingAssembly 355469"];
6239 [label="=> _module.ContainingAssembly 355470"];
6240 [label="_module.ContainingAssembly 355471"];
6241 [label="get\n            {\n                return _assemblySymbol;\n            } 355472"];
6242 [label="return _assemblySymbol; 355473"];
6243 [label="return (object)withinAssembly == (object)assembly || withinAssembly.HasInternalAccessTo(assembly); 355474"];
6244 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355475"];
6245 [label="InCref 355476"];
6246 [label="if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355477"];
6247 [label="if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355478"];
6248 [label="unwrappedSymbol.MustCallMethodsDirectly() 355479"];
6249 [label="param MustCallMethodsDirectly(this Symbol symbol) 355480"];
6250 [label="symbol.Kind 355481"];
6251 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355482"];
6252 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.Property:\n                    return ((PropertySymbol)symbol).MustCallMethodsDirectly;\n                case SymbolKind.Event:\n                    return ((EventSymbol)symbol).MustCallMethodsDirectly;\n                default:\n                    return false;\n            } 355483"];
6253 [label="return false; 355484"];
6254 [label="if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355485"];
6255 [label="if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355486"];
6256 [label="if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355487"];
6257 [label="if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355488"];
6258 [label="if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355489"];
6259 [label="if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355490"];
6260 [label="if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355491"];
6261 [label="if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355492"];
6262 [label="if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355493"];
6263 [label="if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 355494"];
6264 [label="return LookupResult.Good(symbol); 355495"];
6265 [label="LookupResult.Good(symbol) 355496"];
6266 [label="param Good(Symbol symbol) 355497"];
6267 [label="return new SingleLookupResult(LookupResultKind.Viable, symbol, null); 355498"];
6268 [label="return new SingleLookupResult(LookupResultKind.Viable, symbol, null); 355499"];
6269 [label="return new SingleLookupResult(LookupResultKind.Viable, symbol, null); 355500"];
6270 [label="new SingleLookupResult(LookupResultKind.Viable, symbol, null) 355501"];
6271 [label="param SingleLookupResult(LookupResultKind kind) 355502"];
6272 [label="param SingleLookupResult(Symbol symbol) 355503"];
6273 [label="param SingleLookupResult(DiagnosticInfo error) 355504"];
6274 [label="param SingleLookupResult(this) 355505"];
6275 [label="this.Kind 355506"];
6276 [label="this.Symbol 355507"];
6277 [label="this.Error 355508"];
6278 [label="return LookupResult.Good(symbol); 355509"];
6279 [label="result.MergeEqual(resultOfThisMember); 355510"];
6280 [label="result.MergeEqual(resultOfThisMember) 355511"];
6281 [label="param MergeEqual(SingleLookupResult result) 355512"];
6282 [label="param MergeEqual(this) 355513"];
6283 [label="Kind 355514"];
6284 [label="get\n            {\n                return _kind;\n            } 355515"];
6285 [label="if (Kind > result.Kind)\n            {\n                // existing result is better\n            }\n            else if (result.Kind > Kind)\n            {\n                this.SetFrom(result);\n            }\n            else if ((object)result.Symbol != null)\n            {\n                // Same goodness. Include all symbols\n                _symbolList.Add(result.Symbol);\n            } 355516"];
6286 [label="if (Kind > result.Kind)\n            {\n                // existing result is better\n            }\n            else if (result.Kind > Kind)\n            {\n                this.SetFrom(result);\n            }\n            else if ((object)result.Symbol != null)\n            {\n                // Same goodness. Include all symbols\n                _symbolList.Add(result.Symbol);\n            } 355517"];
6287 [label="Kind 355518"];
6288 [label="if (result.Kind > Kind)\n            {\n                this.SetFrom(result);\n            }\n            else if ((object)result.Symbol != null)\n            {\n                // Same goodness. Include all symbols\n                _symbolList.Add(result.Symbol);\n            } 355519"];
6289 [label="this.SetFrom(result); 355520"];
6290 [label="this.SetFrom(result) 355521"];
6291 [label="param SetFrom(SingleLookupResult other) 355522"];
6292 [label="param SetFrom(this) 355523"];
6293 [label="_kind 355524"];
6294 [label="_symbolList.Clear(); 355525"];
6295 [label="_symbolList.Add(other.Symbol); 355526"];
6296 [label="_symbolList.Add(other.Symbol); 355527"];
6297 [label="_error 355528"];
6298 [label="this.SetFrom(result); 355529"];
6299 [label="result.MergeEqual(resultOfThisMember); 355530"];
6300 [label="foreach (Symbol member in members)\n            {\n                SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics);\n                result.MergeEqual(resultOfThisMember);\n            } 355531"];
6301 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 355532"];
6302 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 355533"];
6303 [label="result.IsMultiViable 355534"];
6304 [label="get\n            {\n                return Kind == LookupResultKind.Viable;\n            } 355535"];
6305 [label="return _kind; 355536"];
6306 [label="if (result.IsMultiViable)\n                {\n                    // symbols cannot conflict with using alias names\n                    if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    }\n\n                    return;\n                } 355537"];
6307 [label="if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    } 355538"];
6308 [label="if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    } 355539"];
6309 [label="if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    } 355540"];
6310 [label="originalBinder.IsSemanticModelBinder 355541"];
6311 [label="get\n            {\n                return this.Flags.Includes(BinderFlags.SemanticModel);\n            } 355542"];
6312 [label="return this.Flags.Includes(BinderFlags.SemanticModel); 355543"];
6313 [label="return this.Flags.Includes(BinderFlags.SemanticModel); 355544"];
6314 [label="this.Flags.Includes(BinderFlags.SemanticModel) 355545"];
6315 [label="param Includes(this BinderFlags self) 355546"];
6316 [label="param Includes(BinderFlags other) 355547"];
6317 [label="if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    } 355548"];
6318 [label="imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder) 355549"];
6319 [label="param IsUsingAlias(string name) 355550"];
6320 [label="param IsUsingAlias(bool callerIsSemanticModel) 355551"];
6321 [label="param IsUsingAlias(this) 355552"];
6322 [label="AliasAndUsingDirective node; 355553"];
6323 [label="node 355554"];
6324 [label="if (this.UsingAliases.TryGetValue(name, out node))\n            {\n                // This method is called by InContainerBinder.LookupSymbolsInSingleBinder to see if\n                // there's a conflict between an alias and a member.  As a conflict may cause a\n                // speculative lambda binding to fail this is semantically relevant and we need to\n                // mark this using alias as referenced (and thus not something that can be removed).\n                MarkImportDirective(node.UsingDirective, callerIsSemanticModel);\n                return true;\n            } 355555"];
6325 [label="if (this.UsingAliases.TryGetValue(name, out node))\n            {\n                // This method is called by InContainerBinder.LookupSymbolsInSingleBinder to see if\n                // there's a conflict between an alias and a member.  As a conflict may cause a\n                // speculative lambda binding to fail this is semantically relevant and we need to\n                // mark this using alias as referenced (and thus not something that can be removed).\n                MarkImportDirective(node.UsingDirective, callerIsSemanticModel);\n                return true;\n            } 355556"];
6326 [label="if (this.UsingAliases.TryGetValue(name, out node))\n            {\n                // This method is called by InContainerBinder.LookupSymbolsInSingleBinder to see if\n                // there's a conflict between an alias and a member.  As a conflict may cause a\n                // speculative lambda binding to fail this is semantically relevant and we need to\n                // mark this using alias as referenced (and thus not something that can be removed).\n                MarkImportDirective(node.UsingDirective, callerIsSemanticModel);\n                return true;\n            } 355557"];
6327 [label="return false; 355558"];
6328 [label="if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    } 355559"];
6329 [label="if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    } 355560"];
6330 [label="return; 355561"];
6331 [label="result.IsClear 355562"];
6332 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 355563"];
6333 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 355564"];
6334 [label="if (!result.IsClear)\n                    {\n                        binder = scope;\n                    } 355565"];
6335 [label="binder = scope; 355566"];
6336 [label="if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                } 355567"];
6337 [label="if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                } 355568"];
6338 [label="return binder; 355569"];
6339 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 355570"];
6340 [label="diagnostics.Add(node, useSiteDiagnostics); 355571"];
6341 [label="diagnostics.Add(node, useSiteDiagnostics); 355572"];
6342 [label="diagnostics.Add(node, useSiteDiagnostics); 355573"];
6343 [label="diagnostics.Add(node, useSiteDiagnostics); 355574"];
6344 [label="Symbol bindingResult = null; 355575"];
6345 [label="if ((object)qualifierOpt == null &&\n                !IsViableType(result))\n            {\n                if (node.Identifier.ValueText == 'dynamic')\n                {\n                    if ((node.Parent == null ||\n                          node.Parent.Kind() != SyntaxKind.Attribute && // dynamic not allowed as attribute type\n                          SyntaxFacts.IsInTypeOnlyContext(node)) &&\n                        Compilation.LanguageVersion >= MessageID.IDS_FeatureDynamic.RequiredVersion())\n                    {\n                        bindingResult = Compilation.DynamicType;\n                        ReportUseSiteDiagnosticForDynamic(diagnostics, node);\n                    }\n                }\n                else\n                {\n                    bindingResult = BindNativeIntegerSymbolIfAny(node, diagnostics);\n                }\n            } 355576"];
6346 [label="if ((object)qualifierOpt == null &&\n                !IsViableType(result))\n            {\n                if (node.Identifier.ValueText == 'dynamic')\n                {\n                    if ((node.Parent == null ||\n                          node.Parent.Kind() != SyntaxKind.Attribute && // dynamic not allowed as attribute type\n                          SyntaxFacts.IsInTypeOnlyContext(node)) &&\n                        Compilation.LanguageVersion >= MessageID.IDS_FeatureDynamic.RequiredVersion())\n                    {\n                        bindingResult = Compilation.DynamicType;\n                        ReportUseSiteDiagnosticForDynamic(diagnostics, node);\n                    }\n                }\n                else\n                {\n                    bindingResult = BindNativeIntegerSymbolIfAny(node, diagnostics);\n                }\n            } 355577"];
6347 [label="if ((object)qualifierOpt == null &&\n                !IsViableType(result))\n            {\n                if (node.Identifier.ValueText == 'dynamic')\n                {\n                    if ((node.Parent == null ||\n                          node.Parent.Kind() != SyntaxKind.Attribute && // dynamic not allowed as attribute type\n                          SyntaxFacts.IsInTypeOnlyContext(node)) &&\n                        Compilation.LanguageVersion >= MessageID.IDS_FeatureDynamic.RequiredVersion())\n                    {\n                        bindingResult = Compilation.DynamicType;\n                        ReportUseSiteDiagnosticForDynamic(diagnostics, node);\n                    }\n                }\n                else\n                {\n                    bindingResult = BindNativeIntegerSymbolIfAny(node, diagnostics);\n                }\n            } 355578"];
6348 [label="IsViableType(result) 355579"];
6349 [label="param IsViableType(LookupResult result) 355580"];
6350 [label="result.IsMultiViable 355581"];
6351 [label="get\n            {\n                return Kind == LookupResultKind.Viable;\n            } 355582"];
6352 [label="Kind 355583"];
6353 [label="get\n            {\n                return _kind;\n            } 355584"];
6354 [label="return _kind; 355585"];
6355 [label="if (!result.IsMultiViable)\n            {\n                return false;\n            } 355586"];
6356 [label="result.Symbols 355587"];
6357 [label="get\n            {\n                return _symbolList;\n            } 355588"];
6358 [label="return _symbolList; 355589"];
6359 [label="foreach (var s in result.Symbols)\n            {\n                switch (s.Kind)\n                {\n                    case SymbolKind.Alias:\n                        if (((AliasSymbol)s).Target.Kind == SymbolKind.NamedType) return true;\n                        break;\n                    case SymbolKind.NamedType:\n                    case SymbolKind.TypeParameter:\n                        return true;\n                }\n            } 355590"];
6360 [label="s.Kind 355591"];
6361 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355592"];
6362 [label="switch (s.Kind)\n                {\n                    case SymbolKind.Alias:\n                        if (((AliasSymbol)s).Target.Kind == SymbolKind.NamedType) return true;\n                        break;\n                    case SymbolKind.NamedType:\n                    case SymbolKind.TypeParameter:\n                        return true;\n                } 355593"];
6363 [label="return true; 355594"];
6364 [label="if (bindingResult is null)\n            {\n                bool wasError;\n\n                bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options);\n                if (bindingResult.Kind == SymbolKind.Alias)\n                {\n                    var aliasTarget = ((AliasSymbol)bindingResult).GetAliasTarget(basesBeingResolved);\n                    if (aliasTarget.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)aliasTarget).ContainsDynamic())\n                    {\n                        ReportUseSiteDiagnosticForDynamic(diagnostics, node);\n                    }\n                }\n            } 355595"];
6365 [label="bool wasError; 355596"];
6366 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355597"];
6367 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355598"];
6368 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355599"];
6369 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355600"];
6370 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355601"];
6371 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355602"];
6372 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355603"];
6373 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355604"];
6374 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355605"];
6375 [label="ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options) 355606"];
6376 [label="param ResultSymbol(LookupResult result) 355607"];
6377 [label="param ResultSymbol(string simpleName) 355608"];
6378 [label="param ResultSymbol(int arity) 355609"];
6379 [label="param ResultSymbol(SyntaxNode where) 355610"];
6380 [label="param ResultSymbol(DiagnosticBag diagnostics) 355611"];
6381 [label="param ResultSymbol(bool suppressUseSiteDiagnostics) 355612"];
6382 [label="param ResultSymbol(out bool wasError) 355613"];
6383 [label="param ResultSymbol(NamespaceOrTypeSymbol qualifierOpt = null) 355614"];
6384 [label="param ResultSymbol(LookupOptions options = default(LookupOptions)) 355615"];
6385 [label="param ResultSymbol(this) 355616"];
6386 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355617"];
6387 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355618"];
6388 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355619"];
6389 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355620"];
6390 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355621"];
6391 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355622"];
6392 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355623"];
6393 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355624"];
6394 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 355625"];
6395 [label="resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options) 355626"];
6396 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 355627"];
6397 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 355628"];
6398 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 355629"];
6399 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 355630"];
6400 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 355631"];
6401 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 355632"];
6402 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 355633"];
6403 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 355634"];
6404 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 355635"];
6405 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 355636"];
6406 [label="Debug.Assert(where != null); 355637"];
6407 [label="Debug.Assert(where != null); 355638"];
6408 [label="Debug.Assert(diagnostics != null); 355639"];
6409 [label="Debug.Assert(diagnostics != null); 355640"];
6410 [label="result.Symbols 355641"];
6411 [label="get\n            {\n                return _symbolList;\n            } 355642"];
6412 [label="return _symbolList; 355643"];
6413 [label="var symbols = result.Symbols; 355644"];
6414 [label="wasError = false; 355645"];
6415 [label="result.IsMultiViable 355646"];
6416 [label="get\n            {\n                return Kind == LookupResultKind.Viable;\n            } 355647"];
6417 [label="Kind 355648"];
6418 [label="get\n            {\n                return _kind;\n            } 355649"];
6419 [label="return _kind; 355650"];
6420 [label="if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                } 355651"];
6421 [label="if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    } 355652"];
6422 [label="if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    } 355653"];
6423 [label="var singleResult = symbols[0]; 355654"];
6424 [label="var singleType = singleResult as TypeSymbol; 355655"];
6425 [label="if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        } 355656"];
6426 [label="if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        } 355657"];
6427 [label="singleType.PrimitiveTypeCode 355658"];
6428 [label="=> TypeKind switch\n            {\n                TypeKind.Pointer => Microsoft.Cci.PrimitiveTypeCode.Pointer,\n                TypeKind.FunctionPointer => Microsoft.Cci.PrimitiveTypeCode.FunctionPointer,\n                _ => SpecialTypes.GetTypeCode(SpecialType)\n            } 355659"];
6429 [label="TypeKind 355660"];
6430 [label="get\n            {\n                return _flags.TypeKind;\n            } 355661"];
6431 [label="TypeKind switch\n            {\n                TypeKind.Pointer => Microsoft.Cci.PrimitiveTypeCode.Pointer,\n                TypeKind.FunctionPointer => Microsoft.Cci.PrimitiveTypeCode.FunctionPointer,\n                _ => SpecialTypes.GetTypeCode(SpecialType)\n            } 355662"];
6432 [label="SpecialType 355663"];
6433 [label="get\n            {\n                return _flags.SpecialType;\n            } 355664"];
6434 [label="_flags.SpecialType 355665"];
6435 [label="get { return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); } 355666"];
6436 [label="return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); 355667"];
6437 [label="return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); 355668"];
6438 [label="return _flags.SpecialType; 355669"];
6439 [label="SpecialTypes.GetTypeCode(SpecialType) 355670"];
6440 [label="if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        } 355671"];
6441 [label="singleResult.Kind 355672"];
6442 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355673"];
6443 [label="if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            } 355674"];
6444 [label="this.Compilation.SourceModule 355675"];
6445 [label="get\n            {\n                return Assembly.Modules[0];\n            } 355676"];
6446 [label="GetBoundReferenceManager(); 355677"];
6447 [label="if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            } 355678"];
6448 [label="((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked 355679"];
6449 [label="get\n            {\n                return GetAssembliesToEmbedTypesFrom().Length > 0;\n            } 355680"];
6450 [label="GetAssembliesToEmbedTypesFrom() 355681"];
6451 [label="param GetAssembliesToEmbedTypesFrom(this) 355682"];
6452 [label="if (_lazyAssembliesToEmbedTypesFrom.IsDefault)\n            {\n                AssertReferencesInitialized();\n                var buffer = ArrayBuilder<AssemblySymbol>.GetInstance();\n\n                foreach (AssemblySymbol asm in this.GetReferencedAssemblySymbols())\n                {\n                    if (asm.IsLinked)\n                    {\n                        buffer.Add(asm);\n                    }\n                }\n\n                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>));\n            } 355683"];
6453 [label="AssertReferencesInitialized() 355684"];
6454 [label="param AssertReferencesInitialized(this) 355685"];
6455 [label="Debug.Assert(_moduleReferences != null); 355686"];
6456 [label="Debug.Assert(_moduleReferences != null); 355687"];
6457 [label="AssertReferencesInitialized(); 355688"];
6458 [label="var buffer = ArrayBuilder<AssemblySymbol>.GetInstance(); 355689"];
6459 [label="this.GetReferencedAssemblySymbols() 355690"];
6460 [label="AssertReferencesInitialized() 355691"];
6461 [label="param AssertReferencesInitialized(this) 355692"];
6462 [label="Debug.Assert(_moduleReferences != null); 355693"];
6463 [label="Debug.Assert(_moduleReferences != null); 355694"];
6464 [label="AssertReferencesInitialized(); 355695"];
6465 [label="foreach (AssemblySymbol asm in this.GetReferencedAssemblySymbols())\n                {\n                    if (asm.IsLinked)\n                    {\n                        buffer.Add(asm);\n                    }\n                } 355696"];
6466 [label="asm.IsLinked 355697"];
6467 [label="get\n            {\n                return _isLinked;\n            } 355698"];
6468 [label="return _isLinked; 355699"];
6469 [label="if (asm.IsLinked)\n                    {\n                        buffer.Add(asm);\n                    } 355700"];
6470 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>)); 355701"];
6471 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>)); 355702"];
6472 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>)); 355703"];
6473 [label="Debug.Assert(!_lazyAssembliesToEmbedTypesFrom.IsDefault); 355704"];
6474 [label="return _lazyAssembliesToEmbedTypesFrom; 355705"];
6475 [label="return GetAssembliesToEmbedTypesFrom().Length > 0; 355706"];
6476 [label="return GetAssembliesToEmbedTypesFrom().Length > 0; 355707"];
6477 [label="if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            } 355708"];
6478 [label="if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            } 355709"];
6479 [label="singleResult.Kind 355710"];
6480 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355711"];
6481 [label="if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            } 355712"];
6482 [label="return singleResult; 355713"];
6483 [label="symbol.Kind 355714"];
6484 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355715"];
6485 [label="if (symbol.Kind == SymbolKind.NamedType)\n            {\n                CheckRuntimeSupportForSymbolAccess(where, receiverOpt: null, symbol, diagnostics);\n            } 355716"];
6486 [label="CheckRuntimeSupportForSymbolAccess(where, receiverOpt: null, symbol, diagnostics); 355717"];
6487 [label="CheckRuntimeSupportForSymbolAccess(where, receiverOpt: null, symbol, diagnostics); 355718"];
6488 [label="CheckRuntimeSupportForSymbolAccess(where, receiverOpt: null, symbol, diagnostics); 355719"];
6489 [label="CheckRuntimeSupportForSymbolAccess(where, receiverOpt: null, symbol, diagnostics); 355720"];
6490 [label="CheckRuntimeSupportForSymbolAccess(where, receiverOpt: null, symbol, diagnostics) 355721"];
6491 [label="param CheckRuntimeSupportForSymbolAccess(SyntaxNode node) 355722"];
6492 [label="param CheckRuntimeSupportForSymbolAccess(BoundExpression receiverOpt) 355723"];
6493 [label="param CheckRuntimeSupportForSymbolAccess(Symbol symbol) 355724"];
6494 [label="param CheckRuntimeSupportForSymbolAccess(DiagnosticBag diagnostics) 355725"];
6495 [label="param CheckRuntimeSupportForSymbolAccess(this) 355726"];
6496 [label="symbol.ContainingType 355727"];
6497 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 355728"];
6498 [label="return _containingSymbol as NamedTypeSymbol; 355729"];
6499 [label="if (symbol.ContainingType?.IsInterface == true && !Compilation.Assembly.RuntimeSupportsDefaultInterfaceImplementation && Compilation.SourceModule != symbol.ContainingModule)\n            {\n                if (!symbol.IsStatic && !(symbol is TypeSymbol) &&\n                    !symbol.IsImplementableInterfaceMember())\n                {\n                    Error(diagnostics, ErrorCode.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation, node);\n                }\n                else\n                {\n                    switch (symbol.DeclaredAccessibility)\n                    {\n                        case Accessibility.Protected:\n                        case Accessibility.ProtectedOrInternal:\n                        case Accessibility.ProtectedAndInternal:\n\n                            Error(diagnostics, ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember, node);\n                            break;\n                    }\n                }\n            } 355730"];
6500 [label="if (symbol.ContainingType?.IsInterface == true && !Compilation.Assembly.RuntimeSupportsDefaultInterfaceImplementation && Compilation.SourceModule != symbol.ContainingModule)\n            {\n                if (!symbol.IsStatic && !(symbol is TypeSymbol) &&\n                    !symbol.IsImplementableInterfaceMember())\n                {\n                    Error(diagnostics, ErrorCode.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation, node);\n                }\n                else\n                {\n                    switch (symbol.DeclaredAccessibility)\n                    {\n                        case Accessibility.Protected:\n                        case Accessibility.ProtectedOrInternal:\n                        case Accessibility.ProtectedAndInternal:\n\n                            Error(diagnostics, ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember, node);\n                            break;\n                    }\n                }\n            } 355731"];
6501 [label="return symbol; 355732"];
6502 [label="bindingResult.Kind 355733"];
6503 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355734"];
6504 [label="if (bindingResult.Kind == SymbolKind.Alias)\n                {\n                    var aliasTarget = ((AliasSymbol)bindingResult).GetAliasTarget(basesBeingResolved);\n                    if (aliasTarget.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)aliasTarget).ContainsDynamic())\n                    {\n                        ReportUseSiteDiagnosticForDynamic(diagnostics, node);\n                    }\n                } 355735"];
6505 [label="result.Free() 355736"];
6506 [label="param Free(this) 355737"];
6507 [label="this.Clear() 355738"];
6508 [label="param Clear(this) 355739"];
6509 [label="_kind 355740"];
6510 [label="_symbolList.Clear(); 355741"];
6511 [label="_error = null; 355742"];
6512 [label="_error 355743"];
6513 [label="this.Clear(); 355744"];
6514 [label="if (_pool != null)\n            {\n                _pool.Free(this);\n            } 355745"];
6515 [label="if (_pool != null)\n            {\n                _pool.Free(this);\n            } 355746"];
6516 [label="_pool.Free(this); 355747"];
6517 [label="_pool.Free(this); 355748"];
6518 [label="result.Free(); 355749"];
6519 [label="return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(AreNullableAnnotationsEnabled(node.Identifier), bindingResult); 355750"];
6520 [label="AreNullableAnnotationsEnabled(node.Identifier) 355751"];
6521 [label="param AreNullableAnnotationsEnabled(SyntaxToken token) 355752"];
6522 [label="param AreNullableAnnotationsEnabled(this) 355753"];
6523 [label="RoslynDebug.Assert(token.SyntaxTree is object); 355754"];
6524 [label="return AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart); 355755"];
6525 [label="AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart) 355756"];
6526 [label="param AreNullableAnnotationsEnabled(SyntaxTree syntaxTree) 355757"];
6527 [label="param AreNullableAnnotationsEnabled(int position) 355758"];
6528 [label="param AreNullableAnnotationsEnabled(this) 355759"];
6529 [label="CSharpSyntaxTree csTree = (CSharpSyntaxTree)syntaxTree; 355760"];
6530 [label="Syntax.NullableContextState context = csTree.GetNullableContextState(position); 355761"];
6531 [label="Syntax.NullableContextState context = csTree.GetNullableContextState(position); 355762"];
6532 [label="context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            } 355763"];
6533 [label="this.Compilation.Options 355764"];
6534 [label="get\n            {\n                return _options;\n            } 355765"];
6535 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 355766"];
6536 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 355767"];
6537 [label="AreNullableAnnotationsGloballyEnabled() 355768"];
6538 [label="param AreNullableAnnotationsGloballyEnabled(this) 355769"];
6539 [label="RoslynDebug.Assert(Next is object); 355770"];
6540 [label="RoslynDebug.Assert(Next is object); 355771"];
6541 [label="Next.AreNullableAnnotationsGloballyEnabled() 355772"];
6542 [label="param AreNullableAnnotationsGloballyEnabled(this) 355773"];
6543 [label="RoslynDebug.Assert(Next is object); 355774"];
6544 [label="param AreNullableAnnotationsGloballyEnabled(this) 355775"];
6545 [label="GetGlobalAnnotationState() 355776"];
6546 [label="param GetGlobalAnnotationState(this) 355777"];
6547 [label="Compilation.Options 355778"];
6548 [label="get\n            {\n                return _options;\n            } 355779"];
6549 [label="switch (Compilation.Options.NullableContextOptions)\n            {\n                case NullableContextOptions.Enable:\n                case NullableContextOptions.Annotations:\n                    return true;\n\n                case NullableContextOptions.Disable:\n                case NullableContextOptions.Warnings:\n                    return false;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(Compilation.Options.NullableContextOptions);\n            } 355780"];
6550 [label="return false; 355781"];
6551 [label="return GetGlobalAnnotationState(); 355782"];
6552 [label="return Next.AreNullableAnnotationsGloballyEnabled(); 355783"];
6553 [label="return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(AreNullableAnnotationsEnabled(node.Identifier), bindingResult); 355784"];
6554 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(AreNullableAnnotationsEnabled(node.Identifier), bindingResult) 355785"];
6555 [label="param CreateUnannotated(bool isNullableEnabled) 355786"];
6556 [label="param CreateUnannotated(Symbol symbol) 355787"];
6557 [label="if (symbol is null)\n                {\n                    return default;\n                } 355788"];
6558 [label="var type = symbol as TypeSymbol; 355789"];
6559 [label="return type is null ?\n                    new NamespaceOrTypeOrAliasSymbolWithAnnotations(symbol, isNullableEnabled) :\n                    new NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations.Create(isNullableEnabled, type)); 355790"];
6560 [label="type is null 355791"];
6561 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 355792"];
6562 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 355793"];
6563 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 355794"];
6564 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 355795"];
6565 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 355796"];
6566 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 355797"];
6567 [label="DebuggerDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 355798"];
6568 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 355799"];
6569 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 355800"];
6570 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 355801"];
6571 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 355802"];
6572 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 355803"];
6573 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 355804"];
6574 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 355805"];
6575 [label="TestDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 355806"];
6576 [label="return type is null ?\n                    new NamespaceOrTypeOrAliasSymbolWithAnnotations(symbol, isNullableEnabled) :\n                    new NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations.Create(isNullableEnabled, type)); 355807"];
6577 [label="TypeWithAnnotations.Create(isNullableEnabled, type) 355808"];
6578 [label="param Create(bool isNullableEnabled) 355809"];
6579 [label="param Create(TypeSymbol typeSymbol) 355810"];
6580 [label="param Create(bool isAnnotated = false) 355811"];
6581 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 355812"];
6582 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 355813"];
6583 [label="isAnnotated 355814"];
6584 [label="isNullableEnabled 355815"];
6585 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 355816"];
6586 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 355817"];
6587 [label="Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious) 355818"];
6588 [label="param Create(TypeSymbol typeSymbol) 355819"];
6589 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 355820"];
6590 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 355821"];
6591 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 355822"];
6592 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 355823"];
6593 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 355824"];
6594 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 355825"];
6595 [label="'Expressions' 355826"];
6596 [label="'Linq' 355827"];
6597 [label="'' 355828"];
6598 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 355829"];
6599 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 355830"];
6600 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 355831"];
6601 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 355832"];
6602 [label="s_expressionsNamespaceName = { 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 355833"];
6603 [label="(type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 355834"];
6604 [label="s_containsTypeParameterPredicate =\n            (type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 355835"];
6605 [label="(type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 355836"];
6606 [label="s_isTypeParameterWithSpecificContainerPredicate =\n             (type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 355837"];
6607 [label="(type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 355838"];
6608 [label="s_containsTypeParametersPredicate =\n            (type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 355839"];
6609 [label="(type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 355840"];
6610 [label="s_containsDynamicPredicate = (type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 355841"];
6611 [label="typeSymbol.IsNullableType() 355842"];
6612 [label="param IsNullableType(this TypeSymbol type) 355843"];
6613 [label="type.OriginalDefinition 355844"];
6614 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 355845"];
6615 [label="OriginalTypeSymbolDefinition 355846"];
6616 [label="get\n            {\n                return this.OriginalDefinition;\n            } 355847"];
6617 [label="this.OriginalDefinition 355848"];
6618 [label="get\n            {\n                return this;\n            } 355849"];
6619 [label="return this.OriginalDefinition; 355850"];
6620 [label="return OriginalTypeSymbolDefinition; 355851"];
6621 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 355852"];
6622 [label="type.OriginalDefinition.SpecialType 355853"];
6623 [label="get\n            {\n                return _flags.SpecialType;\n            } 355854"];
6624 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 355855"];
6625 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 355856"];
6626 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 355857"];
6627 [label="CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()) 355858"];
6628 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 355859"];
6629 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 355860"];
6630 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 355861"];
6631 [label="customModifiers: ImmutableArray<CustomModifier>.Empty 355862"];
6632 [label="new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 355863"];
6633 [label="param NonLazyType(ImmutableArray<CustomModifier> customModifiers) 355864"];
6634 [label="param NonLazyType(this) 355865"];
6635 [label="param Extensions(this) 355866"];
6636 [label="Debug.Assert(!customModifiers.IsDefault); 355867"];
6637 [label="_customModifiers 355868"];
6638 [label="Default = new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 355869"];
6639 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 355870"];
6640 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 355871"];
6641 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 355872"];
6642 [label="Extensions.Create(customModifiers) 355873"];
6643 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 355874"];
6644 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 355875"];
6645 [label="return Default; 355876"];
6646 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 355877"];
6647 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 355878"];
6648 [label="param TypeWithAnnotations(TypeSymbol defaultType) 355879"];
6649 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 355880"];
6650 [label="param TypeWithAnnotations(Extensions extensions) 355881"];
6651 [label="param TypeWithAnnotations(this) 355882"];
6652 [label="var a1 = defaultType is null; 355883"];
6653 [label="!a1 355884"];
6654 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 355885"];
6655 [label="defaultType.IsNullableType() 355886"];
6656 [label="param IsNullableType(this TypeSymbol type) 355887"];
6657 [label="type.OriginalDefinition 355888"];
6658 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 355889"];
6659 [label="OriginalTypeSymbolDefinition 355890"];
6660 [label="get\n            {\n                return this.OriginalDefinition;\n            } 355891"];
6661 [label="this.OriginalDefinition 355892"];
6662 [label="get\n            {\n                return this;\n            } 355893"];
6663 [label="return this.OriginalDefinition; 355894"];
6664 [label="return OriginalTypeSymbolDefinition; 355895"];
6665 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 355896"];
6666 [label="type.OriginalDefinition.SpecialType 355897"];
6667 [label="get\n            {\n                return _flags.SpecialType;\n            } 355898"];
6668 [label="_flags.SpecialType 355899"];
6669 [label="get { return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); } 355900"];
6670 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 355901"];
6671 [label="Debug.Assert(a1 || a2 != true || a3); 355902"];
6672 [label="Debug.Assert(a1 || a2 != true || a3); 355903"];
6673 [label="Debug.Assert(extensions != null); 355904"];
6674 [label="Debug.Assert(extensions != null); 355905"];
6675 [label="DefaultType 355906"];
6676 [label="NullableAnnotation 355907"];
6677 [label="_extensions 355908"];
6678 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 355909"];
6679 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 355910"];
6680 [label="new NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations.Create(isNullableEnabled, type)) 355911"];
6681 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations typeWithAnnotations) 355912"];
6682 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(this) 355913"];
6683 [label="typeWithAnnotations.HasType 355914"];
6684 [label="=> !(DefaultType is null) 355915"];
6685 [label="DefaultType is null 355916"];
6686 [label="!(DefaultType is null) 355917"];
6687 [label="Debug.Assert(typeWithAnnotations.HasType); 355918"];
6688 [label="_typeWithAnnotations 355919"];
6689 [label="_symbol = null; 355920"];
6690 [label="_symbol 355921"];
6691 [label="_isNullableEnabled = false; 355922"];
6692 [label="_isNullableEnabled 355923"];
6693 [label="symbol.IsType 355924"];
6694 [label="=> !_typeWithAnnotations.IsDefault 355925"];
6695 [label="_typeWithAnnotations.IsDefault 355926"];
6696 [label="=> DefaultType is null && this.NullableAnnotation == 0 && (_extensions == null || _extensions == Extensions.Default) 355927"];
6697 [label="DefaultType is null 355928"];
6698 [label="DefaultType is null && this.NullableAnnotation == 0 355929"];
6699 [label="DefaultType is null && this.NullableAnnotation == 0 && (_extensions == null || _extensions == Extensions.Default) 355930"];
6700 [label="!_typeWithAnnotations.IsDefault 355931"];
6701 [label="if (symbol.IsType ||\n                (symbol.IsAlias && UnwrapAliasNoDiagnostics(symbol.Symbol, basesBeingResolved) is TypeSymbol))\n            {\n                if (symbol.IsType)\n                {\n                    // Obsolete alias targets are reported in UnwrapAlias, but if it was a type (not an\n                    // alias to a type) we report the obsolete type here.\n                    symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics);\n                }\n\n                return symbol;\n            } 355932"];
6702 [label="symbol.IsType 355933"];
6703 [label="if (symbol.IsType)\n                {\n                    // Obsolete alias targets are reported in UnwrapAlias, but if it was a type (not an\n                    // alias to a type) we report the obsolete type here.\n                    symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics);\n                } 355934"];
6704 [label="symbol.TypeWithAnnotations 355935"];
6705 [label="=> _typeWithAnnotations 355936"];
6706 [label="_typeWithAnnotations 355937"];
6707 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 355938"];
6708 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 355939"];
6709 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 355940"];
6710 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 355941"];
6711 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics) 355942"];
6712 [label="param ReportDiagnosticsIfObsolete(Binder binder) 355943"];
6713 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 355944"];
6714 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 355945"];
6715 [label="=>\n            _extensions.ReportDiagnosticsIfObsolete(this, binder, syntax, diagnostics) 355946"];
6716 [label="this 355947"];
6717 [label="binder 355948"];
6718 [label="syntax 355949"];
6719 [label="diagnostics 355950"];
6720 [label="_extensions.ReportDiagnosticsIfObsolete(this, binder, syntax, diagnostics) 355951"];
6721 [label="param ReportDiagnosticsIfObsolete(TypeWithAnnotations type) 355952"];
6722 [label="param ReportDiagnosticsIfObsolete(Binder binder) 355953"];
6723 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 355954"];
6724 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 355955"];
6725 [label="param ReportDiagnosticsIfObsolete(this) 355956"];
6726 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 355957"];
6727 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 355958"];
6728 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 355959"];
6729 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics) 355960"];
6730 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 355961"];
6731 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 355962"];
6732 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 355963"];
6733 [label="param ReportDiagnosticsIfObsoleteCore(this) 355964"];
6734 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 355965"];
6735 [label="Type 355966"];
6736 [label="=> _extensions?.GetResolvedType(DefaultType) 355967"];
6737 [label="DefaultType 355968"];
6738 [label=".GetResolvedType(DefaultType) 355969"];
6739 [label="param GetResolvedType(TypeSymbol defaultType) 355970"];
6740 [label="=> defaultType 355971"];
6741 [label="defaultType 355972"];
6742 [label="_extensions?.GetResolvedType(DefaultType) 355973"];
6743 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 355974"];
6744 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 355975"];
6745 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 355976"];
6746 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false) 355977"];
6747 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 355978"];
6748 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 355979"];
6749 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 355980"];
6750 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 355981"];
6751 [label="param ReportDiagnosticsIfObsolete(this) 355982"];
6752 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 355983"];
6753 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 355984"];
6754 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 355985"];
6755 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 355986"];
6756 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver) 355987"];
6757 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 355988"];
6758 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 355989"];
6759 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 355990"];
6760 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 355991"];
6761 [label="param ReportDiagnosticsIfObsolete(this) 355992"];
6762 [label="symbol.Kind 355993"];
6763 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 355994"];
6764 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Event:\n                case SymbolKind.Property:\n                    ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags);\n                    break;\n            } 355995"];
6765 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 355996"];
6766 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 355997"];
6767 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 355998"];
6768 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 355999"];
6769 [label="this.ContainingMemberOrLambda 356000"];
6770 [label="get { return _containingMemberOrLambda; } 356001"];
6771 [label="return _containingMemberOrLambda; 356002"];
6772 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 356003"];
6773 [label="this.ContainingType 356004"];
6774 [label="get\n            {\n                var member = this.ContainingMemberOrLambda;\n                RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType);\n                return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                };\n            } 356005"];
6775 [label="this.ContainingMemberOrLambda 356006"];
6776 [label="get { return _containingMemberOrLambda; } 356007"];
6777 [label="return _containingMemberOrLambda; 356008"];
6778 [label="var member = this.ContainingMemberOrLambda; 356009"];
6779 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 356010"];
6780 [label="member.Kind 356011"];
6781 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 356012"];
6782 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 356013"];
6783 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 356014"];
6784 [label="member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                } 356015"];
6785 [label="return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                }; 356016"];
6786 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 356017"];
6787 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 356018"];
6788 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags) 356019"];
6789 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 356020"];
6790 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 356021"];
6791 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 356022"];
6792 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 356023"];
6793 [label="param ReportDiagnosticsIfObsolete(Symbol? containingMember) 356024"];
6794 [label="param ReportDiagnosticsIfObsolete(NamedTypeSymbol? containingType) 356025"];
6795 [label="param ReportDiagnosticsIfObsolete(BinderFlags location) 356026"];
6796 [label="RoslynDebug.Assert(symbol is object); 356027"];
6797 [label="RoslynDebug.Assert(symbol is object); 356028"];
6798 [label="symbol.Kind 356029"];
6799 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 356030"];
6800 [label="RoslynDebug.Assert(symbol.Kind == SymbolKind.NamedType ||\n                         symbol.Kind == SymbolKind.Field ||\n                         symbol.Kind == SymbolKind.Method ||\n                         symbol.Kind == SymbolKind.Event ||\n                         symbol.Kind == SymbolKind.Property); 356031"];
6801 [label="symbol.Kind 356032"];
6802 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 356033"];
6803 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                symbol = ((MethodSymbol)symbol).ConstructedFrom;\n            } 356034"];
6804 [label="Symbol leastOverriddenSymbol = symbol.GetLeastOverriddenMember(containingType); 356035"];
6805 [label="Symbol leastOverriddenSymbol = symbol.GetLeastOverriddenMember(containingType); 356036"];
6806 [label="symbol.GetLeastOverriddenMember(containingType) 356037"];
6807 [label="param GetLeastOverriddenMember(this Symbol member) 356038"];
6808 [label="param GetLeastOverriddenMember(NamedTypeSymbol accessingTypeOpt) 356039"];
6809 [label="member.Kind 356040"];
6810 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 356041"];
6811 [label="switch (member.Kind)\n            {\n                case SymbolKind.Method:\n                    var method = (MethodSymbol)member;\n                    return method.GetConstructedLeastOverriddenMethod(accessingTypeOpt, requireSameReturnType: false);\n\n                case SymbolKind.Property:\n                    var property = (PropertySymbol)member;\n                    return property.GetLeastOverriddenProperty(accessingTypeOpt);\n\n                case SymbolKind.Event:\n                    var evnt = (EventSymbol)member;\n                    return evnt.GetLeastOverriddenEvent(accessingTypeOpt);\n\n                default:\n                    return member;\n            } 356042"];
6812 [label="return member; 356043"];
6813 [label="bool checkOverridingSymbol = hasBaseReceiver && !ReferenceEquals(symbol, leastOverriddenSymbol); 356044"];
6814 [label="if (checkOverridingSymbol)\n            {\n                // If we have a base receiver, we must be done with declaration binding, so it should\n                // be safe to decode diagnostics.  We want to do this since reporting for the overriding\n                // member is conditional on reporting for the overridden member (i.e. we need a definite\n                // answer so we don't double-report).  You might think that double reporting just results\n                // in cascading diagnostics, but it's possible that the second diagnostic is an error\n                // while the first is merely a warning.\n                leastOverriddenSymbol.GetAttributes();\n            } 356045"];
6815 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 356046"];
6816 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 356047"];
6817 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 356048"];
6818 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 356049"];
6819 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 356050"];
6820 [label="ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location) 356051"];
6821 [label="param ReportDiagnosticsIfObsoleteInternal(DiagnosticBag diagnostics) 356052"];
6822 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol symbol) 356053"];
6823 [label="param ReportDiagnosticsIfObsoleteInternal(SyntaxNodeOrToken node) 356054"];
6824 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol? containingMember) 356055"];
6825 [label="param ReportDiagnosticsIfObsoleteInternal(BinderFlags location) 356056"];
6826 [label="RoslynDebug.Assert(diagnostics != null); 356057"];
6827 [label="RoslynDebug.Assert(diagnostics != null); 356058"];
6828 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 356059"];
6829 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 356060"];
6830 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 356061"];
6831 [label="ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember) 356062"];
6832 [label="param GetObsoleteDiagnosticKind(Symbol symbol) 356063"];
6833 [label="param GetObsoleteDiagnosticKind(Symbol containingMember) 356064"];
6834 [label="param GetObsoleteDiagnosticKind(bool forceComplete = false) 356065"];
6835 [label="symbol.ObsoleteKind 356066"];
6836 [label="get\n            {\n                var data = this.ObsoleteAttributeData;\n                return (data == null) ? ObsoleteAttributeKind.None : data.Kind;\n            } 356067"];
6837 [label="this.ObsoleteAttributeData 356068"];
6838 [label="get\n            {\n                var lazyCustomAttributesBag = _lazyCustomAttributesBag;\n                if (lazyCustomAttributesBag != null && lazyCustomAttributesBag.IsEarlyDecodedWellKnownAttributeDataComputed)\n                {\n                    var data = (CommonTypeEarlyWellKnownAttributeData)lazyCustomAttributesBag.EarlyDecodedWellKnownAttributeData;\n                    return data != null ? data.ObsoleteAttributeData : null;\n                }\n\n                foreach (var decl in this.declaration.Declarations)\n                {\n                    if (decl.HasAnyAttributes)\n                    {\n                        return ObsoleteAttributeData.Uninitialized;\n                    }\n                }\n\n                return null;\n            } 356069"];
6839 [label="var lazyCustomAttributesBag = _lazyCustomAttributesBag; 356070"];
6840 [label="if (lazyCustomAttributesBag != null && lazyCustomAttributesBag.IsEarlyDecodedWellKnownAttributeDataComputed)\n                {\n                    var data = (CommonTypeEarlyWellKnownAttributeData)lazyCustomAttributesBag.EarlyDecodedWellKnownAttributeData;\n                    return data != null ? data.ObsoleteAttributeData : null;\n                } 356071"];
6841 [label="if (lazyCustomAttributesBag != null && lazyCustomAttributesBag.IsEarlyDecodedWellKnownAttributeDataComputed)\n                {\n                    var data = (CommonTypeEarlyWellKnownAttributeData)lazyCustomAttributesBag.EarlyDecodedWellKnownAttributeData;\n                    return data != null ? data.ObsoleteAttributeData : null;\n                } 356072"];
6842 [label="foreach (var decl in this.declaration.Declarations)\n                {\n                    if (decl.HasAnyAttributes)\n                    {\n                        return ObsoleteAttributeData.Uninitialized;\n                    }\n                } 356073"];
6843 [label="if (decl.HasAnyAttributes)\n                    {\n                        return ObsoleteAttributeData.Uninitialized;\n                    } 356074"];
6844 [label="return null; 356075"];
6845 [label="var data = this.ObsoleteAttributeData; 356076"];
6846 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 356077"];
6847 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 356078"];
6848 [label="(data == null) 356079"];
6849 [label="switch (symbol.ObsoleteKind)\n            {\n                case ObsoleteAttributeKind.None:\n                    return ObsoleteDiagnosticKind.NotObsolete;\n                case ObsoleteAttributeKind.Experimental:\n                    return ObsoleteDiagnosticKind.Diagnostic;\n                case ObsoleteAttributeKind.Uninitialized:\n                    // If we haven't cracked attributes on the symbol at all or we haven't\n                    // cracked attribute arguments enough to be able to report diagnostics for\n                    // ObsoleteAttribute, store the symbol so that we can report diagnostics at a \n                    // later stage.\n                    return ObsoleteDiagnosticKind.Lazy;\n            } 356080"];
6850 [label="return ObsoleteDiagnosticKind.NotObsolete; 356081"];
6851 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 356082"];
6852 [label="DiagnosticInfo? info = null; 356083"];
6853 [label="switch (kind)\n            {\n                case ObsoleteDiagnosticKind.Diagnostic:\n                    info = ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(symbol, location);\n                    break;\n                case ObsoleteDiagnosticKind.Lazy:\n                case ObsoleteDiagnosticKind.LazyPotentiallySuppressed:\n                    info = new LazyObsoleteDiagnosticInfo(symbol, containingMember, location);\n                    break;\n            } 356084"];
6854 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 356085"];
6855 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 356086"];
6856 [label="return kind; 356087"];
6857 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 356088"];
6858 [label="switch (diagnosticKind)\n            {\n                case ObsoleteDiagnosticKind.NotObsolete:\n                case ObsoleteDiagnosticKind.Lazy:\n                    if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    }\n                    break;\n            } 356089"];
6859 [label="if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    } 356090"];
6860 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 356091"];
6861 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 356092"];
6862 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 356093"];
6863 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 356094"];
6864 [label="return symbol; 356095"];
6865 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 356096"];
6866 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 356097"];
6867 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 356098"];
6868 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 356099"];
6869 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved) 356100"];
6870 [label="param UnwrapAlias(in NamespaceOrTypeOrAliasSymbolWithAnnotations symbol) 356101"];
6871 [label="param UnwrapAlias(DiagnosticBag diagnostics) 356102"];
6872 [label="param UnwrapAlias(SyntaxNode syntax) 356103"];
6873 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 356104"];
6874 [label="param UnwrapAlias(this) 356105"];
6875 [label="symbol.IsAlias 356106"];
6876 [label="=> _symbol?.Kind == SymbolKind.Alias 356107"];
6877 [label="_symbol 356108"];
6878 [label="_symbol?.Kind == SymbolKind.Alias 356109"];
6879 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 356110"];
6880 [label="return symbol; 356111"];
6881 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations 356112"];
6882 [label="=> _typeWithAnnotations 356113"];
6883 [label="_typeWithAnnotations 356114"];
6884 [label="type.IsStatic 356115"];
6885 [label="=>\n            _extensions.IsStatic(DefaultType) 356116"];
6886 [label="DefaultType 356117"];
6887 [label="_extensions.IsStatic(DefaultType) 356118"];
6888 [label="param IsStatic(TypeSymbol typeSymbol) 356119"];
6889 [label="=> typeSymbol.IsStatic 356120"];
6890 [label="typeSymbol.IsStatic 356121"];
6891 [label="=> HasFlag(DeclarationModifiers.Static) 356122"];
6892 [label="DeclarationModifiers.Static 356123"];
6893 [label="HasFlag(DeclarationModifiers.Static) 356124"];
6894 [label="param HasFlag(DeclarationModifiers flag) 356125"];
6895 [label="=> (_declModifiers & flag) != 0 356126"];
6896 [label="_declModifiers & flag 356127"];
6897 [label="0 356128"];
6898 [label="(_declModifiers & flag) != 0 356129"];
6899 [label="if (type.IsStatic)\n            {\n                // CS0719: '{0}': array elements cannot be of static type\n                Error(diagnostics, ErrorCode.ERR_ArrayOfStaticClass, node.ElementType, type.Type);\n            } 356130"];
6900 [label="if (disallowRestrictedTypes)\n            {\n                // Restricted types cannot be on the heap, but they can be on the stack, so are allowed in a stackalloc\n                if (ShouldCheckConstraints)\n                {\n                    if (type.IsRestrictedType())\n                    {\n                        // CS0611: Array elements cannot be of type '{0}'\n                        Error(diagnostics, ErrorCode.ERR_ArrayElementCantBeRefAny, node.ElementType, type.Type);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation());\n                }\n            } 356131"];
6901 [label="ShouldCheckConstraints 356132"];
6902 [label="get\n            {\n                return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks);\n            } 356133"];
6903 [label="return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks); 356134"];
6904 [label="return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks); 356135"];
6905 [label="this.Flags.Includes(BinderFlags.SuppressConstraintChecks) 356136"];
6906 [label="param Includes(this BinderFlags self) 356137"];
6907 [label="param Includes(BinderFlags other) 356138"];
6908 [label="if (ShouldCheckConstraints)\n                {\n                    if (type.IsRestrictedType())\n                    {\n                        // CS0611: Array elements cannot be of type '{0}'\n                        Error(diagnostics, ErrorCode.ERR_ArrayElementCantBeRefAny, node.ElementType, type.Type);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation());\n                } 356139"];
6909 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 356140"];
6910 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 356141"];
6911 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 356142"];
6912 [label="for (int i = node.RankSpecifiers.Count - 1; i >= 0; i--)\n            {\n                var rankSpecifier = node.RankSpecifiers[i];\n                var dimension = rankSpecifier.Sizes;\n                if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                }\n\n                var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank);\n                type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array);\n            } 356143"];
6913 [label="for (int i = node.RankSpecifiers.Count - 1; i >= 0; i--)\n            {\n                var rankSpecifier = node.RankSpecifiers[i];\n                var dimension = rankSpecifier.Sizes;\n                if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                }\n\n                var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank);\n                type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array);\n            } 356144"];
6914 [label="var rankSpecifier = node.RankSpecifiers[i]; 356145"];
6915 [label="var dimension = rankSpecifier.Sizes; 356146"];
6916 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 356147"];
6917 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 356148"];
6918 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 356149"];
6919 [label="this.Compilation.Assembly 356150"];
6920 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 356151"];
6921 [label="return _referenceManager; 356152"];
6922 [label="GetBoundReferenceManager(); 356153"];
6923 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 356154"];
6924 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 356155"];
6925 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 356156"];
6926 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 356157"];
6927 [label="ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank) 356158"];
6928 [label="param CreateCSharpArray(AssemblySymbol declaringAssembly) 356159"];
6929 [label="param CreateCSharpArray(TypeWithAnnotations elementTypeWithAnnotations) 356160"];
6930 [label="param CreateCSharpArray(int rank = 1) 356161"];
6931 [label="if (rank == 1)\n            {\n                return CreateSZArray(declaringAssembly, elementTypeWithAnnotations);\n            } 356162"];
6932 [label="if (rank == 1)\n            {\n                return CreateSZArray(declaringAssembly, elementTypeWithAnnotations);\n            } 356163"];
6933 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 356164"];
6934 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 356165"];
6935 [label="CreateSZArray(declaringAssembly, elementTypeWithAnnotations) 356166"];
6936 [label="param CreateSZArray(AssemblySymbol declaringAssembly) 356167"];
6937 [label="param CreateSZArray(TypeWithAnnotations elementType) 356168"];
6938 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 356169"];
6939 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 356170"];
6940 [label="declaringAssembly.GetSpecialType(SpecialType.System_Array) 356171"];
6941 [label="param GetSpecialType(SpecialType type) 356172"];
6942 [label="param GetSpecialType(this) 356173"];
6943 [label="CorLibrary 356174"];
6944 [label="get\n            {\n                return _corLibrary;\n            } 356175"];
6945 [label="return CorLibrary.GetDeclaredSpecialType(type); 356176"];
6946 [label="return CorLibrary.GetDeclaredSpecialType(type); 356177"];
6947 [label="CorLibrary.GetDeclaredSpecialType(type) 356178"];
6948 [label="param GetDeclaredSpecialType(SpecialType type) 356179"];
6949 [label="param GetDeclaredSpecialType(this) 356180"];
6950 [label="this.Modules 356181"];
6951 [label="get\n            {\n                return _modules;\n            } 356182"];
6952 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 356183"];
6953 [label="module.GetReferencedAssemblies() 356184"];
6954 [label="param GetReferencedAssemblies(this) 356185"];
6955 [label="AssertReferencesInitialized() 356186"];
6956 [label="param AssertReferencesInitialized(this) 356187"];
6957 [label="Debug.Assert(_moduleReferences != null); 356188"];
6958 [label="Debug.Assert(_moduleReferences != null); 356189"];
6959 [label="AssertReferencesInitialized(); 356190"];
6960 [label="return _moduleReferences.Identities; 356191"];
6961 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 356192"];
6962 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 356193"];
6963 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 356194"];
6964 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 356195"];
6965 [label="MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true); 356196"];
6966 [label="MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true); 356197"];
6967 [label="this.Modules 356198"];
6968 [label="ModuleSymbol module = this.Modules[0]; 356199"];
6969 [label="ModuleSymbol module = this.Modules[0]; 356200"];
6970 [label="NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName); 356201"];
6971 [label="module.LookupTopLevelMetadataType(ref emittedName) 356202"];
6972 [label="param LookupTopLevelMetadataType(ref MetadataTypeName emittedName) 356203"];
6973 [label="param LookupTopLevelMetadataType(this) 356204"];
6974 [label="NamedTypeSymbol result; 356205"];
6975 [label="this.GlobalNamespace 356206"];
6976 [label="get { return _globalNamespace; } 356207"];
6977 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 356208"];
6978 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 356209"];
6979 [label="this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments) 356210"];
6980 [label="param LookupNestedNamespace(ImmutableArray<string> names) 356211"];
6981 [label="param LookupNestedNamespace(this) 356212"];
6982 [label="NamespaceSymbol scope = this; 356213"];
6983 [label="foreach (string name in names)\n            {\n                NamespaceSymbol nextScope = null;\n\n                foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                }\n\n                scope = nextScope;\n\n                if ((object)scope == null)\n                {\n                    break;\n                }\n            } 356214"];
6984 [label="NamespaceSymbol nextScope = null; 356215"];
6985 [label="foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                } 356216"];
6986 [label="scope.GetMembers(name) 356217"];
6987 [label="param GetMembers(string name) 356218"];
6988 [label="param GetMembers(this) 356219"];
6989 [label="EnsureAllMembersLoaded(); 356220"];
6990 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 356221"];
6991 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 356222"];
6992 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 356223"];
6993 [label="return ImmutableArray.Create<Symbol>(ns); 356224"];
6994 [label="var ns = symbol as NamespaceSymbol; 356225"];
6995 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 356226"];
6996 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 356227"];
6997 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 356228"];
6998 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 356229"];
6999 [label="nextScope = ns; 356230"];
7000 [label="scope = nextScope; 356231"];
7001 [label="if ((object)scope == null)\n                {\n                    break;\n                } 356232"];
7002 [label="if ((object)scope == null)\n                {\n                    break;\n                } 356233"];
7003 [label="return scope; 356234"];
7004 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 356235"];
7005 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 356236"];
7006 [label="result = scope.LookupMetadataType(ref emittedName); 356237"];
7007 [label="scope.LookupMetadataType(ref emittedName) 356238"];
7008 [label="param LookupMetadataType(ref MetadataTypeName emittedTypeName) 356239"];
7009 [label="param LookupMetadataType(this) 356240"];
7010 [label="Debug.Assert(!emittedTypeName.IsNull); 356241"];
7011 [label="NamespaceOrTypeSymbol scope = this; 356242"];
7012 [label="scope.Kind 356243"];
7013 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 356244"];
7014 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 356245"];
7015 [label="NamedTypeSymbol? namedType = null; 356246"];
7016 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 356247"];
7017 [label="namespaceOrTypeMembers 356248"];
7018 [label="scope.IsNamespace 356249"];
7019 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 356250"];
7020 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 356251"];
7021 [label="bool isTopLevel = scope.IsNamespace; 356252"];
7022 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 356253"];
7023 [label="scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) 356254"];
7024 [label="param ToDisplayString(SymbolDisplayFormat format = null) 356255"];
7025 [label="param ToDisplayString(this) 356256"];
7026 [label="ISymbol 356257"];
7027 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 356258"];
7028 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 356259"];
7029 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 356260"];
7030 [label="CreateISymbol() 356261"];
7031 [label="param CreateISymbol(this) 356262"];
7032 [label="return new PublicModel.NamespaceSymbol(this); 356263"];
7033 [label="return new PublicModel.NamespaceSymbol(this); 356264"];
7034 [label="new PublicModel.NamespaceSymbol(this) 356265"];
7035 [label="param NamespaceSymbol(Symbols.NamespaceSymbol underlying) 356266"];
7036 [label="param NamespaceSymbol(this) 356267"];
7037 [label="param NamespaceSymbol(this) 356268"];
7038 [label="param NamespaceOrTypeSymbol(this) 356269"];
7039 [label="param NamespaceOrTypeSymbol(this) 356270"];
7040 [label="param Symbol(this) 356271"];
7041 [label="_underlying 356272"];
7042 [label="Debug.Assert(underlying is object); 356273"];
7043 [label="_underlying 356274"];
7044 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 356275"];
7045 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 356276"];
7046 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 356277"];
7047 [label="return _lazyISymbol; 356278"];
7048 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 356279"];
7049 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 356280"];
7050 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 356281"];
7051 [label="param ToDisplayString(ISymbol symbol) 356282"];
7052 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 356283"];
7053 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 356284"];
7054 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 356285"];
7055 [label="ToDisplayParts(symbol, format) 356286"];
7056 [label="param ToDisplayParts(ISymbol symbol) 356287"];
7057 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 356288"];
7058 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 356289"];
7059 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 356290"];
7060 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 356291"];
7061 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 356292"];
7062 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 356293"];
7063 [label="param ToDisplayParts(ISymbol symbol) 356294"];
7064 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 356295"];
7065 [label="param ToDisplayParts(int positionOpt) 356296"];
7066 [label="param ToDisplayParts(SymbolDisplayFormat format) 356297"];
7067 [label="param ToDisplayParts(bool minimal) 356298"];
7068 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 356299"];
7069 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 356300"];
7070 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 356301"];
7071 [label="Debug.Assert(semanticModelOpt == null); 356302"];
7072 [label="Debug.Assert(semanticModelOpt == null); 356303"];
7073 [label="Debug.Assert(positionOpt < 0); 356304"];
7074 [label="Debug.Assert(positionOpt < 0); 356305"];
7075 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 356306"];
7076 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 356307"];
7077 [label="'modopt' 356308"];
7078 [label="IL_KEYWORD_MODOPT = 'modopt' 356309"];
7079 [label="'modreq' 356310"];
7080 [label="IL_KEYWORD_MODREQ = 'modreq' 356311"];
7081 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 356312"];
7082 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 356313"];
7083 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 356314"];
7084 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 356315"];
7085 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 356316"];
7086 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 356317"];
7087 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 356318"];
7088 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 356319"];
7089 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 356320"];
7090 [label="param SymbolDisplayVisitor(int positionOpt) 356321"];
7091 [label="param SymbolDisplayVisitor(this) 356322"];
7092 [label="builder 356323"];
7093 [label="format 356324"];
7094 [label="true 356325"];
7095 [label="semanticModelOpt 356326"];
7096 [label="positionOpt 356327"];
7097 [label="param SymbolDisplayVisitor(this) 356328"];
7098 [label="param SymbolDisplayVisitor(this) 356329"];
7099 [label="_escapeKeywordIdentifiers 356330"];
7100 [label="_lazyAliasMap 356331"];
7101 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 356332"];
7102 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 356333"];
7103 [label="_escapeKeywordIdentifiers 356334"];
7104 [label="symbol.Accept(visitor); 356335"];
7105 [label="symbol.Accept(visitor) 356336"];
7106 [label="param Accept(SymbolVisitor visitor) 356337"];
7107 [label="param Accept(this) 356338"];
7108 [label="Accept(visitor); 356339"];
7109 [label="Accept(visitor) 356340"];
7110 [label="param Accept(SymbolVisitor visitor) 356341"];
7111 [label="param Accept(this) 356342"];
7112 [label="visitor.VisitNamespace(this); 356343"];
7113 [label="visitor.VisitNamespace(this) 356344"];
7114 [label="param VisitNamespace(INamespaceSymbol symbol) 356345"];
7115 [label="param VisitNamespace(this) 356346"];
7116 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 356347"];
7117 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 356348"];
7118 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 356349"];
7119 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                var containingNamespace = symbol.ContainingNamespace;\n                if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 356350"];
7120 [label="symbol.ContainingNamespace 356351"];
7121 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 356352"];
7122 [label="UnderlyingSymbol 356353"];
7123 [label="=> _underlying 356354"];
7124 [label="_underlying 356355"];
7125 [label="UnderlyingSymbol.ContainingNamespace 356356"];
7126 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 356357"];
7127 [label="this.ContainingSymbol 356358"];
7128 [label="get { return _containingNamespaceSymbol; } 356359"];
7129 [label="return _containingNamespaceSymbol; 356360"];
7130 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 356361"];
7131 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 356362"];
7132 [label="var ns = container as NamespaceSymbol; 356363"];
7133 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 356364"];
7134 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 356365"];
7135 [label="return ns; 356366"];
7136 [label="UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 356367"];
7137 [label="param GetPublicSymbol(this NamespaceSymbol? symbol) 356368"];
7138 [label="return symbol.GetPublicSymbol<INamespaceSymbol>(); 356369"];
7139 [label="symbol.GetPublicSymbol<INamespaceSymbol>() 356370"];
7140 [label="param GetPublicSymbol(this Symbol? symbol) 356371"];
7141 [label=".ISymbol 356372"];
7142 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 356373"];
7143 [label="param NamespaceOrTypeSymbol(this) 356374"];
7144 [label="param Symbol(this) 356375"];
7145 [label="_underlying 356376"];
7146 [label="Debug.Assert(underlying is object); 356377"];
7147 [label="return (TISymbol?)symbol?.ISymbol; 356378"];
7148 [label="var containingNamespace = symbol.ContainingNamespace; 356379"];
7149 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 356380"];
7150 [label="ShouldVisitNamespace(containingNamespace) 356381"];
7151 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 356382"];
7152 [label="param ShouldVisitNamespace(this) 356383"];
7153 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 356384"];
7154 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 356385"];
7155 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 356386"];
7156 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 356387"];
7157 [label="namespaceSymbol.IsGlobalNamespace 356388"];
7158 [label="=> _underlying.IsGlobalNamespace 356389"];
7159 [label="_underlying.IsGlobalNamespace 356390"];
7160 [label="get\n            {\n                return true;\n            } 356391"];
7161 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 356392"];
7162 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 356393"];
7163 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 356394"];
7164 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 356395"];
7165 [label="symbol.IsGlobalNamespace 356396"];
7166 [label="=> _underlying.IsGlobalNamespace 356397"];
7167 [label="_underlying.IsGlobalNamespace 356398"];
7168 [label="get\n            {\n                return false;\n            } 356399"];
7169 [label="return false; 356400"];
7170 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 356401"];
7171 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 356402"];
7172 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 356403"];
7173 [label="symbol.Name 356404"];
7174 [label="=> UnderlyingSymbol.Name 356405"];
7175 [label="UnderlyingSymbol 356406"];
7176 [label="=> _underlying 356407"];
7177 [label="_underlying 356408"];
7178 [label="UnderlyingSymbol.Name 356409"];
7179 [label="get\n            {\n                return _name;\n            } 356410"];
7180 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 356411"];
7181 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 356412"];
7182 [label="param CreatePart(SymbolDisplayPartKind kind) 356413"];
7183 [label="param CreatePart(ISymbol symbol) 356414"];
7184 [label="param CreatePart(string text) 356415"];
7185 [label="param CreatePart(this) 356416"];
7186 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 356417"];
7187 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 356418"];
7188 [label="(text == null) 356419"];
7189 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 356420"];
7190 [label="(_escapeKeywordIdentifiers && IsEscapable(kind)) 356421"];
7191 [label="return new SymbolDisplayPart(kind, symbol, text); 356422"];
7192 [label="return new SymbolDisplayPart(kind, symbol, text); 356423"];
7193 [label="return new SymbolDisplayPart(kind, symbol, text); 356424"];
7194 [label="return new SymbolDisplayPart(kind, symbol, text); 356425"];
7195 [label="visitor.VisitNamespace(this); 356426"];
7196 [label="Accept(visitor); 356427"];
7197 [label="symbol.Accept(visitor); 356428"];
7198 [label="return builder.ToImmutableAndFree(); 356429"];
7199 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 356430"];
7200 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 356431"];
7201 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 356432"];
7202 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 356433"];
7203 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 356434"];
7204 [label="int forcedArity = emittedTypeName.ForcedArity; 356435"];
7205 [label="if (emittedTypeName.UseCLSCompliantNameArityEncoding)\n            {\n                // Only types with arity 0 are acceptable, we already examined types with mangled names.\n                if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                }\n            } 356436"];
7206 [label="if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 356437"];
7207 [label="if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 356438"];
7208 [label="if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 356439"];
7209 [label="forcedArity = 0; 356440"];
7210 [label="namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.TypeName); 356441"];
7211 [label="scope.GetTypeMembers(emittedTypeName.TypeName) 356442"];
7212 [label="param GetTypeMembers(string name) 356443"];
7213 [label="param GetTypeMembers(this) 356444"];
7214 [label="EnsureAllMembersLoaded() 356445"];
7215 [label="param EnsureAllMembersLoaded(this) 356446"];
7216 [label="var typesByNS = _typesByNS; 356447"];
7217 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 356448"];
7218 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 356449"];
7219 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 356450"];
7220 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 356451"];
7221 [label="LoadAllMembers(typesByNS); 356452"];
7222 [label="LoadAllMembers(typesByNS) 356453"];
7223 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 356454"];
7224 [label="Debug.Assert(typesByNS != null); 356455"];
7225 [label="Debug.Assert(typesByNS != null); 356456"];
7226 [label="get\n            {\n                return false;\n            } 356457"];
7227 [label="GetQualifiedNameLength() 356458"];
7228 [label="param GetQualifiedNameLength(this) 356459"];
7229 [label="this.Name 356460"];
7230 [label="get\n            {\n                return _name;\n            } 356461"];
7231 [label="int length = this.Name.Length; 356462"];
7232 [label="ContainingNamespace 356463"];
7233 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 356464"];
7234 [label="var parent = ContainingNamespace; 356465"];
7235 [label=".IsGlobalNamespace 356466"];
7236 [label="get\n            {\n                return true;\n            } 356467"];
7237 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 356468"];
7238 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 356469"];
7239 [label="return length; 356470"];
7240 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 356471"];
7241 [label="_containingNamespaceSymbol 356472"];
7242 [label="_name 356473"];
7243 [label="_typesByNS 356474"];
7244 [label="Debug.Assert(name != null); 356475"];
7245 [label="Debug.Assert((object)containingNamespace != null); 356476"];
7246 [label="Debug.Assert(typesByNS != null); 356477"];
7247 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356478"];
7248 [label="_containingNamespaceSymbol.ContainingPEModule 356479"];
7249 [label="get\n            {\n                return _moduleSymbol;\n            } 356480"];
7250 [label="return _containingNamespaceSymbol.ContainingPEModule; 356481"];
7251 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 356482"];
7252 [label="genericParameterHandles 356483"];
7253 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 356484"];
7254 [label="param GetGenericInfo(out ushort arity) 356485"];
7255 [label="param GetGenericInfo(out BadImageFormatException mrEx) 356486"];
7256 [label="mrEx = null; 356487"];
7257 [label="PENamedTypeSymbol result; 356488"];
7258 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 356489"];
7259 [label="mangleName 356490"];
7260 [label="param PENamedTypeSymbol(out bool mangleName) 356491"];
7261 [label="_lazyTupleData 356492"];
7262 [label="_container 356493"];
7263 [label="_name 356494"];
7264 [label="_flags 356495"];
7265 [label="_corTypeId 356496"];
7266 [label="Debug.Assert(!handle.IsNil); 356497"];
7267 [label="Debug.Assert((object)container != null); 356498"];
7268 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 356499"];
7269 [label="string metadataName; 356500"];
7270 [label="bool makeBad = false; 356501"];
7271 [label="mangleName = false; 356502"];
7272 [label="Accessibility access = Accessibility.Private; 356503"];
7273 [label="access = Accessibility.Public; 356504"];
7274 [label="_corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName)); 356505"];
7275 [label="_corTypeId 356506"];
7276 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 356507"];
7277 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 356508"];
7278 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 356509"];
7279 [label="genericParameterHandles 356510"];
7280 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 356511"];
7281 [label="param GetGenericInfo(out ushort arity) 356512"];
7282 [label="param GetGenericInfo(out BadImageFormatException mrEx) 356513"];
7283 [label="mrEx = null; 356514"];
7284 [label="PENamedTypeSymbol result; 356515"];
7285 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 356516"];
7286 [label="mangleName 356517"];
7287 [label="param PENamedTypeSymbol(out bool mangleName) 356518"];
7288 [label="_lazyTupleData 356519"];
7289 [label="_container 356520"];
7290 [label="_name 356521"];
7291 [label="_flags 356522"];
7292 [label="_corTypeId 356523"];
7293 [label="Debug.Assert(!handle.IsNil); 356524"];
7294 [label="Debug.Assert((object)container != null); 356525"];
7295 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 356526"];
7296 [label="string metadataName; 356527"];
7297 [label="bool makeBad = false; 356528"];
7298 [label="mangleName = false; 356529"];
7299 [label="Accessibility access = Accessibility.Private; 356530"];
7300 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 356531"];
7301 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 356532"];
7302 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 356533"];
7303 [label="_corTypeId 356534"];
7304 [label="genericParameterHandles 356535"];
7305 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 356536"];
7306 [label="param GetGenericInfo(out ushort arity) 356537"];
7307 [label="param GetGenericInfo(out BadImageFormatException mrEx) 356538"];
7308 [label="mrEx = null; 356539"];
7309 [label="PENamedTypeSymbol result; 356540"];
7310 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 356541"];
7311 [label="mangleName 356542"];
7312 [label="param PENamedTypeSymbol(out bool mangleName) 356543"];
7313 [label="_lazyTupleData 356544"];
7314 [label="_container 356545"];
7315 [label="_name 356546"];
7316 [label="_flags 356547"];
7317 [label="_corTypeId 356548"];
7318 [label="Debug.Assert(!handle.IsNil); 356549"];
7319 [label="Debug.Assert((object)container != null); 356550"];
7320 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 356551"];
7321 [label="string metadataName; 356552"];
7322 [label="bool makeBad = false; 356553"];
7323 [label="mangleName = false; 356554"];
7324 [label="Accessibility access = Accessibility.Private; 356555"];
7325 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 356556"];
7326 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 356557"];
7327 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 356558"];
7328 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 356559"];
7329 [label="mangleName 356560"];
7330 [label="param PENamedTypeSymbol(out bool mangleName) 356561"];
7331 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 356562"];
7332 [label="_arity 356563"];
7333 [label="_mangleName 356564"];
7334 [label="Debug.Assert(genericParameterHandles.Count > 0); 356565"];
7335 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 356566"];
7336 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 356567"];
7337 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 356568"];
7338 [label="bool added; 356569"];
7339 [label="Debug.Assert(added); 356570"];
7340 [label="type.SpecialType 356571"];
7341 [label="get\n            {\n                return _corTypeId;\n            } 356572"];
7342 [label="return _corTypeId; 356573"];
7343 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 356574"];
7344 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 356575"];
7345 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 356576"];
7346 [label="_assemblySymbol.RegisterDeclaredSpecialType(type) 356577"];
7347 [label="param RegisterDeclaredSpecialType(NamedTypeSymbol corType) 356578"];
7348 [label="param RegisterDeclaredSpecialType(this) 356579"];
7349 [label="corType.SpecialType 356580"];
7350 [label="get\n            {\n                return _corTypeId;\n            } 356581"];
7351 [label="SpecialType typeId = corType.SpecialType; 356582"];
7352 [label="Debug.Assert(typeId != SpecialType.None); 356583"];
7353 [label="corType.ContainingAssembly 356584"];
7354 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 356585"];
7355 [label="get\n            {\n                return _container;\n            } 356586"];
7356 [label="return _container; 356587"];
7357 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 356588"];
7358 [label="ContainingPEModule 356589"];
7359 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356590"];
7360 [label="return ContainingPEModule.ContainingAssembly; 356591"];
7361 [label="ContainingPEModule.ContainingAssembly 356592"];
7362 [label="get\n            {\n                return _assemblySymbol;\n            } 356593"];
7363 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 356594"];
7364 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 356595"];
7365 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 356596"];
7366 [label="corType.ContainingModule 356597"];
7367 [label="get\n            {\n                return ContainingPEModule;\n            } 356598"];
7368 [label="ContainingPEModule 356599"];
7369 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 356600"];
7370 [label="Symbol s = _container; 356601"];
7371 [label="s.Kind 356602"];
7372 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 356603"];
7373 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 356604"];
7374 [label="((PENamespaceSymbol)s).ContainingPEModule 356605"];
7375 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356606"];
7376 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 356607"];
7377 [label="return ContainingPEModule; 356608"];
7378 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 356609"];
7379 [label="corType.ContainingModule.Ordinal 356610"];
7380 [label="get\n            {\n                return _ordinal;\n            } 356611"];
7381 [label="return _ordinal; 356612"];
7382 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 356613"];
7383 [label="this.CorLibrary 356614"];
7384 [label="get\n            {\n                return _corLibrary;\n            } 356615"];
7385 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 356616"];
7386 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 356617"];
7387 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 356618"];
7388 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 356619"];
7389 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 356620"];
7390 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 356621"];
7391 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 356622"];
7392 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 356623"];
7393 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 356624"];
7394 [label="Interlocked.Increment(ref _cachedSpecialTypes); 356625"];
7395 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 356626"];
7396 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 356627"];
7397 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 356628"];
7398 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 356629"];
7399 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 356630"];
7400 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 356631"];
7401 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 356632"];
7402 [label="keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes; 356633"];
7403 [label="bool added; 356634"];
7404 [label="Debug.Assert(added); 356635"];
7405 [label="Debug.Assert(typeId != SpecialType.None); 356636"];
7406 [label="corType.ContainingAssembly 356637"];
7407 [label="get\n            {\n                return _container;\n            } 356638"];
7408 [label="return _container; 356639"];
7409 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 356640"];
7410 [label="ContainingPEModule 356641"];
7411 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356642"];
7412 [label="return ContainingPEModule.ContainingAssembly; 356643"];
7413 [label="ContainingPEModule.ContainingAssembly 356644"];
7414 [label="get\n            {\n                return _assemblySymbol;\n            } 356645"];
7415 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 356646"];
7416 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 356647"];
7417 [label="corType.ContainingModule 356648"];
7418 [label="get\n            {\n                return ContainingPEModule;\n            } 356649"];
7419 [label="ContainingPEModule 356650"];
7420 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 356651"];
7421 [label="Symbol s = _container; 356652"];
7422 [label="s.Kind 356653"];
7423 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 356654"];
7424 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 356655"];
7425 [label="((PENamespaceSymbol)s).ContainingPEModule 356656"];
7426 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356657"];
7427 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 356658"];
7428 [label="return ContainingPEModule; 356659"];
7429 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 356660"];
7430 [label="corType.ContainingModule.Ordinal 356661"];
7431 [label="get\n            {\n                return _ordinal;\n            } 356662"];
7432 [label="return _ordinal; 356663"];
7433 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 356664"];
7434 [label="this.CorLibrary 356665"];
7435 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 356666"];
7436 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 356667"];
7437 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 356668"];
7438 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 356669"];
7439 [label="bool added; 356670"];
7440 [label="Debug.Assert(added); 356671"];
7441 [label="Debug.Assert(typeId != SpecialType.None); 356672"];
7442 [label="corType.ContainingAssembly 356673"];
7443 [label="get\n            {\n                return _container;\n            } 356674"];
7444 [label="return _container; 356675"];
7445 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 356676"];
7446 [label="ContainingPEModule 356677"];
7447 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356678"];
7448 [label="return ContainingPEModule.ContainingAssembly; 356679"];
7449 [label="ContainingPEModule.ContainingAssembly 356680"];
7450 [label="get\n            {\n                return _assemblySymbol;\n            } 356681"];
7451 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 356682"];
7452 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 356683"];
7453 [label="corType.ContainingModule 356684"];
7454 [label="get\n            {\n                return ContainingPEModule;\n            } 356685"];
7455 [label="ContainingPEModule 356686"];
7456 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 356687"];
7457 [label="Symbol s = _container; 356688"];
7458 [label="s.Kind 356689"];
7459 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 356690"];
7460 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 356691"];
7461 [label="((PENamespaceSymbol)s).ContainingPEModule 356692"];
7462 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356693"];
7463 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 356694"];
7464 [label="return ContainingPEModule; 356695"];
7465 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 356696"];
7466 [label="corType.ContainingModule.Ordinal 356697"];
7467 [label="get\n            {\n                return _ordinal;\n            } 356698"];
7468 [label="return _ordinal; 356699"];
7469 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 356700"];
7470 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 356701"];
7471 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 356702"];
7472 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 356703"];
7473 [label="bool added; 356704"];
7474 [label="Debug.Assert(added); 356705"];
7475 [label="return _container; 356706"];
7476 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 356707"];
7477 [label="ContainingPEModule 356708"];
7478 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356709"];
7479 [label="return ContainingPEModule.ContainingAssembly; 356710"];
7480 [label="ContainingPEModule.ContainingAssembly 356711"];
7481 [label="get\n            {\n                return _assemblySymbol;\n            } 356712"];
7482 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 356713"];
7483 [label="Symbol s = _container; 356714"];
7484 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 356715"];
7485 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356716"];
7486 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 356717"];
7487 [label="return ContainingPEModule; 356718"];
7488 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 356719"];
7489 [label="get\n            {\n                return _ordinal;\n            } 356720"];
7490 [label="return _ordinal; 356721"];
7491 [label="LoadAllMembers(typesByNS); 356722"];
7492 [label="Interlocked.Exchange(ref _typesByNS, null); 356723"];
7493 [label="Interlocked.Exchange(ref _typesByNS, null); 356724"];
7494 [label="EnsureAllMembersLoaded(); 356725"];
7495 [label="ImmutableArray<PENamedTypeSymbol> t; 356726"];
7496 [label="t 356727"];
7497 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 356728"];
7498 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 356729"];
7499 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 356730"];
7500 [label="lazyTypes.TryGetValue(name, out t) 356731"];
7501 [label="foreach (var named in namespaceOrTypeMembers)\n            {\n                if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                }\n            } 356732"];
7502 [label="named.MangleName 356733"];
7503 [label="get\n                {\n                    return false;\n                } 356734"];
7504 [label="return false; 356735"];
7505 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 356736"];
7506 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 356737"];
7507 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 356738"];
7508 [label="named.Arity 356739"];
7509 [label="get\n                {\n                    return 0;\n                } 356740"];
7510 [label="return 0; 356741"];
7511 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 356742"];
7512 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 356743"];
7513 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 356744"];
7514 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 356745"];
7515 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 356746"];
7516 [label="namedType = named; 356747"];
7517 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 356748"];
7518 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 356749"];
7519 [label="return namedType; 356750"];
7520 [label="Debug.Assert((object)result != null); 356751"];
7521 [label="Debug.Assert((object)result != null); 356752"];
7522 [label="return result; 356753"];
7523 [label="result.Kind 356754"];
7524 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 356755"];
7525 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 356756"];
7526 [label="result.DeclaredAccessibility 356757"];
7527 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 356758"];
7528 [label="Accessibility access = Accessibility.Private; 356759"];
7529 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 356760"];
7530 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 356761"];
7531 [label="RegisterDeclaredSpecialType(result); 356762"];
7532 [label="RegisterDeclaredSpecialType(result) 356763"];
7533 [label="param RegisterDeclaredSpecialType(NamedTypeSymbol corType) 356764"];
7534 [label="param RegisterDeclaredSpecialType(this) 356765"];
7535 [label="corType.SpecialType 356766"];
7536 [label="Debug.Assert(typeId != SpecialType.None); 356767"];
7537 [label="corType.ContainingAssembly 356768"];
7538 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 356769"];
7539 [label="get\n            {\n                return _container;\n            } 356770"];
7540 [label="return _container; 356771"];
7541 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 356772"];
7542 [label="ContainingPEModule 356773"];
7543 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356774"];
7544 [label="return ContainingPEModule.ContainingAssembly; 356775"];
7545 [label="ContainingPEModule.ContainingAssembly 356776"];
7546 [label="get\n            {\n                return _assemblySymbol;\n            } 356777"];
7547 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 356778"];
7548 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 356779"];
7549 [label="corType.ContainingModule 356780"];
7550 [label="get\n            {\n                return ContainingPEModule;\n            } 356781"];
7551 [label="ContainingPEModule 356782"];
7552 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 356783"];
7553 [label="Symbol s = _container; 356784"];
7554 [label="s.Kind 356785"];
7555 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 356786"];
7556 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 356787"];
7557 [label="((PENamespaceSymbol)s).ContainingPEModule 356788"];
7558 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356789"];
7559 [label="_containingNamespaceSymbol.ContainingPEModule 356790"];
7560 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 356791"];
7561 [label="return ContainingPEModule; 356792"];
7562 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 356793"];
7563 [label="corType.ContainingModule.Ordinal 356794"];
7564 [label="get\n            {\n                return _ordinal;\n            } 356795"];
7565 [label="return _ordinal; 356796"];
7566 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 356797"];
7567 [label="this.CorLibrary 356798"];
7568 [label="get\n            {\n                return _corLibrary;\n            } 356799"];
7569 [label="return _corLibrary; 356800"];
7570 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 356801"];
7571 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 356802"];
7572 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 356803"];
7573 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 356804"];
7574 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 356805"];
7575 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 356806"];
7576 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 356807"];
7577 [label="RegisterDeclaredSpecialType(result); 356808"];
7578 [label="return _lazySpecialTypes[(int)type]; 356809"];
7579 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 356810"];
7580 [label="GetSZArrayInterfaces(elementType, declaringAssembly) 356811"];
7581 [label="param GetSZArrayInterfaces(TypeWithAnnotations elementTypeWithAnnotations) 356812"];
7582 [label="param GetSZArrayInterfaces(AssemblySymbol declaringAssembly) 356813"];
7583 [label="var constructedInterfaces = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 356814"];
7584 [label="var iListOfT = declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IList_T); 356815"];
7585 [label="declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IList_T) 356816"];
7586 [label="param GetSpecialType(SpecialType type) 356817"];
7587 [label="param GetSpecialType(this) 356818"];
7588 [label="CorLibrary 356819"];
7589 [label="get\n            {\n                return _corLibrary;\n            } 356820"];
7590 [label="return _corLibrary; 356821"];
7591 [label="return CorLibrary.GetDeclaredSpecialType(type); 356822"];
7592 [label="CorLibrary.GetDeclaredSpecialType(type) 356823"];
7593 [label="param GetDeclaredSpecialType(SpecialType type) 356824"];
7594 [label="this.Modules 356825"];
7595 [label="get\n            {\n                return _modules;\n            } 356826"];
7596 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 356827"];
7597 [label="module.GetReferencedAssemblies() 356828"];
7598 [label="param GetReferencedAssemblies(this) 356829"];
7599 [label="AssertReferencesInitialized() 356830"];
7600 [label="param AssertReferencesInitialized(this) 356831"];
7601 [label="Debug.Assert(_moduleReferences != null); 356832"];
7602 [label="Debug.Assert(_moduleReferences != null); 356833"];
7603 [label="AssertReferencesInitialized(); 356834"];
7604 [label="return _moduleReferences.Identities; 356835"];
7605 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 356836"];
7606 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 356837"];
7607 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 356838"];
7608 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 356839"];
7609 [label="NamedTypeSymbol result; 356840"];
7610 [label="NamespaceSymbol nextScope = null; 356841"];
7611 [label="EnsureAllMembersLoaded(); 356842"];
7612 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 356843"];
7613 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 356844"];
7614 [label="if ((object)scope == null)\n                {\n                    break;\n                } 356845"];
7615 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 356846"];
7616 [label="Debug.Assert(typesByNS != null); 356847"];
7617 [label="get\n            {\n                return false;\n            } 356848"];
7618 [label="ContainingNamespace 356849"];
7619 [label="var parent = ContainingNamespace; 356850"];
7620 [label=".IsGlobalNamespace 356851"];
7621 [label="get\n            {\n                return false;\n            } 356852"];
7622 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 356853"];
7623 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 356854"];
7624 [label="parent.Name 356855"];
7625 [label="get\n            {\n                return _name;\n            } 356856"];
7626 [label="length += parent.Name.Length + 1; 356857"];
7627 [label="length += parent.Name.Length + 1; 356858"];
7628 [label="parent.ContainingNamespace 356859"];
7629 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 356860"];
7630 [label="parent = parent.ContainingNamespace; 356861"];
7631 [label="get\n            {\n                return true;\n            } 356862"];
7632 [label="_containingNamespaceSymbol 356863"];
7633 [label="_name 356864"];
7634 [label="_typesByNS 356865"];
7635 [label="Debug.Assert(name != null); 356866"];
7636 [label="Debug.Assert((object)containingNamespace != null); 356867"];
7637 [label="Debug.Assert(typesByNS != null); 356868"];
7638 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 356869"];
7639 [label="genericParameterHandles 356870"];
7640 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 356871"];
7641 [label="param GetGenericInfo(out ushort arity) 356872"];
7642 [label="param GetGenericInfo(out BadImageFormatException mrEx) 356873"];
7643 [label="mrEx = null; 356874"];
7644 [label="PENamedTypeSymbol result; 356875"];
7645 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 356876"];
7646 [label="mangleName 356877"];
7647 [label="param PENamedTypeSymbol(out bool mangleName) 356878"];
7648 [label="_lazyTupleData 356879"];
7649 [label="_container 356880"];
7650 [label="_name 356881"];
7651 [label="_flags 356882"];
7652 [label="_corTypeId 356883"];
7653 [label="Debug.Assert(!handle.IsNil); 356884"];
7654 [label="Debug.Assert((object)container != null); 356885"];
7655 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 356886"];
7656 [label="string metadataName; 356887"];
7657 [label="bool makeBad = false; 356888"];
7658 [label="mangleName = false; 356889"];
7659 [label="Accessibility access = Accessibility.Private; 356890"];
7660 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 356891"];
7661 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 356892"];
7662 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 356893"];
7663 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 356894"];
7664 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 356895"];
7665 [label="bool added; 356896"];
7666 [label="Debug.Assert(added); 356897"];
7667 [label="Debug.Assert(typeId != SpecialType.None); 356898"];
7668 [label="corType.ContainingAssembly 356899"];
7669 [label="get\n            {\n                return _container;\n            } 356900"];
7670 [label="return _container; 356901"];
7671 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 356902"];
7672 [label="ContainingPEModule 356903"];
7673 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356904"];
7674 [label="return ContainingPEModule.ContainingAssembly; 356905"];
7675 [label="ContainingPEModule.ContainingAssembly 356906"];
7676 [label="get\n            {\n                return _assemblySymbol;\n            } 356907"];
7677 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 356908"];
7678 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 356909"];
7679 [label="corType.ContainingModule 356910"];
7680 [label="get\n            {\n                return ContainingPEModule;\n            } 356911"];
7681 [label="ContainingPEModule 356912"];
7682 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 356913"];
7683 [label="Symbol s = _container; 356914"];
7684 [label="s.Kind 356915"];
7685 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 356916"];
7686 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 356917"];
7687 [label="((PENamespaceSymbol)s).ContainingPEModule 356918"];
7688 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 356919"];
7689 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 356920"];
7690 [label="return ContainingPEModule; 356921"];
7691 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 356922"];
7692 [label="corType.ContainingModule.Ordinal 356923"];
7693 [label="get\n            {\n                return _ordinal;\n            } 356924"];
7694 [label="return _ordinal; 356925"];
7695 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 356926"];
7696 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 356927"];
7697 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 356928"];
7698 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 356929"];
7699 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 356930"];
7700 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 356931"];
7701 [label="if ((object)scope == null)\n                {\n                    break;\n                } 356932"];
7702 [label="Debug.Assert(!emittedTypeName.IsNull); 356933"];
7703 [label="scope.Kind 356934"];
7704 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 356935"];
7705 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 356936"];
7706 [label="NamedTypeSymbol? namedType = null; 356937"];
7707 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 356938"];
7708 [label="namespaceOrTypeMembers 356939"];
7709 [label="scope.IsNamespace 356940"];
7710 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 356941"];
7711 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 356942"];
7712 [label="bool isTopLevel = scope.IsNamespace; 356943"];
7713 [label="param NamespaceOrTypeSymbol(this) 356944"];
7714 [label="param Symbol(this) 356945"];
7715 [label="_underlying 356946"];
7716 [label="Debug.Assert(underlying is object); 356947"];
7717 [label="param ToDisplayParts(bool minimal) 356948"];
7718 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 356949"];
7719 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 356950"];
7720 [label="Debug.Assert(semanticModelOpt == null); 356951"];
7721 [label="Debug.Assert(positionOpt < 0); 356952"];
7722 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 356953"];
7723 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 356954"];
7724 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 356955"];
7725 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 356956"];
7726 [label="return (TISymbol?)symbol?.ISymbol; 356957"];
7727 [label="var containingNamespace = symbol.ContainingNamespace; 356958"];
7728 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 356959"];
7729 [label="ShouldVisitNamespace(containingNamespace) 356960"];
7730 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 356961"];
7731 [label="param ShouldVisitNamespace(this) 356962"];
7732 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 356963"];
7733 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 356964"];
7734 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 356965"];
7735 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 356966"];
7736 [label="namespaceSymbol.IsGlobalNamespace 356967"];
7737 [label="=> _underlying.IsGlobalNamespace 356968"];
7738 [label="get\n            {\n                return false;\n            } 356969"];
7739 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 356970"];
7740 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 356971"];
7741 [label="containingNamespace.Accept(this.NotFirstVisitor); 356972"];
7742 [label="this.NotFirstVisitor 356973"];
7743 [label="param MakeNotFirstVisitor(bool inNamespaceOrType = false) 356974"];
7744 [label="param MakeNotFirstVisitor(this) 356975"];
7745 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 356976"];
7746 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 356977"];
7747 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 356978"];
7748 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 356979"];
7749 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 356980"];
7750 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 356981"];
7751 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 356982"];
7752 [label="param SymbolDisplayVisitor(int positionOpt) 356983"];
7753 [label="param SymbolDisplayVisitor(bool escapeKeywordIdentifiers) 356984"];
7754 [label="param SymbolDisplayVisitor(IDictionary<INamespaceOrTypeSymbol, IAliasSymbol> aliasMap) 356985"];
7755 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 356986"];
7756 [label="param SymbolDisplayVisitor(bool inNamespaceOrType = false) 356987"];
7757 [label="param SymbolDisplayVisitor(this) 356988"];
7758 [label="builder 356989"];
7759 [label="format 356990"];
7760 [label="isFirstSymbolVisited 356991"];
7761 [label="semanticModelOpt 356992"];
7762 [label="positionOpt 356993"];
7763 [label="inNamespaceOrType 356994"];
7764 [label="param SymbolDisplayVisitor(this) 356995"];
7765 [label="param SymbolDisplayVisitor(this) 356996"];
7766 [label="_escapeKeywordIdentifiers 356997"];
7767 [label="_lazyAliasMap 356998"];
7768 [label="containingNamespace.Accept(this.NotFirstVisitor); 356999"];
7769 [label="containingNamespace.Accept(this.NotFirstVisitor); 357000"];
7770 [label="containingNamespace.Accept(this.NotFirstVisitor) 357001"];
7771 [label="param Accept(SymbolVisitor visitor) 357002"];
7772 [label="param Accept(this) 357003"];
7773 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 357004"];
7774 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 357005"];
7775 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 357006"];
7776 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 357007"];
7777 [label="param ShouldVisitNamespace(this) 357008"];
7778 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 357009"];
7779 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 357010"];
7780 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 357011"];
7781 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 357012"];
7782 [label="=> _underlying.IsGlobalNamespace 357013"];
7783 [label="get\n            {\n                return false;\n            } 357014"];
7784 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 357015"];
7785 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 357016"];
7786 [label="get\n            {\n                return true;\n            } 357017"];
7787 [label="=> _underlying.IsGlobalNamespace 357018"];
7788 [label="get\n            {\n                return false;\n            } 357019"];
7789 [label="containingNamespace.IsGlobalNamespace 357020"];
7790 [label="=> _underlying.IsGlobalNamespace 357021"];
7791 [label="get\n            {\n                return false;\n            } 357022"];
7792 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 357023"];
7793 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 357024"];
7794 [label="param AddPunctuation(SyntaxKind punctuationKind) 357025"];
7795 [label="param AddPunctuation(this) 357026"];
7796 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 357027"];
7797 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 357028"];
7798 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 357029"];
7799 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 357030"];
7800 [label="param CreatePart(SymbolDisplayPartKind kind) 357031"];
7801 [label="param CreatePart(ISymbol symbol) 357032"];
7802 [label="param CreatePart(string text) 357033"];
7803 [label="param CreatePart(this) 357034"];
7804 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 357035"];
7805 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 357036"];
7806 [label="=> _underlying.IsGlobalNamespace 357037"];
7807 [label="get\n            {\n                return false;\n            } 357038"];
7808 [label="containingNamespace.Accept(this.NotFirstVisitor); 357039"];
7809 [label="containingNamespace.IsGlobalNamespace 357040"];
7810 [label="=> _underlying.IsGlobalNamespace 357041"];
7811 [label="get\n            {\n                return false;\n            } 357042"];
7812 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 357043"];
7813 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 357044"];
7814 [label="param AddPunctuation(SyntaxKind punctuationKind) 357045"];
7815 [label="param AddPunctuation(this) 357046"];
7816 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 357047"];
7817 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 357048"];
7818 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 357049"];
7819 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 357050"];
7820 [label="param CreatePart(SymbolDisplayPartKind kind) 357051"];
7821 [label="param CreatePart(ISymbol symbol) 357052"];
7822 [label="param CreatePart(string text) 357053"];
7823 [label="param CreatePart(this) 357054"];
7824 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 357055"];
7825 [label="=> _underlying.IsGlobalNamespace 357056"];
7826 [label="get\n            {\n                return false;\n            } 357057"];
7827 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 357058"];
7828 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 357059"];
7829 [label="Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0); 357060"];
7830 [label="Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0); 357061"];
7831 [label="if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                } 357062"];
7832 [label="namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName); 357063"];
7833 [label="scope.GetTypeMembers(emittedTypeName.UnmangledTypeName) 357064"];
7834 [label="param GetTypeMembers(string name) 357065"];
7835 [label="var typesByNS = _typesByNS; 357066"];
7836 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 357067"];
7837 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 357068"];
7838 [label="Debug.Assert(typesByNS != null); 357069"];
7839 [label="get\n            {\n                return false;\n            } 357070"];
7840 [label="parent.ContainingNamespace 357071"];
7841 [label="parent = parent.ContainingNamespace; 357072"];
7842 [label="get\n            {\n                return false;\n            } 357073"];
7843 [label="get\n            {\n                return true;\n            } 357074"];
7844 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 357075"];
7845 [label="genericParameterHandles 357076"];
7846 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 357077"];
7847 [label="param GetGenericInfo(out ushort arity) 357078"];
7848 [label="param GetGenericInfo(out BadImageFormatException mrEx) 357079"];
7849 [label="mrEx = null; 357080"];
7850 [label="PENamedTypeSymbol result; 357081"];
7851 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 357082"];
7852 [label="mangleName 357083"];
7853 [label="param PENamedTypeSymbol(out bool mangleName) 357084"];
7854 [label="_lazyTupleData 357085"];
7855 [label="_container 357086"];
7856 [label="_name 357087"];
7857 [label="_flags 357088"];
7858 [label="_corTypeId 357089"];
7859 [label="Debug.Assert(!handle.IsNil); 357090"];
7860 [label="Debug.Assert((object)container != null); 357091"];
7861 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 357092"];
7862 [label="string metadataName; 357093"];
7863 [label="bool makeBad = false; 357094"];
7864 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 357095"];
7865 [label="Accessibility access = Accessibility.Private; 357096"];
7866 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 357097"];
7867 [label="_arity 357098"];
7868 [label="_mangleName 357099"];
7869 [label="Debug.Assert(genericParameterHandles.Count > 0); 357100"];
7870 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 357101"];
7871 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 357102"];
7872 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 357103"];
7873 [label="mangleName 357104"];
7874 [label="param PENamedTypeSymbol(out bool mangleName) 357105"];
7875 [label="mangleName = false; 357106"];
7876 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 357107"];
7877 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 357108"];
7878 [label="bool added; 357109"];
7879 [label="Debug.Assert(added); 357110"];
7880 [label="Debug.Assert(typeId != SpecialType.None); 357111"];
7881 [label="corType.ContainingAssembly 357112"];
7882 [label="get\n            {\n                return _container;\n            } 357113"];
7883 [label="return _container; 357114"];
7884 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 357115"];
7885 [label="ContainingPEModule 357116"];
7886 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 357117"];
7887 [label="return ContainingPEModule.ContainingAssembly; 357118"];
7888 [label="ContainingPEModule.ContainingAssembly 357119"];
7889 [label="get\n            {\n                return _assemblySymbol;\n            } 357120"];
7890 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 357121"];
7891 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 357122"];
7892 [label="corType.ContainingModule 357123"];
7893 [label="get\n            {\n                return ContainingPEModule;\n            } 357124"];
7894 [label="ContainingPEModule 357125"];
7895 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 357126"];
7896 [label="Symbol s = _container; 357127"];
7897 [label="s.Kind 357128"];
7898 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 357129"];
7899 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 357130"];
7900 [label="((PENamespaceSymbol)s).ContainingPEModule 357131"];
7901 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 357132"];
7902 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 357133"];
7903 [label="return ContainingPEModule; 357134"];
7904 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 357135"];
7905 [label="corType.ContainingModule.Ordinal 357136"];
7906 [label="get\n            {\n                return _ordinal;\n            } 357137"];
7907 [label="return _ordinal; 357138"];
7908 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 357139"];
7909 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 357140"];
7910 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 357141"];
7911 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 357142"];
7912 [label="EnsureAllMembersLoaded(); 357143"];
7913 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 357144"];
7914 [label="foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    } 357145"];
7915 [label="named.Arity 357146"];
7916 [label="get\n                {\n                    return _arity;\n                } 357147"];
7917 [label="return _arity; 357148"];
7918 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 357149"];
7919 [label="named.MangleName 357150"];
7920 [label="get\n                {\n                    return _mangleName;\n                } 357151"];
7921 [label="return _mangleName; 357152"];
7922 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 357153"];
7923 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 357154"];
7924 [label="if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            } 357155"];
7925 [label="if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            } 357156"];
7926 [label="namedType = named; 357157"];
7927 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 357158"];
7928 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 357159"];
7929 [label="Debug.Assert((object)result != null); 357160"];
7930 [label="Debug.Assert((object)result != null); 357161"];
7931 [label="result.Kind 357162"];
7932 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 357163"];
7933 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 357164"];
7934 [label="result.DeclaredAccessibility 357165"];
7935 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 357166"];
7936 [label="Accessibility access = Accessibility.Private; 357167"];
7937 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 357168"];
7938 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 357169"];
7939 [label="Debug.Assert(typeId != SpecialType.None); 357170"];
7940 [label="corType.ContainingAssembly 357171"];
7941 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 357172"];
7942 [label="get\n            {\n                return _container;\n            } 357173"];
7943 [label="return _container; 357174"];
7944 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 357175"];
7945 [label="ContainingPEModule 357176"];
7946 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 357177"];
7947 [label="return ContainingPEModule.ContainingAssembly; 357178"];
7948 [label="ContainingPEModule.ContainingAssembly 357179"];
7949 [label="get\n            {\n                return _assemblySymbol;\n            } 357180"];
7950 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 357181"];
7951 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 357182"];
7952 [label="corType.ContainingModule 357183"];
7953 [label="get\n            {\n                return ContainingPEModule;\n            } 357184"];
7954 [label="ContainingPEModule 357185"];
7955 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 357186"];
7956 [label="Symbol s = _container; 357187"];
7957 [label="s.Kind 357188"];
7958 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 357189"];
7959 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 357190"];
7960 [label="((PENamespaceSymbol)s).ContainingPEModule 357191"];
7961 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 357192"];
7962 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 357193"];
7963 [label="return ContainingPEModule; 357194"];
7964 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 357195"];
7965 [label="corType.ContainingModule.Ordinal 357196"];
7966 [label="get\n            {\n                return _ordinal;\n            } 357197"];
7967 [label="return _ordinal; 357198"];
7968 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 357199"];
7969 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 357200"];
7970 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 357201"];
7971 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 357202"];
7972 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 357203"];
7973 [label="return _lazySpecialTypes[(int)type]; 357204"];
7974 [label="if (!iListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 357205"];
7975 [label="iListOfT.IsErrorType() 357206"];
7976 [label="param IsErrorType(this TypeSymbol type) 357207"];
7977 [label="RoslynDebug.Assert((object)type != null); 357208"];
7978 [label="RoslynDebug.Assert((object)type != null); 357209"];
7979 [label="type.Kind 357210"];
7980 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 357211"];
7981 [label="return type.Kind == SymbolKind.ErrorType; 357212"];
7982 [label="if (!iListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 357213"];
7983 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 357214"];
7984 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 357215"];
7985 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 357216"];
7986 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 357217"];
7987 [label="new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations)) 357218"];
7988 [label="param ConstructedNamedTypeSymbol(NamedTypeSymbol constructedFrom) 357219"];
7989 [label="param ConstructedNamedTypeSymbol(ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations) 357220"];
7990 [label="param ConstructedNamedTypeSymbol(bool unbound = false) 357221"];
7991 [label="param ConstructedNamedTypeSymbol(TupleExtraData tupleData = null) 357222"];
7992 [label="param ConstructedNamedTypeSymbol(this) 357223"];
7993 [label="constructedFrom.ContainingSymbol 357224"];
7994 [label="get\n            {\n                return _container;\n            } 357225"];
7995 [label="return _container; 357226"];
7996 [label="constructedFrom.ContainingType 357227"];
7997 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 357228"];
7998 [label="return _container as NamedTypeSymbol; 357229"];
7999 [label="constructedFrom.OriginalDefinition 357230"];
8000 [label="get\n            {\n                return this;\n            } 357231"];
8001 [label="constructedFrom.OriginalDefinition.TypeParameters 357232"];
8002 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 357233"];
8003 [label="EnsureTypeParametersAreLoaded() 357234"];
8004 [label="param EnsureTypeParametersAreLoaded(this) 357235"];
8005 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 357236"];
8006 [label="ContainingPEModule 357237"];
8007 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 357238"];
8008 [label="Symbol s = _container; 357239"];
8009 [label="s.Kind 357240"];
8010 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 357241"];
8011 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 357242"];
8012 [label="((PENamespaceSymbol)s).ContainingPEModule 357243"];
8013 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 357244"];
8014 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 357245"];
8015 [label="var moduleSymbol = ContainingPEModule; 357246"];
8016 [label="int firstIndex = _genericParameterHandles.Count - _arity; 357247"];
8017 [label="TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity]; 357248"];
8018 [label="for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    } 357249"];
8019 [label="for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    } 357250"];
8020 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 357251"];
8021 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 357252"];
8022 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 357253"];
8023 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 357254"];
8024 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 357255"];
8025 [label="new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]) 357256"];
8026 [label="param PETypeParameterSymbol(PEModuleSymbol moduleSymbol) 357257"];
8027 [label="param PETypeParameterSymbol(PENamedTypeSymbol definingNamedType) 357258"];
8028 [label="param PETypeParameterSymbol(ushort ordinal) 357259"];
8029 [label="param PETypeParameterSymbol(GenericParameterHandle handle) 357260"];
8030 [label="param PETypeParameterSymbol(this) 357261"];
8031 [label="moduleSymbol 357262"];
8032 [label="definingNamedType 357263"];
8033 [label="ordinal 357264"];
8034 [label="handle 357265"];
8035 [label="param PETypeParameterSymbol(this) 357266"];
8036 [label="param PETypeParameterSymbol(PEModuleSymbol moduleSymbol) 357267"];
8037 [label="param PETypeParameterSymbol(Symbol definingSymbol) 357268"];
8038 [label="param PETypeParameterSymbol(ushort ordinal) 357269"];
8039 [label="param PETypeParameterSymbol(GenericParameterHandle handle) 357270"];
8040 [label="param PETypeParameterSymbol(this) 357271"];
8041 [label="param PETypeParameterSymbol(this) 357272"];
8042 [label="param TypeParameterSymbol(this) 357273"];
8043 [label="param TypeParameterSymbol(this) 357274"];
8044 [label="_lazyAdapter 357275"];
8045 [label="_containingSymbol 357276"];
8046 [label="_name 357277"];
8047 [label="_ordinal 357278"];
8048 [label="_lazyConstraintsUseSiteErrorInfo = CSDiagnosticInfo.EmptyErrorInfo 357279"];
8049 [label="_flags 357280"];
8050 [label="_lazyHasIsUnmanagedConstraint 357281"];
8051 [label="new TypeParameterBounds() 357282"];
8052 [label="param TypeParameterBounds(this) 357283"];
8053 [label="EffectiveBaseClass 357284"];
8054 [label="DeducedBaseType 357285"];
8055 [label="EffectiveBaseClass = null!; 357286"];
8056 [label="EffectiveBaseClass 357287"];
8057 [label="DeducedBaseType = null!; 357288"];
8058 [label="DeducedBaseType 357289"];
8059 [label="Unset = new TypeParameterBounds() 357290"];
8060 [label="_lazyBounds = TypeParameterBounds.Unset 357291"];
8061 [label="Debug.Assert((object)moduleSymbol != null); 357292"];
8062 [label="Debug.Assert((object)moduleSymbol != null); 357293"];
8063 [label="Debug.Assert((object)definingSymbol != null); 357294"];
8064 [label="Debug.Assert((object)definingSymbol != null); 357295"];
8065 [label="Debug.Assert(ordinal >= 0); 357296"];
8066 [label="Debug.Assert(ordinal >= 0); 357297"];
8067 [label="Debug.Assert(!handle.IsNil); 357298"];
8068 [label="_containingSymbol 357299"];
8069 [label="GenericParameterAttributes flags = 0; 357300"];
8070 [label="moduleSymbol.Module 357301"];
8071 [label="get\n            {\n                return _module;\n            } 357302"];
8072 [label="return _module; 357303"];
8073 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 357304"];
8074 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 357305"];
8075 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 357306"];
8076 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 357307"];
8077 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 357308"];
8078 [label="_flags = ((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) ? flags : (flags & ~GenericParameterAttributes.DefaultConstructorConstraint); 357309"];
8079 [label="_flags = ((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) ? flags : (flags & ~GenericParameterAttributes.DefaultConstructorConstraint); 357310"];
8080 [label="((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) 357311"];
8081 [label="_flags 357312"];
8082 [label="_ordinal 357313"];
8083 [label="_handle 357314"];
8084 [label="ownedParams[i] 357315"];
8085 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 357316"];
8086 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 357317"];
8087 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 357318"];
8088 [label="EnsureTypeParametersAreLoaded(); 357319"];
8089 [label="return _lazyTypeParameters; 357320"];
8090 [label="t => t.Type 357321"];
8091 [label="AsTypeSymbol = t => t.Type 357322"];
8092 [label="ReferenceEqualityComparer.Instance 357323"];
8093 [label="new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance) 357324"];
8094 [label="s_emptyDictionary =\n            new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance) 357325"];
8095 [label="new TypeMap() 357326"];
8096 [label="param TypeMap(this) 357327"];
8097 [label="s_emptyDictionary 357328"];
8098 [label="param AbstractTypeParameterMap(SmallDictionary<TypeParameterSymbol, TypeWithAnnotations> mapping) 357329"];
8099 [label="param AbstractTypeParameterMap(this) 357330"];
8100 [label="param AbstractTypeMap(this) 357331"];
8101 [label="Mapping 357332"];
8102 [label="this.Mapping 357333"];
8103 [label="Debug.Assert(s_emptyDictionary.IsEmpty()); 357334"];
8104 [label="s_emptyTypeMap = new TypeMap() 357335"];
8105 [label="typeArgumentsWithAnnotations 357336"];
8106 [label="new TypeMap(constructedFrom.ContainingType, constructedFrom.OriginalDefinition.TypeParameters, typeArgumentsWithAnnotations) 357337"];
8107 [label="param TypeMap(NamedTypeSymbol containingType) 357338"];
8108 [label="param TypeMap(ImmutableArray<TypeParameterSymbol> typeParameters) 357339"];
8109 [label="param TypeMap(ImmutableArray<TypeWithAnnotations> typeArguments) 357340"];
8110 [label="param TypeMap(this) 357341"];
8111 [label="containingType 357342"];
8112 [label="ForType(containingType) 357343"];
8113 [label="param ForType(NamedTypeSymbol containingType) 357344"];
8114 [label="var substituted = containingType as SubstitutedNamedTypeSymbol; 357345"];
8115 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 357346"];
8116 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 357347"];
8117 [label="(object)substituted != null 357348"];
8118 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 357349"];
8119 [label="param AbstractTypeParameterMap(SmallDictionary<TypeParameterSymbol, TypeWithAnnotations> mapping) 357350"];
8120 [label="param AbstractTypeParameterMap(this) 357351"];
8121 [label="param AbstractTypeMap(this) 357352"];
8122 [label="Mapping 357353"];
8123 [label="this.Mapping 357354"];
8124 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 357355"];
8125 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 357356"];
8126 [label="TypeParameterSymbol tp = typeParameters[i]; 357357"];
8127 [label="TypeWithAnnotations ta = typeArguments[i]; 357358"];
8128 [label="if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                } 357359"];
8129 [label="ta.Is(tp) 357360"];
8130 [label="param Is(TypeParameterSymbol other) 357361"];
8131 [label="param Is(this) 357362"];
8132 [label="1 357363"];
8133 [label="NotAnnotatedAttributeValue = 1 357364"];
8134 [label="2 357365"];
8135 [label="AnnotatedAttributeValue = 2 357366"];
8136 [label="0 357367"];
8137 [label="ObliviousAttributeValue = 0 357368"];
8138 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 357369"];
8139 [label="NullableAnnotation.IsOblivious() 357370"];
8140 [label="param IsOblivious(this NullableAnnotation annotation) 357371"];
8141 [label="annotation == NullableAnnotation.Oblivious 357372"];
8142 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 357373"];
8143 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 357374"];
8144 [label="Mapping.Add(tp, ta); 357375"];
8145 [label="Mapping.Add(tp, ta); 357376"];
8146 [label="Mapping.Add(tp, ta); 357377"];
8147 [label="constructedFrom.OriginalDefinition 357378"];
8148 [label="get\n            {\n                return this;\n            } 357379"];
8149 [label="s_symbolAsMemberFunc = SymbolExtensions.SymbolAsMember 357380"];
8150 [label="constructedFrom 357381"];
8151 [label="unbound 357382"];
8152 [label="tupleData 357383"];
8153 [label="param ConstructedNamedTypeSymbol(this) 357384"];
8154 [label="param SubstitutedNamedTypeSymbol(Symbol newContainer) 357385"];
8155 [label="param SubstitutedNamedTypeSymbol(TypeMap map) 357386"];
8156 [label="param SubstitutedNamedTypeSymbol(NamedTypeSymbol originalDefinition) 357387"];
8157 [label="param SubstitutedNamedTypeSymbol(NamedTypeSymbol constructedFrom = null) 357388"];
8158 [label="param SubstitutedNamedTypeSymbol(bool unbound = false) 357389"];
8159 [label="param SubstitutedNamedTypeSymbol(TupleExtraData tupleData = null) 357390"];
8160 [label="param SubstitutedNamedTypeSymbol(this) 357391"];
8161 [label="originalDefinition 357392"];
8162 [label="tupleData 357393"];
8163 [label="param SubstitutedNamedTypeSymbol(this) 357394"];
8164 [label="param WrappedNamedTypeSymbol(NamedTypeSymbol underlyingType) 357395"];
8165 [label="param WrappedNamedTypeSymbol(TupleExtraData tupleData) 357396"];
8166 [label="param WrappedNamedTypeSymbol(this) 357397"];
8167 [label="tupleData 357398"];
8168 [label="param WrappedNamedTypeSymbol(this) 357399"];
8169 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 357400"];
8170 [label="_lazyTupleData 357401"];
8171 [label="_underlyingType 357402"];
8172 [label="Debug.Assert((object)underlyingType != null); 357403"];
8173 [label="Debug.Assert((object)underlyingType != null); 357404"];
8174 [label="_underlyingType 357405"];
8175 [label="_unbound 357406"];
8176 [label="_inputMap 357407"];
8177 [label="_newContainer 357408"];
8178 [label="_lazyMap 357409"];
8179 [label="_hashCode 357410"];
8180 [label="_lazyMembersByNameCache 357411"];
8181 [label="originalDefinition.IsDefinition 357412"];
8182 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 357413"];
8183 [label="OriginalDefinition 357414"];
8184 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 357415"];
8185 [label="OriginalSymbolDefinition 357416"];
8186 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 357417"];
8187 [label="this.OriginalTypeSymbolDefinition 357418"];
8188 [label="get\n            {\n                return this.OriginalDefinition;\n            } 357419"];
8189 [label="this.OriginalDefinition 357420"];
8190 [label="get\n            {\n                return this;\n            } 357421"];
8191 [label="return this.OriginalDefinition; 357422"];
8192 [label="return this.OriginalTypeSymbolDefinition; 357423"];
8193 [label="return OriginalSymbolDefinition; 357424"];
8194 [label="return (object)this == (object)OriginalDefinition; 357425"];
8195 [label="Debug.Assert(originalDefinition.IsDefinition); 357426"];
8196 [label="Debug.Assert(!originalDefinition.IsErrorType()); 357427"];
8197 [label="originalDefinition.IsErrorType() 357428"];
8198 [label="param IsErrorType(this TypeSymbol type) 357429"];
8199 [label="RoslynDebug.Assert((object)type != null); 357430"];
8200 [label="RoslynDebug.Assert((object)type != null); 357431"];
8201 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 357432"];
8202 [label="Debug.Assert(!originalDefinition.IsErrorType()); 357433"];
8203 [label="_newContainer 357434"];
8204 [label="_inputMap 357435"];
8205 [label="_unbound 357436"];
8206 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 357437"];
8207 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 357438"];
8208 [label="constructedFrom.ConstructedFrom 357439"];
8209 [label="get\n            {\n                return this;\n            } 357440"];
8210 [label="return this; 357441"];
8211 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 357442"];
8212 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 357443"];
8213 [label="constructedFrom.TypeParameters 357444"];
8214 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 357445"];
8215 [label="EnsureTypeParametersAreLoaded() 357446"];
8216 [label="param EnsureTypeParametersAreLoaded(this) 357447"];
8217 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 357448"];
8218 [label="EnsureTypeParametersAreLoaded(); 357449"];
8219 [label="return _lazyTypeParameters; 357450"];
8220 [label="_lazyTypeParameters = constructedFrom.TypeParameters; 357451"];
8221 [label="_lazyTypeParameters 357452"];
8222 [label="_lazyMap 357453"];
8223 [label="_constructedFrom 357454"];
8224 [label="_typeArgumentsWithAnnotations 357455"];
8225 [label="_constructedFrom 357456"];
8226 [label="constructedFrom.Arity 357457"];
8227 [label="get\n                {\n                    return _arity;\n                } 357458"];
8228 [label="return _arity; 357459"];
8229 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 357460"];
8230 [label="constructedFrom.Arity 357461"];
8231 [label="get\n                {\n                    return _arity;\n                } 357462"];
8232 [label="return _arity; 357463"];
8233 [label="Debug.Assert(constructedFrom.Arity != 0); 357464"];
8234 [label="Debug.Assert(constructedFrom.Arity != 0); 357465"];
8235 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 357466"];
8236 [label="var iReadOnlyListOfT = declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IReadOnlyList_T); 357467"];
8237 [label="declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IReadOnlyList_T) 357468"];
8238 [label="param GetSpecialType(SpecialType type) 357469"];
8239 [label="param GetSpecialType(this) 357470"];
8240 [label="CorLibrary 357471"];
8241 [label="get\n            {\n                return _corLibrary;\n            } 357472"];
8242 [label="return _corLibrary; 357473"];
8243 [label="return CorLibrary.GetDeclaredSpecialType(type); 357474"];
8244 [label="CorLibrary.GetDeclaredSpecialType(type) 357475"];
8245 [label="param GetDeclaredSpecialType(SpecialType type) 357476"];
8246 [label="this.Modules 357477"];
8247 [label="get\n            {\n                return _modules;\n            } 357478"];
8248 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 357479"];
8249 [label="module.GetReferencedAssemblies() 357480"];
8250 [label="param GetReferencedAssemblies(this) 357481"];
8251 [label="AssertReferencesInitialized() 357482"];
8252 [label="param AssertReferencesInitialized(this) 357483"];
8253 [label="Debug.Assert(_moduleReferences != null); 357484"];
8254 [label="Debug.Assert(_moduleReferences != null); 357485"];
8255 [label="AssertReferencesInitialized(); 357486"];
8256 [label="return _moduleReferences.Identities; 357487"];
8257 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 357488"];
8258 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 357489"];
8259 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 357490"];
8260 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 357491"];
8261 [label="return _lazySpecialTypes[(int)type]; 357492"];
8262 [label="if (!iReadOnlyListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 357493"];
8263 [label="iReadOnlyListOfT.IsErrorType() 357494"];
8264 [label="param IsErrorType(this TypeSymbol type) 357495"];
8265 [label="RoslynDebug.Assert((object)type != null); 357496"];
8266 [label="RoslynDebug.Assert((object)type != null); 357497"];
8267 [label="type.Kind 357498"];
8268 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 357499"];
8269 [label="return type.Kind == SymbolKind.ErrorType; 357500"];
8270 [label="if (!iReadOnlyListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 357501"];
8271 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 357502"];
8272 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 357503"];
8273 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 357504"];
8274 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 357505"];
8275 [label="new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)) 357506"];
8276 [label="param ConstructedNamedTypeSymbol(NamedTypeSymbol constructedFrom) 357507"];
8277 [label="param ConstructedNamedTypeSymbol(ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations) 357508"];
8278 [label="param ConstructedNamedTypeSymbol(bool unbound = false) 357509"];
8279 [label="param ConstructedNamedTypeSymbol(TupleExtraData tupleData = null) 357510"];
8280 [label="param ConstructedNamedTypeSymbol(this) 357511"];
8281 [label="constructedFrom.ContainingSymbol 357512"];
8282 [label="constructedFrom.ContainingType 357513"];
8283 [label="constructedFrom.OriginalDefinition 357514"];
8284 [label="constructedFrom.OriginalDefinition.TypeParameters 357515"];
8285 [label="EnsureTypeParametersAreLoaded() 357516"];
8286 [label="s.Kind 357517"];
8287 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 357518"];
8288 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 357519"];
8289 [label="_containingSymbol 357520"];
8290 [label="_ordinal 357521"];
8291 [label="_flags 357522"];
8292 [label="Debug.Assert((object)moduleSymbol != null); 357523"];
8293 [label="Debug.Assert((object)definingSymbol != null); 357524"];
8294 [label="Debug.Assert(ordinal >= 0); 357525"];
8295 [label="Debug.Assert(!handle.IsNil); 357526"];
8296 [label="EnsureTypeParametersAreLoaded(); 357527"];
8297 [label="new TypeMap(constructedFrom.ContainingType, constructedFrom.OriginalDefinition.TypeParameters, typeArgumentsWithAnnotations) 357528"];
8298 [label="param TypeMap(this) 357529"];
8299 [label="ForType(containingType) 357530"];
8300 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 357531"];
8301 [label="param AbstractTypeParameterMap(this) 357532"];
8302 [label="param AbstractTypeMap(this) 357533"];
8303 [label="Mapping 357534"];
8304 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 357535"];
8305 [label="constructedFrom.OriginalDefinition 357536"];
8306 [label="unbound 357537"];
8307 [label="tupleData 357538"];
8308 [label="param ConstructedNamedTypeSymbol(this) 357539"];
8309 [label="param SubstitutedNamedTypeSymbol(TypeMap map) 357540"];
8310 [label="param SubstitutedNamedTypeSymbol(bool unbound = false) 357541"];
8311 [label="param SubstitutedNamedTypeSymbol(TupleExtraData tupleData = null) 357542"];
8312 [label="param SubstitutedNamedTypeSymbol(this) 357543"];
8313 [label="tupleData 357544"];
8314 [label="param SubstitutedNamedTypeSymbol(this) 357545"];
8315 [label="param WrappedNamedTypeSymbol(TupleExtraData tupleData) 357546"];
8316 [label="param WrappedNamedTypeSymbol(this) 357547"];
8317 [label="tupleData 357548"];
8318 [label="param WrappedNamedTypeSymbol(this) 357549"];
8319 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 357550"];
8320 [label="_lazyTupleData 357551"];
8321 [label="_underlyingType 357552"];
8322 [label="Debug.Assert((object)underlyingType != null); 357553"];
8323 [label="Debug.Assert((object)underlyingType != null); 357554"];
8324 [label="_unbound 357555"];
8325 [label="_inputMap 357556"];
8326 [label="_newContainer 357557"];
8327 [label="_lazyMap 357558"];
8328 [label="_hashCode 357559"];
8329 [label="_lazyMembersByNameCache 357560"];
8330 [label="originalDefinition.IsDefinition 357561"];
8331 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 357562"];
8332 [label="OriginalDefinition 357563"];
8333 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 357564"];
8334 [label="OriginalSymbolDefinition 357565"];
8335 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 357566"];
8336 [label="this.OriginalTypeSymbolDefinition 357567"];
8337 [label="get\n            {\n                return this.OriginalDefinition;\n            } 357568"];
8338 [label="this.OriginalDefinition 357569"];
8339 [label="get\n            {\n                return this;\n            } 357570"];
8340 [label="return this.OriginalDefinition; 357571"];
8341 [label="return this.OriginalTypeSymbolDefinition; 357572"];
8342 [label="return OriginalSymbolDefinition; 357573"];
8343 [label="return (object)this == (object)OriginalDefinition; 357574"];
8344 [label="Debug.Assert(originalDefinition.IsDefinition); 357575"];
8345 [label="Debug.Assert(!originalDefinition.IsErrorType()); 357576"];
8346 [label="originalDefinition.IsErrorType() 357577"];
8347 [label="param IsErrorType(this TypeSymbol type) 357578"];
8348 [label="RoslynDebug.Assert((object)type != null); 357579"];
8349 [label="RoslynDebug.Assert((object)type != null); 357580"];
8350 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 357581"];
8351 [label="Debug.Assert(!originalDefinition.IsErrorType()); 357582"];
8352 [label="_inputMap 357583"];
8353 [label="_unbound 357584"];
8354 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 357585"];
8355 [label="constructedFrom.ConstructedFrom 357586"];
8356 [label="get\n            {\n                return this;\n            } 357587"];
8357 [label="return this; 357588"];
8358 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 357589"];
8359 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 357590"];
8360 [label="EnsureTypeParametersAreLoaded(); 357591"];
8361 [label="_constructedFrom 357592"];
8362 [label="constructedFrom.Arity 357593"];
8363 [label="get\n                {\n                    return _arity;\n                } 357594"];
8364 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 357595"];
8365 [label="constructedFrom.Arity 357596"];
8366 [label="get\n                {\n                    return _arity;\n                } 357597"];
8367 [label="Debug.Assert(constructedFrom.Arity != 0); 357598"];
8368 [label="Debug.Assert(constructedFrom.Arity != 0); 357599"];
8369 [label="return constructedInterfaces.ToImmutableAndFree(); 357600"];
8370 [label="CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)) 357601"];
8371 [label="param CreateSZArray(TypeWithAnnotations elementTypeWithAnnotations) 357602"];
8372 [label="param CreateSZArray(NamedTypeSymbol array) 357603"];
8373 [label="param CreateSZArray(ImmutableArray<NamedTypeSymbol> constructedInterfaces) 357604"];
8374 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 357605"];
8375 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 357606"];
8376 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 357607"];
8377 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 357608"];
8378 [label="new SZArray(elementTypeWithAnnotations, array, constructedInterfaces) 357609"];
8379 [label="param SZArray(TypeWithAnnotations elementTypeWithAnnotations) 357610"];
8380 [label="param SZArray(NamedTypeSymbol array) 357611"];
8381 [label="param SZArray(ImmutableArray<NamedTypeSymbol> constructedInterfaces) 357612"];
8382 [label="param SZArray(this) 357613"];
8383 [label="elementTypeWithAnnotations 357614"];
8384 [label="array 357615"];
8385 [label="param SZArray(this) 357616"];
8386 [label="param ArrayTypeSymbol(TypeWithAnnotations elementTypeWithAnnotations) 357617"];
8387 [label="param ArrayTypeSymbol(NamedTypeSymbol array) 357618"];
8388 [label="param ArrayTypeSymbol(this) 357619"];
8389 [label="param ArrayTypeSymbol(this) 357620"];
8390 [label="_lazyAdapter 357621"];
8391 [label="_baseType 357622"];
8392 [label="elementTypeWithAnnotations.HasType 357623"];
8393 [label="=> !(DefaultType is null) 357624"];
8394 [label="DefaultType is null 357625"];
8395 [label="!(DefaultType is null) 357626"];
8396 [label="Debug.Assert(elementTypeWithAnnotations.HasType); 357627"];
8397 [label="RoslynDebug.Assert((object)array != null); 357628"];
8398 [label="RoslynDebug.Assert((object)array != null); 357629"];
8399 [label="_elementTypeWithAnnotations 357630"];
8400 [label="_baseType 357631"];
8401 [label="Debug.Assert(constructedInterfaces.Length <= 2); 357632"];
8402 [label="Debug.Assert(constructedInterfaces.Length <= 2); 357633"];
8403 [label="_interfaces 357634"];
8404 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 357635"];
8405 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 357636"];
8406 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 357637"];
8407 [label="AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken) 357638"];
8408 [label="param AreNullableAnnotationsEnabled(SyntaxToken token) 357639"];
8409 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 357640"];
8410 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 357641"];
8411 [label="TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array) 357642"];
8412 [label="param Create(bool isNullableEnabled) 357643"];
8413 [label="param Create(TypeSymbol typeSymbol) 357644"];
8414 [label="param Create(bool isAnnotated = false) 357645"];
8415 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 357646"];
8416 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 357647"];
8417 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 357648"];
8418 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 357649"];
8419 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 357650"];
8420 [label="typeSymbol.IsNullableType() 357651"];
8421 [label="param IsNullableType(this TypeSymbol type) 357652"];
8422 [label="type.OriginalDefinition 357653"];
8423 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 357654"];
8424 [label="OriginalTypeSymbolDefinition 357655"];
8425 [label="get\n            {\n                return this;\n            } 357656"];
8426 [label="return this; 357657"];
8427 [label="return OriginalTypeSymbolDefinition; 357658"];
8428 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 357659"];
8429 [label="type.OriginalDefinition.SpecialType 357660"];
8430 [label="get\n            {\n                return SpecialType.None;\n            } 357661"];
8431 [label="return SpecialType.None; 357662"];
8432 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 357663"];
8433 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 357664"];
8434 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 357665"];
8435 [label="var a1 = defaultType is null; 357666"];
8436 [label="!a1 357667"];
8437 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 357668"];
8438 [label="defaultType.IsNullableType() 357669"];
8439 [label="param IsNullableType(this TypeSymbol type) 357670"];
8440 [label="type.OriginalDefinition 357671"];
8441 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 357672"];
8442 [label="OriginalTypeSymbolDefinition 357673"];
8443 [label="get\n            {\n                return this;\n            } 357674"];
8444 [label="return this; 357675"];
8445 [label="return OriginalTypeSymbolDefinition; 357676"];
8446 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 357677"];
8447 [label="type.OriginalDefinition.SpecialType 357678"];
8448 [label="get\n            {\n                return SpecialType.None;\n            } 357679"];
8449 [label="return SpecialType.None; 357680"];
8450 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 357681"];
8451 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 357682"];
8452 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 357683"];
8453 [label="Debug.Assert(a1 || a2 != true || a3); 357684"];
8454 [label="Debug.Assert(a1 || a2 != true || a3); 357685"];
8455 [label="Debug.Assert(extensions != null); 357686"];
8456 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 357687"];
8457 [label="return type; 357688"];
8458 [label="param operator(TypeWithAnnotations typeWithAnnotations) 357689"];
8459 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 357690"];
8460 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 357691"];
8461 [label="new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations) 357692"];
8462 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations typeWithAnnotations) 357693"];
8463 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(this) 357694"];
8464 [label="typeWithAnnotations.HasType 357695"];
8465 [label="=> !(DefaultType is null) 357696"];
8466 [label="DefaultType is null 357697"];
8467 [label="!(DefaultType is null) 357698"];
8468 [label="Debug.Assert(typeWithAnnotations.HasType); 357699"];
8469 [label="_symbol = null; 357700"];
8470 [label="_symbol 357701"];
8471 [label="_isNullableEnabled = false; 357702"];
8472 [label="_isNullableEnabled 357703"];
8473 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 357704"];
8474 [label="symbol.IsType 357705"];
8475 [label="=> !_typeWithAnnotations.IsDefault 357706"];
8476 [label="_typeWithAnnotations.IsDefault 357707"];
8477 [label="DefaultType is null 357708"];
8478 [label="param ReportDiagnosticsIfObsolete(Binder binder) 357709"];
8479 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 357710"];
8480 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 357711"];
8481 [label="binder 357712"];
8482 [label="syntax 357713"];
8483 [label="diagnostics 357714"];
8484 [label="param ReportDiagnosticsIfObsolete(Binder binder) 357715"];
8485 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 357716"];
8486 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 357717"];
8487 [label="param ReportDiagnosticsIfObsolete(this) 357718"];
8488 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 357719"];
8489 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 357720"];
8490 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 357721"];
8491 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 357722"];
8492 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 357723"];
8493 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 357724"];
8494 [label="=> defaultType 357725"];
8495 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 357726"];
8496 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 357727"];
8497 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 357728"];
8498 [label="param ReportDiagnosticsIfObsolete(this) 357729"];
8499 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 357730"];
8500 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 357731"];
8501 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 357732"];
8502 [label="param ReportDiagnosticsIfObsolete(this) 357733"];
8503 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 357734"];
8504 [label="return SymbolKind.ArrayType; 357735"];
8505 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 357736"];
8506 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 357737"];
8507 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 357738"];
8508 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 357739"];
8509 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved) 357740"];
8510 [label="param UnwrapAlias(DiagnosticBag diagnostics) 357741"];
8511 [label="param UnwrapAlias(SyntaxNode syntax) 357742"];
8512 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 357743"];
8513 [label="param UnwrapAlias(this) 357744"];
8514 [label="symbol.IsAlias 357745"];
8515 [label="=> _symbol?.Kind == SymbolKind.Alias 357746"];
8516 [label="_symbol 357747"];
8517 [label="_symbol?.Kind == SymbolKind.Alias 357748"];
8518 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 357749"];
8519 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations 357750"];
8520 [label="baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type 357751"];
8521 [label="=> _extensions?.GetResolvedType(DefaultType) 357752"];
8522 [label=".GetResolvedType(DefaultType) 357753"];
8523 [label="=> defaultType 357754"];
8524 [label="baseType.SpecialType 357755"];
8525 [label="get\n            {\n                return SpecialType.None;\n            } 357756"];
8526 [label="return SpecialType.None; 357757"];
8527 [label="SpecialType baseSpecialType = baseType.SpecialType; 357758"];
8528 [label="if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    } 357759"];
8529 [label="IsRestrictedBaseType(baseSpecialType) 357760"];
8530 [label="param IsRestrictedBaseType(SpecialType specialType) 357761"];
8531 [label="switch (specialType)\n            {\n                case SpecialType.System_Array:\n                case SpecialType.System_Enum:\n                case SpecialType.System_Delegate:\n                case SpecialType.System_MulticastDelegate:\n                case SpecialType.System_ValueType:\n                    return true;\n            } 357762"];
8532 [label="return false; 357763"];
8533 [label="if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    } 357764"];
8534 [label="baseType.IsSealed 357765"];
8535 [label="get\n            {\n                return false;\n            } 357766"];
8536 [label="return false; 357767"];
8537 [label="if (baseType.IsSealed && !this.IsStatic) // Give precedence to ERR_StaticDerivedFromNonObject\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CantDeriveFromSealedType, location, this, baseType);\n                        continue;\n                    } 357768"];
8538 [label="bool baseTypeIsErrorWithoutInterfaceGuess = false; 357769"];
8539 [label="baseType.TypeKind 357770"];
8540 [label="get\n            {\n                return TypeKind.Array;\n            } 357771"];
8541 [label="return TypeKind.Array; 357772"];
8542 [label="if (baseType.TypeKind == TypeKind.Error)\n                    {\n                        baseTypeIsErrorWithoutInterfaceGuess = true;\n\n                        TypeKind guessTypeKind = baseType.GetNonErrorTypeKindGuess();\n                        if (guessTypeKind == TypeKind.Interface)\n                        {\n                            //base type is an error *with* a guessed interface\n                            baseTypeIsErrorWithoutInterfaceGuess = false;\n                        }\n                    } 357773"];
8543 [label="baseType.TypeKind 357774"];
8544 [label="get\n            {\n                return TypeKind.Array;\n            } 357775"];
8545 [label="return TypeKind.Array; 357776"];
8546 [label="if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    } 357777"];
8547 [label="baseType.TypeKind 357778"];
8548 [label="get\n            {\n                return TypeKind.Array;\n            } 357779"];
8549 [label="return TypeKind.Array; 357780"];
8550 [label="if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    } 357781"];
8551 [label="if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    } 357782"];
8552 [label="baseType.TypeKind 357783"];
8553 [label="get\n            {\n                return TypeKind.Array;\n            } 357784"];
8554 [label="return TypeKind.Array; 357785"];
8555 [label="if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    } 357786"];
8556 [label="if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    } 357787"];
8557 [label="if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    } 357788"];
8558 [label="baseType.TypeKind 357789"];
8559 [label="get\n            {\n                return TypeKind.Array;\n            } 357790"];
8560 [label="return TypeKind.Array; 357791"];
8561 [label="switch (baseType.TypeKind)\n                {\n                    case TypeKind.Interface:\n                        foreach (var t in localInterfaces)\n                        {\n                            if (t.Equals(baseType, TypeCompareKind.ConsiderEverything))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateInterfaceInBaseList, location, baseType);\n                            }\n                            else if (t.Equals(baseType, TypeCompareKind.ObliviousNullableModifierMatchesAny))\n                            {\n                                // duplicates with ?/! differences are reported later, we report local differences between oblivious and ?/! here\n                                diagnostics.Add(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, location, baseType, this);\n                            }\n                        }\n\n                        if (this.IsStatic)\n                        {\n                            // '{0}': static classes cannot implement interfaces\n                            diagnostics.Add(ErrorCode.ERR_StaticClassInterfaceImpl, location, this, baseType);\n                        }\n\n                        if (this.IsRefLikeType)\n                        {\n                            // '{0}': ref structs cannot implement interfaces\n                            diagnostics.Add(ErrorCode.ERR_RefStructInterfaceImpl, location, this, baseType);\n                        }\n\n                        if (baseType.ContainsDynamic())\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromConstructedDynamic, location, this, baseType);\n                        }\n\n                        localInterfaces.Add((NamedTypeSymbol)baseType);\n                        continue;\n\n                    case TypeKind.Class:\n                        if (TypeKind == TypeKind.Class)\n                        {\n                            if ((object)localBase == null)\n                            {\n                                localBase = (NamedTypeSymbol)baseType;\n                                diagnostics.Add(ErrorCode.ERR_BaseClassMustBeFirst, location, baseType);\n                                continue;\n                            }\n                            else\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NoMultipleInheritance, location, this, localBase, baseType);\n                                continue;\n                            }\n                        }\n                        goto default;\n\n                    case TypeKind.TypeParameter:\n                        diagnostics.Add(ErrorCode.ERR_DerivingFromATyVar, location, baseType);\n                        continue;\n\n                    case TypeKind.Error:\n                        // put the error type in the interface list so we don't lose track of it\n                        localInterfaces.Add((NamedTypeSymbol)baseType);\n                        continue;\n\n                    case TypeKind.Dynamic:\n                        diagnostics.Add(ErrorCode.ERR_DeriveFromDynamic, location, this);\n                        continue;\n\n                    case TypeKind.Submission:\n                        throw ExceptionUtilities.UnexpectedValue(baseType.TypeKind);\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType);\n                        continue;\n                } 357792"];
8562 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType); 357793"];
8563 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType); 357794"];
8564 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType); 357795"];
8565 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType); 357796"];
8566 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType) 357797"];
8567 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType); 357798"];
8568 [label="this.SpecialType 357799"];
8569 [label="get\n            {\n                return _flags.SpecialType;\n            } 357800"];
8570 [label="_flags.SpecialType 357801"];
8571 [label="get { return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); } 357802"];
8572 [label="if (this.SpecialType == SpecialType.System_Object && ((object)localBase != null || localInterfaces.Count != 0))\n            {\n                var name = GetName(bases.Parent);\n                diagnostics.Add(ErrorCode.ERR_ObjectCantHaveBases, new SourceLocation(name));\n            } 357803"];
8573 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(localBase, localInterfaces.ToImmutableAndFree()); 357804"];
8574 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(localBase, localInterfaces.ToImmutableAndFree()); 357805"];
8575 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(localBase, localInterfaces.ToImmutableAndFree()); 357806"];
8576 [label="if ((object)one == null) continue; 357807"];
8577 [label="if ((object)one == null) continue; 357808"];
8578 [label="var partBase = one.Item1; 357809"];
8579 [label="var partInterfaces = one.Item2; 357810"];
8580 [label="if (!reportedPartialConflict)\n                {\n                    if ((object)baseType == null)\n                    {\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if (baseType.TypeKind == TypeKind.Error && (object)partBase != null)\n                    {\n                        // if the old base was an error symbol, copy it to the interfaces list so it doesn't get lost\n                        partInterfaces = partInterfaces.Add(baseType);\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if ((object)partBase != null && !TypeSymbol.Equals(partBase, baseType, TypeCompareKind.ConsiderEverything2) && partBase.TypeKind != TypeKind.Error)\n                    {\n                        // the parts do not agree\n                        var info = diagnostics.Add(ErrorCode.ERR_PartialMultipleBases, Locations[0], this);\n                        baseType = new ExtendedErrorTypeSymbol(baseType, LookupResultKind.Ambiguous, info);\n                        baseTypeLocation = decl.NameLocation;\n                        reportedPartialConflict = true;\n                    }\n                } 357811"];
8581 [label="if ((object)baseType == null)\n                    {\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if (baseType.TypeKind == TypeKind.Error && (object)partBase != null)\n                    {\n                        // if the old base was an error symbol, copy it to the interfaces list so it doesn't get lost\n                        partInterfaces = partInterfaces.Add(baseType);\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if ((object)partBase != null && !TypeSymbol.Equals(partBase, baseType, TypeCompareKind.ConsiderEverything2) && partBase.TypeKind != TypeKind.Error)\n                    {\n                        // the parts do not agree\n                        var info = diagnostics.Add(ErrorCode.ERR_PartialMultipleBases, Locations[0], this);\n                        baseType = new ExtendedErrorTypeSymbol(baseType, LookupResultKind.Ambiguous, info);\n                        baseTypeLocation = decl.NameLocation;\n                        reportedPartialConflict = true;\n                    } 357812"];
8582 [label="if ((object)baseType == null)\n                    {\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if (baseType.TypeKind == TypeKind.Error && (object)partBase != null)\n                    {\n                        // if the old base was an error symbol, copy it to the interfaces list so it doesn't get lost\n                        partInterfaces = partInterfaces.Add(baseType);\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if ((object)partBase != null && !TypeSymbol.Equals(partBase, baseType, TypeCompareKind.ConsiderEverything2) && partBase.TypeKind != TypeKind.Error)\n                    {\n                        // the parts do not agree\n                        var info = diagnostics.Add(ErrorCode.ERR_PartialMultipleBases, Locations[0], this);\n                        baseType = new ExtendedErrorTypeSymbol(baseType, LookupResultKind.Ambiguous, info);\n                        baseTypeLocation = decl.NameLocation;\n                        reportedPartialConflict = true;\n                    } 357813"];
8583 [label="baseType = partBase; 357814"];
8584 [label="baseTypeLocation = decl.NameLocation; 357815"];
8585 [label="foreach (var t in partInterfaces)\n                {\n                    if (!interfaceLocations.ContainsKey(t))\n                    {\n                        baseInterfaces.Add(t);\n                        interfaceLocations.Add(t, decl.NameLocation);\n                    }\n                } 357816"];
8586 [label="HashSet<DiagnosticInfo> useSiteDiagnostics = null; 357817"];
8587 [label="if (declaration.Kind == DeclarationKind.Record)\n            {\n                var type = DeclaringCompilation.GetWellKnownType(WellKnownType.System_IEquatable_T).Construct(this);\n                if (baseInterfaces.IndexOf(type, SymbolEqualityComparer.AllIgnoreOptions) < 0)\n                {\n                    baseInterfaces.Add(type);\n                    type.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n                }\n            } 357818"];
8588 [label="if ((object)baseType != null)\n            {\n                Debug.Assert(baseTypeLocation != null);\n                if (baseType.IsStatic)\n                {\n                    // '{1}': cannot derive from static class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_StaticBaseClass, baseTypeLocation, baseType, this);\n                }\n\n                if (!this.IsNoMoreVisibleThan(baseType, ref useSiteDiagnostics))\n                {\n                    // Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_BadVisBaseClass, baseTypeLocation, this, baseType);\n                }\n            } 357819"];
8589 [label="if ((object)baseType != null)\n            {\n                Debug.Assert(baseTypeLocation != null);\n                if (baseType.IsStatic)\n                {\n                    // '{1}': cannot derive from static class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_StaticBaseClass, baseTypeLocation, baseType, this);\n                }\n\n                if (!this.IsNoMoreVisibleThan(baseType, ref useSiteDiagnostics))\n                {\n                    // Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_BadVisBaseClass, baseTypeLocation, this, baseType);\n                }\n            } 357820"];
8590 [label="var baseInterfacesRO = baseInterfaces.ToImmutableAndFree(); 357821"];
8591 [label="DeclaredAccessibility 357822"];
8592 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 357823"];
8593 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 357824"];
8594 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 357825"];
8595 [label="if (DeclaredAccessibility != Accessibility.Private && IsInterface)\n            {\n                foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                }\n            } 357826"];
8596 [label="IsInterface 357827"];
8597 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 357828"];
8598 [label="this.TypeKind 357829"];
8599 [label="get\n            {\n                return _flags.TypeKind;\n            } 357830"];
8600 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 357831"];
8601 [label="return this.TypeKind == TypeKind.Interface; 357832"];
8602 [label="if (DeclaredAccessibility != Accessibility.Private && IsInterface)\n            {\n                foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                }\n            } 357833"];
8603 [label="if (DeclaredAccessibility != Accessibility.Private && IsInterface)\n            {\n                foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                }\n            } 357834"];
8604 [label="interfaceLocations.Free(); 357835"];
8605 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 357836"];
8606 [label="Locations 357837"];
8607 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 357838"];
8608 [label="return declaration.NameLocations.Cast<SourceLocation, Location>(); 357839"];
8609 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 357840"];
8610 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 357841"];
8611 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 357842"];
8612 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 357843"];
8613 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(baseType, baseInterfacesRO); 357844"];
8614 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(baseType, baseInterfacesRO); 357845"];
8615 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(baseType, baseInterfacesRO); 357846"];
8616 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 357847"];
8617 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 357848"];
8618 [label="AddDeclarationDiagnostics(diagnostics); 357849"];
8619 [label="AddDeclarationDiagnostics(diagnostics) 357850"];
8620 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 357851"];
8621 [label="param AddDeclarationDiagnostics(this) 357852"];
8622 [label="ContainingSymbol 357853"];
8623 [label="get\n            {\n                return _containingSymbol;\n            } 357854"];
8624 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 357855"];
8625 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 357856"];
8626 [label="this.DeclaringCompilation 357857"];
8627 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 357858"];
8628 [label="this.Kind 357859"];
8629 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 357860"];
8630 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 357861"];
8631 [label="CSharpCompilation compilation = this.DeclaringCompilation; 357862"];
8632 [label="Debug.Assert(compilation != null); 357863"];
8633 [label="Debug.Assert(compilation != null); 357864"];
8634 [label="compilation.DeclarationDiagnostics 357865"];
8635 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 357866"];
8636 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 357867"];
8637 [label="compilation.DeclarationDiagnostics.AddRange(diagnostics); 357868"];
8638 [label="compilation.DeclarationDiagnostics.AddRange(diagnostics); 357869"];
8639 [label="AddDeclarationDiagnostics(diagnostics); 357870"];
8640 [label="diagnostics.Free(); 357871"];
8641 [label="return _lazyDeclaredBases; 357872"];
8642 [label="if ((object)declaredBase == null)\n            {\n                switch (typeKind)\n                {\n                    case TypeKind.Class:\n\n                        if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        }\n\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_Object);\n                        break;\n\n                    case TypeKind.Struct:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_ValueType);\n                        break;\n\n                    case TypeKind.Interface:\n                        return null;\n\n                    case TypeKind.Delegate:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_MulticastDelegate);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(typeKind);\n                }\n            } 357873"];
8643 [label="if ((object)declaredBase == null)\n            {\n                switch (typeKind)\n                {\n                    case TypeKind.Class:\n\n                        if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        }\n\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_Object);\n                        break;\n\n                    case TypeKind.Struct:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_ValueType);\n                        break;\n\n                    case TypeKind.Interface:\n                        return null;\n\n                    case TypeKind.Delegate:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_MulticastDelegate);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(typeKind);\n                }\n            } 357874"];
8644 [label="switch (typeKind)\n                {\n                    case TypeKind.Class:\n\n                        if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        }\n\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_Object);\n                        break;\n\n                    case TypeKind.Struct:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_ValueType);\n                        break;\n\n                    case TypeKind.Interface:\n                        return null;\n\n                    case TypeKind.Delegate:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_MulticastDelegate);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(typeKind);\n                } 357875"];
8645 [label="this.SpecialType 357876"];
8646 [label="if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        } 357877"];
8647 [label="declaredBase = compilation.GetSpecialType(SpecialType.System_Object); 357878"];
8648 [label="compilation.GetSpecialType(SpecialType.System_Object) 357879"];
8649 [label="param GetSpecialType(SpecialType specialType) 357880"];
8650 [label="param GetSpecialType(this) 357881"];
8651 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 357882"];
8652 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 357883"];
8653 [label="NamedTypeSymbol result; 357884"];
8654 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 357885"];
8655 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 357886"];
8656 [label="Assembly 357887"];
8657 [label="GetBoundReferenceManager(); 357888"];
8658 [label="result = Assembly.GetSpecialType(specialType); 357889"];
8659 [label="result = Assembly.GetSpecialType(specialType); 357890"];
8660 [label="Assembly.GetSpecialType(specialType) 357891"];
8661 [label="param GetSpecialType(SpecialType type) 357892"];
8662 [label="param GetSpecialType(this) 357893"];
8663 [label="this.Modules 357894"];
8664 [label="get\n            {\n                return _modules;\n            } 357895"];
8665 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 357896"];
8666 [label="module.GetReferencedAssemblies() 357897"];
8667 [label="param GetReferencedAssemblies(this) 357898"];
8668 [label="AssertReferencesInitialized() 357899"];
8669 [label="param AssertReferencesInitialized(this) 357900"];
8670 [label="Debug.Assert(_moduleReferences != null); 357901"];
8671 [label="Debug.Assert(_moduleReferences != null); 357902"];
8672 [label="AssertReferencesInitialized(); 357903"];
8673 [label="return _moduleReferences.Identities; 357904"];
8674 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 357905"];
8675 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 357906"];
8676 [label="result.SpecialType 357907"];
8677 [label="get\n            {\n                return _corTypeId;\n            } 357908"];
8678 [label="Debug.Assert(result.SpecialType == specialType); 357909"];
8679 [label="return result; 357910"];
8680 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return new ExtendedErrorTypeSymbol(declaredBase, LookupResultKind.NotReferencable,\n                    diagnostics.Add(ErrorCode.ERR_CircularBase, Locations[0], declaredBase, this));\n            } 357911"];
8681 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return new ExtendedErrorTypeSymbol(declaredBase, LookupResultKind.NotReferencable,\n                    diagnostics.Add(ErrorCode.ERR_CircularBase, Locations[0], declaredBase, this));\n            } 357912"];
8682 [label="BaseTypeAnalysis.TypeDependsOn(declaredBase, this) 357913"];
8683 [label="param TypeDependsOn(NamedTypeSymbol depends) 357914"];
8684 [label="param TypeDependsOn(NamedTypeSymbol on) 357915"];
8685 [label="Debug.Assert((object)depends != null); 357916"];
8686 [label="Debug.Assert((object)depends != null); 357917"];
8687 [label="Debug.Assert((object)on != null); 357918"];
8688 [label="Debug.Assert((object)on != null); 357919"];
8689 [label="on.IsDefinition 357920"];
8690 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 357921"];
8691 [label="OriginalDefinition 357922"];
8692 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 357923"];
8693 [label="OriginalSymbolDefinition 357924"];
8694 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 357925"];
8695 [label="this.OriginalTypeSymbolDefinition 357926"];
8696 [label="get\n            {\n                return this.OriginalDefinition;\n            } 357927"];
8697 [label="this.OriginalDefinition 357928"];
8698 [label="get\n            {\n                return this;\n            } 357929"];
8699 [label="return this; 357930"];
8700 [label="return this.OriginalDefinition; 357931"];
8701 [label="return this.OriginalTypeSymbolDefinition; 357932"];
8702 [label="return OriginalSymbolDefinition; 357933"];
8703 [label="return (object)this == (object)OriginalDefinition; 357934"];
8704 [label="Debug.Assert(on.IsDefinition); 357935"];
8705 [label="var hs = PooledHashSet<Symbol>.GetInstance(); 357936"];
8706 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 357937"];
8707 [label="depends.DeclaringCompilation 357938"];
8708 [label="get { return null; } 357939"];
8709 [label="return null; 357940"];
8710 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 357941"];
8711 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 357942"];
8712 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs) 357943"];
8713 [label="param TypeDependsClosure(NamedTypeSymbol type) 357944"];
8714 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 357945"];
8715 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 357946"];
8716 [label="if ((object)type == null)\n            {\n                return;\n            } 357947"];
8717 [label="if ((object)type == null)\n            {\n                return;\n            } 357948"];
8718 [label="type.OriginalDefinition 357949"];
8719 [label="get\n            {\n                return this;\n            } 357950"];
8720 [label="type = type.OriginalDefinition; 357951"];
8721 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 357952"];
8722 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 357953"];
8723 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 357954"];
8724 [label="param GetHashCode(this) 357955"];
8725 [label="this.SpecialType 357956"];
8726 [label="get\n            {\n                return _corTypeId;\n            } 357957"];
8727 [label="if (this.SpecialType == SpecialType.System_Object)\n            {\n                return (int)SpecialType.System_Object;\n            } 357958"];
8728 [label="return (int)SpecialType.System_Object; 357959"];
8729 [label="type.IsInterface 357960"];
8730 [label="get\n            {\n                return _flags.IsInterface();\n            } 357961"];
8731 [label="return _flags.IsInterface(); 357962"];
8732 [label="if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                } 357963"];
8733 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 357964"];
8734 [label="type.GetDeclaredBaseType(null) 357965"];
8735 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 357966"];
8736 [label="param GetDeclaredBaseType(this) 357967"];
8737 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 357968"];
8738 [label="GetDeclaredBaseType(skipTransformsIfNecessary: false) 357969"];
8739 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 357970"];
8740 [label="param GetDeclaredBaseType(this) 357971"];
8741 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 357972"];
8742 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 357973"];
8743 [label="MakeDeclaredBaseType() 357974"];
8744 [label="param MakeDeclaredBaseType(this) 357975"];
8745 [label="if (!_flags.IsInterface())\n            {\n                try\n                {\n                    var moduleSymbol = ContainingPEModule;\n                    EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle);\n                    if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    }\n                }\n                catch (BadImageFormatException mrEx)\n                {\n                    return new UnsupportedMetadataTypeSymbol(mrEx);\n                }\n            } 357976"];
8746 [label="ContainingPEModule 357977"];
8747 [label="s.Kind 357978"];
8748 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 357979"];
8749 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 357980"];
8750 [label="var moduleSymbol = ContainingPEModule; 357981"];
8751 [label="moduleSymbol.Module 357982"];
8752 [label="get\n            {\n                return _module;\n            } 357983"];
8753 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 357984"];
8754 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 357985"];
8755 [label="if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    } 357986"];
8756 [label="return null; 357987"];
8757 [label="var baseType = MakeDeclaredBaseType(); 357988"];
8758 [label="if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                } 357989"];
8759 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 357990"];
8760 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 357991"];
8761 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 357992"];
8762 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 357993"];
8763 [label="return _lazyDeclaredBaseType; 357994"];
8764 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 357995"];
8765 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 357996"];
8766 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 357997"];
8767 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 357998"];
8768 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure) 357999"];
8769 [label="param TypeDependsClosure(NamedTypeSymbol type) 358000"];
8770 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 358001"];
8771 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 358002"];
8772 [label="if ((object)type == null)\n            {\n                return;\n            } 358003"];
8773 [label="if ((object)type == null)\n            {\n                return;\n            } 358004"];
8774 [label="return; 358005"];
8775 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 358006"];
8776 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 358007"];
8777 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 358008"];
8778 [label="var result = hs.Contains(on); 358009"];
8779 [label="var result = hs.Contains(on); 358010"];
8780 [label="var result = hs.Contains(on); 358011"];
8781 [label="this.SpecialType 358012"];
8782 [label="_flags.SpecialType 358013"];
8783 [label="OriginalDefinition 358014"];
8784 [label="get\n            {\n                return this;\n            } 358015"];
8785 [label="return RuntimeHelpers.GetHashCode(OriginalDefinition); 358016"];
8786 [label="hs.Free(); 358017"];
8787 [label="return result; 358018"];
8788 [label="this.SetKnownToHaveNoDeclaredBaseCycles() 358019"];
8789 [label="param SetKnownToHaveNoDeclaredBaseCycles(this) 358020"];
8790 [label="_hasNoBaseCycles = true; 358021"];
8791 [label="_hasNoBaseCycles 358022"];
8792 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 358023"];
8793 [label="HashSet<DiagnosticInfo> useSiteDiagnostics = null; 358024"];
8794 [label="NamedTypeSymbol current = declaredBase; 358025"];
8795 [label="current.DeclaringCompilation 358026"];
8796 [label="get { return null; } 358027"];
8797 [label="return null; 358028"];
8798 [label="if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                } 358029"];
8799 [label="this.DeclaringCompilation 358030"];
8800 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 358031"];
8801 [label="this.Kind 358032"];
8802 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 358033"];
8803 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 358034"];
8804 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 358035"];
8805 [label="this.ContainingSymbol 358036"];
8806 [label="get\n            {\n                return _containingSymbol;\n            } 358037"];
8807 [label="return _containingSymbol; 358038"];
8808 [label="return (object)container != null ? container.ContainingModule : null; 358039"];
8809 [label="if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                } 358040"];
8810 [label="if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                } 358041"];
8811 [label="current.AddUseSiteDiagnostics(ref useSiteDiagnostics); 358042"];
8812 [label="current.AddUseSiteDiagnostics(ref useSiteDiagnostics); 358043"];
8813 [label="current.AddUseSiteDiagnostics(ref useSiteDiagnostics) 358044"];
8814 [label="param AddUseSiteDiagnostics(this TypeSymbol type) 358045"];
8815 [label="param AddUseSiteDiagnostics(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 358046"];
8816 [label="type.GetUseSiteDiagnostic() 358047"];
8817 [label="param GetUseSiteDiagnostic(this) 358048"];
8818 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 358049"];
8819 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 358050"];
8820 [label="GetUseSiteDiagnosticImpl() 358051"];
8821 [label="param GetUseSiteDiagnosticImpl(this) 358052"];
8822 [label="DiagnosticInfo diagnostic = null; 358053"];
8823 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 358054"];
8824 [label="CalculateUseSiteDiagnostic() 358055"];
8825 [label="param CalculateUseSiteDiagnostic(this) 358056"];
8826 [label="DiagnosticInfo result = null; 358057"];
8827 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 358058"];
8828 [label="DeriveUseSiteDiagnosticFromBase() 358059"];
8829 [label="param DeriveUseSiteDiagnosticFromBase(this) 358060"];
8830 [label="this.BaseTypeNoUseSiteDiagnostics 358061"];
8831 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                }\n\n                return _lazyBaseType;\n            } 358062"];
8832 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 358063"];
8833 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 358064"];
8834 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 358065"];
8835 [label="MakeAcyclicBaseType() 358066"];
8836 [label="param MakeAcyclicBaseType(this) 358067"];
8837 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 358068"];
8838 [label="GetDeclaredBaseType(null) 358069"];
8839 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 358070"];
8840 [label="param GetDeclaredBaseType(this) 358071"];
8841 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 358072"];
8842 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 358073"];
8843 [label="return _lazyDeclaredBaseType; 358074"];
8844 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 358075"];
8845 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 358076"];
8846 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 358077"];
8847 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 358078"];
8848 [label="return null; 358079"];
8849 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 358080"];
8850 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 358081"];
8851 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 358082"];
8852 [label="return _lazyBaseType; 358083"];
8853 [label="NamedTypeSymbol @base = this.BaseTypeNoUseSiteDiagnostics; 358084"];
8854 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 358085"];
8855 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 358086"];
8856 [label="return null; 358087"];
8857 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 358088"];
8858 [label="MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()) 358089"];
8859 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 358090"];
8860 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 358091"];
8861 [label="param MergeUseSiteDiagnostics(this) 358092"];
8862 [label="if (info == null)\n            {\n                return false;\n            } 358093"];
8863 [label="if (info == null)\n            {\n                return false;\n            } 358094"];
8864 [label="return false; 358095"];
8865 [label="this.ContainingModule 358096"];
8866 [label="get\n            {\n                return ContainingPEModule;\n            } 358097"];
8867 [label="ContainingPEModule 358098"];
8868 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 358099"];
8869 [label="Symbol s = _container; 358100"];
8870 [label="s.Kind 358101"];
8871 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 358102"];
8872 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 358103"];
8873 [label="return ContainingPEModule; 358104"];
8874 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 358105"];
8875 [label="this.ContainingModule.HasUnifiedReferences 358106"];
8876 [label="get { return GetUnifiedAssemblies().Length > 0; } 358107"];
8877 [label="GetUnifiedAssemblies() 358108"];
8878 [label="param GetUnifiedAssemblies(this) 358109"];
8879 [label="AssertReferencesInitialized() 358110"];
8880 [label="param AssertReferencesInitialized(this) 358111"];
8881 [label="Debug.Assert(_moduleReferences != null); 358112"];
8882 [label="Debug.Assert(_moduleReferences != null); 358113"];
8883 [label="AssertReferencesInitialized(); 358114"];
8884 [label="return GetUnifiedAssemblies().Length > 0; 358115"];
8885 [label="return GetUnifiedAssemblies().Length > 0; 358116"];
8886 [label="return result; 358117"];
8887 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 358118"];
8888 [label="MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()) 358119"];
8889 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 358120"];
8890 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 358121"];
8891 [label="param MergeUseSiteDiagnostics(this) 358122"];
8892 [label="if (info == null)\n            {\n                return false;\n            } 358123"];
8893 [label="if (info == null)\n            {\n                return false;\n            } 358124"];
8894 [label="return false; 358125"];
8895 [label="this.ContainingPEModule 358126"];
8896 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 358127"];
8897 [label="Symbol s = _container; 358128"];
8898 [label="s.Kind 358129"];
8899 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 358130"];
8900 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 358131"];
8901 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 358132"];
8902 [label="this.ContainingPEModule.Module 358133"];
8903 [label="get\n            {\n                return _module;\n            } 358134"];
8904 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 358135"];
8905 [label="TypeKind 358136"];
8906 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 358137"];
8907 [label="TypeKind result = _lazyKind; 358138"];
8908 [label="if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                } 358139"];
8909 [label="if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    } 358140"];
8910 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 358141"];
8911 [label="GetDeclaredBaseType(skipTransformsIfNecessary: true) 358142"];
8912 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 358143"];
8913 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 358144"];
8914 [label="result = TypeKind.Class; 358145"];
8915 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 358146"];
8916 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 358147"];
8917 [label="_lazyKind 358148"];
8918 [label="return result; 358149"];
8919 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 358150"];
8920 [label="SpecialType 358151"];
8921 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 358152"];
8922 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 358153"];
8923 [label="TypeSymbol @base = GetDeclaredBaseType(null); 358154"];
8924 [label="GetDeclaredBaseType(null) 358155"];
8925 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 358156"];
8926 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 358157"];
8927 [label="TypeSymbol @base = GetDeclaredBaseType(null); 358158"];
8928 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 358159"];
8929 [label="return diagnostic; 358160"];
8930 [label="_lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl(); 358161"];
8931 [label="_lazyUseSiteDiagnostic 358162"];
8932 [label="return _lazyUseSiteDiagnostic; 358163"];
8933 [label="DiagnosticInfo errorInfo = type.GetUseSiteDiagnostic(); 358164"];
8934 [label="if ((object)errorInfo != null)\n            {\n                if (useSiteDiagnostics == null)\n                {\n                    useSiteDiagnostics = new HashSet<DiagnosticInfo>();\n                }\n\n                useSiteDiagnostics.Add(errorInfo);\n            } 358165"];
8935 [label="if ((object)errorInfo != null)\n            {\n                if (useSiteDiagnostics == null)\n                {\n                    useSiteDiagnostics = new HashSet<DiagnosticInfo>();\n                }\n\n                useSiteDiagnostics.Add(errorInfo);\n            } 358166"];
8936 [label="current.AddUseSiteDiagnostics(ref useSiteDiagnostics); 358167"];
8937 [label="current.BaseTypeNoUseSiteDiagnostics 358168"];
8938 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                }\n\n                return _lazyBaseType;\n            } 358169"];
8939 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 358170"];
8940 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 358171"];
8941 [label="return _lazyBaseType; 358172"];
8942 [label="current = current.BaseTypeNoUseSiteDiagnostics; 358173"];
8943 [label="do\n            {\n                if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                }\n\n                current.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n                current = current.BaseTypeNoUseSiteDiagnostics;\n            }\n            while ((object)current != null); 358174"];
8944 [label="do\n            {\n                if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                }\n\n                current.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n                current = current.BaseTypeNoUseSiteDiagnostics;\n            }\n            while ((object)current != null); 358175"];
8945 [label="if (!useSiteDiagnostics.IsNullOrEmpty())\n            {\n                diagnostics.Add(FindBaseRefSyntax(declaredBase) ?? Locations[0], useSiteDiagnostics);\n            } 358176"];
8946 [label="return declaredBase; 358177"];
8947 [label="var acyclicBase = this.MakeAcyclicBaseType(diagnostics); 358178"];
8948 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 358179"];
8949 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 358180"];
8950 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 358181"];
8951 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 358182"];
8952 [label="AddDeclarationDiagnostics(diagnostics); 358183"];
8953 [label="AddDeclarationDiagnostics(diagnostics) 358184"];
8954 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 358185"];
8955 [label="ContainingSymbol 358186"];
8956 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 358187"];
8957 [label="AddDeclarationDiagnostics(diagnostics); 358188"];
8958 [label="diagnostics.Free(); 358189"];
8959 [label="return _lazyBaseType; 358190"];
8960 [label="return symbol.BaseTypeNoUseSiteDiagnostics; 358191"];
8961 [label="CustomAssert.Equal('Object', bt.Name); 358192"];
8962 [label="bt.Name 358193"];
8963 [label="get\n            {\n                return _name;\n            } 358194"];
8964 [label="CustomAssert.Equal('Object', bt.Name); 358195"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 3;
192 -> 191;
193 -> 192;
194 -> 193;
194 -> 192;
195 -> 1;
195 -> 2;
195 -> 194;
196 -> 1;
197 -> 1;
198 -> 197;
198 -> 1;
199 -> 1;
200 -> 198;
200 -> 199;
201 -> 200;
201 -> 199;
202 -> 199;
203 -> 201;
203 -> 202;
204 -> 202;
205 -> 203;
205 -> 204;
205 -> 202;
206 -> 202;
206 -> 1;
207 -> 1;
208 -> 1;
209 -> 206;
209 -> 208;
210 -> 207;
210 -> 208;
211 -> 207;
211 -> 208;
212 -> 207;
212 -> 208;
213 -> 207;
213 -> 208;
214 -> 207;
214 -> 208;
215 -> 207;
215 -> 208;
216 -> 207;
216 -> 208;
217 -> 209;
217 -> 208;
218 -> 213;
218 -> 208;
219 -> 210;
219 -> 208;
220 -> 208;
221 -> 218;
221 -> 220;
222 -> 219;
222 -> 220;
223 -> 221;
223 -> 220;
224 -> 220;
225 -> 223;
225 -> 224;
226 -> 225;
226 -> 224;
227 -> 226;
228 -> 0;
228 -> 227;
229 -> 228;
230 -> 229;
231 -> 229;
232 -> 0;
232 -> 231;
233 -> 232;
233 -> 230;
233 -> 229;
234 -> 233;
234 -> 227;
235 -> 220;
236 -> 222;
236 -> 235;
236 -> 220;
237 -> 234;
237 -> 236;
238 -> 211;
238 -> 208;
239 -> 212;
239 -> 208;
240 -> 214;
240 -> 208;
241 -> 215;
241 -> 208;
242 -> 216;
242 -> 208;
243 -> 208;
244 -> 217;
244 -> 243;
245 -> 237;
245 -> 243;
246 -> 238;
246 -> 243;
247 -> 239;
247 -> 243;
248 -> 240;
248 -> 243;
249 -> 241;
249 -> 243;
250 -> 242;
250 -> 243;
251 -> 244;
251 -> 243;
252 -> 245;
252 -> 243;
253 -> 246;
253 -> 243;
254 -> 247;
254 -> 243;
255 -> 248;
255 -> 243;
256 -> 249;
256 -> 243;
257 -> 250;
257 -> 243;
258 -> 243;
259 -> 258;
259 -> 243;
260 -> 243;
261 -> 251;
261 -> 260;
262 -> 252;
262 -> 260;
263 -> 253;
263 -> 260;
264 -> 254;
264 -> 260;
265 -> 255;
265 -> 260;
266 -> 256;
266 -> 260;
267 -> 257;
267 -> 260;
268 -> 259;
268 -> 260;
269 -> 264;
269 -> 260;
270 -> 266;
270 -> 260;
271 -> 260;
272 -> 269;
272 -> 271;
273 -> 270;
273 -> 271;
274 -> 261;
274 -> 271;
275 -> 274;
275 -> 205;
275 -> 271;
276 -> 275;
277 -> 273;
277 -> 275;
278 -> 272;
278 -> 275;
279 -> 275;
280 -> 276;
280 -> 279;
281 -> 277;
281 -> 279;
282 -> 278;
282 -> 279;
283 -> 276;
283 -> 279;
284 -> 279;
285 -> 282;
285 -> 284;
285 -> 279;
286 -> 0;
287 -> 0;
289 -> 286;
289 -> 287;
289 -> 288;
290 -> 289;
291 -> 0;
292 -> 290;
292 -> 289;
292 -> 291;
293 -> 292;
294 -> 0;
295 -> 290;
295 -> 289;
295 -> 294;
296 -> 295;
297 -> 0;
298 -> 290;
298 -> 289;
298 -> 297;
299 -> 298;
300 -> 0;
301 -> 290;
301 -> 289;
301 -> 300;
302 -> 301;
303 -> 0;
304 -> 290;
304 -> 289;
304 -> 303;
305 -> 304;
306 -> 0;
307 -> 290;
307 -> 289;
307 -> 306;
308 -> 307;
309 -> 0;
310 -> 290;
310 -> 289;
310 -> 309;
311 -> 310;
312 -> 0;
313 -> 290;
313 -> 289;
313 -> 312;
314 -> 313;
315 -> 0;
316 -> 290;
316 -> 289;
316 -> 315;
317 -> 316;
318 -> 0;
319 -> 290;
319 -> 289;
319 -> 318;
320 -> 319;
321 -> 0;
322 -> 290;
322 -> 289;
322 -> 321;
323 -> 322;
324 -> 290;
327 -> 324;
327 -> 326;
328 -> 325;
328 -> 326;
329 -> 326;
330 -> 327;
330 -> 289;
330 -> 326;
331 -> 326;
332 -> 328;
332 -> 326;
333 -> 329;
333 -> 326;
334 -> 332;
334 -> 333;
334 -> 326;
335 -> 334;
335 -> 331;
335 -> 326;
336 -> 330;
336 -> 331;
336 -> 289;
336 -> 335;
336 -> 334;
336 -> 326;
337 -> 336;
338 -> 0;
339 -> 338;
341 -> 339;
341 -> 340;
342 -> 290;
342 -> 289;
342 -> 341;
343 -> 342;
344 -> 0;
345 -> 344;
346 -> 290;
346 -> 289;
346 -> 345;
347 -> 346;
348 -> 0;
349 -> 290;
349 -> 289;
349 -> 348;
350 -> 349;
351 -> 314;
353 -> 352;
354 -> 0;
355 -> 0;
356 -> 0;
358 -> 354;
358 -> 355;
358 -> 356;
358 -> 357;
359 -> 353;
360 -> 358;
360 -> 359;
360 -> 352;
361 -> 360;
365 -> 362;
365 -> 363;
365 -> 364;
366 -> 296;
366 -> 289;
366 -> 295;
366 -> 362;
366 -> 365;
367 -> 366;
368 -> 308;
369 -> 317;
370 -> 317;
371 -> 314;
372 -> 0;
373 -> 0;
375 -> 372;
375 -> 374;
376 -> 373;
376 -> 374;
377 -> 374;
378 -> 375;
378 -> 374;
379 -> 376;
379 -> 374;
380 -> 0;
380 -> 374;
381 -> 377;
381 -> 374;
382 -> 374;
383 -> 378;
383 -> 379;
383 -> 380;
383 -> 381;
383 -> 382;
383 -> 374;
384 -> 383;
385 -> 0;
386 -> 0;
388 -> 385;
388 -> 387;
389 -> 386;
389 -> 387;
390 -> 387;
391 -> 388;
391 -> 387;
392 -> 389;
392 -> 387;
393 -> 0;
393 -> 387;
394 -> 390;
394 -> 387;
395 -> 387;
396 -> 391;
396 -> 392;
396 -> 393;
396 -> 394;
396 -> 395;
396 -> 387;
397 -> 396;
399 -> 384;
399 -> 383;
399 -> 398;
400 -> 399;
402 -> 397;
402 -> 396;
402 -> 401;
403 -> 402;
404 -> 0;
405 -> 0;
407 -> 404;
407 -> 406;
408 -> 405;
408 -> 406;
409 -> 406;
410 -> 407;
410 -> 406;
411 -> 408;
411 -> 406;
412 -> 0;
412 -> 406;
413 -> 409;
413 -> 406;
414 -> 406;
415 -> 410;
415 -> 411;
415 -> 412;
415 -> 413;
415 -> 414;
415 -> 406;
416 -> 415;
417 -> 0;
418 -> 0;
420 -> 417;
420 -> 419;
421 -> 418;
421 -> 419;
422 -> 419;
423 -> 420;
423 -> 419;
424 -> 421;
424 -> 419;
425 -> 0;
425 -> 419;
426 -> 422;
426 -> 419;
427 -> 419;
428 -> 423;
428 -> 424;
428 -> 425;
428 -> 426;
428 -> 427;
428 -> 419;
429 -> 428;
430 -> 0;
431 -> 0;
433 -> 430;
433 -> 432;
434 -> 431;
434 -> 432;
435 -> 432;
436 -> 433;
436 -> 432;
437 -> 434;
437 -> 432;
438 -> 0;
438 -> 432;
439 -> 435;
439 -> 432;
440 -> 432;
441 -> 436;
441 -> 437;
441 -> 438;
441 -> 439;
441 -> 440;
441 -> 432;
442 -> 441;
443 -> 0;
444 -> 0;
446 -> 443;
446 -> 445;
447 -> 444;
447 -> 445;
448 -> 445;
449 -> 446;
449 -> 445;
450 -> 447;
450 -> 445;
451 -> 0;
451 -> 445;
452 -> 448;
452 -> 445;
453 -> 445;
454 -> 449;
454 -> 450;
454 -> 451;
454 -> 452;
454 -> 453;
454 -> 445;
455 -> 454;
456 -> 0;
457 -> 0;
459 -> 456;
459 -> 458;
460 -> 457;
460 -> 458;
461 -> 458;
462 -> 459;
462 -> 458;
463 -> 460;
463 -> 458;
464 -> 0;
464 -> 458;
465 -> 461;
465 -> 458;
466 -> 458;
467 -> 462;
467 -> 463;
467 -> 464;
467 -> 465;
467 -> 466;
467 -> 458;
468 -> 467;
469 -> 0;
470 -> 0;
472 -> 469;
472 -> 471;
473 -> 470;
473 -> 471;
474 -> 471;
475 -> 472;
475 -> 471;
476 -> 473;
476 -> 471;
477 -> 0;
477 -> 471;
478 -> 474;
478 -> 471;
479 -> 471;
480 -> 475;
480 -> 476;
480 -> 477;
480 -> 478;
480 -> 479;
480 -> 471;
481 -> 480;
483 -> 384;
483 -> 383;
483 -> 482;
484 -> 483;
486 -> 397;
486 -> 396;
486 -> 485;
487 -> 486;
489 -> 416;
489 -> 415;
489 -> 488;
490 -> 489;
492 -> 429;
492 -> 428;
492 -> 491;
493 -> 492;
494 -> 0;
495 -> 384;
495 -> 383;
495 -> 494;
495 -> 0;
496 -> 495;
497 -> 0;
498 -> 397;
498 -> 396;
498 -> 497;
498 -> 0;
499 -> 498;
500 -> 0;
501 -> 468;
501 -> 467;
501 -> 500;
501 -> 0;
502 -> 501;
503 -> 0;
504 -> 416;
504 -> 415;
504 -> 503;
504 -> 0;
505 -> 504;
506 -> 0;
507 -> 0;
507 -> 506;
508 -> 507;
509 -> 290;
509 -> 285;
510 -> 280;
510 -> 279;
511 -> 0;
511 -> 279;
512 -> 511;
512 -> 283;
512 -> 279;
513 -> 279;
514 -> 510;
514 -> 512;
514 -> 513;
514 -> 0;
514 -> 279;
515 -> 514;
515 -> 279;
516 -> 509;
516 -> 279;
517 -> 281;
517 -> 279;
518 -> 279;
519 -> 515;
519 -> 516;
519 -> 517;
519 -> 518;
519 -> 514;
519 -> 289;
519 -> 279;
520 -> 279;
521 -> 519;
521 -> 520;
522 -> 520;
523 -> 520;
524 -> 521;
524 -> 519;
524 -> 523;
524 -> 520;
525 -> 522;
525 -> 520;
526 -> 520;
527 -> 524;
527 -> 519;
527 -> 523;
527 -> 525;
527 -> 526;
527 -> 522;
527 -> 520;
528 -> 520;
529 -> 528;
529 -> 522;
529 -> 520;
530 -> 522;
530 -> 520;
531 -> 520;
532 -> 530;
532 -> 531;
532 -> 522;
532 -> 529;
532 -> 520;
533 -> 521;
533 -> 520;
534 -> 533;
534 -> 276;
534 -> 275;
535 -> 276;
535 -> 260;
536 -> 260;
537 -> 263;
537 -> 536;
537 -> 260;
538 -> 535;
538 -> 537;
539 -> 537;
540 -> 538;
540 -> 539;
540 -> 276;
540 -> 534;
540 -> 519;
540 -> 537;
541 -> 540;
541 -> 537;
542 -> 384;
542 -> 541;
543 -> 0;
543 -> 260;
544 -> 268;
544 -> 260;
545 -> 265;
545 -> 535;
545 -> 262;
545 -> 542;
545 -> 260;
546 -> 545;
546 -> 260;
547 -> 260;
548 -> 546;
548 -> 547;
549 -> 0;
549 -> 547;
550 -> 549;
551 -> 260;
552 -> 545;
552 -> 276;
552 -> 534;
552 -> 519;
552 -> 233;
552 -> 0;
552 -> 383;
552 -> 230;
552 -> 260;
553 -> 260;
554 -> 553;
555 -> 552;
555 -> 554;
555 -> 260;
556 -> 0;
558 -> 556;
558 -> 557;
559 -> 558;
560 -> 0;
562 -> 560;
562 -> 561;
564 -> 562;
564 -> 563;
565 -> 564;
566 -> 552;
566 -> 553;
567 -> 552;
567 -> 553;
568 -> 552;
568 -> 553;
569 -> 552;
569 -> 553;
570 -> 566;
570 -> 553;
571 -> 569;
571 -> 553;
572 -> 567;
572 -> 553;
573 -> 568;
573 -> 553;
574 -> 553;
575 -> 553;
576 -> 570;
576 -> 575;
577 -> 571;
577 -> 575;
578 -> 572;
578 -> 575;
579 -> 573;
579 -> 575;
580 -> 574;
580 -> 575;
581 -> 574;
581 -> 575;
582 -> 574;
582 -> 575;
583 -> 574;
583 -> 575;
584 -> 575;
585 -> 577;
585 -> 584;
585 -> 575;
586 -> 583;
586 -> 575;
587 -> 579;
587 -> 575;
588 -> 587;
588 -> 555;
588 -> 575;
589 -> 576;
589 -> 575;
590 -> 577;
590 -> 575;
591 -> 588;
591 -> 575;
592 -> 580;
592 -> 575;
593 -> 581;
593 -> 575;
594 -> 582;
594 -> 575;
595 -> 583;
595 -> 575;
596 -> 575;
597 -> 0;
597 -> 575;
598 -> 577;
598 -> 588;
598 -> 575;
599 -> 597;
599 -> 598;
599 -> 595;
599 -> 596;
599 -> 0;
599 -> 588;
599 -> 575;
600 -> 575;
601 -> 589;
601 -> 600;
602 -> 590;
602 -> 600;
603 -> 591;
603 -> 600;
604 -> 592;
604 -> 600;
605 -> 593;
605 -> 600;
606 -> 594;
606 -> 600;
607 -> 595;
607 -> 600;
608 -> 596;
608 -> 600;
609 -> 596;
609 -> 600;
610 -> 599;
610 -> 600;
611 -> 596;
611 -> 600;
612 -> 596;
612 -> 600;
613 -> 596;
613 -> 600;
614 -> 601;
614 -> 600;
615 -> 602;
615 -> 600;
616 -> 603;
616 -> 600;
617 -> 604;
617 -> 600;
618 -> 605;
618 -> 600;
619 -> 606;
619 -> 600;
620 -> 607;
620 -> 600;
621 -> 608;
621 -> 600;
622 -> 609;
622 -> 600;
623 -> 610;
623 -> 600;
624 -> 610;
624 -> 599;
624 -> 600;
625 -> 624;
625 -> 599;
625 -> 600;
626 -> 611;
626 -> 600;
627 -> 612;
627 -> 600;
628 -> 600;
629 -> 614;
629 -> 628;
630 -> 615;
630 -> 628;
631 -> 616;
631 -> 628;
632 -> 617;
632 -> 628;
633 -> 618;
633 -> 628;
634 -> 619;
634 -> 628;
635 -> 620;
635 -> 628;
636 -> 621;
636 -> 628;
637 -> 622;
637 -> 628;
638 -> 623;
638 -> 628;
639 -> 625;
639 -> 628;
640 -> 626;
640 -> 628;
641 -> 627;
641 -> 628;
642 -> 613;
642 -> 628;
643 -> 629;
643 -> 628;
644 -> 631;
644 -> 628;
645 -> 639;
645 -> 628;
646 -> 635;
646 -> 628;
647 -> 640;
647 -> 628;
648 -> 641;
648 -> 628;
649 -> 628;
650 -> 649;
650 -> 643;
650 -> 644;
650 -> 645;
650 -> 646;
650 -> 647;
650 -> 648;
650 -> 588;
650 -> 625;
650 -> 628;
651 -> 649;
651 -> 628;
652 -> 649;
652 -> 628;
653 -> 649;
653 -> 628;
654 -> 649;
654 -> 628;
655 -> 649;
655 -> 628;
656 -> 649;
656 -> 628;
657 -> 649;
657 -> 628;
658 -> 649;
658 -> 628;
659 -> 649;
659 -> 628;
660 -> 649;
660 -> 628;
661 -> 649;
661 -> 628;
662 -> 649;
662 -> 628;
663 -> 649;
663 -> 628;
664 -> 649;
664 -> 628;
665 -> 649;
665 -> 628;
666 -> 649;
666 -> 628;
667 -> 649;
667 -> 628;
668 -> 649;
668 -> 628;
669 -> 649;
669 -> 628;
670 -> 649;
670 -> 628;
671 -> 649;
671 -> 628;
672 -> 649;
672 -> 628;
673 -> 649;
673 -> 628;
674 -> 649;
674 -> 628;
675 -> 649;
675 -> 628;
676 -> 649;
676 -> 628;
677 -> 628;
678 -> 677;
678 -> 649;
678 -> 628;
679 -> 649;
679 -> 628;
680 -> 649;
680 -> 628;
681 -> 649;
681 -> 628;
682 -> 649;
682 -> 628;
683 -> 649;
683 -> 628;
684 -> 649;
684 -> 628;
685 -> 649;
685 -> 628;
686 -> 628;
687 -> 628;
688 -> 685;
688 -> 687;
689 -> 686;
689 -> 687;
691 -> 690;
692 -> 690;
693 -> 687;
694 -> 689;
694 -> 693;
695 -> 693;
696 -> 689;
696 -> 687;
697 -> 688;
697 -> 689;
697 -> 687;
698 -> 686;
698 -> 649;
698 -> 628;
699 -> 630;
699 -> 649;
699 -> 628;
700 -> 649;
700 -> 628;
701 -> 700;
701 -> 650;
701 -> 651;
701 -> 699;
701 -> 652;
701 -> 653;
701 -> 654;
701 -> 655;
701 -> 656;
701 -> 657;
701 -> 658;
701 -> 659;
701 -> 660;
701 -> 661;
701 -> 662;
701 -> 663;
701 -> 664;
701 -> 665;
701 -> 666;
701 -> 667;
701 -> 668;
701 -> 669;
701 -> 670;
701 -> 671;
701 -> 672;
701 -> 673;
701 -> 674;
701 -> 675;
701 -> 676;
701 -> 678;
701 -> 679;
701 -> 698;
701 -> 680;
701 -> 681;
701 -> 682;
701 -> 683;
701 -> 684;
701 -> 677;
701 -> 695;
701 -> 696;
701 -> 697;
701 -> 628;
702 -> 701;
702 -> 649;
702 -> 628;
703 -> 649;
703 -> 701;
703 -> 628;
704 -> 703;
704 -> 701;
704 -> 702;
704 -> 628;
705 -> 704;
705 -> 649;
705 -> 628;
706 -> 649;
706 -> 704;
706 -> 628;
707 -> 706;
707 -> 704;
707 -> 705;
707 -> 628;
708 -> 707;
708 -> 649;
708 -> 628;
709 -> 649;
709 -> 707;
709 -> 628;
710 -> 709;
710 -> 707;
710 -> 708;
710 -> 628;
711 -> 710;
711 -> 649;
711 -> 628;
712 -> 649;
712 -> 710;
712 -> 628;
713 -> 712;
713 -> 710;
713 -> 711;
713 -> 628;
714 -> 713;
714 -> 649;
714 -> 628;
715 -> 649;
715 -> 628;
716 -> 628;
717 -> 628;
718 -> 715;
718 -> 717;
719 -> 716;
719 -> 717;
720 -> 717;
721 -> 720;
721 -> 717;
722 -> 720;
722 -> 717;
723 -> 720;
723 -> 717;
724 -> 717;
725 -> 724;
725 -> 720;
725 -> 717;
726 -> 717;
727 -> 718;
727 -> 726;
727 -> 717;
728 -> 718;
728 -> 720;
728 -> 717;
729 -> 716;
729 -> 649;
729 -> 628;
730 -> 638;
730 -> 713;
730 -> 628;
731 -> 628;
732 -> 730;
732 -> 731;
733 -> 731;
734 -> 732;
734 -> 731;
735 -> 734;
735 -> 713;
735 -> 714;
735 -> 729;
735 -> 731;
736 -> 0;
736 -> 731;
737 -> 736;
737 -> 733;
737 -> 731;
738 -> 737;
738 -> 628;
739 -> 738;
739 -> 649;
739 -> 628;
740 -> 635;
740 -> 628;
741 -> 740;
742 -> 632;
742 -> 741;
742 -> 740;
743 -> 633;
743 -> 741;
743 -> 740;
744 -> 742;
744 -> 743;
744 -> 740;
745 -> 634;
745 -> 741;
745 -> 740;
746 -> 744;
746 -> 745;
746 -> 740;
747 -> 637;
747 -> 628;
748 -> 649;
748 -> 713;
748 -> 714;
748 -> 729;
748 -> 739;
748 -> 720;
748 -> 721;
748 -> 728;
748 -> 722;
748 -> 723;
748 -> 725;
748 -> 724;
748 -> 747;
749 -> 747;
750 -> 649;
750 -> 749;
751 -> 750;
751 -> 748;
751 -> 749;
752 -> 636;
752 -> 747;
753 -> 747;
754 -> 747;
755 -> 748;
755 -> 754;
756 -> 751;
756 -> 754;
757 -> 752;
757 -> 754;
758 -> 753;
758 -> 754;
759 -> 755;
759 -> 754;
760 -> 756;
760 -> 754;
761 -> 757;
761 -> 754;
762 -> 754;
763 -> 762;
763 -> 759;
763 -> 760;
763 -> 761;
763 -> 748;
763 -> 754;
764 -> 753;
764 -> 649;
764 -> 747;
765 -> 638;
765 -> 649;
765 -> 628;
766 -> 649;
766 -> 763;
766 -> 628;
767 -> 628;
768 -> 649;
768 -> 763;
768 -> 767;
768 -> 628;
769 -> 575;
770 -> 578;
770 -> 769;
770 -> 575;
771 -> 578;
771 -> 770;
772 -> 770;
773 -> 771;
773 -> 772;
774 -> 596;
774 -> 772;
775 -> 772;
776 -> 773;
776 -> 775;
776 -> 772;
777 -> 773;
777 -> 772;
778 -> 777;
778 -> 763;
778 -> 764;
778 -> 765;
778 -> 772;
779 -> 772;
780 -> 774;
780 -> 778;
780 -> 772;
781 -> 779;
781 -> 772;
782 -> 780;
782 -> 778;
782 -> 772;
783 -> 781;
783 -> 782;
783 -> 779;
783 -> 778;
783 -> 772;
784 -> 772;
785 -> 772;
786 -> 773;
786 -> 772;
787 -> 786;
787 -> 783;
787 -> 772;
788 -> 787;
789 -> 787;
790 -> 787;
791 -> 774;
791 -> 790;
791 -> 787;
792 -> 787;
793 -> 779;
793 -> 792;
793 -> 790;
793 -> 787;
794 -> 784;
794 -> 787;
794 -> 793;
795 -> 785;
795 -> 787;
796 -> 779;
796 -> 793;
796 -> 772;
797 -> 774;
797 -> 796;
797 -> 772;
798 -> 773;
798 -> 772;
799 -> 780;
799 -> 798;
799 -> 796;
799 -> 772;
800 -> 774;
800 -> 799;
800 -> 772;
801 -> 794;
801 -> 772;
802 -> 799;
802 -> 772;
803 -> 772;
804 -> 800;
804 -> 803;
805 -> 801;
805 -> 803;
806 -> 802;
806 -> 803;
807 -> 774;
807 -> 803;
808 -> 807;
808 -> 799;
808 -> 803;
809 -> 803;
810 -> 807;
810 -> 809;
811 -> 810;
811 -> 799;
811 -> 809;
812 -> 811;
812 -> 809;
813 -> 812;
813 -> 803;
814 -> 803;
815 -> 808;
815 -> 814;
816 -> 815;
816 -> 808;
816 -> 814;
817 -> 803;
818 -> 816;
818 -> 817;
819 -> 804;
819 -> 803;
820 -> 805;
820 -> 803;
821 -> 806;
821 -> 803;
822 -> 803;
823 -> 803;
824 -> 808;
824 -> 823;
825 -> 808;
825 -> 823;
826 -> 808;
826 -> 823;
827 -> 813;
827 -> 823;
828 -> 816;
828 -> 823;
829 -> 818;
829 -> 823;
830 -> 818;
830 -> 823;
831 -> 819;
831 -> 823;
832 -> 820;
832 -> 823;
833 -> 821;
833 -> 823;
834 -> 818;
834 -> 823;
835 -> 822;
835 -> 823;
836 -> 822;
836 -> 823;
837 -> 827;
837 -> 823;
838 -> 828;
838 -> 823;
839 -> 829;
839 -> 823;
840 -> 833;
840 -> 818;
840 -> 823;
841 -> 835;
841 -> 823;
842 -> 823;
843 -> 837;
843 -> 842;
844 -> 838;
844 -> 842;
845 -> 839;
845 -> 842;
846 -> 841;
846 -> 842;
847 -> 836;
847 -> 842;
848 -> 846;
848 -> 842;
849 -> 842;
850 -> 849;
850 -> 842;
851 -> 849;
851 -> 842;
852 -> 849;
852 -> 842;
853 -> 849;
853 -> 842;
854 -> 849;
854 -> 842;
855 -> 849;
855 -> 842;
856 -> 849;
856 -> 842;
857 -> 849;
857 -> 842;
858 -> 849;
858 -> 842;
859 -> 849;
859 -> 842;
860 -> 849;
860 -> 842;
861 -> 849;
861 -> 842;
862 -> 849;
862 -> 842;
863 -> 849;
863 -> 842;
864 -> 849;
864 -> 842;
865 -> 849;
865 -> 842;
866 -> 849;
866 -> 842;
867 -> 849;
867 -> 842;
868 -> 849;
868 -> 842;
869 -> 849;
869 -> 842;
870 -> 849;
870 -> 842;
871 -> 849;
871 -> 842;
872 -> 849;
872 -> 842;
873 -> 849;
873 -> 842;
874 -> 849;
874 -> 842;
875 -> 849;
875 -> 842;
876 -> 842;
877 -> 876;
877 -> 849;
877 -> 842;
878 -> 849;
878 -> 842;
879 -> 849;
879 -> 842;
880 -> 849;
880 -> 842;
881 -> 849;
881 -> 842;
882 -> 849;
882 -> 842;
883 -> 849;
883 -> 842;
884 -> 849;
884 -> 842;
885 -> 842;
886 -> 842;
887 -> 884;
887 -> 886;
888 -> 885;
888 -> 886;
889 -> 886;
890 -> 888;
890 -> 889;
891 -> 889;
892 -> 888;
892 -> 886;
893 -> 887;
893 -> 888;
893 -> 886;
894 -> 885;
894 -> 849;
894 -> 842;
895 -> 849;
895 -> 842;
896 -> 849;
896 -> 842;
897 -> 842;
898 -> 842;
899 -> 896;
899 -> 898;
900 -> 897;
900 -> 898;
901 -> 898;
902 -> 901;
902 -> 898;
903 -> 901;
903 -> 898;
904 -> 901;
904 -> 898;
905 -> 898;
906 -> 905;
906 -> 901;
906 -> 898;
907 -> 898;
908 -> 899;
908 -> 907;
908 -> 898;
909 -> 899;
909 -> 901;
909 -> 898;
910 -> 897;
910 -> 849;
910 -> 842;
911 -> 842;
912 -> 840;
912 -> 911;
913 -> 911;
914 -> 912;
914 -> 911;
915 -> 914;
915 -> 840;
915 -> 910;
915 -> 901;
915 -> 902;
915 -> 909;
915 -> 903;
915 -> 904;
915 -> 906;
915 -> 905;
916 -> 914;
917 -> 915;
917 -> 916;
918 -> 830;
918 -> 842;
919 -> 918;
920 -> 843;
920 -> 919;
920 -> 918;
921 -> 844;
921 -> 919;
921 -> 918;
922 -> 920;
922 -> 921;
922 -> 918;
923 -> 845;
923 -> 919;
923 -> 918;
924 -> 922;
924 -> 923;
924 -> 918;
925 -> 831;
925 -> 832;
926 -> 849;
926 -> 832;
927 -> 831;
927 -> 926;
927 -> 840;
927 -> 910;
927 -> 917;
927 -> 901;
927 -> 902;
927 -> 909;
927 -> 903;
927 -> 904;
927 -> 906;
927 -> 905;
927 -> 832;
928 -> 831;
928 -> 849;
928 -> 832;
929 -> 849;
929 -> 927;
929 -> 842;
930 -> 842;
931 -> 849;
931 -> 927;
931 -> 930;
931 -> 842;
932 -> 822;
932 -> 772;
933 -> 932;
933 -> 770;
934 -> 933;
934 -> 927;
934 -> 575;
935 -> 933;
935 -> 575;
936 -> 552;
936 -> 935;
936 -> 927;
936 -> 928;
936 -> 833;
936 -> 260;
937 -> 936;
937 -> 260;
938 -> 260;
939 -> 937;
939 -> 938;
940 -> 938;
941 -> 939;
941 -> 940;
942 -> 941;
942 -> 936;
942 -> 940;
943 -> 942;
943 -> 938;
944 -> 943;
944 -> 942;
944 -> 938;
945 -> 938;
946 -> 943;
946 -> 945;
946 -> 942;
946 -> 938;
947 -> 0;
947 -> 938;
948 -> 946;
948 -> 947;
948 -> 938;
949 -> 267;
949 -> 948;
949 -> 260;
950 -> 936;
950 -> 260;
951 -> 1;
952 -> 950;
952 -> 951;
953 -> 952;
953 -> 948;
953 -> 951;
954 -> 953;
955 -> 954;
955 -> 953;
956 -> 953;
957 -> 955;
957 -> 956;
958 -> 952;
958 -> 956;
959 -> 956;
960 -> 958;
960 -> 959;
961 -> 959;
962 -> 960;
962 -> 961;
963 -> 961;
964 -> 962;
964 -> 963;
965 -> 964;
965 -> 948;
965 -> 963;
966 -> 964;
966 -> 965;
967 -> 965;
968 -> 966;
968 -> 967;
969 -> 964;
969 -> 948;
969 -> 967;
970 -> 968;
970 -> 967;
971 -> 967;
972 -> 970;
972 -> 971;
973 -> 969;
973 -> 971;
974 -> 971;
975 -> 971;
976 -> 971;
977 -> 972;
977 -> 976;
978 -> 977;
978 -> 971;
979 -> 971;
980 -> 971;
981 -> 980;
981 -> 971;
982 -> 971;
983 -> 982;
983 -> 971;
984 -> 971;
985 -> 984;
985 -> 971;
986 -> 971;
987 -> 986;
987 -> 971;
988 -> 972;
988 -> 971;
989 -> 975;
989 -> 971;
990 -> 986;
990 -> 971;
991 -> 979;
991 -> 971;
992 -> 980;
992 -> 971;
993 -> 982;
993 -> 971;
994 -> 984;
994 -> 971;
995 -> 974;
995 -> 971;
996 -> 988;
996 -> 989;
996 -> 990;
996 -> 991;
996 -> 992;
996 -> 993;
996 -> 994;
996 -> 995;
996 -> 973;
996 -> 948;
996 -> 975;
996 -> 974;
996 -> 987;
996 -> 981;
996 -> 983;
996 -> 985;
996 -> 971;
997 -> 971;
998 -> 996;
998 -> 997;
999 -> 997;
1000 -> 998;
1000 -> 999;
1001 -> 1000;
1001 -> 996;
1001 -> 999;
1002 -> 1001;
1002 -> 997;
1003 -> 0;
1004 -> 0;
1004 -> 1003;
1005 -> 0;
1006 -> 1004;
1006 -> 0;
1006 -> 1005;
1007 -> 1006;
1008 -> 997;
1009 -> 1002;
1009 -> 1008;
1010 -> 1002;
1010 -> 1008;
1011 -> 1008;
1012 -> 1009;
1012 -> 1002;
1012 -> 1011;
1012 -> 1008;
1013 -> 1002;
1013 -> 1008;
1014 -> 1002;
1014 -> 1008;
1015 -> 0;
1015 -> 1008;
1016 -> 1008;
1017 -> 1008;
1018 -> 1013;
1018 -> 1008;
1019 -> 1015;
1019 -> 0;
1019 -> 1008;
1020 -> 1015;
1020 -> 1008;
1021 -> 1020;
1021 -> 997;
1022 -> 1002;
1022 -> 1021;
1022 -> 997;
1023 -> 1009;
1023 -> 1022;
1023 -> 1011;
1023 -> 1008;
1024 -> 1018;
1024 -> 1022;
1024 -> 1008;
1025 -> 996;
1025 -> 997;
1026 -> 1025;
1026 -> 1022;
1026 -> 997;
1027 -> 996;
1027 -> 997;
1028 -> 0;
1028 -> 997;
1029 -> 996;
1029 -> 1028;
1029 -> 1026;
1029 -> 971;
1030 -> 996;
1030 -> 997;
1031 -> 996;
1031 -> 997;
1032 -> 996;
1032 -> 997;
1033 -> 996;
1033 -> 997;
1034 -> 996;
1034 -> 997;
1035 -> 996;
1035 -> 997;
1036 -> 996;
1036 -> 997;
1037 -> 1030;
1037 -> 997;
1038 -> 1031;
1038 -> 997;
1039 -> 1035;
1039 -> 997;
1040 -> 1032;
1040 -> 997;
1041 -> 1033;
1041 -> 997;
1042 -> 1034;
1042 -> 997;
1043 -> 997;
1044 -> 997;
1045 -> 1037;
1045 -> 1044;
1046 -> 1038;
1046 -> 1044;
1047 -> 1039;
1047 -> 1044;
1048 -> 1040;
1048 -> 1044;
1049 -> 1041;
1049 -> 1044;
1050 -> 1042;
1050 -> 1044;
1051 -> 1043;
1051 -> 1044;
1052 -> 1045;
1052 -> 1029;
1052 -> 1044;
1053 -> 1045;
1053 -> 1029;
1053 -> 1044;
1054 -> 1047;
1054 -> 1044;
1055 -> 1044;
1056 -> 1052;
1056 -> 1055;
1057 -> 1053;
1057 -> 1055;
1058 -> 1054;
1058 -> 1055;
1059 -> 1051;
1059 -> 1055;
1060 -> 1055;
1061 -> 1060;
1061 -> 1055;
1062 -> 1060;
1062 -> 1055;
1063 -> 1060;
1063 -> 1055;
1064 -> 1055;
1065 -> 1056;
1065 -> 1064;
1065 -> 1055;
1066 -> 1057;
1066 -> 1029;
1066 -> 1055;
1067 -> 1058;
1067 -> 1060;
1067 -> 1055;
1068 -> 1056;
1068 -> 1060;
1068 -> 1055;
1069 -> 1057;
1069 -> 1060;
1069 -> 1055;
1070 -> 1051;
1070 -> 1044;
1071 -> 1051;
1071 -> 1044;
1072 -> 1051;
1072 -> 1044;
1073 -> 1051;
1073 -> 1044;
1074 -> 1051;
1074 -> 1044;
1075 -> 1051;
1075 -> 1044;
1076 -> 1051;
1076 -> 1044;
1077 -> 1044;
1078 -> 1048;
1078 -> 1077;
1078 -> 1044;
1079 -> 1044;
1080 -> 1046;
1080 -> 1079;
1080 -> 1044;
1081 -> 1046;
1081 -> 1051;
1081 -> 1044;
1082 -> 1045;
1082 -> 1051;
1082 -> 1044;
1083 -> 1048;
1083 -> 1051;
1083 -> 1044;
1084 -> 1050;
1084 -> 1051;
1084 -> 1044;
1085 -> 1049;
1085 -> 1051;
1085 -> 1044;
1086 -> 996;
1086 -> 1043;
1086 -> 1029;
1086 -> 1060;
1086 -> 1061;
1086 -> 1062;
1086 -> 1068;
1086 -> 1063;
1086 -> 1067;
1086 -> 1069;
1086 -> 1070;
1086 -> 1082;
1086 -> 1071;
1086 -> 1081;
1086 -> 1072;
1086 -> 1083;
1086 -> 1073;
1086 -> 1084;
1086 -> 1074;
1086 -> 1085;
1086 -> 1075;
1086 -> 1076;
1086 -> 971;
1087 -> 1086;
1087 -> 1064;
1087 -> 1055;
1088 -> 1086;
1088 -> 1055;
1089 -> 973;
1089 -> 1086;
1089 -> 971;
1090 -> 971;
1091 -> 1086;
1091 -> 971;
1092 -> 1089;
1092 -> 1090;
1093 -> 1092;
1093 -> 1089;
1093 -> 1090;
1094 -> 971;
1095 -> 1093;
1095 -> 971;
1096 -> 971;
1097 -> 971;
1098 -> 971;
1099 -> 1098;
1099 -> 971;
1100 -> 971;
1101 -> 1100;
1101 -> 971;
1102 -> 971;
1103 -> 1102;
1103 -> 971;
1104 -> 972;
1104 -> 1095;
1104 -> 971;
1105 -> 971;
1106 -> 1104;
1106 -> 1105;
1106 -> 971;
1107 -> 1106;
1107 -> 971;
1108 -> 971;
1109 -> 1107;
1109 -> 1108;
1109 -> 971;
1110 -> 1109;
1110 -> 971;
1111 -> 971;
1112 -> 1110;
1112 -> 1111;
1112 -> 971;
1113 -> 1112;
1113 -> 971;
1114 -> 0;
1114 -> 971;
1115 -> 1114;
1115 -> 1113;
1115 -> 971;
1116 -> 972;
1116 -> 971;
1117 -> 1095;
1117 -> 971;
1118 -> 1086;
1118 -> 971;
1119 -> 971;
1120 -> 972;
1120 -> 1119;
1121 -> 1120;
1121 -> 1095;
1121 -> 1119;
1122 -> 1121;
1122 -> 971;
1123 -> 971;
1124 -> 972;
1124 -> 1123;
1125 -> 1124;
1125 -> 1095;
1125 -> 1123;
1126 -> 1125;
1126 -> 971;
1127 -> 978;
1127 -> 971;
1128 -> 975;
1128 -> 971;
1129 -> 1102;
1129 -> 971;
1130 -> 1098;
1130 -> 971;
1131 -> 1100;
1131 -> 971;
1132 -> 1115;
1132 -> 971;
1133 -> 974;
1133 -> 971;
1134 -> 1096;
1134 -> 971;
1135 -> 1097;
1135 -> 971;
1136 -> 1116;
1136 -> 1117;
1136 -> 1118;
1136 -> 1122;
1136 -> 1126;
1136 -> 1127;
1136 -> 1128;
1136 -> 1129;
1136 -> 1130;
1136 -> 1131;
1136 -> 1132;
1136 -> 1133;
1136 -> 1134;
1136 -> 1135;
1136 -> 973;
1136 -> 1095;
1136 -> 1086;
1136 -> 1103;
1136 -> 1099;
1136 -> 1101;
1136 -> 0;
1136 -> 971;
1137 -> 971;
1138 -> 1136;
1138 -> 1137;
1139 -> 1136;
1139 -> 1137;
1140 -> 1136;
1140 -> 1137;
1141 -> 1140;
1141 -> 1136;
1141 -> 1137;
1142 -> 1138;
1142 -> 1137;
1143 -> 1137;
1144 -> 1139;
1144 -> 1137;
1145 -> 1141;
1145 -> 1142;
1145 -> 1143;
1145 -> 1144;
1145 -> 1136;
1145 -> 1137;
1146 -> 1136;
1146 -> 1137;
1147 -> 1146;
1147 -> 1145;
1147 -> 1137;
1148 -> 1136;
1148 -> 1137;
1149 -> 1148;
1149 -> 1147;
1149 -> 1137;
1150 -> 1136;
1150 -> 1137;
1151 -> 1150;
1151 -> 1149;
1151 -> 1137;
1152 -> 1136;
1152 -> 1137;
1153 -> 1152;
1153 -> 1151;
1153 -> 1137;
1154 -> 1136;
1154 -> 1137;
1155 -> 1137;
1156 -> 1154;
1156 -> 1153;
1156 -> 1155;
1156 -> 1137;
1157 -> 1156;
1158 -> 1157;
1158 -> 1154;
1158 -> 1156;
1159 -> 1154;
1159 -> 1153;
1159 -> 1158;
1159 -> 1156;
1160 -> 1156;
1161 -> 1159;
1161 -> 1160;
1162 -> 1154;
1162 -> 1160;
1163 -> 1162;
1163 -> 1153;
1163 -> 1160;
1164 -> 1163;
1164 -> 1153;
1164 -> 1158;
1164 -> 1160;
1165 -> 1156;
1166 -> 1154;
1166 -> 1153;
1166 -> 1158;
1166 -> 1137;
1167 -> 1154;
1167 -> 1166;
1168 -> 1166;
1169 -> 1167;
1169 -> 1168;
1170 -> 1154;
1170 -> 1168;
1171 -> 1170;
1171 -> 1166;
1171 -> 1168;
1172 -> 1166;
1173 -> 1166;
1173 -> 971;
1174 -> 1166;
1174 -> 971;
1175 -> 1166;
1175 -> 971;
1176 -> 1086;
1176 -> 1175;
1176 -> 1166;
1176 -> 1174;
1176 -> 971;
1177 -> 971;
1178 -> 971;
1179 -> 1178;
1179 -> 971;
1180 -> 1166;
1180 -> 971;
1181 -> 1174;
1181 -> 971;
1182 -> 1176;
1182 -> 971;
1183 -> 1086;
1183 -> 971;
1184 -> 1086;
1184 -> 1176;
1184 -> 971;
1185 -> 975;
1185 -> 971;
1186 -> 978;
1186 -> 971;
1187 -> 1177;
1187 -> 971;
1188 -> 1178;
1188 -> 971;
1189 -> 1180;
1189 -> 1181;
1189 -> 1182;
1189 -> 1183;
1189 -> 1184;
1189 -> 1185;
1189 -> 1186;
1189 -> 1187;
1189 -> 1188;
1189 -> 1176;
1189 -> 1174;
1189 -> 1179;
1189 -> 971;
1190 -> 971;
1191 -> 971;
1192 -> 1191;
1192 -> 1166;
1192 -> 1189;
1192 -> 971;
1193 -> 1166;
1193 -> 1189;
1193 -> 1191;
1193 -> 1192;
1194 -> 1193;
1194 -> 1189;
1194 -> 1192;
1195 -> 1166;
1195 -> 1191;
1195 -> 1189;
1195 -> 1194;
1196 -> 1194;
1197 -> 1195;
1197 -> 1196;
1198 -> 1197;
1198 -> 1195;
1198 -> 1196;
1199 -> 1196;
1200 -> 1197;
1200 -> 1199;
1201 -> 1200;
1201 -> 1196;
1202 -> 1196;
1203 -> 1197;
1203 -> 1202;
1204 -> 1202;
1205 -> 1203;
1205 -> 1204;
1206 -> 1205;
1206 -> 1195;
1206 -> 1204;
1207 -> 1205;
1207 -> 1195;
1207 -> 1206;
1208 -> 1207;
1208 -> 1205;
1208 -> 1206;
1209 -> 1206;
1210 -> 1209;
1210 -> 1205;
1210 -> 1206;
1211 -> 1205;
1211 -> 1207;
1211 -> 1208;
1211 -> 1204;
1212 -> 1211;
1212 -> 1202;
1213 -> 1203;
1213 -> 1207;
1213 -> 1202;
1214 -> 1213;
1214 -> 1196;
1215 -> 1196;
1216 -> 1196;
1217 -> 1198;
1217 -> 1216;
1218 -> 1198;
1218 -> 1216;
1219 -> 1201;
1219 -> 1216;
1220 -> 1214;
1220 -> 1216;
1221 -> 1215;
1221 -> 1216;
1222 -> 1216;
1223 -> 1221;
1223 -> 1222;
1224 -> 1222;
1225 -> 1223;
1225 -> 1224;
1228 -> 1227;
1228 -> 1226;
1229 -> 1226;
1230 -> 1224;
1231 -> 1225;
1231 -> 1230;
1232 -> 1230;
1233 -> 1231;
1233 -> 1232;
1234 -> 1233;
1234 -> 1232;
1235 -> 1231;
1235 -> 1230;
1236 -> 1224;
1237 -> 1236;
1237 -> 1225;
1237 -> 1224;
1238 -> 1225;
1238 -> 1224;
1239 -> 1223;
1239 -> 1222;
1240 -> 1223;
1240 -> 1222;
1241 -> 1223;
1241 -> 1222;
1242 -> 1223;
1242 -> 1222;
1243 -> 1223;
1243 -> 1222;
1244 -> 1223;
1244 -> 1222;
1245 -> 1223;
1245 -> 1222;
1246 -> 1221;
1246 -> 1216;
1247 -> 1221;
1247 -> 1216;
1248 -> 1221;
1248 -> 1216;
1249 -> 1216;
1250 -> 1217;
1250 -> 1249;
1250 -> 1216;
1251 -> 1216;
1252 -> 1218;
1252 -> 1251;
1252 -> 1216;
1253 -> 1217;
1253 -> 1221;
1253 -> 1216;
1254 -> 1218;
1254 -> 1221;
1254 -> 1216;
1255 -> 1217;
1255 -> 1207;
1255 -> 1208;
1255 -> 1210;
1255 -> 1216;
1256 -> 1216;
1257 -> 1256;
1257 -> 1217;
1257 -> 1207;
1257 -> 1208;
1257 -> 1210;
1257 -> 1216;
1258 -> 1221;
1258 -> 1257;
1260 -> 1259;
1261 -> 1217;
1261 -> 1207;
1261 -> 1256;
1261 -> 1208;
1261 -> 1210;
1261 -> 1257;
1262 -> 1220;
1262 -> 1257;
1263 -> 1256;
1263 -> 1257;
1264 -> 1257;
1265 -> 1257;
1266 -> 1258;
1266 -> 1265;
1267 -> 1261;
1267 -> 1265;
1268 -> 1262;
1268 -> 1265;
1269 -> 1263;
1269 -> 1265;
1270 -> 1264;
1270 -> 1265;
1271 -> 1266;
1271 -> 1265;
1272 -> 1267;
1272 -> 1265;
1273 -> 1268;
1273 -> 1265;
1274 -> 1269;
1274 -> 1265;
1275 -> 1265;
1276 -> 1271;
1276 -> 1275;
1277 -> 1272;
1277 -> 1275;
1278 -> 1273;
1278 -> 1275;
1279 -> 1274;
1279 -> 1275;
1280 -> 1270;
1280 -> 1275;
1281 -> 1275;
1282 -> 1280;
1282 -> 1281;
1283 -> 1281;
1284 -> 1282;
1284 -> 1283;
1285 -> 1283;
1286 -> 1284;
1286 -> 1285;
1287 -> 1286;
1287 -> 1285;
1288 -> 1282;
1288 -> 1281;
1289 -> 1280;
1289 -> 1275;
1290 -> 1280;
1290 -> 1275;
1291 -> 1280;
1291 -> 1275;
1292 -> 1280;
1292 -> 1275;
1293 -> 1280;
1293 -> 1275;
1294 -> 1280;
1294 -> 1275;
1295 -> 1280;
1295 -> 1275;
1296 -> 1275;
1297 -> 1296;
1297 -> 1275;
1298 -> 1260;
1298 -> 1275;
1299 -> 1297;
1299 -> 1298;
1299 -> 1275;
1300 -> 1299;
1300 -> 1280;
1300 -> 1275;
1301 -> 1275;
1302 -> 1301;
1302 -> 1275;
1303 -> 1260;
1303 -> 1275;
1304 -> 1302;
1304 -> 1303;
1304 -> 1275;
1305 -> 1304;
1305 -> 1280;
1305 -> 1275;
1306 -> 1280;
1306 -> 1275;
1307 -> 1280;
1307 -> 1275;
1308 -> 1280;
1308 -> 1275;
1309 -> 1280;
1309 -> 1275;
1310 -> 1275;
1311 -> 1276;
1311 -> 1310;
1311 -> 1275;
1312 -> 1275;
1313 -> 1277;
1313 -> 1312;
1313 -> 1275;
1314 -> 1276;
1314 -> 1280;
1314 -> 1275;
1315 -> 1279;
1315 -> 1280;
1315 -> 1275;
1316 -> 1277;
1316 -> 1280;
1316 -> 1275;
1317 -> 1278;
1317 -> 1280;
1317 -> 1275;
1318 -> 1280;
1318 -> 1275;
1319 -> 1275;
1320 -> 1275;
1321 -> 1318;
1321 -> 1320;
1322 -> 1319;
1322 -> 1320;
1323 -> 1320;
1324 -> 1322;
1324 -> 1323;
1325 -> 1323;
1326 -> 1324;
1326 -> 1325;
1327 -> 1325;
1328 -> 1326;
1328 -> 1327;
1329 -> 1327;
1330 -> 1328;
1330 -> 1329;
1331 -> 1330;
1331 -> 1329;
1332 -> 1326;
1332 -> 1325;
1333 -> 1326;
1333 -> 1325;
1334 -> 1324;
1334 -> 1323;
1335 -> 1324;
1335 -> 1323;
1336 -> 1324;
1336 -> 1323;
1337 -> 1322;
1337 -> 1320;
1338 -> 1320;
1339 -> 1321;
1339 -> 1338;
1339 -> 1320;
1340 -> 1321;
1340 -> 1322;
1340 -> 1320;
1341 -> 1319;
1341 -> 1280;
1341 -> 1275;
1342 -> 1280;
1342 -> 1275;
1343 -> 1342;
1343 -> 1287;
1343 -> 1288;
1343 -> 1314;
1343 -> 1315;
1343 -> 1316;
1343 -> 1341;
1343 -> 1293;
1343 -> 1294;
1343 -> 1295;
1343 -> 1300;
1343 -> 1305;
1343 -> 1317;
1343 -> 1307;
1343 -> 1308;
1343 -> 1309;
1343 -> 1299;
1343 -> 1304;
1343 -> 1234;
1343 -> 1235;
1343 -> 1237;
1343 -> 1238;
1343 -> 1239;
1343 -> 1240;
1343 -> 1241;
1343 -> 1242;
1343 -> 1243;
1343 -> 1244;
1343 -> 1245;
1343 -> 1253;
1343 -> 1254;
1343 -> 1248;
1343 -> 1236;
1343 -> 1261;
1343 -> 1331;
1343 -> 1332;
1343 -> 1333;
1343 -> 1334;
1343 -> 1335;
1343 -> 1336;
1343 -> 1340;
1343 -> 1275;
1344 -> 1343;
1344 -> 1280;
1344 -> 1275;
1345 -> 1265;
1346 -> 1269;
1346 -> 1345;
1346 -> 1265;
1347 -> 1264;
1347 -> 1256;
1347 -> 1255;
1347 -> 1257;
1348 -> 1255;
1348 -> 1216;
1349 -> 1348;
1349 -> 1255;
1349 -> 1347;
1349 -> 1343;
1349 -> 1344;
1349 -> 1216;
1350 -> 1349;
1350 -> 1221;
1350 -> 1216;
1351 -> 1219;
1351 -> 1221;
1351 -> 1216;
1352 -> 1215;
1352 -> 1194;
1353 -> 1352;
1353 -> 1193;
1353 -> 1194;
1354 -> 1191;
1354 -> 1194;
1355 -> 1190;
1355 -> 1354;
1355 -> 1194;
1356 -> 1166;
1356 -> 1191;
1356 -> 1349;
1356 -> 1350;
1356 -> 1351;
1356 -> 1192;
1357 -> 1192;
1358 -> 1356;
1358 -> 1357;
1359 -> 1192;
1360 -> 1193;
1360 -> 1189;
1360 -> 1353;
1360 -> 1359;
1361 -> 1360;
1361 -> 1356;
1361 -> 1359;
1362 -> 1358;
1362 -> 1361;
1362 -> 1192;
1363 -> 1356;
1364 -> 1363;
1364 -> 1356;
1365 -> 1356;
1366 -> 1356;
1367 -> 1356;
1368 -> 1356;
1369 -> 1356;
1370 -> 1356;
1371 -> 1356;
1372 -> 1356;
1373 -> 1356;
1374 -> 1356;
1375 -> 1356;
1376 -> 1356;
1377 -> 1356;
1378 -> 1356;
1379 -> 1356;
1380 -> 1192;
1380 -> 1356;
1381 -> 1190;
1381 -> 1355;
1381 -> 1380;
1381 -> 1356;
1382 -> 1356;
1383 -> 1356;
1384 -> 1356;
1384 -> 1379;
1384 -> 1383;
1385 -> 1384;
1385 -> 1356;
1385 -> 1383;
1386 -> 1382;
1386 -> 1385;
1386 -> 1356;
1387 -> 1382;
1387 -> 1356;
1388 -> 1382;
1388 -> 1356;
1389 -> 1382;
1390 -> 1382;
1391 -> 1382;
1392 -> 1382;
1393 -> 1382;
1394 -> 1382;
1395 -> 1382;
1396 -> 1382;
1397 -> 1382;
1398 -> 1382;
1398 -> 1378;
1398 -> 1356;
1399 -> 1382;
1399 -> 1356;
1400 -> 1356;
1401 -> 1356;
1401 -> 1399;
1401 -> 1383;
1402 -> 1401;
1402 -> 1382;
1402 -> 1383;
1403 -> 1382;
1404 -> 1403;
1404 -> 1382;
1405 -> 1382;
1406 -> 1382;
1407 -> 1382;
1408 -> 1382;
1409 -> 1382;
1410 -> 1382;
1411 -> 1356;
1411 -> 1382;
1412 -> 1190;
1412 -> 1355;
1412 -> 1381;
1412 -> 1411;
1412 -> 1382;
1413 -> 1382;
1414 -> 1382;
1414 -> 1410;
1414 -> 1413;
1415 -> 1414;
1415 -> 1382;
1415 -> 1413;
1416 -> 1382;
1417 -> 972;
1417 -> 971;
1418 -> 973;
1418 -> 1382;
1418 -> 971;
1419 -> 972;
1419 -> 1382;
1419 -> 971;
1420 -> 971;
1422 -> 1086;
1422 -> 971;
1423 -> 971;
1424 -> 1417;
1424 -> 1423;
1425 -> 1418;
1425 -> 1423;
1426 -> 1419;
1426 -> 1423;
1427 -> 1422;
1427 -> 1423;
1428 -> 1420;
1428 -> 1423;
1429 -> 1423;
1430 -> 1428;
1430 -> 1429;
1431 -> 1429;
1432 -> 1430;
1432 -> 1431;
1433 -> 1431;
1434 -> 1432;
1434 -> 1433;
1435 -> 1433;
1436 -> 1434;
1436 -> 1435;
1437 -> 1436;
1437 -> 1435;
1438 -> 1434;
1438 -> 1433;
1439 -> 1431;
1440 -> 1439;
1440 -> 1432;
1440 -> 1431;
1441 -> 1432;
1441 -> 1431;
1442 -> 1430;
1442 -> 1429;
1443 -> 1430;
1443 -> 1429;
1444 -> 1430;
1444 -> 1429;
1445 -> 1430;
1445 -> 1429;
1446 -> 1430;
1446 -> 1429;
1447 -> 1430;
1447 -> 1429;
1448 -> 1430;
1448 -> 1429;
1449 -> 1428;
1449 -> 1423;
1450 -> 1428;
1450 -> 1423;
1451 -> 1428;
1451 -> 1423;
1452 -> 1428;
1452 -> 1423;
1453 -> 1428;
1453 -> 1423;
1454 -> 1428;
1454 -> 1423;
1455 -> 1428;
1455 -> 1423;
1456 -> 1428;
1456 -> 1423;
1457 -> 1428;
1457 -> 1423;
1458 -> 1423;
1459 -> 1458;
1459 -> 1428;
1459 -> 1423;
1460 -> 1423;
1461 -> 1460;
1461 -> 1428;
1461 -> 1423;
1462 -> 1423;
1463 -> 1462;
1463 -> 1428;
1463 -> 1423;
1464 -> 1428;
1464 -> 1423;
1465 -> 1428;
1465 -> 1423;
1466 -> 1423;
1467 -> 1424;
1467 -> 1466;
1467 -> 1423;
1468 -> 1423;
1469 -> 1425;
1469 -> 1468;
1469 -> 1423;
1470 -> 1426;
1470 -> 1423;
1471 -> 1427;
1471 -> 1086;
1471 -> 1423;
1472 -> 1424;
1472 -> 1428;
1472 -> 1423;
1473 -> 1425;
1473 -> 1428;
1473 -> 1423;
1474 -> 1423;
1475 -> 1474;
1475 -> 1427;
1475 -> 1086;
1475 -> 1423;
1476 -> 1428;
1476 -> 1423;
1477 -> 1423;
1478 -> 1424;
1478 -> 1477;
1479 -> 1478;
1479 -> 1419;
1479 -> 1477;
1480 -> 1479;
1480 -> 1423;
1481 -> 1426;
1481 -> 1423;
1482 -> 1423;
1483 -> 1423;
1484 -> 1476;
1484 -> 1483;
1485 -> 1480;
1485 -> 1483;
1486 -> 1481;
1486 -> 1483;
1487 -> 1482;
1487 -> 1483;
1488 -> 1483;
1489 -> 1487;
1489 -> 1488;
1490 -> 1488;
1491 -> 1489;
1491 -> 1490;
1492 -> 1490;
1493 -> 1491;
1493 -> 1492;
1494 -> 1493;
1494 -> 1492;
1495 -> 1489;
1495 -> 1488;
1496 -> 1487;
1496 -> 1483;
1497 -> 0;
1497 -> 1487;
1497 -> 1483;
1498 -> 1487;
1498 -> 1483;
1499 -> 1487;
1499 -> 1483;
1500 -> 1487;
1500 -> 1483;
1501 -> 1487;
1501 -> 1483;
1502 -> 1487;
1502 -> 1483;
1503 -> 1483;
1504 -> 1484;
1504 -> 1503;
1504 -> 1483;
1505 -> 1484;
1505 -> 1487;
1505 -> 1483;
1506 -> 1485;
1506 -> 1487;
1506 -> 1483;
1507 -> 1486;
1507 -> 1487;
1507 -> 1483;
1508 -> 1475;
1508 -> 1482;
1508 -> 1494;
1508 -> 1495;
1508 -> 1505;
1508 -> 1497;
1508 -> 1506;
1508 -> 1499;
1508 -> 1500;
1508 -> 1501;
1508 -> 1507;
1508 -> 1437;
1508 -> 1438;
1508 -> 1440;
1508 -> 1441;
1508 -> 1442;
1508 -> 1443;
1508 -> 1444;
1508 -> 1445;
1508 -> 1446;
1508 -> 1447;
1508 -> 1448;
1508 -> 1472;
1508 -> 1450;
1508 -> 1473;
1508 -> 1452;
1508 -> 1453;
1508 -> 1454;
1508 -> 1455;
1508 -> 1456;
1508 -> 1457;
1508 -> 1459;
1508 -> 1461;
1508 -> 1463;
1508 -> 1464;
1508 -> 1465;
1508 -> 1439;
1508 -> 1479;
1508 -> 1458;
1508 -> 1460;
1508 -> 1462;
1508 -> 1423;
1509 -> 1423;
1510 -> 1424;
1510 -> 1509;
1511 -> 1510;
1511 -> 1508;
1511 -> 1509;
1512 -> 1511;
1512 -> 1423;
1513 -> 1512;
1513 -> 1423;
1514 -> 1427;
1514 -> 1423;
1515 -> 1475;
1515 -> 1508;
1515 -> 1423;
1516 -> 1515;
1516 -> 1428;
1516 -> 1423;
1517 -> 1423;
1518 -> 1424;
1518 -> 1517;
1519 -> 1518;
1519 -> 1508;
1519 -> 1517;
1520 -> 1519;
1520 -> 1423;
1521 -> 1520;
1521 -> 1508;
1521 -> 1516;
1521 -> 1423;
1522 -> 971;
1523 -> 971;
1524 -> 1166;
1524 -> 1523;
1524 -> 971;
1525 -> 1524;
1526 -> 1166;
1526 -> 1508;
1526 -> 1516;
1526 -> 1525;
1527 -> 1526;
1527 -> 971;
1528 -> 971;
1529 -> 1527;
1529 -> 1528;
1530 -> 1420;
1530 -> 1528;
1531 -> 1528;
1532 -> 1530;
1532 -> 1508;
1532 -> 1531;
1532 -> 1528;
1533 -> 1529;
1533 -> 1530;
1533 -> 1528;
1534 -> 971;
1535 -> 971;
1536 -> 971;
1537 -> 1166;
1537 -> 1508;
1537 -> 1536;
1537 -> 971;
1538 -> 971;
1539 -> 1538;
1539 -> 971;
1540 -> 1420;
1540 -> 971;
1541 -> 1086;
1541 -> 971;
1542 -> 1537;
1542 -> 971;
1543 -> 1166;
1543 -> 971;
1544 -> 1535;
1544 -> 971;
1545 -> 1538;
1545 -> 971;
1546 -> 971;
1547 -> 1540;
1547 -> 1546;
1548 -> 1541;
1548 -> 1546;
1549 -> 1542;
1549 -> 1546;
1550 -> 1543;
1550 -> 1546;
1551 -> 1544;
1551 -> 1546;
1552 -> 1545;
1552 -> 1546;
1553 -> 1546;
1554 -> 1547;
1554 -> 1553;
1555 -> 1554;
1555 -> 1508;
1555 -> 1516;
1555 -> 1553;
1556 -> 1555;
1556 -> 1546;
1557 -> 1546;
1558 -> 1557;
1558 -> 1548;
1558 -> 1086;
1558 -> 1546;
1559 -> 1556;
1559 -> 1508;
1559 -> 1515;
1559 -> 1558;
1559 -> 1546;
1560 -> 1546;
1561 -> 1556;
1561 -> 1508;
1561 -> 1515;
1561 -> 1560;
1561 -> 1546;
1562 -> 1561;
1562 -> 1546;
1563 -> 1546;
1564 -> 1546;
1565 -> 1564;
1565 -> 1556;
1565 -> 1508;
1565 -> 1515;
1565 -> 1546;
1566 -> 1565;
1567 -> 1566;
1567 -> 1565;
1568 -> 1549;
1568 -> 1567;
1569 -> 1568;
1569 -> 1565;
1570 -> 1568;
1570 -> 1565;
1571 -> 1565;
1572 -> 1565;
1573 -> 1572;
1573 -> 1568;
1573 -> 1565;
1574 -> 1573;
1575 -> 1550;
1575 -> 1508;
1575 -> 1516;
1575 -> 1533;
1575 -> 1574;
1575 -> 1573;
1576 -> 1573;
1577 -> 1550;
1577 -> 1508;
1577 -> 1516;
1577 -> 1533;
1577 -> 1576;
1577 -> 1573;
1578 -> 1563;
1578 -> 1572;
1578 -> 1573;
1579 -> 1577;
1579 -> 1508;
1579 -> 1516;
1579 -> 1533;
1579 -> 1515;
1579 -> 1578;
1579 -> 1573;
1580 -> 1579;
1580 -> 1508;
1580 -> 1515;
1580 -> 1573;
1581 -> 1579;
1581 -> 1508;
1581 -> 1515;
1581 -> 1573;
1582 -> 1550;
1582 -> 1581;
1583 -> 1579;
1583 -> 1581;
1584 -> 1571;
1584 -> 1581;
1585 -> 1581;
1586 -> 1582;
1586 -> 1585;
1587 -> 1583;
1587 -> 1585;
1588 -> 1584;
1588 -> 1585;
1589 -> 1587;
1589 -> 1508;
1589 -> 1515;
1589 -> 1585;
1590 -> 1587;
1590 -> 1508;
1590 -> 1515;
1590 -> 1585;
1591 -> 1586;
1591 -> 1508;
1591 -> 1516;
1591 -> 1533;
1591 -> 1587;
1591 -> 1515;
1591 -> 1585;
1592 -> 1591;
1592 -> 1585;
1593 -> 1585;
1594 -> 1587;
1594 -> 1508;
1594 -> 1515;
1594 -> 1593;
1594 -> 1585;
1595 -> 1591;
1595 -> 1585;
1596 -> 1595;
1596 -> 1572;
1596 -> 1570;
1596 -> 1581;
1597 -> 1579;
1597 -> 1508;
1597 -> 1515;
1597 -> 1572;
1597 -> 1569;
1597 -> 1573;
1598 -> 1563;
1598 -> 1573;
1599 -> 1577;
1599 -> 1508;
1599 -> 1516;
1599 -> 1533;
1599 -> 1515;
1599 -> 1598;
1599 -> 1573;
1600 -> 1599;
1600 -> 1508;
1600 -> 1515;
1600 -> 1573;
1601 -> 1599;
1601 -> 1508;
1601 -> 1515;
1601 -> 1573;
1602 -> 1550;
1602 -> 1601;
1603 -> 1599;
1603 -> 1601;
1604 -> 1601;
1605 -> 1602;
1605 -> 1604;
1606 -> 1603;
1606 -> 1604;
1607 -> 1606;
1607 -> 1508;
1607 -> 1515;
1607 -> 1604;
1608 -> 1606;
1608 -> 1508;
1608 -> 1515;
1608 -> 1604;
1609 -> 1605;
1609 -> 1508;
1609 -> 1516;
1609 -> 1533;
1609 -> 1606;
1609 -> 1515;
1609 -> 1604;
1610 -> 1609;
1610 -> 1604;
1611 -> 1604;
1612 -> 1606;
1612 -> 1508;
1612 -> 1515;
1612 -> 1611;
1612 -> 1604;
1613 -> 1609;
1613 -> 1604;
1614 -> 1613;
1614 -> 1573;
1614 -> 1570;
1614 -> 1601;
1615 -> 1599;
1615 -> 1508;
1615 -> 1515;
1615 -> 1573;
1615 -> 1569;
1616 -> 1569;
1616 -> 1565;
1617 -> 1616;
1617 -> 1569;
1617 -> 1597;
1617 -> 1615;
1617 -> 1508;
1617 -> 1516;
1617 -> 1533;
1617 -> 1515;
1617 -> 1565;
1618 -> 1570;
1618 -> 1565;
1619 -> 1618;
1619 -> 1570;
1619 -> 1596;
1619 -> 1614;
1619 -> 1617;
1619 -> 1565;
1620 -> 1588;
1620 -> 1565;
1621 -> 1617;
1621 -> 1619;
1621 -> 1620;
1621 -> 1565;
1622 -> 1565;
1623 -> 1556;
1623 -> 1564;
1623 -> 1508;
1623 -> 1516;
1623 -> 1533;
1623 -> 1515;
1623 -> 1621;
1623 -> 1565;
1624 -> 1621;
1624 -> 1565;
1625 -> 1547;
1625 -> 1565;
1626 -> 1565;
1627 -> 1624;
1627 -> 1626;
1628 -> 1625;
1628 -> 1626;
1629 -> 1623;
1629 -> 1626;
1630 -> 1626;
1631 -> 1627;
1631 -> 1630;
1631 -> 1626;
1632 -> 1626;
1633 -> 1629;
1633 -> 1632;
1634 -> 1632;
1635 -> 1633;
1635 -> 1623;
1635 -> 1634;
1635 -> 1632;
1636 -> 1626;
1637 -> 1627;
1637 -> 1629;
1637 -> 1626;
1638 -> 1565;
1639 -> 1563;
1639 -> 1568;
1639 -> 1565;
1640 -> 1562;
1640 -> 1546;
1641 -> 971;
1642 -> 971;
1643 -> 1190;
1643 -> 1355;
1643 -> 1381;
1643 -> 1412;
1643 -> 1642;
1643 -> 971;
1644 -> 1166;
1644 -> 1643;
1645 -> 1190;
1645 -> 1643;
1646 -> 1420;
1646 -> 1643;
1647 -> 1166;
1647 -> 1643;
1648 -> 1551;
1648 -> 1643;
1649 -> 1643;
1650 -> 1645;
1650 -> 1649;
1651 -> 1646;
1651 -> 1649;
1652 -> 1647;
1652 -> 1649;
1653 -> 1647;
1653 -> 1649;
1654 -> 1648;
1654 -> 1649;
1655 -> 1649;
1656 -> 1650;
1656 -> 1190;
1656 -> 1355;
1656 -> 1381;
1656 -> 1412;
1656 -> 1655;
1656 -> 1649;
1657 -> 1649;
1658 -> 1651;
1658 -> 1657;
1659 -> 1658;
1659 -> 1623;
1659 -> 1657;
1660 -> 1659;
1660 -> 1649;
1661 -> 1649;
1662 -> 1660;
1662 -> 1661;
1662 -> 1649;
1663 -> 1650;
1663 -> 1649;
1664 -> 1652;
1664 -> 1663;
1664 -> 1623;
1664 -> 1637;
1665 -> 1663;
1666 -> 1664;
1666 -> 1665;
1666 -> 1663;
1667 -> 1652;
1667 -> 1663;
1667 -> 1664;
1667 -> 1666;
1668 -> 1667;
1668 -> 1666;
1669 -> 1653;
1669 -> 1666;
1670 -> 1653;
1670 -> 1667;
1670 -> 1663;
1670 -> 1666;
1671 -> 1654;
1671 -> 1666;
1672 -> 1651;
1672 -> 1666;
1673 -> 1666;
1674 -> 1668;
1674 -> 1673;
1675 -> 1669;
1675 -> 1673;
1676 -> 1670;
1676 -> 1673;
1677 -> 1671;
1677 -> 1673;
1678 -> 1672;
1678 -> 1673;
1679 -> 1676;
1679 -> 1667;
1679 -> 1673;
1680 -> 1676;
1680 -> 1667;
1680 -> 1673;
1681 -> 1676;
1681 -> 1667;
1681 -> 1673;
1682 -> 1673;
1683 -> 1681;
1683 -> 1682;
1684 -> 1683;
1684 -> 1667;
1684 -> 1682;
1685 -> 1684;
1685 -> 1673;
1686 -> 1685;
1686 -> 1667;
1686 -> 1673;
1687 -> 1673;
1688 -> 1673;
1689 -> 1688;
1689 -> 1686;
1689 -> 1673;
1690 -> 1674;
1690 -> 1667;
1690 -> 1688;
1690 -> 1689;
1691 -> 1690;
1691 -> 1689;
1692 -> 1690;
1692 -> 1689;
1693 -> 1689;
1694 -> 1674;
1694 -> 1693;
1695 -> 1694;
1695 -> 1690;
1695 -> 1693;
1696 -> 1695;
1696 -> 1689;
1697 -> 1687;
1697 -> 1689;
1698 -> 1691;
1698 -> 1689;
1699 -> 1689;
1700 -> 1690;
1700 -> 1689;
1701 -> 1696;
1701 -> 1697;
1701 -> 1698;
1701 -> 1699;
1701 -> 1700;
1701 -> 1690;
1701 -> 1691;
1701 -> 1689;
1702 -> 1689;
1703 -> 1689;
1704 -> 1703;
1704 -> 1690;
1704 -> 1689;
1705 -> 1691;
1705 -> 1689;
1706 -> 1705;
1706 -> 1701;
1706 -> 1689;
1707 -> 1692;
1707 -> 1689;
1708 -> 1702;
1708 -> 1689;
1709 -> 1706;
1709 -> 1707;
1709 -> 1708;
1709 -> 1689;
1710 -> 1685;
1710 -> 1688;
1710 -> 1667;
1710 -> 1709;
1710 -> 1689;
1711 -> 1709;
1711 -> 1689;
1712 -> 1678;
1712 -> 1689;
1713 -> 1689;
1714 -> 1711;
1714 -> 1713;
1715 -> 1712;
1715 -> 1713;
1716 -> 1710;
1716 -> 1713;
1717 -> 1713;
1718 -> 1714;
1718 -> 1717;
1718 -> 1713;
1719 -> 1713;
1720 -> 1716;
1720 -> 1719;
1721 -> 1719;
1722 -> 1720;
1722 -> 1710;
1722 -> 1721;
1722 -> 1719;
1723 -> 1713;
1724 -> 1689;
1725 -> 1687;
1725 -> 1690;
1725 -> 1689;
1726 -> 1666;
1727 -> 1677;
1727 -> 1714;
1728 -> 1651;
1728 -> 1714;
1729 -> 1714;
1730 -> 1728;
1730 -> 1714;
1731 -> 1714;
1732 -> 1714;
1733 -> 1714;
1734 -> 1714;
1734 -> 1733;
1735 -> 1734;
1735 -> 1714;
1735 -> 1733;
1736 -> 1729;
1736 -> 1735;
1737 -> 1734;
1737 -> 1735;
1738 -> 1714;
1738 -> 1735;
1739 -> 1735;
1740 -> 1736;
1740 -> 1739;
1741 -> 1737;
1741 -> 1739;
1742 -> 1738;
1742 -> 1739;
1743 -> 1741;
1743 -> 1714;
1743 -> 1739;
1744 -> 1741;
1744 -> 1714;
1744 -> 1739;
1745 -> 1740;
1745 -> 1739;
1746 -> 1739;
1747 -> 1741;
1747 -> 1714;
1747 -> 1746;
1747 -> 1739;
1748 -> 1740;
1748 -> 1733;
1748 -> 1714;
1748 -> 1735;
1749 -> 1714;
1749 -> 1733;
1749 -> 1735;
1750 -> 1727;
1750 -> 1735;
1751 -> 1735;
1752 -> 1749;
1752 -> 1751;
1753 -> 1750;
1753 -> 1751;
1754 -> 1751;
1755 -> 1751;
1756 -> 1753;
1756 -> 1755;
1756 -> 1751;
1757 -> 1756;
1758 -> 1752;
1758 -> 1751;
1759 -> 1751;
1760 -> 1751;
1761 -> 1758;
1761 -> 1760;
1762 -> 1759;
1762 -> 1760;
1763 -> 1760;
1764 -> 1762;
1764 -> 1760;
1765 -> 1762;
1765 -> 1760;
1766 -> 1760;
1767 -> 1761;
1767 -> 1766;
1767 -> 1760;
1768 -> 1761;
1768 -> 1762;
1768 -> 1760;
1769 -> 1762;
1769 -> 1760;
1770 -> 1760;
1771 -> 1760;
1772 -> 1769;
1772 -> 1771;
1773 -> 1770;
1773 -> 1771;
1774 -> 1770;
1774 -> 1771;
1775 -> 1771;
1776 -> 1774;
1776 -> 1771;
1777 -> 1774;
1777 -> 1771;
1778 -> 1774;
1778 -> 1771;
1779 -> 1771;
1780 -> 1772;
1780 -> 1779;
1780 -> 1771;
1781 -> 1771;
1782 -> 1773;
1782 -> 1781;
1782 -> 1771;
1783 -> 1772;
1783 -> 1774;
1783 -> 1771;
1784 -> 1773;
1784 -> 1774;
1784 -> 1771;
1785 -> 1774;
1785 -> 1771;
1786 -> 1771;
1787 -> 1771;
1788 -> 1785;
1788 -> 1787;
1789 -> 1786;
1789 -> 1787;
1790 -> 1787;
1791 -> 1789;
1791 -> 1787;
1792 -> 1789;
1792 -> 1787;
1793 -> 1787;
1794 -> 1788;
1794 -> 1793;
1794 -> 1787;
1795 -> 1788;
1795 -> 1789;
1795 -> 1787;
1796 -> 0;
1796 -> 1789;
1796 -> 1787;
1797 -> 1786;
1797 -> 1774;
1797 -> 1771;
1798 -> 1770;
1798 -> 1762;
1798 -> 1760;
1799 -> 1752;
1799 -> 1751;
1800 -> 1759;
1800 -> 1751;
1801 -> 1757;
1801 -> 1799;
1801 -> 1800;
1801 -> 1751;
1802 -> 1759;
1802 -> 1751;
1803 -> 1802;
1803 -> 1735;
1804 -> 1803;
1804 -> 1733;
1804 -> 1714;
1804 -> 1735;
1805 -> 1752;
1805 -> 1757;
1806 -> 1754;
1806 -> 1757;
1807 -> 1757;
1807 -> 1805;
1807 -> 1806;
1807 -> 1714;
1807 -> 1801;
1807 -> 1762;
1807 -> 1768;
1807 -> 1798;
1807 -> 1774;
1807 -> 1783;
1807 -> 1784;
1807 -> 1797;
1807 -> 1789;
1807 -> 1796;
1807 -> 1795;
1808 -> 1714;
1808 -> 1748;
1808 -> 1804;
1808 -> 1807;
1809 -> 1730;
1809 -> 1714;
1810 -> 1714;
1811 -> 1808;
1811 -> 1810;
1811 -> 1714;
1812 -> 1714;
1813 -> 1808;
1813 -> 1812;
1814 -> 1812;
1815 -> 1813;
1815 -> 1808;
1815 -> 1814;
1815 -> 1812;
1816 -> 1714;
1817 -> 1714;
1818 -> 1651;
1818 -> 1808;
1819 -> 1818;
1819 -> 1808;
1820 -> 1808;
1821 -> 1808;
1822 -> 1808;
1823 -> 1808;
1824 -> 1808;
1825 -> 1808;
1826 -> 1808;
1827 -> 1826;
1827 -> 1808;
1828 -> 1826;
1828 -> 1808;
1829 -> 1808;
1830 -> 1826;
1830 -> 1829;
1830 -> 1808;
1831 -> 1826;
1831 -> 1808;
1832 -> 1826;
1832 -> 1808;
1833 -> 1826;
1833 -> 1808;
1834 -> 1808;
1835 -> 1826;
1835 -> 1834;
1835 -> 1808;
1836 -> 1808;
1837 -> 1826;
1837 -> 1836;
1837 -> 1808;
1838 -> 1826;
1838 -> 1808;
1839 -> 1826;
1839 -> 1808;
1840 -> 1808;
1841 -> 1826;
1841 -> 1840;
1841 -> 1808;
1842 -> 1826;
1843 -> 1826;
1844 -> 1826;
1845 -> 1826;
1846 -> 1826;
1847 -> 1826;
1848 -> 1826;
1849 -> 1826;
1850 -> 1826;
1851 -> 1826;
1852 -> 1826;
1853 -> 1819;
1853 -> 1808;
1854 -> 1808;
1855 -> 1826;
1855 -> 1854;
1855 -> 1808;
1856 -> 1808;
1857 -> 1826;
1857 -> 1856;
1858 -> 1856;
1859 -> 1857;
1859 -> 1826;
1859 -> 1858;
1859 -> 1856;
1860 -> 1808;
1861 -> 1808;
1862 -> 1651;
1862 -> 1826;
1863 -> 1862;
1863 -> 1826;
1864 -> 1826;
1865 -> 1826;
1866 -> 1826;
1867 -> 1826;
1868 -> 1826;
1869 -> 1826;
1870 -> 1869;
1871 -> 1870;
1872 -> 1826;
1872 -> 1869;
1873 -> 1871;
1873 -> 1872;
1873 -> 1869;
1874 -> 1873;
1875 -> 1873;
1876 -> 1873;
1877 -> 1873;
1878 -> 1873;
1879 -> 1873;
1880 -> 1873;
1881 -> 1873;
1882 -> 1873;
1883 -> 1873;
1884 -> 1873;
1885 -> 1863;
1885 -> 1826;
1886 -> 1826;
1887 -> 1873;
1887 -> 1886;
1887 -> 1826;
1888 -> 1826;
1889 -> 1873;
1889 -> 1888;
1890 -> 1888;
1891 -> 1889;
1891 -> 1873;
1891 -> 1890;
1891 -> 1888;
1892 -> 1826;
1893 -> 1826;
1894 -> 1651;
1894 -> 1873;
1895 -> 1894;
1895 -> 1873;
1896 -> 1873;
1897 -> 1873;
1898 -> 1873;
1899 -> 1873;
1900 -> 1873;
1901 -> 1895;
1901 -> 1873;
1902 -> 1873;
1903 -> 1873;
1904 -> 1873;
1904 -> 1903;
1905 -> 1903;
1906 -> 1904;
1906 -> 1873;
1906 -> 1905;
1906 -> 1903;
1907 -> 1873;
1908 -> 1873;
1909 -> 1649;
1910 -> 1649;
1911 -> 1651;
1911 -> 1910;
1912 -> 1911;
1912 -> 1873;
1912 -> 1910;
1913 -> 1912;
1913 -> 1649;
1914 -> 1649;
1915 -> 1649;
1916 -> 1913;
1916 -> 1915;
1917 -> 1915;
1918 -> 1916;
1918 -> 1917;
1919 -> 1917;
1920 -> 1918;
1920 -> 1913;
1920 -> 1919;
1920 -> 1917;
1921 -> 1915;
1922 -> 1916;
1922 -> 1913;
1922 -> 1915;
1923 -> 1650;
1923 -> 1649;
1924 -> 1653;
1924 -> 1913;
1924 -> 1923;
1925 -> 1924;
1925 -> 1913;
1925 -> 1923;
1926 -> 1924;
1926 -> 1913;
1926 -> 1923;
1927 -> 1652;
1927 -> 1923;
1927 -> 1913;
1928 -> 1923;
1929 -> 1927;
1929 -> 1928;
1930 -> 1909;
1930 -> 1923;
1931 -> 1652;
1931 -> 1923;
1931 -> 1929;
1932 -> 1923;
1933 -> 1931;
1933 -> 1932;
1934 -> 1924;
1934 -> 1913;
1934 -> 1923;
1935 -> 1934;
1935 -> 1931;
1935 -> 1923;
1936 -> 1923;
1937 -> 1909;
1937 -> 1930;
1937 -> 1936;
1937 -> 1923;
1938 -> 1660;
1938 -> 1923;
1939 -> 1923;
1940 -> 1938;
1940 -> 1939;
1941 -> 1924;
1941 -> 1913;
1941 -> 1939;
1942 -> 1939;
1943 -> 1941;
1943 -> 1931;
1943 -> 1942;
1943 -> 1939;
1944 -> 1940;
1944 -> 1941;
1944 -> 1939;
1945 -> 1923;
1946 -> 1653;
1946 -> 1931;
1946 -> 1944;
1946 -> 1923;
1947 -> 1946;
1947 -> 1931;
1947 -> 1923;
1948 -> 1946;
1948 -> 1931;
1948 -> 1923;
1949 -> 1652;
1949 -> 1923;
1949 -> 1931;
1949 -> 1944;
1950 -> 1949;
1950 -> 1932;
1951 -> 1946;
1951 -> 1931;
1951 -> 1923;
1952 -> 1652;
1952 -> 1951;
1952 -> 1949;
1953 -> 1951;
1954 -> 1952;
1954 -> 1953;
1955 -> 1946;
1955 -> 1952;
1955 -> 1942;
1955 -> 1939;
1956 -> 1952;
1956 -> 1923;
1957 -> 1952;
1957 -> 1923;
1958 -> 1952;
1958 -> 1932;
1959 -> 1952;
1960 -> 1952;
1960 -> 1942;
1960 -> 1939;
1961 -> 1909;
1961 -> 1930;
1961 -> 1649;
1962 -> 1649;
1963 -> 1873;
1963 -> 1962;
1963 -> 1649;
1964 -> 1873;
1964 -> 1952;
1964 -> 1963;
1965 -> 1660;
1965 -> 1964;
1966 -> 1964;
1967 -> 1965;
1967 -> 1966;
1968 -> 1966;
1969 -> 1964;
1970 -> 1967;
1971 -> 1643;
1972 -> 972;
1972 -> 1952;
1972 -> 971;
1973 -> 972;
1973 -> 1952;
1973 -> 1972;
1974 -> 973;
1974 -> 1952;
1974 -> 1973;
1975 -> 1190;
1975 -> 1973;
1976 -> 1166;
1976 -> 1973;
1977 -> 1973;
1978 -> 1975;
1978 -> 1977;
1979 -> 1976;
1979 -> 1977;
1980 -> 1976;
1980 -> 1977;
1981 -> 1978;
1981 -> 1977;
1982 -> 1980;
1982 -> 1952;
1982 -> 1967;
1982 -> 1981;
1983 -> 1982;
1983 -> 1952;
1983 -> 1981;
1984 -> 1979;
1984 -> 1981;
1984 -> 1952;
1984 -> 1967;
1985 -> 1981;
1986 -> 1984;
1986 -> 1985;
1986 -> 1981;
1987 -> 1979;
1987 -> 1981;
1987 -> 1984;
1987 -> 1986;
1988 -> 1982;
1988 -> 1952;
1988 -> 1986;
1989 -> 1987;
1989 -> 1988;
1989 -> 1986;
1990 -> 1989;
1990 -> 1981;
1991 -> 1973;
1992 -> 1189;
1992 -> 1973;
1993 -> 1086;
1993 -> 1973;
1994 -> 1166;
1994 -> 1973;
1995 -> 974;
1995 -> 1989;
1995 -> 1973;
1996 -> 1526;
1996 -> 1973;
1997 -> 1420;
1997 -> 1973;
1998 -> 1996;
1998 -> 1973;
1999 -> 1640;
1999 -> 1973;
2000 -> 1973;
2001 -> 1420;
2001 -> 2000;
2002 -> 2000;
2003 -> 2001;
2003 -> 2002;
2004 -> 2003;
2004 -> 1995;
2004 -> 2002;
2005 -> 2004;
2005 -> 2000;
2006 -> 2000;
2007 -> 1973;
2008 -> 2005;
2008 -> 2007;
2009 -> 2007;
2010 -> 2008;
2010 -> 2009;
2011 -> 2009;
2012 -> 2010;
2012 -> 2005;
2012 -> 2011;
2012 -> 2009;
2013 -> 2007;
2014 -> 2008;
2014 -> 2005;
2014 -> 2007;
2015 -> 1973;
2016 -> 1420;
2016 -> 2015;
2017 -> 2015;
2018 -> 2016;
2018 -> 2017;
2019 -> 2018;
2019 -> 2005;
2019 -> 2017;
2020 -> 2015;
2021 -> 1973;
2022 -> 2019;
2022 -> 2021;
2023 -> 2021;
2024 -> 2022;
2024 -> 2023;
2025 -> 2023;
2026 -> 2024;
2026 -> 2019;
2026 -> 2025;
2026 -> 2023;
2027 -> 2021;
2028 -> 2022;
2028 -> 2019;
2028 -> 2021;
2029 -> 973;
2029 -> 1992;
2029 -> 1993;
2029 -> 1994;
2029 -> 1995;
2029 -> 1998;
2029 -> 1999;
2029 -> 2014;
2029 -> 2028;
2029 -> 2019;
2029 -> 2005;
2029 -> 1086;
2029 -> 1989;
2029 -> 1640;
2029 -> 1189;
2029 -> 1973;
2030 -> 972;
2030 -> 2029;
2030 -> 1973;
2031 -> 973;
2031 -> 1973;
2032 -> 973;
2032 -> 972;
2032 -> 1973;
2033 -> 1420;
2033 -> 972;
2033 -> 1973;
2034 -> 971;
2035 -> 974;
2035 -> 2029;
2035 -> 2032;
2035 -> 2033;
2035 -> 971;
2036 -> 975;
2036 -> 2035;
2036 -> 971;
2037 -> 2034;
2037 -> 967;
2038 -> 969;
2038 -> 2036;
2038 -> 2037;
2038 -> 967;
2039 -> 969;
2039 -> 2036;
2039 -> 967;
2040 -> 968;
2040 -> 2039;
2040 -> 967;
2041 -> 965;
2042 -> 964;
2042 -> 2039;
2042 -> 965;
2043 -> 964;
2043 -> 2039;
2043 -> 963;
2044 -> 2043;
2044 -> 961;
2045 -> 962;
2045 -> 2039;
2045 -> 961;
2046 -> 962;
2046 -> 2045;
2046 -> 961;
2047 -> 2046;
2047 -> 959;
2048 -> 2047;
2048 -> 956;
2049 -> 956;
2050 -> 2048;
2050 -> 2049;
2051 -> 957;
2051 -> 2050;
2051 -> 954;
2051 -> 2045;
2051 -> 956;
2052 -> 956;
2053 -> 958;
2053 -> 2052;
2054 -> 2053;
2054 -> 2051;
2054 -> 2052;
2055 -> 2053;
2055 -> 2051;
2055 -> 2052;
2056 -> 2055;
2056 -> 956;
2057 -> 956;
2058 -> 2057;
2058 -> 2056;
2058 -> 2051;
2058 -> 956;
2059 -> 2057;
2059 -> 2058;
2060 -> 2056;
2060 -> 2059;
2060 -> 2057;
2061 -> 2059;
2062 -> 2060;
2062 -> 2061;
2063 -> 953;
2064 -> 952;
2064 -> 953;
2065 -> 953;
2066 -> 953;
2067 -> 2064;
2067 -> 2066;
2068 -> 2065;
2068 -> 2066;
2069 -> 0;
2069 -> 2068;
2069 -> 2066;
2070 -> 2067;
2070 -> 2068;
2070 -> 2066;
2071 -> 2065;
2071 -> 954;
2071 -> 2062;
2071 -> 953;
2072 -> 2071;
2072 -> 2065;
2073 -> 2065;
2074 -> 2072;
2074 -> 2071;
2074 -> 2073;
2074 -> 2065;
2075 -> 2074;
2076 -> 2072;
2076 -> 2074;
2077 -> 2074;
2078 -> 2072;
2078 -> 2077;
2079 -> 2077;
2080 -> 2078;
2080 -> 2071;
2080 -> 2079;
2081 -> 2080;
2081 -> 2071;
2081 -> 2079;
2082 -> 2081;
2082 -> 2077;
2083 -> 2082;
2083 -> 2074;
2084 -> 2074;
2085 -> 2083;
2085 -> 2084;
2086 -> 2084;
2087 -> 2085;
2087 -> 2086;
2088 -> 2087;
2088 -> 2084;
2089 -> 2085;
2089 -> 2084;
2090 -> 2084;
2092 -> 2091;
2094 -> 2093;
2095 -> 2075;
2095 -> 2074;
2096 -> 2074;
2097 -> 2074;
2098 -> 2076;
2098 -> 2097;
2099 -> 2076;
2099 -> 2097;
2100 -> 2088;
2100 -> 2097;
2101 -> 2095;
2101 -> 2097;
2102 -> 2096;
2102 -> 2097;
2103 -> 2097;
2104 -> 2102;
2104 -> 2097;
2105 -> 2102;
2105 -> 2097;
2106 -> 2102;
2106 -> 2097;
2107 -> 2102;
2107 -> 2097;
2108 -> 2102;
2108 -> 2097;
2109 -> 2102;
2109 -> 2097;
2112 -> 2111;
2112 -> 2110;
2114 -> 2113;
2114 -> 2110;
2115 -> 2110;
2118 -> 2117;
2118 -> 2116;
2120 -> 2119;
2120 -> 2116;
2121 -> 2116;
2123 -> 0;
2123 -> 2122;
2125 -> 0;
2125 -> 2124;
2126 -> 2125;
2126 -> 2122;
2127 -> 2122;
2129 -> 0;
2129 -> 2128;
2130 -> 0;
2130 -> 2128;
2131 -> 2128;
2132 -> 2121;
2132 -> 2102;
2132 -> 2097;
2133 -> 2097;
2134 -> 2100;
2134 -> 2133;
2134 -> 2097;
2135 -> 2098;
2135 -> 2102;
2135 -> 2097;
2136 -> 2099;
2136 -> 2102;
2136 -> 2097;
2137 -> 2100;
2137 -> 2102;
2137 -> 2097;
2138 -> 2100;
2138 -> 2088;
2138 -> 2097;
2139 -> 2138;
2139 -> 2088;
2140 -> 2101;
2140 -> 2139;
2140 -> 2075;
2140 -> 2088;
2140 -> 2138;
2141 -> 2075;
2141 -> 2140;
2141 -> 2074;
2142 -> 2075;
2142 -> 2140;
2142 -> 2074;
2143 -> 2072;
2143 -> 2142;
2143 -> 2074;
2144 -> 2096;
2144 -> 2074;
2145 -> 2074;
2146 -> 2143;
2146 -> 2144;
2146 -> 2145;
2146 -> 2102;
2146 -> 2135;
2146 -> 2136;
2146 -> 2137;
2146 -> 2107;
2146 -> 2108;
2146 -> 2109;
2146 -> 2132;
2146 -> 2142;
2146 -> 2118;
2146 -> 2120;
2146 -> 2116;
2146 -> 2074;
2147 -> 2072;
2147 -> 2146;
2147 -> 2065;
2148 -> 2071;
2148 -> 2065;
2149 -> 2148;
2149 -> 2065;
2150 -> 2149;
2150 -> 2147;
2150 -> 2065;
2151 -> 2071;
2151 -> 2065;
2152 -> 2151;
2152 -> 2150;
2152 -> 2065;
2153 -> 953;
2154 -> 2065;
2154 -> 2153;
2155 -> 2065;
2155 -> 2153;
2156 -> 2152;
2156 -> 2153;
2157 -> 2065;
2157 -> 2153;
2158 -> 2153;
2159 -> 2156;
2159 -> 2152;
2159 -> 2158;
2159 -> 2153;
2160 -> 2153;
2161 -> 2156;
2161 -> 2152;
2161 -> 2160;
2161 -> 2153;
2162 -> 2161;
2162 -> 2153;
2163 -> 2154;
2163 -> 2162;
2164 -> 2155;
2164 -> 2162;
2165 -> 2157;
2165 -> 2162;
2166 -> 2162;
2167 -> 2163;
2167 -> 2166;
2168 -> 2164;
2168 -> 2166;
2169 -> 2162;
2169 -> 2166;
2170 -> 2165;
2170 -> 2166;
2171 -> 2162;
2171 -> 2166;
2172 -> 2166;
2173 -> 2171;
2173 -> 2166;
2174 -> 2171;
2174 -> 2166;
2175 -> 2171;
2175 -> 2166;
2176 -> 2167;
2176 -> 2171;
2176 -> 2166;
2177 -> 2169;
2177 -> 2171;
2177 -> 2166;
2178 -> 2168;
2178 -> 2171;
2178 -> 2166;
2179 -> 2171;
2179 -> 2166;
2180 -> 0;
2180 -> 2166;
2181 -> 2179;
2181 -> 2171;
2181 -> 2166;
2182 -> 2170;
2182 -> 2171;
2182 -> 2166;
2183 -> 2169;
2183 -> 2166;
2184 -> 2183;
2185 -> 2183;
2185 -> 2184;
2186 -> 2185;
2186 -> 2184;
2187 -> 2186;
2187 -> 2183;
2188 -> 2183;
2189 -> 954;
2189 -> 2152;
2189 -> 953;
2190 -> 952;
2190 -> 2189;
2190 -> 953;
2191 -> 2162;
2191 -> 953;
2192 -> 953;
2193 -> 2190;
2193 -> 2191;
2193 -> 2192;
2193 -> 2171;
2193 -> 2178;
2193 -> 2182;
2193 -> 2181;
2193 -> 2176;
2193 -> 2177;
2193 -> 2189;
2193 -> 2069;
2193 -> 2070;
2193 -> 2152;
2193 -> 2179;
2193 -> 953;
2194 -> 952;
2194 -> 2193;
2194 -> 951;
2195 -> 2194;
2195 -> 1;
2196 -> 1;
2197 -> 1;
2198 -> 2196;
2198 -> 2197;
2199 -> 2195;
2199 -> 2197;
2200 -> 2199;
2200 -> 2193;
2200 -> 2198;
2200 -> 2197;
2201 -> 2197;
2202 -> 2200;
2202 -> 2201;
2203 -> 2200;
2203 -> 2201;
2204 -> 2201;
2205 -> 2201;
2206 -> 2203;
2206 -> 2200;
2206 -> 2201;
2207 -> 2202;
2207 -> 2206;
2208 -> 2206;
2209 -> 2207;
2209 -> 2208;
2210 -> 2206;
2210 -> 2208;
2211 -> 2208;
2212 -> 2211;
2212 -> 2208;
2213 -> 2208;
2214 -> 2210;
2214 -> 2213;
2215 -> 2213;
2216 -> 2214;
2216 -> 2200;
2216 -> 2215;
2216 -> 2213;
2217 -> 2216;
2218 -> 2214;
2218 -> 2200;
2218 -> 2216;
2219 -> 2217;
2219 -> 2216;
2220 -> 2216;
2221 -> 2219;
2221 -> 2220;
2222 -> 2214;
2222 -> 2220;
2223 -> 2222;
2223 -> 2200;
2223 -> 2220;
2224 -> 2220;
2225 -> 2223;
2225 -> 2224;
2226 -> 2223;
2226 -> 2224;
2227 -> 2225;
2227 -> 2224;
2228 -> 0;
2228 -> 2224;
2229 -> 2227;
2229 -> 2226;
2229 -> 2224;
2230 -> 2222;
2230 -> 2229;
2230 -> 2220;
2231 -> 2230;
2232 -> 2221;
2232 -> 2230;
2233 -> 2230;
2234 -> 2231;
2234 -> 2233;
2235 -> 2232;
2235 -> 2233;
2236 -> 2222;
2236 -> 2233;
2237 -> 2234;
2237 -> 2229;
2237 -> 2233;
2238 -> 2236;
2238 -> 2229;
2238 -> 2237;
2239 -> 2236;
2239 -> 2237;
2240 -> 2234;
2240 -> 2237;
2241 -> 2235;
2241 -> 2237;
2242 -> 2237;
2243 -> 2237;
2244 -> 2238;
2244 -> 2243;
2245 -> 2239;
2245 -> 2243;
2246 -> 2240;
2246 -> 2243;
2247 -> 2241;
2247 -> 2243;
2248 -> 2242;
2248 -> 2243;
2249 -> 2248;
2249 -> 2243;
2250 -> 2248;
2250 -> 2243;
2251 -> 2248;
2251 -> 2243;
2252 -> 2243;
2253 -> 2246;
2253 -> 2252;
2253 -> 2243;
2254 -> 2230;
2255 -> 2242;
2255 -> 2254;
2256 -> 2229;
2256 -> 2254;
2257 -> 2254;
2258 -> 2255;
2258 -> 2257;
2259 -> 2258;
2259 -> 2246;
2259 -> 2247;
2259 -> 2257;
2260 -> 2259;
2260 -> 2254;
2261 -> 2254;
2262 -> 2260;
2262 -> 2254;
2263 -> 2261;
2263 -> 2254;
2264 -> 2256;
2264 -> 2229;
2264 -> 2262;
2264 -> 2263;
2264 -> 2254;
2265 -> 2255;
2265 -> 2260;
2265 -> 2256;
2265 -> 2264;
2266 -> 2220;
2267 -> 2229;
2267 -> 2266;
2268 -> 2267;
2268 -> 2229;
2268 -> 2265;
2268 -> 2264;
2268 -> 2266;
2269 -> 0;
2269 -> 2266;
2270 -> 2267;
2270 -> 2229;
2270 -> 2265;
2270 -> 2266;
2271 -> 2270;
2271 -> 2264;
2272 -> 2270;
2273 -> 2272;
2273 -> 2270;
2274 -> 2271;
2274 -> 2270;
2275 -> 2270;
2276 -> 2274;
2276 -> 2275;
2276 -> 2270;
2277 -> 2271;
2277 -> 2276;
2278 -> 2276;
2279 -> 2277;
2279 -> 2278;
2280 -> 0;
2280 -> 2278;
2281 -> 2280;
2281 -> 2276;
2282 -> 2281;
2282 -> 2276;
2283 -> 2277;
2283 -> 2282;
2284 -> 2270;
2284 -> 2264;
2285 -> 2283;
2285 -> 2270;
2286 -> 2268;
2286 -> 2284;
2286 -> 2285;
2286 -> 2270;
2287 -> 2268;
2287 -> 2266;
2288 -> 2287;
2288 -> 2220;
2289 -> 2222;
2289 -> 2220;
2290 -> 2288;
2290 -> 2220;
2291 -> 2221;
2291 -> 2220;
2292 -> 2220;
2293 -> 2289;
2293 -> 2292;
2294 -> 2290;
2294 -> 2292;
2295 -> 2291;
2295 -> 2292;
2296 -> 2292;
2297 -> 2292;
2298 -> 2292;
2299 -> 2293;
2299 -> 2298;
2300 -> 2298;
2301 -> 2299;
2301 -> 2247;
2301 -> 2300;
2302 -> 2301;
2302 -> 2247;
2302 -> 2300;
2303 -> 2302;
2303 -> 2292;
2304 -> 2292;
2305 -> 2303;
2305 -> 2304;
2306 -> 2292;
2307 -> 2294;
2307 -> 2268;
2307 -> 2292;
2308 -> 2307;
2308 -> 2268;
2308 -> 2286;
2308 -> 2292;
2309 -> 2296;
2309 -> 2308;
2310 -> 2308;
2311 -> 2294;
2311 -> 2308;
2311 -> 2268;
2311 -> 2286;
2311 -> 2247;
2311 -> 2264;
2311 -> 2283;
2312 -> 2311;
2313 -> 2311;
2314 -> 2312;
2314 -> 2313;
2314 -> 2311;
2315 -> 2314;
2315 -> 2311;
2316 -> 2315;
2316 -> 2296;
2316 -> 2309;
2316 -> 2311;
2317 -> 2296;
2317 -> 2309;
2317 -> 2315;
2317 -> 2311;
2318 -> 2311;
2319 -> 2317;
2319 -> 2318;
2319 -> 2311;
2320 -> 2297;
2320 -> 2318;
2320 -> 2311;
2321 -> 2319;
2321 -> 2320;
2321 -> 2311;
2322 -> 2311;
2323 -> 2317;
2323 -> 2322;
2323 -> 2311;
2324 -> 2311;
2324 -> 2315;
2324 -> 2296;
2325 -> 2311;
2326 -> 2312;
2326 -> 2325;
2326 -> 2311;
2327 -> 2220;
2328 -> 2288;
2328 -> 2220;
2329 -> 2216;
2330 -> 2218;
2330 -> 2328;
2330 -> 2329;
2330 -> 2311;
2330 -> 2216;
2331 -> 2330;
2332 -> 2214;
2332 -> 2331;
2333 -> 2331;
2334 -> 2332;
2334 -> 2333;
2335 -> 2333;
2335 -> 2331;
2336 -> 2331;
2337 -> 2332;
2337 -> 2336;
2338 -> 2337;
2338 -> 2330;
2338 -> 2336;
2339 -> 2338;
2339 -> 2331;
2340 -> 2331;
2341 -> 2339;
2341 -> 2340;
2341 -> 2331;
2342 -> 2341;
2342 -> 2331;
2343 -> 2342;
2344 -> 2343;
2344 -> 2330;
2345 -> 2330;
2346 -> 2344;
2346 -> 2345;
2347 -> 2346;
2347 -> 2330;
2347 -> 2345;
2348 -> 2345;
2349 -> 2346;
2349 -> 2330;
2349 -> 2348;
2349 -> 2345;
2350 -> 2349;
2351 -> 2346;
2351 -> 2330;
2351 -> 2349;
2352 -> 2350;
2352 -> 2349;
2353 -> 2349;
2354 -> 2346;
2354 -> 2352;
2354 -> 2345;
2355 -> 2217;
2355 -> 2330;
2356 -> 2330;
2357 -> 2214;
2357 -> 2356;
2358 -> 2356;
2359 -> 2357;
2359 -> 2358;
2360 -> 2358;
2361 -> 2359;
2361 -> 2354;
2361 -> 2360;
2362 -> 2361;
2362 -> 2354;
2362 -> 2360;
2363 -> 2362;
2363 -> 2356;
2364 -> 2356;
2365 -> 2363;
2365 -> 2364;
2366 -> 2364;
2367 -> 2365;
2367 -> 2366;
2368 -> 2367;
2368 -> 2364;
2369 -> 2365;
2369 -> 2364;
2370 -> 2368;
2370 -> 2356;
2371 -> 2330;
2372 -> 2330;
2373 -> 2214;
2373 -> 2372;
2374 -> 2372;
2375 -> 2373;
2375 -> 2374;
2376 -> 2374;
2376 -> 2372;
2377 -> 2372;
2378 -> 2373;
2378 -> 2377;
2379 -> 2378;
2379 -> 2354;
2379 -> 2377;
2380 -> 2372;
2381 -> 2379;
2381 -> 2330;
2382 -> 2214;
2382 -> 2330;
2383 -> 2330;
2384 -> 2382;
2384 -> 2383;
2385 -> 2381;
2385 -> 2383;
2386 -> 2385;
2386 -> 2383;
2387 -> 2384;
2387 -> 2383;
2388 -> 2387;
2388 -> 2354;
2388 -> 2383;
2389 -> 2383;
2390 -> 2386;
2390 -> 2388;
2390 -> 2389;
2390 -> 2383;
2391 -> 2330;
2392 -> 0;
2392 -> 2330;
2393 -> 2330;
2394 -> 2392;
2394 -> 2393;
2395 -> 2214;
2395 -> 2390;
2395 -> 2393;
2396 -> 2395;
2396 -> 2390;
2396 -> 2393;
2397 -> 2394;
2397 -> 2393;
2398 -> 2396;
2398 -> 2397;
2398 -> 2393;
2399 -> 2398;
2399 -> 2330;
2400 -> 2217;
2400 -> 2390;
2400 -> 2398;
2400 -> 2216;
2401 -> 2214;
2401 -> 2400;
2401 -> 2213;
2402 -> 2401;
2402 -> 2208;
2403 -> 2209;
2403 -> 2208;
2404 -> 2211;
2404 -> 2208;
2405 -> 2402;
2405 -> 2403;
2405 -> 2404;
2405 -> 2400;
2405 -> 2212;
2405 -> 2208;
2406 -> 2405;
2406 -> 2208;
2407 -> 2406;
2408 -> 2406;
2408 -> 2407;
2409 -> 2407;
2409 -> 2406;
2410 -> 2409;
2411 -> 2410;
2411 -> 2204;
2411 -> 2409;
2412 -> 2406;
2412 -> 2409;
2413 -> 2411;
2413 -> 2412;
2413 -> 2410;
2413 -> 2406;
2413 -> 2409;
2414 -> 2413;
2415 -> 2413;
2416 -> 2413;
2417 -> 2415;
2417 -> 2416;
2418 -> 2416;
2419 -> 2417;
2419 -> 2413;
2419 -> 2418;
2419 -> 2416;
2420 -> 2419;
2421 -> 2419;
2422 -> 2417;
2422 -> 2413;
2422 -> 2421;
2423 -> 2422;
2423 -> 2413;
2423 -> 2421;
2424 -> 2423;
2424 -> 2419;
2425 -> 0;
2425 -> 2419;
2426 -> 2424;
2426 -> 2419;
2427 -> 2419;
2428 -> 2426;
2428 -> 2427;
2429 -> 2417;
2429 -> 2427;
2430 -> 2427;
2431 -> 2428;
2431 -> 2430;
2431 -> 2427;
2432 -> 2427;
2433 -> 2427;
2434 -> 2427;
2435 -> 2429;
2435 -> 2434;
2436 -> 2434;
2437 -> 2436;
2437 -> 2427;
2438 -> 2437;
2438 -> 2427;
2439 -> 2437;
2439 -> 2427;
2440 -> 2439;
2441 -> 2428;
2441 -> 2427;
2442 -> 0;
2442 -> 2427;
2443 -> 2432;
2443 -> 2427;
2444 -> 2433;
2444 -> 2427;
2445 -> 2438;
2445 -> 2440;
2445 -> 2441;
2445 -> 2442;
2445 -> 2443;
2445 -> 2444;
2445 -> 2424;
2445 -> 2427;
2446 -> 2445;
2446 -> 2427;
2447 -> 2427;
2448 -> 2446;
2448 -> 2447;
2449 -> 2429;
2449 -> 2447;
2450 -> 2447;
2451 -> 2449;
2451 -> 2445;
2451 -> 2450;
2451 -> 2447;
2452 -> 0;
2452 -> 2451;
2453 -> 2448;
2453 -> 2451;
2454 -> 2453;
2454 -> 2445;
2455 -> 2449;
2455 -> 2453;
2456 -> 2453;
2457 -> 2453;
2458 -> 2454;
2458 -> 2457;
2459 -> 2455;
2459 -> 2457;
2460 -> 2454;
2460 -> 2457;
2461 -> 2456;
2461 -> 2457;
2462 -> 2457;
2463 -> 2461;
2463 -> 2457;
2464 -> 2461;
2464 -> 2457;
2465 -> 2461;
2465 -> 2457;
2466 -> 2457;
2467 -> 2458;
2467 -> 2466;
2467 -> 2457;
2468 -> 2457;
2469 -> 2459;
2469 -> 2468;
2469 -> 2457;
2470 -> 2457;
2471 -> 2460;
2471 -> 2470;
2471 -> 2457;
2472 -> 2459;
2472 -> 2461;
2472 -> 2457;
2473 -> 2458;
2473 -> 2461;
2473 -> 2457;
2474 -> 2460;
2474 -> 2461;
2474 -> 2457;
2475 -> 2453;
2476 -> 2456;
2476 -> 2475;
2477 -> 2476;
2477 -> 2473;
2477 -> 2475;
2478 -> 2477;
2478 -> 2453;
2479 -> 2456;
2479 -> 2453;
2480 -> 2452;
2480 -> 2478;
2480 -> 2479;
2480 -> 2453;
2481 -> 2449;
2481 -> 2445;
2481 -> 2451;
2482 -> 2452;
2482 -> 2451;
2483 -> 2451;
2484 -> 2481;
2484 -> 2482;
2484 -> 2483;
2484 -> 2452;
2484 -> 2445;
2484 -> 2480;
2484 -> 2461;
2484 -> 2472;
2484 -> 2473;
2484 -> 2474;
2484 -> 2451;
2485 -> 2427;
2486 -> 2445;
2486 -> 2427;
2487 -> 2427;
2488 -> 2486;
2488 -> 2487;
2489 -> 2429;
2489 -> 2487;
2490 -> 2487;
2491 -> 2489;
2491 -> 2484;
2491 -> 2490;
2491 -> 2487;
2492 -> 2491;
2493 -> 2489;
2493 -> 2492;
2494 -> 2493;
2494 -> 2484;
2494 -> 2492;
2495 -> 2494;
2495 -> 2491;
2496 -> 2491;
2497 -> 2491;
2498 -> 2495;
2498 -> 2497;
2499 -> 2498;
2499 -> 2491;
2500 -> 2491;
2501 -> 2488;
2501 -> 2491;
2502 -> 2501;
2502 -> 2499;
2502 -> 2491;
2503 -> 2502;
2504 -> 2499;
2504 -> 2503;
2505 -> 2495;
2505 -> 2504;
2506 -> 2489;
2506 -> 2504;
2507 -> 2503;
2507 -> 2504;
2508 -> 0;
2509 -> 2508;
2510 -> 2509;
2512 -> 2511;
2513 -> 2512;
2513 -> 2511;
2514 -> 0;
2514 -> 2512;
2514 -> 2511;
2515 -> 0;
2515 -> 2512;
2515 -> 2511;
2516 -> 2512;
2516 -> 2511;
2517 -> 2512;
2517 -> 2511;
2518 -> 2512;
2518 -> 2511;
2519 -> 2512;
2519 -> 2511;
2521 -> 2520;
2522 -> 2520;
2523 -> 2522;
2524 -> 2522;
2526 -> 2525;
2528 -> 2527;
2530 -> 2529;
2532 -> 2531;
2534 -> 2532;
2534 -> 2533;
2535 -> 2534;
2537 -> 2536;
2539 -> 2538;
2541 -> 2540;
2543 -> 2542;
2553 -> 2545;
2553 -> 2544;
2554 -> 2546;
2554 -> 2544;
2555 -> 2547;
2555 -> 2544;
2556 -> 2548;
2556 -> 2544;
2557 -> 2549;
2557 -> 2544;
2558 -> 2550;
2558 -> 2544;
2559 -> 2551;
2559 -> 2544;
2560 -> 2552;
2560 -> 2544;
2561 -> 2544;
2562 -> 2524;
2562 -> 2522;
2563 -> 2562;
2563 -> 2523;
2564 -> 2523;
2566 -> 2565;
2568 -> 0;
2570 -> 2568;
2570 -> 2569;
2571 -> 2569;
2572 -> 2571;
2572 -> 2569;
2573 -> 2570;
2573 -> 2571;
2573 -> 2569;
2574 -> 2569;
2575 -> 0;
2577 -> 2575;
2577 -> 2576;
2578 -> 2576;
2579 -> 2578;
2579 -> 2576;
2580 -> 2577;
2580 -> 2578;
2580 -> 2576;
2581 -> 2576;
2582 -> 0;
2584 -> 2582;
2584 -> 2583;
2585 -> 2583;
2586 -> 2585;
2586 -> 2583;
2587 -> 2584;
2587 -> 2585;
2587 -> 2583;
2588 -> 2583;
2589 -> 0;
2591 -> 2589;
2591 -> 2590;
2592 -> 2590;
2593 -> 2592;
2593 -> 2590;
2594 -> 2591;
2594 -> 2592;
2594 -> 2590;
2595 -> 2590;
2596 -> 0;
2598 -> 2596;
2598 -> 2597;
2599 -> 2597;
2600 -> 2599;
2600 -> 2597;
2601 -> 2598;
2601 -> 2599;
2601 -> 2597;
2602 -> 2597;
2603 -> 0;
2605 -> 2603;
2605 -> 2604;
2606 -> 2604;
2607 -> 2606;
2607 -> 2604;
2608 -> 2605;
2608 -> 2606;
2608 -> 2604;
2609 -> 2604;
2610 -> 0;
2612 -> 2610;
2612 -> 2611;
2613 -> 2611;
2614 -> 2613;
2614 -> 2611;
2615 -> 2612;
2615 -> 2613;
2615 -> 2611;
2616 -> 2611;
2617 -> 0;
2619 -> 2617;
2619 -> 2618;
2620 -> 2618;
2621 -> 2620;
2621 -> 2618;
2622 -> 2619;
2622 -> 2620;
2622 -> 2618;
2623 -> 2618;
2624 -> 2623;
2626 -> 2567;
2626 -> 2624;
2626 -> 2625;
2626 -> 2620;
2626 -> 2621;
2626 -> 2622;
2627 -> 2626;
2629 -> 2628;
2630 -> 2629;
2630 -> 2628;
2631 -> 2629;
2631 -> 2628;
2632 -> 2629;
2632 -> 2628;
2633 -> 2628;
2635 -> 2634;
2636 -> 2564;
2637 -> 2636;
2638 -> 2637;
2639 -> 2638;
2639 -> 2637;
2640 -> 2636;
2640 -> 2564;
2641 -> 2636;
2641 -> 2564;
2642 -> 2564;
2642 -> 2523;
2643 -> 2564;
2643 -> 2523;
2644 -> 2564;
2644 -> 2523;
2645 -> 2563;
2645 -> 2564;
2645 -> 2523;
2646 -> 2522;
2646 -> 2520;
2647 -> 2521;
2647 -> 2522;
2647 -> 2520;
2648 -> 2520;
2649 -> 2648;
2649 -> 2512;
2649 -> 2511;
2650 -> 0;
2650 -> 2512;
2650 -> 2511;
2651 -> 2511;
2652 -> 2502;
2652 -> 2499;
2652 -> 2504;
2653 -> 2504;
2654 -> 2505;
2654 -> 2653;
2655 -> 2506;
2655 -> 2653;
2656 -> 2507;
2656 -> 2653;
2657 -> 2652;
2657 -> 2653;
2658 -> 2653;
2659 -> 2658;
2659 -> 2653;
2660 -> 2653;
2661 -> 2653;
2662 -> 2654;
2662 -> 2653;
2663 -> 2656;
2663 -> 2653;
2664 -> 2658;
2664 -> 2653;
2665 -> 2660;
2665 -> 2653;
2666 -> 2661;
2666 -> 2653;
2667 -> 2653;
2668 -> 2662;
2668 -> 2667;
2669 -> 2663;
2669 -> 2667;
2670 -> 2664;
2670 -> 2667;
2671 -> 2665;
2671 -> 2667;
2672 -> 2666;
2672 -> 2667;
2673 -> 2667;
2674 -> 2668;
2674 -> 2673;
2675 -> 2674;
2675 -> 2667;
2676 -> 2669;
2676 -> 2667;
2677 -> 2675;
2677 -> 2676;
2677 -> 2499;
2677 -> 2667;
2678 -> 2677;
2678 -> 2667;
2679 -> 2667;
2680 -> 2653;
2681 -> 2653;
2682 -> 2653;
2683 -> 2653;
2684 -> 2678;
2684 -> 2683;
2684 -> 2653;
2685 -> 2654;
2685 -> 2684;
2686 -> 2655;
2686 -> 2684;
2687 -> 2656;
2687 -> 2684;
2688 -> 2657;
2688 -> 2684;
2689 -> 2681;
2689 -> 2684;
2690 -> 2684;
2691 -> 2684;
2692 -> 2685;
2692 -> 2691;
2693 -> 2686;
2693 -> 2691;
2694 -> 2687;
2694 -> 2691;
2695 -> 2688;
2695 -> 2691;
2696 -> 2689;
2696 -> 2691;
2697 -> 2690;
2697 -> 2691;
2698 -> 2692;
2698 -> 2691;
2699 -> 2693;
2699 -> 2691;
2700 -> 2694;
2700 -> 2691;
2701 -> 2695;
2701 -> 2691;
2702 -> 2691;
2703 -> 2696;
2703 -> 2691;
2704 -> 2691;
2705 -> 2698;
2705 -> 2704;
2706 -> 2699;
2706 -> 2704;
2707 -> 2700;
2707 -> 2704;
2708 -> 2701;
2708 -> 2704;
2709 -> 2702;
2709 -> 2704;
2710 -> 2703;
2710 -> 2704;
2711 -> 2697;
2711 -> 2704;
2712 -> 2704;
2713 -> 2711;
2713 -> 2712;
2714 -> 2712;
2715 -> 2712;
2716 -> 2713;
2716 -> 2715;
2717 -> 2715;
2718 -> 2716;
2718 -> 2715;
2719 -> 2716;
2719 -> 2715;
2720 -> 2713;
2720 -> 2712;
2721 -> 2713;
2721 -> 2712;
2722 -> 2713;
2722 -> 2712;
2723 -> 2714;
2723 -> 2713;
2723 -> 2712;
2724 -> 2711;
2724 -> 2704;
2725 -> 2711;
2725 -> 2704;
2726 -> 2711;
2726 -> 2704;
2727 -> 2711;
2727 -> 2704;
2728 -> 2711;
2728 -> 2704;
2729 -> 2711;
2729 -> 2704;
2730 -> 2711;
2730 -> 2704;
2731 -> 2711;
2731 -> 2704;
2732 -> 2711;
2732 -> 2704;
2733 -> 2648;
2733 -> 2711;
2733 -> 2704;
2734 -> 2704;
2735 -> 2734;
2735 -> 2711;
2735 -> 2704;
2736 -> 2648;
2736 -> 2711;
2736 -> 2704;
2737 -> 2704;
2738 -> 2737;
2738 -> 2711;
2738 -> 2704;
2739 -> 2711;
2739 -> 2704;
2740 -> 0;
2740 -> 2711;
2740 -> 2704;
2741 -> 2711;
2741 -> 2704;
2742 -> 2711;
2742 -> 2704;
2743 -> 2707;
2743 -> 2499;
2743 -> 2704;
2744 -> 2704;
2745 -> 2706;
2745 -> 2744;
2745 -> 2704;
2746 -> 2704;
2747 -> 2709;
2747 -> 2746;
2747 -> 2704;
2748 -> 2704;
2749 -> 2704;
2750 -> 2704;
2751 -> 2705;
2751 -> 2750;
2752 -> 2751;
2752 -> 2704;
2753 -> 2707;
2753 -> 2704;
2754 -> 2752;
2754 -> 2753;
2754 -> 2677;
2754 -> 2499;
2754 -> 2704;
2755 -> 2707;
2755 -> 2711;
2755 -> 2704;
2756 -> 2706;
2756 -> 2711;
2756 -> 2704;
2757 -> 2704;
2758 -> 2705;
2758 -> 2757;
2759 -> 2758;
2759 -> 2754;
2759 -> 2757;
2760 -> 2759;
2760 -> 2704;
2761 -> 2707;
2761 -> 2704;
2762 -> 2760;
2762 -> 2711;
2762 -> 2704;
2763 -> 2704;
2764 -> 2709;
2764 -> 2763;
2764 -> 2704;
2765 -> 2754;
2765 -> 2711;
2765 -> 2764;
2766 -> 2764;
2767 -> 2704;
2768 -> 2708;
2768 -> 2767;
2768 -> 2704;
2769 -> 2704;
2770 -> 2705;
2770 -> 2769;
2771 -> 2770;
2771 -> 2760;
2771 -> 2769;
2772 -> 2771;
2772 -> 2704;
2773 -> 2704;
2774 -> 2772;
2774 -> 2773;
2775 -> 2773;
2776 -> 2774;
2776 -> 2775;
2777 -> 2776;
2777 -> 2773;
2778 -> 2774;
2778 -> 2773;
2779 -> 2774;
2779 -> 2760;
2779 -> 0;
2779 -> 2773;
2780 -> 2768;
2780 -> 2777;
2780 -> 2704;
2781 -> 2704;
2782 -> 2711;
2782 -> 2781;
2783 -> 0;
2783 -> 2781;
2784 -> 2782;
2784 -> 2762;
2784 -> 0;
2784 -> 2781;
2785 -> 0;
2785 -> 2784;
2786 -> 2785;
2786 -> 2781;
2787 -> 2786;
2787 -> 2704;
2788 -> 2780;
2788 -> 2787;
2788 -> 2704;
2789 -> 0;
2789 -> 2711;
2789 -> 2788;
2790 -> 2749;
2790 -> 2704;
2791 -> 2653;
2792 -> 2679;
2792 -> 2791;
2792 -> 2653;
2793 -> 2690;
2793 -> 2653;
2794 -> 2496;
2794 -> 2793;
2794 -> 2716;
2794 -> 2718;
2794 -> 2719;
2794 -> 2720;
2794 -> 2721;
2794 -> 2723;
2794 -> 2756;
2794 -> 2765;
2794 -> 2762;
2794 -> 2789;
2794 -> 2728;
2794 -> 2729;
2794 -> 2730;
2794 -> 2731;
2794 -> 2732;
2794 -> 2733;
2794 -> 2735;
2794 -> 2736;
2794 -> 2738;
2794 -> 2739;
2794 -> 2740;
2794 -> 2741;
2794 -> 2742;
2794 -> 2755;
2794 -> 2639;
2794 -> 2640;
2794 -> 2641;
2794 -> 2642;
2794 -> 2643;
2794 -> 2645;
2794 -> 2647;
2794 -> 2734;
2794 -> 2737;
2794 -> 0;
2794 -> 2499;
2794 -> 2760;
2794 -> 2504;
2795 -> 2794;
2796 -> 2795;
2796 -> 2794;
2797 -> 2794;
2798 -> 2794;
2799 -> 2795;
2799 -> 2794;
2800 -> 2797;
2800 -> 2794;
2801 -> 2798;
2801 -> 2794;
2802 -> 2794;
2803 -> 2794;
2804 -> 2794;
2805 -> 2794;
2806 -> 2803;
2806 -> 2794;
2807 -> 2794;
2808 -> 2805;
2808 -> 2807;
2809 -> 2805;
2809 -> 2807;
2810 -> 2805;
2810 -> 2807;
2811 -> 2805;
2811 -> 2807;
2812 -> 2805;
2812 -> 2807;
2813 -> 2805;
2813 -> 2807;
2814 -> 2806;
2814 -> 2807;
2815 -> 2805;
2815 -> 2807;
2816 -> 2808;
2816 -> 2807;
2817 -> 2809;
2817 -> 2807;
2818 -> 2810;
2818 -> 2807;
2819 -> 2811;
2819 -> 2807;
2820 -> 2813;
2820 -> 2807;
2821 -> 2814;
2821 -> 2807;
2822 -> 2807;
2823 -> 2816;
2823 -> 2822;
2824 -> 2817;
2824 -> 2822;
2825 -> 2818;
2825 -> 2822;
2826 -> 2819;
2826 -> 2822;
2827 -> 2820;
2827 -> 2822;
2828 -> 2821;
2828 -> 2822;
2829 -> 2815;
2829 -> 2822;
2830 -> 2815;
2830 -> 2822;
2831 -> 2815;
2831 -> 2822;
2832 -> 2815;
2832 -> 2822;
2833 -> 2815;
2833 -> 2822;
2834 -> 2825;
2834 -> 2794;
2834 -> 2822;
2835 -> 2822;
2836 -> 2824;
2836 -> 2835;
2836 -> 2822;
2837 -> 2822;
2838 -> 2827;
2838 -> 2837;
2838 -> 2822;
2839 -> 2822;
2840 -> 2822;
2841 -> 2823;
2841 -> 2825;
2841 -> 2794;
2841 -> 2822;
2842 -> 2841;
2842 -> 2827;
2843 -> 2827;
2844 -> 2842;
2844 -> 2815;
2844 -> 2827;
2845 -> 2815;
2845 -> 2844;
2845 -> 2827;
2846 -> 2841;
2846 -> 2827;
2847 -> 2815;
2847 -> 2844;
2847 -> 2841;
2847 -> 2827;
2848 -> 2815;
2848 -> 2844;
2848 -> 2827;
2849 -> 2841;
2849 -> 2827;
2850 -> 2826;
2850 -> 2841;
2850 -> 2822;
2851 -> 0;
2851 -> 2822;
2852 -> 2840;
2852 -> 2822;
2853 -> 2815;
2853 -> 2807;
2854 -> 2815;
2854 -> 2807;
2855 -> 2807;
2856 -> 2812;
2856 -> 2794;
2856 -> 2855;
2856 -> 2807;
2857 -> 2813;
2857 -> 2815;
2857 -> 2807;
2858 -> 2812;
2858 -> 2815;
2858 -> 2807;
2859 -> 2848;
2859 -> 2815;
2859 -> 2807;
2860 -> 2794;
2861 -> 2802;
2861 -> 2860;
2861 -> 2794;
2862 -> 2496;
2862 -> 2805;
2862 -> 2841;
2862 -> 2815;
2862 -> 2824;
2862 -> 2844;
2862 -> 2850;
2862 -> 2825;
2862 -> 2857;
2862 -> 2859;
2862 -> 2858;
2862 -> 2822;
2862 -> 2794;
2863 -> 2862;
2864 -> 2863;
2864 -> 2862;
2865 -> 2862;
2866 -> 2862;
2867 -> 2863;
2867 -> 2862;
2868 -> 2865;
2868 -> 2862;
2869 -> 2866;
2869 -> 2862;
2870 -> 2862;
2871 -> 2862;
2872 -> 2862;
2873 -> 2871;
2873 -> 2862;
2874 -> 2873;
2874 -> 2862;
2875 -> 2874;
2875 -> 2871;
2876 -> 2871;
2877 -> 2871;
2878 -> 2871;
2879 -> 2871;
2880 -> 2871;
2881 -> 2871;
2881 -> 2862;
2882 -> 2871;
2883 -> 2871;
2884 -> 2871;
2885 -> 2871;
2886 -> 2871;
2887 -> 0;
2887 -> 2871;
2888 -> 2885;
2888 -> 2871;
2889 -> 2871;
2889 -> 2862;
2890 -> 2871;
2890 -> 2862;
2891 -> 2862;
2892 -> 2862;
2893 -> 2870;
2893 -> 2892;
2893 -> 2862;
2894 -> 2871;
2895 -> 2894;
2895 -> 2871;
2896 -> 2871;
2897 -> 2871;
2898 -> 2894;
2898 -> 2871;
2899 -> 2896;
2899 -> 2871;
2900 -> 2897;
2900 -> 2871;
2901 -> 2871;
2902 -> 2871;
2903 -> 2871;
2904 -> 2903;
2904 -> 2871;
2905 -> 2904;
2905 -> 2871;
2906 -> 2871;
2907 -> 2871;
2908 -> 2871;
2909 -> 2901;
2909 -> 2908;
2909 -> 2871;
2910 -> 2894;
2911 -> 2910;
2911 -> 2894;
2912 -> 2911;
2912 -> 2894;
2913 -> 2894;
2914 -> 2894;
2915 -> 2894;
2916 -> 2894;
2917 -> 2894;
2918 -> 2894;
2918 -> 2871;
2919 -> 2894;
2920 -> 2894;
2921 -> 2894;
2922 -> 2894;
2923 -> 2894;
2924 -> 0;
2924 -> 2894;
2925 -> 2922;
2925 -> 2894;
2926 -> 2894;
2927 -> 2894;
2928 -> 2894;
2929 -> 2894;
2930 -> 2927;
2930 -> 2894;
2931 -> 2928;
2931 -> 2894;
2932 -> 2894;
2933 -> 2894;
2934 -> 2894;
2935 -> 2894;
2936 -> 2932;
2936 -> 2935;
2936 -> 2894;
2937 -> 2927;
2937 -> 2894;
2938 -> 2927;
2939 -> 2938;
2939 -> 2927;
2940 -> 2939;
2940 -> 2927;
2941 -> 2927;
2942 -> 2927;
2943 -> 2927;
2944 -> 2927;
2945 -> 2927;
2946 -> 2927;
2946 -> 2894;
2947 -> 2927;
2948 -> 2927;
2949 -> 2927;
2950 -> 2927;
2951 -> 2927;
2952 -> 0;
2952 -> 2927;
2953 -> 2950;
2953 -> 2927;
2954 -> 2491;
2955 -> 0;
2955 -> 2491;
2956 -> 2954;
2956 -> 2955;
2956 -> 2496;
2956 -> 2927;
2956 -> 2491;
2957 -> 2956;
2957 -> 2954;
2958 -> 2957;
2958 -> 2956;
2958 -> 2954;
2959 -> 2496;
2959 -> 2958;
2959 -> 2491;
2960 -> 2491;
2961 -> 2500;
2961 -> 2960;
2961 -> 2491;
2962 -> 2489;
2962 -> 2959;
2962 -> 2491;
2963 -> 2958;
2963 -> 2491;
2964 -> 2491;
2965 -> 2491;
2966 -> 2962;
2966 -> 2965;
2966 -> 2491;
2967 -> 2958;
2967 -> 2966;
2968 -> 2966;
2969 -> 2967;
2969 -> 2968;
2970 -> 2495;
2970 -> 2968;
2971 -> 2968;
2972 -> 2970;
2972 -> 2962;
2972 -> 2971;
2972 -> 2968;
2973 -> 2968;
2974 -> 2970;
2974 -> 2962;
2974 -> 2973;
2975 -> 2974;
2975 -> 2968;
2976 -> 2969;
2976 -> 2962;
2976 -> 2968;
2977 -> 2976;
2978 -> 2977;
2979 -> 2977;
2980 -> 2977;
2980 -> 2979;
2981 -> 2980;
2981 -> 2962;
2981 -> 2979;
2982 -> 2981;
2982 -> 2977;
2983 -> 2977;
2984 -> 2970;
2984 -> 2962;
2984 -> 2982;
2984 -> 2983;
2984 -> 2977;
2985 -> 2984;
2985 -> 2977;
2986 -> 2977;
2987 -> 2977;
2987 -> 2986;
2988 -> 2987;
2988 -> 2984;
2988 -> 2986;
2989 -> 2988;
2989 -> 2977;
2990 -> 2975;
2990 -> 2989;
2990 -> 2977;
2991 -> 2984;
2992 -> 2984;
2993 -> 2984;
2994 -> 2984;
2994 -> 2993;
2995 -> 2994;
2995 -> 2984;
2995 -> 2993;
2996 -> 2995;
2996 -> 2984;
2997 -> 2975;
2997 -> 2996;
2997 -> 2984;
2998 -> 2966;
2999 -> 2427;
3000 -> 2419;
3001 -> 2413;
3002 -> 2413;
3003 -> 2413;
3004 -> 3003;
3004 -> 2413;
3005 -> 2414;
3005 -> 2413;
3006 -> 3002;
3006 -> 2413;
3007 -> 2415;
3007 -> 2984;
3007 -> 3005;
3007 -> 3006;
3007 -> 2413;
3008 -> 2414;
3008 -> 3007;
3009 -> 3003;
3009 -> 3007;
3010 -> 2415;
3010 -> 3007;
3010 -> 3008;
3010 -> 3009;
3010 -> 3004;
3011 -> 0;
3011 -> 2413;
3012 -> 3010;
3013 -> 3010;
3014 -> 3010;
3015 -> 3010;
3016 -> 3010;
3017 -> 3010;
3018 -> 3010;
3019 -> 3010;
3020 -> 3010;
3021 -> 3010;
3022 -> 3010;
3023 -> 3010;
3024 -> 3010;
3025 -> 3010;
3026 -> 3023;
3026 -> 3010;
3027 -> 3010;
3028 -> 3010;
3029 -> 3010;
3030 -> 3029;
3030 -> 3010;
3031 -> 3030;
3031 -> 3010;
3032 -> 3010;
3033 -> 3010;
3034 -> 3010;
3035 -> 3010;
3036 -> 3010;
3037 -> 3010;
3038 -> 3010;
3039 -> 3010;
3040 -> 3010;
3041 -> 3010;
3042 -> 3010;
3043 -> 3041;
3043 -> 3010;
3044 -> 3010;
3045 -> 3027;
3045 -> 3044;
3045 -> 3010;
3046 -> 3023;
3046 -> 3010;
3047 -> 3023;
3047 -> 3010;
3048 -> 3023;
3049 -> 3048;
3049 -> 3023;
3050 -> 3049;
3050 -> 3023;
3051 -> 3023;
3052 -> 3023;
3053 -> 3023;
3054 -> 3023;
3055 -> 3023;
3056 -> 3023;
3056 -> 3010;
3057 -> 3023;
3058 -> 3023;
3059 -> 3023;
3060 -> 3023;
3061 -> 3023;
3062 -> 3060;
3062 -> 3023;
3063 -> 3023;
3064 -> 3023;
3065 -> 3023;
3066 -> 3023;
3067 -> 3023;
3068 -> 3023;
3069 -> 3023;
3070 -> 3023;
3071 -> 3067;
3071 -> 3070;
3071 -> 3023;
3072 -> 3010;
3073 -> 3021;
3073 -> 3072;
3073 -> 3010;
3074 -> 3023;
3075 -> 3023;
3076 -> 3075;
3076 -> 3023;
3077 -> 3023;
3078 -> 3023;
3079 -> 3076;
3079 -> 3023;
3080 -> 3010;
3081 -> 0;
3081 -> 3010;
3082 -> 3023;
3083 -> 3023;
3084 -> 3023;
3085 -> 3023;
3086 -> 3023;
3087 -> 3023;
3088 -> 3023;
3089 -> 3023;
3090 -> 3023;
3091 -> 3023;
3092 -> 3023;
3093 -> 3091;
3093 -> 3092;
3093 -> 3023;
3094 -> 3075;
3095 -> 3075;
3096 -> 3075;
3097 -> 3094;
3097 -> 3075;
3098 -> 3023;
3099 -> 0;
3099 -> 3023;
3100 -> 3075;
3101 -> 3075;
3102 -> 3075;
3103 -> 3075;
3104 -> 3075;
3105 -> 3075;
3106 -> 3075;
3107 -> 3075;
3108 -> 3075;
3109 -> 3075;
3110 -> 3075;
3111 -> 3075;
3112 -> 3075;
3113 -> 3075;
3114 -> 3075;
3115 -> 3075;
3116 -> 3075;
3117 -> 3116;
3117 -> 3075;
3118 -> 3117;
3118 -> 3075;
3119 -> 3075;
3120 -> 3075;
3121 -> 3075;
3122 -> 3075;
3123 -> 3075;
3124 -> 3075;
3125 -> 3075;
3126 -> 3075;
3127 -> 3075;
3128 -> 3075;
3129 -> 3075;
3130 -> 3128;
3130 -> 3075;
3131 -> 3075;
3132 -> 3114;
3132 -> 3131;
3132 -> 3075;
3133 -> 3075;
3134 -> 3109;
3134 -> 3133;
3134 -> 3075;
3135 -> 3075;
3136 -> 0;
3136 -> 3075;
3137 -> 2201;
3138 -> 2411;
3138 -> 3137;
3138 -> 2201;
3139 -> 2203;
3139 -> 3075;
3139 -> 3138;
3140 -> 2203;
3140 -> 3138;
3141 -> 2411;
3141 -> 3075;
3141 -> 3138;
3142 -> 3138;
3143 -> 3138;
3144 -> 3139;
3144 -> 3143;
3145 -> 3140;
3145 -> 3143;
3146 -> 3141;
3146 -> 3143;
3147 -> 3142;
3147 -> 3143;
3148 -> 3143;
3149 -> 3146;
3149 -> 3141;
3149 -> 3148;
3149 -> 3143;
3150 -> 2205;
3150 -> 3146;
3150 -> 3138;
3151 -> 2205;
3151 -> 3150;
3151 -> 2201;
3152 -> 1;
3153 -> 1;
3154 -> 3152;
3154 -> 3153;
3155 -> 3151;
3155 -> 3153;
3156 -> 3153;
3157 -> 3156;
3157 -> 3153;
3158 -> 3153;
3159 -> 3158;
3160 -> 3155;
3161 -> 3160;
3161 -> 3155;
3162 -> 3155;
3163 -> 3155;
3164 -> 3161;
3164 -> 3163;
3165 -> 3162;
3165 -> 3163;
3166 -> 3162;
3166 -> 3163;
3167 -> 3162;
3167 -> 3163;
3168 -> 3162;
3168 -> 3163;
3170 -> 3169;
3172 -> 3171;
3174 -> 3173;
3176 -> 3175;
3178 -> 3177;
3180 -> 3179;
3181 -> 0;
3183 -> 3170;
3183 -> 3182;
3184 -> 3172;
3184 -> 3182;
3185 -> 3174;
3185 -> 3182;
3186 -> 3176;
3186 -> 3182;
3187 -> 3178;
3187 -> 3182;
3188 -> 3180;
3188 -> 3182;
3189 -> 3181;
3189 -> 3182;
3190 -> 3182;
3191 -> 3190;
3191 -> 3182;
3192 -> 3190;
3192 -> 3182;
3193 -> 3190;
3193 -> 3182;
3194 -> 3190;
3194 -> 3182;
3195 -> 3190;
3195 -> 3182;
3196 -> 3190;
3196 -> 3182;
3197 -> 3190;
3197 -> 3182;
3198 -> 3184;
3198 -> 3182;
3199 -> 3182;
3200 -> 3183;
3200 -> 3190;
3200 -> 3182;
3201 -> 3184;
3201 -> 3190;
3201 -> 3182;
3202 -> 3185;
3202 -> 3190;
3202 -> 3182;
3203 -> 3186;
3203 -> 3190;
3203 -> 3182;
3204 -> 3187;
3204 -> 3190;
3204 -> 3182;
3205 -> 3188;
3205 -> 3190;
3205 -> 3182;
3206 -> 3189;
3206 -> 3190;
3206 -> 3182;
3207 -> 3190;
3207 -> 3206;
3207 -> 0;
3207 -> 3182;
3208 -> 3182;
3209 -> 3188;
3209 -> 3182;
3210 -> 3182;
3212 -> 3211;
3214 -> 3213;
3216 -> 3215;
3218 -> 3217;
3220 -> 3219;
3222 -> 3221;
3223 -> 0;
3225 -> 3212;
3225 -> 3224;
3226 -> 3214;
3226 -> 3224;
3227 -> 3216;
3227 -> 3224;
3228 -> 3218;
3228 -> 3224;
3229 -> 3220;
3229 -> 3224;
3230 -> 3222;
3230 -> 3224;
3231 -> 3223;
3231 -> 3224;
3232 -> 3224;
3233 -> 3232;
3233 -> 3224;
3234 -> 3232;
3234 -> 3224;
3235 -> 3232;
3235 -> 3224;
3236 -> 3232;
3236 -> 3224;
3237 -> 3232;
3237 -> 3224;
3238 -> 3232;
3238 -> 3224;
3239 -> 3232;
3239 -> 3224;
3240 -> 3226;
3240 -> 3225;
3240 -> 3224;
3241 -> 3224;
3242 -> 3225;
3242 -> 3232;
3242 -> 3224;
3243 -> 3226;
3243 -> 3232;
3243 -> 3224;
3244 -> 3227;
3244 -> 3232;
3244 -> 3224;
3245 -> 3228;
3245 -> 3232;
3245 -> 3224;
3246 -> 3229;
3246 -> 3232;
3246 -> 3224;
3247 -> 3230;
3247 -> 3232;
3247 -> 3224;
3248 -> 3231;
3248 -> 3232;
3248 -> 3224;
3249 -> 3232;
3249 -> 3248;
3249 -> 0;
3249 -> 3224;
3250 -> 3224;
3251 -> 3230;
3251 -> 3224;
3252 -> 3224;
3254 -> 3253;
3256 -> 3255;
3258 -> 3257;
3260 -> 3259;
3262 -> 3261;
3264 -> 3263;
3265 -> 0;
3267 -> 3254;
3267 -> 3266;
3268 -> 3256;
3268 -> 3266;
3269 -> 3258;
3269 -> 3266;
3270 -> 3260;
3270 -> 3266;
3271 -> 3262;
3271 -> 3266;
3272 -> 3264;
3272 -> 3266;
3273 -> 3265;
3273 -> 3266;
3274 -> 3266;
3275 -> 3274;
3275 -> 3266;
3276 -> 3274;
3276 -> 3266;
3277 -> 3274;
3277 -> 3266;
3278 -> 3274;
3278 -> 3266;
3279 -> 3274;
3279 -> 3266;
3280 -> 3274;
3280 -> 3266;
3281 -> 3274;
3281 -> 3266;
3282 -> 3268;
3282 -> 3267;
3282 -> 3266;
3283 -> 3266;
3284 -> 3267;
3284 -> 3274;
3284 -> 3266;
3285 -> 3268;
3285 -> 3274;
3285 -> 3266;
3286 -> 3269;
3286 -> 3274;
3286 -> 3266;
3287 -> 3270;
3287 -> 3274;
3287 -> 3266;
3288 -> 3271;
3288 -> 3274;
3288 -> 3266;
3289 -> 3272;
3289 -> 3274;
3289 -> 3266;
3290 -> 3273;
3290 -> 3274;
3290 -> 3266;
3291 -> 3274;
3291 -> 3290;
3291 -> 0;
3291 -> 3266;
3292 -> 3266;
3293 -> 3272;
3293 -> 3266;
3294 -> 3266;
3296 -> 3295;
3298 -> 3297;
3300 -> 3299;
3302 -> 3301;
3304 -> 3303;
3306 -> 3305;
3307 -> 0;
3309 -> 3296;
3309 -> 3308;
3310 -> 3298;
3310 -> 3308;
3311 -> 3300;
3311 -> 3308;
3312 -> 3302;
3312 -> 3308;
3313 -> 3304;
3313 -> 3308;
3314 -> 3306;
3314 -> 3308;
3315 -> 3307;
3315 -> 3308;
3316 -> 3308;
3317 -> 3316;
3317 -> 3308;
3318 -> 3316;
3318 -> 3308;
3319 -> 3316;
3319 -> 3308;
3320 -> 3316;
3320 -> 3308;
3321 -> 3316;
3321 -> 3308;
3322 -> 3316;
3322 -> 3308;
3323 -> 3316;
3323 -> 3308;
3324 -> 3310;
3324 -> 3309;
3324 -> 3308;
3325 -> 3308;
3326 -> 3309;
3326 -> 3316;
3326 -> 3308;
3327 -> 3310;
3327 -> 3316;
3327 -> 3308;
3328 -> 3311;
3328 -> 3316;
3328 -> 3308;
3329 -> 3312;
3329 -> 3316;
3329 -> 3308;
3330 -> 3313;
3330 -> 3316;
3330 -> 3308;
3331 -> 3314;
3331 -> 3316;
3331 -> 3308;
3332 -> 3315;
3332 -> 3316;
3332 -> 3308;
3333 -> 3316;
3333 -> 3332;
3333 -> 0;
3333 -> 3308;
3334 -> 3308;
3335 -> 3314;
3335 -> 3308;
3336 -> 3316;
3336 -> 3332;
3336 -> 0;
3336 -> 3335;
3337 -> 3336;
3337 -> 3316;
3337 -> 3335;
3338 -> 3308;
3340 -> 3339;
3342 -> 3341;
3344 -> 3343;
3346 -> 3345;
3348 -> 3347;
3350 -> 3349;
3351 -> 0;
3353 -> 3340;
3353 -> 3352;
3354 -> 3342;
3354 -> 3352;
3355 -> 3344;
3355 -> 3352;
3356 -> 3346;
3356 -> 3352;
3357 -> 3348;
3357 -> 3352;
3358 -> 3350;
3358 -> 3352;
3359 -> 3351;
3359 -> 3352;
3360 -> 3352;
3361 -> 3360;
3361 -> 3352;
3362 -> 3360;
3362 -> 3352;
3363 -> 3360;
3363 -> 3352;
3364 -> 3360;
3364 -> 3352;
3365 -> 3360;
3365 -> 3352;
3366 -> 3360;
3366 -> 3352;
3367 -> 3360;
3367 -> 3352;
3368 -> 3354;
3368 -> 3353;
3368 -> 3352;
3369 -> 3352;
3370 -> 3353;
3370 -> 3360;
3370 -> 3352;
3371 -> 3354;
3371 -> 3360;
3371 -> 3352;
3372 -> 3355;
3372 -> 3360;
3372 -> 3352;
3373 -> 3356;
3373 -> 3360;
3373 -> 3352;
3374 -> 3357;
3374 -> 3360;
3374 -> 3352;
3375 -> 3358;
3375 -> 3360;
3375 -> 3352;
3376 -> 3359;
3376 -> 3360;
3376 -> 3352;
3377 -> 3360;
3377 -> 3376;
3377 -> 0;
3377 -> 3352;
3378 -> 3352;
3379 -> 3358;
3379 -> 3352;
3380 -> 3352;
3382 -> 3381;
3384 -> 3383;
3386 -> 3385;
3388 -> 3387;
3390 -> 3389;
3392 -> 3391;
3393 -> 0;
3395 -> 3382;
3395 -> 3394;
3396 -> 3384;
3396 -> 3394;
3397 -> 3386;
3397 -> 3394;
3398 -> 3388;
3398 -> 3394;
3399 -> 3390;
3399 -> 3394;
3400 -> 3392;
3400 -> 3394;
3401 -> 3393;
3401 -> 3394;
3402 -> 3394;
3403 -> 3402;
3403 -> 3394;
3404 -> 3402;
3404 -> 3394;
3405 -> 3402;
3405 -> 3394;
3406 -> 3402;
3406 -> 3394;
3407 -> 3402;
3407 -> 3394;
3408 -> 3402;
3408 -> 3394;
3409 -> 3402;
3409 -> 3394;
3410 -> 3396;
3410 -> 3395;
3410 -> 3394;
3411 -> 3394;
3412 -> 3395;
3412 -> 3402;
3412 -> 3394;
3413 -> 3396;
3413 -> 3402;
3413 -> 3394;
3414 -> 3397;
3414 -> 3402;
3414 -> 3394;
3415 -> 3398;
3415 -> 3402;
3415 -> 3394;
3416 -> 3399;
3416 -> 3402;
3416 -> 3394;
3417 -> 3400;
3417 -> 3402;
3417 -> 3394;
3418 -> 3401;
3418 -> 3402;
3418 -> 3394;
3419 -> 3402;
3419 -> 3418;
3419 -> 0;
3419 -> 3394;
3420 -> 3394;
3421 -> 3400;
3421 -> 3394;
3422 -> 3394;
3424 -> 3423;
3426 -> 3425;
3428 -> 3427;
3430 -> 3429;
3432 -> 3431;
3434 -> 3433;
3435 -> 0;
3437 -> 3424;
3437 -> 3436;
3438 -> 3426;
3438 -> 3436;
3439 -> 3428;
3439 -> 3436;
3440 -> 3430;
3440 -> 3436;
3441 -> 3432;
3441 -> 3436;
3442 -> 3434;
3442 -> 3436;
3443 -> 3435;
3443 -> 3436;
3444 -> 3436;
3445 -> 3444;
3445 -> 3436;
3446 -> 3444;
3446 -> 3436;
3447 -> 3444;
3447 -> 3436;
3448 -> 3444;
3448 -> 3436;
3449 -> 3444;
3449 -> 3436;
3450 -> 3444;
3450 -> 3436;
3451 -> 3444;
3451 -> 3436;
3452 -> 3438;
3452 -> 3436;
3453 -> 3436;
3454 -> 3437;
3454 -> 3444;
3454 -> 3436;
3455 -> 3438;
3455 -> 3444;
3455 -> 3436;
3456 -> 3439;
3456 -> 3444;
3456 -> 3436;
3457 -> 3440;
3457 -> 3444;
3457 -> 3436;
3458 -> 3441;
3458 -> 3444;
3458 -> 3436;
3459 -> 3442;
3459 -> 3444;
3459 -> 3436;
3460 -> 3443;
3460 -> 3444;
3460 -> 3436;
3461 -> 3444;
3461 -> 3460;
3461 -> 0;
3461 -> 3436;
3462 -> 3436;
3463 -> 3442;
3463 -> 3436;
3464 -> 3436;
3466 -> 3465;
3468 -> 3467;
3470 -> 3469;
3472 -> 3471;
3474 -> 3473;
3476 -> 3475;
3477 -> 0;
3478 -> 3477;
3480 -> 3466;
3480 -> 3479;
3481 -> 3468;
3481 -> 3479;
3482 -> 3470;
3482 -> 3479;
3483 -> 3472;
3483 -> 3479;
3484 -> 3474;
3484 -> 3479;
3485 -> 3476;
3485 -> 3479;
3486 -> 3478;
3486 -> 3479;
3487 -> 3479;
3488 -> 3487;
3488 -> 3479;
3489 -> 3487;
3489 -> 3479;
3490 -> 3487;
3490 -> 3479;
3491 -> 3487;
3491 -> 3479;
3492 -> 3487;
3492 -> 3479;
3493 -> 3487;
3493 -> 3479;
3494 -> 3487;
3494 -> 3479;
3495 -> 3481;
3495 -> 3479;
3496 -> 3479;
3497 -> 3480;
3497 -> 3487;
3497 -> 3479;
3498 -> 3481;
3498 -> 3487;
3498 -> 3479;
3499 -> 3482;
3499 -> 3487;
3499 -> 3479;
3500 -> 3483;
3500 -> 3487;
3500 -> 3479;
3501 -> 3484;
3501 -> 3487;
3501 -> 3479;
3502 -> 3485;
3502 -> 3487;
3502 -> 3479;
3503 -> 3486;
3503 -> 3487;
3503 -> 3479;
3504 -> 3487;
3504 -> 3503;
3504 -> 0;
3504 -> 3479;
3505 -> 3479;
3506 -> 3485;
3506 -> 3479;
3507 -> 3487;
3507 -> 3503;
3507 -> 0;
3507 -> 3506;
3508 -> 3507;
3508 -> 3487;
3508 -> 3506;
3509 -> 3479;
3511 -> 3510;
3513 -> 3512;
3515 -> 3514;
3517 -> 3516;
3519 -> 3518;
3521 -> 3520;
3522 -> 0;
3524 -> 3511;
3524 -> 3523;
3525 -> 3513;
3525 -> 3523;
3526 -> 3515;
3526 -> 3523;
3527 -> 3517;
3527 -> 3523;
3528 -> 3519;
3528 -> 3523;
3529 -> 3521;
3529 -> 3523;
3530 -> 3522;
3530 -> 3523;
3531 -> 3523;
3532 -> 3531;
3532 -> 3523;
3533 -> 3531;
3533 -> 3523;
3534 -> 3531;
3534 -> 3523;
3535 -> 3531;
3535 -> 3523;
3536 -> 3531;
3536 -> 3523;
3537 -> 3531;
3537 -> 3523;
3538 -> 3531;
3538 -> 3523;
3539 -> 3525;
3539 -> 3523;
3540 -> 3523;
3541 -> 3524;
3541 -> 3531;
3541 -> 3523;
3542 -> 3525;
3542 -> 3531;
3542 -> 3523;
3543 -> 3526;
3543 -> 3531;
3543 -> 3523;
3544 -> 3527;
3544 -> 3531;
3544 -> 3523;
3545 -> 3528;
3545 -> 3531;
3545 -> 3523;
3546 -> 3529;
3546 -> 3531;
3546 -> 3523;
3547 -> 3530;
3547 -> 3531;
3547 -> 3523;
3548 -> 3531;
3548 -> 3547;
3548 -> 0;
3548 -> 3523;
3549 -> 3523;
3550 -> 3529;
3550 -> 3523;
3551 -> 3531;
3551 -> 3547;
3551 -> 0;
3551 -> 3550;
3552 -> 3551;
3552 -> 3531;
3552 -> 3550;
3553 -> 3523;
3555 -> 3554;
3557 -> 3556;
3559 -> 3558;
3561 -> 3560;
3563 -> 3562;
3565 -> 3564;
3566 -> 0;
3568 -> 3555;
3568 -> 3567;
3569 -> 3557;
3569 -> 3567;
3570 -> 3559;
3570 -> 3567;
3571 -> 3561;
3571 -> 3567;
3572 -> 3563;
3572 -> 3567;
3573 -> 3565;
3573 -> 3567;
3574 -> 3566;
3574 -> 3567;
3575 -> 3567;
3576 -> 3575;
3576 -> 3567;
3577 -> 3575;
3577 -> 3567;
3578 -> 3575;
3578 -> 3567;
3579 -> 3575;
3579 -> 3567;
3580 -> 3575;
3580 -> 3567;
3581 -> 3575;
3581 -> 3567;
3582 -> 3575;
3582 -> 3567;
3583 -> 3569;
3583 -> 3567;
3584 -> 3567;
3585 -> 3568;
3585 -> 3575;
3585 -> 3567;
3586 -> 3569;
3586 -> 3575;
3586 -> 3567;
3587 -> 3570;
3587 -> 3575;
3587 -> 3567;
3588 -> 3571;
3588 -> 3575;
3588 -> 3567;
3589 -> 3572;
3589 -> 3575;
3589 -> 3567;
3590 -> 3573;
3590 -> 3575;
3590 -> 3567;
3591 -> 3574;
3591 -> 3575;
3591 -> 3567;
3592 -> 3575;
3592 -> 3591;
3592 -> 0;
3592 -> 3567;
3593 -> 3567;
3594 -> 3573;
3594 -> 3567;
3595 -> 3567;
3597 -> 3596;
3599 -> 3598;
3601 -> 3600;
3603 -> 3602;
3605 -> 3604;
3607 -> 3606;
3608 -> 0;
3609 -> 3608;
3609 -> 0;
3610 -> 3609;
3612 -> 3597;
3612 -> 3611;
3613 -> 3599;
3613 -> 3611;
3614 -> 3601;
3614 -> 3611;
3615 -> 3603;
3615 -> 3611;
3616 -> 3605;
3616 -> 3611;
3617 -> 3607;
3617 -> 3611;
3618 -> 3610;
3618 -> 3611;
3619 -> 3611;
3620 -> 3619;
3620 -> 3611;
3621 -> 3619;
3621 -> 3611;
3622 -> 3619;
3622 -> 3611;
3623 -> 3619;
3623 -> 3611;
3624 -> 3619;
3624 -> 3611;
3625 -> 3619;
3625 -> 3611;
3626 -> 3619;
3626 -> 3611;
3627 -> 3613;
3627 -> 3611;
3628 -> 3611;
3629 -> 3612;
3629 -> 3619;
3629 -> 3611;
3630 -> 3613;
3630 -> 3619;
3630 -> 3611;
3631 -> 3614;
3631 -> 3619;
3631 -> 3611;
3632 -> 3615;
3632 -> 3619;
3632 -> 3611;
3633 -> 3616;
3633 -> 3619;
3633 -> 3611;
3634 -> 3617;
3634 -> 3619;
3634 -> 3611;
3635 -> 3618;
3635 -> 3619;
3635 -> 3611;
3636 -> 3619;
3636 -> 3635;
3636 -> 0;
3636 -> 3611;
3637 -> 3611;
3638 -> 3617;
3638 -> 3611;
3639 -> 3611;
3641 -> 3640;
3643 -> 3642;
3645 -> 3644;
3647 -> 3646;
3649 -> 3648;
3651 -> 3650;
3652 -> 0;
3653 -> 3652;
3653 -> 0;
3654 -> 3653;
3656 -> 3641;
3656 -> 3655;
3657 -> 3643;
3657 -> 3655;
3658 -> 3645;
3658 -> 3655;
3659 -> 3647;
3659 -> 3655;
3660 -> 3649;
3660 -> 3655;
3661 -> 3651;
3661 -> 3655;
3662 -> 3654;
3662 -> 3655;
3663 -> 3655;
3664 -> 3663;
3664 -> 3655;
3665 -> 3663;
3665 -> 3655;
3666 -> 3663;
3666 -> 3655;
3667 -> 3663;
3667 -> 3655;
3668 -> 3663;
3668 -> 3655;
3669 -> 3663;
3669 -> 3655;
3670 -> 3663;
3670 -> 3655;
3671 -> 3657;
3671 -> 3655;
3672 -> 3655;
3673 -> 3656;
3673 -> 3663;
3673 -> 3655;
3674 -> 3657;
3674 -> 3663;
3674 -> 3655;
3675 -> 3658;
3675 -> 3663;
3675 -> 3655;
3676 -> 3659;
3676 -> 3663;
3676 -> 3655;
3677 -> 3660;
3677 -> 3663;
3677 -> 3655;
3678 -> 3661;
3678 -> 3663;
3678 -> 3655;
3679 -> 3662;
3679 -> 3663;
3679 -> 3655;
3680 -> 3663;
3680 -> 3679;
3680 -> 0;
3680 -> 3655;
3681 -> 3655;
3682 -> 3661;
3682 -> 3655;
3683 -> 3663;
3683 -> 3679;
3683 -> 0;
3683 -> 3682;
3684 -> 3683;
3684 -> 3663;
3684 -> 3682;
3685 -> 3655;
3687 -> 3686;
3689 -> 3688;
3691 -> 3690;
3693 -> 3692;
3695 -> 3694;
3697 -> 3696;
3698 -> 0;
3699 -> 3698;
3699 -> 0;
3700 -> 3699;
3702 -> 3687;
3702 -> 3701;
3703 -> 3689;
3703 -> 3701;
3704 -> 3691;
3704 -> 3701;
3705 -> 3693;
3705 -> 3701;
3706 -> 3695;
3706 -> 3701;
3707 -> 3697;
3707 -> 3701;
3708 -> 3700;
3708 -> 3701;
3709 -> 3701;
3710 -> 3709;
3710 -> 3701;
3711 -> 3709;
3711 -> 3701;
3712 -> 3709;
3712 -> 3701;
3713 -> 3709;
3713 -> 3701;
3714 -> 3709;
3714 -> 3701;
3715 -> 3709;
3715 -> 3701;
3716 -> 3709;
3716 -> 3701;
3717 -> 3703;
3717 -> 3701;
3718 -> 3701;
3719 -> 3702;
3719 -> 3709;
3719 -> 3701;
3720 -> 3703;
3720 -> 3709;
3720 -> 3701;
3721 -> 3704;
3721 -> 3709;
3721 -> 3701;
3722 -> 3705;
3722 -> 3709;
3722 -> 3701;
3723 -> 3706;
3723 -> 3709;
3723 -> 3701;
3724 -> 3707;
3724 -> 3709;
3724 -> 3701;
3725 -> 3708;
3725 -> 3709;
3725 -> 3701;
3726 -> 3709;
3726 -> 3725;
3726 -> 0;
3726 -> 3701;
3727 -> 3701;
3728 -> 3707;
3728 -> 3701;
3729 -> 3709;
3729 -> 3725;
3729 -> 0;
3729 -> 3728;
3730 -> 3729;
3730 -> 3709;
3730 -> 3728;
3731 -> 3701;
3733 -> 3732;
3735 -> 3734;
3737 -> 3736;
3739 -> 3738;
3741 -> 3740;
3743 -> 3742;
3744 -> 0;
3745 -> 3744;
3745 -> 0;
3746 -> 3745;
3748 -> 3733;
3748 -> 3747;
3749 -> 3735;
3749 -> 3747;
3750 -> 3737;
3750 -> 3747;
3751 -> 3739;
3751 -> 3747;
3752 -> 3741;
3752 -> 3747;
3753 -> 3743;
3753 -> 3747;
3754 -> 3746;
3754 -> 3747;
3755 -> 3747;
3756 -> 3755;
3756 -> 3747;
3757 -> 3755;
3757 -> 3747;
3758 -> 3755;
3758 -> 3747;
3759 -> 3755;
3759 -> 3747;
3760 -> 3755;
3760 -> 3747;
3761 -> 3755;
3761 -> 3747;
3762 -> 3755;
3762 -> 3747;
3763 -> 3749;
3763 -> 3747;
3764 -> 3747;
3765 -> 3748;
3765 -> 3755;
3765 -> 3747;
3766 -> 3749;
3766 -> 3755;
3766 -> 3747;
3767 -> 3750;
3767 -> 3755;
3767 -> 3747;
3768 -> 3751;
3768 -> 3755;
3768 -> 3747;
3769 -> 3752;
3769 -> 3755;
3769 -> 3747;
3770 -> 3753;
3770 -> 3755;
3770 -> 3747;
3771 -> 3754;
3771 -> 3755;
3771 -> 3747;
3772 -> 3755;
3772 -> 3771;
3772 -> 0;
3772 -> 3747;
3773 -> 3747;
3774 -> 3753;
3774 -> 3747;
3775 -> 3747;
3777 -> 3776;
3779 -> 3778;
3781 -> 3780;
3783 -> 3782;
3785 -> 3784;
3787 -> 3786;
3788 -> 0;
3789 -> 3788;
3789 -> 0;
3790 -> 3789;
3792 -> 3777;
3792 -> 3791;
3793 -> 3779;
3793 -> 3791;
3794 -> 3781;
3794 -> 3791;
3795 -> 3783;
3795 -> 3791;
3796 -> 3785;
3796 -> 3791;
3797 -> 3787;
3797 -> 3791;
3798 -> 3790;
3798 -> 3791;
3799 -> 3791;
3800 -> 3799;
3800 -> 3791;
3801 -> 3799;
3801 -> 3791;
3802 -> 3799;
3802 -> 3791;
3803 -> 3799;
3803 -> 3791;
3804 -> 3799;
3804 -> 3791;
3805 -> 3799;
3805 -> 3791;
3806 -> 3799;
3806 -> 3791;
3807 -> 3793;
3807 -> 3792;
3807 -> 3791;
3808 -> 3791;
3809 -> 3792;
3809 -> 3799;
3809 -> 3791;
3810 -> 3793;
3810 -> 3799;
3810 -> 3791;
3811 -> 3794;
3811 -> 3799;
3811 -> 3791;
3812 -> 3795;
3812 -> 3799;
3812 -> 3791;
3813 -> 3796;
3813 -> 3799;
3813 -> 3791;
3814 -> 3797;
3814 -> 3799;
3814 -> 3791;
3815 -> 3798;
3815 -> 3799;
3815 -> 3791;
3816 -> 3799;
3816 -> 3815;
3816 -> 0;
3816 -> 3791;
3817 -> 3791;
3818 -> 3797;
3818 -> 3791;
3819 -> 3799;
3819 -> 3815;
3819 -> 0;
3819 -> 3818;
3820 -> 3819;
3820 -> 3799;
3820 -> 3818;
3821 -> 3791;
3823 -> 3822;
3825 -> 3824;
3827 -> 3826;
3829 -> 3828;
3831 -> 3830;
3833 -> 3832;
3834 -> 0;
3835 -> 3834;
3835 -> 0;
3836 -> 3835;
3838 -> 3823;
3838 -> 3837;
3839 -> 3825;
3839 -> 3837;
3840 -> 3827;
3840 -> 3837;
3841 -> 3829;
3841 -> 3837;
3842 -> 3831;
3842 -> 3837;
3843 -> 3833;
3843 -> 3837;
3844 -> 3836;
3844 -> 3837;
3845 -> 3837;
3846 -> 3845;
3846 -> 3837;
3847 -> 3845;
3847 -> 3837;
3848 -> 3845;
3848 -> 3837;
3849 -> 3845;
3849 -> 3837;
3850 -> 3845;
3850 -> 3837;
3851 -> 3845;
3851 -> 3837;
3852 -> 3845;
3852 -> 3837;
3853 -> 3839;
3853 -> 3838;
3853 -> 3837;
3854 -> 3837;
3855 -> 3838;
3855 -> 3845;
3855 -> 3837;
3856 -> 3839;
3856 -> 3845;
3856 -> 3837;
3857 -> 3840;
3857 -> 3845;
3857 -> 3837;
3858 -> 3841;
3858 -> 3845;
3858 -> 3837;
3859 -> 3842;
3859 -> 3845;
3859 -> 3837;
3860 -> 3843;
3860 -> 3845;
3860 -> 3837;
3861 -> 3844;
3861 -> 3845;
3861 -> 3837;
3862 -> 3845;
3862 -> 3861;
3862 -> 0;
3862 -> 3837;
3863 -> 3837;
3864 -> 3843;
3864 -> 3837;
3865 -> 3837;
3867 -> 3866;
3869 -> 3868;
3871 -> 3870;
3873 -> 3872;
3875 -> 3874;
3877 -> 3876;
3878 -> 0;
3879 -> 3878;
3879 -> 0;
3880 -> 3879;
3882 -> 3867;
3882 -> 3881;
3883 -> 3869;
3883 -> 3881;
3884 -> 3871;
3884 -> 3881;
3885 -> 3873;
3885 -> 3881;
3886 -> 3875;
3886 -> 3881;
3887 -> 3877;
3887 -> 3881;
3888 -> 3880;
3888 -> 3881;
3889 -> 3881;
3890 -> 3889;
3890 -> 3881;
3891 -> 3889;
3891 -> 3881;
3892 -> 3889;
3892 -> 3881;
3893 -> 3889;
3893 -> 3881;
3894 -> 3889;
3894 -> 3881;
3895 -> 3889;
3895 -> 3881;
3896 -> 3889;
3896 -> 3881;
3897 -> 3883;
3897 -> 3881;
3898 -> 3881;
3899 -> 3882;
3899 -> 3889;
3899 -> 3881;
3900 -> 3883;
3900 -> 3889;
3900 -> 3881;
3901 -> 3884;
3901 -> 3889;
3901 -> 3881;
3902 -> 3885;
3902 -> 3889;
3902 -> 3881;
3903 -> 3886;
3903 -> 3889;
3903 -> 3881;
3904 -> 3887;
3904 -> 3889;
3904 -> 3881;
3905 -> 3888;
3905 -> 3889;
3905 -> 3881;
3906 -> 3889;
3906 -> 3905;
3906 -> 0;
3906 -> 3881;
3907 -> 3881;
3908 -> 3887;
3908 -> 3881;
3909 -> 3881;
3911 -> 3910;
3913 -> 3912;
3915 -> 3914;
3917 -> 3916;
3919 -> 3918;
3921 -> 3920;
3922 -> 0;
3923 -> 3922;
3923 -> 0;
3924 -> 3923;
3926 -> 3911;
3926 -> 3925;
3927 -> 3913;
3927 -> 3925;
3928 -> 3915;
3928 -> 3925;
3929 -> 3917;
3929 -> 3925;
3930 -> 3919;
3930 -> 3925;
3931 -> 3921;
3931 -> 3925;
3932 -> 3924;
3932 -> 3925;
3933 -> 3925;
3934 -> 3933;
3934 -> 3925;
3935 -> 3933;
3935 -> 3925;
3936 -> 3933;
3936 -> 3925;
3937 -> 3933;
3937 -> 3925;
3938 -> 3933;
3938 -> 3925;
3939 -> 3933;
3939 -> 3925;
3940 -> 3933;
3940 -> 3925;
3941 -> 3927;
3941 -> 3925;
3942 -> 3925;
3943 -> 3926;
3943 -> 3933;
3943 -> 3925;
3944 -> 3927;
3944 -> 3933;
3944 -> 3925;
3945 -> 3928;
3945 -> 3933;
3945 -> 3925;
3946 -> 3929;
3946 -> 3933;
3946 -> 3925;
3947 -> 3930;
3947 -> 3933;
3947 -> 3925;
3948 -> 3931;
3948 -> 3933;
3948 -> 3925;
3949 -> 3932;
3949 -> 3933;
3949 -> 3925;
3950 -> 3933;
3950 -> 3949;
3950 -> 0;
3950 -> 3925;
3951 -> 3925;
3952 -> 3931;
3952 -> 3925;
3953 -> 3925;
3954 -> 3380;
3955 -> 3954;
3955 -> 3370;
3955 -> 3371;
3955 -> 3372;
3955 -> 3373;
3955 -> 3374;
3955 -> 3375;
3955 -> 3376;
3956 -> 3955;
3957 -> 0;
3958 -> 3957;
3959 -> 3958;
3960 -> 0;
3961 -> 3960;
3962 -> 0;
3963 -> 3962;
3964 -> 3164;
3964 -> 3163;
3965 -> 3165;
3965 -> 3163;
3966 -> 3166;
3966 -> 3163;
3967 -> 3167;
3967 -> 3163;
3968 -> 3163;
3969 -> 3964;
3969 -> 3968;
3970 -> 3965;
3970 -> 3968;
3971 -> 3966;
3971 -> 3968;
3972 -> 3967;
3972 -> 3968;
3973 -> 3168;
3973 -> 3968;
3974 -> 3972;
3974 -> 3968;
3975 -> 3968;
3976 -> 3974;
3976 -> 3975;
3977 -> 3973;
3977 -> 3975;
3978 -> 3973;
3978 -> 3968;
3979 -> 3973;
3979 -> 3968;
3980 -> 3973;
3980 -> 3968;
3982 -> 3981;
3983 -> 3982;
3983 -> 3981;
3984 -> 3982;
3984 -> 3981;
3985 -> 3982;
3985 -> 3981;
3986 -> 3982;
3986 -> 3981;
3987 -> 3982;
3987 -> 3981;
3988 -> 3982;
3988 -> 3981;
3989 -> 3981;
3990 -> 3989;
3990 -> 3973;
3990 -> 3968;
3991 -> 3973;
3991 -> 3968;
3992 -> 3973;
3992 -> 3968;
3993 -> 3973;
3993 -> 3968;
3994 -> 3973;
3994 -> 3968;
3995 -> 3973;
3995 -> 3968;
3996 -> 2121;
3996 -> 3973;
3996 -> 3968;
3997 -> 3973;
3997 -> 3968;
3998 -> 3973;
3998 -> 3968;
3999 -> 3969;
3999 -> 3973;
3999 -> 3968;
4000 -> 3970;
4000 -> 3973;
4000 -> 3968;
4001 -> 3970;
4001 -> 3155;
4001 -> 3968;
4002 -> 3968;
4003 -> 4001;
4003 -> 4002;
4004 -> 4003;
4004 -> 4002;
4005 -> 0;
4005 -> 4004;
4006 -> 4005;
4006 -> 3968;
4007 -> 3971;
4007 -> 3968;
4008 -> 3968;
4009 -> 4006;
4009 -> 4008;
4010 -> 4007;
4010 -> 4008;
4011 -> 3973;
4011 -> 4008;
4012 -> 4008;
4013 -> 4011;
4013 -> 4012;
4014 -> 4013;
4014 -> 3999;
4014 -> 4012;
4015 -> 4014;
4015 -> 4008;
4016 -> 4008;
4017 -> 0;
4017 -> 4008;
4018 -> 4008;
4019 -> 4015;
4019 -> 4018;
4020 -> 4018;
4020 -> 4008;
4021 -> 0;
4021 -> 4020;
4022 -> 4009;
4022 -> 4008;
4023 -> 0;
4023 -> 4022;
4024 -> 4017;
4024 -> 4023;
4024 -> 4022;
4025 -> 4022;
4026 -> 4011;
4026 -> 4025;
4027 -> 4025;
4028 -> 4026;
4028 -> 4000;
4028 -> 3155;
4028 -> 4027;
4028 -> 4025;
4029 -> 4028;
4029 -> 4022;
4030 -> 4024;
4030 -> 0;
4030 -> 4029;
4031 -> 4008;
4032 -> 4021;
4032 -> 4008;
4033 -> 4030;
4033 -> 4008;
4034 -> 4010;
4034 -> 4008;
4035 -> 4031;
4035 -> 4008;
4036 -> 4008;
4037 -> 4032;
4037 -> 4036;
4038 -> 4033;
4038 -> 4036;
4039 -> 4034;
4039 -> 4036;
4040 -> 4035;
4040 -> 4036;
4041 -> 4011;
4041 -> 4036;
4042 -> 4036;
4043 -> 0;
4043 -> 4036;
4044 -> 4041;
4044 -> 4000;
4044 -> 4028;
4044 -> 4036;
4045 -> 4036;
4046 -> 4036;
4047 -> 4046;
4047 -> 4044;
4047 -> 4036;
4048 -> 4041;
4048 -> 4000;
4048 -> 4028;
4048 -> 4046;
4048 -> 4047;
4049 -> 4048;
4049 -> 4047;
4050 -> 4047;
4051 -> 4042;
4051 -> 4047;
4052 -> 4049;
4052 -> 4051;
4053 -> 4038;
4053 -> 4051;
4054 -> 4041;
4054 -> 4000;
4054 -> 4048;
4054 -> 4046;
4054 -> 4051;
4055 -> 4039;
4055 -> 4051;
4056 -> 4051;
4057 -> 4042;
4057 -> 4051;
4058 -> 4051;
4059 -> 4052;
4059 -> 4058;
4060 -> 4053;
4060 -> 4058;
4061 -> 4054;
4061 -> 4058;
4062 -> 4055;
4062 -> 4058;
4063 -> 4056;
4063 -> 4058;
4064 -> 4057;
4064 -> 4058;
4065 -> 4058;
4066 -> 4059;
4066 -> 4060;
4066 -> 4058;
4067 -> 4059;
4067 -> 4060;
4067 -> 4058;
4068 -> 4066;
4068 -> 0;
4068 -> 4058;
4069 -> 4067;
4069 -> 0;
4069 -> 4058;
4070 -> 4058;
4071 -> 4067;
4071 -> 4058;
4072 -> 4065;
4072 -> 4051;
4073 -> 4071;
4073 -> 4072;
4074 -> 4041;
4074 -> 4072;
4075 -> 4072;
4076 -> 4072;
4077 -> 4073;
4077 -> 4076;
4078 -> 4074;
4078 -> 4076;
4079 -> 4075;
4079 -> 4076;
4080 -> 4077;
4080 -> 4076;
4081 -> 4076;
4082 -> 4080;
4082 -> 4081;
4083 -> 4082;
4083 -> 0;
4083 -> 4081;
4084 -> 4083;
4085 -> 4076;
4086 -> 4078;
4086 -> 4085;
4087 -> 0;
4087 -> 4085;
4088 -> 4087;
4088 -> 4076;
4089 -> 4079;
4089 -> 4088;
4089 -> 4076;
4090 -> 4077;
4090 -> 0;
4090 -> 4076;
4091 -> 4076;
4092 -> 4089;
4092 -> 4090;
4092 -> 4076;
4093 -> 4077;
4093 -> 0;
4093 -> 4092;
4094 -> 4076;
4095 -> 4094;
4095 -> 4072;
4096 -> 4072;
4097 -> 4095;
4097 -> 4096;
4097 -> 4072;
4098 -> 4043;
4098 -> 0;
4098 -> 4047;
4099 -> 4071;
4099 -> 4098;
4100 -> 4099;
4100 -> 0;
4100 -> 4036;
4101 -> 4036;
4102 -> 4099;
4102 -> 4037;
4102 -> 4100;
4103 -> 4045;
4103 -> 4036;
4104 -> 4036;
4105 -> 4041;
4105 -> 4104;
4106 -> 4105;
4106 -> 4000;
4106 -> 4054;
4106 -> 4104;
4107 -> 4106;
4107 -> 4036;
4108 -> 0;
4108 -> 4036;
4109 -> 4102;
4109 -> 4036;
4111 -> 4110;
4112 -> 4011;
4112 -> 4008;
4113 -> 4109;
4113 -> 4008;
4114 -> 4010;
4114 -> 4008;
4115 -> 4008;
4116 -> 4112;
4116 -> 4115;
4117 -> 4113;
4117 -> 4115;
4118 -> 4114;
4118 -> 4115;
4119 -> 4116;
4119 -> 4115;
4120 -> 4117;
4120 -> 4115;
4121 -> 4115;
4122 -> 4116;
4122 -> 4121;
4123 -> 4122;
4123 -> 4000;
4123 -> 4054;
4123 -> 4121;
4124 -> 4123;
4124 -> 4115;
4125 -> 4115;
4126 -> 4118;
4126 -> 4115;
4127 -> 4115;
4128 -> 4119;
4128 -> 4127;
4129 -> 4120;
4129 -> 4127;
4130 -> 4124;
4130 -> 4127;
4131 -> 4126;
4131 -> 4127;
4132 -> 4129;
4132 -> 0;
4132 -> 4127;
4133 -> 4008;
4134 -> 4109;
4134 -> 0;
4134 -> 4008;
4135 -> 4008;
4136 -> 4065;
4136 -> 4134;
4136 -> 4008;
4137 -> 0;
4137 -> 4008;
4138 -> 4109;
4138 -> 4137;
4138 -> 4008;
4139 -> 4065;
4139 -> 4138;
4139 -> 4008;
4140 -> 4009;
4140 -> 4008;
4141 -> 4109;
4141 -> 4008;
4142 -> 3970;
4142 -> 4124;
4142 -> 3968;
4143 -> 4142;
4143 -> 4124;
4144 -> 3971;
4144 -> 4143;
4144 -> 3155;
4144 -> 4124;
4144 -> 4142;
4145 -> 4141;
4145 -> 0;
4145 -> 3968;
4146 -> 3968;
4147 -> 4145;
4147 -> 4146;
4147 -> 3968;
4148 -> 4141;
4148 -> 3973;
4148 -> 3968;
4149 -> 4145;
4149 -> 0;
4149 -> 3968;
4150 -> 4149;
4150 -> 3968;
4152 -> 4151;
4154 -> 4153;
4155 -> 4152;
4155 -> 4154;
4156 -> 4155;
4158 -> 4157;
4159 -> 4156;
4159 -> 4158;
4160 -> 4159;
4162 -> 4161;
4163 -> 4160;
4163 -> 4162;
4164 -> 4163;
4166 -> 4165;
4167 -> 4164;
4167 -> 4166;
4168 -> 4167;
4170 -> 4169;
4171 -> 4168;
4171 -> 4170;
4172 -> 4171;
4174 -> 4173;
4176 -> 4175;
4176 -> 4154;
4178 -> 4176;
4178 -> 4177;
4179 -> 4178;
4181 -> 4180;
4181 -> 4158;
4183 -> 4181;
4183 -> 4182;
4184 -> 4183;
4186 -> 4185;
4186 -> 4170;
4188 -> 4186;
4188 -> 4187;
4189 -> 4188;
4191 -> 4190;
4191 -> 4174;
4193 -> 4191;
4193 -> 4192;
4194 -> 4193;
4196 -> 4195;
4196 -> 4160;
4197 -> 4196;
4199 -> 4198;
4199 -> 4164;
4200 -> 4199;
4201 -> 4179;
4202 -> 4194;
4203 -> 4150;
4203 -> 3968;
4204 -> 4005;
4204 -> 3968;
4205 -> 3968;
4206 -> 3968;
4207 -> 4203;
4207 -> 4206;
4208 -> 4204;
4208 -> 4206;
4209 -> 4205;
4209 -> 4206;
4210 -> 4207;
4210 -> 4179;
4210 -> 4206;
4211 -> 4210;
4211 -> 4152;
4211 -> 4206;
4212 -> 4208;
4212 -> 4189;
4212 -> 4206;
4213 -> 4212;
4213 -> 4168;
4213 -> 4206;
4214 -> 4211;
4214 -> 4213;
4214 -> 4206;
4215 -> 4214;
4215 -> 4209;
4215 -> 4206;
4216 -> 4205;
4216 -> 3973;
4216 -> 3968;
4217 -> 3968;
4218 -> 3973;
4218 -> 4217;
4219 -> 4218;
4219 -> 3999;
4219 -> 4217;
4220 -> 4219;
4220 -> 3968;
4221 -> 4220;
4221 -> 3968;
4222 -> 3968;
4223 -> 0;
4223 -> 3968;
4224 -> 3968;
4225 -> 4223;
4225 -> 4224;
4226 -> 3973;
4226 -> 4224;
4227 -> 4226;
4227 -> 4225;
4227 -> 4224;
4228 -> 3168;
4228 -> 3163;
4229 -> 3168;
4229 -> 3163;
4230 -> 3168;
4230 -> 3163;
4231 -> 0;
4231 -> 3168;
4231 -> 3163;
4232 -> 3168;
4232 -> 3163;
4233 -> 2648;
4233 -> 3168;
4233 -> 3163;
4234 -> 3168;
4234 -> 3163;
4235 -> 2648;
4235 -> 3168;
4235 -> 3163;
4236 -> 3165;
4236 -> 4144;
4236 -> 3163;
4237 -> 3163;
4238 -> 3164;
4238 -> 4237;
4239 -> 4237;
4239 -> 3163;
4240 -> 3162;
4240 -> 3155;
4241 -> 4240;
4241 -> 4000;
4241 -> 4144;
4241 -> 3155;
4242 -> 3155;
4242 -> 4144;
4243 -> 4242;
4243 -> 4144;
4244 -> 4144;
4245 -> 4243;
4245 -> 4144;
4246 -> 4244;
4246 -> 4144;
4247 -> 4245;
4247 -> 4144;
4248 -> 4246;
4248 -> 4144;
4249 -> 4248;
4249 -> 4144;
4250 -> 4144;
4251 -> 4144;
4252 -> 4144;
4253 -> 4144;
4254 -> 3989;
4254 -> 4144;
4255 -> 4144;
4256 -> 4144;
4257 -> 4144;
4258 -> 4144;
4259 -> 4144;
4260 -> 2121;
4260 -> 4144;
4261 -> 4144;
4262 -> 4144;
4263 -> 4247;
4263 -> 4144;
4264 -> 4144;
4265 -> 4144;
4266 -> 4144;
4266 -> 4265;
4267 -> 4266;
4267 -> 4263;
4267 -> 4265;
4268 -> 4267;
4268 -> 4144;
4269 -> 4144;
4270 -> 0;
4270 -> 4144;
4271 -> 4144;
4272 -> 4268;
4272 -> 4271;
4273 -> 4271;
4273 -> 4144;
4274 -> 0;
4274 -> 4273;
4275 -> 0;
4275 -> 4144;
4276 -> 4270;
4276 -> 4275;
4276 -> 4144;
4277 -> 4144;
4278 -> 4276;
4278 -> 0;
4278 -> 4277;
4279 -> 4144;
4280 -> 4274;
4280 -> 4144;
4281 -> 4278;
4281 -> 4144;
4282 -> 4264;
4282 -> 4144;
4283 -> 4279;
4283 -> 4144;
4284 -> 4280;
4284 -> 4144;
4285 -> 4281;
4285 -> 4144;
4286 -> 4282;
4286 -> 4144;
4287 -> 4283;
4287 -> 4144;
4288 -> 0;
4288 -> 4144;
4289 -> 4144;
4290 -> 4144;
4291 -> 4144;
4292 -> 4144;
4293 -> 4290;
4293 -> 4292;
4294 -> 4285;
4294 -> 4292;
4295 -> 4290;
4295 -> 4292;
4296 -> 4286;
4296 -> 4292;
4297 -> 4290;
4297 -> 4292;
4298 -> 4290;
4298 -> 4292;
4299 -> 4292;
4300 -> 4293;
4300 -> 4294;
4300 -> 4292;
4301 -> 4293;
4301 -> 4294;
4301 -> 4292;
4302 -> 4300;
4302 -> 0;
4302 -> 4292;
4303 -> 4301;
4303 -> 0;
4303 -> 4292;
4304 -> 4292;
4305 -> 4301;
4305 -> 4292;
4306 -> 4299;
4306 -> 4144;
4307 -> 4305;
4307 -> 4306;
4308 -> 4144;
4308 -> 4306;
4309 -> 4306;
4310 -> 4306;
4311 -> 4307;
4311 -> 4310;
4312 -> 4308;
4312 -> 4310;
4313 -> 4309;
4313 -> 4310;
4314 -> 4311;
4314 -> 4310;
4315 -> 4310;
4316 -> 4314;
4316 -> 4315;
4317 -> 4316;
4317 -> 0;
4317 -> 4315;
4318 -> 4317;
4319 -> 4310;
4320 -> 4312;
4320 -> 4319;
4321 -> 0;
4321 -> 4319;
4322 -> 4321;
4322 -> 4310;
4323 -> 4313;
4323 -> 4322;
4323 -> 4310;
4324 -> 4311;
4324 -> 0;
4324 -> 4310;
4325 -> 4310;
4326 -> 4323;
4326 -> 4324;
4326 -> 4310;
4327 -> 4311;
4327 -> 0;
4327 -> 4326;
4328 -> 4310;
4329 -> 4328;
4329 -> 4306;
4330 -> 4306;
4331 -> 4329;
4331 -> 4330;
4331 -> 4306;
4332 -> 4288;
4332 -> 0;
4332 -> 4144;
4333 -> 4305;
4333 -> 4332;
4334 -> 4333;
4334 -> 0;
4334 -> 4144;
4335 -> 4144;
4336 -> 4333;
4336 -> 4284;
4336 -> 4334;
4337 -> 4289;
4337 -> 4144;
4338 -> 4144;
4339 -> 4144;
4339 -> 4338;
4340 -> 4339;
4340 -> 4144;
4340 -> 4290;
4340 -> 4338;
4341 -> 4340;
4341 -> 4144;
4342 -> 0;
4342 -> 4144;
4343 -> 4336;
4343 -> 4144;
4344 -> 4343;
4344 -> 4144;
4345 -> 4264;
4345 -> 4144;
4346 -> 4144;
4347 -> 4144;
4347 -> 4346;
4348 -> 4344;
4348 -> 4346;
4349 -> 4290;
4349 -> 4346;
4350 -> 4345;
4350 -> 4346;
4351 -> 4348;
4351 -> 0;
4351 -> 4346;
4352 -> 4343;
4352 -> 0;
4352 -> 4144;
4353 -> 4144;
4354 -> 4299;
4354 -> 4352;
4354 -> 4144;
4355 -> 0;
4355 -> 4144;
4356 -> 4343;
4356 -> 4355;
4356 -> 4144;
4357 -> 4299;
4357 -> 4356;
4357 -> 4144;
4358 -> 4144;
4359 -> 4343;
4359 -> 4144;
4360 -> 4359;
4360 -> 0;
4360 -> 4144;
4361 -> 4144;
4362 -> 4360;
4362 -> 4361;
4362 -> 4144;
4363 -> 4359;
4363 -> 4144;
4364 -> 4360;
4364 -> 0;
4364 -> 4144;
4365 -> 4364;
4365 -> 4144;
4366 -> 4365;
4366 -> 4144;
4367 -> 4144;
4368 -> 4144;
4369 -> 4366;
4369 -> 4368;
4370 -> 4367;
4370 -> 4368;
4371 -> 4367;
4371 -> 4368;
4372 -> 4369;
4372 -> 4179;
4372 -> 4368;
4373 -> 4372;
4373 -> 4152;
4373 -> 4368;
4374 -> 4370;
4374 -> 4189;
4374 -> 4368;
4375 -> 4374;
4375 -> 4168;
4375 -> 4368;
4376 -> 4373;
4376 -> 4375;
4376 -> 4368;
4377 -> 4376;
4377 -> 4371;
4377 -> 4368;
4378 -> 4367;
4378 -> 4144;
4379 -> 4144;
4380 -> 4144;
4380 -> 4379;
4381 -> 4380;
4381 -> 4263;
4381 -> 4379;
4382 -> 4381;
4382 -> 4144;
4383 -> 4382;
4383 -> 4144;
4384 -> 4144;
4385 -> 0;
4385 -> 4144;
4386 -> 4144;
4387 -> 4385;
4387 -> 4386;
4388 -> 4144;
4389 -> 4144;
4390 -> 4144;
4391 -> 0;
4391 -> 4144;
4392 -> 4144;
4393 -> 2648;
4393 -> 4144;
4394 -> 4144;
4395 -> 2648;
4395 -> 4144;
4396 -> 4144;
4396 -> 4290;
4397 -> 4144;
4398 -> 4243;
4398 -> 4397;
4399 -> 4397;
4399 -> 4144;
4400 -> 4144;
4401 -> 4400;
4401 -> 4144;
4401 -> 4290;
4402 -> 4401;
4403 -> 4402;
4403 -> 4401;
4404 -> 4401;
4405 -> 0;
4405 -> 4401;
4406 -> 4405;
4407 -> 4406;
4407 -> 4405;
4408 -> 4405;
4409 -> 3155;
4410 -> 3155;
4411 -> 3155;
4412 -> 3155;
4413 -> 3155;
4414 -> 4409;
4414 -> 4413;
4415 -> 4413;
4416 -> 4414;
4416 -> 4290;
4416 -> 4415;
4417 -> 4416;
4417 -> 4290;
4417 -> 4415;
4418 -> 4417;
4418 -> 3155;
4419 -> 3155;
4420 -> 4418;
4420 -> 4419;
4421 -> 3155;
4422 -> 4411;
4422 -> 4405;
4423 -> 4405;
4424 -> 4405;
4425 -> 4405;
4426 -> 4424;
4426 -> 4425;
4426 -> 4405;
4427 -> 4426;
4427 -> 4405;
4428 -> 4427;
4429 -> 4424;
4429 -> 4428;
4430 -> 4429;
4430 -> 4405;
4430 -> 4428;
4431 -> 4430;
4431 -> 4411;
4431 -> 4422;
4431 -> 4405;
4432 -> 4411;
4432 -> 4422;
4432 -> 4430;
4432 -> 4405;
4433 -> 4405;
4434 -> 4432;
4434 -> 4433;
4434 -> 4405;
4435 -> 4412;
4435 -> 4433;
4435 -> 4405;
4436 -> 4434;
4436 -> 4435;
4436 -> 4405;
4437 -> 4405;
4438 -> 4432;
4438 -> 4437;
4438 -> 4405;
4439 -> 4405;
4439 -> 4430;
4439 -> 4411;
4440 -> 4405;
4441 -> 4424;
4441 -> 4440;
4441 -> 4405;
4442 -> 4441;
4443 -> 4424;
4443 -> 4442;
4444 -> 4443;
4444 -> 4405;
4444 -> 4442;
4445 -> 4442;
4446 -> 4444;
4446 -> 4445;
4447 -> 4446;
4447 -> 0;
4447 -> 4445;
4448 -> 0;
4448 -> 4447;
4449 -> 4448;
4449 -> 4441;
4450 -> 4449;
4450 -> 0;
4450 -> 4441;
4451 -> 4411;
4451 -> 4422;
4451 -> 4439;
4451 -> 4405;
4452 -> 4451;
4452 -> 4411;
4453 -> 4411;
4453 -> 4451;
4454 -> 4451;
4455 -> 4453;
4455 -> 4454;
4455 -> 4451;
4456 -> 4412;
4456 -> 4454;
4456 -> 4451;
4457 -> 4455;
4457 -> 4456;
4457 -> 4451;
4458 -> 4451;
4459 -> 4453;
4459 -> 4458;
4459 -> 4451;
4460 -> 4451;
4461 -> 4460;
4462 -> 4451;
4462 -> 4461;
4463 -> 4462;
4463 -> 4451;
4463 -> 4461;
4464 -> 4461;
4465 -> 4463;
4465 -> 4464;
4466 -> 4465;
4466 -> 0;
4466 -> 4464;
4467 -> 0;
4467 -> 4466;
4468 -> 4467;
4468 -> 4460;
4469 -> 4468;
4469 -> 0;
4469 -> 4460;
4470 -> 4451;
4471 -> 4451;
4471 -> 4470;
4472 -> 4470;
4472 -> 4451;
4473 -> 4451;
4474 -> 4451;
4475 -> 3155;
4475 -> 4474;
4476 -> 4474;
4477 -> 4475;
4477 -> 4476;
4478 -> 4476;
4479 -> 4477;
4479 -> 4451;
4479 -> 4478;
4480 -> 4479;
4480 -> 4451;
4480 -> 4478;
4481 -> 4480;
4481 -> 4474;
4482 -> 4474;
4483 -> 4481;
4483 -> 4482;
4484 -> 4483;
4484 -> 4474;
4485 -> 4451;
4486 -> 4451;
4487 -> 3154;
4487 -> 3153;
4488 -> 3156;
4488 -> 3153;
4489 -> 4451;
4489 -> 4487;
4489 -> 4488;
4489 -> 3157;
4489 -> 3153;
4490 -> 1;
4491 -> 1;
4492 -> 4490;
4492 -> 4491;
4493 -> 3151;
4493 -> 4491;
4494 -> 4491;
4495 -> 4494;
4495 -> 4491;
4496 -> 4491;
4497 -> 4496;
4498 -> 4493;
4498 -> 4489;
4498 -> 4497;
4498 -> 4496;
4499 -> 4493;
4499 -> 4489;
4499 -> 4496;
4500 -> 4492;
4500 -> 4491;
4501 -> 4494;
4501 -> 4491;
4502 -> 4499;
4502 -> 4500;
4502 -> 4501;
4502 -> 4489;
4502 -> 4495;
4502 -> 4491;
4503 -> 1;
4504 -> 4502;
4504 -> 4503;
4505 -> 4503;
4506 -> 4504;
4506 -> 4505;
4507 -> 4506;
4507 -> 4502;
4507 -> 4505;
4508 -> 2648;
4508 -> 4505;
4509 -> 4507;
4510 -> 4506;
4510 -> 4509;
4511 -> 4510;
4511 -> 4502;
4511 -> 4509;
4512 -> 4511;
4512 -> 4507;
4513 -> 4507;
4514 -> 4507;
4515 -> 4514;
4515 -> 4507;
4516 -> 4507;
4517 -> 4515;
4517 -> 4516;
4518 -> 4506;
4518 -> 4516;
4519 -> 4516;
4520 -> 4518;
4520 -> 4519;
4521 -> 4519;
4522 -> 4520;
4522 -> 4502;
4522 -> 4521;
4523 -> 4522;
4523 -> 4502;
4523 -> 4168;
4523 -> 4521;
4524 -> 4523;
4524 -> 4189;
4524 -> 4521;
4525 -> 4524;
4525 -> 4519;
4526 -> 4525;
4526 -> 4516;
4527 -> 4516;
4528 -> 4518;
4528 -> 4527;
4529 -> 4527;
4530 -> 4528;
4530 -> 4529;
4531 -> 4529;
4531 -> 4527;
4532 -> 4528;
4532 -> 4527;
4533 -> 4527;
4534 -> 4532;
4534 -> 4533;
4535 -> 4534;
4535 -> 4502;
4535 -> 4533;
4536 -> 4535;
4536 -> 4527;
4537 -> 4527;
4538 -> 4536;
4538 -> 4537;
4538 -> 4527;
4539 -> 4538;
4539 -> 4527;
4540 -> 4539;
4541 -> 4540;
4541 -> 4516;
4542 -> 4516;
4543 -> 4526;
4543 -> 0;
4543 -> 4516;
4544 -> 4543;
4545 -> 4543;
4546 -> 4544;
4546 -> 4545;
4547 -> 4518;
4547 -> 4545;
4548 -> 4546;
4548 -> 4545;
4549 -> 4545;
4550 -> 4548;
4550 -> 4549;
4551 -> 4547;
4551 -> 4549;
4552 -> 4551;
4552 -> 4502;
4552 -> 4549;
4553 -> 4549;
4554 -> 4552;
4555 -> 4551;
4555 -> 4502;
4555 -> 4552;
4556 -> 4550;
4556 -> 4552;
4557 -> 4554;
4557 -> 4552;
4558 -> 4552;
4559 -> 4556;
4559 -> 4558;
4560 -> 4557;
4560 -> 4558;
4561 -> 4551;
4561 -> 4558;
4562 -> 4558;
4563 -> 4561;
4563 -> 4562;
4564 -> 4563;
4564 -> 4558;
4565 -> 4558;
4566 -> 4558;
4567 -> 4559;
4567 -> 4566;
4567 -> 4558;
4568 -> 4559;
4568 -> 4558;
4569 -> 4558;
4570 -> 4561;
4570 -> 4569;
4571 -> 4570;
4571 -> 4569;
4572 -> 4571;
4572 -> 4558;
4573 -> 4568;
4573 -> 4572;
4573 -> 4502;
4573 -> 4558;
4574 -> 4558;
4575 -> 4558;
4576 -> 4558;
4577 -> 4558;
4578 -> 2574;
4579 -> 4578;
4579 -> 2571;
4579 -> 2572;
4579 -> 2573;
4580 -> 4579;
4581 -> 0;
4581 -> 4577;
4582 -> 4577;
4583 -> 4581;
4583 -> 4582;
4583 -> 4577;
4584 -> 4581;
4584 -> 4577;
4585 -> 4584;
4585 -> 4558;
4586 -> 4561;
4586 -> 4573;
4586 -> 4558;
4587 -> 4573;
4587 -> 4586;
4588 -> 4586;
4589 -> 4560;
4589 -> 4586;
4590 -> 4586;
4591 -> 4587;
4591 -> 4590;
4592 -> 4588;
4592 -> 4590;
4593 -> 4589;
4593 -> 4590;
4594 -> 4561;
4594 -> 4590;
4595 -> 4592;
4595 -> 4590;
4596 -> 4590;
4597 -> 4595;
4597 -> 4596;
4598 -> 4597;
4598 -> 4573;
4598 -> 4596;
4599 -> 4598;
4600 -> 4599;
4600 -> 4598;
4601 -> 4590;
4602 -> 4600;
4602 -> 4601;
4602 -> 4590;
4603 -> 4590;
4604 -> 4590;
4605 -> 4590;
4606 -> 4594;
4606 -> 4605;
4607 -> 4605;
4608 -> 4606;
4608 -> 4607;
4609 -> 4607;
4609 -> 4605;
4610 -> 4606;
4610 -> 4605;
4611 -> 4605;
4612 -> 4610;
4612 -> 4611;
4613 -> 4612;
4613 -> 4599;
4613 -> 4611;
4614 -> 4613;
4614 -> 4605;
4615 -> 4605;
4616 -> 4614;
4616 -> 4615;
4616 -> 4605;
4617 -> 4616;
4617 -> 4605;
4618 -> 4617;
4619 -> 4618;
4619 -> 4590;
4620 -> 4600;
4620 -> 4590;
4621 -> 4590;
4622 -> 4620;
4622 -> 4621;
4623 -> 4619;
4623 -> 4621;
4624 -> 4622;
4624 -> 4599;
4624 -> 4621;
4625 -> 4621;
4626 -> 4621;
4627 -> 4624;
4627 -> 4626;
4628 -> 4625;
4628 -> 4626;
4629 -> 4623;
4629 -> 4626;
4630 -> 4628;
4630 -> 4626;
4631 -> 4627;
4631 -> 4626;
4632 -> 4626;
4633 -> 4629;
4633 -> 4599;
4633 -> 4626;
4634 -> 4626;
4635 -> 4631;
4635 -> 4634;
4636 -> 4632;
4636 -> 4634;
4637 -> 4633;
4637 -> 4634;
4638 -> 4629;
4638 -> 4634;
4639 -> 4637;
4639 -> 4634;
4640 -> 4636;
4640 -> 4634;
4641 -> 4638;
4641 -> 4599;
4641 -> 4640;
4642 -> 4638;
4642 -> 4599;
4642 -> 4641;
4642 -> 4634;
4643 -> 4639;
4643 -> 4642;
4643 -> 4599;
4643 -> 4641;
4643 -> 4634;
4644 -> 4635;
4644 -> 4634;
4645 -> 4634;
4646 -> 4644;
4646 -> 4645;
4647 -> 4638;
4647 -> 4645;
4648 -> 4646;
4648 -> 4645;
4649 -> 4645;
4650 -> 4648;
4650 -> 4649;
4651 -> 4647;
4651 -> 4649;
4652 -> 4649;
4653 -> 4650;
4653 -> 4652;
4653 -> 4649;
4654 -> 4651;
4654 -> 4643;
4654 -> 4649;
4655 -> 4650;
4655 -> 4649;
4656 -> 4654;
4656 -> 4655;
4656 -> 4649;
4657 -> 4647;
4657 -> 4656;
4657 -> 4645;
4658 -> 4643;
4658 -> 4634;
4659 -> 4634;
4660 -> 4658;
4660 -> 4659;
4660 -> 4634;
4661 -> 4660;
4662 -> 4661;
4662 -> 4657;
4663 -> 4662;
4663 -> 4660;
4664 -> 4643;
4664 -> 4660;
4665 -> 4663;
4665 -> 4660;
4666 -> 4660;
4667 -> 4634;
4668 -> 4665;
4668 -> 4657;
4668 -> 4634;
4669 -> 4634;
4670 -> 4668;
4670 -> 4669;
4670 -> 4634;
4671 -> 4635;
4671 -> 4634;
4672 -> 4636;
4672 -> 4634;
4673 -> 4665;
4673 -> 4657;
4673 -> 4634;
4674 -> 4634;
4675 -> 4671;
4675 -> 4674;
4676 -> 4672;
4676 -> 4674;
4677 -> 4673;
4677 -> 4674;
4678 -> 4638;
4678 -> 4674;
4679 -> 4678;
4679 -> 4674;
4680 -> 4675;
4680 -> 4674;
4681 -> 4676;
4681 -> 4674;
4682 -> 4674;
4683 -> 4674;
4684 -> 4679;
4684 -> 4683;
4685 -> 4680;
4685 -> 4683;
4686 -> 4681;
4686 -> 4683;
4687 -> 4682;
4687 -> 4683;
4688 -> 4687;
4688 -> 4683;
4689 -> 4687;
4689 -> 4683;
4690 -> 4687;
4690 -> 4683;
4691 -> 4687;
4691 -> 4683;
4692 -> 4687;
4692 -> 4683;
4693 -> 4687;
4693 -> 4683;
4694 -> 4684;
4694 -> 4687;
4694 -> 4683;
4695 -> 4685;
4695 -> 4687;
4695 -> 4683;
4696 -> 4686;
4696 -> 4687;
4696 -> 4683;
4697 -> 4687;
4697 -> 4683;
4698 -> 4683;
4699 -> 4697;
4699 -> 4698;
4699 -> 4688;
4699 -> 4694;
4699 -> 4695;
4699 -> 4691;
4699 -> 4696;
4699 -> 4693;
4699 -> 4665;
4699 -> 4683;
4700 -> 4699;
4700 -> 4687;
4700 -> 4683;
4701 -> 4683;
4702 -> 4701;
4702 -> 4687;
4702 -> 4683;
4703 -> 4684;
4703 -> 4683;
4704 -> 4683;
4705 -> 4683;
4706 -> 4703;
4706 -> 4705;
4707 -> 4704;
4707 -> 4705;
4709 -> 4708;
4711 -> 4710;
4713 -> 4712;
4716 -> 4715;
4717 -> 0;
4718 -> 0;
4719 -> 0;
4720 -> 4719;
4722 -> 4717;
4722 -> 4718;
4722 -> 4720;
4722 -> 4721;
4723 -> 4722;
4725 -> 4724;
4727 -> 4726;
4729 -> 4728;
4731 -> 4730;
4732 -> 4706;
4732 -> 4705;
4733 -> 4705;
4734 -> 4732;
4734 -> 4733;
4735 -> 4707;
4735 -> 4733;
4736 -> 4735;
4736 -> 4733;
4737 -> 4735;
4737 -> 4733;
4738 -> 4735;
4738 -> 4733;
4739 -> 4735;
4739 -> 4733;
4740 -> 4735;
4740 -> 4733;
4741 -> 4733;
4742 -> 4734;
4742 -> 4741;
4742 -> 4733;
4743 -> 4735;
4743 -> 4733;
4744 -> 4743;
4744 -> 4736;
4744 -> 4737;
4744 -> 4738;
4744 -> 4739;
4744 -> 4740;
4744 -> 4733;
4745 -> 4733;
4746 -> 4734;
4746 -> 4745;
4747 -> 4746;
4747 -> 4699;
4747 -> 4745;
4748 -> 4747;
4748 -> 4733;
4749 -> 4748;
4749 -> 4699;
4749 -> 4735;
4749 -> 4733;
4750 -> 4734;
4750 -> 4735;
4750 -> 4733;
4751 -> 4704;
4751 -> 4687;
4751 -> 4683;
4752 -> 4682;
4752 -> 4674;
4753 -> 4752;
4753 -> 4699;
4753 -> 4700;
4753 -> 4702;
4753 -> 4751;
4753 -> 4701;
4753 -> 4744;
4753 -> 4749;
4753 -> 4750;
4753 -> 4674;
4754 -> 4674;
4755 -> 4754;
4756 -> 4677;
4756 -> 4754;
4757 -> 4754;
4758 -> 4756;
4758 -> 4757;
4758 -> 4754;
4759 -> 4677;
4759 -> 4754;
4760 -> 4753;
4760 -> 4754;
4761 -> 4756;
4761 -> 4754;
4762 -> 4759;
4762 -> 4760;
4762 -> 4761;
4762 -> 4753;
4762 -> 4754;
4763 -> 4682;
4763 -> 4762;
4764 -> 4622;
4764 -> 4621;
4765 -> 4621;
4766 -> 4764;
4766 -> 4765;
4767 -> 4625;
4767 -> 4765;
4768 -> 4625;
4768 -> 4765;
4769 -> 4763;
4769 -> 4765;
4770 -> 4766;
4770 -> 4762;
4770 -> 4765;
4771 -> 4765;
4772 -> 4769;
4772 -> 4771;
4773 -> 4772;
4773 -> 4762;
4773 -> 4665;
4773 -> 0;
4773 -> 4771;
4774 -> 4773;
4774 -> 4765;
4775 -> 4765;
4776 -> 4766;
4776 -> 4762;
4776 -> 4775;
4776 -> 4765;
4777 -> 4774;
4777 -> 4776;
4777 -> 4765;
4778 -> 4766;
4778 -> 4762;
4778 -> 4777;
4779 -> 4778;
4779 -> 4765;
4780 -> 4770;
4780 -> 4765;
4781 -> 4767;
4781 -> 4765;
4782 -> 4768;
4782 -> 4765;
4783 -> 4765;
4784 -> 4779;
4784 -> 4783;
4785 -> 4780;
4785 -> 4783;
4786 -> 4781;
4786 -> 4783;
4787 -> 4782;
4787 -> 4783;
4788 -> 4769;
4788 -> 4783;
4789 -> 4783;
4790 -> 4784;
4790 -> 4789;
4790 -> 4783;
4791 -> 4787;
4791 -> 4783;
4792 -> 4788;
4792 -> 4762;
4792 -> 4783;
4793 -> 4788;
4793 -> 4762;
4793 -> 4665;
4793 -> 4783;
4794 -> 4783;
4795 -> 4793;
4795 -> 4794;
4796 -> 4792;
4796 -> 4794;
4797 -> 4794;
4798 -> 4797;
4798 -> 4794;
4799 -> 4797;
4799 -> 4794;
4800 -> 4797;
4800 -> 4794;
4801 -> 4797;
4801 -> 4794;
4802 -> 4795;
4802 -> 4797;
4802 -> 4794;
4803 -> 4793;
4803 -> 4792;
4803 -> 4797;
4803 -> 4798;
4803 -> 4799;
4803 -> 4800;
4803 -> 4801;
4803 -> 4802;
4803 -> 4783;
4804 -> 4785;
4804 -> 4783;
4805 -> 4786;
4805 -> 4783;
4806 -> 4787;
4806 -> 4783;
4807 -> 4783;
4808 -> 4804;
4808 -> 4807;
4809 -> 4805;
4809 -> 4807;
4810 -> 4806;
4810 -> 4807;
4811 -> 4803;
4811 -> 4807;
4812 -> 4807;
4813 -> 4807;
4814 -> 4809;
4814 -> 4813;
4815 -> 4812;
4815 -> 4813;
4816 -> 4815;
4816 -> 4813;
4817 -> 4814;
4817 -> 4816;
4818 -> 4809;
4818 -> 4812;
4818 -> 4807;
4819 -> 4810;
4819 -> 4812;
4819 -> 4807;
4820 -> 4818;
4820 -> 4819;
4820 -> 4807;
4821 -> 4808;
4821 -> 4811;
4821 -> 4807;
4822 -> 4809;
4822 -> 4811;
4822 -> 4807;
4823 -> 4810;
4823 -> 4811;
4823 -> 4807;
4824 -> 4783;
4825 -> 4784;
4825 -> 4783;
4826 -> 4783;
4827 -> 4825;
4827 -> 4826;
4828 -> 4803;
4828 -> 4826;
4829 -> 4827;
4829 -> 4826;
4830 -> 4826;
4831 -> 4829;
4831 -> 4830;
4832 -> 4828;
4832 -> 4830;
4833 -> 4832;
4833 -> 4830;
4834 -> 4833;
4834 -> 4831;
4834 -> 4803;
4834 -> 4821;
4834 -> 4822;
4834 -> 4823;
4834 -> 4830;
4835 -> 4830;
4836 -> 4834;
4836 -> 4835;
4837 -> 4834;
4837 -> 4835;
4838 -> 4836;
4838 -> 4835;
4839 -> 4835;
4840 -> 4838;
4840 -> 4839;
4841 -> 4837;
4841 -> 4839;
4842 -> 4841;
4842 -> 4834;
4842 -> 4839;
4843 -> 4840;
4843 -> 4839;
4844 -> 4842;
4844 -> 4843;
4844 -> 4834;
4844 -> 4839;
4845 -> 0;
4845 -> 4839;
4846 -> 4839;
4847 -> 4840;
4847 -> 4844;
4847 -> 4846;
4847 -> 4839;
4848 -> 4841;
4848 -> 4844;
4848 -> 4839;
4849 -> 4840;
4849 -> 4844;
4849 -> 4839;
4850 -> 4841;
4850 -> 4848;
4850 -> 4847;
4851 -> 4840;
4851 -> 4847;
4852 -> 4841;
4852 -> 4850;
4853 -> 4840;
4853 -> 4850;
4854 -> 0;
4854 -> 4852;
4855 -> 4840;
4855 -> 4839;
4856 -> 4854;
4856 -> 4839;
4857 -> 4839;
4858 -> 4855;
4858 -> 4857;
4859 -> 4856;
4859 -> 4857;
4860 -> 4841;
4860 -> 4857;
4861 -> 4858;
4861 -> 4857;
4862 -> 4859;
4862 -> 4857;
4863 -> 4857;
4864 -> 4861;
4864 -> 4863;
4865 -> 4862;
4865 -> 4863;
4866 -> 4865;
4866 -> 4863;
4867 -> 4863;
4868 -> 4864;
4868 -> 4863;
4869 -> 4865;
4869 -> 4863;
4870 -> 4863;
4871 -> 4863;
4872 -> 4868;
4872 -> 4871;
4873 -> 4869;
4873 -> 4871;
4874 -> 4870;
4874 -> 4871;
4875 -> 4872;
4875 -> 4874;
4875 -> 4871;
4876 -> 4873;
4876 -> 4874;
4876 -> 4871;
4877 -> 4870;
4877 -> 4857;
4878 -> 4857;
4879 -> 4857;
4880 -> 4860;
4880 -> 4879;
4881 -> 4880;
4881 -> 4852;
4881 -> 4879;
4882 -> 4881;
4882 -> 4857;
4883 -> 4877;
4883 -> 4857;
4884 -> 4878;
4884 -> 4857;
4885 -> 4883;
4885 -> 4884;
4885 -> 4882;
4885 -> 4875;
4885 -> 4876;
4885 -> 4852;
4885 -> 4857;
4886 -> 4857;
4887 -> 4885;
4887 -> 4886;
4888 -> 4887;
4888 -> 4885;
4888 -> 4886;
4889 -> 4858;
4889 -> 4888;
4890 -> 4888;
4891 -> 4889;
4891 -> 4890;
4892 -> 4891;
4892 -> 4890;
4893 -> 4891;
4893 -> 4890;
4894 -> 4893;
4894 -> 4891;
4894 -> 4890;
4895 -> 4892;
4895 -> 4890;
4896 -> 4894;
4896 -> 4895;
4896 -> 4891;
4896 -> 4890;
4897 -> 4893;
4897 -> 4896;
4897 -> 4890;
4898 -> 4892;
4898 -> 4896;
4898 -> 4890;
4899 -> 4892;
4899 -> 4890;
4900 -> 4890;
4901 -> 4899;
4901 -> 4900;
4902 -> 4893;
4902 -> 4900;
4903 -> 4901;
4903 -> 4897;
4903 -> 4900;
4904 -> 4900;
4905 -> 4904;
4905 -> 4900;
4906 -> 4901;
4906 -> 4897;
4906 -> 4900;
4907 -> 4902;
4907 -> 4906;
4907 -> 4903;
4907 -> 4897;
4907 -> 4900;
4908 -> 4902;
4908 -> 4906;
4908 -> 4903;
4908 -> 4897;
4908 -> 4907;
4909 -> 4902;
4909 -> 4906;
4909 -> 4908;
4910 -> 4908;
4911 -> 4909;
4911 -> 4900;
4912 -> 4900;
4913 -> 4911;
4913 -> 4912;
4913 -> 4900;
4914 -> 4911;
4914 -> 4901;
4914 -> 4900;
4915 -> 4911;
4915 -> 4913;
4916 -> 0;
4916 -> 4913;
4917 -> 4911;
4917 -> 4915;
4917 -> 4913;
4918 -> 4900;
4919 -> 4918;
4919 -> 4890;
4920 -> 4892;
4920 -> 4890;
4921 -> 4893;
4921 -> 4917;
4921 -> 4890;
4922 -> 4897;
4922 -> 4890;
4923 -> 4919;
4923 -> 4890;
4924 -> 4890;
4925 -> 4920;
4925 -> 4924;
4926 -> 4921;
4926 -> 4924;
4927 -> 4922;
4927 -> 4924;
4928 -> 4923;
4928 -> 4924;
4929 -> 4893;
4929 -> 4924;
4930 -> 4928;
4930 -> 4924;
4931 -> 4924;
4932 -> 4928;
4932 -> 4924;
4933 -> 4927;
4933 -> 4932;
4934 -> 0;
4934 -> 4933;
4935 -> 4925;
4935 -> 4924;
4936 -> 4934;
4936 -> 4924;
4937 -> 4924;
4938 -> 4935;
4938 -> 4937;
4939 -> 4936;
4939 -> 4937;
4940 -> 4939;
4940 -> 4937;
4941 -> 4937;
4942 -> 4937;
4942 -> 4924;
4943 -> 4924;
4944 -> 4924;
4945 -> 4929;
4945 -> 4944;
4946 -> 4945;
4946 -> 4917;
4946 -> 4944;
4947 -> 4946;
4947 -> 4924;
4948 -> 4942;
4948 -> 4924;
4949 -> 4943;
4949 -> 4924;
4950 -> 4948;
4950 -> 4949;
4950 -> 4947;
4950 -> 4938;
4950 -> 4939;
4950 -> 4917;
4950 -> 4924;
4951 -> 4924;
4952 -> 4950;
4953 -> 4925;
4953 -> 4950;
4954 -> 4950;
4955 -> 4929;
4955 -> 4954;
4956 -> 4954;
4957 -> 4955;
4957 -> 4950;
4957 -> 4956;
4958 -> 4957;
4958 -> 4954;
4959 -> 4958;
4959 -> 4950;
4960 -> 4925;
4960 -> 4950;
4960 -> 4959;
4961 -> 4926;
4961 -> 4959;
4962 -> 4959;
4963 -> 4959;
4964 -> 4960;
4964 -> 4963;
4965 -> 4961;
4965 -> 4963;
4966 -> 4962;
4966 -> 4963;
4967 -> 4962;
4967 -> 4963;
4968 -> 4963;
4969 -> 4964;
4969 -> 4968;
4969 -> 4963;
4970 -> 4967;
4970 -> 4963;
4971 -> 4963;
4972 -> 4963;
4973 -> 4966;
4973 -> 4972;
4974 -> 4971;
4974 -> 4972;
4975 -> 4974;
4975 -> 4972;
4976 -> 4973;
4976 -> 4975;
4977 -> 4966;
4977 -> 4971;
4977 -> 4963;
4978 -> 4967;
4978 -> 4971;
4978 -> 4963;
4979 -> 4965;
4979 -> 4963;
4980 -> 4965;
4980 -> 4963;
4981 -> 4979;
4981 -> 4963;
4982 -> 4963;
4983 -> 4981;
4983 -> 4982;
4984 -> 4980;
4984 -> 4982;
4985 -> 4982;
4986 -> 4985;
4986 -> 4982;
4987 -> 4984;
4987 -> 4983;
4987 -> 4965;
4988 -> 4982;
4988 -> 4963;
4989 -> 4963;
4990 -> 4980;
4990 -> 4989;
4991 -> 4990;
4991 -> 4987;
4991 -> 4989;
4992 -> 4963;
4993 -> 4981;
4993 -> 4992;
4994 -> 4988;
4994 -> 4992;
4995 -> 4991;
4995 -> 4992;
4996 -> 4980;
4996 -> 4992;
4997 -> 4992;
4998 -> 4996;
4998 -> 4997;
4999 -> 4998;
4999 -> 4987;
4999 -> 4997;
5000 -> 4999;
5000 -> 4992;
5001 -> 4992;
5002 -> 4993;
5002 -> 5000;
5002 -> 4992;
5003 -> 4994;
5003 -> 4992;
5004 -> 4995;
5004 -> 5003;
5005 -> 0;
5005 -> 5004;
5006 -> 4993;
5006 -> 4992;
5007 -> 5005;
5007 -> 4992;
5008 -> 4992;
5009 -> 5006;
5009 -> 5008;
5010 -> 5007;
5010 -> 5008;
5011 -> 5010;
5011 -> 5008;
5012 -> 5008;
5013 -> 5008;
5013 -> 4992;
5014 -> 4992;
5015 -> 4992;
5016 -> 4996;
5016 -> 5015;
5017 -> 5016;
5017 -> 4987;
5017 -> 5015;
5018 -> 5017;
5018 -> 4992;
5019 -> 5013;
5019 -> 4992;
5020 -> 5014;
5020 -> 4992;
5021 -> 5019;
5021 -> 5020;
5021 -> 5018;
5021 -> 5009;
5021 -> 5010;
5021 -> 4987;
5021 -> 4992;
5022 -> 4992;
5023 -> 5021;
5024 -> 4996;
5024 -> 5023;
5025 -> 5024;
5025 -> 5021;
5025 -> 5023;
5026 -> 5025;
5026 -> 5021;
5027 -> 4995;
5027 -> 5021;
5028 -> 5027;
5029 -> 4996;
5029 -> 5028;
5030 -> 5029;
5030 -> 5021;
5030 -> 5028;
5031 -> 5030;
5031 -> 5027;
5032 -> 5027;
5033 -> 5031;
5033 -> 5032;
5034 -> 5026;
5034 -> 5027;
5035 -> 4993;
5035 -> 5027;
5036 -> 4994;
5036 -> 5027;
5037 -> 5027;
5038 -> 5027;
5039 -> 5033;
5039 -> 5038;
5040 -> 5034;
5040 -> 5038;
5041 -> 5035;
5041 -> 5038;
5042 -> 5036;
5042 -> 5038;
5043 -> 5037;
5043 -> 5038;
5044 -> 5040;
5044 -> 5038;
5045 -> 5038;
5046 -> 5044;
5046 -> 5045;
5047 -> 5043;
5047 -> 5045;
5048 -> 5045;
5049 -> 5045;
5050 -> 5046;
5050 -> 5049;
5050 -> 5045;
5051 -> 5046;
5051 -> 5047;
5051 -> 5045;
5052 -> 5046;
5052 -> 5021;
5052 -> 5047;
5052 -> 5045;
5053 -> 5046;
5053 -> 5021;
5053 -> 5047;
5053 -> 5045;
5054 -> 5048;
5054 -> 5047;
5054 -> 5045;
5055 -> 5043;
5055 -> 5038;
5056 -> 5043;
5056 -> 5038;
5057 -> 5043;
5057 -> 5038;
5058 -> 5043;
5058 -> 5038;
5059 -> 5043;
5059 -> 5038;
5060 -> 5038;
5061 -> 5039;
5061 -> 5060;
5061 -> 5038;
5062 -> 5038;
5063 -> 5041;
5063 -> 5062;
5063 -> 5038;
5064 -> 5039;
5064 -> 5043;
5064 -> 5038;
5065 -> 5041;
5065 -> 5043;
5065 -> 5042;
5065 -> 5038;
5066 -> 5065;
5066 -> 5043;
5066 -> 5038;
5067 -> 5042;
5067 -> 5038;
5068 -> 5041;
5068 -> 5021;
5068 -> 5067;
5069 -> 5041;
5069 -> 5068;
5070 -> 5069;
5070 -> 5068;
5070 -> 5043;
5071 -> 5027;
5072 -> 4996;
5072 -> 5071;
5073 -> 5072;
5073 -> 5068;
5073 -> 5071;
5074 -> 5073;
5074 -> 5027;
5075 -> 4993;
5075 -> 5027;
5076 -> 5027;
5077 -> 5027;
5078 -> 5074;
5078 -> 5077;
5079 -> 5075;
5079 -> 5077;
5080 -> 5076;
5080 -> 5077;
5081 -> 5078;
5081 -> 5077;
5082 -> 5077;
5083 -> 5081;
5083 -> 5082;
5084 -> 5082;
5085 -> 5083;
5085 -> 5084;
5086 -> 5084;
5087 -> 5085;
5087 -> 5086;
5088 -> 5087;
5088 -> 5086;
5089 -> 5087;
5089 -> 5084;
5090 -> 5084;
5091 -> 5089;
5091 -> 5090;
5092 -> 5084;
5093 -> 5091;
5093 -> 5082;
5094 -> 5082;
5095 -> 5093;
5095 -> 5094;
5096 -> 0;
5096 -> 5082;
5097 -> 5082;
5098 -> 5096;
5098 -> 5097;
5099 -> 5095;
5099 -> 5097;
5100 -> 5097;
5101 -> 5100;
5101 -> 5097;
5102 -> 5097;
5103 -> 5099;
5103 -> 5102;
5104 -> 5102;
5105 -> 5103;
5105 -> 5091;
5105 -> 5104;
5105 -> 5102;
5106 -> 5103;
5106 -> 5091;
5106 -> 5105;
5107 -> 5105;
5108 -> 5107;
5108 -> 5105;
5109 -> 5105;
5110 -> 5108;
5110 -> 5109;
5111 -> 0;
5111 -> 5109;
5112 -> 5110;
5112 -> 5109;
5113 -> 5112;
5113 -> 5091;
5114 -> 5112;
5115 -> 5112;
5116 -> 5113;
5116 -> 5112;
5117 -> 5116;
5118 -> 5116;
5118 -> 5117;
5119 -> 5117;
5119 -> 5116;
5120 -> 5119;
5121 -> 5116;
5121 -> 5120;
5122 -> 5120;
5122 -> 5119;
5123 -> 5119;
5124 -> 5114;
5124 -> 5119;
5125 -> 5114;
5125 -> 5112;
5126 -> 5111;
5126 -> 5109;
5127 -> 5126;
5127 -> 5105;
5128 -> 5105;
5129 -> 5103;
5129 -> 5127;
5129 -> 5102;
5130 -> 5129;
5130 -> 5097;
5131 -> 5098;
5131 -> 5097;
5132 -> 5100;
5132 -> 5097;
5133 -> 5130;
5133 -> 5131;
5133 -> 5132;
5133 -> 5127;
5133 -> 5101;
5133 -> 5097;
5134 -> 5133;
5134 -> 5097;
5135 -> 5134;
5135 -> 5077;
5136 -> 5135;
5137 -> 5021;
5138 -> 5137;
5138 -> 5133;
5139 -> 5138;
5139 -> 5021;
5140 -> 5013;
5140 -> 5021;
5141 -> 5037;
5141 -> 5021;
5142 -> 5140;
5142 -> 5141;
5142 -> 5139;
5142 -> 5009;
5142 -> 5010;
5142 -> 5053;
5142 -> 5052;
5142 -> 5051;
5142 -> 5054;
5142 -> 5047;
5142 -> 5064;
5142 -> 5066;
5142 -> 5057;
5142 -> 5058;
5142 -> 5059;
5142 -> 5070;
5142 -> 5133;
5142 -> 5065;
5142 -> 5068;
5142 -> 5021;
5143 -> 5021;
5144 -> 5037;
5144 -> 4992;
5145 -> 4965;
5145 -> 5144;
5145 -> 5142;
5145 -> 4963;
5146 -> 4963;
5147 -> 4963;
5147 -> 5145;
5147 -> 5146;
5148 -> 5145;
5148 -> 4963;
5149 -> 4927;
5149 -> 4950;
5150 -> 4925;
5150 -> 5149;
5151 -> 4925;
5151 -> 5147;
5151 -> 5149;
5152 -> 5148;
5152 -> 5149;
5153 -> 4928;
5153 -> 5149;
5154 -> 5149;
5155 -> 5150;
5155 -> 5154;
5156 -> 5151;
5156 -> 5154;
5157 -> 5152;
5157 -> 5154;
5158 -> 5153;
5158 -> 5154;
5159 -> 4929;
5159 -> 5154;
5160 -> 5154;
5161 -> 5156;
5161 -> 5154;
5162 -> 5154;
5163 -> 5156;
5163 -> 5162;
5163 -> 5154;
5164 -> 5154;
5165 -> 5157;
5165 -> 5154;
5166 -> 5165;
5167 -> 5165;
5167 -> 5166;
5168 -> 5167;
5168 -> 5147;
5168 -> 5166;
5169 -> 5168;
5169 -> 5165;
5170 -> 5156;
5170 -> 5154;
5171 -> 5154;
5172 -> 5170;
5172 -> 5171;
5173 -> 5169;
5173 -> 5171;
5174 -> 5172;
5174 -> 5147;
5174 -> 5171;
5175 -> 5172;
5175 -> 5174;
5176 -> 5174;
5177 -> 5175;
5177 -> 5176;
5178 -> 5175;
5178 -> 5176;
5179 -> 5177;
5179 -> 5176;
5180 -> 5176;
5181 -> 5179;
5181 -> 5180;
5182 -> 5178;
5182 -> 5180;
5183 -> 5182;
5183 -> 5175;
5183 -> 5181;
5183 -> 5180;
5184 -> 5183;
5185 -> 5183;
5185 -> 5184;
5186 -> 5184;
5186 -> 5183;
5187 -> 5183;
5187 -> 5186;
5188 -> 5173;
5188 -> 5187;
5188 -> 5174;
5189 -> 5154;
5190 -> 5188;
5190 -> 5189;
5190 -> 5154;
5191 -> 5188;
5191 -> 5154;
5192 -> 5157;
5192 -> 5154;
5193 -> 5155;
5193 -> 5154;
5194 -> 5158;
5194 -> 5154;
5195 -> 5154;
5196 -> 5154;
5197 -> 5191;
5197 -> 5196;
5198 -> 5192;
5198 -> 5196;
5199 -> 5193;
5199 -> 5196;
5200 -> 5194;
5200 -> 5196;
5201 -> 5195;
5201 -> 5196;
5202 -> 5196;
5203 -> 5201;
5203 -> 5202;
5204 -> 5202;
5205 -> 5202;
5206 -> 5198;
5206 -> 5205;
5206 -> 5202;
5207 -> 5198;
5207 -> 5188;
5207 -> 5203;
5207 -> 5202;
5208 -> 5198;
5208 -> 5188;
5208 -> 5203;
5208 -> 5202;
5209 -> 5204;
5209 -> 5203;
5209 -> 5202;
5210 -> 5201;
5210 -> 5196;
5211 -> 5201;
5211 -> 5196;
5212 -> 5201;
5212 -> 5196;
5213 -> 5201;
5213 -> 5196;
5214 -> 5201;
5214 -> 5196;
5215 -> 5196;
5216 -> 5197;
5216 -> 5215;
5216 -> 5196;
5217 -> 5196;
5218 -> 5199;
5218 -> 5217;
5218 -> 5196;
5219 -> 5199;
5219 -> 5201;
5219 -> 5200;
5219 -> 5196;
5220 -> 5219;
5220 -> 5201;
5220 -> 5196;
5221 -> 5200;
5221 -> 5196;
5222 -> 5199;
5222 -> 5188;
5222 -> 5221;
5223 -> 5199;
5223 -> 5222;
5224 -> 5199;
5224 -> 5223;
5225 -> 5224;
5225 -> 5223;
5225 -> 5201;
5226 -> 5195;
5226 -> 5149;
5227 -> 4950;
5228 -> 5227;
5228 -> 5223;
5229 -> 5228;
5229 -> 4950;
5230 -> 4942;
5230 -> 4950;
5231 -> 5226;
5231 -> 4950;
5232 -> 5230;
5232 -> 5231;
5232 -> 5229;
5232 -> 4938;
5232 -> 4939;
5232 -> 5208;
5232 -> 5207;
5232 -> 5198;
5232 -> 5209;
5232 -> 5203;
5232 -> 5197;
5232 -> 5220;
5232 -> 5212;
5232 -> 5213;
5232 -> 5214;
5232 -> 5225;
5232 -> 5223;
5232 -> 5219;
5232 -> 4950;
5233 -> 4950;
5234 -> 5226;
5234 -> 4924;
5235 -> 4891;
5235 -> 5234;
5235 -> 5232;
5235 -> 4890;
5236 -> 4859;
5236 -> 5005;
5236 -> 4888;
5237 -> 5236;
5238 -> 5235;
5238 -> 5237;
5239 -> 5238;
5239 -> 5235;
5239 -> 5237;
5240 -> 5237;
5241 -> 5239;
5241 -> 5240;
5241 -> 5237;
5242 -> 5241;
5242 -> 5237;
5243 -> 5238;
5243 -> 5235;
5243 -> 5242;
5244 -> 5243;
5244 -> 5236;
5245 -> 4858;
5245 -> 5236;
5246 -> 5236;
5247 -> 5245;
5247 -> 5246;
5248 -> 5244;
5248 -> 5246;
5249 -> 5247;
5249 -> 5235;
5249 -> 5243;
5249 -> 5246;
5250 -> 5247;
5250 -> 5235;
5250 -> 5246;
5251 -> 5247;
5251 -> 5246;
5252 -> 5246;
5253 -> 5249;
5253 -> 5252;
5254 -> 5250;
5254 -> 5252;
5255 -> 5249;
5255 -> 5252;
5256 -> 5251;
5256 -> 5252;
5257 -> 5248;
5257 -> 5252;
5258 -> 5255;
5258 -> 5252;
5259 -> 5252;
5260 -> 5258;
5260 -> 5259;
5261 -> 5253;
5261 -> 5252;
5262 -> 5254;
5262 -> 5252;
5263 -> 5252;
5264 -> 5261;
5264 -> 5263;
5265 -> 5262;
5265 -> 5263;
5266 -> 5257;
5266 -> 5263;
5267 -> 5264;
5267 -> 5263;
5268 -> 5263;
5269 -> 5267;
5269 -> 5268;
5270 -> 5266;
5270 -> 5268;
5271 -> 5268;
5272 -> 5271;
5272 -> 5268;
5273 -> 5268;
5274 -> 5273;
5275 -> 5270;
5275 -> 5249;
5275 -> 5274;
5275 -> 5273;
5276 -> 5275;
5277 -> 5276;
5277 -> 5275;
5278 -> 5277;
5278 -> 5275;
5279 -> 5278;
5279 -> 5249;
5280 -> 5278;
5281 -> 5278;
5282 -> 5279;
5282 -> 5278;
5283 -> 5282;
5284 -> 5282;
5284 -> 5283;
5285 -> 5283;
5285 -> 5282;
5286 -> 5285;
5287 -> 5281;
5287 -> 5285;
5288 -> 5286;
5288 -> 5278;
5289 -> 5281;
5289 -> 5288;
5290 -> 5278;
5290 -> 5249;
5290 -> 5289;
5291 -> 5279;
5291 -> 5249;
5291 -> 5289;
5292 -> 5291;
5293 -> 5291;
5294 -> 5291;
5295 -> 5271;
5295 -> 5268;
5296 -> 5291;
5296 -> 5269;
5296 -> 5295;
5296 -> 5272;
5296 -> 5268;
5297 -> 5296;
5297 -> 5268;
5298 -> 5263;
5299 -> 5265;
5299 -> 5263;
5300 -> 5297;
5300 -> 5298;
5300 -> 5299;
5300 -> 5296;
5300 -> 5263;
5301 -> 5300;
5302 -> 5300;
5303 -> 5301;
5303 -> 5302;
5303 -> 5300;
5304 -> 5300;
5305 -> 5301;
5305 -> 5304;
5306 -> 5305;
5306 -> 5300;
5307 -> 5306;
5307 -> 5260;
5307 -> 5300;
5308 -> 5307;
5309 -> 5256;
5309 -> 5308;
5309 -> 5307;
5310 -> 5309;
5311 -> 5310;
5311 -> 5309;
5312 -> 5311;
5312 -> 5310;
5312 -> 5256;
5313 -> 5311;
5313 -> 5310;
5314 -> 5301;
5314 -> 5312;
5315 -> 4859;
5315 -> 0;
5315 -> 5236;
5316 -> 5314;
5316 -> 5315;
5317 -> 5235;
5317 -> 5315;
5318 -> 5315;
5319 -> 5315;
5320 -> 5316;
5320 -> 5319;
5321 -> 5317;
5321 -> 5319;
5322 -> 5318;
5322 -> 5319;
5323 -> 5321;
5323 -> 5319;
5324 -> 5319;
5325 -> 5323;
5325 -> 5324;
5326 -> 5322;
5326 -> 5324;
5327 -> 5325;
5327 -> 5324;
5328 -> 5324;
5329 -> 5327;
5329 -> 5328;
5330 -> 5326;
5330 -> 5328;
5331 -> 5328;
5332 -> 5328;
5333 -> 5329;
5333 -> 5332;
5333 -> 5328;
5334 -> 5329;
5334 -> 5313;
5334 -> 5330;
5334 -> 5328;
5335 -> 5329;
5335 -> 5313;
5335 -> 5330;
5335 -> 5328;
5336 -> 5331;
5336 -> 5330;
5336 -> 5328;
5337 -> 5322;
5337 -> 5319;
5338 -> 5322;
5338 -> 5319;
5339 -> 5319;
5340 -> 5320;
5340 -> 5339;
5340 -> 5319;
5341 -> 5320;
5341 -> 5322;
5341 -> 5319;
5342 -> 4858;
5342 -> 5313;
5342 -> 4888;
5343 -> 4888;
5344 -> 5342;
5344 -> 5343;
5345 -> 5318;
5345 -> 5343;
5346 -> 5345;
5346 -> 5334;
5346 -> 5343;
5347 -> 0;
5347 -> 5343;
5348 -> 5343;
5349 -> 5346;
5349 -> 5348;
5350 -> 5347;
5350 -> 5348;
5351 -> 5349;
5351 -> 5350;
5351 -> 5348;
5352 -> 5344;
5352 -> 5343;
5353 -> 5351;
5353 -> 5352;
5353 -> 5343;
5354 -> 5353;
5354 -> 5343;
5355 -> 4888;
5356 -> 5355;
5356 -> 5352;
5357 -> 5356;
5357 -> 4888;
5358 -> 4877;
5358 -> 4888;
5359 -> 5354;
5359 -> 4888;
5360 -> 5358;
5360 -> 5359;
5360 -> 5357;
5360 -> 4875;
5360 -> 4876;
5360 -> 5335;
5360 -> 5334;
5360 -> 5329;
5360 -> 5336;
5360 -> 5330;
5360 -> 5341;
5360 -> 5338;
5360 -> 5352;
5360 -> 5300;
5360 -> 4888;
5361 -> 4888;
5362 -> 5354;
5362 -> 4857;
5363 -> 4834;
5363 -> 5362;
5363 -> 5360;
5363 -> 4830;
5364 -> 4803;
5364 -> 4783;
5365 -> 0;
5365 -> 4590;
5366 -> 4594;
5366 -> 4590;
5367 -> 4590;
5368 -> 5365;
5368 -> 5367;
5369 -> 5366;
5369 -> 5367;
5370 -> 5363;
5370 -> 5367;
5371 -> 5367;
5372 -> 5369;
5372 -> 5371;
5372 -> 5367;
5373 -> 5370;
5373 -> 5367;
5374 -> 5370;
5374 -> 5363;
5374 -> 5368;
5374 -> 5367;
5375 -> 5369;
5375 -> 5367;
5376 -> 5367;
5377 -> 5367;
5378 -> 5373;
5378 -> 5377;
5379 -> 5374;
5379 -> 5377;
5380 -> 5375;
5380 -> 5377;
5381 -> 5376;
5381 -> 5377;
5382 -> 5378;
5382 -> 5377;
5383 -> 5379;
5383 -> 5377;
5384 -> 5377;
5385 -> 5382;
5385 -> 5384;
5386 -> 5383;
5386 -> 5384;
5387 -> 5381;
5387 -> 5384;
5388 -> 5387;
5388 -> 5384;
5389 -> 5387;
5389 -> 5384;
5390 -> 5387;
5390 -> 5384;
5391 -> 5387;
5391 -> 5384;
5392 -> 5387;
5392 -> 5384;
5393 -> 5384;
5394 -> 5385;
5394 -> 5393;
5394 -> 5384;
5395 -> 5386;
5395 -> 5384;
5396 -> 0;
5396 -> 5384;
5397 -> 5384;
5398 -> 5395;
5398 -> 5397;
5399 -> 5396;
5399 -> 5397;
5400 -> 5386;
5400 -> 5384;
5401 -> 0;
5401 -> 5384;
5402 -> 5384;
5403 -> 5400;
5403 -> 5402;
5404 -> 5401;
5404 -> 5402;
5405 -> 5385;
5405 -> 5387;
5405 -> 5384;
5406 -> 5386;
5406 -> 5387;
5406 -> 5384;
5407 -> 5385;
5407 -> 5363;
5407 -> 5387;
5407 -> 5384;
5408 -> 5381;
5408 -> 5377;
5409 -> 5377;
5410 -> 5377;
5411 -> 5380;
5411 -> 5410;
5412 -> 5409;
5412 -> 5410;
5413 -> 5412;
5413 -> 5410;
5414 -> 5411;
5414 -> 5413;
5415 -> 5380;
5415 -> 5409;
5415 -> 5377;
5416 -> 5380;
5416 -> 5381;
5416 -> 5377;
5417 -> 5376;
5417 -> 4590;
5418 -> 4590;
5419 -> 4600;
5419 -> 5363;
5419 -> 4590;
5420 -> 5418;
5420 -> 5419;
5421 -> 5419;
5421 -> 5363;
5422 -> 5421;
5422 -> 5363;
5422 -> 5419;
5423 -> 4593;
5423 -> 5422;
5424 -> 0;
5424 -> 5422;
5425 -> 5421;
5425 -> 5422;
5426 -> 5421;
5426 -> 5419;
5427 -> 5426;
5427 -> 5423;
5427 -> 5419;
5428 -> 5419;
5429 -> 5419;
5430 -> 5420;
5430 -> 5429;
5430 -> 5419;
5431 -> 5419;
5432 -> 5431;
5432 -> 5427;
5433 -> 5432;
5433 -> 5419;
5434 -> 5430;
5434 -> 5433;
5434 -> 5419;
5435 -> 5421;
5435 -> 5434;
5436 -> 4593;
5436 -> 5434;
5437 -> 4591;
5437 -> 5434;
5438 -> 5434;
5439 -> 5434;
5440 -> 5435;
5440 -> 5439;
5441 -> 5436;
5441 -> 5439;
5442 -> 5437;
5442 -> 5439;
5443 -> 5438;
5443 -> 5439;
5444 -> 5417;
5444 -> 5439;
5445 -> 5440;
5445 -> 5439;
5446 -> 5441;
5446 -> 5439;
5447 -> 5442;
5447 -> 5439;
5448 -> 5443;
5448 -> 5439;
5449 -> 5439;
5450 -> 5445;
5450 -> 5449;
5451 -> 5446;
5451 -> 5449;
5452 -> 5447;
5452 -> 5449;
5453 -> 5448;
5453 -> 5449;
5454 -> 5444;
5454 -> 5449;
5455 -> 5449;
5456 -> 5451;
5456 -> 5455;
5456 -> 5449;
5457 -> 5450;
5457 -> 5449;
5458 -> 5451;
5458 -> 5449;
5459 -> 5452;
5459 -> 5449;
5460 -> 5449;
5461 -> 5452;
5461 -> 5460;
5461 -> 5449;
5462 -> 5449;
5463 -> 5457;
5463 -> 5462;
5464 -> 5458;
5464 -> 5462;
5465 -> 5459;
5465 -> 5462;
5466 -> 5461;
5466 -> 5462;
5467 -> 5454;
5467 -> 5462;
5468 -> 5463;
5468 -> 5427;
5468 -> 5462;
5469 -> 5463;
5469 -> 5468;
5470 -> 5464;
5470 -> 5468;
5471 -> 5468;
5472 -> 5465;
5472 -> 5468;
5473 -> 5468;
5474 -> 5469;
5474 -> 5473;
5475 -> 5470;
5475 -> 5473;
5476 -> 5471;
5476 -> 5473;
5477 -> 5472;
5477 -> 5473;
5478 -> 5471;
5478 -> 5473;
5479 -> 5467;
5479 -> 5473;
5480 -> 5474;
5480 -> 5468;
5480 -> 5473;
5481 -> 5475;
5481 -> 5473;
5482 -> 5477;
5482 -> 5473;
5483 -> 5473;
5484 -> 5473;
5485 -> 5480;
5485 -> 5484;
5486 -> 5481;
5486 -> 5484;
5487 -> 5482;
5487 -> 5484;
5488 -> 5483;
5488 -> 5484;
5489 -> 5479;
5489 -> 5484;
5490 -> 5488;
5490 -> 5484;
5491 -> 5484;
5492 -> 5486;
5492 -> 5491;
5492 -> 5484;
5493 -> 5487;
5493 -> 5484;
5494 -> 5485;
5495 -> 5486;
5495 -> 5485;
5496 -> 5487;
5496 -> 5485;
5497 -> 5493;
5497 -> 5485;
5498 -> 5485;
5499 -> 5494;
5499 -> 5498;
5500 -> 5495;
5500 -> 5498;
5501 -> 5496;
5501 -> 5498;
5502 -> 5497;
5502 -> 5498;
5503 -> 5494;
5503 -> 5498;
5504 -> 5489;
5504 -> 5498;
5505 -> 5499;
5505 -> 5485;
5505 -> 5498;
5506 -> 5505;
5506 -> 5498;
5507 -> 5499;
5507 -> 5485;
5507 -> 5498;
5508 -> 5503;
5508 -> 5498;
5509 -> 5505;
5509 -> 5498;
5510 -> 5498;
5511 -> 5500;
5511 -> 5498;
5512 -> 5498;
5513 -> 5507;
5513 -> 5512;
5514 -> 5508;
5514 -> 5512;
5515 -> 5509;
5515 -> 5512;
5516 -> 5510;
5516 -> 5512;
5517 -> 5511;
5517 -> 5512;
5518 -> 5504;
5518 -> 5512;
5519 -> 5512;
5520 -> 5514;
5520 -> 5519;
5520 -> 5512;
5521 -> 5512;
5522 -> 5521;
5522 -> 5498;
5523 -> 5498;
5524 -> 5522;
5524 -> 5523;
5524 -> 5498;
5526 -> 5525;
5527 -> 5526;
5527 -> 5525;
5528 -> 5525;
5529 -> 5527;
5529 -> 5525;
5530 -> 5529;
5531 -> 5498;
5532 -> 5530;
5532 -> 5531;
5533 -> 5530;
5533 -> 5527;
5533 -> 5531;
5534 -> 5531;
5535 -> 5533;
5535 -> 5534;
5536 -> 5532;
5536 -> 5534;
5537 -> 5536;
5537 -> 5534;
5538 -> 5536;
5538 -> 5534;
5539 -> 5536;
5539 -> 5534;
5540 -> 5536;
5540 -> 5534;
5541 -> 5535;
5541 -> 5536;
5541 -> 5534;
5542 -> 0;
5542 -> 5536;
5542 -> 5534;
5543 -> 5534;
5544 -> 5543;
5544 -> 5536;
5544 -> 5534;
5545 -> 5534;
5546 -> 5545;
5546 -> 5536;
5546 -> 5534;
5547 -> 5533;
5547 -> 5532;
5547 -> 5542;
5547 -> 5544;
5547 -> 5546;
5547 -> 5541;
5547 -> 5543;
5547 -> 5531;
5548 -> 5531;
5549 -> 5547;
5549 -> 5548;
5550 -> 5549;
5550 -> 5547;
5550 -> 0;
5550 -> 5548;
5551 -> 5548;
5552 -> 5549;
5552 -> 5547;
5552 -> 5551;
5552 -> 5548;
5553 -> 5550;
5553 -> 5531;
5554 -> 5547;
5554 -> 5531;
5555 -> 5554;
5555 -> 5498;
5556 -> 5499;
5556 -> 5498;
5557 -> 5499;
5557 -> 5485;
5557 -> 5498;
5558 -> 5498;
5559 -> 5556;
5559 -> 5558;
5560 -> 5557;
5560 -> 5558;
5561 -> 5559;
5561 -> 5558;
5562 -> 0;
5562 -> 5561;
5563 -> 5498;
5564 -> 5555;
5564 -> 5498;
5565 -> 5503;
5565 -> 5498;
5566 -> 5505;
5566 -> 5498;
5567 -> 5498;
5568 -> 5501;
5568 -> 5498;
5569 -> 5562;
5569 -> 5498;
5570 -> 5563;
5570 -> 5498;
5571 -> 5498;
5572 -> 5564;
5572 -> 5571;
5573 -> 5565;
5573 -> 5571;
5574 -> 5566;
5574 -> 5571;
5575 -> 5567;
5575 -> 5571;
5576 -> 5568;
5576 -> 5571;
5577 -> 5569;
5577 -> 5571;
5578 -> 5567;
5578 -> 5571;
5579 -> 5570;
5579 -> 5571;
5580 -> 5504;
5580 -> 5571;
5581 -> 5577;
5581 -> 5571;
5582 -> 5571;
5583 -> 5581;
5583 -> 5582;
5584 -> 5583;
5584 -> 0;
5584 -> 5582;
5585 -> 5572;
5585 -> 5584;
5586 -> 5573;
5586 -> 5584;
5587 -> 5574;
5587 -> 5584;
5588 -> 5575;
5588 -> 5584;
5589 -> 5576;
5589 -> 5584;
5590 -> 5577;
5590 -> 5584;
5591 -> 5578;
5591 -> 5584;
5592 -> 5579;
5592 -> 5584;
5593 -> 5584;
5594 -> 5585;
5594 -> 5593;
5595 -> 5586;
5595 -> 5593;
5596 -> 5587;
5596 -> 5593;
5597 -> 5588;
5597 -> 5593;
5598 -> 5589;
5598 -> 5593;
5599 -> 5590;
5599 -> 5593;
5600 -> 5591;
5600 -> 5593;
5601 -> 5592;
5601 -> 5593;
5602 -> 5580;
5602 -> 5593;
5603 -> 5593;
5604 -> 5595;
5604 -> 5603;
5604 -> 5593;
5605 -> 5594;
5605 -> 5604;
5606 -> 5596;
5606 -> 5604;
5607 -> 5597;
5607 -> 5604;
5608 -> 5598;
5608 -> 5604;
5609 -> 5599;
5609 -> 5604;
5610 -> 5600;
5610 -> 5604;
5611 -> 5601;
5611 -> 5604;
5612 -> 5604;
5613 -> 5605;
5613 -> 5612;
5614 -> 5606;
5614 -> 5612;
5615 -> 5607;
5615 -> 5612;
5616 -> 5608;
5616 -> 5612;
5617 -> 5609;
5617 -> 5612;
5618 -> 5610;
5618 -> 5612;
5619 -> 5611;
5619 -> 5612;
5620 -> 5602;
5620 -> 5612;
5621 -> 5612;
5622 -> 5613;
5622 -> 5621;
5623 -> 5622;
5623 -> 5547;
5623 -> 0;
5623 -> 5621;
5624 -> 5621;
5625 -> 5622;
5625 -> 5547;
5625 -> 5624;
5625 -> 5621;
5626 -> 5623;
5626 -> 5612;
5627 -> 5617;
5627 -> 5612;
5628 -> 5612;
5629 -> 5627;
5629 -> 5628;
5630 -> 5629;
5630 -> 0;
5630 -> 5628;
5631 -> 5629;
5631 -> 0;
5631 -> 5628;
5632 -> 5628;
5633 -> 0;
5633 -> 5628;
5634 -> 5629;
5634 -> 5633;
5634 -> 5628;
5635 -> 0;
5635 -> 5628;
5636 -> 5629;
5636 -> 5635;
5636 -> 5628;
5637 -> 5628;
5638 -> 0;
5638 -> 5628;
5639 -> 5629;
5639 -> 5638;
5639 -> 5628;
5640 -> 5639;
5640 -> 5628;
5641 -> 5628;
5642 -> 5640;
5642 -> 5641;
5643 -> 5641;
5644 -> 5642;
5644 -> 5643;
5644 -> 5641;
5645 -> 5612;
5646 -> 5620;
5646 -> 5612;
5647 -> 5612;
5648 -> 5612;
5649 -> 5613;
5649 -> 5648;
5650 -> 5648;
5651 -> 5649;
5651 -> 5650;
5652 -> 5651;
5652 -> 5547;
5652 -> 5650;
5653 -> 5652;
5653 -> 5648;
5654 -> 5653;
5654 -> 5612;
5655 -> 5646;
5655 -> 5654;
5655 -> 5612;
5656 -> 5655;
5657 -> 5645;
5657 -> 5656;
5657 -> 5655;
5658 -> 5613;
5658 -> 5657;
5659 -> 5614;
5659 -> 5657;
5660 -> 5615;
5660 -> 5657;
5661 -> 5616;
5661 -> 5657;
5662 -> 5617;
5662 -> 5657;
5663 -> 5620;
5663 -> 5657;
5664 -> 5618;
5664 -> 5657;
5665 -> 5619;
5665 -> 5657;
5666 -> 5657;
5667 -> 5658;
5667 -> 5666;
5668 -> 5659;
5668 -> 5666;
5669 -> 5660;
5669 -> 5666;
5670 -> 5661;
5670 -> 5666;
5671 -> 5662;
5671 -> 5666;
5672 -> 5663;
5672 -> 5666;
5673 -> 5664;
5673 -> 5666;
5674 -> 5665;
5674 -> 5666;
5675 -> 5646;
5675 -> 5666;
5676 -> 5657;
5677 -> 5657;
5678 -> 5613;
5678 -> 5677;
5679 -> 5678;
5679 -> 5547;
5679 -> 0;
5679 -> 5677;
5680 -> 5677;
5681 -> 5678;
5681 -> 5547;
5681 -> 5680;
5681 -> 5677;
5682 -> 5679;
5682 -> 5657;
5683 -> 5617;
5683 -> 0;
5683 -> 5655;
5684 -> 5655;
5685 -> 5646;
5685 -> 5405;
5685 -> 5655;
5686 -> 5685;
5687 -> 5645;
5687 -> 5686;
5687 -> 5685;
5688 -> 5613;
5688 -> 5687;
5689 -> 5614;
5689 -> 5687;
5690 -> 5615;
5690 -> 5687;
5691 -> 5616;
5691 -> 5687;
5692 -> 5617;
5692 -> 5687;
5693 -> 5620;
5693 -> 5687;
5694 -> 5618;
5694 -> 5687;
5695 -> 5674;
5695 -> 5687;
5696 -> 5687;
5697 -> 5688;
5697 -> 5696;
5698 -> 5689;
5698 -> 5696;
5699 -> 5690;
5699 -> 5696;
5700 -> 5691;
5700 -> 5696;
5701 -> 5692;
5701 -> 5696;
5702 -> 5693;
5702 -> 5696;
5703 -> 5694;
5703 -> 5696;
5704 -> 5695;
5704 -> 5696;
5705 -> 5685;
5705 -> 5696;
5706 -> 5696;
5707 -> 5697;
5707 -> 5706;
5708 -> 5707;
5708 -> 5547;
5708 -> 0;
5708 -> 5706;
5709 -> 5706;
5710 -> 5707;
5710 -> 5547;
5710 -> 5709;
5710 -> 5706;
5711 -> 5708;
5711 -> 5696;
5712 -> 5696;
5713 -> 5705;
5713 -> 5712;
5714 -> 0;
5714 -> 5712;
5715 -> 5714;
5715 -> 5696;
5716 -> 5701;
5716 -> 5715;
5716 -> 5696;
5717 -> 5696;
5718 -> 5696;
5719 -> 5705;
5719 -> 5718;
5720 -> 5718;
5721 -> 5719;
5721 -> 5561;
5721 -> 5720;
5721 -> 5718;
5722 -> 5721;
5723 -> 5721;
5724 -> 5719;
5724 -> 5561;
5724 -> 5723;
5725 -> 5724;
5725 -> 5561;
5725 -> 5723;
5726 -> 5725;
5727 -> 5724;
5727 -> 5561;
5727 -> 5725;
5728 -> 5726;
5728 -> 5725;
5729 -> 5726;
5729 -> 5728;
5730 -> 5728;
5731 -> 5729;
5731 -> 5730;
5732 -> 5724;
5732 -> 5730;
5733 -> 5730;
5734 -> 5732;
5734 -> 5733;
5735 -> 5734;
5735 -> 5730;
5736 -> 5731;
5736 -> 5728;
5736 -> 5730;
5737 -> 5728;
5738 -> 5726;
5738 -> 5728;
5738 -> 5725;
5739 -> 5724;
5739 -> 5738;
5739 -> 5723;
5740 -> 5739;
5740 -> 5721;
5741 -> 5719;
5741 -> 5738;
5741 -> 5721;
5742 -> 5722;
5742 -> 5721;
5743 -> 5721;
5744 -> 5741;
5744 -> 5742;
5744 -> 5743;
5744 -> 5722;
5744 -> 5738;
5744 -> 5721;
5745 -> 5719;
5745 -> 5744;
5745 -> 5718;
5746 -> 5745;
5746 -> 5696;
5747 -> 5746;
5747 -> 5698;
5747 -> 5744;
5747 -> 5696;
5748 -> 5687;
5749 -> 5687;
5750 -> 5613;
5750 -> 5749;
5751 -> 5750;
5751 -> 5547;
5751 -> 0;
5751 -> 5749;
5752 -> 5749;
5753 -> 5750;
5753 -> 5547;
5753 -> 5752;
5753 -> 5749;
5754 -> 5751;
5754 -> 5687;
5755 -> 5617;
5755 -> 0;
5755 -> 5685;
5756 -> 5685;
5757 -> 5615;
5757 -> 5747;
5758 -> 5616;
5758 -> 5747;
5759 -> 5617;
5759 -> 5747;
5760 -> 5618;
5760 -> 5747;
5761 -> 5704;
5761 -> 5747;
5762 -> 5747;
5763 -> 5747;
5764 -> 5757;
5764 -> 5747;
5765 -> 5758;
5765 -> 5747;
5766 -> 5759;
5766 -> 5747;
5767 -> 5747;
5768 -> 5760;
5768 -> 5747;
5769 -> 5761;
5769 -> 5747;
5770 -> 5747;
5771 -> 5747;
5772 -> 5762;
5772 -> 5771;
5773 -> 5772;
5773 -> 5547;
5773 -> 0;
5773 -> 5771;
5774 -> 5771;
5775 -> 5772;
5775 -> 5547;
5775 -> 5774;
5775 -> 5771;
5776 -> 5773;
5776 -> 5747;
5777 -> 5747;
5778 -> 5770;
5778 -> 5777;
5779 -> 5777;
5780 -> 5778;
5780 -> 5747;
5780 -> 5779;
5781 -> 5779;
5781 -> 5777;
5782 -> 5781;
5782 -> 5747;
5783 -> 5765;
5783 -> 5747;
5784 -> 5747;
5785 -> 5783;
5785 -> 5784;
5786 -> 5770;
5786 -> 5784;
5787 -> 5784;
5788 -> 5786;
5788 -> 5747;
5788 -> 5787;
5788 -> 5784;
5789 -> 5784;
5790 -> 5786;
5790 -> 5747;
5790 -> 5789;
5790 -> 5784;
5792 -> 0;
5793 -> 0;
5794 -> 0;
5797 -> 5791;
5797 -> 5796;
5798 -> 5792;
5798 -> 5796;
5799 -> 5793;
5799 -> 5796;
5800 -> 5794;
5800 -> 5796;
5801 -> 5795;
5801 -> 5796;
5802 -> 5796;
5803 -> 5802;
5803 -> 5796;
5804 -> 5802;
5804 -> 5796;
5805 -> 5802;
5805 -> 5796;
5806 -> 5796;
5807 -> 5798;
5807 -> 5806;
5807 -> 5796;
5808 -> 5799;
5808 -> 0;
5808 -> 5796;
5809 -> 5800;
5809 -> 0;
5809 -> 5796;
5810 -> 5797;
5810 -> 5802;
5810 -> 5796;
5811 -> 5798;
5811 -> 5802;
5811 -> 5796;
5812 -> 5799;
5812 -> 5802;
5812 -> 5796;
5813 -> 5801;
5813 -> 5802;
5813 -> 5796;
5814 -> 5800;
5814 -> 5802;
5814 -> 5796;
5815 -> 5796;
5816 -> 5786;
5816 -> 5747;
5816 -> 5790;
5817 -> 5785;
5817 -> 5790;
5818 -> 5790;
5819 -> 5817;
5819 -> 5818;
5820 -> 5817;
5820 -> 5818;
5821 -> 5817;
5821 -> 5818;
5822 -> 5817;
5822 -> 5818;
5823 -> 5818;
5824 -> 5823;
5824 -> 5818;
5825 -> 5818;
5826 -> 5825;
5826 -> 5818;
5827 -> 5819;
5827 -> 5817;
5827 -> 5818;
5828 -> 5819;
5828 -> 5827;
5829 -> 5819;
5829 -> 5828;
5830 -> 5822;
5830 -> 5828;
5831 -> 5829;
5831 -> 5828;
5831 -> 5830;
5832 -> 5829;
5832 -> 5828;
5832 -> 5831;
5833 -> 5829;
5833 -> 5828;
5834 -> 5818;
5835 -> 5832;
5835 -> 5828;
5835 -> 5834;
5835 -> 5818;
5836 -> 5833;
5836 -> 5828;
5836 -> 5834;
5836 -> 5818;
5837 -> 5835;
5837 -> 5836;
5837 -> 5818;
5838 -> 5815;
5838 -> 5837;
5839 -> 5817;
5839 -> 5838;
5839 -> 5828;
5839 -> 5831;
5839 -> 5810;
5839 -> 5813;
5839 -> 5811;
5839 -> 5812;
5839 -> 5814;
5839 -> 0;
5839 -> 5790;
5840 -> 5786;
5840 -> 5839;
5840 -> 5784;
5841 -> 5766;
5841 -> 0;
5841 -> 5747;
5842 -> 5747;
5843 -> 5747;
5844 -> 5770;
5844 -> 5839;
5844 -> 5843;
5845 -> 5842;
5845 -> 5843;
5846 -> 5845;
5846 -> 5843;
5847 -> 5844;
5847 -> 5846;
5848 -> 5770;
5848 -> 5839;
5848 -> 5842;
5848 -> 5747;
5849 -> 5841;
5849 -> 5848;
5849 -> 5747;
5850 -> 5762;
5850 -> 5849;
5851 -> 5770;
5851 -> 5839;
5851 -> 5849;
5852 -> 5763;
5852 -> 5849;
5853 -> 5764;
5853 -> 5849;
5854 -> 5765;
5854 -> 5849;
5855 -> 5766;
5855 -> 5849;
5856 -> 5767;
5856 -> 5849;
5857 -> 5768;
5857 -> 5849;
5858 -> 5769;
5858 -> 5849;
5859 -> 5849;
5860 -> 5850;
5860 -> 5859;
5861 -> 5851;
5861 -> 5859;
5862 -> 5852;
5862 -> 5859;
5863 -> 5853;
5863 -> 5859;
5864 -> 5854;
5864 -> 5859;
5865 -> 5855;
5865 -> 5859;
5866 -> 5856;
5866 -> 5859;
5867 -> 5857;
5867 -> 5859;
5868 -> 5858;
5868 -> 5859;
5869 -> 5770;
5869 -> 5859;
5870 -> 5865;
5870 -> 5859;
5871 -> 5859;
5872 -> 5870;
5872 -> 5871;
5873 -> 5872;
5873 -> 0;
5873 -> 5871;
5874 -> 5872;
5874 -> 0;
5874 -> 5871;
5875 -> 5871;
5876 -> 0;
5876 -> 5871;
5877 -> 5872;
5877 -> 5876;
5877 -> 5871;
5878 -> 0;
5878 -> 5871;
5879 -> 5872;
5879 -> 5878;
5879 -> 5871;
5880 -> 5871;
5881 -> 0;
5881 -> 5871;
5882 -> 5872;
5882 -> 5881;
5882 -> 5871;
5883 -> 5882;
5883 -> 5871;
5884 -> 5871;
5885 -> 5883;
5885 -> 5884;
5886 -> 5884;
5887 -> 5885;
5887 -> 5886;
5887 -> 5884;
5888 -> 5859;
5889 -> 5863;
5889 -> 5888;
5889 -> 5859;
5890 -> 5859;
5891 -> 5861;
5891 -> 5890;
5892 -> 5890;
5893 -> 5891;
5893 -> 5892;
5894 -> 5892;
5894 -> 5890;
5895 -> 5894;
5895 -> 5859;
5896 -> 5860;
5896 -> 5895;
5897 -> 5861;
5897 -> 5895;
5898 -> 5862;
5898 -> 5895;
5899 -> 5863;
5899 -> 5895;
5900 -> 5865;
5900 -> 5895;
5901 -> 5866;
5901 -> 5895;
5902 -> 5867;
5902 -> 5895;
5903 -> 5868;
5903 -> 5895;
5904 -> 5895;
5905 -> 5896;
5905 -> 5904;
5906 -> 5897;
5906 -> 5904;
5907 -> 5898;
5907 -> 5904;
5908 -> 5899;
5908 -> 5904;
5909 -> 5900;
5909 -> 5904;
5910 -> 5901;
5910 -> 5904;
5911 -> 5902;
5911 -> 5904;
5912 -> 5903;
5912 -> 5904;
5913 -> 5906;
5913 -> 5904;
5914 -> 5907;
5914 -> 5904;
5915 -> 5909;
5915 -> 5904;
5916 -> 5910;
5916 -> 5904;
5917 -> 5904;
5918 -> 5913;
5918 -> 5917;
5919 -> 5914;
5919 -> 5917;
5920 -> 5915;
5920 -> 5917;
5921 -> 5916;
5921 -> 5917;
5922 -> 5920;
5922 -> 0;
5922 -> 5917;
5923 -> 5917;
5924 -> 5922;
5924 -> 5918;
5924 -> 5917;
5925 -> 5924;
5926 -> 5918;
5926 -> 5925;
5927 -> 5925;
5927 -> 5924;
5928 -> 5920;
5928 -> 0;
5928 -> 5927;
5929 -> 5927;
5930 -> 5919;
5930 -> 5928;
5931 -> 5928;
5932 -> 5930;
5932 -> 5931;
5933 -> 5932;
5933 -> 5904;
5934 -> 5933;
5935 -> 5908;
5935 -> 5933;
5936 -> 5909;
5936 -> 5933;
5937 -> 5911;
5937 -> 5933;
5938 -> 5912;
5938 -> 5933;
5939 -> 5933;
5940 -> 5934;
5940 -> 5939;
5941 -> 5935;
5941 -> 5939;
5942 -> 5936;
5942 -> 5939;
5943 -> 5934;
5943 -> 5939;
5944 -> 5937;
5944 -> 5939;
5945 -> 5938;
5945 -> 5939;
5946 -> 5934;
5946 -> 5939;
5947 -> 5910;
5947 -> 5939;
5948 -> 5939;
5949 -> 5939;
5950 -> 5939;
5951 -> 5940;
5951 -> 5950;
5952 -> 5950;
5952 -> 5939;
5953 -> 5952;
5953 -> 5939;
5954 -> 5940;
5954 -> 5953;
5955 -> 5939;
5956 -> 5947;
5956 -> 5407;
5956 -> 5955;
5957 -> 5956;
5957 -> 5955;
5958 -> 5956;
5958 -> 5939;
5959 -> 5939;
5960 -> 5954;
5960 -> 5959;
5961 -> 5960;
5961 -> 5932;
5961 -> 5956;
5961 -> 5959;
5962 -> 5961;
5962 -> 5939;
5963 -> 5939;
5964 -> 5962;
5964 -> 5963;
5965 -> 5958;
5965 -> 5963;
5966 -> 5964;
5966 -> 5963;
5967 -> 5963;
5968 -> 5963;
5969 -> 5966;
5969 -> 5968;
5970 -> 5967;
5970 -> 5968;
5971 -> 5965;
5971 -> 5968;
5972 -> 5971;
5972 -> 5969;
5972 -> 5968;
5973 -> 5954;
5973 -> 5972;
5974 -> 5941;
5974 -> 5972;
5975 -> 5944;
5975 -> 5972;
5976 -> 5942;
5976 -> 5972;
5977 -> 5949;
5977 -> 5972;
5978 -> 5972;
5979 -> 5973;
5979 -> 5978;
5980 -> 5974;
5980 -> 5978;
5981 -> 5975;
5981 -> 5978;
5982 -> 5976;
5982 -> 5978;
5983 -> 5977;
5983 -> 5978;
5984 -> 5978;
5985 -> 5979;
5985 -> 5984;
5986 -> 5984;
5986 -> 5978;
5987 -> 5986;
5988 -> 5980;
5988 -> 5987;
5988 -> 5986;
5989 -> 5982;
5989 -> 0;
5989 -> 5986;
5990 -> 5988;
5990 -> 5989;
5990 -> 5986;
5991 -> 5979;
5991 -> 5990;
5992 -> 5990;
5993 -> 5991;
5993 -> 5992;
5994 -> 5993;
5994 -> 5992;
5995 -> 5994;
5995 -> 5990;
5996 -> 5991;
5996 -> 5990;
5997 -> 5990;
5998 -> 5991;
5998 -> 5997;
5999 -> 5998;
5999 -> 5990;
6000 -> 5982;
6000 -> 5990;
6001 -> 5990;
6002 -> 6000;
6002 -> 6001;
6003 -> 5999;
6003 -> 6002;
6003 -> 5990;
6004 -> 5978;
6005 -> 5978;
6006 -> 6005;
6006 -> 5972;
6007 -> 6006;
6008 -> 5947;
6008 -> 6007;
6009 -> 6008;
6009 -> 5406;
6009 -> 6007;
6010 -> 0;
6010 -> 6007;
6011 -> 6007;
6012 -> 6009;
6012 -> 6011;
6013 -> 6010;
6013 -> 6011;
6014 -> 6012;
6014 -> 6006;
6015 -> 6006;
6016 -> 5954;
6016 -> 6015;
6017 -> 6015;
6018 -> 6016;
6018 -> 6017;
6019 -> 6017;
6019 -> 6015;
6020 -> 6015;
6021 -> 6020;
6021 -> 6006;
6022 -> 6014;
6022 -> 6021;
6022 -> 6006;
6023 -> 5942;
6023 -> 0;
6023 -> 6022;
6024 -> 6022;
6025 -> 5942;
6025 -> 0;
6025 -> 6023;
6026 -> 6023;
6027 -> 6025;
6028 -> 6027;
6028 -> 6025;
6029 -> 6028;
6030 -> 6029;
6030 -> 6028;
6031 -> 5954;
6031 -> 6028;
6032 -> 5942;
6032 -> 6028;
6033 -> 5943;
6033 -> 6028;
6034 -> 6028;
6035 -> 6032;
6035 -> 6034;
6036 -> 6033;
6036 -> 6034;
6037 -> 6035;
6037 -> 0;
6037 -> 6034;
6038 -> 6034;
6039 -> 6037;
6039 -> 6034;
6040 -> 6036;
6040 -> 6039;
6041 -> 5948;
6041 -> 6028;
6042 -> 5945;
6042 -> 6028;
6043 -> 5946;
6043 -> 6028;
6044 -> 6028;
6045 -> 6031;
6045 -> 6044;
6046 -> 6040;
6046 -> 6044;
6047 -> 6041;
6047 -> 6044;
6048 -> 6042;
6048 -> 6044;
6049 -> 6043;
6049 -> 6044;
6050 -> 5947;
6050 -> 6044;
6051 -> 6050;
6051 -> 5406;
6051 -> 6044;
6052 -> 0;
6052 -> 6044;
6053 -> 6044;
6054 -> 6051;
6054 -> 6053;
6055 -> 6052;
6055 -> 6053;
6056 -> 6045;
6056 -> 6044;
6057 -> 6046;
6057 -> 6044;
6058 -> 6047;
6058 -> 6044;
6059 -> 6048;
6059 -> 6044;
6060 -> 6049;
6060 -> 6044;
6061 -> 6044;
6062 -> 6056;
6062 -> 6061;
6063 -> 6057;
6063 -> 6061;
6064 -> 6058;
6064 -> 6061;
6065 -> 6059;
6065 -> 6061;
6066 -> 6060;
6066 -> 6061;
6067 -> 6050;
6067 -> 6061;
6068 -> 6062;
6068 -> 6061;
6069 -> 6063;
6069 -> 6061;
6070 -> 6064;
6070 -> 6061;
6071 -> 6065;
6071 -> 6061;
6072 -> 6066;
6072 -> 6061;
6073 -> 6061;
6074 -> 6068;
6074 -> 6073;
6075 -> 6069;
6075 -> 6073;
6076 -> 6070;
6076 -> 6073;
6077 -> 6071;
6077 -> 6073;
6078 -> 6072;
6078 -> 6073;
6079 -> 6067;
6079 -> 5405;
6079 -> 6073;
6080 -> 6074;
6080 -> 6073;
6081 -> 6079;
6081 -> 5956;
6081 -> 6073;
6082 -> 6075;
6082 -> 6073;
6083 -> 6076;
6083 -> 6073;
6084 -> 6077;
6084 -> 6073;
6085 -> 6078;
6085 -> 6073;
6086 -> 6073;
6087 -> 6080;
6087 -> 6086;
6088 -> 6081;
6088 -> 6086;
6089 -> 6082;
6089 -> 6086;
6090 -> 6083;
6090 -> 6086;
6091 -> 6084;
6091 -> 6086;
6092 -> 6085;
6092 -> 6086;
6093 -> 6079;
6093 -> 6086;
6094 -> 6093;
6094 -> 5956;
6094 -> 6086;
6095 -> 0;
6095 -> 6086;
6096 -> 6086;
6097 -> 6094;
6097 -> 6096;
6098 -> 6095;
6098 -> 6096;
6099 -> 6087;
6099 -> 6086;
6100 -> 6088;
6100 -> 6086;
6101 -> 6089;
6101 -> 6086;
6102 -> 6090;
6102 -> 6086;
6103 -> 6091;
6103 -> 6086;
6104 -> 6092;
6104 -> 6086;
6105 -> 6086;
6106 -> 6099;
6106 -> 6105;
6107 -> 6100;
6107 -> 6105;
6108 -> 6101;
6108 -> 6105;
6109 -> 6102;
6109 -> 6105;
6110 -> 6103;
6110 -> 6105;
6111 -> 6104;
6111 -> 6105;
6112 -> 6106;
6112 -> 6105;
6113 -> 6107;
6113 -> 6105;
6114 -> 6108;
6114 -> 6105;
6115 -> 6109;
6115 -> 6105;
6116 -> 6105;
6117 -> 6107;
6117 -> 6116;
6118 -> 6116;
6119 -> 6117;
6119 -> 6118;
6120 -> 6118;
6120 -> 6116;
6121 -> 6117;
6121 -> 6105;
6122 -> 6110;
6122 -> 6105;
6123 -> 6111;
6123 -> 6105;
6124 -> 6105;
6125 -> 6112;
6125 -> 6124;
6126 -> 6113;
6126 -> 6124;
6127 -> 6114;
6127 -> 6124;
6128 -> 6115;
6128 -> 6124;
6129 -> 6121;
6129 -> 6124;
6130 -> 6122;
6130 -> 6124;
6131 -> 6123;
6131 -> 6124;
6132 -> 6124;
6133 -> 6125;
6133 -> 6132;
6133 -> 6124;
6134 -> 6124;
6135 -> 6126;
6135 -> 6134;
6135 -> 6124;
6136 -> 6124;
6137 -> 6126;
6137 -> 6136;
6138 -> 6136;
6139 -> 6137;
6139 -> 6138;
6140 -> 6138;
6141 -> 6139;
6141 -> 6140;
6142 -> 6140;
6143 -> 6141;
6143 -> 6142;
6144 -> 6142;
6145 -> 6143;
6145 -> 6144;
6146 -> 6145;
6146 -> 6142;
6147 -> 6146;
6147 -> 6140;
6148 -> 6147;
6148 -> 6138;
6149 -> 6148;
6149 -> 6136;
6150 -> 6149;
6150 -> 6124;
6151 -> 6126;
6151 -> 6124;
6152 -> 6124;
6153 -> 6124;
6154 -> 6125;
6154 -> 6153;
6155 -> 6153;
6155 -> 6124;
6156 -> 6125;
6156 -> 6155;
6157 -> 6126;
6157 -> 6155;
6158 -> 6130;
6158 -> 6155;
6159 -> 6131;
6159 -> 6155;
6160 -> 6155;
6161 -> 6156;
6161 -> 6160;
6162 -> 6157;
6162 -> 6160;
6163 -> 6158;
6163 -> 6160;
6164 -> 6159;
6164 -> 6160;
6165 -> 6162;
6165 -> 6160;
6166 -> 6160;
6167 -> 6161;
6167 -> 6166;
6167 -> 6160;
6168 -> 6160;
6169 -> 6162;
6169 -> 6168;
6170 -> 6168;
6171 -> 6169;
6171 -> 6170;
6172 -> 6170;
6172 -> 6168;
6173 -> 6169;
6173 -> 6160;
6174 -> 6160;
6175 -> 6160;
6176 -> 6161;
6176 -> 6175;
6177 -> 6175;
6178 -> 6176;
6178 -> 6177;
6179 -> 6177;
6180 -> 6178;
6180 -> 6179;
6181 -> 6179;
6182 -> 6180;
6182 -> 6181;
6183 -> 6181;
6184 -> 6182;
6184 -> 6183;
6185 -> 6184;
6185 -> 6181;
6186 -> 6185;
6186 -> 6179;
6187 -> 6186;
6187 -> 6177;
6188 -> 6187;
6188 -> 6175;
6189 -> 6188;
6189 -> 6160;
6190 -> 6160;
6191 -> 6161;
6191 -> 6190;
6192 -> 6191;
6192 -> 5932;
6192 -> 5956;
6192 -> 6190;
6193 -> 6192;
6193 -> 6160;
6194 -> 6160;
6195 -> 6193;
6195 -> 6194;
6195 -> 6160;
6196 -> 6195;
6196 -> 6160;
6197 -> 6196;
6198 -> 6161;
6198 -> 6197;
6199 -> 6197;
6200 -> 6198;
6200 -> 6199;
6201 -> 6200;
6201 -> 6197;
6202 -> 6197;
6203 -> 6201;
6203 -> 6202;
6203 -> 6197;
6204 -> 6203;
6204 -> 6197;
6205 -> 6204;
6206 -> 6201;
6206 -> 6205;
6207 -> 6205;
6208 -> 6206;
6208 -> 5956;
6208 -> 6207;
6209 -> 6208;
6209 -> 5956;
6209 -> 6207;
6210 -> 6196;
6211 -> 6161;
6211 -> 6210;
6212 -> 6211;
6212 -> 5932;
6212 -> 5956;
6212 -> 6210;
6213 -> 6210;
6214 -> 6212;
6214 -> 6213;
6215 -> 6214;
6215 -> 0;
6215 -> 6213;
6216 -> 0;
6216 -> 6215;
6217 -> 6162;
6217 -> 6196;
6218 -> 6196;
6219 -> 6209;
6219 -> 6218;
6220 -> 6216;
6220 -> 6218;
6221 -> 6217;
6221 -> 6218;
6222 -> 6221;
6222 -> 6218;
6223 -> 6218;
6224 -> 6219;
6224 -> 6223;
6224 -> 6218;
6225 -> 6220;
6225 -> 6218;
6226 -> 6221;
6226 -> 6225;
6227 -> 6225;
6228 -> 6226;
6228 -> 6227;
6228 -> 6225;
6229 -> 6228;
6229 -> 6225;
6230 -> 6229;
6231 -> 6226;
6231 -> 6230;
6232 -> 6230;
6233 -> 6231;
6233 -> 6232;
6234 -> 6233;
6234 -> 6230;
6235 -> 6230;
6236 -> 6234;
6236 -> 6235;
6236 -> 6230;
6237 -> 6236;
6237 -> 6230;
6238 -> 6237;
6239 -> 6234;
6239 -> 6238;
6240 -> 6238;
6241 -> 6239;
6241 -> 5956;
6241 -> 6240;
6242 -> 6241;
6242 -> 5956;
6242 -> 6240;
6243 -> 6242;
6243 -> 6219;
6243 -> 6225;
6244 -> 6030;
6244 -> 6243;
6244 -> 6028;
6245 -> 6244;
6246 -> 6245;
6246 -> 6244;
6247 -> 5954;
6247 -> 6244;
6248 -> 6244;
6249 -> 6247;
6249 -> 6248;
6250 -> 6248;
6251 -> 6249;
6251 -> 6250;
6252 -> 6250;
6252 -> 6248;
6253 -> 6252;
6254 -> 6253;
6254 -> 6244;
6255 -> 6246;
6255 -> 6254;
6255 -> 6244;
6256 -> 5942;
6256 -> 0;
6256 -> 6255;
6257 -> 6255;
6258 -> 5942;
6258 -> 0;
6258 -> 6256;
6259 -> 6256;
6260 -> 5942;
6260 -> 0;
6260 -> 6258;
6261 -> 6258;
6262 -> 5942;
6262 -> 0;
6262 -> 6260;
6263 -> 6260;
6264 -> 5954;
6264 -> 6262;
6265 -> 6262;
6266 -> 6264;
6266 -> 6265;
6267 -> 0;
6267 -> 6265;
6268 -> 6266;
6268 -> 6265;
6269 -> 6265;
6270 -> 6265;
6271 -> 6267;
6271 -> 6270;
6272 -> 6268;
6272 -> 6270;
6273 -> 6269;
6273 -> 6270;
6274 -> 6269;
6274 -> 6270;
6275 -> 6271;
6275 -> 6274;
6275 -> 6270;
6276 -> 6272;
6276 -> 6274;
6276 -> 6270;
6277 -> 6273;
6277 -> 6274;
6277 -> 6270;
6278 -> 6269;
6278 -> 6262;
6279 -> 6278;
6279 -> 5933;
6280 -> 5933;
6281 -> 6279;
6281 -> 6280;
6282 -> 5905;
6282 -> 6280;
6283 -> 6280;
6284 -> 6282;
6284 -> 6283;
6285 -> 6284;
6285 -> 6280;
6286 -> 6285;
6286 -> 6281;
6286 -> 6275;
6286 -> 6280;
6287 -> 6286;
6288 -> 6287;
6288 -> 6286;
6289 -> 6281;
6289 -> 6288;
6290 -> 6288;
6291 -> 6289;
6291 -> 6290;
6292 -> 6282;
6292 -> 6290;
6293 -> 6291;
6293 -> 6275;
6293 -> 6292;
6293 -> 6290;
6294 -> 6292;
6294 -> 5547;
6294 -> 6293;
6294 -> 6290;
6295 -> 6291;
6295 -> 6276;
6295 -> 6290;
6296 -> 6292;
6296 -> 6294;
6296 -> 6295;
6296 -> 5932;
6296 -> 5956;
6296 -> 6290;
6297 -> 6291;
6297 -> 6277;
6297 -> 6292;
6297 -> 6290;
6298 -> 6288;
6299 -> 5933;
6300 -> 5933;
6300 -> 6296;
6300 -> 6297;
6300 -> 5904;
6301 -> 5895;
6302 -> 5849;
6303 -> 5849;
6304 -> 5762;
6304 -> 6303;
6305 -> 6304;
6305 -> 6296;
6305 -> 6303;
6306 -> 6305;
6306 -> 5849;
6307 -> 6306;
6308 -> 5764;
6308 -> 6307;
6308 -> 6306;
6309 -> 5763;
6309 -> 6306;
6310 -> 6306;
6311 -> 5767;
6311 -> 6310;
6312 -> 6311;
6312 -> 5406;
6312 -> 6310;
6313 -> 0;
6313 -> 6310;
6314 -> 6310;
6315 -> 6312;
6315 -> 6314;
6316 -> 6313;
6316 -> 6314;
6317 -> 6315;
6317 -> 6306;
6318 -> 6306;
6319 -> 6309;
6319 -> 6318;
6320 -> 6317;
6320 -> 6318;
6321 -> 5840;
6321 -> 6318;
6322 -> 6318;
6323 -> 6322;
6323 -> 6318;
6324 -> 6319;
6324 -> 6318;
6325 -> 6322;
6325 -> 6318;
6326 -> 6321;
6326 -> 6296;
6326 -> 6324;
6326 -> 6325;
6326 -> 6297;
6326 -> 6323;
6326 -> 6318;
6327 -> 6318;
6328 -> 6327;
6328 -> 6306;
6329 -> 6308;
6329 -> 6328;
6329 -> 6306;
6330 -> 6306;
6331 -> 5747;
6332 -> 5613;
6332 -> 6331;
6333 -> 6332;
6333 -> 6326;
6333 -> 0;
6333 -> 6331;
6334 -> 6333;
6334 -> 5747;
6335 -> 5747;
6335 -> 6334;
6336 -> 5617;
6336 -> 0;
6336 -> 5747;
6337 -> 5747;
6338 -> 6335;
6338 -> 5612;
6339 -> 5584;
6340 -> 5500;
6340 -> 5498;
6341 -> 5499;
6341 -> 5498;
6342 -> 6163;
6342 -> 5498;
6343 -> 6340;
6343 -> 6341;
6343 -> 6342;
6343 -> 6326;
6343 -> 5498;
6344 -> 5498;
6345 -> 5498;
6346 -> 5503;
6346 -> 6345;
6346 -> 5498;
6347 -> 5555;
6347 -> 5498;
6348 -> 5498;
6349 -> 6347;
6349 -> 6348;
6350 -> 6348;
6351 -> 6349;
6351 -> 6350;
6352 -> 6350;
6353 -> 6351;
6353 -> 6352;
6354 -> 6353;
6354 -> 6343;
6354 -> 6352;
6355 -> 6354;
6355 -> 6348;
6356 -> 6348;
6357 -> 6349;
6357 -> 6356;
6358 -> 6357;
6358 -> 6343;
6358 -> 6356;
6359 -> 6358;
6359 -> 6348;
6360 -> 6359;
6361 -> 6359;
6361 -> 6360;
6362 -> 6360;
6362 -> 6359;
6363 -> 6362;
6364 -> 6344;
6364 -> 5498;
6365 -> 6364;
6366 -> 5555;
6366 -> 6364;
6367 -> 5505;
6367 -> 6364;
6368 -> 6364;
6369 -> 5499;
6369 -> 6364;
6370 -> 5500;
6370 -> 6364;
6371 -> 5502;
6371 -> 6364;
6372 -> 6365;
6372 -> 6364;
6373 -> 5503;
6373 -> 6364;
6374 -> 5562;
6374 -> 6364;
6375 -> 6364;
6376 -> 6366;
6376 -> 6375;
6377 -> 6367;
6377 -> 6375;
6378 -> 6368;
6378 -> 6375;
6379 -> 6369;
6379 -> 6375;
6380 -> 6370;
6380 -> 6375;
6381 -> 6371;
6381 -> 6375;
6382 -> 6372;
6382 -> 6375;
6383 -> 6373;
6383 -> 6375;
6384 -> 6374;
6384 -> 6375;
6385 -> 5504;
6385 -> 6375;
6386 -> 6376;
6386 -> 6375;
6387 -> 6377;
6387 -> 6375;
6388 -> 6378;
6388 -> 6375;
6389 -> 6379;
6389 -> 6375;
6390 -> 6380;
6390 -> 6375;
6391 -> 6381;
6391 -> 6375;
6392 -> 6382;
6392 -> 6375;
6393 -> 6383;
6393 -> 6375;
6394 -> 6384;
6394 -> 6375;
6395 -> 6375;
6396 -> 6386;
6396 -> 6395;
6397 -> 6387;
6397 -> 6395;
6398 -> 6388;
6398 -> 6395;
6399 -> 6389;
6399 -> 6395;
6400 -> 6390;
6400 -> 6395;
6401 -> 6391;
6401 -> 6395;
6402 -> 6392;
6402 -> 6395;
6403 -> 6393;
6403 -> 6395;
6404 -> 6394;
6404 -> 6395;
6405 -> 6385;
6405 -> 6395;
6406 -> 6395;
6407 -> 6399;
6407 -> 6406;
6407 -> 6395;
6408 -> 6395;
6409 -> 6400;
6409 -> 6408;
6409 -> 6395;
6410 -> 6395;
6411 -> 6396;
6411 -> 6410;
6412 -> 6411;
6412 -> 6343;
6412 -> 6410;
6413 -> 6412;
6413 -> 6395;
6414 -> 6395;
6415 -> 6395;
6416 -> 6396;
6416 -> 6415;
6417 -> 6415;
6418 -> 6416;
6418 -> 6417;
6419 -> 6418;
6419 -> 6343;
6419 -> 6417;
6420 -> 6419;
6420 -> 6395;
6421 -> 6420;
6422 -> 6413;
6422 -> 6343;
6422 -> 6421;
6422 -> 6420;
6423 -> 6422;
6424 -> 6423;
6424 -> 6422;
6425 -> 6422;
6426 -> 6424;
6426 -> 6425;
6426 -> 6422;
6427 -> 6422;
6428 -> 6424;
6428 -> 6427;
6429 -> 6427;
6430 -> 6428;
6430 -> 6429;
6431 -> 6430;
6431 -> 6427;
6432 -> 6431;
6433 -> 6428;
6433 -> 6432;
6434 -> 6432;
6435 -> 6433;
6435 -> 6423;
6435 -> 6434;
6436 -> 6435;
6436 -> 6423;
6436 -> 4152;
6436 -> 6434;
6437 -> 6436;
6437 -> 4179;
6437 -> 6434;
6438 -> 6437;
6438 -> 6432;
6439 -> 6438;
6439 -> 6431;
6440 -> 6439;
6440 -> 6422;
6441 -> 6440;
6442 -> 6423;
6442 -> 6441;
6443 -> 6441;
6443 -> 6440;
6444 -> 6440;
6445 -> 6405;
6445 -> 5407;
6445 -> 6444;
6446 -> 6445;
6446 -> 6444;
6447 -> 6445;
6447 -> 6440;
6448 -> 6440;
6449 -> 6447;
6449 -> 6448;
6450 -> 6448;
6451 -> 6449;
6451 -> 6450;
6452 -> 6451;
6452 -> 6445;
6452 -> 6450;
6453 -> 6452;
6454 -> 6451;
6454 -> 6453;
6455 -> 6453;
6456 -> 6454;
6456 -> 6445;
6456 -> 6455;
6456 -> 6453;
6457 -> 6452;
6458 -> 6452;
6459 -> 6452;
6460 -> 6459;
6461 -> 6459;
6461 -> 6460;
6462 -> 6460;
6463 -> 6461;
6463 -> 6445;
6463 -> 6462;
6463 -> 6460;
6464 -> 6459;
6465 -> 6459;
6465 -> 6452;
6466 -> 6465;
6467 -> 6465;
6467 -> 6466;
6468 -> 6467;
6468 -> 6445;
6468 -> 6466;
6469 -> 6468;
6469 -> 6465;
6470 -> 6451;
6470 -> 6445;
6470 -> 6452;
6471 -> 6458;
6471 -> 6452;
6472 -> 6452;
6473 -> 6451;
6473 -> 6471;
6473 -> 6450;
6474 -> 6451;
6474 -> 6471;
6474 -> 6450;
6475 -> 6474;
6475 -> 6448;
6476 -> 6448;
6477 -> 6443;
6477 -> 6475;
6477 -> 6440;
6478 -> 6401;
6478 -> 6440;
6479 -> 6478;
6480 -> 6423;
6480 -> 6479;
6481 -> 6479;
6481 -> 6478;
6482 -> 6423;
6482 -> 6422;
6483 -> 6375;
6484 -> 6482;
6484 -> 6483;
6485 -> 6483;
6485 -> 6375;
6486 -> 6379;
6486 -> 6485;
6487 -> 6485;
6488 -> 6482;
6488 -> 6485;
6489 -> 6380;
6489 -> 6485;
6490 -> 6485;
6491 -> 6486;
6491 -> 6490;
6492 -> 6487;
6492 -> 6490;
6493 -> 6488;
6493 -> 6490;
6494 -> 6489;
6494 -> 6490;
6495 -> 6385;
6495 -> 6490;
6496 -> 6490;
6497 -> 6493;
6497 -> 6496;
6498 -> 6497;
6498 -> 6471;
6498 -> 6496;
6499 -> 6498;
6499 -> 6490;
6500 -> 6490;
6501 -> 6482;
6501 -> 6375;
6502 -> 6364;
6503 -> 6501;
6503 -> 6502;
6504 -> 6502;
6504 -> 6364;
6505 -> 5498;
6506 -> 5555;
6506 -> 6505;
6507 -> 6505;
6508 -> 6506;
6508 -> 6507;
6509 -> 0;
6509 -> 6508;
6509 -> 6507;
6510 -> 6508;
6510 -> 6471;
6510 -> 6509;
6510 -> 6507;
6511 -> 6507;
6512 -> 6511;
6512 -> 6508;
6512 -> 6507;
6513 -> 6505;
6514 -> 6505;
6515 -> 6506;
6515 -> 6510;
6515 -> 6514;
6515 -> 6505;
6516 -> 6506;
6516 -> 6515;
6517 -> 6506;
6517 -> 6510;
6517 -> 6516;
6517 -> 6512;
6517 -> 6515;
6518 -> 5498;
6519 -> 5499;
6519 -> 6517;
6519 -> 5498;
6520 -> 5498;
6521 -> 6519;
6521 -> 6520;
6522 -> 5504;
6522 -> 6520;
6523 -> 6521;
6523 -> 6517;
6523 -> 6520;
6524 -> 6521;
6524 -> 6517;
6524 -> 6520;
6525 -> 6520;
6526 -> 6524;
6526 -> 6525;
6527 -> 6524;
6527 -> 6525;
6528 -> 6522;
6528 -> 6525;
6529 -> 6526;
6529 -> 6525;
6530 -> 6527;
6530 -> 6525;
6531 -> 6529;
6531 -> 6530;
6531 -> 6523;
6531 -> 6525;
6532 -> 6531;
6532 -> 6525;
6533 -> 6532;
6534 -> 6528;
6534 -> 5407;
6534 -> 6533;
6535 -> 6534;
6535 -> 6532;
6536 -> 0;
6536 -> 6532;
6537 -> 6532;
6538 -> 6528;
6538 -> 6537;
6539 -> 6538;
6539 -> 5405;
6539 -> 6537;
6540 -> 6539;
6540 -> 6535;
6540 -> 6537;
6541 -> 6537;
6542 -> 6538;
6542 -> 5405;
6542 -> 6541;
6543 -> 6542;
6543 -> 6540;
6543 -> 6541;
6544 -> 6543;
6544 -> 6541;
6545 -> 6541;
6546 -> 6544;
6546 -> 6545;
6547 -> 6545;
6548 -> 6546;
6548 -> 6543;
6548 -> 6547;
6549 -> 6548;
6549 -> 6545;
6550 -> 6549;
6551 -> 6550;
6551 -> 6541;
6552 -> 6551;
6552 -> 6541;
6553 -> 6501;
6553 -> 5498;
6554 -> 5498;
6555 -> 6552;
6555 -> 6554;
6556 -> 6553;
6556 -> 6554;
6557 -> 6556;
6557 -> 6554;
6558 -> 6556;
6558 -> 6554;
6559 -> 6558;
6559 -> 6554;
6560 -> 6559;
6560 -> 6554;
6561 -> 0;
6562 -> 0;
6563 -> 0;
6564 -> 6563;
6566 -> 6561;
6566 -> 6562;
6566 -> 6564;
6566 -> 6565;
6567 -> 6566;
6568 -> 0;
6569 -> 0;
6570 -> 0;
6571 -> 6570;
6571 -> 0;
6572 -> 6571;
6574 -> 6568;
6574 -> 6569;
6574 -> 6572;
6574 -> 6573;
6575 -> 6574;
6576 -> 6555;
6576 -> 6560;
6577 -> 6560;
6578 -> 6576;
6578 -> 6577;
6579 -> 6560;
6579 -> 6577;
6580 -> 6560;
6580 -> 6577;
6581 -> 6579;
6581 -> 6577;
6582 -> 6579;
6582 -> 6577;
6583 -> 6580;
6583 -> 6577;
6584 -> 6578;
6584 -> 6583;
6585 -> 0;
6585 -> 6584;
6586 -> 6577;
6587 -> 6577;
6588 -> 6582;
6588 -> 6587;
6589 -> 6585;
6589 -> 6587;
6590 -> 6586;
6590 -> 6587;
6591 -> 6588;
6591 -> 6587;
6592 -> 6589;
6592 -> 0;
6592 -> 6587;
6593 -> 6589;
6593 -> 6587;
6594 -> 6588;
6594 -> 6593;
6599 -> 6595;
6599 -> 6598;
6600 -> 6596;
6600 -> 6598;
6601 -> 6597;
6601 -> 6598;
6602 -> 6598;
6603 -> 0;
6604 -> 6603;
6605 -> 0;
6606 -> 6605;
6607 -> 0;
6608 -> 6607;
6609 -> 0;
6610 -> 6609;
6611 -> 6593;
6612 -> 6594;
6612 -> 6611;
6613 -> 6611;
6614 -> 6612;
6614 -> 6613;
6615 -> 6613;
6616 -> 6614;
6616 -> 6615;
6617 -> 6615;
6618 -> 6616;
6618 -> 6617;
6619 -> 6618;
6619 -> 6615;
6620 -> 6619;
6620 -> 6613;
6621 -> 6620;
6621 -> 6611;
6622 -> 6611;
6623 -> 6621;
6623 -> 6622;
6624 -> 6588;
6624 -> 6587;
6625 -> 6589;
6625 -> 6587;
6626 -> 6590;
6626 -> 6587;
6627 -> 6587;
6628 -> 6624;
6628 -> 6627;
6629 -> 6625;
6629 -> 6627;
6630 -> 6626;
6630 -> 6627;
6631 -> 0;
6633 -> 6631;
6633 -> 6632;
6634 -> 6632;
6635 -> 6634;
6636 -> 6633;
6636 -> 0;
6636 -> 6632;
6637 -> 6633;
6637 -> 6634;
6637 -> 6632;
6638 -> 6632;
6639 -> 6628;
6639 -> 6627;
6640 -> 6629;
6640 -> 6627;
6641 -> 6630;
6641 -> 6627;
6642 -> 6627;
6643 -> 6641;
6643 -> 6642;
6644 -> 6643;
6644 -> 6626;
6644 -> 6642;
6645 -> 6638;
6645 -> 6644;
6646 -> 6627;
6647 -> 6627;
6648 -> 6639;
6648 -> 6647;
6649 -> 6640;
6649 -> 6647;
6650 -> 6645;
6650 -> 6647;
6651 -> 6646;
6651 -> 6647;
6652 -> 6648;
6652 -> 6647;
6653 -> 6652;
6653 -> 6647;
6654 -> 6648;
6654 -> 6653;
6655 -> 6653;
6656 -> 6654;
6656 -> 6655;
6657 -> 6655;
6658 -> 6656;
6658 -> 6657;
6659 -> 6657;
6660 -> 6658;
6660 -> 6659;
6661 -> 6659;
6662 -> 6660;
6662 -> 6661;
6663 -> 6662;
6663 -> 6659;
6664 -> 6663;
6664 -> 6657;
6665 -> 6664;
6665 -> 6655;
6666 -> 6655;
6667 -> 6665;
6667 -> 6666;
6668 -> 6666;
6669 -> 6667;
6669 -> 6543;
6669 -> 6668;
6670 -> 6649;
6670 -> 0;
6670 -> 6647;
6671 -> 6647;
6672 -> 6669;
6672 -> 6671;
6672 -> 6647;
6673 -> 6647;
6674 -> 6650;
6674 -> 6673;
6674 -> 6647;
6675 -> 6648;
6675 -> 6651;
6675 -> 6647;
6676 -> 6649;
6676 -> 6651;
6676 -> 6647;
6677 -> 6650;
6677 -> 6651;
6677 -> 6647;
6678 -> 6646;
6678 -> 6587;
6679 -> 6678;
6679 -> 6577;
6680 -> 6560;
6681 -> 6679;
6681 -> 6680;
6682 -> 6560;
6682 -> 6680;
6683 -> 6680;
6684 -> 6681;
6684 -> 6683;
6685 -> 6684;
6685 -> 6675;
6685 -> 6683;
6686 -> 6685;
6686 -> 6683;
6687 -> 6686;
6687 -> 6680;
6688 -> 6681;
6688 -> 6682;
6688 -> 6680;
6689 -> 6680;
6690 -> 6689;
6690 -> 6682;
6690 -> 6680;
6691 -> 6680;
6692 -> 6691;
6692 -> 6682;
6692 -> 6680;
6693 -> 5484;
6694 -> 6560;
6694 -> 6693;
6695 -> 6693;
6696 -> 6694;
6696 -> 6688;
6696 -> 6695;
6697 -> 6696;
6697 -> 6675;
6697 -> 6695;
6698 -> 6697;
6698 -> 6695;
6699 -> 6698;
6699 -> 6695;
6700 -> 6699;
6700 -> 6693;
6701 -> 6700;
6701 -> 5484;
6702 -> 6701;
6703 -> 6702;
6703 -> 6701;
6704 -> 6703;
6705 -> 6560;
6705 -> 6704;
6706 -> 6705;
6706 -> 6688;
6706 -> 6704;
6707 -> 6706;
6707 -> 6703;
6708 -> 5489;
6708 -> 6703;
6709 -> 5485;
6709 -> 6703;
6710 -> 5486;
6710 -> 6703;
6711 -> 6703;
6712 -> 6708;
6712 -> 6711;
6713 -> 6709;
6713 -> 6711;
6714 -> 6710;
6714 -> 6711;
6715 -> 6707;
6715 -> 6711;
6716 -> 6715;
6716 -> 6711;
6717 -> 6712;
6717 -> 6711;
6718 -> 6713;
6718 -> 6711;
6719 -> 6714;
6719 -> 6711;
6720 -> 6711;
6721 -> 6716;
6721 -> 6720;
6722 -> 6717;
6722 -> 6720;
6723 -> 6718;
6723 -> 6720;
6724 -> 6719;
6724 -> 6720;
6725 -> 6715;
6725 -> 6677;
6725 -> 6720;
6726 -> 6722;
6726 -> 6720;
6727 -> 6723;
6727 -> 6720;
6728 -> 6724;
6728 -> 6720;
6729 -> 6720;
6730 -> 6726;
6730 -> 6729;
6731 -> 6727;
6731 -> 6729;
6732 -> 6728;
6732 -> 6729;
6733 -> 6721;
6733 -> 6729;
6734 -> 6732;
6734 -> 6729;
6735 -> 6729;
6736 -> 6733;
6736 -> 6735;
6737 -> 6736;
6737 -> 6675;
6737 -> 6735;
6738 -> 6735;
6739 -> 6737;
6739 -> 6738;
6740 -> 6736;
6740 -> 6677;
6740 -> 6738;
6741 -> 6739;
6741 -> 6738;
6742 -> 6741;
6742 -> 6735;
6743 -> 6742;
6743 -> 6729;
6744 -> 6731;
6744 -> 6729;
6745 -> 6729;
6746 -> 6729;
6747 -> 6734;
6747 -> 6746;
6748 -> 6743;
6748 -> 6746;
6749 -> 6744;
6749 -> 6746;
6750 -> 6745;
6750 -> 6746;
6751 -> 6730;
6751 -> 6746;
6752 -> 6747;
6752 -> 6746;
6753 -> 6748;
6753 -> 6746;
6754 -> 6749;
6754 -> 6746;
6755 -> 6750;
6755 -> 6746;
6756 -> 6746;
6757 -> 6752;
6757 -> 6756;
6758 -> 6753;
6758 -> 6756;
6759 -> 6754;
6759 -> 6756;
6760 -> 6755;
6760 -> 6756;
6761 -> 6751;
6761 -> 6756;
6762 -> 6756;
6763 -> 6758;
6763 -> 6762;
6764 -> 6762;
6764 -> 6756;
6765 -> 6757;
6765 -> 6764;
6766 -> 6758;
6766 -> 6764;
6767 -> 6759;
6767 -> 6764;
6768 -> 6760;
6768 -> 6764;
6769 -> 6764;
6770 -> 6761;
6770 -> 6769;
6771 -> 6770;
6771 -> 5416;
6771 -> 6769;
6772 -> 6771;
6772 -> 6764;
6773 -> 6764;
6774 -> 6761;
6774 -> 6773;
6775 -> 6773;
6776 -> 6774;
6776 -> 6775;
6777 -> 6776;
6777 -> 5416;
6777 -> 6775;
6778 -> 6777;
6778 -> 6773;
6779 -> 6778;
6779 -> 6773;
6780 -> 6773;
6781 -> 6778;
6781 -> 6780;
6782 -> 6780;
6782 -> 6773;
6783 -> 6779;
6783 -> 6782;
6783 -> 6773;
6784 -> 6778;
6784 -> 6773;
6785 -> 6778;
6785 -> 6773;
6786 -> 6785;
6786 -> 6764;
6787 -> 6761;
6787 -> 5406;
6787 -> 6764;
6788 -> 6764;
6789 -> 6765;
6789 -> 6788;
6790 -> 6766;
6790 -> 6788;
6791 -> 6767;
6791 -> 6788;
6792 -> 6768;
6792 -> 6788;
6793 -> 6772;
6793 -> 6788;
6794 -> 6786;
6794 -> 6788;
6795 -> 6787;
6795 -> 6788;
6796 -> 6790;
6796 -> 6788;
6797 -> 6796;
6797 -> 6543;
6797 -> 6788;
6798 -> 6788;
6799 -> 6790;
6799 -> 6798;
6800 -> 6798;
6800 -> 6788;
6801 -> 6788;
6802 -> 6790;
6802 -> 6801;
6803 -> 6801;
6803 -> 6788;
6804 -> 6790;
6804 -> 6788;
6805 -> 6794;
6805 -> 6788;
6806 -> 6788;
6807 -> 6804;
6807 -> 6806;
6808 -> 6805;
6808 -> 6806;
6809 -> 6806;
6810 -> 6807;
6810 -> 6809;
6811 -> 6809;
6811 -> 6806;
6812 -> 6807;
6812 -> 6811;
6813 -> 6792;
6813 -> 6788;
6814 -> 6813;
6814 -> 6788;
6815 -> 6789;
6815 -> 6788;
6816 -> 6812;
6816 -> 6788;
6817 -> 6791;
6817 -> 6788;
6818 -> 6793;
6818 -> 6788;
6819 -> 6795;
6819 -> 6788;
6820 -> 6788;
6821 -> 6815;
6821 -> 6820;
6822 -> 6816;
6822 -> 6820;
6823 -> 6817;
6823 -> 6820;
6824 -> 6818;
6824 -> 6820;
6825 -> 6819;
6825 -> 6820;
6826 -> 6820;
6827 -> 6821;
6827 -> 6826;
6827 -> 6820;
6828 -> 6822;
6828 -> 6820;
6829 -> 6824;
6829 -> 6820;
6830 -> 6820;
6831 -> 6820;
6832 -> 6828;
6832 -> 6831;
6833 -> 6829;
6833 -> 6831;
6834 -> 6830;
6834 -> 6831;
6835 -> 6831;
6836 -> 6832;
6836 -> 6835;
6837 -> 6835;
6838 -> 6836;
6838 -> 6837;
6839 -> 6838;
6839 -> 6797;
6839 -> 6837;
6840 -> 6837;
6841 -> 6839;
6841 -> 6840;
6841 -> 6837;
6842 -> 6838;
6842 -> 6797;
6842 -> 6837;
6843 -> 6842;
6843 -> 6797;
6844 -> 6837;
6845 -> 6844;
6845 -> 6835;
6846 -> 6835;
6847 -> 6845;
6847 -> 6846;
6847 -> 6835;
6848 -> 6847;
6848 -> 6835;
6849 -> 6848;
6849 -> 6831;
6850 -> 0;
6850 -> 6849;
6851 -> 6850;
6851 -> 6820;
6852 -> 6820;
6853 -> 6851;
6853 -> 6820;
6854 -> 6820;
6855 -> 6852;
6855 -> 6854;
6855 -> 6820;
6856 -> 6851;
6856 -> 6820;
6857 -> 6856;
6857 -> 6788;
6858 -> 6857;
6858 -> 6788;
6859 -> 6813;
6859 -> 6858;
6860 -> 6764;
6861 -> 6746;
6862 -> 6720;
6863 -> 6703;
6864 -> 6560;
6864 -> 6701;
6865 -> 6864;
6865 -> 5484;
6866 -> 5486;
6866 -> 5484;
6867 -> 5485;
6867 -> 5484;
6868 -> 5487;
6868 -> 5484;
6869 -> 5484;
6870 -> 6865;
6870 -> 6869;
6871 -> 6866;
6871 -> 6869;
6872 -> 6867;
6872 -> 6869;
6873 -> 6868;
6873 -> 6869;
6874 -> 5489;
6874 -> 6869;
6875 -> 6869;
6876 -> 6870;
6876 -> 6875;
6877 -> 6876;
6877 -> 6690;
6877 -> 6875;
6878 -> 6877;
6878 -> 0;
6878 -> 6875;
6879 -> 6878;
6879 -> 6869;
6880 -> 6870;
6880 -> 6869;
6881 -> 5484;
6882 -> 6880;
6882 -> 6881;
6883 -> 6882;
6883 -> 6688;
6883 -> 6881;
6884 -> 5473;
6885 -> 6883;
6885 -> 6884;
6886 -> 6885;
6886 -> 6675;
6886 -> 6884;
6887 -> 6884;
6888 -> 6886;
6888 -> 6887;
6889 -> 6885;
6889 -> 6677;
6889 -> 6887;
6890 -> 6887;
6891 -> 6888;
6891 -> 6890;
6892 -> 0;
6892 -> 6890;
6893 -> 6890;
6894 -> 6892;
6894 -> 6893;
6895 -> 6891;
6895 -> 6893;
6896 -> 6895;
6896 -> 6797;
6896 -> 6894;
6896 -> 6893;
6897 -> 6893;
6898 -> 6896;
6898 -> 6897;
6898 -> 6893;
6899 -> 6898;
6899 -> 5473;
6900 -> 5478;
6900 -> 5473;
6901 -> 6900;
6902 -> 5479;
6902 -> 6901;
6903 -> 6902;
6903 -> 5406;
6903 -> 6901;
6904 -> 0;
6904 -> 6901;
6905 -> 6901;
6906 -> 6903;
6906 -> 6905;
6907 -> 6904;
6907 -> 6905;
6908 -> 6906;
6908 -> 6900;
6909 -> 5475;
6909 -> 6908;
6910 -> 6883;
6910 -> 6908;
6911 -> 6910;
6911 -> 6675;
6911 -> 6676;
6911 -> 6677;
6911 -> 6797;
6911 -> 6637;
6911 -> 0;
6911 -> 6908;
6912 -> 5473;
6913 -> 5474;
6913 -> 6911;
6913 -> 6912;
6913 -> 5473;
6914 -> 5474;
6914 -> 6911;
6914 -> 6913;
6915 -> 6914;
6915 -> 6913;
6916 -> 6913;
6917 -> 6915;
6917 -> 6914;
6917 -> 6916;
6917 -> 6913;
6918 -> 5476;
6918 -> 6917;
6918 -> 6913;
6919 -> 6913;
6920 -> 6919;
6920 -> 6917;
6921 -> 6919;
6921 -> 6917;
6922 -> 6921;
6922 -> 6919;
6923 -> 6919;
6923 -> 6917;
6924 -> 6923;
6924 -> 6913;
6925 -> 6883;
6925 -> 6913;
6926 -> 6914;
6926 -> 6923;
6926 -> 6913;
6927 -> 6913;
6928 -> 6924;
6928 -> 6927;
6929 -> 6925;
6929 -> 6927;
6930 -> 6926;
6930 -> 6927;
6931 -> 6927;
6932 -> 6930;
6932 -> 6931;
6932 -> 6927;
6933 -> 6928;
6933 -> 6932;
6934 -> 6929;
6934 -> 6932;
6935 -> 6932;
6936 -> 6933;
6936 -> 6935;
6937 -> 6934;
6937 -> 6935;
6938 -> 6937;
6938 -> 6935;
6939 -> 0;
6939 -> 6935;
6940 -> 6935;
6941 -> 6939;
6941 -> 6940;
6942 -> 6936;
6942 -> 6940;
6943 -> 6940;
6944 -> 6942;
6944 -> 6943;
6945 -> 6944;
6945 -> 6940;
6946 -> 6941;
6946 -> 6940;
6947 -> 6940;
6948 -> 6946;
6948 -> 6947;
6949 -> 6945;
6949 -> 6947;
6950 -> 6947;
6951 -> 6949;
6951 -> 6950;
6952 -> 6951;
6952 -> 6947;
6953 -> 6952;
6954 -> 6952;
6954 -> 6953;
6955 -> 6953;
6956 -> 6954;
6956 -> 6955;
6957 -> 6955;
6958 -> 6956;
6958 -> 6923;
6958 -> 6957;
6958 -> 6955;
6959 -> 6953;
6960 -> 6954;
6960 -> 6923;
6960 -> 6953;
6961 -> 6960;
6961 -> 6952;
6962 -> 6952;
6963 -> 6947;
6964 -> 6949;
6964 -> 6923;
6964 -> 6963;
6964 -> 6947;
6965 -> 6948;
6965 -> 6964;
6966 -> 6964;
6967 -> 6964;
6968 -> 6967;
6968 -> 6964;
6969 -> 6964;
6970 -> 6965;
6970 -> 6964;
6971 -> 6964;
6972 -> 6970;
6972 -> 6971;
6973 -> 6968;
6973 -> 6971;
6974 -> 6971;
6975 -> 6971;
6976 -> 6973;
6976 -> 6975;
6977 -> 6976;
6977 -> 6971;
6978 -> 6972;
6978 -> 6965;
6978 -> 6971;
6979 -> 6971;
6980 -> 6978;
6980 -> 6979;
6981 -> 6977;
6981 -> 6979;
6982 -> 6981;
6982 -> 6979;
6983 -> 6980;
6983 -> 6979;
6984 -> 6983;
6985 -> 6983;
6986 -> 6983;
6987 -> 6985;
6987 -> 6986;
6988 -> 6982;
6988 -> 6986;
6989 -> 6986;
6990 -> 6988;
6990 -> 6968;
6990 -> 6987;
6990 -> 6986;
6991 -> 6987;
6991 -> 6990;
6992 -> 6986;
6992 -> 6990;
6993 -> 6990;
6993 -> 6991;
6994 -> 6993;
6995 -> 6993;
6996 -> 6994;
6996 -> 6995;
6996 -> 6993;
6997 -> 6996;
6998 -> 6984;
6998 -> 6997;
6998 -> 6996;
6999 -> 6994;
6999 -> 6996;
7000 -> 6999;
7000 -> 6983;
7001 -> 6983;
7002 -> 7000;
7002 -> 7001;
7002 -> 6983;
7003 -> 7000;
7003 -> 6979;
7004 -> 6971;
7005 -> 7003;
7005 -> 7004;
7005 -> 6971;
7006 -> 6972;
7006 -> 7005;
7007 -> 7005;
7008 -> 7006;
7008 -> 7007;
7009 -> 7003;
7009 -> 7007;
7010 -> 7008;
7010 -> 6965;
7010 -> 7007;
7011 -> 7009;
7011 -> 7007;
7012 -> 7007;
7013 -> 7011;
7013 -> 7012;
7014 -> 7012;
7014 -> 7007;
7015 -> 7007;
7016 -> 7007;
7017 -> 7016;
7017 -> 7007;
7018 -> 7007;
7019 -> 7011;
7019 -> 7018;
7020 -> 7019;
7020 -> 7018;
7021 -> 7018;
7021 -> 7007;
7022 -> 0;
7022 -> 7007;
7023 -> 7007;
7024 -> 7022;
7024 -> 7023;
7025 -> 7011;
7025 -> 7023;
7026 -> 7023;
7027 -> 7025;
7027 -> 7026;
7028 -> 7027;
7028 -> 6993;
7028 -> 6991;
7028 -> 7026;
7029 -> 7027;
7029 -> 6993;
7029 -> 6991;
7029 -> 7028;
7030 -> 7028;
7031 -> 7027;
7031 -> 7030;
7032 -> 7031;
7032 -> 7030;
7033 -> 7030;
7034 -> 7030;
7035 -> 7032;
7035 -> 7034;
7036 -> 7033;
7036 -> 7034;
7037 -> 7034;
7038 -> 7036;
7038 -> 7037;
7039 -> 7037;
7040 -> 7038;
7040 -> 7039;
7041 -> 7036;
7041 -> 7034;
7042 -> 7035;
7042 -> 7034;
7043 -> 7035;
7043 -> 7036;
7043 -> 7034;
7044 -> 7033;
7044 -> 7028;
7045 -> 7028;
7046 -> 7029;
7046 -> 7044;
7046 -> 7045;
7046 -> 7043;
7046 -> 6991;
7046 -> 6993;
7046 -> 7028;
7047 -> 7027;
7047 -> 7046;
7047 -> 7026;
7048 -> 7047;
7048 -> 7023;
7049 -> 7024;
7049 -> 7023;
7050 -> 7023;
7051 -> 7048;
7051 -> 7050;
7052 -> 7049;
7052 -> 7050;
7053 -> 7051;
7053 -> 7050;
7054 -> 7052;
7054 -> 7050;
7055 -> 7050;
7056 -> 7053;
7056 -> 7055;
7057 -> 7054;
7057 -> 7055;
7058 -> 7057;
7058 -> 7055;
7059 -> 7056;
7059 -> 7055;
7060 -> 7055;
7061 -> 7058;
7061 -> 7055;
7062 -> 7055;
7063 -> 7059;
7063 -> 7062;
7064 -> 7060;
7064 -> 7062;
7065 -> 7060;
7065 -> 7062;
7066 -> 7061;
7066 -> 7062;
7067 -> 7060;
7067 -> 7062;
7068 -> 7062;
7069 -> 7063;
7069 -> 7068;
7069 -> 7062;
7070 -> 7067;
7070 -> 7062;
7071 -> 7070;
7072 -> 7064;
7072 -> 7071;
7072 -> 7070;
7073 -> 7070;
7074 -> 7065;
7074 -> 7073;
7074 -> 7070;
7075 -> 7063;
7075 -> 7062;
7076 -> 7062;
7078 -> 7077;
7080 -> 7079;
7081 -> 7076;
7081 -> 7062;
7082 -> 7066;
7082 -> 7062;
7083 -> 7064;
7083 -> 7062;
7084 -> 7065;
7084 -> 7062;
7085 -> 7062;
7086 -> 7062;
7087 -> 7081;
7087 -> 7086;
7088 -> 7082;
7088 -> 7086;
7089 -> 7083;
7089 -> 7086;
7090 -> 7084;
7090 -> 7086;
7091 -> 7085;
7091 -> 7086;
7092 -> 7087;
7092 -> 7086;
7093 -> 7088;
7093 -> 7086;
7094 -> 7086;
7095 -> 7089;
7095 -> 7086;
7096 -> 7090;
7096 -> 7086;
7097 -> 7086;
7098 -> 7097;
7098 -> 7092;
7098 -> 7093;
7098 -> 7094;
7098 -> 7095;
7098 -> 7096;
7098 -> 7076;
7098 -> 0;
7098 -> 7086;
7099 -> 7097;
7099 -> 7086;
7100 -> 7097;
7100 -> 7086;
7101 -> 7088;
7101 -> 7098;
7101 -> 7086;
7102 -> 0;
7102 -> 7086;
7103 -> 7101;
7103 -> 7097;
7103 -> 7086;
7104 -> 7085;
7104 -> 7062;
7105 -> 7062;
7106 -> 7104;
7106 -> 7105;
7107 -> 7063;
7107 -> 7105;
7108 -> 7106;
7108 -> 7105;
7109 -> 7105;
7110 -> 7108;
7110 -> 7109;
7111 -> 7107;
7111 -> 7109;
7112 -> 7111;
7112 -> 7109;
7113 -> 7109;
7114 -> 7112;
7114 -> 7113;
7115 -> 7110;
7115 -> 7113;
7116 -> 7115;
7116 -> 7098;
7116 -> 7113;
7117 -> 7115;
7117 -> 7098;
7117 -> 7099;
7117 -> 7103;
7117 -> 7100;
7117 -> 7113;
7118 -> 0;
7118 -> 7113;
7119 -> 7115;
7119 -> 7098;
7119 -> 7099;
7119 -> 7103;
7119 -> 7100;
7119 -> 0;
7119 -> 7113;
7120 -> 7119;
7121 -> 7114;
7121 -> 7120;
7122 -> 7120;
7123 -> 7121;
7123 -> 7122;
7124 -> 7123;
7124 -> 7046;
7124 -> 7122;
7125 -> 7120;
7126 -> 7124;
7126 -> 7125;
7127 -> 7125;
7128 -> 7126;
7128 -> 7127;
7129 -> 7128;
7129 -> 7046;
7129 -> 7127;
7130 -> 7129;
7130 -> 7125;
7131 -> 7125;
7132 -> 7130;
7133 -> 7130;
7134 -> 7132;
7134 -> 7133;
7134 -> 7130;
7135 -> 7132;
7135 -> 7134;
7136 -> 7120;
7137 -> 7135;
7137 -> 7136;
7138 -> 7137;
7138 -> 7136;
7139 -> 7136;
7140 -> 7138;
7140 -> 7139;
7141 -> 7139;
7142 -> 7140;
7142 -> 7141;
7143 -> 7142;
7144 -> 7143;
7145 -> 7142;
7146 -> 7142;
7147 -> 7142;
7147 -> 7139;
7148 -> 7147;
7148 -> 7119;
7149 -> 7148;
7149 -> 7119;
7150 -> 7119;
7151 -> 7149;
7151 -> 7150;
7152 -> 7115;
7152 -> 7150;
7153 -> 7151;
7153 -> 7150;
7154 -> 7150;
7155 -> 7153;
7155 -> 7154;
7155 -> 7150;
7156 -> 7152;
7156 -> 7098;
7156 -> 7099;
7156 -> 7103;
7156 -> 7100;
7156 -> 0;
7156 -> 7150;
7157 -> 7150;
7158 -> 7153;
7158 -> 7157;
7159 -> 7157;
7160 -> 7158;
7160 -> 7142;
7160 -> 7159;
7161 -> 7159;
7161 -> 7150;
7162 -> 7152;
7162 -> 7098;
7162 -> 7099;
7162 -> 7103;
7162 -> 7100;
7162 -> 0;
7162 -> 7150;
7163 -> 7161;
7163 -> 7162;
7163 -> 7150;
7164 -> 7163;
7164 -> 7119;
7165 -> 7113;
7166 -> 7114;
7166 -> 7165;
7167 -> 7165;
7168 -> 7166;
7168 -> 7142;
7168 -> 7167;
7169 -> 7167;
7170 -> 7169;
7170 -> 7113;
7171 -> 0;
7171 -> 7170;
7172 -> 7114;
7172 -> 7170;
7173 -> 7170;
7174 -> 7114;
7174 -> 7173;
7175 -> 7173;
7176 -> 7174;
7176 -> 7175;
7177 -> 7176;
7177 -> 7142;
7177 -> 7175;
7178 -> 7173;
7179 -> 7177;
7179 -> 7178;
7180 -> 7179;
7180 -> 7170;
7181 -> 7170;
7182 -> 7171;
7182 -> 7181;
7183 -> 7172;
7183 -> 7181;
7184 -> 7180;
7184 -> 7181;
7185 -> 7115;
7185 -> 7181;
7186 -> 7181;
7187 -> 7184;
7187 -> 7186;
7187 -> 7181;
7188 -> 7187;
7188 -> 7181;
7189 -> 7185;
7189 -> 7098;
7189 -> 7099;
7189 -> 7103;
7189 -> 7188;
7190 -> 7189;
7190 -> 7188;
7191 -> 7182;
7191 -> 7181;
7192 -> 7183;
7192 -> 7181;
7193 -> 7190;
7193 -> 7181;
7194 -> 7191;
7194 -> 7192;
7194 -> 7193;
7194 -> 7142;
7194 -> 7181;
7195 -> 7109;
7196 -> 7105;
7197 -> 7062;
7198 -> 7076;
7198 -> 7194;
7198 -> 7062;
7199 -> 7198;
7199 -> 7008;
7199 -> 6965;
7199 -> 7007;
7200 -> 7021;
7200 -> 7199;
7200 -> 7007;
7201 -> 7008;
7201 -> 6965;
7201 -> 7007;
7202 -> 7008;
7202 -> 6965;
7202 -> 7201;
7203 -> 7201;
7204 -> 7008;
7204 -> 6965;
7204 -> 7007;
7205 -> 7008;
7205 -> 6965;
7205 -> 7007;
7206 -> 7205;
7207 -> 7206;
7208 -> 7204;
7208 -> 7207;
7208 -> 7206;
7209 -> 7208;
7210 -> 7008;
7210 -> 6965;
7210 -> 7007;
7211 -> 7007;
7212 -> 7210;
7212 -> 7211;
7213 -> 7011;
7213 -> 7211;
7214 -> 7211;
7215 -> 7213;
7215 -> 7214;
7216 -> 7215;
7216 -> 7198;
7216 -> 7214;
7217 -> 7214;
7218 -> 7215;
7218 -> 7198;
7218 -> 7217;
7218 -> 7214;
7219 -> 7218;
7220 -> 7216;
7220 -> 7219;
7220 -> 7218;
7221 -> 7216;
7221 -> 7218;
7222 -> 7218;
7223 -> 7221;
7223 -> 7222;
7224 -> 7222;
7225 -> 7223;
7225 -> 7224;
7225 -> 7222;
7226 -> 7222;
7227 -> 7222;
7228 -> 7222;
7228 -> 7227;
7229 -> 7227;
7230 -> 7228;
7230 -> 7229;
7231 -> 7230;
7231 -> 7227;
7232 -> 7227;
7233 -> 7228;
7233 -> 7232;
7234 -> 7233;
7234 -> 7227;
7235 -> 7227;
7236 -> 7234;
7236 -> 7235;
7237 -> 7235;
7237 -> 7227;
7238 -> 7227;
7239 -> 7231;
7239 -> 7227;
7240 -> 7222;
7240 -> 7239;
7240 -> 7223;
7240 -> 7198;
7241 -> 7240;
7242 -> 7240;
7243 -> 7240;
7244 -> 7240;
7245 -> 7240;
7246 -> 7240;
7247 -> 7222;
7247 -> 7240;
7248 -> 7240;
7249 -> 7247;
7249 -> 7240;
7249 -> 7248;
7250 -> 7249;
7250 -> 7240;
7251 -> 7240;
7252 -> 7250;
7253 -> 7250;
7254 -> 7250;
7255 -> 7250;
7256 -> 7250;
7257 -> 7250;
7258 -> 7250;
7259 -> 7258;
7259 -> 7250;
7260 -> 7259;
7260 -> 7250;
7261 -> 7250;
7262 -> 7250;
7263 -> 7250;
7264 -> 7250;
7265 -> 7250;
7266 -> 7250;
7267 -> 7250;
7268 -> 7250;
7269 -> 7250;
7270 -> 7250;
7271 -> 7250;
7272 -> 0;
7272 -> 7250;
7273 -> 0;
7273 -> 7250;
7274 -> 7250;
7274 -> 7273;
7275 -> 7274;
7275 -> 7250;
7275 -> 7273;
7276 -> 7270;
7276 -> 7250;
7277 -> 7250;
7278 -> 7256;
7278 -> 7277;
7278 -> 7250;
7279 -> 7275;
7280 -> 7275;
7281 -> 7275;
7282 -> 7275;
7283 -> 7275;
7284 -> 7275;
7285 -> 7275;
7286 -> 7285;
7286 -> 7275;
7287 -> 7286;
7287 -> 7275;
7288 -> 7275;
7289 -> 7275;
7290 -> 7275;
7291 -> 7275;
7292 -> 7275;
7293 -> 7275;
7294 -> 7275;
7295 -> 7275;
7296 -> 7275;
7297 -> 7275;
7298 -> 7275;
7299 -> 0;
7299 -> 7275;
7300 -> 7297;
7300 -> 7275;
7301 -> 7275;
7302 -> 7283;
7302 -> 7301;
7302 -> 7275;
7303 -> 4365;
7303 -> 7275;
7304 -> 7303;
7305 -> 7303;
7306 -> 7303;
7307 -> 7303;
7308 -> 7303;
7309 -> 7303;
7310 -> 7303;
7311 -> 7310;
7311 -> 7303;
7312 -> 7311;
7312 -> 7303;
7313 -> 7303;
7314 -> 7303;
7315 -> 7303;
7316 -> 7303;
7317 -> 7303;
7318 -> 7303;
7319 -> 7303;
7320 -> 7303;
7321 -> 7303;
7322 -> 7303;
7323 -> 7303;
7324 -> 0;
7324 -> 7303;
7325 -> 7322;
7325 -> 7303;
7326 -> 7303;
7327 -> 7308;
7327 -> 7326;
7327 -> 7303;
7328 -> 7303;
7329 -> 7328;
7329 -> 7303;
7330 -> 7329;
7330 -> 7303;
7331 -> 7303;
7332 -> 7303;
7333 -> 7303;
7334 -> 7303;
7335 -> 7240;
7336 -> 7251;
7336 -> 7335;
7336 -> 7240;
7337 -> 7303;
7338 -> 7303;
7339 -> 7303;
7340 -> 7303;
7341 -> 7303;
7341 -> 7340;
7342 -> 7341;
7342 -> 7303;
7342 -> 7340;
7343 -> 7342;
7343 -> 7303;
7344 -> 7337;
7344 -> 7343;
7344 -> 7303;
7345 -> 7303;
7345 -> 7344;
7346 -> 7344;
7347 -> 7345;
7347 -> 7346;
7348 -> 7303;
7348 -> 7346;
7349 -> 7346;
7350 -> 7347;
7350 -> 7349;
7351 -> 7350;
7351 -> 7346;
7352 -> 7351;
7352 -> 4365;
7352 -> 7346;
7353 -> 7346;
7354 -> 7347;
7354 -> 7353;
7355 -> 7354;
7355 -> 7353;
7356 -> 7355;
7356 -> 7303;
7356 -> 7353;
7357 -> 7356;
7358 -> 7356;
7359 -> 7357;
7359 -> 7358;
7360 -> 7359;
7360 -> 7356;
7361 -> 7356;
7362 -> 7360;
7362 -> 7361;
7363 -> 7362;
7363 -> 7346;
7364 -> 7348;
7364 -> 7346;
7365 -> 7363;
7365 -> 7364;
7365 -> 7346;
7366 -> 7346;
7367 -> 7347;
7367 -> 7366;
7368 -> 7366;
7369 -> 7367;
7369 -> 7368;
7370 -> 7369;
7370 -> 7303;
7370 -> 7368;
7371 -> 7368;
7372 -> 7370;
7372 -> 7371;
7373 -> 7371;
7373 -> 7368;
7374 -> 7368;
7375 -> 7370;
7375 -> 7374;
7376 -> 7375;
7376 -> 7368;
7377 -> 7376;
7377 -> 7366;
7378 -> 7377;
7378 -> 7346;
7379 -> 7346;
7380 -> 7378;
7380 -> 7379;
7381 -> 7380;
7381 -> 7303;
7381 -> 7379;
7382 -> 7346;
7383 -> 7346;
7384 -> 7348;
7384 -> 7383;
7385 -> 7384;
7385 -> 7346;
7386 -> 7348;
7386 -> 7346;
7387 -> 7346;
7388 -> 7348;
7388 -> 7303;
7388 -> 7387;
7388 -> 7346;
7389 -> 7348;
7389 -> 7303;
7389 -> 7388;
7390 -> 7388;
7391 -> 7348;
7391 -> 7389;
7391 -> 7351;
7391 -> 7346;
7392 -> 7347;
7392 -> 7346;
7393 -> 7346;
7394 -> 7348;
7394 -> 7391;
7395 -> 7391;
7396 -> 7348;
7396 -> 7391;
7396 -> 7394;
7396 -> 7395;
7397 -> 7348;
7397 -> 7391;
7397 -> 7394;
7397 -> 0;
7398 -> 7344;
7399 -> 7344;
7400 -> 7303;
7400 -> 7391;
7400 -> 7399;
7401 -> 7400;
7401 -> 7391;
7401 -> 7394;
7401 -> 0;
7401 -> 7399;
7402 -> 7401;
7402 -> 7344;
7403 -> 7394;
7404 -> 7394;
7405 -> 7402;
7405 -> 4365;
7406 -> 7402;
7407 -> 7406;
7408 -> 7407;
7408 -> 7394;
7408 -> 7406;
7409 -> 7408;
7410 -> 7408;
7411 -> 7409;
7411 -> 7410;
7412 -> 7411;
7412 -> 7408;
7413 -> 7408;
7414 -> 7412;
7414 -> 7413;
7415 -> 7414;
7415 -> 7402;
7416 -> 7402;
7417 -> 7402;
7418 -> 7402;
7418 -> 7417;
7419 -> 7417;
7420 -> 7418;
7420 -> 7419;
7421 -> 7420;
7421 -> 7394;
7421 -> 7419;
7422 -> 7419;
7423 -> 7421;
7423 -> 7422;
7424 -> 7422;
7424 -> 7419;
7425 -> 7419;
7426 -> 7421;
7426 -> 7425;
7427 -> 7426;
7427 -> 7419;
7428 -> 7427;
7428 -> 7417;
7429 -> 7428;
7429 -> 7402;
7430 -> 7402;
7431 -> 7429;
7431 -> 7430;
7432 -> 7431;
7432 -> 7394;
7432 -> 7430;
7433 -> 7402;
7434 -> 7402;
7435 -> 7434;
7435 -> 7402;
7436 -> 7402;
7437 -> 7402;
7438 -> 7402;
7438 -> 0;
7439 -> 7402;
7440 -> 7402;
7441 -> 7434;
7441 -> 4365;
7442 -> 7434;
7443 -> 7442;
7444 -> 7443;
7444 -> 7402;
7444 -> 7442;
7445 -> 7444;
7446 -> 7444;
7447 -> 7445;
7447 -> 7446;
7448 -> 7447;
7448 -> 7444;
7449 -> 7444;
7450 -> 7448;
7450 -> 7449;
7451 -> 7450;
7451 -> 7434;
7452 -> 7434;
7453 -> 7434;
7454 -> 7434;
7454 -> 7453;
7455 -> 7453;
7456 -> 7454;
7456 -> 7455;
7457 -> 7456;
7457 -> 7402;
7457 -> 7455;
7458 -> 7455;
7459 -> 7457;
7459 -> 7458;
7460 -> 7458;
7460 -> 7455;
7461 -> 7455;
7462 -> 7457;
7462 -> 7461;
7463 -> 7462;
7463 -> 7455;
7464 -> 7463;
7464 -> 7453;
7465 -> 7464;
7465 -> 7434;
7466 -> 7434;
7467 -> 7465;
7467 -> 7466;
7468 -> 7467;
7468 -> 7402;
7468 -> 7466;
7469 -> 7434;
7470 -> 7434;
7471 -> 7434;
7472 -> 7434;
7472 -> 0;
7473 -> 7434;
7474 -> 7434;
7475 -> 7443;
7475 -> 7434;
7475 -> 7442;
7476 -> 7475;
7477 -> 7475;
7478 -> 7476;
7478 -> 7477;
7479 -> 7478;
7479 -> 7475;
7480 -> 7475;
7481 -> 7479;
7481 -> 7480;
7482 -> 7481;
7482 -> 7434;
7483 -> 7456;
7483 -> 7434;
7483 -> 7455;
7484 -> 7483;
7484 -> 7458;
7485 -> 7483;
7485 -> 7461;
7486 -> 7485;
7486 -> 7455;
7487 -> 7486;
7487 -> 7453;
7488 -> 7487;
7488 -> 7434;
7489 -> 7488;
7489 -> 7466;
7490 -> 7489;
7490 -> 7434;
7490 -> 7466;
7491 -> 7218;
7492 -> 7215;
7492 -> 7434;
7492 -> 7218;
7493 -> 7218;
7494 -> 7211;
7495 -> 7211;
7496 -> 7495;
7496 -> 7211;
7497 -> 7212;
7497 -> 7211;
7498 -> 7495;
7498 -> 7211;
7499 -> 7213;
7499 -> 7492;
7499 -> 7497;
7499 -> 7498;
7499 -> 7496;
7499 -> 7211;
7500 -> 7499;
7500 -> 7211;
7501 -> 7500;
7501 -> 7007;
7502 -> 7501;
7503 -> 7501;
7503 -> 7502;
7504 -> 7502;
7505 -> 7504;
7505 -> 7501;
7506 -> 7501;
7507 -> 7209;
7507 -> 7506;
7507 -> 7501;
7508 -> 7501;
7509 -> 7501;
7509 -> 7508;
7510 -> 7508;
7511 -> 7510;
7511 -> 7501;
7512 -> 7209;
7512 -> 7511;
7512 -> 7501;
7513 -> 7505;
7513 -> 7512;
7513 -> 7501;
7514 -> 7513;
7515 -> 7015;
7515 -> 7514;
7515 -> 7513;
7516 -> 7501;
7516 -> 7513;
7517 -> 7007;
7518 -> 7516;
7518 -> 7517;
7518 -> 7007;
7519 -> 7516;
7519 -> 7007;
7520 -> 6971;
7521 -> 7519;
7521 -> 7520;
7521 -> 6971;
7522 -> 7519;
7522 -> 6971;
7523 -> 6964;
7524 -> 7522;
7524 -> 7523;
7525 -> 7523;
7525 -> 6964;
7526 -> 6964;
7527 -> 7522;
7527 -> 7526;
7528 -> 0;
7528 -> 7526;
7529 -> 7527;
7529 -> 6964;
7530 -> 7525;
7530 -> 7529;
7530 -> 6964;
7531 -> 7522;
7531 -> 6964;
7532 -> 6964;
7533 -> 7531;
7533 -> 7532;
7534 -> 6949;
7534 -> 7532;
7535 -> 7532;
7536 -> 7533;
7536 -> 4365;
7536 -> 7532;
7537 -> 7532;
7538 -> 7533;
7538 -> 7537;
7539 -> 7538;
7539 -> 7537;
7540 -> 7539;
7540 -> 7500;
7540 -> 7537;
7541 -> 7540;
7542 -> 7540;
7543 -> 7541;
7543 -> 7542;
7544 -> 7543;
7544 -> 7540;
7545 -> 7540;
7546 -> 7544;
7546 -> 7545;
7547 -> 7546;
7547 -> 7532;
7548 -> 7534;
7548 -> 7532;
7549 -> 7532;
7550 -> 7533;
7550 -> 7549;
7551 -> 7549;
7552 -> 7550;
7552 -> 7551;
7553 -> 7552;
7553 -> 7500;
7553 -> 7551;
7554 -> 7551;
7555 -> 7553;
7555 -> 7554;
7556 -> 7554;
7556 -> 7551;
7557 -> 7551;
7558 -> 7553;
7558 -> 7557;
7559 -> 7557;
7560 -> 7558;
7560 -> 7551;
7561 -> 7560;
7561 -> 7549;
7562 -> 7561;
7562 -> 7532;
7563 -> 7532;
7564 -> 7562;
7564 -> 7563;
7565 -> 7564;
7565 -> 7500;
7565 -> 7563;
7566 -> 7532;
7567 -> 7532;
7568 -> 7534;
7568 -> 7567;
7569 -> 7568;
7569 -> 7500;
7569 -> 7567;
7570 -> 7569;
7570 -> 7532;
7571 -> 7534;
7571 -> 7532;
7572 -> 7532;
7573 -> 7534;
7573 -> 7500;
7573 -> 7572;
7573 -> 7532;
7574 -> 7532;
7575 -> 7533;
7576 -> 7534;
7576 -> 7533;
7577 -> 6964;
7578 -> 6949;
7578 -> 7533;
7578 -> 6948;
7578 -> 6947;
7579 -> 6936;
7579 -> 6935;
7580 -> 6935;
7581 -> 6938;
7581 -> 7580;
7582 -> 7579;
7582 -> 7580;
7583 -> 7580;
7584 -> 0;
7584 -> 7580;
7585 -> 7580;
7586 -> 7584;
7586 -> 7585;
7587 -> 7582;
7587 -> 7585;
7588 -> 7585;
7589 -> 7587;
7589 -> 7588;
7590 -> 7589;
7590 -> 7533;
7590 -> 7588;
7591 -> 7586;
7591 -> 7585;
7592 -> 7585;
7593 -> 7591;
7593 -> 7592;
7594 -> 7592;
7595 -> 7590;
7595 -> 7594;
7596 -> 7595;
7596 -> 7592;
7597 -> 7596;
7598 -> 7596;
7598 -> 7597;
7599 -> 7597;
7600 -> 7598;
7600 -> 7599;
7601 -> 7599;
7602 -> 7600;
7602 -> 7533;
7602 -> 7601;
7602 -> 7599;
7603 -> 7597;
7604 -> 7598;
7604 -> 7533;
7604 -> 7597;
7605 -> 7604;
7605 -> 7596;
7606 -> 7596;
7607 -> 7592;
7608 -> 7590;
7608 -> 7533;
7608 -> 7593;
7608 -> 7592;
7609 -> 7608;
7610 -> 7608;
7611 -> 7608;
7612 -> 7608;
7613 -> 7610;
7613 -> 7612;
7613 -> 7608;
7614 -> 7608;
7615 -> 7608;
7616 -> 7608;
7617 -> 7608;
7618 -> 7608;
7619 -> 7618;
7619 -> 7608;
7620 -> 7608;
7621 -> 7619;
7621 -> 7620;
7622 -> 7620;
7622 -> 7608;
7623 -> 7608;
7624 -> 7622;
7625 -> 7619;
7625 -> 7624;
7626 -> 7625;
7626 -> 7622;
7627 -> 7622;
7628 -> 7622;
7629 -> 7619;
7629 -> 7628;
7630 -> 7629;
7630 -> 7622;
7631 -> 7630;
7631 -> 7620;
7632 -> 7626;
7633 -> 7626;
7634 -> 7626;
7635 -> 7626;
7636 -> 7626;
7637 -> 7626;
7638 -> 7626;
7639 -> 7626;
7640 -> 7626;
7641 -> 7626;
7642 -> 7626;
7643 -> 7626;
7644 -> 7626;
7645 -> 7626;
7646 -> 7645;
7646 -> 7626;
7647 -> 7646;
7647 -> 7626;
7648 -> 7626;
7649 -> 7626;
7650 -> 7626;
7651 -> 7626;
7652 -> 7626;
7653 -> 7626;
7654 -> 7626;
7655 -> 7626;
7656 -> 7626;
7657 -> 7626;
7658 -> 7626;
7659 -> 0;
7659 -> 7626;
7660 -> 7657;
7660 -> 7626;
7661 -> 7626;
7662 -> 7643;
7662 -> 7661;
7662 -> 7626;
7663 -> 7626;
7664 -> 7638;
7664 -> 7663;
7664 -> 7626;
7665 -> 7626;
7666 -> 7626;
7667 -> 7626;
7667 -> 4365;
7668 -> 7626;
7669 -> 7668;
7670 -> 7669;
7670 -> 7626;
7670 -> 7668;
7671 -> 7670;
7672 -> 7670;
7673 -> 7671;
7673 -> 7672;
7674 -> 7673;
7674 -> 7670;
7675 -> 7670;
7676 -> 7674;
7676 -> 7675;
7677 -> 7676;
7677 -> 7626;
7678 -> 7626;
7679 -> 7626;
7680 -> 7626;
7680 -> 7679;
7681 -> 7679;
7682 -> 7680;
7682 -> 7681;
7683 -> 7682;
7683 -> 7626;
7683 -> 7681;
7684 -> 7681;
7685 -> 7683;
7685 -> 7684;
7686 -> 7684;
7686 -> 7681;
7687 -> 7681;
7688 -> 7683;
7688 -> 7687;
7689 -> 7688;
7689 -> 7681;
7690 -> 7689;
7690 -> 7679;
7691 -> 7690;
7691 -> 7626;
7692 -> 7626;
7693 -> 7691;
7693 -> 7692;
7694 -> 7693;
7694 -> 7626;
7694 -> 7692;
7695 -> 7626;
7696 -> 7626;
7697 -> 7626;
7698 -> 7626;
7698 -> 0;
7699 -> 7626;
7700 -> 7610;
7700 -> 7699;
7700 -> 7626;
7701 -> 7626;
7701 -> 7614;
7701 -> 7608;
7702 -> 7626;
7702 -> 7608;
7703 -> 7626;
7704 -> 7626;
7704 -> 7703;
7705 -> 7703;
7705 -> 7626;
7706 -> 7626;
7707 -> 7626;
7708 -> 7707;
7708 -> 7626;
7709 -> 7626;
7710 -> 7626;
7710 -> 7709;
7711 -> 7710;
7711 -> 7709;
7712 -> 7709;
7712 -> 7626;
7713 -> 7626;
7714 -> 7713;
7715 -> 7626;
7716 -> 7626;
7717 -> 7626;
7718 -> 7626;
7719 -> 7717;
7719 -> 7626;
7720 -> 7719;
7721 -> 7719;
7722 -> 7626;
7723 -> 7626;
7724 -> 7626;
7725 -> 0;
7725 -> 7626;
7726 -> 7626;
7727 -> 7726;
7727 -> 7626;
7728 -> 7727;
7728 -> 7626;
7729 -> 7626;
7730 -> 7728;
7730 -> 7729;
7731 -> 7626;
7731 -> 7729;
7732 -> 7730;
7732 -> 7729;
7733 -> 7729;
7734 -> 7732;
7734 -> 7733;
7734 -> 7729;
7735 -> 7731;
7735 -> 7626;
7735 -> 0;
7735 -> 7729;
7736 -> 7729;
7737 -> 7732;
7737 -> 7736;
7738 -> 7737;
7738 -> 7626;
7738 -> 7736;
7739 -> 7736;
7739 -> 7729;
7740 -> 7739;
7740 -> 7626;
7741 -> 7626;
7741 -> 7740;
7742 -> 7740;
7743 -> 7741;
7743 -> 7742;
7744 -> 7741;
7744 -> 7742;
7745 -> 7744;
7745 -> 7741;
7745 -> 7742;
7746 -> 7742;
7747 -> 7743;
7747 -> 7742;
7748 -> 7742;
7749 -> 7745;
7749 -> 7748;
7750 -> 7745;
7750 -> 7748;
7751 -> 7745;
7751 -> 7748;
7752 -> 7745;
7752 -> 7748;
7753 -> 7745;
7753 -> 7748;
7754 -> 7745;
7754 -> 7748;
7755 -> 7746;
7755 -> 7748;
7756 -> 7747;
7756 -> 7748;
7757 -> 7746;
7757 -> 7748;
7758 -> 7749;
7758 -> 7748;
7759 -> 7750;
7759 -> 7748;
7760 -> 7755;
7760 -> 7748;
7761 -> 7751;
7761 -> 7748;
7762 -> 7752;
7762 -> 7748;
7763 -> 7756;
7763 -> 7748;
7764 -> 7748;
7765 -> 7764;
7765 -> 7758;
7765 -> 7759;
7765 -> 7760;
7765 -> 7761;
7765 -> 7762;
7765 -> 7763;
7765 -> 7741;
7765 -> 7748;
7766 -> 7753;
7766 -> 7764;
7766 -> 7748;
7767 -> 7754;
7767 -> 7764;
7767 -> 7748;
7768 -> 7746;
7768 -> 7740;
7769 -> 7741;
7769 -> 7768;
7769 -> 7765;
7769 -> 7764;
7769 -> 7766;
7769 -> 7767;
7769 -> 7740;
7770 -> 7740;
7771 -> 7769;
7771 -> 7770;
7772 -> 7727;
7772 -> 7770;
7773 -> 7771;
7773 -> 7769;
7773 -> 7770;
7774 -> 7771;
7774 -> 7769;
7774 -> 7770;
7775 -> 7772;
7775 -> 7771;
7776 -> 7775;
7776 -> 7771;
7777 -> 7771;
7778 -> 7776;
7778 -> 7771;
7779 -> 7771;
7780 -> 7778;
7780 -> 7779;
7780 -> 7771;
7781 -> 7777;
7781 -> 7769;
7781 -> 0;
7781 -> 7771;
7782 -> 7778;
7782 -> 7771;
7783 -> 7782;
7783 -> 7769;
7783 -> 7771;
7784 -> 7771;
7784 -> 7769;
7785 -> 7771;
7785 -> 7769;
7786 -> 7782;
7786 -> 7769;
7786 -> 7771;
7787 -> 7775;
7787 -> 7771;
7788 -> 7787;
7788 -> 7769;
7788 -> 7771;
7789 -> 7771;
7790 -> 7775;
7790 -> 7789;
7791 -> 7790;
7791 -> 7775;
7791 -> 7789;
7792 -> 7789;
7792 -> 7771;
7793 -> 7771;
7794 -> 7792;
7794 -> 7793;
7795 -> 7771;
7795 -> 7793;
7796 -> 0;
7796 -> 7793;
7797 -> 7793;
7798 -> 7794;
7798 -> 7793;
7799 -> 7793;
7800 -> 7796;
7800 -> 7799;
7801 -> 7797;
7801 -> 7799;
7802 -> 7798;
7802 -> 7799;
7803 -> 7795;
7803 -> 7799;
7804 -> 7803;
7804 -> 7775;
7804 -> 7802;
7805 -> 7771;
7806 -> 7772;
7806 -> 7770;
7807 -> 7806;
7807 -> 7804;
7807 -> 7770;
7808 -> 7740;
7809 -> 7740;
7810 -> 7727;
7810 -> 7809;
7811 -> 7810;
7811 -> 7804;
7811 -> 7809;
7812 -> 7809;
7812 -> 7740;
7813 -> 7740;
7814 -> 7792;
7814 -> 7813;
7815 -> 7626;
7815 -> 7813;
7816 -> 0;
7816 -> 7813;
7817 -> 7813;
7818 -> 7814;
7818 -> 7813;
7819 -> 7813;
7820 -> 7816;
7820 -> 7819;
7821 -> 7817;
7821 -> 7819;
7822 -> 7818;
7822 -> 7819;
7823 -> 7815;
7823 -> 7819;
7824 -> 7740;
7825 -> 7626;
7826 -> 7825;
7826 -> 7804;
7826 -> 7626;
7827 -> 7712;
7827 -> 7804;
7827 -> 7626;
7828 -> 7626;
7828 -> 7608;
7829 -> 7626;
7829 -> 7608;
7829 -> 7828;
7830 -> 7828;
7831 -> 7828;
7832 -> 7626;
7832 -> 7608;
7832 -> 7831;
7833 -> 7831;
7834 -> 7832;
7834 -> 7833;
7835 -> 7833;
7835 -> 7804;
7836 -> 7833;
7836 -> 7804;
7837 -> 7836;
7838 -> 7836;
7839 -> 7836;
7840 -> 7836;
7841 -> 7840;
7841 -> 7836;
7842 -> 7841;
7842 -> 7836;
7843 -> 7841;
7843 -> 7836;
7844 -> 7841;
7845 -> 7841;
7846 -> 7841;
7847 -> 7841;
7848 -> 7841;
7849 -> 7841;
7850 -> 7841;
7851 -> 7841;
7852 -> 7851;
7852 -> 7841;
7853 -> 7852;
7853 -> 7841;
7854 -> 7841;
7855 -> 7841;
7856 -> 7841;
7857 -> 7841;
7858 -> 7841;
7859 -> 7841;
7860 -> 7841;
7861 -> 7841;
7862 -> 7841;
7863 -> 7841;
7864 -> 7841;
7865 -> 0;
7865 -> 7841;
7866 -> 7863;
7866 -> 7841;
7867 -> 7841;
7868 -> 7841;
7869 -> 7841;
7870 -> 7841;
7871 -> 7849;
7871 -> 7870;
7871 -> 7841;
7872 -> 7841;
7873 -> 7872;
7873 -> 7841;
7874 -> 7873;
7874 -> 7841;
7875 -> 7841;
7876 -> 7841;
7877 -> 7844;
7877 -> 7876;
7877 -> 7841;
7878 -> 7841;
7879 -> 7841;
7880 -> 7841;
7880 -> 4365;
7881 -> 7841;
7882 -> 7881;
7883 -> 7882;
7883 -> 7841;
7883 -> 7881;
7884 -> 7883;
7885 -> 7883;
7886 -> 7884;
7886 -> 7885;
7887 -> 7886;
7887 -> 7883;
7888 -> 7883;
7889 -> 7887;
7889 -> 7888;
7890 -> 7889;
7890 -> 7841;
7891 -> 7841;
7892 -> 7841;
7893 -> 7841;
7893 -> 7892;
7894 -> 7892;
7895 -> 7893;
7895 -> 7894;
7896 -> 7895;
7896 -> 7841;
7896 -> 7894;
7897 -> 7894;
7898 -> 7896;
7898 -> 7897;
7899 -> 7897;
7899 -> 7894;
7900 -> 7894;
7901 -> 7896;
7901 -> 7900;
7902 -> 7901;
7902 -> 7894;
7903 -> 7902;
7903 -> 7892;
7904 -> 7903;
7904 -> 7841;
7905 -> 7841;
7906 -> 7904;
7906 -> 7905;
7907 -> 7906;
7907 -> 7841;
7907 -> 7905;
7908 -> 7841;
7909 -> 7841;
7910 -> 7841;
7911 -> 7841;
7911 -> 0;
7912 -> 7833;
7913 -> 7833;
7913 -> 7841;
7913 -> 7834;
7914 -> 7913;
7914 -> 7831;
7915 -> 7914;
7916 -> 7914;
7916 -> 7915;
7917 -> 7916;
7917 -> 7913;
7917 -> 7915;
7918 -> 7917;
7918 -> 7914;
7919 -> 7914;
7920 -> 7914;
7920 -> 7919;
7921 -> 7920;
7921 -> 7913;
7921 -> 7919;
7922 -> 7921;
7922 -> 7914;
7923 -> 7918;
7923 -> 7922;
7923 -> 7914;
7924 -> 7923;
7925 -> 7706;
7925 -> 7924;
7925 -> 7923;
7926 -> 7914;
7926 -> 7923;
7927 -> 7626;
7928 -> 7926;
7928 -> 7927;
7928 -> 7626;
7929 -> 7608;
7930 -> 7926;
7930 -> 7929;
7930 -> 7608;
7931 -> 7608;
7932 -> 7926;
7932 -> 7931;
7933 -> 7931;
7933 -> 7608;
7934 -> 7608;
7935 -> 7926;
7935 -> 7934;
7936 -> 0;
7936 -> 7934;
7937 -> 7935;
7937 -> 7608;
7938 -> 7933;
7938 -> 7937;
7938 -> 7608;
7939 -> 7926;
7939 -> 4365;
7939 -> 7608;
7940 -> 7608;
7941 -> 7926;
7941 -> 7940;
7942 -> 7941;
7942 -> 7940;
7943 -> 7942;
7943 -> 7913;
7943 -> 7940;
7944 -> 7943;
7945 -> 7943;
7946 -> 7944;
7946 -> 7945;
7947 -> 7946;
7947 -> 7943;
7948 -> 7943;
7949 -> 7947;
7949 -> 7948;
7950 -> 7949;
7950 -> 7608;
7951 -> 7608;
7952 -> 7608;
7953 -> 7926;
7953 -> 7952;
7954 -> 7952;
7955 -> 7953;
7955 -> 7954;
7956 -> 7955;
7956 -> 7913;
7956 -> 7954;
7957 -> 7954;
7958 -> 7956;
7958 -> 7957;
7959 -> 7957;
7959 -> 7954;
7960 -> 7954;
7961 -> 7956;
7961 -> 7960;
7962 -> 7961;
7962 -> 7954;
7963 -> 7962;
7963 -> 7952;
7964 -> 7963;
7964 -> 7608;
7965 -> 7608;
7966 -> 7964;
7966 -> 7965;
7967 -> 7966;
7967 -> 7913;
7967 -> 7965;
7968 -> 7608;
7969 -> 7913;
7969 -> 7608;
7970 -> 7608;
7971 -> 7926;
7972 -> 7608;
7972 -> 7926;
7973 -> 7590;
7973 -> 7926;
7973 -> 7593;
7973 -> 7592;
7974 -> 7973;
7974 -> 7580;
7975 -> 7580;
7976 -> 7974;
7976 -> 7975;
7977 -> 7975;
7978 -> 7976;
7978 -> 7977;
7978 -> 7975;
7979 -> 7975;
7980 -> 7976;
7980 -> 7979;
7981 -> 7979;
7981 -> 7975;
7982 -> 7981;
7982 -> 7580;
7983 -> 7973;
7983 -> 7982;
7984 -> 7581;
7984 -> 7982;
7985 -> 7984;
7985 -> 6675;
7985 -> 6676;
7985 -> 6677;
7985 -> 7926;
7985 -> 7982;
7986 -> 7982;
7987 -> 7982;
7988 -> 7983;
7988 -> 7987;
7989 -> 7985;
7989 -> 7987;
7990 -> 7986;
7990 -> 7987;
7991 -> 7986;
7991 -> 7987;
7992 -> 7986;
7992 -> 7987;
7993 -> 7987;
7994 -> 7988;
7994 -> 7993;
7995 -> 7994;
7995 -> 7926;
7995 -> 7993;
7996 -> 7987;
7997 -> 7988;
7997 -> 7996;
7998 -> 7997;
7998 -> 7926;
7998 -> 7996;
7999 -> 7987;
8000 -> 7988;
8000 -> 7999;
8001 -> 7987;
8002 -> 8000;
8002 -> 8001;
8003 -> 8001;
8004 -> 8002;
8004 -> 8003;
8005 -> 8004;
8005 -> 7926;
8005 -> 8003;
8006 -> 8005;
8007 -> 8004;
8007 -> 8006;
8008 -> 8007;
8008 -> 7926;
8008 -> 8006;
8009 -> 8006;
8010 -> 8008;
8010 -> 8009;
8011 -> 8009;
8011 -> 8006;
8012 -> 8006;
8013 -> 8008;
8013 -> 8012;
8014 -> 8013;
8014 -> 8006;
8015 -> 8014;
8015 -> 8005;
8016 -> 8004;
8016 -> 7926;
8016 -> 8005;
8017 -> 8004;
8017 -> 7926;
8017 -> 8005;
8018 -> 8005;
8019 -> 8018;
8019 -> 8017;
8019 -> 8005;
8020 -> 8015;
8020 -> 8019;
8021 -> 8004;
8021 -> 8019;
8022 -> 8018;
8022 -> 8019;
8023 -> 8016;
8023 -> 8018;
8023 -> 8019;
8024 -> 8019;
8025 -> 8019;
8026 -> 8020;
8026 -> 8025;
8027 -> 8021;
8027 -> 8025;
8028 -> 8022;
8028 -> 8025;
8029 -> 8023;
8029 -> 8025;
8030 -> 8024;
8030 -> 8025;
8031 -> 8026;
8031 -> 8025;
8032 -> 8027;
8032 -> 8025;
8033 -> 8028;
8033 -> 8025;
8034 -> 8029;
8034 -> 8025;
8035 -> 8025;
8036 -> 8031;
8036 -> 8035;
8037 -> 8032;
8037 -> 8035;
8038 -> 8033;
8038 -> 8035;
8039 -> 8034;
8039 -> 8035;
8040 -> 8030;
8040 -> 8035;
8041 -> 8035;
8042 -> 8040;
8042 -> 8041;
8043 -> 8041;
8044 -> 8042;
8044 -> 8041;
8045 -> 8040;
8045 -> 8035;
8046 -> 8040;
8046 -> 8035;
8047 -> 8040;
8047 -> 8035;
8048 -> 0;
8048 -> 8040;
8048 -> 8035;
8049 -> 8040;
8049 -> 8035;
8050 -> 8040;
8050 -> 8035;
8052 -> 8051;
8053 -> 8052;
8053 -> 8051;
8054 -> 8052;
8054 -> 8051;
8055 -> 8051;
8056 -> 8055;
8056 -> 8052;
8056 -> 8051;
8057 -> 8051;
8058 -> 8057;
8058 -> 8052;
8058 -> 8051;
8059 -> 8051;
8060 -> 8059;
8060 -> 8040;
8060 -> 8035;
8061 -> 8035;
8062 -> 8036;
8062 -> 8061;
8062 -> 8035;
8063 -> 8035;
8064 -> 8037;
8064 -> 8063;
8064 -> 8035;
8065 -> 8035;
8066 -> 8038;
8066 -> 8065;
8066 -> 8035;
8067 -> 8039;
8067 -> 8023;
8067 -> 8035;
8068 -> 8037;
8068 -> 8040;
8068 -> 8035;
8069 -> 8035;
8070 -> 8035;
8071 -> 8036;
8071 -> 8070;
8072 -> 8071;
8072 -> 8023;
8072 -> 8070;
8073 -> 8072;
8073 -> 8035;
8074 -> 8039;
8074 -> 8035;
8075 -> 8040;
8075 -> 8046;
8075 -> 8035;
8076 -> 8069;
8076 -> 8035;
8077 -> 8073;
8077 -> 8074;
8077 -> 8075;
8077 -> 8076;
8077 -> 8023;
8077 -> 8035;
8078 -> 8077;
8078 -> 0;
8078 -> 8035;
8079 -> 8035;
8080 -> 8078;
8080 -> 8035;
8081 -> 8080;
8081 -> 8040;
8081 -> 8035;
8082 -> 8038;
8082 -> 8040;
8082 -> 8035;
8083 -> 8039;
8083 -> 8040;
8083 -> 8035;
8084 -> 8024;
8084 -> 8018;
8084 -> 8017;
8084 -> 8019;
8085 -> 8004;
8085 -> 8077;
8085 -> 8005;
8086 -> 8017;
8086 -> 8005;
8087 -> 8086;
8087 -> 8017;
8087 -> 8084;
8087 -> 8042;
8087 -> 8044;
8087 -> 8068;
8087 -> 8077;
8087 -> 8082;
8087 -> 8048;
8087 -> 8081;
8087 -> 8050;
8087 -> 8060;
8087 -> 8083;
8087 -> 8056;
8087 -> 8058;
8087 -> 8023;
8087 -> 8005;
8088 -> 8001;
8089 -> 8002;
8089 -> 8087;
8089 -> 8001;
8091 -> 8090;
8092 -> 0;
8093 -> 8092;
8093 -> 0;
8094 -> 8093;
8096 -> 8095;
8097 -> 8094;
8097 -> 8095;
8098 -> 8097;
8098 -> 8096;
8099 -> 8096;
8100 -> 8099;
8101 -> 8099;
8101 -> 8096;
8102 -> 8098;
8102 -> 8099;
8102 -> 8096;
8103 -> 8094;
8103 -> 8095;
8104 -> 8095;
8105 -> 7989;
8105 -> 7987;
8106 -> 7987;
8107 -> 7998;
8107 -> 8106;
8108 -> 8089;
8108 -> 8106;
8109 -> 8105;
8109 -> 8106;
8110 -> 8106;
8111 -> 8107;
8111 -> 8106;
8112 -> 8106;
8113 -> 8111;
8113 -> 8112;
8114 -> 8113;
8114 -> 8112;
8115 -> 8112;
8116 -> 8114;
8116 -> 8115;
8116 -> 8112;
8117 -> 8116;
8117 -> 8112;
8118 -> 8117;
8118 -> 8103;
8119 -> 8118;
8119 -> 8110;
8120 -> 8110;
8121 -> 8120;
8122 -> 8120;
8122 -> 8110;
8123 -> 8119;
8123 -> 8120;
8123 -> 8110;
8124 -> 8106;
8125 -> 8124;
8125 -> 8108;
8125 -> 8087;
8125 -> 8106;
8126 -> 8108;
8126 -> 8124;
8126 -> 8087;
8126 -> 8125;
8127 -> 8109;
8127 -> 8124;
8127 -> 7926;
8127 -> 6675;
8127 -> 6676;
8127 -> 6677;
8127 -> 7985;
8127 -> 8126;
8127 -> 8125;
8128 -> 8126;
8128 -> 8125;
8129 -> 8125;
8130 -> 8128;
8130 -> 8129;
8131 -> 8127;
8131 -> 8129;
8133 -> 8132;
8135 -> 8134;
8137 -> 8136;
8138 -> 8131;
8138 -> 8127;
8138 -> 8129;
8139 -> 8129;
8140 -> 8138;
8140 -> 8139;
8141 -> 8140;
8141 -> 6585;
8141 -> 8139;
8142 -> 8131;
8142 -> 8127;
8142 -> 8130;
8142 -> 8129;
8143 -> 8141;
8143 -> 8142;
8143 -> 8129;
8144 -> 8126;
8144 -> 8143;
8145 -> 8127;
8145 -> 8143;
8146 -> 8110;
8146 -> 8123;
8146 -> 8144;
8146 -> 8145;
8146 -> 8118;
8146 -> 8127;
8146 -> 8143;
8147 -> 7987;
8148 -> 7988;
8148 -> 8147;
8149 -> 0;
8150 -> 7988;
8150 -> 7987;
8151 -> 7990;
8151 -> 7987;
8152 -> 7991;
8152 -> 7987;
8153 -> 7987;
8154 -> 7995;
8154 -> 8153;
8155 -> 8106;
8155 -> 8153;
8156 -> 8148;
8156 -> 8153;
8157 -> 8150;
8157 -> 8153;
8158 -> 8151;
8158 -> 8153;
8159 -> 8152;
8159 -> 8153;
8160 -> 7992;
8160 -> 8153;
8161 -> 8156;
8161 -> 8153;
8162 -> 8159;
8162 -> 8153;
8163 -> 8153;
8164 -> 8161;
8164 -> 8163;
8165 -> 8162;
8165 -> 8163;
8166 -> 8160;
8166 -> 8163;
8167 -> 8165;
8167 -> 8163;
8168 -> 8163;
8169 -> 8167;
8169 -> 8168;
8170 -> 8166;
8170 -> 8168;
8171 -> 8166;
8171 -> 8163;
8172 -> 8163;
8173 -> 8164;
8173 -> 8172;
8173 -> 8163;
8174 -> 8164;
8174 -> 8166;
8174 -> 8163;
8175 -> 8160;
8175 -> 8153;
8176 -> 8160;
8176 -> 8153;
8177 -> 8160;
8177 -> 8153;
8178 -> 8160;
8178 -> 8153;
8179 -> 8160;
8179 -> 8153;
8180 -> 8160;
8180 -> 8153;
8181 -> 8153;
8182 -> 8156;
8182 -> 8181;
8183 -> 8181;
8184 -> 8182;
8184 -> 8183;
8185 -> 8183;
8186 -> 8184;
8186 -> 8185;
8187 -> 8185;
8188 -> 8186;
8188 -> 8187;
8189 -> 8187;
8190 -> 8188;
8190 -> 8189;
8191 -> 8190;
8191 -> 8187;
8192 -> 8191;
8192 -> 8185;
8193 -> 8192;
8193 -> 8183;
8194 -> 8193;
8194 -> 8181;
8195 -> 8194;
8195 -> 8153;
8196 -> 8156;
8196 -> 8153;
8197 -> 8153;
8198 -> 8196;
8198 -> 8197;
8199 -> 8197;
8200 -> 8198;
8200 -> 8199;
8200 -> 8197;
8201 -> 8198;
8201 -> 8197;
8202 -> 8197;
8202 -> 8153;
8203 -> 8154;
8203 -> 8160;
8203 -> 8153;
8204 -> 8155;
8204 -> 8160;
8204 -> 8153;
8205 -> 8158;
8205 -> 8160;
8205 -> 8153;
8206 -> 8153;
8207 -> 8157;
8207 -> 8206;
8207 -> 8153;
8208 -> 8207;
8209 -> 8157;
8209 -> 8208;
8210 -> 8209;
8210 -> 8208;
8211 -> 8210;
8211 -> 8207;
8212 -> 8157;
8212 -> 8207;
8213 -> 8207;
8214 -> 8157;
8214 -> 8213;
8215 -> 8213;
8216 -> 8214;
8216 -> 8215;
8217 -> 8216;
8217 -> 8146;
8217 -> 8215;
8218 -> 8213;
8219 -> 8214;
8219 -> 8146;
8219 -> 8213;
8220 -> 8219;
8220 -> 8207;
8221 -> 8220;
8221 -> 8160;
8221 -> 8207;
8222 -> 8155;
8222 -> 8160;
8222 -> 8207;
8223 -> 7992;
8223 -> 7987;
8224 -> 7989;
8224 -> 7992;
8224 -> 7987;
8225 -> 7988;
8225 -> 7992;
8225 -> 7987;
8226 -> 7987;
8227 -> 7988;
8227 -> 8226;
8228 -> 8227;
8228 -> 8146;
8228 -> 8226;
8229 -> 8228;
8229 -> 7987;
8230 -> 7987;
8231 -> 7988;
8231 -> 8230;
8232 -> 8231;
8232 -> 8146;
8232 -> 8230;
8233 -> 8232;
8233 -> 7987;
8234 -> 7987;
8235 -> 7583;
8235 -> 7986;
8235 -> 8166;
8235 -> 8169;
8235 -> 8174;
8235 -> 8205;
8235 -> 8204;
8235 -> 8203;
8235 -> 8222;
8235 -> 8179;
8235 -> 8180;
8235 -> 8221;
8235 -> 8225;
8235 -> 8224;
8235 -> 8146;
8235 -> 8123;
8235 -> 7926;
8235 -> 6675;
8235 -> 6676;
8235 -> 6677;
8235 -> 7985;
8235 -> 7982;
8236 -> 0;
8236 -> 7580;
8237 -> 7580;
8238 -> 8236;
8238 -> 8237;
8239 -> 7582;
8239 -> 8237;
8240 -> 8237;
8241 -> 8239;
8241 -> 8240;
8242 -> 8241;
8242 -> 8235;
8242 -> 8240;
8243 -> 8238;
8243 -> 8237;
8244 -> 8237;
8245 -> 8243;
8245 -> 8244;
8246 -> 8244;
8247 -> 8242;
8247 -> 8246;
8248 -> 8247;
8248 -> 8244;
8249 -> 8248;
8250 -> 8248;
8250 -> 8249;
8251 -> 8249;
8252 -> 8250;
8252 -> 8251;
8253 -> 8251;
8254 -> 8252;
8254 -> 8235;
8254 -> 8253;
8254 -> 8251;
8255 -> 8249;
8256 -> 8250;
8256 -> 8235;
8256 -> 8249;
8257 -> 8256;
8257 -> 8248;
8258 -> 8248;
8259 -> 8244;
8260 -> 8242;
8260 -> 8235;
8260 -> 8245;
8260 -> 8244;
8261 -> 8242;
8261 -> 8235;
8261 -> 8245;
8261 -> 8244;
8262 -> 8261;
8262 -> 7580;
8263 -> 7580;
8264 -> 8262;
8264 -> 8263;
8265 -> 8263;
8266 -> 8264;
8266 -> 8265;
8266 -> 8263;
8267 -> 8263;
8268 -> 8264;
8268 -> 8267;
8269 -> 8267;
8269 -> 8263;
8270 -> 8269;
8270 -> 7580;
8271 -> 8261;
8271 -> 8270;
8272 -> 7581;
8272 -> 8270;
8273 -> 8272;
8273 -> 6675;
8273 -> 6676;
8273 -> 6677;
8273 -> 8235;
8273 -> 8270;
8274 -> 8270;
8275 -> 8270;
8276 -> 8271;
8276 -> 8275;
8277 -> 8273;
8277 -> 8275;
8278 -> 8274;
8278 -> 8275;
8279 -> 8274;
8279 -> 8275;
8280 -> 8274;
8280 -> 8275;
8281 -> 8275;
8282 -> 8275;
8283 -> 8275;
8284 -> 8275;
8285 -> 8284;
8286 -> 8276;
8287 -> 8276;
8287 -> 8286;
8288 -> 8286;
8288 -> 8276;
8289 -> 8276;
8290 -> 8276;
8291 -> 8276;
8292 -> 8276;
8293 -> 8276;
8294 -> 8276;
8295 -> 8276;
8296 -> 8284;
8297 -> 8275;
8298 -> 8297;
8299 -> 8297;
8300 -> 8299;
8301 -> 8298;
8302 -> 8301;
8303 -> 8301;
8303 -> 8298;
8304 -> 8297;
8305 -> 8275;
8306 -> 8278;
8306 -> 8275;
8307 -> 8279;
8307 -> 8275;
8308 -> 8275;
8309 -> 8297;
8309 -> 8308;
8310 -> 8306;
8310 -> 8308;
8311 -> 8307;
8311 -> 8308;
8312 -> 8280;
8312 -> 8308;
8313 -> 8311;
8313 -> 8308;
8314 -> 8308;
8315 -> 8313;
8315 -> 8314;
8316 -> 8312;
8316 -> 8314;
8317 -> 8315;
8317 -> 8314;
8318 -> 8314;
8319 -> 8317;
8319 -> 8318;
8320 -> 8316;
8320 -> 8318;
8321 -> 8316;
8321 -> 8314;
8322 -> 8314;
8323 -> 8276;
8323 -> 8322;
8323 -> 8314;
8324 -> 8312;
8324 -> 8308;
8325 -> 8312;
8325 -> 8308;
8326 -> 8312;
8326 -> 8308;
8327 -> 8312;
8327 -> 8308;
8328 -> 8312;
8328 -> 8308;
8329 -> 8312;
8329 -> 8308;
8330 -> 8308;
8331 -> 8276;
8331 -> 8330;
8332 -> 8330;
8333 -> 8331;
8333 -> 8332;
8334 -> 8332;
8335 -> 8333;
8335 -> 8334;
8336 -> 8334;
8337 -> 8335;
8337 -> 8336;
8338 -> 8336;
8339 -> 8337;
8339 -> 8338;
8340 -> 8339;
8340 -> 8336;
8341 -> 8340;
8341 -> 8334;
8342 -> 8341;
8342 -> 8332;
8343 -> 8342;
8343 -> 8330;
8344 -> 8343;
8344 -> 8308;
8345 -> 8276;
8345 -> 8308;
8346 -> 8308;
8347 -> 8345;
8347 -> 8346;
8348 -> 8346;
8349 -> 8347;
8349 -> 8348;
8349 -> 8346;
8350 -> 8347;
8350 -> 8346;
8351 -> 8346;
8351 -> 8308;
8352 -> 8309;
8352 -> 8312;
8352 -> 8308;
8353 -> 8310;
8353 -> 8312;
8353 -> 8308;
8354 -> 8308;
8355 -> 8276;
8356 -> 8276;
8356 -> 8355;
8357 -> 8356;
8357 -> 8355;
8358 -> 8357;
8358 -> 8276;
8359 -> 8276;
8360 -> 8276;
8361 -> 8280;
8361 -> 8275;
8362 -> 8275;
8363 -> 8276;
8363 -> 8362;
8364 -> 8363;
8364 -> 8275;
8365 -> 8275;
8366 -> 8276;
8366 -> 8365;
8367 -> 8366;
8367 -> 8275;
8368 -> 8275;
8369 -> 7583;
8369 -> 8276;
8369 -> 7580;
8370 -> 6935;
8371 -> 6938;
8371 -> 8370;
8372 -> 7578;
8372 -> 8370;
8373 -> 8369;
8373 -> 8370;
8374 -> 8371;
8374 -> 8370;
8375 -> 8372;
8375 -> 8370;
8376 -> 8373;
8376 -> 8370;
8377 -> 8370;
8378 -> 8370;
8379 -> 8374;
8379 -> 8378;
8380 -> 8375;
8380 -> 8378;
8381 -> 8376;
8381 -> 8378;
8382 -> 8377;
8382 -> 8378;
8383 -> 8379;
8383 -> 8378;
8384 -> 8380;
8384 -> 8378;
8385 -> 8378;
8386 -> 8383;
8386 -> 8385;
8387 -> 8384;
8387 -> 8385;
8388 -> 8382;
8388 -> 8385;
8389 -> 8385;
8390 -> 8388;
8390 -> 8385;
8391 -> 8388;
8391 -> 8385;
8392 -> 8385;
8393 -> 8386;
8393 -> 8392;
8394 -> 8393;
8394 -> 6675;
8394 -> 8392;
8395 -> 8394;
8395 -> 8392;
8396 -> 8395;
8396 -> 8385;
8397 -> 8385;
8398 -> 8387;
8398 -> 8397;
8398 -> 8385;
8399 -> 8386;
8399 -> 8388;
8399 -> 8385;
8400 -> 8387;
8400 -> 8388;
8400 -> 8385;
8401 -> 8378;
8402 -> 8381;
8402 -> 8369;
8402 -> 8401;
8402 -> 8378;
8403 -> 8381;
8403 -> 8382;
8403 -> 8378;
8404 -> 8377;
8404 -> 6935;
8405 -> 8404;
8405 -> 6932;
8406 -> 6914;
8406 -> 8276;
8406 -> 6913;
8407 -> 6913;
8408 -> 8406;
8408 -> 8407;
8409 -> 8405;
8409 -> 6913;
8410 -> 6913;
8411 -> 6913;
8412 -> 8408;
8412 -> 8411;
8413 -> 8409;
8413 -> 8411;
8414 -> 8410;
8414 -> 8411;
8415 -> 8413;
8415 -> 8411;
8416 -> 8413;
8416 -> 8411;
8417 -> 8412;
8417 -> 0;
8417 -> 8411;
8418 -> 8412;
8418 -> 8411;
8419 -> 8413;
8419 -> 8418;
8420 -> 8418;
8421 -> 8419;
8421 -> 8420;
8422 -> 8420;
8423 -> 8421;
8423 -> 8422;
8424 -> 8422;
8425 -> 8423;
8425 -> 8424;
8426 -> 8425;
8426 -> 8424;
8427 -> 8426;
8427 -> 8422;
8428 -> 8427;
8428 -> 8420;
8429 -> 8420;
8430 -> 8428;
8430 -> 8429;
8431 -> 4365;
8431 -> 8429;
8432 -> 8431;
8432 -> 8420;
8433 -> 8432;
8433 -> 8418;
8434 -> 8419;
8434 -> 8433;
8434 -> 8418;
8435 -> 8413;
8435 -> 8411;
8436 -> 8435;
8436 -> 8411;
8437 -> 8413;
8437 -> 8436;
8438 -> 8436;
8439 -> 8437;
8439 -> 8438;
8440 -> 8438;
8441 -> 8439;
8441 -> 8440;
8442 -> 8440;
8443 -> 8441;
8443 -> 8442;
8444 -> 8443;
8444 -> 8442;
8445 -> 8444;
8445 -> 8440;
8446 -> 8445;
8446 -> 8438;
8447 -> 8438;
8448 -> 8446;
8448 -> 8447;
8449 -> 4365;
8449 -> 8447;
8450 -> 8449;
8450 -> 8438;
8451 -> 8450;
8451 -> 8436;
8452 -> 8412;
8452 -> 0;
8452 -> 8411;
8453 -> 8411;
8454 -> 8451;
8454 -> 8453;
8454 -> 8411;
8455 -> 8411;
8456 -> 8411;
8456 -> 6913;
8457 -> 8456;
8457 -> 5473;
8458 -> 8457;
8458 -> 5473;
8459 -> 8458;
8459 -> 5473;
8460 -> 5473;
8461 -> 5473;
8462 -> 8459;
8462 -> 8461;
8463 -> 8460;
8463 -> 8461;
8464 -> 8461;
8465 -> 8462;
8465 -> 8464;
8466 -> 8465;
8466 -> 8413;
8466 -> 8464;
8467 -> 8466;
8467 -> 8464;
8468 -> 8467;
8468 -> 8461;
8469 -> 8461;
8470 -> 8469;
8470 -> 8463;
8470 -> 8461;
8471 -> 8461;
8472 -> 8471;
8472 -> 8463;
8472 -> 8461;
8473 -> 8460;
8473 -> 5468;
8474 -> 5449;
8475 -> 8473;
8475 -> 8474;
8476 -> 8474;
8477 -> 8462;
8477 -> 8413;
8477 -> 8476;
8478 -> 8477;
8479 -> 8477;
8480 -> 8477;
8481 -> 8478;
8481 -> 8477;
8482 -> 8479;
8482 -> 8477;
8483 -> 8480;
8483 -> 8477;
8484 -> 8481;
8484 -> 8477;
8485 -> 8482;
8485 -> 8477;
8486 -> 8483;
8486 -> 8477;
8487 -> 8477;
8487 -> 8411;
8488 -> 8484;
8488 -> 8477;
8489 -> 8485;
8489 -> 8477;
8490 -> 8486;
8490 -> 8477;
8491 -> 8488;
8491 -> 8477;
8492 -> 8489;
8492 -> 8477;
8493 -> 8490;
8493 -> 8477;
8494 -> 8477;
8494 -> 8411;
8495 -> 8493;
8495 -> 8477;
8496 -> 8492;
8496 -> 8477;
8497 -> 8477;
8498 -> 8491;
8498 -> 8477;
8499 -> 8495;
8499 -> 8477;
8500 -> 8496;
8500 -> 8477;
8501 -> 8497;
8501 -> 8477;
8502 -> 8498;
8502 -> 8477;
8503 -> 8477;
8504 -> 0;
8504 -> 8477;
8505 -> 8477;
8506 -> 5441;
8506 -> 5439;
8507 -> 5440;
8507 -> 5439;
8508 -> 5442;
8508 -> 5439;
8509 -> 5439;
8510 -> 8506;
8510 -> 8509;
8511 -> 8507;
8511 -> 8509;
8512 -> 8508;
8512 -> 8509;
8513 -> 5444;
8513 -> 8509;
8514 -> 8509;
8515 -> 8477;
8515 -> 8514;
8516 -> 8515;
8516 -> 8470;
8516 -> 8514;
8517 -> 8516;
8517 -> 0;
8517 -> 8514;
8518 -> 8517;
8518 -> 8509;
8519 -> 5439;
8520 -> 5434;
8521 -> 8477;
8521 -> 8520;
8522 -> 8520;
8523 -> 8521;
8523 -> 8411;
8523 -> 8522;
8524 -> 5434;
8525 -> 8521;
8525 -> 8524;
8526 -> 4365;
8526 -> 8524;
8527 -> 8526;
8527 -> 5434;
8528 -> 8527;
8528 -> 5434;
8529 -> 5434;
8530 -> 8528;
8530 -> 8529;
8531 -> 8530;
8531 -> 8529;
8532 -> 8529;
8533 -> 8532;
8533 -> 5434;
8534 -> 5434;
8535 -> 8521;
8535 -> 8534;
8536 -> 8534;
8537 -> 8536;
8537 -> 5434;
8538 -> 5434;
8539 -> 5434;
8540 -> 8521;
8540 -> 8539;
8541 -> 0;
8541 -> 8539;
8542 -> 8541;
8542 -> 5434;
8543 -> 5434;
8544 -> 8521;
8544 -> 8543;
8545 -> 0;
8545 -> 8543;
8546 -> 8545;
8546 -> 5434;
8547 -> 5434;
8548 -> 8521;
8548 -> 8547;
8549 -> 0;
8549 -> 8547;
8550 -> 8549;
8550 -> 5434;
8551 -> 8546;
8551 -> 8550;
8551 -> 5434;
8552 -> 5434;
8553 -> 8521;
8553 -> 8552;
8554 -> 0;
8554 -> 8552;
8555 -> 8554;
8555 -> 5434;
8556 -> 8551;
8556 -> 8555;
8556 -> 5434;
8557 -> 8556;
8557 -> 8538;
8557 -> 5434;
8558 -> 5419;
8559 -> 8521;
8559 -> 8558;
8560 -> 0;
8560 -> 8558;
8561 -> 8560;
8561 -> 5419;
8562 -> 4593;
8562 -> 8561;
8563 -> 0;
8563 -> 8561;
8564 -> 5427;
8564 -> 8561;
8565 -> 8561;
8566 -> 8521;
8566 -> 8565;
8566 -> 8561;
8567 -> 8562;
8567 -> 8563;
8567 -> 8564;
8567 -> 8565;
8567 -> 8408;
8567 -> 8566;
8567 -> 8388;
8567 -> 8390;
8567 -> 8400;
8567 -> 8399;
8567 -> 8403;
8567 -> 6675;
8567 -> 6676;
8567 -> 6677;
8567 -> 8369;
8567 -> 8561;
8568 -> 8561;
8569 -> 4594;
8569 -> 8568;
8570 -> 8568;
8571 -> 8569;
8571 -> 8567;
8571 -> 8570;
8572 -> 8571;
8572 -> 8561;
8573 -> 4603;
8573 -> 8561;
8574 -> 4604;
8574 -> 8561;
8575 -> 8573;
8575 -> 8574;
8575 -> 4604;
8575 -> 8561;
8576 -> 4586;
8577 -> 8575;
8577 -> 8576;
8577 -> 4586;
8578 -> 8575;
8578 -> 4586;
8579 -> 8575;
8579 -> 4586;
8580 -> 4565;
8580 -> 4586;
8581 -> 8580;
8582 -> 4575;
8582 -> 8581;
8582 -> 8580;
8583 -> 8578;
8583 -> 8582;
8584 -> 4586;
8584 -> 8567;
8584 -> 8582;
8585 -> 8579;
8585 -> 4586;
8586 -> 4558;
8587 -> 4561;
8587 -> 8567;
8587 -> 0;
8587 -> 4558;
8588 -> 4558;
8589 -> 8583;
8589 -> 8588;
8589 -> 4558;
8590 -> 4574;
8590 -> 4558;
8591 -> 4558;
8592 -> 4561;
8592 -> 8591;
8593 -> 8592;
8593 -> 8567;
8593 -> 8591;
8594 -> 8591;
8595 -> 8593;
8595 -> 4558;
8596 -> 4558;
8597 -> 4561;
8597 -> 8596;
8598 -> 8596;
8599 -> 8597;
8599 -> 8598;
8600 -> 8599;
8600 -> 8567;
8600 -> 8598;
8601 -> 8600;
8601 -> 8596;
8602 -> 8601;
8602 -> 4558;
8603 -> 8595;
8603 -> 8602;
8603 -> 4558;
8604 -> 4585;
8604 -> 4581;
8604 -> 4558;
8605 -> 4560;
8605 -> 4558;
8606 -> 4558;
8607 -> 4561;
8607 -> 8606;
8608 -> 8607;
8608 -> 8567;
8608 -> 8606;
8609 -> 8608;
8609 -> 4558;
8610 -> 4558;
8611 -> 8586;
8611 -> 4558;
8612 -> 8605;
8612 -> 8609;
8612 -> 8611;
8612 -> 4558;
8613 -> 8583;
8613 -> 4558;
8614 -> 8590;
8614 -> 4558;
8615 -> 8613;
8615 -> 8614;
8615 -> 8575;
8615 -> 8590;
8615 -> 4574;
8615 -> 4558;
8616 -> 4552;
8617 -> 4555;
8617 -> 8615;
8617 -> 8616;
8617 -> 8612;
8617 -> 4552;
8618 -> 4554;
8618 -> 8617;
8619 -> 8617;
8620 -> 8618;
8620 -> 8619;
8621 -> 4551;
8621 -> 8619;
8622 -> 8619;
8623 -> 8621;
8623 -> 8622;
8624 -> 8623;
8624 -> 8619;
8625 -> 8620;
8625 -> 8617;
8625 -> 8619;
8626 -> 8625;
8627 -> 8621;
8627 -> 8626;
8628 -> 8626;
8629 -> 8627;
8629 -> 8628;
8630 -> 8628;
8630 -> 8626;
8631 -> 8627;
8631 -> 8625;
8632 -> 8625;
8633 -> 8631;
8633 -> 8632;
8633 -> 8625;
8634 -> 8625;
8635 -> 8631;
8635 -> 8634;
8636 -> 8635;
8636 -> 8617;
8636 -> 8634;
8637 -> 8635;
8637 -> 8625;
8638 -> 8620;
8638 -> 8625;
8639 -> 8617;
8640 -> 4554;
8640 -> 8637;
8640 -> 4552;
8641 -> 4551;
8641 -> 8640;
8641 -> 4549;
8642 -> 4516;
8643 -> 8641;
8643 -> 8642;
8643 -> 4516;
8644 -> 4526;
8644 -> 8643;
8645 -> 8644;
8646 -> 8645;
8646 -> 8644;
8647 -> 0;
8647 -> 8644;
8648 -> 8644;
8649 -> 8647;
8649 -> 8648;
8650 -> 4541;
8650 -> 8648;
8651 -> 8649;
8651 -> 4365;
8651 -> 8648;
8652 -> 8649;
8652 -> 0;
8652 -> 8648;
8653 -> 8648;
8654 -> 8649;
8654 -> 8648;
8655 -> 8650;
8655 -> 8654;
8655 -> 8640;
8655 -> 8648;
8656 -> 8655;
8657 -> 8656;
8658 -> 8656;
8658 -> 8655;
8659 -> 8649;
8659 -> 8655;
8660 -> 8655;
8661 -> 8659;
8661 -> 8660;
8662 -> 8658;
8662 -> 8660;
8663 -> 8660;
8664 -> 8662;
8664 -> 8663;
8665 -> 8664;
8665 -> 8660;
8666 -> 8665;
8667 -> 8665;
8667 -> 8666;
8668 -> 8666;
8669 -> 8667;
8669 -> 8668;
8670 -> 8668;
8671 -> 8669;
8671 -> 8656;
8671 -> 8670;
8671 -> 8668;
8672 -> 8666;
8673 -> 8667;
8673 -> 8656;
8673 -> 8666;
8674 -> 8673;
8674 -> 8665;
8675 -> 8665;
8676 -> 8648;
8677 -> 8662;
8677 -> 8676;
8678 -> 8677;
8678 -> 8648;
8679 -> 8662;
8679 -> 8648;
8680 -> 8679;
8680 -> 4516;
8681 -> 4518;
8681 -> 4516;
8682 -> 4516;
8683 -> 8680;
8683 -> 8682;
8684 -> 8681;
8684 -> 8682;
8685 -> 8682;
8686 -> 8683;
8686 -> 8685;
8686 -> 8682;
8687 -> 8682;
8688 -> 8684;
8688 -> 8687;
8688 -> 8682;
8689 -> 8682;
8690 -> 8684;
8690 -> 8689;
8691 -> 8689;
8692 -> 8690;
8692 -> 8691;
8693 -> 8691;
8694 -> 8692;
8694 -> 8693;
8695 -> 8693;
8696 -> 8694;
8696 -> 8695;
8697 -> 8695;
8698 -> 8696;
8698 -> 8697;
8699 -> 8698;
8699 -> 8697;
8700 -> 8699;
8700 -> 8695;
8701 -> 8700;
8701 -> 8693;
8702 -> 8701;
8702 -> 8691;
8703 -> 8702;
8703 -> 8689;
8704 -> 8703;
8704 -> 8682;
8705 -> 8682;
8706 -> 8683;
8706 -> 8682;
8707 -> 8682;
8708 -> 8683;
8708 -> 8707;
8709 -> 8707;
8710 -> 8709;
8710 -> 8682;
8711 -> 8705;
8711 -> 8682;
8712 -> 8682;
8713 -> 8706;
8713 -> 8712;
8714 -> 8710;
8714 -> 8712;
8715 -> 8711;
8715 -> 8712;
8716 -> 8712;
8717 -> 8713;
8717 -> 8716;
8717 -> 8712;
8718 -> 8712;
8719 -> 8713;
8719 -> 8718;
8720 -> 8719;
8720 -> 8712;
8721 -> 8720;
8721 -> 8712;
8722 -> 8721;
8722 -> 8715;
8722 -> 8656;
8722 -> 8705;
8722 -> 8712;
8723 -> 8712;
8724 -> 8722;
8724 -> 8723;
8725 -> 8723;
8726 -> 8724;
8726 -> 8725;
8727 -> 8726;
8727 -> 8723;
8728 -> 0;
8728 -> 8727;
8729 -> 8728;
8730 -> 8720;
8730 -> 8729;
8731 -> 8730;
8731 -> 8728;
8731 -> 8729;
8732 -> 8731;
8732 -> 8728;
8733 -> 8732;
8734 -> 8732;
8735 -> 8733;
8735 -> 8734;
8736 -> 8720;
8736 -> 8734;
8737 -> 8734;
8738 -> 8734;
8739 -> 8737;
8739 -> 8738;
8740 -> 8736;
8740 -> 8738;
8741 -> 8740;
8741 -> 8728;
8741 -> 8738;
8742 -> 2648;
8742 -> 8738;
8743 -> 8741;
8744 -> 8740;
8744 -> 8743;
8745 -> 8744;
8745 -> 8728;
8745 -> 8743;
8746 -> 8745;
8747 -> 8746;
8748 -> 8746;
8748 -> 8747;
8749 -> 8747;
8749 -> 8746;
8750 -> 8746;
8750 -> 8745;
8751 -> 8745;
8752 -> 8750;
8752 -> 8751;
8753 -> 8752;
8753 -> 8745;
8754 -> 8744;
8754 -> 8728;
8754 -> 8745;
8755 -> 8753;
8755 -> 8745;
8756 -> 8743;
8757 -> 8756;
8757 -> 8741;
8758 -> 8757;
8758 -> 8741;
8759 -> 8740;
8759 -> 8753;
8759 -> 8741;
8760 -> 8757;
8760 -> 8741;
8761 -> 2648;
8761 -> 8741;
8762 -> 8759;
8762 -> 8760;
8762 -> 8761;
8762 -> 8753;
8762 -> 8741;
8763 -> 8740;
8763 -> 8762;
8763 -> 8738;
8764 -> 8763;
8764 -> 8734;
8765 -> 8764;
8765 -> 8732;
8766 -> 8714;
8766 -> 8732;
8767 -> 8715;
8767 -> 8732;
8768 -> 8732;
8769 -> 8765;
8769 -> 8768;
8770 -> 8766;
8770 -> 8768;
8771 -> 8767;
8771 -> 8768;
8772 -> 8768;
8773 -> 8769;
8773 -> 8772;
8773 -> 8768;
8774 -> 8773;
8775 -> 8728;
8776 -> 8714;
8776 -> 8775;
8776 -> 8728;
8777 -> 8682;
8778 -> 8684;
8778 -> 8682;
8779 -> 8778;
8779 -> 8705;
8779 -> 8762;
8779 -> 8682;
8780 -> 8682;
8781 -> 8780;
8782 -> 8781;
8783 -> 8780;
8784 -> 8779;
8784 -> 8783;
8785 -> 8784;
8785 -> 8780;
8786 -> 8705;
8786 -> 8785;
8786 -> 8682;
8787 -> 8785;
8787 -> 8682;
8788 -> 4516;
8789 -> 4518;
8789 -> 8788;
8790 -> 8788;
8791 -> 8790;
8791 -> 8789;
8791 -> 8788;
8792 -> 4516;
8793 -> 4516;
8794 -> 8679;
8794 -> 4516;
8795 -> 4516;
8796 -> 8794;
8796 -> 8795;
8797 -> 8795;
8798 -> 8797;
8798 -> 4516;
8799 -> 4516;
8800 -> 4518;
8800 -> 8799;
8801 -> 8799;
8802 -> 8800;
8802 -> 8801;
8803 -> 8801;
8803 -> 8799;
8804 -> 8800;
8804 -> 8799;
8805 -> 8799;
8806 -> 8804;
8806 -> 8805;
8807 -> 8806;
8807 -> 8786;
8807 -> 8805;
8808 -> 8799;
8809 -> 8807;
8809 -> 4516;
8810 -> 8798;
8810 -> 8809;
8810 -> 4516;
8811 -> 8794;
8811 -> 4516;
8812 -> 8793;
8812 -> 4516;
8813 -> 4516;
8814 -> 8811;
8814 -> 8813;
8815 -> 8812;
8815 -> 8813;
8816 -> 8813;
8817 -> 8814;
8817 -> 8816;
8818 -> 8817;
8818 -> 8786;
8818 -> 8816;
8819 -> 0;
8819 -> 8816;
8820 -> 8818;
8821 -> 8817;
8821 -> 8820;
8822 -> 8820;
8823 -> 8822;
8823 -> 8820;
8824 -> 8820;
8825 -> 8821;
8825 -> 8824;
8826 -> 8824;
8827 -> 8826;
8827 -> 8824;
8828 -> 8824;
8829 -> 8825;
8829 -> 8828;
8830 -> 8828;
8831 -> 8829;
8831 -> 8830;
8832 -> 8831;
8832 -> 8786;
8832 -> 8830;
8833 -> 2648;
8833 -> 8830;
8834 -> 8831;
8834 -> 8786;
8834 -> 8832;
8835 -> 8832;
8836 -> 8831;
8836 -> 8835;
8837 -> 8835;
8838 -> 8835;
8839 -> 8837;
8839 -> 8838;
8840 -> 8836;
8840 -> 8838;
8841 -> 8838;
8842 -> 8841;
8842 -> 8838;
8843 -> 8840;
8843 -> 8786;
8843 -> 8838;
8844 -> 8843;
8844 -> 8838;
8845 -> 8844;
8845 -> 8835;
8846 -> 8835;
8847 -> 8845;
8847 -> 8846;
8847 -> 8835;
8848 -> 8847;
8849 -> 8848;
8849 -> 8832;
8850 -> 2648;
8850 -> 8832;
8851 -> 8834;
8851 -> 8849;
8851 -> 8850;
8851 -> 8786;
8851 -> 8791;
8851 -> 8832;
8852 -> 8831;
8852 -> 8851;
8852 -> 8830;
8853 -> 8852;
8853 -> 8828;
8854 -> 8828;
8855 -> 8853;
8855 -> 8854;
8855 -> 8828;
8856 -> 8828;
8857 -> 8856;
8857 -> 8824;
8858 -> 8824;
8859 -> 8827;
8859 -> 8858;
8860 -> 8857;
8860 -> 8858;
8861 -> 8825;
8861 -> 8858;
8862 -> 8858;
8863 -> 8860;
8863 -> 8862;
8863 -> 8858;
8864 -> 8863;
8865 -> 8824;
8866 -> 8825;
8866 -> 8865;
8867 -> 8865;
8868 -> 8866;
8868 -> 8867;
8869 -> 8868;
8869 -> 8851;
8869 -> 8867;
8870 -> 8867;
8871 -> 8869;
8871 -> 8870;
8872 -> 8870;
8872 -> 8867;
8873 -> 8869;
8873 -> 8865;
8874 -> 8873;
8874 -> 8824;
8875 -> 8824;
8876 -> 8874;
8876 -> 8875;
8877 -> 8875;
8878 -> 8876;
8878 -> 8877;
8879 -> 8877;
8880 -> 8878;
8880 -> 8879;
8881 -> 8879;
8882 -> 8880;
8882 -> 8851;
8882 -> 8881;
8882 -> 8879;
8883 -> 8877;
8884 -> 8878;
8884 -> 8875;
8885 -> 8875;
8886 -> 8859;
8886 -> 8824;
8887 -> 8886;
8887 -> 8820;
8888 -> 8820;
8889 -> 8823;
8889 -> 8888;
8890 -> 8887;
8890 -> 8888;
8891 -> 8821;
8891 -> 8888;
8892 -> 8888;
8893 -> 8890;
8893 -> 8892;
8893 -> 8888;
8894 -> 8893;
8895 -> 8894;
8896 -> 8821;
8896 -> 8895;
8897 -> 8896;
8897 -> 8851;
8897 -> 8895;
8898 -> 8895;
8899 -> 8897;
8899 -> 8898;
8900 -> 8898;
8900 -> 8895;
8901 -> 8897;
8901 -> 8894;
8902 -> 8894;
8903 -> 8901;
8903 -> 8902;
8904 -> 8821;
8904 -> 8851;
8904 -> 8894;
8905 -> 8903;
8906 -> 8821;
8906 -> 8905;
8907 -> 8906;
8907 -> 8903;
8907 -> 8905;
8908 -> 8907;
8908 -> 0;
8908 -> 8905;
8909 -> 8906;
8909 -> 8903;
8909 -> 8908;
8910 -> 8909;
8911 -> 8909;
8912 -> 8910;
8912 -> 8911;
8913 -> 8911;
8913 -> 8909;
8914 -> 0;
8914 -> 8909;
8915 -> 8909;
8916 -> 8913;
8916 -> 8915;
8916 -> 8909;
8917 -> 8914;
8917 -> 8906;
8917 -> 8908;
8918 -> 8914;
8918 -> 8905;
8919 -> 8918;
8919 -> 8903;
8920 -> 8903;
8921 -> 8920;
8921 -> 8903;
8922 -> 8919;
8922 -> 8921;
8922 -> 8903;
8923 -> 8922;
8924 -> 8922;
8925 -> 8923;
8925 -> 8924;
8926 -> 8924;
8927 -> 8924;
8927 -> 8922;
8928 -> 8927;
8928 -> 8922;
8929 -> 8889;
8929 -> 8820;
8930 -> 8929;
8930 -> 8818;
8931 -> 8930;
8931 -> 8817;
8931 -> 8818;
8932 -> 8817;
8932 -> 8903;
8932 -> 8931;
8932 -> 8816;
8933 -> 8932;
8933 -> 8813;
8934 -> 8813;
8935 -> 8933;
8935 -> 8934;
8935 -> 8813;
8936 -> 4516;
8937 -> 4516;
8938 -> 8794;
8938 -> 8937;
8939 -> 8938;
8939 -> 8903;
8939 -> 8937;
8940 -> 2648;
8940 -> 8937;
8941 -> 8938;
8941 -> 8903;
8941 -> 8937;
8942 -> 8941;
8942 -> 4516;
8943 -> 4516;
8944 -> 8942;
8944 -> 8943;
8944 -> 4516;
8945 -> 8815;
8945 -> 4516;
8946 -> 8679;
8946 -> 4516;
8947 -> 8946;
8947 -> 4507;
8948 -> 4506;
8948 -> 8903;
8948 -> 4507;
8949 -> 8947;
8949 -> 4507;
8950 -> 2648;
8950 -> 4507;
8951 -> 8948;
8951 -> 8949;
8951 -> 8950;
8951 -> 8903;
8951 -> 8917;
8951 -> 8931;
8951 -> 4507;
8952 -> 4514;
8952 -> 8951;
8953 -> 8951;
8954 -> 8952;
8954 -> 8953;
8955 -> 8953;
8956 -> 8955;
8956 -> 8953;
8957 -> 8951;
8958 -> 4514;
8958 -> 4507;
8959 -> 4506;
8959 -> 8951;
8959 -> 4505;
8960 -> 8959;
8960 -> 4503;
8961 -> 1;
8962 -> 1;
8963 -> 8960;
8963 -> 8962;
8964 -> 8963;
8964 -> 1;
}