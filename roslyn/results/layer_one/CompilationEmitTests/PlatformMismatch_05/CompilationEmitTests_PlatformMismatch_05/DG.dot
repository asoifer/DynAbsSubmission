digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 820630"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 820631"];
3 [label="param CompilationEmitTests(this) 820632"];
4 [label="param EmitMetadataTestBase(this) 820633"];
5 [label="param CSharpTestBase(this) 820634"];
6 [label="param CommonTestBase(this) 820635"];
7 [label="param TestBase(this) 820636"];
8 [label="_temp 820637"];
9 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 820638"];
10 [label="param PlatformMismatch_05(this) 820639"];
11 [label="var emitOptions = new EmitOptions(runtimeMetadataVersion: 'v1234'); 820640"];
12 [label="string refSource = @'\npublic interface ITestPlatform\n{}\n'; 820641"];
13 [label="var refCompilation = CreateEmptyCompilation(refSource, options: TestOptions.ReleaseDll.WithPlatform(Platform.AnyCpu), assemblyName: 'PlatformMismatch'); 820642"];
14 [label="var refCompilation = CreateEmptyCompilation(refSource, options: TestOptions.ReleaseDll.WithPlatform(Platform.AnyCpu), assemblyName: 'PlatformMismatch'); 820643"];
15 [label="var refCompilation = CreateEmptyCompilation(refSource, options: TestOptions.ReleaseDll.WithPlatform(Platform.AnyCpu), assemblyName: 'PlatformMismatch'); 820644"];
16 [label="param operator(string source) 820645"];
17 [label="source 820646"];
18 [label="new CSharpTestSource(source) 820647"];
19 [label="param CSharpTestSource(object value) 820648"];
20 [label="param CSharpTestSource(this) 820649"];
21 [label="Value 820650"];
22 [label="param CreateEmptyCompilation(CSharpTestSource source) 820651"];
23 [label="param CreateEmptyCompilation(IEnumerable<MetadataReference> references = null) 820652"];
24 [label="param CreateEmptyCompilation(CSharpCompilationOptions options = null) 820653"];
25 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 820654"];
26 [label="param CreateEmptyCompilation(string assemblyName = '') 820655"];
27 [label="param CreateEmptyCompilation(string sourceFileName = '') 820656"];
28 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 820657"];
29 [label="=> CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 820658"];
30 [label="source 820659"];
31 [label="references 820660"];
32 [label="options 820661"];
33 [label="parseOptions 820662"];
34 [label="assemblyName 820663"];
35 [label="sourceFileName 820664"];
36 [label="skipUsesIsNullable 820665"];
37 [label="null 820666"];
38 [label="experimentalFeature: null 820667"];
39 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 820668"];
40 [label="param CreateCompilationCore(CSharpTestSource source) 820669"];
41 [label="param CreateCompilationCore(IEnumerable<MetadataReference> references) 820670"];
42 [label="param CreateCompilationCore(CSharpCompilationOptions options) 820671"];
43 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 820672"];
44 [label="param CreateCompilationCore(string assemblyName) 820673"];
45 [label="param CreateCompilationCore(string sourceFileName) 820674"];
46 [label="param CreateCompilationCore(bool skipUsesIsNullable) 820675"];
47 [label="param CreateCompilationCore(MessageID? experimentalFeature) 820676"];
48 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 820677"];
49 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 820678"];
50 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 820679"];
51 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 820680"];
52 [label="param GetSyntaxTrees(string sourceFileName = '') 820681"];
53 [label="param GetSyntaxTrees(this) 820682"];
54 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 820683"];
55 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 820684"];
56 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 820685"];
57 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 820686"];
58 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 820687"];
59 [label="param Parse(string text) 820688"];
60 [label="param Parse(string filename = '') 820689"];
61 [label="param Parse(CSharpParseOptions options = null) 820690"];
62 [label="param Parse(Encoding encoding = null) 820691"];
63 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 820692"];
64 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 820693"];
65 [label="options = TestOptions.Regular; 820694"];
66 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 820695"];
67 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 820696"];
68 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 820697"];
69 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 820698"];
70 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 820699"];
71 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 820700"];
72 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 820701"];
73 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 820702"];
74 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 820703"];
75 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 820704"];
76 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 820705"];
77 [label="param CheckSerializable(SyntaxTree tree) 820706"];
78 [label="var stream = new MemoryStream(); 820707"];
79 [label="var root = tree.GetRoot(); 820708"];
80 [label="var root = tree.GetRoot(); 820709"];
81 [label="root.SerializeTo(stream); 820710"];
82 [label="root.SerializeTo(stream); 820711"];
83 [label="root.SerializeTo(stream); 820712"];
84 [label="stream.Position = 0; 820713"];
85 [label="stream.Position 820714"];
86 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 820715"];
87 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 820716"];
88 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 820717"];
89 [label="return tree; 820718"];
90 [label="new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) } 820719"];
91 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 820720"];
92 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 820721"];
93 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 820722"];
94 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 820723"];
95 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 820724"];
96 [label="Func<CSharpCompilation> createCompilationLambda = () => CSharpCompilation.Create(\n                assemblyName == '' ? GetUniqueName() : assemblyName,\n                syntaxTrees,\n                references,\n                options); 820725"];
97 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 820726"];
98 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 820727"];
99 [label="param ValidateIOperations(Func<Compilation> createCompilation) 820728"];
100 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 820729"];
101 [label="return; 820730"];
102 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 820731"];
103 [label="OutputKind.ConsoleApplication 820732"];
104 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 820733"];
105 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 820734"];
106 [label="s_defaultOptions = new CSharpCompilationOptions(OutputKind.ConsoleApplication) 820735"];
107 [label="OutputKind.DynamicallyLinkedLibrary 820736"];
108 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 820737"];
109 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 820738"];
110 [label="true 820739"];
111 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 820740"];
112 [label="s_defaultSubmissionOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 820741"];
113 [label="var compilation = createCompilationLambda(); 820742"];
114 [label="var compilation = createCompilationLambda(); 820743"];
115 [label="param Create(string? assemblyName) 820744"];
116 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees = null) 820745"];
117 [label="param Create(IEnumerable<MetadataReference>? references = null) 820746"];
118 [label="param Create(CSharpCompilationOptions? options = null) 820747"];
119 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 820748"];
120 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 820749"];
121 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 820750"];
122 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 820751"];
123 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 820752"];
124 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 820753"];
125 [label="param Create(string? assemblyName) 820754"];
126 [label="param Create(CSharpCompilationOptions options) 820755"];
127 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees) 820756"];
128 [label="param Create(IEnumerable<MetadataReference>? references) 820757"];
129 [label="param Create(CSharpCompilation? previousSubmission) 820758"];
130 [label="param Create(Type? returnType) 820759"];
131 [label="param Create(Type? hostObjectType) 820760"];
132 [label="param Create(bool isSubmission) 820761"];
133 [label="RoslynDebug.Assert(options != null); 820762"];
134 [label="RoslynDebug.Assert(options != null); 820763"];
135 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 820764"];
136 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 820765"];
137 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 820766"];
138 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 820767"];
139 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 820768"];
140 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 820769"];
141 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 820770"];
142 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 820771"];
143 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 820772"];
144 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 820773"];
145 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 820774"];
146 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 820775"];
147 [label="new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null) 820776"];
148 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 820777"];
149 [label="param SyntaxAndDeclarationManager(string scriptClassName) 820778"];
150 [label="param SyntaxAndDeclarationManager(SourceReferenceResolver resolver) 820779"];
151 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 820780"];
152 [label="param SyntaxAndDeclarationManager(bool isSubmission) 820781"];
153 [label="param SyntaxAndDeclarationManager(State state) 820782"];
154 [label="param SyntaxAndDeclarationManager(this) 820783"];
155 [label="externalSyntaxTrees 820784"];
156 [label="scriptClassName 820785"];
157 [label="resolver 820786"];
158 [label="messageProvider 820787"];
159 [label="isSubmission 820788"];
160 [label="param SyntaxAndDeclarationManager(this) 820789"];
161 [label="param SyntaxAndDeclarationManager(this) 820790"];
162 [label="_lazyState 820791"];
163 [label="_lazyState 820792"];
164 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 820793"];
165 [label="param CSharpCompilation(string? assemblyName) 820794"];
166 [label="param CSharpCompilation(CSharpCompilationOptions options) 820795"];
167 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 820796"];
168 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 820797"];
169 [label="param CSharpCompilation(Type? submissionReturnType) 820798"];
170 [label="param CSharpCompilation(Type? hostObjectType) 820799"];
171 [label="param CSharpCompilation(bool isSubmission) 820800"];
172 [label="param CSharpCompilation(ReferenceManager? referenceManager) 820801"];
173 [label="param CSharpCompilation(bool reuseReferenceManager) 820802"];
174 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 820803"];
175 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 820804"];
176 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 820805"];
177 [label="param CSharpCompilation(this) 820806"];
178 [label="assemblyName 820807"];
179 [label="options 820808"];
180 [label="references 820809"];
181 [label="previousSubmission 820810"];
182 [label="submissionReturnType 820811"];
183 [label="hostObjectType 820812"];
184 [label="isSubmission 820813"];
185 [label="referenceManager 820814"];
186 [label="reuseReferenceManager 820815"];
187 [label="syntaxAndDeclarations 820816"];
188 [label="syntaxAndDeclarations.ExternalSyntaxTrees 820817"];
189 [label="SyntaxTreeCommonFeatures(syntaxAndDeclarations.ExternalSyntaxTrees) 820818"];
190 [label="semanticModelProvider 820819"];
191 [label="eventQueue 820820"];
192 [label="param CSharpCompilation(this) 820821"];
193 [label="param CSharpCompilation(string? assemblyName) 820822"];
194 [label="param CSharpCompilation(CSharpCompilationOptions options) 820823"];
195 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 820824"];
196 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 820825"];
197 [label="param CSharpCompilation(Type? submissionReturnType) 820826"];
198 [label="param CSharpCompilation(Type? hostObjectType) 820827"];
199 [label="param CSharpCompilation(bool isSubmission) 820828"];
200 [label="param CSharpCompilation(ReferenceManager? referenceManager) 820829"];
201 [label="param CSharpCompilation(bool reuseReferenceManager) 820830"];
202 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 820831"];
203 [label="param CSharpCompilation(IReadOnlyDictionary<string, string> features) 820832"];
204 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 820833"];
205 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 820834"];
206 [label="param CSharpCompilation(this) 820835"];
207 [label="assemblyName 820836"];
208 [label="references 820837"];
209 [label="features 820838"];
210 [label="isSubmission 820839"];
211 [label="semanticModelProvider 820840"];
212 [label="eventQueue 820841"];
213 [label="param CSharpCompilation(this) 820842"];
214 [label="param CSharpCompilation(this) 820843"];
215 [label="_options 820844"];
216 [label="_globalImports 820845"];
217 [label="_previousSubmissionImports 820846"];
218 [label="_globalNamespaceAlias 820847"];
219 [label="_scriptClass 820848"];
220 [label="_lazyHostObjectTypeSymbol 820849"];
221 [label="_lazyImportInfos 820850"];
222 [label="_conversions 820851"];
223 [label="_anonymousTypeManager 820852"];
224 [label="_lazyGlobalNamespace 820853"];
225 [label="builtInOperators 820854"];
226 [label="_lazyAssemblySymbol 820855"];
227 [label="_referenceManager 820856"];
228 [label="_syntaxAndDeclarations 820857"];
229 [label="_lazyEntryPoint 820858"];
230 [label="_lazyEmitNullablePublicOnly 820859"];
231 [label="_lazyCompilationUnitCompletedTrees 820860"];
232 [label="NullableAnalysisData 820861"];
233 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 820862"];
234 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 820863"];
235 [label="_externAliasTargets 820864"];
236 [label="_moduleInitializerMethods 820865"];
237 [label="_binderFactories 820866"];
238 [label="_ignoreAccessibilityBinderFactories 820867"];
239 [label="_lazyDeclarationDiagnostics 820868"];
240 [label="_declarationDiagnosticsFrozen 820869"];
241 [label="new DiagnosticBag() 820870"];
242 [label="_additionalCodegenWarnings = new DiagnosticBag() 820871"];
243 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 820872"];
244 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 820873"];
245 [label="WellKnownMemberSignatureComparer 820874"];
246 [label="_options 820875"];
247 [label="this.builtInOperators = new BuiltInOperators(this); 820876"];
248 [label="this.builtInOperators = new BuiltInOperators(this); 820877"];
249 [label="new BuiltInOperators(this) 820878"];
250 [label="param BuiltInOperators(CSharpCompilation compilation) 820879"];
251 [label="param BuiltInOperators(this) 820880"];
252 [label="_compilation 820881"];
253 [label="_builtInUnaryOperators 820882"];
254 [label="_builtInOperators 820883"];
255 [label="_compilation 820884"];
256 [label="this.builtInOperators 820885"];
257 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 820886"];
258 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 820887"];
259 [label="_scriptClass 820888"];
260 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 820889"];
261 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 820890"];
262 [label="_globalImports 820891"];
263 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 820892"];
264 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 820893"];
265 [label="_previousSubmissionImports 820894"];
266 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 820895"];
267 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 820896"];
268 [label="_globalNamespaceAlias 820897"];
269 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 820898"];
270 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 820899"];
271 [label="_anonymousTypeManager 820900"];
272 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 820901"];
273 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 820902"];
274 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 820903"];
275 [label="LanguageVersion? result = null; 820904"];
276 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 820905"];
277 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 820906"];
278 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 820907"];
279 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 820908"];
280 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 820909"];
281 [label="this.LanguageVersion 820910"];
282 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 820911"];
283 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 820912"];
284 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 820913"];
285 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 820914"];
286 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 820915"];
287 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 820916"];
288 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 820917"];
289 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 820918"];
290 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 820919"];
291 [label="this.Options 820920"];
292 [label="get\n            {\n                return _options;\n            } 820921"];
293 [label="return _options; 820922"];
294 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 820923"];
295 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 820924"];
296 [label="_referenceManager 820925"];
297 [label="_syntaxAndDeclarations 820926"];
298 [label="Debug.Assert(_lazyAssemblySymbol is null); 820927"];
299 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 820928"];
300 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 820929"];
301 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 820930"];
302 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 820931"];
303 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 820932"];
304 [label="compilation.AddSyntaxTrees(syntaxTrees) 820933"];
305 [label="param AddSyntaxTrees(IEnumerable<SyntaxTree> trees) 820934"];
306 [label="param AddSyntaxTrees(this) 820935"];
307 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 820936"];
308 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 820937"];
309 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 820938"];
310 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 820939"];
311 [label="var externalSyntaxTrees = PooledHashSet<SyntaxTree>.GetInstance(); 820940"];
312 [label="var syntaxAndDeclarations = _syntaxAndDeclarations; 820941"];
313 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 820942"];
314 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 820943"];
315 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 820944"];
316 [label="bool reuseReferenceManager = true; 820945"];
317 [label="int i = 0; 820946"];
318 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 820947"];
319 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 820948"];
320 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 820949"];
321 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 820950"];
322 [label="if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                } 820951"];
323 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 820952"];
324 [label="externalSyntaxTrees.Add(tree); 820953"];
325 [label="externalSyntaxTrees.Add(tree); 820954"];
326 [label="reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives; 820955"];
327 [label="i++; 820956"];
328 [label="externalSyntaxTrees.Free(); 820957"];
329 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 820958"];
330 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 820959"];
331 [label="syntaxAndDeclarations.AddSyntaxTrees(trees) 820960"];
332 [label="param AddSyntaxTrees(IEnumerable<SyntaxTree> trees) 820961"];
333 [label="param AddSyntaxTrees(this) 820962"];
334 [label="var scriptClassName = this.ScriptClassName; 820963"];
335 [label="var resolver = this.Resolver; 820964"];
336 [label="var messageProvider = this.MessageProvider; 820965"];
337 [label="var isSubmission = this.IsSubmission; 820966"];
338 [label="var state = _lazyState; 820967"];
339 [label="var newExternalSyntaxTrees = this.ExternalSyntaxTrees.AddRange(trees); 820968"];
340 [label="var newExternalSyntaxTrees = this.ExternalSyntaxTrees.AddRange(trees); 820969"];
341 [label="if (state == null)\n            {\n                return this.WithExternalSyntaxTrees(newExternalSyntaxTrees);\n            } 820970"];
342 [label="if (state == null)\n            {\n                return this.WithExternalSyntaxTrees(newExternalSyntaxTrees);\n            } 820971"];
343 [label="return this.WithExternalSyntaxTrees(newExternalSyntaxTrees); 820972"];
344 [label="this.WithExternalSyntaxTrees(newExternalSyntaxTrees) 820973"];
345 [label="param WithExternalSyntaxTrees(ImmutableArray<SyntaxTree> trees) 820974"];
346 [label="param WithExternalSyntaxTrees(this) 820975"];
347 [label="return new SyntaxAndDeclarationManager(trees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission, state: null); 820976"];
348 [label="return new SyntaxAndDeclarationManager(trees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission, state: null); 820977"];
349 [label="return new SyntaxAndDeclarationManager(trees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission, state: null); 820978"];
350 [label="new SyntaxAndDeclarationManager(trees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission, state: null) 820979"];
351 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 820980"];
352 [label="param SyntaxAndDeclarationManager(string scriptClassName) 820981"];
353 [label="param SyntaxAndDeclarationManager(SourceReferenceResolver resolver) 820982"];
354 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 820983"];
355 [label="param SyntaxAndDeclarationManager(bool isSubmission) 820984"];
356 [label="param SyntaxAndDeclarationManager(State state) 820985"];
357 [label="param SyntaxAndDeclarationManager(this) 820986"];
358 [label="param SyntaxAndDeclarationManager(this) 820987"];
359 [label="return this.WithExternalSyntaxTrees(newExternalSyntaxTrees); 820988"];
360 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 820989"];
361 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 820990"];
362 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 820991"];
363 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 820992"];
364 [label="Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations) 820993"];
365 [label="param Update(ReferenceManager referenceManager) 820994"];
366 [label="param Update(bool reuseReferenceManager) 820995"];
367 [label="param Update(SyntaxAndDeclarationManager syntaxAndDeclarations) 820996"];
368 [label="param Update(this) 820997"];
369 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 820998"];
370 [label="this.PreviousSubmission 820999"];
371 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 821000"];
372 [label="ScriptCompilationInfo 821001"];
373 [label="ScriptCompilationInfo?.PreviousScriptCompilation 821002"];
374 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 821003"];
375 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 821004"];
376 [label="this.SubmissionReturnType 821005"];
377 [label="=> ScriptCompilationInfo 821006"];
378 [label="ScriptCompilationInfo 821007"];
379 [label="this.HostObjectType 821008"];
380 [label="=> ScriptCompilationInfo 821009"];
381 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 821010"];
382 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 821011"];
383 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 821012"];
384 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 821013"];
385 [label="new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider) 821014"];
386 [label="param CSharpCompilation(string? assemblyName) 821015"];
387 [label="param CSharpCompilation(CSharpCompilationOptions options) 821016"];
388 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 821017"];
389 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 821018"];
390 [label="param CSharpCompilation(Type? submissionReturnType) 821019"];
391 [label="param CSharpCompilation(Type? hostObjectType) 821020"];
392 [label="param CSharpCompilation(bool isSubmission) 821021"];
393 [label="param CSharpCompilation(ReferenceManager? referenceManager) 821022"];
394 [label="param CSharpCompilation(bool reuseReferenceManager) 821023"];
395 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 821024"];
396 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 821025"];
397 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 821026"];
398 [label="param CSharpCompilation(this) 821027"];
399 [label="previousSubmission 821028"];
400 [label="submissionReturnType 821029"];
401 [label="hostObjectType 821030"];
402 [label="syntaxAndDeclarations.ExternalSyntaxTrees 821031"];
403 [label="eventQueue 821032"];
404 [label="param CSharpCompilation(this) 821033"];
405 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 821034"];
406 [label="param CSharpCompilation(Type? submissionReturnType) 821035"];
407 [label="param CSharpCompilation(Type? hostObjectType) 821036"];
408 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 821037"];
409 [label="param CSharpCompilation(this) 821038"];
410 [label="eventQueue 821039"];
411 [label="param CSharpCompilation(this) 821040"];
412 [label="_options 821041"];
413 [label="_globalImports 821042"];
414 [label="_previousSubmissionImports 821043"];
415 [label="_globalNamespaceAlias 821044"];
416 [label="_scriptClass 821045"];
417 [label="_lazyHostObjectTypeSymbol 821046"];
418 [label="_lazyImportInfos 821047"];
419 [label="_conversions 821048"];
420 [label="_anonymousTypeManager 821049"];
421 [label="_lazyGlobalNamespace 821050"];
422 [label="builtInOperators 821051"];
423 [label="_lazyAssemblySymbol 821052"];
424 [label="_referenceManager 821053"];
425 [label="_syntaxAndDeclarations 821054"];
426 [label="_lazyEntryPoint 821055"];
427 [label="_lazyEmitNullablePublicOnly 821056"];
428 [label="_lazyCompilationUnitCompletedTrees 821057"];
429 [label="NullableAnalysisData 821058"];
430 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 821059"];
431 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 821060"];
432 [label="_externAliasTargets 821061"];
433 [label="_moduleInitializerMethods 821062"];
434 [label="_binderFactories 821063"];
435 [label="_ignoreAccessibilityBinderFactories 821064"];
436 [label="_lazyDeclarationDiagnostics 821065"];
437 [label="_declarationDiagnosticsFrozen 821066"];
438 [label="new DiagnosticBag() 821067"];
439 [label="_additionalCodegenWarnings = new DiagnosticBag() 821068"];
440 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 821069"];
441 [label="this.builtInOperators = new BuiltInOperators(this); 821070"];
442 [label="this.builtInOperators = new BuiltInOperators(this); 821071"];
443 [label="new BuiltInOperators(this) 821072"];
444 [label="param BuiltInOperators(CSharpCompilation compilation) 821073"];
445 [label="param BuiltInOperators(this) 821074"];
446 [label="_compilation 821075"];
447 [label="_builtInUnaryOperators 821076"];
448 [label="_builtInOperators 821077"];
449 [label="_compilation 821078"];
450 [label="this.builtInOperators 821079"];
451 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 821080"];
452 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 821081"];
453 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 821082"];
454 [label="LanguageVersion? result = null; 821083"];
455 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 821084"];
456 [label="var version = ((CSharpParseOptions)tree.Options).LanguageVersion; 821085"];
457 [label="if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                } 821086"];
458 [label="result = version; 821087"];
459 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 821088"];
460 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 821089"];
461 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 821090"];
462 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 821091"];
463 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 821092"];
464 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 821093"];
465 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 821094"];
466 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 821095"];
467 [label="referenceManager.AssertCanReuseForCompilation(this); 821096"];
468 [label="referenceManager.AssertCanReuseForCompilation(this); 821097"];
469 [label="_referenceManager 821098"];
470 [label="Debug.Assert(_lazyAssemblySymbol is null); 821099"];
471 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 821100"];
472 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 821101"];
473 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 821102"];
474 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 821103"];
475 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 821104"];
476 [label="return compilation; 821105"];
477 [label="var compilation = createCompilationLambda(); 821106"];
478 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 821107"];
479 [label="IsNullableEnabled(compilation) 821108"];
480 [label="param IsNullableEnabled(CSharpCompilation compilation) 821109"];
481 [label="compilation.SyntaxTrees 821110"];
482 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 821111"];
483 [label="_syntaxAndDeclarations.GetLazyState() 821112"];
484 [label="param GetLazyState(this) 821113"];
485 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 821114"];
486 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 821115"];
487 [label="Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null); 821116"];
488 [label="CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission) 821117"];
489 [label="param CreateState(ImmutableArray<SyntaxTree> externalSyntaxTrees) 821118"];
490 [label="param CreateState(string scriptClassName) 821119"];
491 [label="param CreateState(SourceReferenceResolver resolver) 821120"];
492 [label="param CreateState(CommonMessageProvider messageProvider) 821121"];
493 [label="param CreateState(bool isSubmission) 821122"];
494 [label="var treesBuilder = ArrayBuilder<SyntaxTree>.GetInstance(); 821123"];
495 [label="var ordinalMapBuilder = PooledDictionary<SyntaxTree, int>.GetInstance(); 821124"];
496 [label="var loadDirectiveMapBuilder = PooledDictionary<SyntaxTree, ImmutableArray<LoadDirective>>.GetInstance(); 821125"];
497 [label="var loadedSyntaxTreeMapBuilder = PooledDictionary<string, SyntaxTree>.GetInstance(); 821126"];
498 [label="var declMapBuilder = PooledDictionary<SyntaxTree, Lazy<RootSingleNamespaceDeclaration>>.GetInstance(); 821127"];
499 [label="var declTable = DeclarationTable.Empty; 821128"];
500 [label="foreach (var tree in externalSyntaxTrees)\n            {\n                AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable);\n            } 821129"];
501 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 821130"];
502 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 821131"];
503 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 821132"];
504 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 821133"];
505 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 821134"];
506 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 821135"];
507 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 821136"];
508 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 821137"];
509 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 821138"];
510 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 821139"];
511 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 821140"];
512 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable) 821141"];
513 [label="param AppendAllSyntaxTrees(ArrayBuilder<SyntaxTree> treesBuilder) 821142"];
514 [label="param AppendAllSyntaxTrees(SyntaxTree tree) 821143"];
515 [label="param AppendAllSyntaxTrees(string scriptClassName) 821144"];
516 [label="param AppendAllSyntaxTrees(SourceReferenceResolver resolver) 821145"];
517 [label="param AppendAllSyntaxTrees(CommonMessageProvider messageProvider) 821146"];
518 [label="param AppendAllSyntaxTrees(bool isSubmission) 821147"];
519 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, int> ordinalMapBuilder) 821148"];
520 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMapBuilder) 821149"];
521 [label="param AppendAllSyntaxTrees(IDictionary<string, SyntaxTree> loadedSyntaxTreeMapBuilder) 821150"];
522 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, Lazy<RootSingleNamespaceDeclaration>> declMapBuilder) 821151"];
523 [label="param AppendAllSyntaxTrees(ref DeclarationTable declTable) 821152"];
524 [label="var sourceCodeKind = tree.Options.Kind; 821153"];
525 [label="if (sourceCodeKind == SourceCodeKind.Script)\n            {\n                AppendAllLoadedSyntaxTrees(treesBuilder, tree, scriptClassName, resolver, messageProvider, isSubmission, ordinalMapBuilder, loadDirectiveMapBuilder, loadedSyntaxTreeMapBuilder, declMapBuilder, ref declTable);\n            } 821154"];
526 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 821155"];
527 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 821156"];
528 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 821157"];
529 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 821158"];
530 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 821159"];
531 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable) 821160"];
532 [label="param AddSyntaxTreeToDeclarationMapAndTable(SyntaxTree tree) 821161"];
533 [label="param AddSyntaxTreeToDeclarationMapAndTable(string scriptClassName) 821162"];
534 [label="param AddSyntaxTreeToDeclarationMapAndTable(bool isSubmission) 821163"];
535 [label="param AddSyntaxTreeToDeclarationMapAndTable(IDictionary<SyntaxTree, Lazy<RootSingleNamespaceDeclaration>> declMapBuilder) 821164"];
536 [label="param AddSyntaxTreeToDeclarationMapAndTable(ref DeclarationTable declTable) 821165"];
537 [label="var lazyRoot = new Lazy<RootSingleNamespaceDeclaration>(() => DeclarationTreeBuilder.ForTree(tree, scriptClassName, isSubmission)); 821166"];
538 [label="declMapBuilder.Add(tree, lazyRoot); 821167"];
539 [label="declMapBuilder.Add(tree, lazyRoot); 821168"];
540 [label="declMapBuilder.Add(tree, lazyRoot); 821169"];
541 [label="declTable = declTable.AddRootDeclaration(lazyRoot); 821170"];
542 [label="declTable = declTable.AddRootDeclaration(lazyRoot); 821171"];
543 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 821172"];
544 [label="treesBuilder.Add(tree); 821173"];
545 [label="treesBuilder.Add(tree); 821174"];
546 [label="ordinalMapBuilder.Add(tree, ordinalMapBuilder.Count); 821175"];
547 [label="ordinalMapBuilder.Add(tree, ordinalMapBuilder.Count); 821176"];
548 [label="ordinalMapBuilder.Add(tree, ordinalMapBuilder.Count); 821177"];
549 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 821178"];
550 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 821179"];
551 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 821180"];
552 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 821181"];
553 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 821182"];
554 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 821183"];
555 [label="new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable) 821184"];
556 [label="param State(ImmutableArray<SyntaxTree> syntaxTrees) 821185"];
557 [label="param State(ImmutableDictionary<SyntaxTree, int> syntaxTreeOrdinalMap) 821186"];
558 [label="param State(ImmutableDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMap) 821187"];
559 [label="param State(ImmutableDictionary<string, SyntaxTree> loadedSyntaxTreeMap) 821188"];
560 [label="param State(ImmutableDictionary<SyntaxTree, Lazy<RootSingleNamespaceDeclaration>> rootNamespaces) 821189"];
561 [label="param State(DeclarationTable declarationTable) 821190"];
562 [label="param State(this) 821191"];
563 [label="OrdinalMap 821192"];
564 [label="LoadDirectiveMap 821193"];
565 [label="LoadedSyntaxTreeMap 821194"];
566 [label="RootNamespaces 821195"];
567 [label="DeclarationTable 821196"];
568 [label="Debug.Assert(syntaxTrees.All(tree => syntaxTrees[syntaxTreeOrdinalMap[tree]] == tree)); 821197"];
569 [label="Debug.Assert(syntaxTrees.All(tree => syntaxTrees[syntaxTreeOrdinalMap[tree]] == tree)); 821198"];
570 [label="Debug.Assert(syntaxTrees.SetEquals(rootNamespaces.Keys.AsImmutable(), EqualityComparer<SyntaxTree>.Default)); 821199"];
571 [label="Debug.Assert(syntaxTrees.SetEquals(rootNamespaces.Keys.AsImmutable(), EqualityComparer<SyntaxTree>.Default)); 821200"];
572 [label="Debug.Assert(syntaxTrees.SetEquals(rootNamespaces.Keys.AsImmutable(), EqualityComparer<SyntaxTree>.Default)); 821201"];
573 [label="this.SyntaxTrees 821202"];
574 [label="this.OrdinalMap 821203"];
575 [label="this.LoadDirectiveMap 821204"];
576 [label="this.LoadedSyntaxTreeMap 821205"];
577 [label="this.RootNamespaces 821206"];
578 [label="this.DeclarationTable 821207"];
579 [label="Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null); 821208"];
580 [label="Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null); 821209"];
581 [label="Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null); 821210"];
582 [label="return _lazyState; 821211"];
583 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 821212"];
584 [label="var trees = compilation.SyntaxTrees; 821213"];
585 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 821214"];
586 [label="var options = (CSharpParseOptions)trees[0].Options; 821215"];
587 [label="var options = (CSharpParseOptions)trees[0].Options; 821216"];
588 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 821217"];
589 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 821218"];
590 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 821219"];
591 [label="return compilation; 821220"];
592 [label="var refCompilation = CreateEmptyCompilation(refSource, options: TestOptions.ReleaseDll.WithPlatform(Platform.AnyCpu), assemblyName: 'PlatformMismatch'); 821221"];
593 [label="refCompilation.VerifyEmitDiagnostics(emitOptions); 821222"];
594 [label="refCompilation.VerifyEmitDiagnostics(emitOptions); 821223"];
595 [label="refCompilation.VerifyEmitDiagnostics(emitOptions); 821224"];
596 [label="refCompilation.VerifyEmitDiagnostics(emitOptions) 821225"];
597 [label="param VerifyEmitDiagnostics(this TCompilation c) 821226"];
598 [label="param VerifyEmitDiagnostics(EmitOptions options) 821227"];
599 [label="param VerifyEmitDiagnostics(params DiagnosticDescription[] expected) 821228"];
600 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 821229"];
601 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 821230"];
602 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 821231"];
603 [label="c.GetEmitDiagnostics(options: options) 821232"];
604 [label="param GetEmitDiagnostics(this TCompilation c) 821233"];
605 [label="param GetEmitDiagnostics(EmitOptions options = null) 821234"];
606 [label="param GetEmitDiagnostics(IEnumerable<ResourceDescription> manifestResources = null) 821235"];
607 [label="MonoHelpers.IsRunningOnMono() 821236"];
608 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 821237"];
609 [label="var pdbStream = MonoHelpers.IsRunningOnMono() ? null : new MemoryStream(); 821238"];
610 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 821239"];
611 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 821240"];
612 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 821241"];
613 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 821242"];
614 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 821243"];
615 [label="get { return _options; } 821244"];
616 [label="return _options; 821245"];
617 [label="get { return _syntaxAndDeclarations.MessageProvider; } 821246"];
618 [label="return _syntaxAndDeclarations.MessageProvider; 821247"];
619 [label="param CreateModuleBuilder(EmitOptions emitOptions) 821248"];
620 [label="param CreateModuleBuilder(IMethodSymbol? debugEntryPoint) 821249"];
621 [label="param CreateModuleBuilder(Stream? sourceLinkStream) 821250"];
622 [label="param CreateModuleBuilder(IEnumerable<EmbeddedText>? embeddedTexts) 821251"];
623 [label="param CreateModuleBuilder(IEnumerable<ResourceDescription>? manifestResources) 821252"];
624 [label="param CreateModuleBuilder(CompilationTestData? testData) 821253"];
625 [label="param CreateModuleBuilder(DiagnosticBag diagnostics) 821254"];
626 [label="param CreateModuleBuilder(CancellationToken cancellationToken) 821255"];
627 [label="param CreateModuleBuilder(this) 821256"];
628 [label="Debug.Assert(!IsSubmission || HasCodeToEmit()); 821257"];
629 [label="string? runtimeMDVersion = GetRuntimeMetadataVersion(emitOptions, diagnostics); 821258"];
630 [label="string? runtimeMDVersion = GetRuntimeMetadataVersion(emitOptions, diagnostics); 821259"];
631 [label="GetRuntimeMetadataVersion(emitOptions, diagnostics) 821260"];
632 [label="param GetRuntimeMetadataVersion(EmitOptions emitOptions) 821261"];
633 [label="param GetRuntimeMetadataVersion(DiagnosticBag diagnostics) 821262"];
634 [label="param GetRuntimeMetadataVersion(this) 821263"];
635 [label="string? runtimeMDVersion = GetRuntimeMetadataVersion(emitOptions); 821264"];
636 [label="GetRuntimeMetadataVersion(emitOptions) 821265"];
637 [label="param GetRuntimeMetadataVersion(EmitOptions emitOptions) 821266"];
638 [label="param GetRuntimeMetadataVersion(this) 821267"];
639 [label="Assembly 821268"];
640 [label="get\n            {\n                return SourceAssembly;\n            } 821269"];
641 [label="SourceAssembly 821270"];
642 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 821271"];
643 [label="GetBoundReferenceManager() 821272"];
644 [label="param GetBoundReferenceManager(this) 821273"];
645 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 821274"];
646 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 821275"];
647 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 821276"];
648 [label="get { return this.Declarations.ReferenceDirectives; } 821277"];
649 [label="this.Declarations 821278"];
650 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 821279"];
651 [label="_syntaxAndDeclarations.GetLazyState() 821280"];
652 [label="param GetLazyState(this) 821281"];
653 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 821282"];
654 [label="return this.Declarations.ReferenceDirectives; 821283"];
655 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 821284"];
656 [label="_syntaxAndDeclarations.GetLazyState() 821285"];
657 [label="Debug.Assert(_lazyAssemblySymbol is object); 821286"];
658 [label="return _referenceManager; 821287"];
659 [label="GetBoundReferenceManager(); 821288"];
660 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 821289"];
661 [label="return _lazyAssemblySymbol; 821290"];
662 [label="return SourceAssembly; 821291"];
663 [label="var corAssembly = Assembly.CorLibrary as Symbols.Metadata.PE.PEAssemblySymbol; 821292"];
664 [label="if (corAssembly is object)\n            {\n                return corAssembly.Assembly.ManifestModule.MetadataVersion;\n            } 821293"];
665 [label="return emitOptions.RuntimeMetadataVersion; 821294"];
666 [label="if (runtimeMDVersion != null)\n            {\n                return runtimeMDVersion;\n            } 821295"];
667 [label="if (runtimeMDVersion != null)\n            {\n                return runtimeMDVersion;\n            } 821296"];
668 [label="return runtimeMDVersion; 821297"];
669 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 821298"];
670 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 821299"];
671 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 821300"];
672 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 821301"];
673 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 821302"];
674 [label="get { return SourceAssembly.IsDelaySigned; } 821303"];
675 [label="SourceAssembly 821304"];
676 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 821305"];
677 [label="GetBoundReferenceManager() 821306"];
678 [label="return _referenceManager; 821307"];
679 [label="GetBoundReferenceManager(); 821308"];
680 [label="return _lazyAssemblySymbol; 821309"];
681 [label="return SourceAssembly.IsDelaySigned; 821310"];
682 [label="SourceAssembly.IsDelaySigned 821311"];
683 [label="get\n            {\n                return _options;\n            } 821312"];
684 [label="get\n            {\n                return Declarations.GetMergedRoot(this);\n            } 821313"];
685 [label="Declarations 821314"];
686 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 821315"];
687 [label="_syntaxAndDeclarations.GetLazyState() 821316"];
688 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 821317"];
689 [label="return Declarations.GetMergedRoot(this); 821318"];
690 [label="return Declarations.GetMergedRoot(this); 821319"];
691 [label="return Declarations.GetMergedRoot(this); 821320"];
692 [label="_syntaxAndDeclarations.GetLazyState() 821321"];
693 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 821322"];
694 [label="get { return SourceAssembly.StrongNameKeys; } 821323"];
695 [label="SourceAssembly 821324"];
696 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 821325"];
697 [label="GetBoundReferenceManager() 821326"];
698 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 821327"];
699 [label="return _referenceManager; 821328"];
700 [label="GetBoundReferenceManager(); 821329"];
701 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 821330"];
702 [label="return SourceAssembly.StrongNameKeys; 821331"];
703 [label="SourceAssembly.StrongNameKeys 821332"];
704 [label="get\n            {\n                return _options;\n            } 821333"];
705 [label="=> 0x30 821334"];
706 [label="0x30 821335"];
707 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 821336"];
708 [label="if (manifestResources == null)\n            {\n                manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>();\n            } 821337"];
709 [label="if (manifestResources == null)\n            {\n                manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>();\n            } 821338"];
710 [label="manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>(); 821339"];
711 [label="PEModuleBuilder moduleBeingBuilt; 821340"];
712 [label="if (_options.OutputKind.IsNetModule())\n            {\n                moduleBeingBuilt = new PENetModuleBuilder(\n                    (SourceModuleSymbol)SourceModule,\n                    emitOptions,\n                    moduleProps,\n                    manifestResources);\n            }\n            else\n            {\n                var kind = _options.OutputKind.IsValid() ? _options.OutputKind : OutputKind.DynamicallyLinkedLibrary;\n                moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources);\n            } 821341"];
713 [label="var kind = _options.OutputKind.IsValid() ? _options.OutputKind : OutputKind.DynamicallyLinkedLibrary; 821342"];
714 [label="_options.OutputKind.IsValid() 821343"];
715 [label="_options.OutputKind 821344"];
716 [label="SourceAssembly 821345"];
717 [label="return _referenceManager; 821346"];
718 [label="GetBoundReferenceManager(); 821347"];
719 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 821348"];
720 [label="moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources); 821349"];
721 [label="moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources); 821350"];
722 [label="moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources); 821351"];
723 [label="moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources); 821352"];
724 [label="moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources); 821353"];
725 [label="moduleBeingBuilt = new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources); 821354"];
726 [label="new PEAssemblyBuilder(\n                    SourceAssembly,\n                    emitOptions,\n                    kind,\n                    moduleProps,\n                    manifestResources) 821355"];
727 [label="param PEAssemblyBuilder(SourceAssemblySymbol sourceAssembly) 821356"];
728 [label="param PEAssemblyBuilder(EmitOptions emitOptions) 821357"];
729 [label="param PEAssemblyBuilder(OutputKind outputKind) 821358"];
730 [label="param PEAssemblyBuilder(Cci.ModulePropertiesForSerialization serializationProperties) 821359"];
731 [label="param PEAssemblyBuilder(IEnumerable<ResourceDescription> manifestResources) 821360"];
732 [label="param PEAssemblyBuilder(this) 821361"];
733 [label="sourceAssembly 821362"];
734 [label="emitOptions 821363"];
735 [label="outputKind 821364"];
736 [label="serializationProperties 821365"];
737 [label="manifestResources 821366"];
738 [label="ImmutableArray<NamedTypeSymbol>.Empty 821367"];
739 [label="param PEAssemblyBuilder(this) 821368"];
740 [label="param PEAssemblyBuilderBase(SourceAssemblySymbol sourceAssembly) 821369"];
741 [label="param PEAssemblyBuilderBase(EmitOptions emitOptions) 821370"];
742 [label="param PEAssemblyBuilderBase(OutputKind outputKind) 821371"];
743 [label="param PEAssemblyBuilderBase(Cci.ModulePropertiesForSerialization serializationProperties) 821372"];
744 [label="param PEAssemblyBuilderBase(IEnumerable<ResourceDescription> manifestResources) 821373"];
745 [label="param PEAssemblyBuilderBase(ImmutableArray<NamedTypeSymbol> additionalTypes) 821374"];
746 [label="param PEAssemblyBuilderBase(this) 821375"];
747 [label="0 821376"];
748 [label="sourceAssembly.Modules[0] 821377"];
749 [label="emitOptions 821378"];
750 [label="outputKind 821379"];
751 [label="serializationProperties 821380"];
752 [label="manifestResources 821381"];
753 [label="param PEAssemblyBuilderBase(this) 821382"];
754 [label="param PEModuleBuilder(SourceModuleSymbol sourceModule) 821383"];
755 [label="param PEModuleBuilder(EmitOptions emitOptions) 821384"];
756 [label="param PEModuleBuilder(OutputKind outputKind) 821385"];
757 [label="param PEModuleBuilder(Cci.ModulePropertiesForSerialization serializationProperties) 821386"];
758 [label="param PEModuleBuilder(IEnumerable<ResourceDescription> manifestResources) 821387"];
759 [label="param PEModuleBuilder(this) 821388"];
760 [label="sourceModule.ContainingSourceAssembly.DeclaringCompilation 821389"];
761 [label="sourceModule 821390"];
762 [label="serializationProperties 821391"];
763 [label="manifestResources 821392"];
764 [label="outputKind 821393"];
765 [label="emitOptions 821394"];
766 [label="new ModuleCompilationState() 821395"];
767 [label="param ModuleCompilationState(this) 821396"];
768 [label="param PEModuleBuilder(this) 821397"];
769 [label="param PEModuleBuilder(this) 821398"];
770 [label="get\n            {\n                return true;\n            } 821399"];
771 [label="return true; 821400"];
772 [label="param PEModuleBuilder(this) 821401"];
773 [label="new ConcurrentDictionary<Symbol, Cci.IModuleReference>() 821402"];
774 [label="AssemblyOrModuleSymbolToModuleRefMap = new ConcurrentDictionary<Symbol, Cci.IModuleReference>() 821403"];
775 [label="Symbols.SymbolEqualityComparer.ConsiderEverything 821404"];
776 [label="new ConcurrentDictionary<Symbol, object>(Symbols.SymbolEqualityComparer.ConsiderEverything) 821405"];
777 [label="_genericInstanceMap = new ConcurrentDictionary<Symbol, object>(Symbols.SymbolEqualityComparer.ConsiderEverything) 821406"];
778 [label="new ConcurrentSet<TypeSymbol>() 821407"];
779 [label="_reportedErrorTypesMap = new ConcurrentSet<TypeSymbol>() 821408"];
780 [label="_embeddedTypesManagerOpt 821409"];
781 [label="_metadataName 821410"];
782 [label="_fixedImplementationTypes 821411"];
783 [label="_needsGeneratedAttributes 821412"];
784 [label="_needsGeneratedAttributes_IsFrozen 821413"];
785 [label="var specifiedName = sourceModule.MetadataName; 821414"];
786 [label="_metadataName = specifiedName != Microsoft.CodeAnalysis.Compilation.UnspecifiedModuleAssemblyName ?\n                            specifiedName :\n                            emitOptions.OutputNameOverride ?? specifiedName; 821415"];
787 [label="specifiedName != Microsoft.CodeAnalysis.Compilation.UnspecifiedModuleAssemblyName 821416"];
788 [label="_metadataName 821417"];
789 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceModule, this); 821418"];
790 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceModule, this); 821419"];
791 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceModule, this); 821420"];
792 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceModule, this); 821421"];
793 [label="if (sourceModule.AnyReferencedAssembliesAreLinked)\n            {\n                _embeddedTypesManagerOpt = new NoPia.EmbeddedTypesManager(this);\n            } 821422"];
794 [label="_sourceAssembly 821423"];
795 [label="_lazyEmbeddedAttribute 821424"];
796 [label="_lazyIsReadOnlyAttribute 821425"];
797 [label="_lazyIsByRefLikeAttribute 821426"];
798 [label="_lazyIsUnmanagedAttribute 821427"];
799 [label="_lazyNullableAttribute 821428"];
800 [label="_lazyNullableContextAttribute 821429"];
801 [label="_lazyNullablePublicOnlyAttribute 821430"];
802 [label="_lazyNativeIntegerAttribute 821431"];
803 [label="_metadataName 821432"];
804 [label="Debug.Assert(sourceAssembly is object); 821433"];
805 [label="_sourceAssembly 821434"];
806 [label="_additionalTypes = additionalTypes.NullToEmpty(); 821435"];
807 [label="_additionalTypes 821436"];
808 [label="_metadataName = (emitOptions.OutputNameOverride == null) ? sourceAssembly.MetadataName : FileNameUtilities.ChangeExtension(emitOptions.OutputNameOverride, extension: null); 821437"];
809 [label="_metadataName = (emitOptions.OutputNameOverride == null) ? sourceAssembly.MetadataName : FileNameUtilities.ChangeExtension(emitOptions.OutputNameOverride, extension: null); 821438"];
810 [label="(emitOptions.OutputNameOverride == null) 821439"];
811 [label="sourceAssembly.MetadataName 821440"];
812 [label="_metadataName 821441"];
813 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceAssembly, this); 821442"];
814 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceAssembly, this); 821443"];
815 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceAssembly, this); 821444"];
816 [label="AssemblyOrModuleSymbolToModuleRefMap.Add(sourceAssembly, this); 821445"];
817 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 821446"];
818 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 821447"];
819 [label="moduleBeingBuilt.SourceLinkStreamOpt 821448"];
820 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 821449"];
821 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 821450"];
822 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 821451"];
823 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 821452"];
824 [label="return moduleBeingBuilt; 821453"];
825 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 821454"];
826 [label="param CompileMethods(CommonPEModuleBuilder moduleBuilder) 821455"];
827 [label="param CompileMethods(bool emittingPdb) 821456"];
828 [label="param CompileMethods(bool emitMetadataOnly) 821457"];
829 [label="param CompileMethods(bool emitTestCoverageData) 821458"];
830 [label="param CompileMethods(DiagnosticBag diagnostics) 821459"];
831 [label="param CompileMethods(Predicate<ISymbolInternal>? filterOpt) 821460"];
832 [label="param CompileMethods(CancellationToken cancellationToken) 821461"];
833 [label="param CompileMethods(this) 821462"];
834 [label="PooledHashSet<int>? excludeDiagnostics = null; 821463"];
835 [label="if (emitMetadataOnly)\n            {\n                excludeDiagnostics = PooledHashSet<int>.GetInstance();\n                excludeDiagnostics.Add((int)ErrorCode.ERR_ConcreteMissingBody);\n            } 821464"];
836 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 821465"];
837 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 821466"];
838 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 821467"];
839 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 821468"];
840 [label="GetDiagnostics(CompilationStage.Declare, true, cancellationToken) 821469"];
841 [label="param GetDiagnostics(CompilationStage stage) 821470"];
842 [label="param GetDiagnostics(bool includeEarlierStages) 821471"];
843 [label="param GetDiagnostics(CancellationToken cancellationToken) 821472"];
844 [label="param GetDiagnostics(this) 821473"];
845 [label="var diagnostics = DiagnosticBag.GetInstance(); 821474"];
846 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 821475"];
847 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 821476"];
848 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 821477"];
849 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 821478"];
850 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 821479"];
851 [label="param GetDiagnostics(CompilationStage stage) 821480"];
852 [label="param GetDiagnostics(bool includeEarlierStages) 821481"];
853 [label="param GetDiagnostics(DiagnosticBag diagnostics) 821482"];
854 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 821483"];
855 [label="param GetDiagnostics(this) 821484"];
856 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 821485"];
857 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 821486"];
858 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 821487"];
859 [label="this.SyntaxTrees 821488"];
860 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 821489"];
861 [label="_syntaxAndDeclarations.GetLazyState() 821490"];
862 [label="param GetLazyState(this) 821491"];
863 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 821492"];
864 [label="var syntaxTrees = this.SyntaxTrees; 821493"];
865 [label="this.Options 821494"];
866 [label="get\n            {\n                return _options;\n            } 821495"];
867 [label="return _options; 821496"];
868 [label="if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                } 821497"];
869 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 821498"];
870 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 821499"];
871 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 821500"];
872 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 821501"];
873 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 821502"];
874 [label="param AppendLoadDirectiveDiagnostics(SyntaxAndDeclarationManager syntaxAndDeclarations) 821503"];
875 [label="param AppendLoadDirectiveDiagnostics(SyntaxTree syntaxTree) 821504"];
876 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 821505"];
877 [label="ImmutableArray<LoadDirective> loadDirectives; 821506"];
878 [label="loadDirectives 821507"];
879 [label="syntaxAndDeclarations.GetLazyState() 821508"];
880 [label="param GetLazyState(this) 821509"];
881 [label="if (syntaxAndDeclarations.GetLazyState().LoadDirectiveMap.TryGetValue(syntaxTree, out loadDirectives))\n            {\n                Debug.Assert(!loadDirectives.IsEmpty);\n                foreach (var directive in loadDirectives)\n                {\n                    IEnumerable<Diagnostic> diagnostics = directive.Diagnostics;\n                    if (locationFilterOpt != null)\n                    {\n                        diagnostics = locationFilterOpt(diagnostics);\n                    }\n                    builder.AddRange(diagnostics);\n                }\n            } 821510"];
882 [label="if (syntaxAndDeclarations.GetLazyState().LoadDirectiveMap.TryGetValue(syntaxTree, out loadDirectives))\n            {\n                Debug.Assert(!loadDirectives.IsEmpty);\n                foreach (var directive in loadDirectives)\n                {\n                    IEnumerable<Diagnostic> diagnostics = directive.Diagnostics;\n                    if (locationFilterOpt != null)\n                    {\n                        diagnostics = locationFilterOpt(diagnostics);\n                    }\n                    builder.AddRange(diagnostics);\n                }\n            } 821511"];
883 [label="if (syntaxAndDeclarations.GetLazyState().LoadDirectiveMap.TryGetValue(syntaxTree, out loadDirectives))\n            {\n                Debug.Assert(!loadDirectives.IsEmpty);\n                foreach (var directive in loadDirectives)\n                {\n                    IEnumerable<Diagnostic> diagnostics = directive.Diagnostics;\n                    if (locationFilterOpt != null)\n                    {\n                        diagnostics = locationFilterOpt(diagnostics);\n                    }\n                    builder.AddRange(diagnostics);\n                }\n            } 821512"];
884 [label="if (syntaxAndDeclarations.GetLazyState().LoadDirectiveMap.TryGetValue(syntaxTree, out loadDirectives))\n            {\n                Debug.Assert(!loadDirectives.IsEmpty);\n                foreach (var directive in loadDirectives)\n                {\n                    IEnumerable<Diagnostic> diagnostics = directive.Diagnostics;\n                    if (locationFilterOpt != null)\n                    {\n                        diagnostics = locationFilterOpt(diagnostics);\n                    }\n                    builder.AddRange(diagnostics);\n                }\n            } 821513"];
885 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 821514"];
886 [label="foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                } 821515"];
887 [label="cancellationToken.ThrowIfCancellationRequested(); 821516"];
888 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 821517"];
889 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 821518"];
890 [label="CheckAssemblyName(builder); 821519"];
891 [label="CheckAssemblyName(builder); 821520"];
892 [label="CheckAssemblyName(builder); 821521"];
893 [label="Options 821522"];
894 [label="get\n            {\n                return _options;\n            } 821523"];
895 [label="return _options; 821524"];
896 [label="builder.AddRange(Options.Errors); 821525"];
897 [label="Options 821526"];
898 [label="get\n            {\n                return _options;\n            } 821527"];
899 [label="return _options; 821528"];
900 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 821529"];
901 [label="cancellationToken.ThrowIfCancellationRequested(); 821530"];
902 [label="GetBoundReferenceManager() 821531"];
903 [label="param GetBoundReferenceManager(this) 821532"];
904 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 821533"];
905 [label="return _referenceManager; 821534"];
906 [label="builder.AddRange(GetBoundReferenceManager().Diagnostics); 821535"];
907 [label="cancellationToken.ThrowIfCancellationRequested(); 821536"];
908 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 821537"];
909 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 821538"];
910 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 821539"];
911 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 821540"];
912 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 821541"];
913 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 821542"];
914 [label="param GetSourceDeclarationDiagnostics(CancellationToken cancellationToken = default) 821543"];
915 [label="param GetSourceDeclarationDiagnostics(this) 821544"];
916 [label="GlobalImports 821545"];
917 [label="=> _globalImports.Value 821546"];
918 [label="_globalImports.Value 821547"];
919 [label="_globalImports.Value 821548"];
920 [label="=> Imports.FromGlobalUsings(this) 821549"];
921 [label="this 821550"];
922 [label="Imports.FromGlobalUsings(this) 821551"];
923 [label="Imports.FromGlobalUsings(this) 821552"];
924 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 821553"];
925 [label="ScriptCompilationInfo 821554"];
926 [label="ScriptCompilationInfo?.PreviousScriptCompilation 821555"];
927 [label="GlobalImports.Complete(cancellationToken); 821556"];
928 [label="GlobalImports.Complete(cancellationToken); 821557"];
929 [label="GlobalImports.Complete(cancellationToken); 821558"];
930 [label="SourceLocation? location = null; 821559"];
931 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 821560"];
932 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 821561"];
933 [label="Assembly 821562"];
934 [label="get\n            {\n                return SourceAssembly;\n            } 821563"];
935 [label="SourceAssembly 821564"];
936 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 821565"];
937 [label="GetBoundReferenceManager() 821566"];
938 [label="param GetBoundReferenceManager(this) 821567"];
939 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 821568"];
940 [label="return _referenceManager; 821569"];
941 [label="GetBoundReferenceManager(); 821570"];
942 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 821571"];
943 [label="return SourceAssembly; 821572"];
944 [label="Assembly.ForceComplete(location, cancellationToken); 821573"];
945 [label="Assembly.ForceComplete(location, cancellationToken); 821574"];
946 [label="Assembly.ForceComplete(location, cancellationToken); 821575"];
947 [label="Assembly.ForceComplete(location, cancellationToken); 821576"];
948 [label="Assembly.ForceComplete(location, cancellationToken); 821577"];
949 [label="SourceAssembly 821578"];
950 [label="GetBoundReferenceManager() 821579"];
951 [label="GetBoundReferenceManager(); 821580"];
952 [label="Declarations 821581"];
953 [label="_syntaxAndDeclarations.GetLazyState() 821582"];
954 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 821583"];
955 [label="return Declarations.GetMergedRoot(this); 821584"];
956 [label="_syntaxAndDeclarations.GetLazyState() 821585"];
957 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 821586"];
958 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 821587"];
959 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 821588"];
960 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 821589"];
961 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 821590"];
962 [label="var diagnostics = new DiagnosticBag(); 821591"];
963 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 821592"];
964 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 821593"];
965 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 821594"];
966 [label="return _lazyDeclarationDiagnostics; 821595"];
967 [label="param SymbolDeclaredEvent(Symbol symbol) 821596"];
968 [label="param SymbolDeclaredEvent(this) 821597"];
969 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 821598"];
970 [label="param GetUnaliasedReferencedAssemblies(ArrayBuilder<AssemblySymbol> assemblies) 821599"];
971 [label="param GetUnaliasedReferencedAssemblies(this) 821600"];
972 [label="GetBoundReferenceManager() 821601"];
973 [label="param GetBoundReferenceManager(this) 821602"];
974 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 821603"];
975 [label="return _referenceManager; 821604"];
976 [label="var referenceManager = GetBoundReferenceManager(); 821605"];
977 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 821606"];
978 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 821607"];
979 [label="GetBoundReferenceManager(); 821608"];
980 [label="get\n            {\n                return _additionalCodegenWarnings;\n            } 821609"];
981 [label="return _additionalCodegenWarnings; 821610"];
982 [label="GetBoundReferenceManager(); 821611"];
983 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 821612"];
984 [label="return _referenceManager; 821613"];
985 [label="var referenceManager = GetBoundReferenceManager(); 821614"];
986 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 821615"];
987 [label="param ShouldEmitNullableAttributes(Symbol symbol) 821616"];
988 [label="param ShouldEmitNullableAttributes(this) 821617"];
989 [label="RoslynDebug.Assert(symbol is object); 821618"];
990 [label="RoslynDebug.Assert(symbol is object); 821619"];
991 [label="Debug.Assert(symbol.IsDefinition); 821620"];
992 [label="SourceModule 821621"];
993 [label="get\n            {\n                return Assembly.Modules[0];\n            } 821622"];
994 [label="Assembly 821623"];
995 [label="get\n            {\n                return SourceAssembly;\n            } 821624"];
996 [label="SourceAssembly 821625"];
997 [label="GetBoundReferenceManager() 821626"];
998 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 821627"];
999 [label="return _referenceManager; 821628"];
1000 [label="GetBoundReferenceManager(); 821629"];
1001 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 821630"];
1002 [label="return Assembly.Modules[0]; 821631"];
1003 [label="return Assembly.Modules[0]; 821632"];
1004 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 821633"];
1005 [label="EmitNullablePublicOnly 821634"];
1006 [label="get\n            {\n                if (!_lazyEmitNullablePublicOnly.HasValue())\n                {\n                    // Lafhis\n                    var firstSt = SyntaxTrees.FirstOrDefault();\n                    bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true;\n                    _lazyEmitNullablePublicOnly = value.ToThreeState();\n                }\n                return _lazyEmitNullablePublicOnly.Value();\n            } 821635"];
1007 [label="if (!_lazyEmitNullablePublicOnly.HasValue())\n                {\n                    // Lafhis\n                    var firstSt = SyntaxTrees.FirstOrDefault();\n                    bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true;\n                    _lazyEmitNullablePublicOnly = value.ToThreeState();\n                } 821636"];
1008 [label="SyntaxTrees 821637"];
1009 [label="var firstSt = SyntaxTrees.FirstOrDefault(); 821638"];
1010 [label="bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true; 821639"];
1011 [label="bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true; 821640"];
1012 [label="_lazyEmitNullablePublicOnly = value.ToThreeState(); 821641"];
1013 [label="_lazyEmitNullablePublicOnly 821642"];
1014 [label="return _lazyEmitNullablePublicOnly.Value(); 821643"];
1015 [label="if (!EmitNullablePublicOnly)\n            {\n                return true;\n            } 821644"];
1016 [label="return true; 821645"];
1017 [label="Debug.Assert(symbol.IsDefinition); 821646"];
1018 [label="GetBoundReferenceManager(); 821647"];
1019 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 821648"];
1020 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 821649"];
1021 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 821650"];
1022 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 821651"];
1023 [label="_declarationDiagnosticsFrozen = true; 821652"];
1024 [label="_declarationDiagnosticsFrozen 821653"];
1025 [label="_needsGeneratedAttributes_IsFrozen = true; 821654"];
1026 [label="_needsGeneratedAttributes_IsFrozen 821655"];
1027 [label="var result = _lazyDeclarationDiagnostics?.AsEnumerable() ?? Enumerable.Empty<Diagnostic>(); 821656"];
1028 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 821657"];
1029 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 821658"];
1030 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 821659"];
1031 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 821660"];
1032 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 821661"];
1033 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 821662"];
1034 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 821663"];
1035 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 821664"];
1036 [label="param GetClsComplianceDiagnostics(CancellationToken cancellationToken) 821665"];
1037 [label="param GetClsComplianceDiagnostics(this) 821666"];
1038 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 821667"];
1039 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 821668"];
1040 [label="if (_lazyClsComplianceDiagnostics.IsDefault)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken);\n                ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree());\n            } 821669"];
1041 [label="var builder = DiagnosticBag.GetInstance(); 821670"];
1042 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 821671"];
1043 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 821672"];
1044 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 821673"];
1045 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 821674"];
1046 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken) 821675"];
1047 [label="param CheckCompliance(CSharpCompilation compilation) 821676"];
1048 [label="param CheckCompliance(DiagnosticBag diagnostics) 821677"];
1049 [label="param CheckCompliance(CancellationToken cancellationToken) 821678"];
1050 [label="param CheckCompliance(SyntaxTree filterTree = null) 821679"];
1051 [label="param CheckCompliance(TextSpan? filterSpanWithinTree = null) 821680"];
1052 [label="var queue = new ConcurrentQueue<Diagnostic>(); 821681"];
1053 [label="var checker = new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken); 821682"];
1054 [label="var checker = new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken); 821683"];
1055 [label="var checker = new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken); 821684"];
1056 [label="var checker = new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken); 821685"];
1057 [label="var checker = new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken); 821686"];
1058 [label="var checker = new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken); 821687"];
1059 [label="new ClsComplianceChecker(compilation, filterTree, filterSpanWithinTree, queue, cancellationToken) 821688"];
1060 [label="param ClsComplianceChecker(CSharpCompilation compilation) 821689"];
1061 [label="param ClsComplianceChecker(SyntaxTree filterTree) 821690"];
1062 [label="param ClsComplianceChecker(TextSpan? filterSpanWithinTree) 821691"];
1063 [label="param ClsComplianceChecker(ConcurrentQueue<Diagnostic> diagnostics) 821692"];
1064 [label="param ClsComplianceChecker(CancellationToken cancellationToken) 821693"];
1065 [label="param ClsComplianceChecker(this) 821694"];
1066 [label="param ClsComplianceChecker(this) 821695"];
1067 [label="_compilation 821696"];
1068 [label="_filterTree 821697"];
1069 [label="_filterSpanWithinTree 821698"];
1070 [label="_diagnostics 821699"];
1071 [label="_declaredOrInheritedCompliance 821700"];
1072 [label="_compilerTasks 821701"];
1073 [label="_compilation 821702"];
1074 [label="_filterTree 821703"];
1075 [label="_filterSpanWithinTree 821704"];
1076 [label="_diagnostics 821705"];
1077 [label="_cancellationToken 821706"];
1078 [label="_declaredOrInheritedCompliance = new ConcurrentDictionary<Symbol, Compliance>(Symbols.SymbolEqualityComparer.ConsiderEverything); 821707"];
1079 [label="_declaredOrInheritedCompliance 821708"];
1080 [label="ConcurrentAnalysis 821709"];
1081 [label="=> _filterTree == null && _compilation.Options.ConcurrentBuild 821710"];
1082 [label="null 821711"];
1083 [label="_filterTree == null 821712"];
1084 [label="_compilation.Options 821713"];
1085 [label="get\n            {\n                return _options;\n            } 821714"];
1086 [label="return _options; 821715"];
1087 [label="_filterTree == null && _compilation.Options.ConcurrentBuild 821716"];
1088 [label="if (ConcurrentAnalysis)\n            {\n                _compilerTasks = new ConcurrentStack<Task>();\n            } 821717"];
1089 [label="_compilerTasks = new ConcurrentStack<Task>(); 821718"];
1090 [label="_compilerTasks 821719"];
1091 [label="compilation.Assembly 821720"];
1092 [label="get\n            {\n                return SourceAssembly;\n            } 821721"];
1093 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 821722"];
1094 [label="return _referenceManager; 821723"];
1095 [label="GetBoundReferenceManager(); 821724"];
1096 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 821725"];
1097 [label="checker.Visit(compilation.Assembly); 821726"];
1098 [label="checker.Visit(compilation.Assembly); 821727"];
1099 [label="checker.Visit(compilation.Assembly); 821728"];
1100 [label="param VisitAssembly(AssemblySymbol symbol) 821729"];
1101 [label="param VisitAssembly(this) 821730"];
1102 [label="_cancellationToken.ThrowIfCancellationRequested(); 821731"];
1103 [label="System.Diagnostics.Debug.Assert(symbol is SourceAssemblySymbol); 821732"];
1104 [label="Compliance assemblyCompliance = GetDeclaredOrInheritedCompliance(symbol); 821733"];
1105 [label="GetDeclaredOrInheritedCompliance(symbol) 821734"];
1106 [label="param GetDeclaredOrInheritedCompliance(Symbol symbol) 821735"];
1107 [label="param GetDeclaredOrInheritedCompliance(this) 821736"];
1108 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 821737"];
1109 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 821738"];
1110 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                // Don't bother storing entries for namespaces - just go straight to the assembly.\n                return GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly);\n            }\n            else if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 821739"];
1111 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 821740"];
1112 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 821741"];
1113 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 821742"];
1114 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 821743"];
1115 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 821744"];
1116 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 821745"];
1117 [label="Compliance compliance; 821746"];
1118 [label="if (_declaredOrInheritedCompliance.TryGetValue(symbol, out compliance))\n            {\n                return compliance;\n            } 821747"];
1119 [label="if (_declaredOrInheritedCompliance.TryGetValue(symbol, out compliance))\n            {\n                return compliance;\n            } 821748"];
1120 [label="if (_declaredOrInheritedCompliance.TryGetValue(symbol, out compliance))\n            {\n                return compliance;\n            } 821749"];
1121 [label="Location ignoredLocation; 821750"];
1122 [label="bool? declaredCompliance = GetDeclaredCompliance(symbol, out ignoredLocation); 821751"];
1123 [label="bool? declaredCompliance = GetDeclaredCompliance(symbol, out ignoredLocation); 821752"];
1124 [label="GetDeclaredCompliance(symbol, out ignoredLocation) 821753"];
1125 [label="param GetDeclaredCompliance(Symbol symbol) 821754"];
1126 [label="param GetDeclaredCompliance(out Location attributeLocation) 821755"];
1127 [label="param GetDeclaredCompliance(this) 821756"];
1128 [label="attributeLocation = null; 821757"];
1129 [label="foreach (CSharpAttributeData data in symbol.GetAttributes())\n            {\n                // Check signature before HasErrors to avoid realizing symbols for other attributes.\n                if (data.IsTargetAttribute(symbol, AttributeDescription.CLSCompliantAttribute))\n                {\n                    NamedTypeSymbol attributeClass = data.AttributeClass;\n                    if ((object)attributeClass != null)\n                    {\n                        DiagnosticInfo info = attributeClass.GetUseSiteDiagnostic();\n                        if (info != null)\n                        {\n                            Location location = symbol.Locations.IsEmpty ? NoLocation.Singleton : symbol.Locations[0];\n                            _diagnostics.Enqueue(new CSDiagnostic(info, location));\n                            if (info.Severity >= DiagnosticSeverity.Error)\n                            {\n                                continue;\n                            }\n                        }\n                    }\n\n                    if (!data.HasErrors)\n                    {\n                        if (!TryGetAttributeWarningLocation(data, out attributeLocation))\n                        {\n                            attributeLocation = null;\n                        }\n\n                        ImmutableArray<TypedConstant> args = data.CommonConstructorArguments;\n                        System.Diagnostics.Debug.Assert(args.Length == 1, 'We already checked the signature and HasErrors.');\n\n                        // Duplicates are reported elsewhere - we only care about the first (error-free) occurrence.\n                        return (bool)args[0].ValueInternal;\n                    }\n                }\n            } 821758"];
1130 [label="return null; 821759"];
1131 [label="bool? declaredCompliance = GetDeclaredCompliance(symbol, out ignoredLocation); 821760"];
1132 [label="if (declaredCompliance.HasValue)\n            {\n                compliance = declaredCompliance.GetValueOrDefault() ? Compliance.DeclaredTrue : Compliance.DeclaredFalse;\n            }\n            else if (symbol.Kind == SymbolKind.Assembly)\n            {\n                // Assemblies are not compliant unless specifically declared to be so.\n                compliance = Compliance.ImpliedFalse;\n            }\n            else\n            {\n                compliance = IsTrue(GetInheritedCompliance(symbol)) ? Compliance.InheritedTrue : Compliance.InheritedFalse;\n            } 821761"];
1133 [label="if (symbol.Kind == SymbolKind.Assembly)\n            {\n                // Assemblies are not compliant unless specifically declared to be so.\n                compliance = Compliance.ImpliedFalse;\n            }\n            else\n            {\n                compliance = IsTrue(GetInheritedCompliance(symbol)) ? Compliance.InheritedTrue : Compliance.InheritedFalse;\n            } 821762"];
1134 [label="compliance = Compliance.ImpliedFalse; 821763"];
1135 [label="return (symbol.Kind == SymbolKind.Assembly || symbol.Kind == SymbolKind.NamedType)\n                ? _declaredOrInheritedCompliance.GetOrAdd(symbol, compliance)\n                : compliance; 821764"];
1136 [label="(symbol.Kind == SymbolKind.Assembly || symbol.Kind == SymbolKind.NamedType) 821765"];
1137 [label="return (symbol.Kind == SymbolKind.Assembly || symbol.Kind == SymbolKind.NamedType)\n                ? _declaredOrInheritedCompliance.GetOrAdd(symbol, compliance)\n                : compliance; 821766"];
1138 [label="if (assemblyCompliance == Compliance.DeclaredFalse)\n            {\n                // Our interpretation of an assembly-level CLSCompliant attribute is as follows:\n                //   1) If true, then perform all CLS checks.\n                //   2) If false, then perform no CLS checks (dev11 still performs a few, mostly around\n                //      meaningless attributes).  Our interpretation is that the user ultimately wants\n                //      his code to be CLS-compliant, but is temporarily disabling the checks (e.g. during\n                //      refactoring/prototyping).\n                //   3) If absent, the perform all CLS checks.  Our interpretation is that - in the\n                //      absence of an assembly-level attribute - any CLS problems within the compilation\n                //      indicate that the user was trying to do something but didn't know how.  It would\n                //      be nice if the most common case (i.e. this one) was the cheapest, but we don't\n                //      want to confuse novice users.\n                return;\n            } 821767"];
1139 [label="bool assemblyComplianceValue = IsTrue(assemblyCompliance); 821768"];
1140 [label="IsTrue(assemblyCompliance) 821769"];
1141 [label="param IsTrue(Compliance compliance) 821770"];
1142 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 821771"];
1143 [label="return false; 821772"];
1144 [label="for (int i = 0; i < symbol.Modules.Length; i++)\n            {\n                ModuleSymbol module = symbol.Modules[i];\n                Location attributeLocation;\n                bool? moduleDeclaredCompliance = GetDeclaredCompliance(module, out attributeLocation);\n\n                Location warningLocation = i == 0 ? attributeLocation : module.Locations[0];\n                System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.');\n\n                if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                }\n            } 821773"];
1145 [label="for (int i = 0; i < symbol.Modules.Length; i++)\n            {\n                ModuleSymbol module = symbol.Modules[i];\n                Location attributeLocation;\n                bool? moduleDeclaredCompliance = GetDeclaredCompliance(module, out attributeLocation);\n\n                Location warningLocation = i == 0 ? attributeLocation : module.Locations[0];\n                System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.');\n\n                if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                }\n            } 821774"];
1146 [label="ModuleSymbol module = symbol.Modules[i]; 821775"];
1147 [label="Location attributeLocation; 821776"];
1148 [label="bool? moduleDeclaredCompliance = GetDeclaredCompliance(module, out attributeLocation); 821777"];
1149 [label="bool? moduleDeclaredCompliance = GetDeclaredCompliance(module, out attributeLocation); 821778"];
1150 [label="GetDeclaredCompliance(module, out attributeLocation) 821779"];
1151 [label="param GetDeclaredCompliance(Symbol symbol) 821780"];
1152 [label="param GetDeclaredCompliance(out Location attributeLocation) 821781"];
1153 [label="param GetDeclaredCompliance(this) 821782"];
1154 [label="attributeLocation = null; 821783"];
1155 [label="bool? moduleDeclaredCompliance = GetDeclaredCompliance(module, out attributeLocation); 821784"];
1156 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 821785"];
1157 [label="i == 0 821786"];
1158 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 821787"];
1159 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 821788"];
1160 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 821789"];
1161 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 821790"];
1162 [label="if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 821791"];
1163 [label="if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 821792"];
1164 [label="if (assemblyComplianceValue)\n            {\n                CheckForAttributeWithArrayArgument(symbol);\n            } 821793"];
1165 [label="ModuleSymbol sourceModule = symbol.Modules[0]; 821794"];
1166 [label="ModuleSymbol sourceModule = symbol.Modules[0]; 821795"];
1167 [label="if (IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)))\n            {\n                CheckForAttributeWithArrayArgument(sourceModule);\n            } 821796"];
1168 [label="GetDeclaredOrInheritedCompliance(sourceModule) 821797"];
1169 [label="param GetDeclaredOrInheritedCompliance(Symbol symbol) 821798"];
1170 [label="param GetDeclaredOrInheritedCompliance(this) 821799"];
1171 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 821800"];
1172 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 821801"];
1173 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                // Don't bother storing entries for namespaces - just go straight to the assembly.\n                return GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly);\n            }\n            else if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 821802"];
1174 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 821803"];
1175 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 821804"];
1176 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 821805"];
1177 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 821806"];
1178 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 821807"];
1179 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 821808"];
1180 [label="Compliance compliance; 821809"];
1181 [label="if (_declaredOrInheritedCompliance.TryGetValue(symbol, out compliance))\n            {\n                return compliance;\n            } 821810"];
1182 [label="Location ignoredLocation; 821811"];
1183 [label="bool? declaredCompliance = GetDeclaredCompliance(symbol, out ignoredLocation); 821812"];
1184 [label="GetDeclaredCompliance(symbol, out ignoredLocation) 821813"];
1185 [label="param GetDeclaredCompliance(out Location attributeLocation) 821814"];
1186 [label="param GetDeclaredCompliance(this) 821815"];
1187 [label="attributeLocation = null; 821816"];
1188 [label="return null; 821817"];
1189 [label="bool? declaredCompliance = GetDeclaredCompliance(symbol, out ignoredLocation); 821818"];
1190 [label="if (declaredCompliance.HasValue)\n            {\n                compliance = declaredCompliance.GetValueOrDefault() ? Compliance.DeclaredTrue : Compliance.DeclaredFalse;\n            }\n            else if (symbol.Kind == SymbolKind.Assembly)\n            {\n                // Assemblies are not compliant unless specifically declared to be so.\n                compliance = Compliance.ImpliedFalse;\n            }\n            else\n            {\n                compliance = IsTrue(GetInheritedCompliance(symbol)) ? Compliance.InheritedTrue : Compliance.InheritedFalse;\n            } 821819"];
1191 [label="compliance = IsTrue(GetInheritedCompliance(symbol)) ? Compliance.InheritedTrue : Compliance.InheritedFalse; 821820"];
1192 [label="GetInheritedCompliance(symbol) 821821"];
1193 [label="param GetInheritedCompliance(Symbol symbol) 821822"];
1194 [label="param GetInheritedCompliance(this) 821823"];
1195 [label="System.Diagnostics.Debug.Assert(symbol.Kind != SymbolKind.Assembly); 821824"];
1196 [label="Symbol containing = (Symbol)symbol.ContainingType ?? symbol.ContainingAssembly; 821825"];
1197 [label="System.Diagnostics.Debug.Assert((object)containing != null); 821826"];
1198 [label="System.Diagnostics.Debug.Assert((object)containing != null); 821827"];
1199 [label="return GetDeclaredOrInheritedCompliance(containing); 821828"];
1200 [label="GetDeclaredOrInheritedCompliance(containing) 821829"];
1201 [label="param GetDeclaredOrInheritedCompliance(Symbol symbol) 821830"];
1202 [label="param GetDeclaredOrInheritedCompliance(this) 821831"];
1203 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 821832"];
1204 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 821833"];
1205 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                // Don't bother storing entries for namespaces - just go straight to the assembly.\n                return GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly);\n            }\n            else if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 821834"];
1206 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 821835"];
1207 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 821836"];
1208 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 821837"];
1209 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 821838"];
1210 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 821839"];
1211 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 821840"];
1212 [label="if (_declaredOrInheritedCompliance.TryGetValue(symbol, out compliance))\n            {\n                return compliance;\n            } 821841"];
1213 [label="return compliance; 821842"];
1214 [label="IsTrue(GetInheritedCompliance(symbol)) 821843"];
1215 [label="param IsTrue(Compliance compliance) 821844"];
1216 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 821845"];
1217 [label="return false; 821846"];
1218 [label="IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)) 821847"];
1219 [label="param IsTrue(Compliance compliance) 821848"];
1220 [label="Visit(symbol.GlobalNamespace); 821849"];
1221 [label="Visit(symbol.GlobalNamespace); 821850"];
1222 [label="param VisitNamespace(NamespaceSymbol symbol) 821851"];
1223 [label="param VisitNamespace(this) 821852"];
1224 [label="_cancellationToken.ThrowIfCancellationRequested(); 821853"];
1225 [label="if (DoNotVisit(symbol)) return; 821854"];
1226 [label="DoNotVisit(symbol) 821855"];
1227 [label="param DoNotVisit(Symbol symbol) 821856"];
1228 [label="param DoNotVisit(this) 821857"];
1229 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                return false;\n            } 821858"];
1230 [label="return false; 821859"];
1231 [label="if (IsTrue(GetDeclaredOrInheritedCompliance(symbol)))\n            {\n                CheckName(symbol);\n                CheckMemberDistinctness(symbol);\n            } 821860"];
1232 [label="GetDeclaredOrInheritedCompliance(symbol) 821861"];
1233 [label="param GetDeclaredOrInheritedCompliance(Symbol symbol) 821862"];
1234 [label="param GetDeclaredOrInheritedCompliance(this) 821863"];
1235 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 821864"];
1236 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 821865"];
1237 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                // Don't bother storing entries for namespaces - just go straight to the assembly.\n                return GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly);\n            }\n            else if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 821866"];
1238 [label="return GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly); 821867"];
1239 [label="GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly) 821868"];
1240 [label="param GetDeclaredOrInheritedCompliance(Symbol symbol) 821869"];
1241 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 821870"];
1242 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 821871"];
1243 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 821872"];
1244 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 821873"];
1245 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 821874"];
1246 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 821875"];
1247 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 821876"];
1248 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 821877"];
1249 [label="return compliance; 821878"];
1250 [label="IsTrue(GetDeclaredOrInheritedCompliance(symbol)) 821879"];
1251 [label="param IsTrue(Compliance compliance) 821880"];
1252 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 821881"];
1253 [label="return false; 821882"];
1254 [label="ConcurrentAnalysis 821883"];
1255 [label="=> _filterTree == null && _compilation.Options.ConcurrentBuild 821884"];
1256 [label="null 821885"];
1257 [label="_filterTree == null 821886"];
1258 [label="_compilation.Options 821887"];
1259 [label="get\n            {\n                return _options;\n            } 821888"];
1260 [label="if (ConcurrentAnalysis)\n            {\n                VisitNamespaceMembersAsTasks(symbol);\n            }\n            else\n            {\n                VisitNamespaceMembers(symbol);\n            } 821889"];
1261 [label="VisitNamespaceMembersAsTasks(symbol); 821890"];
1262 [label="VisitNamespaceMembersAsTasks(symbol) 821891"];
1263 [label="param VisitNamespaceMembersAsTasks(NamespaceSymbol symbol) 821892"];
1264 [label="param VisitNamespaceMembersAsTasks(this) 821893"];
1265 [label="foreach (var m in symbol.GetMembersUnordered())\n            {\n                _compilerTasks.Push(Task.Run(UICultureUtilities.WithCurrentUICulture(() =>\n                {\n                    try\n                    {\n                        Visit(m);\n                    }\n                    catch (Exception e) when (FatalError.ReportAndPropagateUnlessCanceled(e))\n                    {\n                        throw ExceptionUtilities.Unreachable;\n                    }\n                }), _cancellationToken));\n            } 821894"];
1266 [label="_compilerTasks.Push(Task.Run(UICultureUtilities.WithCurrentUICulture(() =>\n                {\n                    try\n                    {\n                        Visit(m);\n                    }\n                    catch (Exception e) when (FatalError.ReportAndPropagateUnlessCanceled(e))\n                    {\n                        throw ExceptionUtilities.Unreachable;\n                    }\n                }), _cancellationToken)); 821895"];
1267 [label="_compilerTasks.Push(Task.Run(UICultureUtilities.WithCurrentUICulture(() =>\n                {\n                    try\n                    {\n                        Visit(m);\n                    }\n                    catch (Exception e) when (FatalError.ReportAndPropagateUnlessCanceled(e))\n                    {\n                        throw ExceptionUtilities.Unreachable;\n                    }\n                }), _cancellationToken)); 821896"];
1268 [label="VisitNamespaceMembersAsTasks(symbol); 821897"];
1269 [label="checker.WaitForWorkers() 821898"];
1270 [label="param WaitForWorkers(this) 821899"];
1271 [label="var tasks = _compilerTasks; 821900"];
1272 [label="if (tasks == null)\n            {\n                return;\n            } 821901"];
1273 [label="if (tasks == null)\n            {\n                return;\n            } 821902"];
1274 [label="while (tasks.TryPop(out Task curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 821903"];
1275 [label="while (tasks.TryPop(out Task curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 821904"];
1276 [label="curTask.GetAwaiter().GetResult(); 821905"];
1277 [label="checker.WaitForWorkers(); 821906"];
1278 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 821907"];
1279 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 821908"];
1280 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree()); 821909"];
1281 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree()); 821910"];
1282 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree()); 821911"];
1283 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 821912"];
1284 [label="return _lazyClsComplianceDiagnostics; 821913"];
1285 [label="return result.AsImmutable().Concat(clsDiagnostics); 821914"];
1286 [label="return result.AsImmutable().Concat(clsDiagnostics); 821915"];
1287 [label="return result.AsImmutable().Concat(clsDiagnostics); 821916"];
1288 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 821917"];
1289 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 821918"];
1290 [label="cancellationToken.ThrowIfCancellationRequested(); 821919"];
1291 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 821920"];
1292 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 821921"];
1293 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 821922"];
1294 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 821923"];
1295 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 821924"];
1296 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 821925"];
1297 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 821926"];
1298 [label="return diagnostics.ToReadOnlyAndFree(); 821927"];
1299 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 821928"];
1300 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 821929"];
1301 [label="excludeDiagnostics?.Free(); 821930"];
1302 [label="var moduleBeingBuilt = (PEModuleBuilder)moduleBuilder; 821931"];
1303 [label="if (emitMetadataOnly)\n            {\n                if (hasDeclarationErrors)\n                {\n                    return false;\n                }\n\n                if (moduleBeingBuilt.SourceModule.HasBadAttributes)\n                {\n                    // If there were errors but no declaration diagnostics, explicitly add a 'Failed to emit module' error.\n                    diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuilt).Name,\n                        new LocalizableResourceString(nameof(CodeAnalysisResources.ModuleHasInvalidAttributes), CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n\n                    return false;\n                }\n\n                SynthesizedMetadataCompiler.ProcessSynthesizedMembers(this, moduleBeingBuilt, cancellationToken);\n            }\n            else\n            {\n                if ((emittingPdb || emitTestCoverageData) &&\n                    !CreateDebugDocuments(moduleBeingBuilt.DebugDocumentsBuilder, moduleBeingBuilt.EmbeddedTexts, diagnostics))\n                {\n                    return false;\n                }\n\n                // Perform initial bind of method bodies in spite of earlier errors. This is the same\n                // behavior as when calling GetDiagnostics()\n\n                // Use a temporary bag so we don't have to refilter pre-existing diagnostics.\n                DiagnosticBag? methodBodyDiagnosticBag = DiagnosticBag.GetInstance();\n\n                MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken);\n\n                if (!hasDeclarationErrors && !CommonCompiler.HasUnsuppressableErrors(methodBodyDiagnosticBag))\n                {\n                    GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag);\n                }\n\n                bool hasMethodBodyError = !FilterAndAppendAndFreeDiagnostics(diagnostics, ref methodBodyDiagnosticBag, cancellationToken);\n\n                if (hasDeclarationErrors || hasMethodBodyError)\n                {\n                    return false;\n                }\n            } 821932"];
1304 [label="if ((emittingPdb || emitTestCoverageData) &&\n                    !CreateDebugDocuments(moduleBeingBuilt.DebugDocumentsBuilder, moduleBeingBuilt.EmbeddedTexts, diagnostics))\n                {\n                    return false;\n                } 821933"];
1305 [label="if ((emittingPdb || emitTestCoverageData) &&\n                    !CreateDebugDocuments(moduleBeingBuilt.DebugDocumentsBuilder, moduleBeingBuilt.EmbeddedTexts, diagnostics))\n                {\n                    return false;\n                } 821934"];
1306 [label="if ((emittingPdb || emitTestCoverageData) &&\n                    !CreateDebugDocuments(moduleBeingBuilt.DebugDocumentsBuilder, moduleBeingBuilt.EmbeddedTexts, diagnostics))\n                {\n                    return false;\n                } 821935"];
1307 [label="if ((emittingPdb || emitTestCoverageData) &&\n                    !CreateDebugDocuments(moduleBeingBuilt.DebugDocumentsBuilder, moduleBeingBuilt.EmbeddedTexts, diagnostics))\n                {\n                    return false;\n                } 821936"];
1308 [label="get\n            {\n                return this.SyntaxTrees;\n            } 821937"];
1309 [label="this.SyntaxTrees 821938"];
1310 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 821939"];
1311 [label="return this.SyntaxTrees; 821940"];
1312 [label="param AddDebugSourceDocumentsForChecksumDirectives(DebugDocumentsBuilder documentsBuilder) 821941"];
1313 [label="param AddDebugSourceDocumentsForChecksumDirectives(SyntaxTree tree) 821942"];
1314 [label="param AddDebugSourceDocumentsForChecksumDirectives(DiagnosticBag diagnostics) 821943"];
1315 [label="param AddDebugSourceDocumentsForChecksumDirectives(this) 821944"];
1316 [label="var checksumDirectives = tree.GetRoot().GetDirectives(d => d.Kind() == SyntaxKind.PragmaChecksumDirectiveTrivia &&\n                                                                 !d.ContainsDiagnostics); 821945"];
1317 [label="var checksumDirectives = tree.GetRoot().GetDirectives(d => d.Kind() == SyntaxKind.PragmaChecksumDirectiveTrivia &&\n                                                                 !d.ContainsDiagnostics); 821946"];
1318 [label="var checksumDirectives = tree.GetRoot().GetDirectives(d => d.Kind() == SyntaxKind.PragmaChecksumDirectiveTrivia &&\n                                                                 !d.ContainsDiagnostics); 821947"];
1319 [label="foreach (var directive in checksumDirectives)\n            {\n                var checksumDirective = (PragmaChecksumDirectiveTriviaSyntax)directive;\n                var path = checksumDirective.File.ValueText;\n\n                var checksumText = checksumDirective.Bytes.ValueText;\n                var normalizedPath = documentsBuilder.NormalizeDebugDocumentPath(path, basePath: tree.FilePath);\n                var existingDoc = documentsBuilder.TryGetDebugDocumentForNormalizedPath(normalizedPath);\n\n                // duplicate checksum pragmas are valid as long as values match\n                // if we have seen this document already, check for matching values.\n                if (existingDoc != null)\n                {\n                    // pragma matches a file path on an actual tree.\n                    // Dev12 compiler just ignores the pragma in this case which means that\n                    // checksum of the actual tree always wins and no warning is given.\n                    // We will continue doing the same.\n                    if (existingDoc.IsComputedChecksum)\n                    {\n                        continue;\n                    }\n\n                    var sourceInfo = existingDoc.GetSourceInfo();\n                    if (ChecksumMatches(checksumText, sourceInfo.Checksum))\n                    {\n                        var guid = Guid.Parse(checksumDirective.Guid.ValueText);\n                        if (guid == sourceInfo.ChecksumAlgorithmId)\n                        {\n                            // all parts match, nothing to do\n                            continue;\n                        }\n                    }\n\n                    // did not match to an existing document\n                    // produce a warning and ignore the pragma\n                    diagnostics.Add(ErrorCode.WRN_ConflictingChecksum, new SourceLocation(checksumDirective), path);\n                }\n                else\n                {\n                    var newDocument = new Cci.DebugSourceDocument(\n                        normalizedPath,\n                        Cci.DebugSourceDocument.CorSymLanguageTypeCSharp,\n                        MakeChecksumBytes(checksumText),\n                        Guid.Parse(checksumDirective.Guid.ValueText));\n\n                    documentsBuilder.AddDebugDocument(newDocument);\n                }\n            } 821948"];
1320 [label="if ((emittingPdb || emitTestCoverageData) &&\n                    !CreateDebugDocuments(moduleBeingBuilt.DebugDocumentsBuilder, moduleBeingBuilt.EmbeddedTexts, diagnostics))\n                {\n                    return false;\n                } 821949"];
1321 [label="DiagnosticBag? methodBodyDiagnosticBag = DiagnosticBag.GetInstance(); 821950"];
1322 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 821951"];
1323 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 821952"];
1324 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 821953"];
1325 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 821954"];
1326 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 821955"];
1327 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 821956"];
1328 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 821957"];
1329 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 821958"];
1330 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken) 821959"];
1331 [label="param CompileMethodBodies(CSharpCompilation compilation) 821960"];
1332 [label="param CompileMethodBodies(PEModuleBuilder moduleBeingBuiltOpt) 821961"];
1333 [label="param CompileMethodBodies(bool emittingPdb) 821962"];
1334 [label="param CompileMethodBodies(bool emitTestCoverageData) 821963"];
1335 [label="param CompileMethodBodies(bool hasDeclarationErrors) 821964"];
1336 [label="param CompileMethodBodies(DiagnosticBag diagnostics) 821965"];
1337 [label="param CompileMethodBodies(Predicate<Symbol> filterOpt) 821966"];
1338 [label="param CompileMethodBodies(CancellationToken cancellationToken) 821967"];
1339 [label="Debug.Assert(compilation != null); 821968"];
1340 [label="Debug.Assert(compilation != null); 821969"];
1341 [label="Debug.Assert(diagnostics != null); 821970"];
1342 [label="Debug.Assert(diagnostics != null); 821971"];
1343 [label="compilation.PreviousSubmission 821972"];
1344 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 821973"];
1345 [label="ScriptCompilationInfo 821974"];
1346 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 821975"];
1347 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 821976"];
1348 [label="MethodSymbol entryPoint = null; 821977"];
1349 [label="if (filterOpt is null)\n            {\n                entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken);\n            } 821978"];
1350 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 821979"];
1351 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 821980"];
1352 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 821981"];
1353 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 821982"];
1354 [label="entryPoint = GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken); 821983"];
1355 [label="GetEntryPoint(compilation, moduleBeingBuiltOpt, hasDeclarationErrors, diagnostics, cancellationToken) 821984"];
1356 [label="param GetEntryPoint(CSharpCompilation compilation) 821985"];
1357 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 821986"];
1358 [label="param GetEntryPoint(bool hasDeclarationErrors) 821987"];
1359 [label="param GetEntryPoint(DiagnosticBag diagnostics) 821988"];
1360 [label="param GetEntryPoint(CancellationToken cancellationToken) 821989"];
1361 [label="var entryPointAndDiagnostics = compilation.GetEntryPointAndDiagnostics(cancellationToken); 821990"];
1362 [label="compilation.GetEntryPointAndDiagnostics(cancellationToken) 821991"];
1363 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 821992"];
1364 [label="param GetEntryPointAndDiagnostics(this) 821993"];
1365 [label="if (_lazyEntryPoint == null)\n            {\n                EntryPoint? entryPoint;\n                var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this);\n\n                if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                }\n\n                Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null);\n            } 821994"];
1366 [label="if (_lazyEntryPoint == null)\n            {\n                EntryPoint? entryPoint;\n                var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this);\n\n                if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                }\n\n                Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null);\n            } 821995"];
1367 [label="EntryPoint? entryPoint; 821996"];
1368 [label="var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this); 821997"];
1369 [label="var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this); 821998"];
1370 [label="GetBoundReferenceManager(); 821999"];
1371 [label="this.Options 822000"];
1372 [label="return _options; 822001"];
1373 [label="if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                } 822002"];
1374 [label="this.ScriptClass 822003"];
1375 [label="get { return _scriptClass.Value; } 822004"];
1376 [label="return _scriptClass.Value; 822005"];
1377 [label="_scriptClass.Value 822006"];
1378 [label="param BindScriptClass(this) 822007"];
1379 [label="return (ImplicitNamedTypeSymbol?)CommonBindScriptClass().GetSymbol(); 822008"];
1380 [label="return (ImplicitNamedTypeSymbol?)CommonBindScriptClass().GetSymbol(); 822009"];
1381 [label="get { return this.SourceModule.GetPublicSymbol(); } 822010"];
1382 [label="this.SourceModule 822011"];
1383 [label="get\n            {\n                return Assembly.Modules[0];\n            } 822012"];
1384 [label="GetBoundReferenceManager(); 822013"];
1385 [label="return this.SourceModule.GetPublicSymbol(); 822014"];
1386 [label="if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                } 822015"];
1387 [label="if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                } 822016"];
1388 [label="if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    } 822017"];
1389 [label="null 822018"];
1390 [label="ImmutableArray<Diagnostic>.Empty 822019"];
1391 [label="new EntryPoint(null, ImmutableArray<Diagnostic>.Empty) 822020"];
1392 [label="param EntryPoint(MethodSymbol? methodSymbol) 822021"];
1393 [label="param EntryPoint(ImmutableArray<Diagnostic> diagnostics) 822022"];
1394 [label="param EntryPoint(this) 822023"];
1395 [label="MethodSymbol 822024"];
1396 [label="this.MethodSymbol 822025"];
1397 [label="this.Diagnostics 822026"];
1398 [label="None = new EntryPoint(null, ImmutableArray<Diagnostic>.Empty) 822027"];
1399 [label="entryPoint = EntryPoint.None; 822028"];
1400 [label="Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null); 822029"];
1401 [label="Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null); 822030"];
1402 [label="Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null); 822031"];
1403 [label="Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null); 822032"];
1404 [label="return _lazyEntryPoint; 822033"];
1405 [label="var entryPointAndDiagnostics = compilation.GetEntryPointAndDiagnostics(cancellationToken); 822034"];
1406 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 822035"];
1407 [label="diagnostics.AddRange(entryPointAndDiagnostics.Diagnostics); 822036"];
1408 [label="diagnostics.AddRange(entryPointAndDiagnostics.Diagnostics); 822037"];
1409 [label="var entryPoint = entryPointAndDiagnostics.MethodSymbol; 822038"];
1410 [label="if ((object)entryPoint == null)\n            {\n                return null;\n            } 822039"];
1411 [label="if ((object)entryPoint == null)\n            {\n                return null;\n            } 822040"];
1412 [label="return null; 822041"];
1413 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 822042"];
1414 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 822043"];
1415 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 822044"];
1416 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 822045"];
1417 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 822046"];
1418 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 822047"];
1419 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 822048"];
1420 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 822049"];
1421 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 822050"];
1422 [label="var methodCompiler = new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken); 822051"];
1423 [label="new MethodCompiler(\n                compilation,\n                moduleBeingBuiltOpt,\n                emittingPdb,\n                emitTestCoverageData,\n                hasDeclarationErrors,\n                diagnostics,\n                filterOpt,\n                entryPoint as SynthesizedEntryPointSymbol.AsyncForwardEntryPoint,\n                cancellationToken) 822052"];
1424 [label="param MethodCompiler(CSharpCompilation compilation) 822053"];
1425 [label="param MethodCompiler(PEModuleBuilder moduleBeingBuiltOpt) 822054"];
1426 [label="param MethodCompiler(bool emittingPdb) 822055"];
1427 [label="param MethodCompiler(bool emitTestCoverageData) 822056"];
1428 [label="param MethodCompiler(bool hasDeclarationErrors) 822057"];
1429 [label="param MethodCompiler(DiagnosticBag diagnostics) 822058"];
1430 [label="param MethodCompiler(Predicate<Symbol> filterOpt) 822059"];
1431 [label="param MethodCompiler(SynthesizedEntryPointSymbol.AsyncForwardEntryPoint entryPointOpt) 822060"];
1432 [label="param MethodCompiler(CancellationToken cancellationToken) 822061"];
1433 [label="param MethodCompiler(this) 822062"];
1434 [label="param MethodCompiler(this) 822063"];
1435 [label="_compilation 822064"];
1436 [label="_emittingPdb 822065"];
1437 [label="_emitTestCoverageData 822066"];
1438 [label="_diagnostics 822067"];
1439 [label="_hasDeclarationErrors 822068"];
1440 [label="_moduleBeingBuiltOpt 822069"];
1441 [label="_filterOpt 822070"];
1442 [label="_debugDocumentProvider 822071"];
1443 [label="_entryPointOpt 822072"];
1444 [label="_compilerTasks 822073"];
1445 [label="_globalHasErrors 822074"];
1446 [label="Debug.Assert(compilation != null); 822075"];
1447 [label="Debug.Assert(compilation != null); 822076"];
1448 [label="Debug.Assert(diagnostics != null); 822077"];
1449 [label="Debug.Assert(diagnostics != null); 822078"];
1450 [label="_compilation 822079"];
1451 [label="_moduleBeingBuiltOpt 822080"];
1452 [label="_emittingPdb 822081"];
1453 [label="_cancellationToken 822082"];
1454 [label="_diagnostics 822083"];
1455 [label="_filterOpt 822084"];
1456 [label="_entryPointOpt 822085"];
1457 [label="_hasDeclarationErrors 822086"];
1458 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 822087"];
1459 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 822088"];
1460 [label="param SetGlobalErrorIfTrue(bool arg) 822089"];
1461 [label="param SetGlobalErrorIfTrue(this) 822090"];
1462 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 822091"];
1463 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 822092"];
1464 [label="if (emittingPdb || emitTestCoverageData)\n            {\n                _debugDocumentProvider = (path, basePath) => moduleBeingBuiltOpt.DebugDocumentsBuilder.GetOrAddDebugDocument(path, basePath, CreateDebugDocumentForFile);\n            } 822093"];
1465 [label="_debugDocumentProvider = (path, basePath) => moduleBeingBuiltOpt.DebugDocumentsBuilder.GetOrAddDebugDocument(path, basePath, CreateDebugDocumentForFile); 822094"];
1466 [label="_debugDocumentProvider 822095"];
1467 [label="_emitTestCoverageData 822096"];
1468 [label="compilation.Options 822097"];
1469 [label="get\n            {\n                return _options;\n            } 822098"];
1470 [label="return _options; 822099"];
1471 [label="if (compilation.Options.ConcurrentBuild)\n            {\n                methodCompiler._compilerTasks = new ConcurrentStack<Task>();\n            } 822100"];
1472 [label="methodCompiler._compilerTasks = new ConcurrentStack<Task>(); 822101"];
1473 [label="methodCompiler._compilerTasks 822102"];
1474 [label="compilation.SourceModule 822103"];
1475 [label="get\n            {\n                return Assembly.Modules[0];\n            } 822104"];
1476 [label="Assembly 822105"];
1477 [label="get\n            {\n                return SourceAssembly;\n            } 822106"];
1478 [label="SourceAssembly 822107"];
1479 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 822108"];
1480 [label="GetBoundReferenceManager() 822109"];
1481 [label="param GetBoundReferenceManager(this) 822110"];
1482 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 822111"];
1483 [label="return _referenceManager; 822112"];
1484 [label="GetBoundReferenceManager(); 822113"];
1485 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 822114"];
1486 [label="return Assembly.Modules[0]; 822115"];
1487 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace); 822116"];
1488 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace) 822117"];
1489 [label="param CompileNamespace(NamespaceSymbol symbol) 822118"];
1490 [label="param CompileNamespace(this) 822119"];
1491 [label="foreach (var s in symbol.GetMembersUnordered())\n            {\n                s.Accept(this, null);\n            } 822120"];
1492 [label="s.Accept(this, null); 822121"];
1493 [label="s.Accept(this, null); 822122"];
1494 [label="s.Accept(this, null); 822123"];
1495 [label="param VisitNamedType(NamedTypeSymbol symbol) 822124"];
1496 [label="param VisitNamedType(TypeCompilationState arg) 822125"];
1497 [label="param VisitNamedType(this) 822126"];
1498 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 822127"];
1499 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 822128"];
1500 [label="PassesFilter(_filterOpt, symbol) 822129"];
1501 [label="param PassesFilter(Predicate<Symbol> filterOpt) 822130"];
1502 [label="param PassesFilter(Symbol symbol) 822131"];
1503 [label="return (filterOpt == null) || filterOpt(symbol); 822132"];
1504 [label="return (filterOpt == null) || filterOpt(symbol); 822133"];
1505 [label="arg = null; 822134"];
1506 [label="_cancellationToken.ThrowIfCancellationRequested(); 822135"];
1507 [label="_compilation.Options 822136"];
1508 [label="get\n            {\n                return _options;\n            } 822137"];
1509 [label="if (_compilation.Options.ConcurrentBuild)\n            {\n                Task worker = CompileNamedTypeAsync(symbol);\n                _compilerTasks.Push(worker);\n            }\n            else\n            {\n                CompileNamedType(symbol);\n            } 822138"];
1510 [label="Task worker = CompileNamedTypeAsync(symbol); 822139"];
1511 [label="CompileNamedTypeAsync(symbol) 822140"];
1512 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 822141"];
1513 [label="param CompileNamedTypeAsync(this) 822142"];
1514 [label="return Task.Run(UICultureUtilities.WithCurrentUICulture(() =>\n                {\n                    try\n                    {\n                        CompileNamedType(symbol);\n                    }\n                    catch (Exception e) when (FatalError.ReportAndPropagateUnlessCanceled(e))\n                    {\n                        throw ExceptionUtilities.Unreachable;\n                    }\n                }), _cancellationToken); 822143"];
1515 [label="return Task.Run(UICultureUtilities.WithCurrentUICulture(() =>\n                {\n                    try\n                    {\n                        CompileNamedType(symbol);\n                    }\n                    catch (Exception e) when (FatalError.ReportAndPropagateUnlessCanceled(e))\n                    {\n                        throw ExceptionUtilities.Unreachable;\n                    }\n                }), _cancellationToken); 822144"];
1516 [label="Task worker = CompileNamedTypeAsync(symbol); 822145"];
1517 [label="_compilerTasks.Push(worker); 822146"];
1518 [label="return null; 822147"];
1519 [label="s.Accept(this, null); 822148"];
1520 [label="methodCompiler.CompileNamespace(compilation.SourceModule.GlobalNamespace); 822149"];
1521 [label="methodCompiler.WaitForWorkers() 822150"];
1522 [label="param WaitForWorkers(this) 822151"];
1523 [label="var tasks = _compilerTasks; 822152"];
1524 [label="if (tasks == null)\n            {\n                return;\n            } 822153"];
1525 [label="if (tasks == null)\n            {\n                return;\n            } 822154"];
1526 [label="Task curTask; 822155"];
1527 [label="while (tasks.TryPop(out curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 822156"];
1528 [label="while (tasks.TryPop(out curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 822157"];
1529 [label="curTask.GetAwaiter().GetResult(); 822158"];
1530 [label="methodCompiler.WaitForWorkers(); 822159"];
1531 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 822160"];
1532 [label="if (moduleBeingBuiltOpt != null)\n            {\n                var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics);\n\n                var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics);\n                methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics);\n\n                // By this time we have processed all types reachable from module's global namespace\n                compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics);\n                methodCompiler.WaitForWorkers();\n\n                var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass;\n                if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                }\n            } 822161"];
1533 [label="var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics); 822162"];
1534 [label="moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics) 822163"];
1535 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 822164"];
1536 [label="=> _additionalTypes 822165"];
1537 [label="_additionalTypes 822166"];
1538 [label="var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics); 822167"];
1539 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 822168"];
1540 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 822169"];
1541 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics) 822170"];
1542 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 822171"];
1543 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 822172"];
1544 [label="param CompileSynthesizedMethods(this) 822173"];
1545 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 822174"];
1546 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 822175"];
1547 [label="var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics); 822176"];
1548 [label="moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics) 822177"];
1549 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 822178"];
1550 [label="param GetEmbeddedTypes(this) 822179"];
1551 [label="var builder = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 822180"];
1552 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 822181"];
1553 [label="CreateEmbeddedAttributesIfNeeded(diagnostics) 822182"];
1554 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 822183"];
1555 [label="param CreateEmbeddedAttributesIfNeeded(this) 822184"];
1556 [label="GetNeedsGeneratedAttributes() 822185"];
1557 [label="param GetNeedsGeneratedAttributes(this) 822186"];
1558 [label="_needsGeneratedAttributes_IsFrozen = true; 822187"];
1559 [label="_needsGeneratedAttributes_IsFrozen 822188"];
1560 [label="GetNeedsGeneratedAttributesInternal() 822189"];
1561 [label="param GetNeedsGeneratedAttributesInternal(this) 822190"];
1562 [label="return (EmbeddableAttributes)_needsGeneratedAttributes | Compilation.GetNeedsGeneratedAttributes(); 822191"];
1563 [label="return GetNeedsGeneratedAttributesInternal(); 822192"];
1564 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 822193"];
1565 [label="ShouldEmitNullablePublicOnlyAttribute() 822194"];
1566 [label="param ShouldEmitNullablePublicOnlyAttribute(this) 822195"];
1567 [label="return Compilation.GetUsesNullableAttributes() && Compilation.EmitNullablePublicOnly; 822196"];
1568 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 822197"];
1569 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 822198"];
1570 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 822199"];
1571 [label="return; 822200"];
1572 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 822201"];
1573 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 822202"];
1574 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 822203"];
1575 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 822204"];
1576 [label="builder.AddIfNotNull(_lazyIsReadOnlyAttribute); 822205"];
1577 [label="builder.AddIfNotNull(_lazyIsReadOnlyAttribute); 822206"];
1578 [label="builder.AddIfNotNull(_lazyIsUnmanagedAttribute); 822207"];
1579 [label="builder.AddIfNotNull(_lazyIsUnmanagedAttribute); 822208"];
1580 [label="builder.AddIfNotNull(_lazyIsByRefLikeAttribute); 822209"];
1581 [label="builder.AddIfNotNull(_lazyIsByRefLikeAttribute); 822210"];
1582 [label="builder.AddIfNotNull(_lazyNullableAttribute); 822211"];
1583 [label="builder.AddIfNotNull(_lazyNullableAttribute); 822212"];
1584 [label="builder.AddIfNotNull(_lazyNullableContextAttribute); 822213"];
1585 [label="builder.AddIfNotNull(_lazyNullableContextAttribute); 822214"];
1586 [label="builder.AddIfNotNull(_lazyNullablePublicOnlyAttribute); 822215"];
1587 [label="builder.AddIfNotNull(_lazyNullablePublicOnlyAttribute); 822216"];
1588 [label="builder.AddIfNotNull(_lazyNativeIntegerAttribute); 822217"];
1589 [label="builder.AddIfNotNull(_lazyNativeIntegerAttribute); 822218"];
1590 [label="return builder.ToImmutableAndFree(); 822219"];
1591 [label="var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics); 822220"];
1592 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 822221"];
1593 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 822222"];
1594 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics) 822223"];
1595 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 822224"];
1596 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 822225"];
1597 [label="param CompileSynthesizedMethods(this) 822226"];
1598 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 822227"];
1599 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 822228"];
1600 [label="compilation.AnonymousTypeManager 822229"];
1601 [label="get\n            {\n                return _anonymousTypeManager;\n            } 822230"];
1602 [label="return _anonymousTypeManager; 822231"];
1603 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 822232"];
1604 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 822233"];
1605 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 822234"];
1606 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 822235"];
1607 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 822236"];
1608 [label="param GetPreviousAnonymousTypes(this) 822237"];
1609 [label="return ImmutableArray<AnonymousTypeKey>.Empty; 822238"];
1610 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 822239"];
1611 [label="param GetNextAnonymousTypeIndex(this) 822240"];
1612 [label="return 0; 822241"];
1613 [label="compilation.AnonymousTypeManager.AssignTemplatesNamesAndCompile(methodCompiler, moduleBeingBuiltOpt, diagnostics); 822242"];
1614 [label="methodCompiler.WaitForWorkers() 822243"];
1615 [label="param WaitForWorkers(this) 822244"];
1616 [label="var tasks = _compilerTasks; 822245"];
1617 [label="if (tasks == null)\n            {\n                return;\n            } 822246"];
1618 [label="if (tasks == null)\n            {\n                return;\n            } 822247"];
1619 [label="Task curTask; 822248"];
1620 [label="while (tasks.TryPop(out curTask))\n            {\n                curTask.GetAwaiter().GetResult();\n            } 822249"];
1621 [label="methodCompiler.WaitForWorkers(); 822250"];
1622 [label="var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass; 822251"];
1623 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 822252"];
1624 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 822253"];
1625 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 822254"];
1626 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 822255"];
1627 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 822256"];
1628 [label="compilation.AdditionalCodegenWarnings 822257"];
1629 [label="get\n            {\n                return _additionalCodegenWarnings;\n            } 822258"];
1630 [label="return _additionalCodegenWarnings; 822259"];
1631 [label="diagnostics.AddRange(compilation.AdditionalCodegenWarnings); 822260"];
1632 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 822261"];
1633 [label="if (filterOpt == null)\n            {\n                WarnUnusedFields(compilation, diagnostics, cancellationToken);\n\n                if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                }\n            } 822262"];
1634 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 822263"];
1635 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 822264"];
1636 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 822265"];
1637 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken) 822266"];
1638 [label="param WarnUnusedFields(CSharpCompilation compilation) 822267"];
1639 [label="param WarnUnusedFields(DiagnosticBag diagnostics) 822268"];
1640 [label="param WarnUnusedFields(CancellationToken cancellationToken) 822269"];
1641 [label="compilation.Assembly 822270"];
1642 [label="get\n            {\n                return SourceAssembly;\n            } 822271"];
1643 [label="SourceAssembly 822272"];
1644 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 822273"];
1645 [label="GetBoundReferenceManager() 822274"];
1646 [label="param GetBoundReferenceManager(this) 822275"];
1647 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 822276"];
1648 [label="return _referenceManager; 822277"];
1649 [label="GetBoundReferenceManager(); 822278"];
1650 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 822279"];
1651 [label="SourceAssemblySymbol assembly = (SourceAssemblySymbol)compilation.Assembly; 822280"];
1652 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 822281"];
1653 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 822282"];
1654 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 822283"];
1655 [label="diagnostics.AddRange(assembly.GetUnusedFieldWarnings(cancellationToken)); 822284"];
1656 [label="WarnUnusedFields(compilation, diagnostics, cancellationToken); 822285"];
1657 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 822286"];
1658 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 822287"];
1659 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 822288"];
1660 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 822289"];
1661 [label="MethodCompiler.CompileMethodBodies(\n                    this,\n                    moduleBeingBuilt,\n                    emittingPdb,\n                    emitTestCoverageData,\n                    hasDeclarationErrors,\n                    diagnostics: methodBodyDiagnosticBag,\n                    filterOpt: filterOpt,\n                    cancellationToken: cancellationToken); 822290"];
1662 [label="if (!hasDeclarationErrors && !CommonCompiler.HasUnsuppressableErrors(methodBodyDiagnosticBag))\n                {\n                    GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag);\n                } 822291"];
1663 [label="if (!hasDeclarationErrors && !CommonCompiler.HasUnsuppressableErrors(methodBodyDiagnosticBag))\n                {\n                    GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag);\n                } 822292"];
1664 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 822293"];
1665 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 822294"];
1666 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag) 822295"];
1667 [label="param GenerateModuleInitializer(PEModuleBuilder moduleBeingBuilt) 822296"];
1668 [label="param GenerateModuleInitializer(DiagnosticBag methodBodyDiagnosticBag) 822297"];
1669 [label="param GenerateModuleInitializer(this) 822298"];
1670 [label="Debug.Assert(_declarationDiagnosticsFrozen); 822299"];
1671 [label="if (_moduleInitializerMethods is object)\n            {\n                var ilBuilder = new ILBuilder(moduleBeingBuilt, new LocalSlotManager(slotAllocator: null), OptimizationLevel.Release, areLocalsZeroed: false);\n\n                foreach (MethodSymbol method in _moduleInitializerMethods.OrderBy<MethodSymbol>(LexicalOrderSymbolComparer.Instance))\n                {\n                    ilBuilder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n\n                    ilBuilder.EmitToken(\n                        moduleBeingBuilt.Translate(method, methodBodyDiagnosticBag, needDeclaration: true),\n                        CSharpSyntaxTree.Dummy.GetRoot(),\n                        methodBodyDiagnosticBag);\n                }\n\n                ilBuilder.EmitRet(isVoid: true);\n                ilBuilder.Realize();\n                moduleBeingBuilt.RootModuleType.SetStaticConstructorBody(ilBuilder.RealizedIL);\n            } 822300"];
1672 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 822301"];
1673 [label="bool hasMethodBodyError = !FilterAndAppendAndFreeDiagnostics(diagnostics, ref methodBodyDiagnosticBag, cancellationToken); 822302"];
1674 [label="bool hasMethodBodyError = !FilterAndAppendAndFreeDiagnostics(diagnostics, ref methodBodyDiagnosticBag, cancellationToken); 822303"];
1675 [label="bool hasMethodBodyError = !FilterAndAppendAndFreeDiagnostics(diagnostics, ref methodBodyDiagnosticBag, cancellationToken); 822304"];
1676 [label="bool hasMethodBodyError = !FilterAndAppendAndFreeDiagnostics(diagnostics, ref methodBodyDiagnosticBag, cancellationToken); 822305"];
1677 [label="bool hasMethodBodyError = !FilterAndAppendAndFreeDiagnostics(diagnostics, ref methodBodyDiagnosticBag, cancellationToken); 822306"];
1678 [label="if (hasDeclarationErrors || hasMethodBodyError)\n                {\n                    return false;\n                } 822307"];
1679 [label="return true; 822308"];
1680 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 822309"];
1681 [label="param GenerateResourcesAndDocumentationComments(CommonPEModuleBuilder moduleBuilder) 822310"];
1682 [label="param GenerateResourcesAndDocumentationComments(Stream? xmlDocStream) 822311"];
1683 [label="param GenerateResourcesAndDocumentationComments(Stream? win32Resources) 822312"];
1684 [label="param GenerateResourcesAndDocumentationComments(string? outputNameOverride) 822313"];
1685 [label="param GenerateResourcesAndDocumentationComments(DiagnosticBag diagnostics) 822314"];
1686 [label="param GenerateResourcesAndDocumentationComments(CancellationToken cancellationToken) 822315"];
1687 [label="param GenerateResourcesAndDocumentationComments(this) 822316"];
1688 [label="DiagnosticBag? resourceDiagnostics = DiagnosticBag.GetInstance(); 822317"];
1689 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 822318"];
1690 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 822319"];
1691 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 822320"];
1692 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 822321"];
1693 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 822322"];
1694 [label="SourceAssembly 822323"];
1695 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 822324"];
1696 [label="GetBoundReferenceManager() 822325"];
1697 [label="param GetBoundReferenceManager(this) 822326"];
1698 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 822327"];
1699 [label="return _referenceManager; 822328"];
1700 [label="GetBoundReferenceManager(); 822329"];
1701 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 822330"];
1702 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 822331"];
1703 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 822332"];
1704 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 822333"];
1705 [label="AddedModulesResourceNames(resourceDiagnostics) 822334"];
1706 [label="param AddedModulesResourceNames(DiagnosticBag diagnostics) 822335"];
1707 [label="param AddedModulesResourceNames(this) 822336"];
1708 [label="SourceAssembly 822337"];
1709 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 822338"];
1710 [label="GetBoundReferenceManager() 822339"];
1711 [label="param GetBoundReferenceManager(this) 822340"];
1712 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 822341"];
1713 [label="return _referenceManager; 822342"];
1714 [label="GetBoundReferenceManager(); 822343"];
1715 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 822344"];
1716 [label="ImmutableArray<ModuleSymbol> modules = SourceAssembly.Modules; 822345"];
1717 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 822346"];
1718 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 822347"];
1719 [label="param AddedModulesResourceNames(this) 822348"];
1720 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 822349"];
1721 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 822350"];
1722 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 822351"];
1723 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 822352"];
1724 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 822353"];
1725 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 822354"];
1726 [label="cancellationToken.ThrowIfCancellationRequested(); 822355"];
1727 [label="DiagnosticBag? xmlDiagnostics = DiagnosticBag.GetInstance(); 822356"];
1728 [label="string? assemblyName = FileNameUtilities.ChangeExtension(outputNameOverride, extension: null); 822357"];
1729 [label="string? assemblyName = FileNameUtilities.ChangeExtension(outputNameOverride, extension: null); 822358"];
1730 [label="new[] { '\\r\\n', '\\r', '\\n' } 822359"];
1731 [label="'\\r\\n' 822360"];
1732 [label="'\\r' 822361"];
1733 [label="'\\n' 822362"];
1734 [label="new[] { '\\r\\n', '\\r', '\\n' } 822363"];
1735 [label="new[] { '\\r\\n', '\\r', '\\n' } 822364"];
1736 [label="new[] { '\\r\\n', '\\r', '\\n' } 822365"];
1737 [label="s_newLineSequences = new[] { '\\r\\n', '\\r', '\\n' } 822366"];
1738 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 822367"];
1739 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 822368"];
1740 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 822369"];
1741 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 822370"];
1742 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 822371"];
1743 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 822372"];
1744 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken) 822373"];
1745 [label="param WriteDocumentationCommentXml(CSharpCompilation compilation) 822374"];
1746 [label="param WriteDocumentationCommentXml(string? assemblyName) 822375"];
1747 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 822376"];
1748 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 822377"];
1749 [label="param WriteDocumentationCommentXml(CancellationToken cancellationToken) 822378"];
1750 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 822379"];
1751 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 822380"];
1752 [label="StreamWriter writer = null; 822381"];
1753 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 822382"];
1754 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 822383"];
1755 [label="compilation.SourceAssembly 822384"];
1756 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 822385"];
1757 [label="GetBoundReferenceManager() 822386"];
1758 [label="param GetBoundReferenceManager(this) 822387"];
1759 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 822388"];
1760 [label="return _referenceManager; 822389"];
1761 [label="GetBoundReferenceManager(); 822390"];
1762 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 822391"];
1763 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 822392"];
1764 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 822393"];
1765 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 822394"];
1766 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 822395"];
1767 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 822396"];
1768 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 822397"];
1769 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 822398"];
1770 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 822399"];
1771 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 822400"];
1772 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 822401"];
1773 [label="param DocumentationCommentCompiler(string assemblyName) 822402"];
1774 [label="param DocumentationCommentCompiler(CSharpCompilation compilation) 822403"];
1775 [label="param DocumentationCommentCompiler(TextWriter writer) 822404"];
1776 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 822405"];
1777 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 822406"];
1778 [label="param DocumentationCommentCompiler(bool processIncludes) 822407"];
1779 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 822408"];
1780 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 822409"];
1781 [label="param DocumentationCommentCompiler(CancellationToken cancellationToken) 822410"];
1782 [label="param DocumentationCommentCompiler(this) 822411"];
1783 [label="param DocumentationCommentCompiler(this) 822412"];
1784 [label="_assemblyName 822413"];
1785 [label="_compilation 822414"];
1786 [label="_writer 822415"];
1787 [label="_filterTree 822416"];
1788 [label="_filterSpanWithinTree 822417"];
1789 [label="_processIncludes 822418"];
1790 [label="_isForSingleSymbol 822419"];
1791 [label="_diagnostics 822420"];
1792 [label="_lazyComparer 822421"];
1793 [label="_includedFileCache 822422"];
1794 [label="_indentDepth 822423"];
1795 [label="_temporaryStringBuilders 822424"];
1796 [label="_assemblyName 822425"];
1797 [label="_compilation 822426"];
1798 [label="_writer 822427"];
1799 [label="_filterTree 822428"];
1800 [label="_filterSpanWithinTree 822429"];
1801 [label="_processIncludes 822430"];
1802 [label="_isForSingleSymbol 822431"];
1803 [label="_diagnostics 822432"];
1804 [label="_cancellationToken 822433"];
1805 [label="compilation.SourceAssembly 822434"];
1806 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 822435"];
1807 [label="GetBoundReferenceManager() 822436"];
1808 [label="param GetBoundReferenceManager(this) 822437"];
1809 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 822438"];
1810 [label="return _referenceManager; 822439"];
1811 [label="GetBoundReferenceManager(); 822440"];
1812 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 822441"];
1813 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 822442"];
1814 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 822443"];
1815 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 822444"];
1816 [label="param VisitNamespace(NamespaceSymbol symbol) 822445"];
1817 [label="param VisitNamespace(this) 822446"];
1818 [label="_cancellationToken.ThrowIfCancellationRequested(); 822447"];
1819 [label="if (symbol.IsGlobalNamespace)\n            {\n                Debug.Assert(_assemblyName != null);\n\n                WriteLine('<?xml version=\\'1.0\\'?>');\n                WriteLine('<doc>');\n                Indent();\n\n                if (!_compilation.Options.OutputKind.IsNetModule())\n                {\n                    WriteLine('<assembly>');\n                    Indent();\n                    WriteLine('<name>{0}</name>', _assemblyName);\n                    Unindent();\n                    WriteLine('</assembly>');\n                }\n\n                WriteLine('<members>');\n                Indent();\n            } 822448"];
1820 [label="Debug.Assert(_assemblyName != null); 822449"];
1821 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 822450"];
1822 [label="WriteLine('<?xml version=\\'1.0\\'?>') 822451"];
1823 [label="param WriteLine(string message) 822452"];
1824 [label="param WriteLine(this) 822453"];
1825 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822454"];
1826 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822455"];
1827 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822456"];
1828 [label="WriteLine('<doc>'); 822457"];
1829 [label="WriteLine('<doc>') 822458"];
1830 [label="param WriteLine(string message) 822459"];
1831 [label="param WriteLine(this) 822460"];
1832 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822461"];
1833 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822462"];
1834 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822463"];
1835 [label="Indent() 822464"];
1836 [label="param Indent(this) 822465"];
1837 [label="_indentDepth 822466"];
1838 [label="Indent(); 822467"];
1839 [label="_compilation.Options 822468"];
1840 [label="if (!_compilation.Options.OutputKind.IsNetModule())\n                {\n                    WriteLine('<assembly>');\n                    Indent();\n                    WriteLine('<name>{0}</name>', _assemblyName);\n                    Unindent();\n                    WriteLine('</assembly>');\n                } 822469"];
1841 [label="WriteLine('<assembly>'); 822470"];
1842 [label="WriteLine('<assembly>') 822471"];
1843 [label="param WriteLine(string message) 822472"];
1844 [label="param WriteLine(this) 822473"];
1845 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822474"];
1846 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822475"];
1847 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822476"];
1848 [label="Indent() 822477"];
1849 [label="param Indent(this) 822478"];
1850 [label="_indentDepth 822479"];
1851 [label="Indent(); 822480"];
1852 [label="WriteLine('<name>{0}</name>', _assemblyName); 822481"];
1853 [label="WriteLine('<name>{0}</name>', _assemblyName) 822482"];
1854 [label="WriteLine('<name>{0}</name>', _assemblyName) 822483"];
1855 [label="param WriteLine(string format) 822484"];
1856 [label="param WriteLine(params object[] args) 822485"];
1857 [label="param WriteLine(this) 822486"];
1858 [label="WriteLine(string.Format(format, args)); 822487"];
1859 [label="WriteLine(string.Format(format, args)); 822488"];
1860 [label="WriteLine(string.Format(format, args)); 822489"];
1861 [label="WriteLine(string.Format(format, args)) 822490"];
1862 [label="param WriteLine(string message) 822491"];
1863 [label="param WriteLine(this) 822492"];
1864 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822493"];
1865 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822494"];
1866 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822495"];
1867 [label="WriteLine(string.Format(format, args)); 822496"];
1868 [label="Unindent() 822497"];
1869 [label="param Unindent(this) 822498"];
1870 [label="_indentDepth 822499"];
1871 [label="Debug.Assert(_indentDepth >= 0); 822500"];
1872 [label="Debug.Assert(_indentDepth >= 0); 822501"];
1873 [label="Unindent(); 822502"];
1874 [label="WriteLine('</assembly>'); 822503"];
1875 [label="WriteLine('</assembly>') 822504"];
1876 [label="param WriteLine(string message) 822505"];
1877 [label="param WriteLine(this) 822506"];
1878 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822507"];
1879 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822508"];
1880 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822509"];
1881 [label="WriteLine('<members>'); 822510"];
1882 [label="WriteLine('<members>') 822511"];
1883 [label="param WriteLine(string message) 822512"];
1884 [label="param WriteLine(this) 822513"];
1885 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822514"];
1886 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822515"];
1887 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822516"];
1888 [label="Indent() 822517"];
1889 [label="param Indent(this) 822518"];
1890 [label="_indentDepth 822519"];
1891 [label="Indent(); 822520"];
1892 [label="Debug.Assert(!_isForSingleSymbol); 822521"];
1893 [label="foreach (var s in symbol.GetMembers())\n            {\n                _cancellationToken.ThrowIfCancellationRequested();\n                s.Accept(this);\n            } 822522"];
1894 [label="_cancellationToken.ThrowIfCancellationRequested(); 822523"];
1895 [label="s.Accept(this); 822524"];
1896 [label="s.Accept(this); 822525"];
1897 [label="s.Accept(this); 822526"];
1898 [label="param VisitNamedType(NamedTypeSymbol symbol) 822527"];
1899 [label="param VisitNamedType(this) 822528"];
1900 [label="_cancellationToken.ThrowIfCancellationRequested(); 822529"];
1901 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 822530"];
1902 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 822531"];
1903 [label="DefaultVisit(symbol); 822532"];
1904 [label="DefaultVisit(symbol) 822533"];
1905 [label="param DefaultVisit(Symbol symbol) 822534"];
1906 [label="param DefaultVisit(this) 822535"];
1907 [label="_cancellationToken.ThrowIfCancellationRequested(); 822536"];
1908 [label="if (ShouldSkip(symbol))\n            {\n                return;\n            } 822537"];
1909 [label="ShouldSkip(symbol) 822538"];
1910 [label="param ShouldSkip(Symbol symbol) 822539"];
1911 [label="return symbol.IsImplicitlyDeclared ||\n                symbol.IsAccessor() ||\n                symbol is SynthesizedSimpleProgramEntryPointSymbol ||\n                symbol is SimpleProgramNamedTypeSymbol ||\n                symbol is SynthesizedRecordPropertySymbol; 822540"];
1912 [label="return symbol.IsImplicitlyDeclared ||\n                symbol.IsAccessor() ||\n                symbol is SynthesizedSimpleProgramEntryPointSymbol ||\n                symbol is SimpleProgramNamedTypeSymbol ||\n                symbol is SynthesizedRecordPropertySymbol; 822541"];
1913 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 822542"];
1914 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 822543"];
1915 [label="bool isPartialMethodDefinitionPart = symbol.IsPartialDefinition(); 822544"];
1916 [label="bool isPartialMethodDefinitionPart = symbol.IsPartialDefinition(); 822545"];
1917 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 822546"];
1918 [label="DocumentationMode maxDocumentationMode; 822547"];
1919 [label="ImmutableArray<DocumentationCommentTriviaSyntax> docCommentNodes; 822548"];
1920 [label="docCommentNodes 822549"];
1921 [label="if (!TryGetDocumentationCommentNodes(symbol, out maxDocumentationMode, out docCommentNodes))\n            {\n                // If the XML in any of the doc comments is invalid, skip all further processing (for this symbol) and \n                // just write a comment saying that info was lost for this symbol.\n                string message = ErrorFacts.GetMessage(MessageID.IDS_XMLIGNORED, CultureInfo.CurrentUICulture);\n                WriteLine(string.Format(CultureInfo.CurrentUICulture, message, symbol.GetDocumentationCommentId()));\n                return;\n            } 822550"];
1922 [label="if (!TryGetDocumentationCommentNodes(symbol, out maxDocumentationMode, out docCommentNodes))\n            {\n                // If the XML in any of the doc comments is invalid, skip all further processing (for this symbol) and \n                // just write a comment saying that info was lost for this symbol.\n                string message = ErrorFacts.GetMessage(MessageID.IDS_XMLIGNORED, CultureInfo.CurrentUICulture);\n                WriteLine(string.Format(CultureInfo.CurrentUICulture, message, symbol.GetDocumentationCommentId()));\n                return;\n            } 822551"];
1923 [label="if (!TryGetDocumentationCommentNodes(symbol, out maxDocumentationMode, out docCommentNodes))\n            {\n                // If the XML in any of the doc comments is invalid, skip all further processing (for this symbol) and \n                // just write a comment saying that info was lost for this symbol.\n                string message = ErrorFacts.GetMessage(MessageID.IDS_XMLIGNORED, CultureInfo.CurrentUICulture);\n                WriteLine(string.Format(CultureInfo.CurrentUICulture, message, symbol.GetDocumentationCommentId()));\n                return;\n            } 822552"];
1924 [label="TryGetDocumentationCommentNodes(symbol, out maxDocumentationMode, out docCommentNodes) 822553"];
1925 [label="param TryGetDocumentationCommentNodes(Symbol symbol) 822554"];
1926 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 822555"];
1927 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 822556"];
1928 [label="param TryGetDocumentationCommentNodes(this) 822557"];
1929 [label="maxDocumentationMode = DocumentationMode.None; 822558"];
1930 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 822559"];
1931 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 822560"];
1932 [label="foreach (SyntaxReference reference in symbol.DeclaringSyntaxReferences)\n            {\n                DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode;\n                maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode;\n\n                ImmutableArray<DocumentationCommentTriviaSyntax> triviaList = SourceDocumentationCommentUtils.GetDocumentationCommentTriviaFromSyntaxNode((CSharpSyntaxNode)reference.GetSyntax(), _diagnostics);\n                foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                }\n            } 822561"];
1933 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 822562"];
1934 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 822563"];
1935 [label="currDocumentationMode > maxDocumentationMode 822564"];
1936 [label="ImmutableArray<DocumentationCommentTriviaSyntax> triviaList = SourceDocumentationCommentUtils.GetDocumentationCommentTriviaFromSyntaxNode((CSharpSyntaxNode)reference.GetSyntax(), _diagnostics); 822565"];
1937 [label="ImmutableArray<DocumentationCommentTriviaSyntax> triviaList = SourceDocumentationCommentUtils.GetDocumentationCommentTriviaFromSyntaxNode((CSharpSyntaxNode)reference.GetSyntax(), _diagnostics); 822566"];
1938 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 822567"];
1939 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 822568"];
1940 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 822569"];
1941 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 822570"];
1942 [label="return true; 822571"];
1943 [label="if (!TryGetDocumentationCommentNodes(symbol, out maxDocumentationMode, out docCommentNodes))\n            {\n                // If the XML in any of the doc comments is invalid, skip all further processing (for this symbol) and \n                // just write a comment saying that info was lost for this symbol.\n                string message = ErrorFacts.GetMessage(MessageID.IDS_XMLIGNORED, CultureInfo.CurrentUICulture);\n                WriteLine(string.Format(CultureInfo.CurrentUICulture, message, symbol.GetDocumentationCommentId()));\n                return;\n            } 822572"];
1944 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 822573"];
1945 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 822574"];
1946 [label="return; 822575"];
1947 [label="DefaultVisit(symbol); 822576"];
1948 [label="if (!_isForSingleSymbol)\n            {\n                foreach (Symbol member in symbol.GetMembers())\n                {\n                    _cancellationToken.ThrowIfCancellationRequested();\n                    member.Accept(this);\n                }\n            } 822577"];
1949 [label="foreach (Symbol member in symbol.GetMembers())\n                {\n                    _cancellationToken.ThrowIfCancellationRequested();\n                    member.Accept(this);\n                } 822578"];
1950 [label="if (symbol.IsGlobalNamespace)\n            {\n                Unindent();\n                WriteLine('</members>');\n                Unindent();\n                WriteLine('</doc>');\n            } 822579"];
1951 [label="Unindent() 822580"];
1952 [label="Debug.Assert(_indentDepth >= 0); 822581"];
1953 [label="Unindent(); 822582"];
1954 [label="WriteLine('</members>'); 822583"];
1955 [label="WriteLine('</members>') 822584"];
1956 [label="param WriteLine(string message) 822585"];
1957 [label="param WriteLine(this) 822586"];
1958 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822587"];
1959 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822588"];
1960 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822589"];
1961 [label="Unindent() 822590"];
1962 [label="_indentDepth 822591"];
1963 [label="Debug.Assert(_indentDepth >= 0); 822592"];
1964 [label="Debug.Assert(_indentDepth >= 0); 822593"];
1965 [label="Unindent(); 822594"];
1966 [label="WriteLine('</doc>'); 822595"];
1967 [label="WriteLine('</doc>') 822596"];
1968 [label="param WriteLine(string message) 822597"];
1969 [label="param WriteLine(this) 822598"];
1970 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822599"];
1971 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822600"];
1972 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 822601"];
1973 [label="Debug.Assert(compiler._indentDepth == 0); 822602"];
1974 [label="Debug.Assert(compiler._indentDepth == 0); 822603"];
1975 [label="writer?.Flush(); 822604"];
1976 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 822605"];
1977 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 822606"];
1978 [label="compilation.SyntaxTrees 822607"];
1979 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 822608"];
1980 [label="_syntaxAndDeclarations.GetLazyState() 822609"];
1981 [label="param GetLazyState(this) 822610"];
1982 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 822611"];
1983 [label="foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                } 822612"];
1984 [label="UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken); 822613"];
1985 [label="UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken); 822614"];
1986 [label="UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken); 822615"];
1987 [label="UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken) 822616"];
1988 [label="param ReportUnprocessed(SyntaxTree tree) 822617"];
1989 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 822618"];
1990 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 822619"];
1991 [label="param ReportUnprocessed(CancellationToken cancellationToken) 822620"];
1992 [label="if (tree.ReportDocumentationCommentDiagnostics())\n            {\n                UnprocessedDocumentationCommentFinder finder = new UnprocessedDocumentationCommentFinder(diagnostics, filterSpanWithinTree, cancellationToken);\n                finder.Visit(tree.GetRoot(cancellationToken));\n            } 822621"];
1993 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 822622"];
1994 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 822623"];
1995 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 822624"];
1996 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 822625"];
1997 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 822626"];
1998 [label="param ReportUnusedImports(SyntaxTree? filterTree) 822627"];
1999 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 822628"];
2000 [label="param ReportUnusedImports(CancellationToken cancellationToken) 822629"];
2001 [label="param ReportUnusedImports(this) 822630"];
2002 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 822631"];
2003 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 822632"];
2004 [label="CompleteTrees(filterTree); 822633"];
2005 [label="CompleteTrees(filterTree) 822634"];
2006 [label="param CompleteTrees(SyntaxTree? filterTree) 822635"];
2007 [label="param CompleteTrees(this) 822636"];
2008 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 822637"];
2009 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 822638"];
2010 [label="CompleteTrees(filterTree); 822639"];
2011 [label="get { return this.SourceModule.GetPublicSymbol(); } 822640"];
2012 [label="this.SourceModule 822641"];
2013 [label="get\n            {\n                return Assembly.Modules[0];\n            } 822642"];
2014 [label="Assembly 822643"];
2015 [label="get\n            {\n                return SourceAssembly;\n            } 822644"];
2016 [label="SourceAssembly 822645"];
2017 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 822646"];
2018 [label="GetBoundReferenceManager() 822647"];
2019 [label="param GetBoundReferenceManager(this) 822648"];
2020 [label="GetBoundReferenceManager(); 822649"];
2021 [label="return Assembly.Modules[0]; 822650"];
2022 [label="get { return SourceAssembly.IsDelaySigned; } 822651"];
2023 [label="SourceAssembly 822652"];
2024 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 822653"];
2025 [label="GetBoundReferenceManager() 822654"];
2026 [label="param GetBoundReferenceManager(this) 822655"];
2027 [label="GetBoundReferenceManager(); 822656"];
2028 [label="SourceAssembly.IsDelaySigned 822657"];
2029 [label="get { return SourceAssembly.StrongNameKeys; } 822658"];
2030 [label="SourceAssembly 822659"];
2031 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 822660"];
2032 [label="GetBoundReferenceManager() 822661"];
2033 [label="param GetBoundReferenceManager(this) 822662"];
2034 [label="GetBoundReferenceManager(); 822663"];
2035 [label="param GetCorLibraryReferenceToEmit(CodeAnalysis.Emit.EmitContext context) 822664"];
2036 [label="param GetCorLibraryReferenceToEmit(this) 822665"];
2037 [label="CorLibrary 822666"];
2038 [label="get { return SourceModule.ContainingSourceAssembly.CorLibrary; } 822667"];
2039 [label="return SourceModule.ContainingSourceAssembly.CorLibrary; 822668"];
2040 [label="AssemblySymbol corLibrary = CorLibrary; 822669"];
2041 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 822670"];
2042 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 822671"];
2043 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 822672"];
2044 [label="return null; 822673"];
2045 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 822674"];
2046 [label="param GetAssemblyReferencesFromAddedModules(DiagnosticBag diagnostics) 822675"];
2047 [label="param GetAssemblyReferencesFromAddedModules(this) 822676"];
2048 [label="ImmutableArray<ModuleSymbol> modules = SourceModule.ContainingAssembly.Modules; 822677"];
2049 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 822678"];
2050 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 822679"];
2051 [label="param GetAssemblyReferencesFromAddedModules(this) 822680"];
2052 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 822681"];
2053 [label="param GetFiles(EmitContext context) 822682"];
2054 [label="param GetFiles(this) 822683"];
2055 [label="if (!context.IsRefAssembly)\n            {\n                return getFiles(ref _lazyFiles, context, _sourceAssembly);\n            } 822684"];
2056 [label="return getFiles(ref _lazyFiles, context, _sourceAssembly); 822685"];
2057 [label="return getFiles(ref _lazyFiles, context, _sourceAssembly); 822686"];
2058 [label="getFiles(ref _lazyFiles, context, _sourceAssembly) 822687"];
2059 [label="ImmutableArray<Cci.IFileReference> getFiles(ref ImmutableArray<Cci.IFileReference> lazyFiles, EmitContext contxt, SourceAssemblySymbol sourceAssSymbol)\n            {\n                if (lazyFiles.IsDefault)\n                {\n                    var builder = ArrayBuilder<Cci.IFileReference>.GetInstance();\n                    try\n                    {\n                        var modules = sourceAssSymbol.Modules;\n                        for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        }\n\n                        if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        }\n\n                        // Dev12 compilers don't report ERR_CryptoHashFailed if there are no files to be hashed.\n                        if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        builder.Free();\n                    }\n                }\n\n                return lazyFiles;\n            } 822688"];
2060 [label="ImmutableArray<Cci.IFileReference> getFiles(ref ImmutableArray<Cci.IFileReference> lazyFiles, EmitContext contxt, SourceAssemblySymbol sourceAssSymbol)\n            {\n                if (lazyFiles.IsDefault)\n                {\n                    var builder = ArrayBuilder<Cci.IFileReference>.GetInstance();\n                    try\n                    {\n                        var modules = sourceAssSymbol.Modules;\n                        for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        }\n\n                        if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        }\n\n                        // Dev12 compilers don't report ERR_CryptoHashFailed if there are no files to be hashed.\n                        if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        builder.Free();\n                    }\n                }\n\n                return lazyFiles;\n            } 822689"];
2061 [label="ImmutableArray<Cci.IFileReference> getFiles(ref ImmutableArray<Cci.IFileReference> lazyFiles, EmitContext contxt, SourceAssemblySymbol sourceAssSymbol)\n            {\n                if (lazyFiles.IsDefault)\n                {\n                    var builder = ArrayBuilder<Cci.IFileReference>.GetInstance();\n                    try\n                    {\n                        var modules = sourceAssSymbol.Modules;\n                        for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        }\n\n                        if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        }\n\n                        // Dev12 compilers don't report ERR_CryptoHashFailed if there are no files to be hashed.\n                        if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        builder.Free();\n                    }\n                }\n\n                return lazyFiles;\n            } 822690"];
2062 [label="if (lazyFiles.IsDefault)\n                {\n                    var builder = ArrayBuilder<Cci.IFileReference>.GetInstance();\n                    try\n                    {\n                        var modules = sourceAssSymbol.Modules;\n                        for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        }\n\n                        if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        }\n\n                        // Dev12 compilers don't report ERR_CryptoHashFailed if there are no files to be hashed.\n                        if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        builder.Free();\n                    }\n                } 822691"];
2063 [label="var builder = ArrayBuilder<Cci.IFileReference>.GetInstance(); 822692"];
2064 [label="var modules = sourceAssSymbol.Modules; 822693"];
2065 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 822694"];
2066 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 822695"];
2067 [label="if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        } 822696"];
2068 [label="foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            } 822697"];
2069 [label="if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        } 822698"];
2070 [label="if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        } 822699"];
2071 [label="if (ImmutableInterlocked.InterlockedInitialize(ref lazyFiles, builder.ToImmutable()) && lazyFiles.Length > 0)\n                        {\n                            if (!CryptographicHashProvider.IsSupportedAlgorithm(sourceAssSymbol.HashAlgorithm))\n                            {\n                                contxt.Diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_CryptoHashFailed), NoLocation.Singleton));\n                            }\n                        } 822700"];
2072 [label="builder.Free(); 822701"];
2073 [label="return lazyFiles; 822702"];
2074 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 822703"];
2075 [label="=> _embeddedTypesManagerOpt 822704"];
2076 [label="_embeddedTypesManagerOpt 822705"];
2077 [label="param GetAnonymousTypeDefinitions(EmitContext context) 822706"];
2078 [label="param GetAnonymousTypeDefinitions(this) 822707"];
2079 [label="if (context.MetadataOnly)\n            {\n                return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>();\n            } 822708"];
2080 [label="Compilation.AnonymousTypeManager 822709"];
2081 [label="get\n            {\n                return _anonymousTypeManager;\n            } 822710"];
2082 [label="return Compilation.AnonymousTypeManager.GetAllCreatedTemplates()\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n\n#endif\n                   ; 822711"];
2083 [label="return Compilation.AnonymousTypeManager.GetAllCreatedTemplates()\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n\n#endif\n                   ; 822712"];
2084 [label="param GetAdditionalTopLevelTypeDefinitions(EmitContext context) 822713"];
2085 [label="param GetAdditionalTopLevelTypeDefinitions(this) 822714"];
2086 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 822715"];
2087 [label="GetAdditionalTopLevelTypes(context.Diagnostics) 822716"];
2088 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 822717"];
2089 [label="=> _additionalTypes 822718"];
2090 [label="_additionalTypes 822719"];
2091 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 822720"];
2092 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 822721"];
2093 [label="param GetEmbeddedTypeDefinitions(EmitContext context) 822722"];
2094 [label="param GetEmbeddedTypeDefinitions(this) 822723"];
2095 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 822724"];
2096 [label="GetEmbeddedTypes(context.Diagnostics) 822725"];
2097 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 822726"];
2098 [label="param GetEmbeddedTypes(this) 822727"];
2099 [label="var builder = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 822728"];
2100 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 822729"];
2101 [label="CreateEmbeddedAttributesIfNeeded(diagnostics) 822730"];
2102 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 822731"];
2103 [label="param CreateEmbeddedAttributesIfNeeded(this) 822732"];
2104 [label="GetNeedsGeneratedAttributes() 822733"];
2105 [label="param GetNeedsGeneratedAttributes(this) 822734"];
2106 [label="_needsGeneratedAttributes_IsFrozen = true; 822735"];
2107 [label="_needsGeneratedAttributes_IsFrozen 822736"];
2108 [label="GetNeedsGeneratedAttributesInternal() 822737"];
2109 [label="param GetNeedsGeneratedAttributesInternal(this) 822738"];
2110 [label="return (EmbeddableAttributes)_needsGeneratedAttributes | Compilation.GetNeedsGeneratedAttributes(); 822739"];
2111 [label="return GetNeedsGeneratedAttributesInternal(); 822740"];
2112 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 822741"];
2113 [label="ShouldEmitNullablePublicOnlyAttribute() 822742"];
2114 [label="param ShouldEmitNullablePublicOnlyAttribute(this) 822743"];
2115 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 822744"];
2116 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 822745"];
2117 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 822746"];
2118 [label="return; 822747"];
2119 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 822748"];
2120 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 822749"];
2121 [label="builder.AddIfNotNull(_lazyIsReadOnlyAttribute); 822750"];
2122 [label="builder.AddIfNotNull(_lazyIsUnmanagedAttribute); 822751"];
2123 [label="builder.AddIfNotNull(_lazyIsByRefLikeAttribute); 822752"];
2124 [label="builder.AddIfNotNull(_lazyNullableAttribute); 822753"];
2125 [label="builder.AddIfNotNull(_lazyNullableContextAttribute); 822754"];
2126 [label="builder.AddIfNotNull(_lazyNullablePublicOnlyAttribute); 822755"];
2127 [label="builder.AddIfNotNull(_lazyNativeIntegerAttribute); 822756"];
2128 [label="return builder.ToImmutableAndFree(); 822757"];
2129 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 822758"];
2130 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 822759"];
2131 [label="param GetTopLevelSourceTypeDefinitions(EmitContext context) 822760"];
2132 [label="param GetTopLevelSourceTypeDefinitions(this) 822761"];
2133 [label="var namespacesToProcess = new Stack<NamespaceSymbol>(); 822762"];
2134 [label="namespacesToProcess.Push(SourceModule.GlobalNamespace); 822763"];
2135 [label="namespacesToProcess.Push(SourceModule.GlobalNamespace); 822764"];
2136 [label="while (namespacesToProcess.Count > 0)\n            {\n                var ns = namespacesToProcess.Pop();\n                foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                }\n            } 822765"];
2137 [label="while (namespacesToProcess.Count > 0)\n            {\n                var ns = namespacesToProcess.Pop();\n                foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                }\n            } 822766"];
2138 [label="var ns = namespacesToProcess.Pop(); 822767"];
2139 [label="foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                } 822768"];
2140 [label="if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    } 822769"];
2141 [label="yield return ((NamedTypeSymbol)member).GetCciAdapter(); 822770"];
2142 [label="yield return ((NamedTypeSymbol)member).GetCciAdapter(); 822771"];
2143 [label="new LexicalOrderSymbolComparer() 822772"];
2144 [label="param LexicalOrderSymbolComparer(this) 822773"];
2145 [label="Instance = new LexicalOrderSymbolComparer() 822774"];
2146 [label="param GetSynthesizedNestedTypes(NamedTypeSymbol container) 822775"];
2147 [label="param GetSynthesizedNestedTypes(this) 822776"];
2148 [label="return null; 822777"];
2149 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 822778"];
2150 [label="param GetSourceAssemblyAttributes(bool isRefAssembly) 822779"];
2151 [label="param GetSourceAssemblyAttributes(this) 822780"];
2152 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 822781"];
2153 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 822782"];
2154 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 822783"];
2155 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 822784"];
2156 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 822785"];
2157 [label="SourceAssembly 822786"];
2158 [label="GetBoundReferenceManager() 822787"];
2159 [label="GetBoundReferenceManager(); 822788"];
2160 [label="param GetUnaliasedReferencedAssemblies(ArrayBuilder<AssemblySymbol> assemblies) 822789"];
2161 [label="param GetUnaliasedReferencedAssemblies(this) 822790"];
2162 [label="GetBoundReferenceManager() 822791"];
2163 [label="param GetBoundReferenceManager(this) 822792"];
2164 [label="var referenceManager = GetBoundReferenceManager(); 822793"];
2165 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 822794"];
2166 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 822795"];
2167 [label="param GetSourceAssemblySecurityAttributes(this) 822796"];
2168 [label="return SourceModule.ContainingSourceAssembly.GetSecurityAttributes(); 822797"];
2169 [label="return SourceModule.ContainingSourceAssembly.GetSecurityAttributes(); 822798"];
2170 [label="return SourceModule.ContainingSourceAssembly.CorLibrary; 822799"];
2171 [label="AssemblySymbol corLibrary = CorLibrary; 822800"];
2172 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 822801"];
2173 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 822802"];
2174 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 822803"];
2175 [label="ImmutableArray<ModuleSymbol> modules = SourceModule.ContainingAssembly.Modules; 822804"];
2176 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 822805"];
2177 [label="param GetSourceModuleAttributes(this) 822806"];
2178 [label="return SourceModule.GetCustomAttributesToEmit(this); 822807"];
2179 [label="return SourceModule.GetCustomAttributesToEmit(this); 822808"];
2180 [label="return SourceModule.GetCustomAttributesToEmit(this); 822809"];
2181 [label="if (context.MetadataOnly)\n            {\n                return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>();\n            } 822810"];
2182 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 822811"];
2183 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 822812"];
2184 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 822813"];
2185 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 822814"];
2186 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 822815"];
2187 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 822816"];
2188 [label="return GetNeedsGeneratedAttributesInternal(); 822817"];
2189 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 822818"];
2190 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 822819"];
2191 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 822820"];
2192 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 822821"];
2193 [label="return; 822822"];
2194 [label="param ShouldEmitNullableAttributes(Symbol symbol) 822823"];
2195 [label="param ShouldEmitNullableAttributes(this) 822824"];
2196 [label="RoslynDebug.Assert(symbol is object); 822825"];
2197 [label="Debug.Assert(symbol.IsDefinition); 822826"];
2198 [label="SourceModule 822827"];
2199 [label="get\n            {\n                return Assembly.Modules[0];\n            } 822828"];
2200 [label="Assembly 822829"];
2201 [label="get\n            {\n                return SourceAssembly;\n            } 822830"];
2202 [label="SourceAssembly 822831"];
2203 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 822832"];
2204 [label="GetBoundReferenceManager() 822833"];
2205 [label="param GetBoundReferenceManager(this) 822834"];
2206 [label="GetBoundReferenceManager(); 822835"];
2207 [label="return Assembly.Modules[0]; 822836"];
2208 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 822837"];
2209 [label="EmitNullablePublicOnly 822838"];
2210 [label="get\n            {\n                if (!_lazyEmitNullablePublicOnly.HasValue())\n                {\n                    // Lafhis\n                    var firstSt = SyntaxTrees.FirstOrDefault();\n                    bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true;\n                    _lazyEmitNullablePublicOnly = value.ToThreeState();\n                }\n                return _lazyEmitNullablePublicOnly.Value();\n            } 822839"];
2211 [label="param GetExportedTypes(DiagnosticBag diagnostics) 822840"];
2212 [label="param GetExportedTypes(this) 822841"];
2213 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 822842"];
2214 [label="if (_lazyExportedTypes.IsDefault)\n            {\n                _lazyExportedTypes = CalculateExportedTypes();\n\n                if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                }\n            } 822843"];
2215 [label="CalculateExportedTypes() 822844"];
2216 [label="param CalculateExportedTypes(this) 822845"];
2217 [label="SourceAssemblySymbol sourceAssembly = SourceModule.ContainingSourceAssembly; 822846"];
2218 [label="var builder = ArrayBuilder<Cci.ExportedType>.GetInstance(); 822847"];
2219 [label="if (!OutputKind.IsNetModule())\n            {\n                var modules = sourceAssembly.Modules;\n                for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                }\n            } 822848"];
2220 [label="var modules = sourceAssembly.Modules; 822849"];
2221 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 822850"];
2222 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 822851"];
2223 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 822852"];
2224 [label="sourceAssembly.DeclaringCompilation.Options 822853"];
2225 [label="get\n            {\n                return _options;\n            } 822854"];
2226 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 822855"];
2227 [label="GetForwardedTypes(sourceAssembly, builder); 822856"];
2228 [label="GetForwardedTypes(sourceAssembly, builder); 822857"];
2229 [label="GetForwardedTypes(sourceAssembly, builder) 822858"];
2230 [label="param GetForwardedTypes(SourceAssemblySymbol sourceAssembly) 822859"];
2231 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 822860"];
2232 [label="var seenTopLevelForwardedTypes = new HashSet<NamedTypeSymbol>(); 822861"];
2233 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder); 822862"];
2234 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder); 822863"];
2235 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder); 822864"];
2236 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder) 822865"];
2237 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 822866"];
2238 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 822867"];
2239 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 822868"];
2240 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 822869"];
2241 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 822870"];
2242 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder); 822871"];
2243 [label="sourceAssembly.DeclaringCompilation.Options 822872"];
2244 [label="get\n            {\n                return _options;\n            } 822873"];
2245 [label="if (!sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule())\n            {\n                GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder);\n            } 822874"];
2246 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder); 822875"];
2247 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder); 822876"];
2248 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder); 822877"];
2249 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder) 822878"];
2250 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 822879"];
2251 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 822880"];
2252 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 822881"];
2253 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 822882"];
2254 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 822883"];
2255 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder); 822884"];
2256 [label="return seenTopLevelForwardedTypes; 822885"];
2257 [label="GetForwardedTypes(sourceAssembly, builder); 822886"];
2258 [label="return builder.ToImmutableAndFree(); 822887"];
2259 [label="_lazyExportedTypes = CalculateExportedTypes(); 822888"];
2260 [label="_lazyExportedTypes 822889"];
2261 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 822890"];
2262 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 822891"];
2263 [label="return _lazyExportedTypes; 822892"];
2264 [label="param AddEmbeddedResourcesFromAddedModules(ArrayBuilder<Cci.ManagedResource> builder) 822893"];
2265 [label="param AddEmbeddedResourcesFromAddedModules(DiagnosticBag diagnostics) 822894"];
2266 [label="param AddEmbeddedResourcesFromAddedModules(this) 822895"];
2267 [label="var modules = _sourceAssembly.Modules; 822896"];
2268 [label="int count = modules.Length; 822897"];
2269 [label="for (int i = 1; i < count; i++)\n            {\n                var file = (Cci.IFileReference)Translate(modules[i], diagnostics);\n\n                try\n                {\n                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow())\n                    {\n                        builder.Add(new Cci.ManagedResource(\n                            resource.Name,\n                            (resource.Attributes & ManifestResourceAttributes.Public) != 0,\n                            null,\n                            file,\n                            resource.Offset));\n                    }\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, modules[i]), NoLocation.Singleton);\n                }\n            } 822898"];
2270 [label="for (int i = 1; i < count; i++)\n            {\n                var file = (Cci.IFileReference)Translate(modules[i], diagnostics);\n\n                try\n                {\n                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow())\n                    {\n                        builder.Add(new Cci.ManagedResource(\n                            resource.Name,\n                            (resource.Attributes & ManifestResourceAttributes.Public) != 0,\n                            null,\n                            file,\n                            resource.Offset));\n                    }\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, modules[i]), NoLocation.Singleton);\n                }\n            } 822899"];
2271 [label="=> ImmutableArray<Cci.UsedNamespaceOrType>.Empty 822900"];
2272 [label="ImmutableArray<Cci.UsedNamespaceOrType>.Empty 822901"];
2273 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 822902"];
2274 [label="=> _sourceAssembly 822903"];
2275 [label="_sourceAssembly 822904"];
2276 [label="=> _metadataName 822905"];
2277 [label="_metadataName 822906"];
2278 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 822907"];
2279 [label="get { return _metadataName; } 822908"];
2280 [label="return _metadataName; 822909"];
2281 [label="param MemberVisibility(Symbol symbol) 822910"];
2282 [label="switch (symbol.DeclaredAccessibility)\n            {\n                case Accessibility.Public:\n                    return Cci.TypeMemberVisibility.Public;\n\n                case Accessibility.Private:\n                    if (symbol.ContainingType?.TypeKind == TypeKind.Submission)\n                    {\n                        // top-level private member:\n                        return Cci.TypeMemberVisibility.Public;\n                    }\n                    else\n                    {\n                        return Cci.TypeMemberVisibility.Private;\n                    }\n\n                case Accessibility.Internal:\n                    if (symbol.ContainingAssembly.IsInteractive)\n                    {\n                        // top-level or nested internal member:\n                        return Cci.TypeMemberVisibility.Public;\n                    }\n                    else\n                    {\n                        return Cci.TypeMemberVisibility.Assembly;\n                    }\n\n                case Accessibility.Protected:\n                    if (symbol.ContainingType.TypeKind == TypeKind.Submission)\n                    {\n                        // top-level protected member:\n                        return Cci.TypeMemberVisibility.Public;\n                    }\n                    else\n                    {\n                        return Cci.TypeMemberVisibility.Family;\n                    }\n\n                case Accessibility.ProtectedAndInternal:\n                    Debug.Assert(symbol.ContainingType.TypeKind != TypeKind.Submission);\n                    return Cci.TypeMemberVisibility.FamilyAndAssembly;\n\n                case Accessibility.ProtectedOrInternal:\n                    if (symbol.ContainingAssembly.IsInteractive)\n                    {\n                        // top-level or nested protected internal member:\n                        return Cci.TypeMemberVisibility.Public;\n                    }\n                    else\n                    {\n                        return Cci.TypeMemberVisibility.FamilyOrAssembly;\n                    }\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n            } 822911"];
2283 [label="return Cci.TypeMemberVisibility.Public; 822912"];
2284 [label="Debug.Assert(symbol.IsDefinition); 822913"];
2285 [label="GetBoundReferenceManager(); 822914"];
2286 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 822915"];
2287 [label="param GetSymbolToLocationMap(this) 822916"];
2288 [label="var result = new MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation>(); 822917"];
2289 [label="var namespacesAndTypesToProcess = new Stack<NamespaceOrTypeSymbol>(); 822918"];
2290 [label="namespacesAndTypesToProcess.Push(SourceModule.GlobalNamespace); 822919"];
2291 [label="namespacesAndTypesToProcess.Push(SourceModule.GlobalNamespace); 822920"];
2292 [label="Location location = null; 822921"];
2293 [label="while (namespacesAndTypesToProcess.Count > 0)\n            {\n                NamespaceOrTypeSymbol symbol = namespacesAndTypesToProcess.Pop();\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Namespace:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n\n                        // filtering out synthesized symbols not having real source \n                        // locations such as anonymous types, etc...\n                        if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    case SymbolKind.NamedType:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n                        if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n                }\n            } 822922"];
2294 [label="while (namespacesAndTypesToProcess.Count > 0)\n            {\n                NamespaceOrTypeSymbol symbol = namespacesAndTypesToProcess.Pop();\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Namespace:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n\n                        // filtering out synthesized symbols not having real source \n                        // locations such as anonymous types, etc...\n                        if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    case SymbolKind.NamedType:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n                        if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n                }\n            } 822923"];
2295 [label="NamespaceOrTypeSymbol symbol = namespacesAndTypesToProcess.Pop(); 822924"];
2296 [label="switch (symbol.Kind)\n                {\n                    case SymbolKind.Namespace:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n\n                        // filtering out synthesized symbols not having real source \n                        // locations such as anonymous types, etc...\n                        if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    case SymbolKind.NamedType:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n                        if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n                } 822925"];
2297 [label="location = GetSmallestSourceLocationOrNull(symbol); 822926"];
2298 [label="GetSmallestSourceLocationOrNull(symbol) 822927"];
2299 [label="param GetSmallestSourceLocationOrNull(Symbol symbol) 822928"];
2300 [label="param GetSmallestSourceLocationOrNull(this) 822929"];
2301 [label="CSharpCompilation compilation = symbol.DeclaringCompilation; 822930"];
2302 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 822931"];
2303 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 822932"];
2304 [label="Location result = null; 822933"];
2305 [label="foreach (var loc in symbol.Locations)\n            {\n                if (loc.IsInSource && (result == null || compilation.CompareSourceLocations(result, loc) > 0))\n                {\n                    result = loc;\n                }\n            } 822934"];
2306 [label="if (loc.IsInSource && (result == null || compilation.CompareSourceLocations(result, loc) > 0))\n                {\n                    result = loc;\n                } 822935"];
2307 [label="if (loc.IsInSource && (result == null || compilation.CompareSourceLocations(result, loc) > 0))\n                {\n                    result = loc;\n                } 822936"];
2308 [label="result = loc; 822937"];
2309 [label="return result; 822938"];
2310 [label="if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        } 822939"];
2311 [label="if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        } 822940"];
2312 [label="foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            } 822941"];
2313 [label="switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                } 822942"];
2314 [label="namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member); 822943"];
2315 [label="location = GetSmallestSourceLocationOrNull(symbol); 822944"];
2316 [label="GetSmallestSourceLocationOrNull(symbol) 822945"];
2317 [label="param GetSmallestSourceLocationOrNull(Symbol symbol) 822946"];
2318 [label="param GetSmallestSourceLocationOrNull(this) 822947"];
2319 [label="CSharpCompilation compilation = symbol.DeclaringCompilation; 822948"];
2320 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 822949"];
2321 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 822950"];
2322 [label="if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        } 822951"];
2323 [label="if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        } 822952"];
2324 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()); 822953"];
2325 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()); 822954"];
2326 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()); 822955"];
2327 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()) 822956"];
2328 [label="param AddSymbolLocation(MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation> result) 822957"];
2329 [label="param AddSymbolLocation(Location location) 822958"];
2330 [label="param AddSymbolLocation(Cci.IDefinition definition) 822959"];
2331 [label="param AddSymbolLocation(this) 822960"];
2332 [label="FileLinePositionSpan span = location.GetLineSpan(); 822961"];
2333 [label="Cci.DebugSourceDocument doc = DebugDocumentsBuilder.TryGetDebugDocument(span.Path, basePath: location.SourceTree.FilePath); 822962"];
2334 [label="Cci.DebugSourceDocument doc = DebugDocumentsBuilder.TryGetDebugDocument(span.Path, basePath: location.SourceTree.FilePath); 822963"];
2335 [label="Cci.DebugSourceDocument doc = DebugDocumentsBuilder.TryGetDebugDocument(span.Path, basePath: location.SourceTree.FilePath); 822964"];
2336 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 822965"];
2337 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 822966"];
2338 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()); 822967"];
2339 [label="foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            } 822968"];
2340 [label="return result; 822969"];
2341 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 822970"];
2342 [label="GetBoundReferenceManager(); 822971"];
2343 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 822972"];
2344 [label="c.GetEmitDiagnostics(options: options).Verify(expected) 822973"];
2345 [label="param Verify(this ImmutableArray<Diagnostic> actual) 822974"];
2346 [label="param Verify(params DiagnosticDescription[] expected) 822975"];
2347 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 822976"];
2348 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 822977"];
2349 [label="Verify((IEnumerable<Diagnostic>)actual, expected) 822978"];
2350 [label="param Verify(this IEnumerable<Diagnostic> actual) 822979"];
2351 [label="param Verify(params DiagnosticDescription[] expected) 822980"];
2352 [label="Verify(actual, expected, errorCodeOnly: false); 822981"];
2353 [label="Verify(actual, expected, errorCodeOnly: false); 822982"];
2354 [label="Verify(actual, expected, errorCodeOnly: false); 822983"];
2355 [label="Verify(actual, expected, errorCodeOnly: false) 822984"];
2356 [label="param Verify(IEnumerable<Diagnostic> actual) 822985"];
2357 [label="param Verify(DiagnosticDescription[] expected) 822986"];
2358 [label="param Verify(bool errorCodeOnly) 822987"];
2359 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 822988"];
2360 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 822989"];
2361 [label="var includeDefaultSeverity = expected.Any() && expected.All(e => e.DefaultSeverity != null); 822990"];
2362 [label="var includeEffectiveSeverity = expected.Any() && expected.All(e => e.EffectiveSeverity != null); 822991"];
2363 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 822992"];
2364 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 822993"];
2365 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 822994"];
2366 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 822995"];
2367 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 822996"];
2368 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 822997"];
2369 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 822998"];
2370 [label="{ } 822999"];
2371 [label="None = { } 823000"];
2372 [label="null 823001"];
2373 [label="Any = null 823002"];
2374 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 823003"];
2375 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 823004"];
2376 [label="DiagnosticDescription.GetAssertText(expected, actual) 823005"];
2377 [label="param GetAssertText(DiagnosticDescription[] expected) 823006"];
2378 [label="param GetAssertText(IEnumerable<Diagnostic> actual) 823007"];
2379 [label="const int CSharp = 1; 823008"];
2380 [label="const int VisualBasic = 2; 823009"];
2381 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 823010"];
2382 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 823011"];
2383 [label="actual.Any() && actual.First() is CSDiagnostic 823012"];
2384 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 823013"];
2385 [label="var includeDiagnosticMessagesAsComments = (language == CSharp); 823014"];
2386 [label="int indentDepth = (language == CSharp) ? 4 : 1; 823015"];
2387 [label="(language == CSharp) 823016"];
2388 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 823017"];
2389 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 823018"];
2390 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 823019"];
2391 [label="IsSortedOrEmpty(expected) 823020"];
2392 [label="param IsSortedOrEmpty(DiagnosticDescription[] diagnostics) 823021"];
2393 [label="new LinePositionComparer() 823022"];
2394 [label="param LinePositionComparer(this) 823023"];
2395 [label="Instance = new LinePositionComparer() 823024"];
2396 [label="var comparer = LinePositionComparer.Instance; 823025"];
2397 [label="DiagnosticDescription last = null; 823026"];
2398 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 823027"];
2399 [label="return true; 823028"];
2400 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 823029"];
2401 [label="actual = Sort(actual); 823030"];
2402 [label="Sort(actual) 823031"];
2403 [label="param Sort(IEnumerable<Diagnostic> diagnostics) 823032"];
2404 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 823033"];
2405 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 823034"];
2406 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 823035"];
2407 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 823036"];
2408 [label="var assertText = new StringBuilder(); 823037"];
2409 [label="assertText.AppendLine(); 823038"];
2410 [label="int i; 823039"];
2411 [label="assertText.AppendLine('Expected:'); 823040"];
2412 [label="assertText.AppendLine('Expected:'); 823041"];
2413 [label="var expectedText = ArrayBuilder<string>.GetInstance(); 823042"];
2414 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 823043"];
2415 [label="GetCommaSeparatedLines(assertText, expectedText); 823044"];
2416 [label="GetCommaSeparatedLines(assertText, expectedText); 823045"];
2417 [label="GetCommaSeparatedLines(assertText, expectedText) 823046"];
2418 [label="param GetCommaSeparatedLines(StringBuilder sb) 823047"];
2419 [label="param GetCommaSeparatedLines(ArrayBuilder<string> lines) 823048"];
2420 [label="int n = lines.Count; 823049"];
2421 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 823050"];
2422 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 823051"];
2423 [label="GetCommaSeparatedLines(assertText, expectedText); 823052"];
2424 [label="assertText.AppendLine('Actual:'); 823053"];
2425 [label="assertText.AppendLine('Actual:'); 823054"];
2426 [label="var actualText = ArrayBuilder<string>.GetInstance(); 823055"];
2427 [label="var e = actual.GetEnumerator(); 823056"];
2428 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 823057"];
2429 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 823058"];
2430 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 823059"];
2431 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 823060"];
2432 [label="assertText.AppendLine('Diff:'); 823061"];
2433 [label="assertText.AppendLine('Diff:'); 823062"];
2434 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 823063"];
2435 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 823064"];
2436 [label="new[] { '\\r', '\\n' } 823065"];
2437 [label="'\\r' 823066"];
2438 [label="'\\n' 823067"];
2439 [label="new[] { '\\r', '\\n' } 823068"];
2440 [label="new[] { '\\r', '\\n' } 823069"];
2441 [label="s_lineSplitChars = new[] { '\\r', '\\n' } 823070"];
2442 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 823071"];
2443 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 823072"];
2444 [label="DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine) 823073"];
2445 [label="param DiffReport(IEnumerable<T> expected) 823074"];
2446 [label="param DiffReport(IEnumerable<T> actual) 823075"];
2447 [label="param DiffReport(string separator) 823076"];
2448 [label="param DiffReport(IEqualityComparer<T> comparer = null) 823077"];
2449 [label="param DiffReport(Func<T, string> toString = null) 823078"];
2450 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 823079"];
2451 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 823080"];
2452 [label="(comparer != null) 823081"];
2453 [label="EqualityComparer<T>.Default 823082"];
2454 [label="new LCS<T>(EqualityComparer<T>.Default) 823083"];
2455 [label="param LCS(IEqualityComparer<T> comparer) 823084"];
2456 [label="param LCS(this) 823085"];
2457 [label="1 823086"];
2458 [label="DeleteCost = 1 823087"];
2459 [label="1 823088"];
2460 [label="InsertCost = 1 823089"];
2461 [label="2 823090"];
2462 [label="UpdateCost = 2 823091"];
2463 [label="param LongestCommonSubsequence(this) 823092"];
2464 [label="_comparer 823093"];
2465 [label="_comparer 823094"];
2466 [label="Default = new LCS<T>(EqualityComparer<T>.Default) 823095"];
2467 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 823096"];
2468 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 823097"];
2469 [label="IList<T> expectedList = expected as IList<T> ?? new List<T>(expected); 823098"];
2470 [label="IList<T> actualList = actual as IList<T> ?? new List<T>(actual); 823099"];
2471 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 823100"];
2472 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 823101"];
2473 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 823102"];
2474 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 823103"];
2475 [label="lcs.CalculateDiff(expectedList, actualList, toString) 823104"];
2476 [label="param CalculateDiff(IList<T> sequenceA) 823105"];
2477 [label="param CalculateDiff(IList<T> sequenceB) 823106"];
2478 [label="param CalculateDiff(Func<T, string> toString) 823107"];
2479 [label="param CalculateDiff(this) 823108"];
2480 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 823109"];
2481 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 823110"];
2482 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 823111"];
2483 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 823112"];
2484 [label="GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count) 823113"];
2485 [label="param GetEdits(TSequence sequenceA) 823114"];
2486 [label="param GetEdits(int lengthA) 823115"];
2487 [label="param GetEdits(TSequence sequenceB) 823116"];
2488 [label="param GetEdits(int lengthB) 823117"];
2489 [label="param GetEdits(this) 823118"];
2490 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 823119"];
2491 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 823120"];
2492 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 823121"];
2493 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 823122"];
2494 [label="ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB) 823123"];
2495 [label="param ComputeCostMatrix(TSequence sequenceA) 823124"];
2496 [label="param ComputeCostMatrix(int lengthA) 823125"];
2497 [label="param ComputeCostMatrix(TSequence sequenceB) 823126"];
2498 [label="param ComputeCostMatrix(int lengthB) 823127"];
2499 [label="param ComputeCostMatrix(this) 823128"];
2500 [label="var la = lengthA + 1; 823129"];
2501 [label="var la = lengthA + 1; 823130"];
2502 [label="var lb = lengthB + 1; 823131"];
2503 [label="var lb = lengthB + 1; 823132"];
2504 [label="var d = new int[la, lb]; 823133"];
2505 [label="d[0, 0] = 0; 823134"];
2506 [label="d[0, 0] 823135"];
2507 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 823136"];
2508 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 823137"];
2509 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 823138"];
2510 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 823139"];
2511 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 823140"];
2512 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 823141"];
2513 [label="return d; 823142"];
2514 [label="int i = lengthA; 823143"];
2515 [label="int j = lengthB; 823144"];
2516 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 823145"];
2517 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 823146"];
2518 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 823147"];
2519 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 823148"];
2520 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 823149"];
2521 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 823150"];
2522 [label="param GetEdits(this) 823151"];
2523 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 823152"];
2524 [label="param CalculateDiff(this) 823153"];
2525 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 823154"];
2526 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 823155"];
2527 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 823156"];
2528 [label="actualText.Free(); 823157"];
2529 [label="expectedText.Free(); 823158"];
2530 [label="return assertText.ToString(); 823159"];
2531 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 823160"];
2532 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 823161"];
2533 [label="return c; 823162"];
2534 [label="var compRef = new CSharpCompilationReference(refCompilation); 823163"];
2535 [label="var compRef = new CSharpCompilationReference(refCompilation); 823164"];
2536 [label="new CSharpCompilationReference(refCompilation) 823165"];
2537 [label="param CSharpCompilationReference(CSharpCompilation compilation) 823166"];
2538 [label="param CSharpCompilationReference(ImmutableArray<string> aliases = default(ImmutableArray<string>)) 823167"];
2539 [label="param CSharpCompilationReference(bool embedInteropTypes = false) 823168"];
2540 [label="param CSharpCompilationReference(this) 823169"];
2541 [label="compilation 823170"];
2542 [label="aliases 823171"];
2543 [label="embedInteropTypes 823172"];
2544 [label="GetProperties(compilation, aliases, embedInteropTypes) 823173"];
2545 [label="GetProperties(compilation, aliases, embedInteropTypes) 823174"];
2546 [label="param CSharpCompilationReference(this) 823175"];
2547 [label="param CSharpCompilationReference(this) 823176"];
2548 [label="public new CSharpCompilation Compilation { get; } 823177"];
2549 [label="this.Compilation 823178"];
2550 [label="var imageRef = refCompilation.EmitToImageReference(); 823179"];
2551 [label="var imageRef = refCompilation.EmitToImageReference(); 823180"];
2552 [label="refCompilation.EmitToImageReference() 823181"];
2553 [label="param EmitToImageReference(this Compilation comp) 823182"];
2554 [label="param EmitToImageReference(EmitOptions options = null) 823183"];
2555 [label="param EmitToImageReference(bool embedInteropTypes = false) 823184"];
2556 [label="param EmitToImageReference(ImmutableArray<string> aliases = default) 823185"];
2557 [label="param EmitToImageReference(DiagnosticDescription[] expectedWarnings = null) 823186"];
2558 [label="comp 823187"];
2559 [label="options 823188"];
2560 [label="embedInteropTypes 823189"];
2561 [label="aliases 823190"];
2562 [label="expectedWarnings 823191"];
2563 [label="EmitToPortableExecutableReference(comp, options, embedInteropTypes, aliases, expectedWarnings) 823192"];
2564 [label="param EmitToPortableExecutableReference(this Compilation comp) 823193"];
2565 [label="param EmitToPortableExecutableReference(EmitOptions options = null) 823194"];
2566 [label="param EmitToPortableExecutableReference(bool embedInteropTypes = false) 823195"];
2567 [label="param EmitToPortableExecutableReference(ImmutableArray<string> aliases = default) 823196"];
2568 [label="param EmitToPortableExecutableReference(DiagnosticDescription[] expectedWarnings = null) 823197"];
2569 [label="var image = comp.EmitToArray(options, expectedWarnings: expectedWarnings); 823198"];
2570 [label="var image = comp.EmitToArray(options, expectedWarnings: expectedWarnings); 823199"];
2571 [label="var image = comp.EmitToArray(options, expectedWarnings: expectedWarnings); 823200"];
2572 [label="var image = comp.EmitToArray(options, expectedWarnings: expectedWarnings); 823201"];
2573 [label="comp.EmitToArray(options, expectedWarnings: expectedWarnings) 823202"];
2574 [label="param EmitToArray(this Compilation compilation) 823203"];
2575 [label="param EmitToArray(EmitOptions options = null) 823204"];
2576 [label="param EmitToArray(CompilationTestData testData = null) 823205"];
2577 [label="param EmitToArray(DiagnosticDescription[] expectedWarnings = null) 823206"];
2578 [label="param EmitToArray(Stream pdbStream = null) 823207"];
2579 [label="param EmitToArray(IMethodSymbol debugEntryPoint = null) 823208"];
2580 [label="param EmitToArray(Stream sourceLinkStream = null) 823209"];
2581 [label="param EmitToArray(IEnumerable<EmbeddedText> embeddedTexts = null) 823210"];
2582 [label="param EmitToArray(IEnumerable<ResourceDescription> manifestResources = null) 823211"];
2583 [label="param EmitToArray(Stream metadataPEStream = null) 823212"];
2584 [label="var peStream = new MemoryStream(); 823213"];
2585 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 823214"];
2586 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 823215"];
2587 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 823216"];
2588 [label="compilation.Options 823217"];
2589 [label="get { return _options; } 823218"];
2590 [label="if (pdbStream == null && compilation.Options.OptimizationLevel == OptimizationLevel.Debug && options?.DebugInformationFormat != DebugInformationFormat.Embedded)\n            {\n                if (MonoHelpers.IsRunningOnMono() || PathUtilities.IsUnixLikePlatform)\n                {\n                    options = (options ?? EmitOptions.Default).WithDebugInformationFormat(DebugInformationFormat.PortablePdb);\n                }\n\n                var discretePdb = (object)options != null && options.DebugInformationFormat != DebugInformationFormat.Embedded;\n                pdbStream = discretePdb ? new MemoryStream() : null;\n            } 823219"];
2591 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 823220"];
2592 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 823221"];
2593 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 823222"];
2594 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 823223"];
2595 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 823224"];
2596 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 823225"];
2597 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 823226"];
2598 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 823227"];
2599 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 823228"];
2600 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 823229"];
2601 [label="var emitResult = compilation.Emit(\n                peStream: peStream,\n                metadataPEStream: metadataPEStream,\n                pdbStream: pdbStream,\n                xmlDocumentationStream: null,\n                win32Resources: null,\n                manifestResources: manifestResources,\n                options: options,\n                debugEntryPoint: debugEntryPoint,\n                sourceLinkStream: sourceLinkStream,\n                embeddedTexts: embeddedTexts,\n                testData: testData,\n                cancellationToken: default(CancellationToken)); 823230"];
2602 [label="param CreateModuleBuilder(IMethodSymbol? debugEntryPoint) 823231"];
2603 [label="param CreateModuleBuilder(IEnumerable<EmbeddedText>? embeddedTexts) 823232"];
2604 [label="param CreateModuleBuilder(CompilationTestData? testData) 823233"];
2605 [label="param CreateModuleBuilder(DiagnosticBag diagnostics) 823234"];
2606 [label="param CreateModuleBuilder(CancellationToken cancellationToken) 823235"];
2607 [label="Debug.Assert(!IsSubmission || HasCodeToEmit()); 823236"];
2608 [label="GetRuntimeMetadataVersion(emitOptions, diagnostics) 823237"];
2609 [label="param GetRuntimeMetadataVersion(DiagnosticBag diagnostics) 823238"];
2610 [label="GetRuntimeMetadataVersion(emitOptions) 823239"];
2611 [label="Assembly 823240"];
2612 [label="SourceAssembly 823241"];
2613 [label="GetBoundReferenceManager() 823242"];
2614 [label="GetBoundReferenceManager(); 823243"];
2615 [label="var corAssembly = Assembly.CorLibrary as Symbols.Metadata.PE.PEAssemblySymbol; 823244"];
2616 [label="if (corAssembly is object)\n            {\n                return corAssembly.Assembly.ManifestModule.MetadataVersion;\n            } 823245"];
2617 [label="if (runtimeMDVersion != null)\n            {\n                return runtimeMDVersion;\n            } 823246"];
2618 [label="DiagnosticBag? runtimeMDVersionDiagnostics = DiagnosticBag.GetInstance(); 823247"];
2619 [label="runtimeMDVersionDiagnostics.Add(ErrorCode.WRN_NoRuntimeMetadataVersion, NoLocation.Singleton); 823248"];
2620 [label="runtimeMDVersionDiagnostics.Add(ErrorCode.WRN_NoRuntimeMetadataVersion, NoLocation.Singleton); 823249"];
2621 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref runtimeMDVersionDiagnostics, CancellationToken.None))\n            {\n                return null;\n            } 823250"];
2622 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref runtimeMDVersionDiagnostics, CancellationToken.None))\n            {\n                return null;\n            } 823251"];
2623 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref runtimeMDVersionDiagnostics, CancellationToken.None))\n            {\n                return null;\n            } 823252"];
2624 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref runtimeMDVersionDiagnostics, CancellationToken.None))\n            {\n                return null;\n            } 823253"];
2625 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref runtimeMDVersionDiagnostics, CancellationToken.None))\n            {\n                return null;\n            } 823254"];
2626 [label="{ ErrorCode.WRN_ConflictingMachineAssembly,\n                                                              ErrorCode.WRN_RefCultureMismatch,\n                                                              ErrorCode.WRN_InvalidVersionFormat } 823255"];
2627 [label="s_alinkWarnings = { ErrorCode.WRN_ConflictingMachineAssembly,\n                                                              ErrorCode.WRN_RefCultureMismatch,\n                                                              ErrorCode.WRN_InvalidVersionFormat } 823256"];
2628 [label="param Filter(Diagnostic d) 823257"];
2629 [label="param Filter(int warningLevelOption) 823258"];
2630 [label="param Filter(NullableContextOptions nullableOption) 823259"];
2631 [label="param Filter(ReportDiagnostic generalDiagnosticOption) 823260"];
2632 [label="param Filter(IDictionary<string, ReportDiagnostic> specificDiagnosticOptions) 823261"];
2633 [label="param Filter(SyntaxTreeOptionsProvider? syntaxTreeOptions) 823262"];
2634 [label="param Filter(CancellationToken cancellationToken) 823263"];
2635 [label="if (d == null)\n            {\n                return d;\n            }\n            else if (d.IsNotConfigurable())\n            {\n                if (d.IsEnabledByDefault)\n                {\n                    // Enabled NotConfigurable should always be reported as it is.\n                    return d;\n                }\n                else\n                {\n                    // Disabled NotConfigurable should never be reported.\n                    return null;\n                }\n            }\n            else if (d.Severity == InternalDiagnosticSeverity.Void)\n            {\n                return null;\n            } 823264"];
2636 [label="if (d == null)\n            {\n                return d;\n            }\n            else if (d.IsNotConfigurable())\n            {\n                if (d.IsEnabledByDefault)\n                {\n                    // Enabled NotConfigurable should always be reported as it is.\n                    return d;\n                }\n                else\n                {\n                    // Disabled NotConfigurable should never be reported.\n                    return null;\n                }\n            }\n            else if (d.Severity == InternalDiagnosticSeverity.Void)\n            {\n                return null;\n            } 823265"];
2637 [label="if (d.IsNotConfigurable())\n            {\n                if (d.IsEnabledByDefault)\n                {\n                    // Enabled NotConfigurable should always be reported as it is.\n                    return d;\n                }\n                else\n                {\n                    // Disabled NotConfigurable should never be reported.\n                    return null;\n                }\n            }\n            else if (d.Severity == InternalDiagnosticSeverity.Void)\n            {\n                return null;\n            } 823266"];
2638 [label="if (d.Severity == InternalDiagnosticSeverity.Void)\n            {\n                return null;\n            } 823267"];
2639 [label="ReportDiagnostic reportAction; 823268"];
2640 [label="bool hasPragmaSuppression; 823269"];
2641 [label="if (s_alinkWarnings.Contains((ErrorCode)d.Code) &&\n                specificDiagnosticOptions.Keys.Contains(CSharp.MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ALinkWarn)))\n            {\n                reportAction = GetDiagnosticReport(ErrorFacts.GetSeverity(ErrorCode.WRN_ALinkWarn),\n                    d.IsEnabledByDefault,\n                    CSharp.MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ALinkWarn),\n                    ErrorFacts.GetWarningLevel(ErrorCode.WRN_ALinkWarn),\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression);\n            }\n            else\n            {\n                reportAction = GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression);\n            } 823270"];
2642 [label="if (s_alinkWarnings.Contains((ErrorCode)d.Code) &&\n                specificDiagnosticOptions.Keys.Contains(CSharp.MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ALinkWarn)))\n            {\n                reportAction = GetDiagnosticReport(ErrorFacts.GetSeverity(ErrorCode.WRN_ALinkWarn),\n                    d.IsEnabledByDefault,\n                    CSharp.MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ALinkWarn),\n                    ErrorFacts.GetWarningLevel(ErrorCode.WRN_ALinkWarn),\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression);\n            }\n            else\n            {\n                reportAction = GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression);\n            } 823271"];
2643 [label="if (s_alinkWarnings.Contains((ErrorCode)d.Code) &&\n                specificDiagnosticOptions.Keys.Contains(CSharp.MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ALinkWarn)))\n            {\n                reportAction = GetDiagnosticReport(ErrorFacts.GetSeverity(ErrorCode.WRN_ALinkWarn),\n                    d.IsEnabledByDefault,\n                    CSharp.MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ALinkWarn),\n                    ErrorFacts.GetWarningLevel(ErrorCode.WRN_ALinkWarn),\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression);\n            }\n            else\n            {\n                reportAction = GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression);\n            } 823272"];
2644 [label="if (s_alinkWarnings.Contains((ErrorCode)d.Code) &&\n                specificDiagnosticOptions.Keys.Contains(CSharp.MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ALinkWarn)))\n            {\n                reportAction = GetDiagnosticReport(ErrorFacts.GetSeverity(ErrorCode.WRN_ALinkWarn),\n                    d.IsEnabledByDefault,\n                    CSharp.MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ALinkWarn),\n                    ErrorFacts.GetWarningLevel(ErrorCode.WRN_ALinkWarn),\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression);\n            }\n            else\n            {\n                reportAction = GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression);\n            } 823273"];
2645 [label="reportAction = GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression); 823274"];
2646 [label="reportAction = GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression); 823275"];
2647 [label="reportAction = GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression); 823276"];
2648 [label="reportAction = GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression); 823277"];
2649 [label="reportAction = GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression); 823278"];
2650 [label="reportAction = GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression); 823279"];
2651 [label="reportAction = GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression); 823280"];
2652 [label="reportAction = GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression); 823281"];
2653 [label="GetDiagnosticReport(d.Severity,\n                    d.IsEnabledByDefault,\n                    d.Id,\n                    d.WarningLevel,\n                    d.Location,\n                    d.Category,\n                    warningLevelOption,\n                    nullableOption,\n                    generalDiagnosticOption,\n                    specificDiagnosticOptions,\n                    syntaxTreeOptions,\n                    cancellationToken,\n                    out hasPragmaSuppression) 823282"];
2654 [label="param GetDiagnosticReport(DiagnosticSeverity severity) 823283"];
2655 [label="param GetDiagnosticReport(bool isEnabledByDefault) 823284"];
2656 [label="param GetDiagnosticReport(string id) 823285"];
2657 [label="param GetDiagnosticReport(int diagnosticWarningLevel) 823286"];
2658 [label="param GetDiagnosticReport(Location location) 823287"];
2659 [label="param GetDiagnosticReport(string category) 823288"];
2660 [label="param GetDiagnosticReport(int warningLevelOption) 823289"];
2661 [label="param GetDiagnosticReport(NullableContextOptions nullableOption) 823290"];
2662 [label="param GetDiagnosticReport(ReportDiagnostic generalDiagnosticOption) 823291"];
2663 [label="param GetDiagnosticReport(IDictionary<string, ReportDiagnostic> specificDiagnosticOptions) 823292"];
2664 [label="param GetDiagnosticReport(SyntaxTreeOptionsProvider? syntaxTreeOptions) 823293"];
2665 [label="param GetDiagnosticReport(CancellationToken cancellationToken) 823294"];
2666 [label="param GetDiagnosticReport(out bool hasPragmaSuppression) 823295"];
2667 [label="hasPragmaSuppression = false; 823296"];
2668 [label="Debug.Assert(location.SourceTree is null || location.SourceTree is CSharpSyntaxTree); 823297"];
2669 [label="var tree = location.SourceTree as CSharpSyntaxTree; 823298"];
2670 [label="var position = location.SourceSpan.Start; 823299"];
2671 [label="bool isNullableFlowAnalysisWarning = ErrorFacts.NullableWarnings.Contains(id); 823300"];
2672 [label="if (isNullableFlowAnalysisWarning)\n            {\n                // LAFHIS\n                Syntax.NullableContextState.State? warningsState = tree is not null ? tree.GetNullableContextState(position).WarningsState : null;\n                var nullableWarningsEnabled = warningsState switch\n                {\n                    Syntax.NullableContextState.State.Enabled => true,\n                    Syntax.NullableContextState.State.Disabled => false,\n                    Syntax.NullableContextState.State.ExplicitlyRestored => nullableOption.WarningsEnabled(),\n                    Syntax.NullableContextState.State.Unknown =>\n                        tree?.IsGeneratedCode(syntaxTreeOptions, cancellationToken) != true && nullableOption.WarningsEnabled(),\n                    null => nullableOption.WarningsEnabled(),\n                    _ => throw ExceptionUtilities.UnexpectedValue(warningsState)\n                };\n\n                if (!nullableWarningsEnabled)\n                {\n                    return ReportDiagnostic.Suppress;\n                }\n            } 823301"];
2673 [label="if (diagnosticWarningLevel > warningLevelOption)  // honor the warning level\n            {\n                return ReportDiagnostic.Suppress;\n            } 823302"];
2674 [label="ReportDiagnostic report; 823303"];
2675 [label="bool isSpecified = false; 823304"];
2676 [label="bool specifiedWarnAsErrorMinus = false; 823305"];
2677 [label="if (specificDiagnosticOptions.TryGetValue(id, out report))\n            {\n                // 2. Command line options (/nowarn, /warnaserror)\n                isSpecified = true;\n\n                // 'ReportDiagnostic.Default' is added to SpecificDiagnosticOptions for '/warnaserror-:DiagnosticId',\n                if (report == ReportDiagnostic.Default)\n                {\n                    specifiedWarnAsErrorMinus = true;\n                }\n            } 823306"];
2678 [label="if (specificDiagnosticOptions.TryGetValue(id, out report))\n            {\n                // 2. Command line options (/nowarn, /warnaserror)\n                isSpecified = true;\n\n                // 'ReportDiagnostic.Default' is added to SpecificDiagnosticOptions for '/warnaserror-:DiagnosticId',\n                if (report == ReportDiagnostic.Default)\n                {\n                    specifiedWarnAsErrorMinus = true;\n                }\n            } 823307"];
2679 [label="if (specificDiagnosticOptions.TryGetValue(id, out report))\n            {\n                // 2. Command line options (/nowarn, /warnaserror)\n                isSpecified = true;\n\n                // 'ReportDiagnostic.Default' is added to SpecificDiagnosticOptions for '/warnaserror-:DiagnosticId',\n                if (report == ReportDiagnostic.Default)\n                {\n                    specifiedWarnAsErrorMinus = true;\n                }\n            } 823308"];
2680 [label="if (syntaxTreeOptions != null &&\n                (!isSpecified || specifiedWarnAsErrorMinus))\n            {\n                // 3. Editor config options (syntax tree level)\n                // 4. Global analyzer config options (compilation level)\n                // Do not apply config options if it is bumping a warning to an error and '/warnaserror-:DiagnosticId' was specified on the command line.\n                if ((tree != null && syntaxTreeOptions.TryGetDiagnosticValue(tree, id, cancellationToken, out var reportFromSyntaxTreeOptions) ||\n                    syntaxTreeOptions.TryGetGlobalDiagnosticValue(id, cancellationToken, out reportFromSyntaxTreeOptions)) &&\n                    !(specifiedWarnAsErrorMinus && severity == DiagnosticSeverity.Warning && reportFromSyntaxTreeOptions == ReportDiagnostic.Error))\n                {\n                    isSpecified = true;\n                    report = reportFromSyntaxTreeOptions;\n\n                    // '/warnaserror' should promote warnings configured in analyzer config to error.\n                    if (!specifiedWarnAsErrorMinus && report == ReportDiagnostic.Warn && generalDiagnosticOption == ReportDiagnostic.Error)\n                    {\n                        report = ReportDiagnostic.Error;\n                    }\n                }\n            } 823309"];
2681 [label="if (syntaxTreeOptions != null &&\n                (!isSpecified || specifiedWarnAsErrorMinus))\n            {\n                // 3. Editor config options (syntax tree level)\n                // 4. Global analyzer config options (compilation level)\n                // Do not apply config options if it is bumping a warning to an error and '/warnaserror-:DiagnosticId' was specified on the command line.\n                if ((tree != null && syntaxTreeOptions.TryGetDiagnosticValue(tree, id, cancellationToken, out var reportFromSyntaxTreeOptions) ||\n                    syntaxTreeOptions.TryGetGlobalDiagnosticValue(id, cancellationToken, out reportFromSyntaxTreeOptions)) &&\n                    !(specifiedWarnAsErrorMinus && severity == DiagnosticSeverity.Warning && reportFromSyntaxTreeOptions == ReportDiagnostic.Error))\n                {\n                    isSpecified = true;\n                    report = reportFromSyntaxTreeOptions;\n\n                    // '/warnaserror' should promote warnings configured in analyzer config to error.\n                    if (!specifiedWarnAsErrorMinus && report == ReportDiagnostic.Warn && generalDiagnosticOption == ReportDiagnostic.Error)\n                    {\n                        report = ReportDiagnostic.Error;\n                    }\n                }\n            } 823310"];
2682 [label="if (!isSpecified)\n            {\n                report = isEnabledByDefault ? ReportDiagnostic.Default : ReportDiagnostic.Suppress;\n            } 823311"];
2683 [label="isEnabledByDefault 823312"];
2684 [label="report = isEnabledByDefault ? ReportDiagnostic.Default : ReportDiagnostic.Suppress; 823313"];
2685 [label="if (report == ReportDiagnostic.Suppress)\n            {\n                return ReportDiagnostic.Suppress;\n            } 823314"];
2686 [label="var pragmaWarningState = tree?.GetPragmaDirectiveWarningState(id, position) ?? Syntax.PragmaWarningState.Default; 823315"];
2687 [label="var pragmaWarningState = tree?.GetPragmaDirectiveWarningState(id, position) ?? Syntax.PragmaWarningState.Default; 823316"];
2688 [label="if (pragmaWarningState == Syntax.PragmaWarningState.Disabled)\n            {\n                hasPragmaSuppression = true;\n            } 823317"];
2689 [label="if (pragmaWarningState == Syntax.PragmaWarningState.Enabled)\n            {\n                switch (report)\n                {\n                    case ReportDiagnostic.Error:\n                    case ReportDiagnostic.Hidden:\n                    case ReportDiagnostic.Info:\n                    case ReportDiagnostic.Warn:\n                        // No need to adjust the current report state, it already means 'enabled'\n                        return report;\n\n                    case ReportDiagnostic.Suppress:\n                        // Enable the warning\n                        return ReportDiagnostic.Default;\n\n                    case ReportDiagnostic.Default:\n                        if (generalDiagnosticOption == ReportDiagnostic.Error && promoteToAnError())\n                        {\n                            return ReportDiagnostic.Error;\n                        }\n\n                        return ReportDiagnostic.Default;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(report);\n                }\n            }\n            else if (report == ReportDiagnostic.Suppress) // check options (/nowarn)\n            {\n                return ReportDiagnostic.Suppress;\n            } 823318"];
2690 [label="if (report == ReportDiagnostic.Suppress) // check options (/nowarn)\n            {\n                return ReportDiagnostic.Suppress;\n            } 823319"];
2691 [label="if (report == ReportDiagnostic.Default)\n            {\n                switch (generalDiagnosticOption)\n                {\n                    case ReportDiagnostic.Error:\n                        if (promoteToAnError())\n                        {\n                            return ReportDiagnostic.Error;\n                        }\n                        break;\n                    case ReportDiagnostic.Suppress:\n                        // When doing suppress-all-warnings, don't lower severity for anything other than warning and info.\n                        // We shouldn't suppress hidden diagnostics here because then features that use hidden diagnostics to\n                        // display a lightbulb would stop working if someone has suppress-all-warnings (/nowarn) specified in their project.\n                        if (severity == DiagnosticSeverity.Warning || severity == DiagnosticSeverity.Info)\n                        {\n                            report = ReportDiagnostic.Suppress;\n                            isSpecified = true;\n                        }\n                        break;\n                }\n            } 823320"];
2692 [label="switch (generalDiagnosticOption)\n                {\n                    case ReportDiagnostic.Error:\n                        if (promoteToAnError())\n                        {\n                            return ReportDiagnostic.Error;\n                        }\n                        break;\n                    case ReportDiagnostic.Suppress:\n                        // When doing suppress-all-warnings, don't lower severity for anything other than warning and info.\n                        // We shouldn't suppress hidden diagnostics here because then features that use hidden diagnostics to\n                        // display a lightbulb would stop working if someone has suppress-all-warnings (/nowarn) specified in their project.\n                        if (severity == DiagnosticSeverity.Warning || severity == DiagnosticSeverity.Info)\n                        {\n                            report = ReportDiagnostic.Suppress;\n                            isSpecified = true;\n                        }\n                        break;\n                } 823321"];
2693 [label="return report; 823322"];
2694 [label="if (hasPragmaSuppression)\n            {\n                d = d.WithIsSuppressed(true);\n            } 823323"];
2695 [label="return d.WithReportDiagnostic(reportAction); 823324"];
2696 [label="return d.WithReportDiagnostic(reportAction); 823325"];
2697 [label="return string.Empty; 823326"];
2698 [label="string? runtimeMDVersion = GetRuntimeMetadataVersion(emitOptions, diagnostics); 823327"];
2699 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 823328"];
2700 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 823329"];
2701 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 823330"];
2702 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 823331"];
2703 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 823332"];
2704 [label="SourceAssembly 823333"];
2705 [label="GetBoundReferenceManager() 823334"];
2706 [label="GetBoundReferenceManager(); 823335"];
2707 [label="SourceAssembly.IsDelaySigned 823336"];
2708 [label="SourceAssembly 823337"];
2709 [label="GetBoundReferenceManager() 823338"];
2710 [label="GetBoundReferenceManager(); 823339"];
2711 [label="=> 0x30 823340"];
2712 [label="0x30 823341"];
2713 [label="if (manifestResources == null)\n            {\n                manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>();\n            } 823342"];
2714 [label="PEModuleBuilder moduleBeingBuilt; 823343"];
2715 [label="GetBoundReferenceManager(); 823344"];
2716 [label="get\n            {\n                return true;\n            } 823345"];
2717 [label="if (sourceModule.AnyReferencedAssembliesAreLinked)\n            {\n                _embeddedTypesManagerOpt = new NoPia.EmbeddedTypesManager(this);\n            } 823346"];
2718 [label="Debug.Assert(sourceAssembly is object); 823347"];
2719 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 823348"];
2720 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 823349"];
2721 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 823350"];
2722 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 823351"];
2723 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 823352"];
2724 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 823353"];
2725 [label="PooledHashSet<int>? excludeDiagnostics = null; 823354"];
2726 [label="if (emitMetadataOnly)\n            {\n                excludeDiagnostics = PooledHashSet<int>.GetInstance();\n                excludeDiagnostics.Add((int)ErrorCode.ERR_ConcreteMissingBody);\n            } 823355"];
2727 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 823356"];
2728 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 823357"];
2729 [label="GetDiagnostics(CompilationStage.Declare, true, cancellationToken) 823358"];
2730 [label="param GetDiagnostics(CompilationStage stage) 823359"];
2731 [label="param GetDiagnostics(bool includeEarlierStages) 823360"];
2732 [label="var diagnostics = DiagnosticBag.GetInstance(); 823361"];
2733 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 823362"];
2734 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 823363"];
2735 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 823364"];
2736 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 823365"];
2737 [label="param GetDiagnostics(CompilationStage stage) 823366"];
2738 [label="param GetDiagnostics(bool includeEarlierStages) 823367"];
2739 [label="param GetDiagnostics(DiagnosticBag diagnostics) 823368"];
2740 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 823369"];
2741 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 823370"];
2742 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 823371"];
2743 [label="this.SyntaxTrees 823372"];
2744 [label="_syntaxAndDeclarations.GetLazyState() 823373"];
2745 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 823374"];
2746 [label="this.Options 823375"];
2747 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 823376"];
2748 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 823377"];
2749 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 823378"];
2750 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 823379"];
2751 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 823380"];
2752 [label="CheckAssemblyName(builder); 823381"];
2753 [label="CheckAssemblyName(builder); 823382"];
2754 [label="Options 823383"];
2755 [label="Options 823384"];
2756 [label="get\n            {\n                return _options;\n            } 823385"];
2757 [label="return _options; 823386"];
2758 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 823387"];
2759 [label="GetBoundReferenceManager() 823388"];
2760 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 823389"];
2761 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 823390"];
2762 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 823391"];
2763 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 823392"];
2764 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 823393"];
2765 [label="GlobalImports 823394"];
2766 [label="SourceLocation? location = null; 823395"];
2767 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 823396"];
2768 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 823397"];
2769 [label="Assembly 823398"];
2770 [label="SourceAssembly 823399"];
2771 [label="GetBoundReferenceManager() 823400"];
2772 [label="GetBoundReferenceManager(); 823401"];
2773 [label="Assembly.ForceComplete(location, cancellationToken); 823402"];
2774 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 823403"];
2775 [label="_declarationDiagnosticsFrozen = true; 823404"];
2776 [label="_needsGeneratedAttributes_IsFrozen = true; 823405"];
2777 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 823406"];
2778 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 823407"];
2779 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 823408"];
2780 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 823409"];
2781 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 823410"];
2782 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 823411"];
2783 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 823412"];
2784 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 823413"];
2785 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 823414"];
2786 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 823415"];
2787 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 823416"];
2788 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 823417"];
2789 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 823418"];
2790 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 823419"];
2791 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 823420"];
2792 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 823421"];
2793 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 823422"];
2794 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 823423"];
2795 [label="excludeDiagnostics?.Free(); 823424"];
2796 [label="Debug.Assert(compilation != null); 823425"];
2797 [label="Debug.Assert(diagnostics != null); 823426"];
2798 [label="compilation.PreviousSubmission 823427"];
2799 [label="ScriptCompilationInfo 823428"];
2800 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 823429"];
2801 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 823430"];
2802 [label="MethodSymbol entryPoint = null; 823431"];
2803 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 823432"];
2804 [label="param GetEntryPoint(bool hasDeclarationErrors) 823433"];
2805 [label="param GetEntryPoint(CancellationToken cancellationToken) 823434"];
2806 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 823435"];
2807 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 823436"];
2808 [label="Debug.Assert(compilation != null); 823437"];
2809 [label="Debug.Assert(diagnostics != null); 823438"];
2810 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 823439"];
2811 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 823440"];
2812 [label="param SetGlobalErrorIfTrue(bool arg) 823441"];
2813 [label="param SetGlobalErrorIfTrue(this) 823442"];
2814 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 823443"];
2815 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 823444"];
2816 [label="GetBoundReferenceManager(); 823445"];
2817 [label="param VisitNamedType(NamedTypeSymbol symbol) 823446"];
2818 [label="param VisitNamedType(TypeCompilationState arg) 823447"];
2819 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 823448"];
2820 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 823449"];
2821 [label="PassesFilter(_filterOpt, symbol) 823450"];
2822 [label="param PassesFilter(Predicate<Symbol> filterOpt) 823451"];
2823 [label="param PassesFilter(Symbol symbol) 823452"];
2824 [label="return (filterOpt == null) || filterOpt(symbol); 823453"];
2825 [label="return (filterOpt == null) || filterOpt(symbol); 823454"];
2826 [label="arg = null; 823455"];
2827 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 823456"];
2828 [label="if (tasks == null)\n            {\n                return;\n            } 823457"];
2829 [label="if (tasks == null)\n            {\n                return;\n            } 823458"];
2830 [label="methodCompiler.WaitForWorkers(); 823459"];
2831 [label="var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics); 823460"];
2832 [label="moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics) 823461"];
2833 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 823462"];
2834 [label="_additionalTypes 823463"];
2835 [label="var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics); 823464"];
2836 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 823465"];
2837 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 823466"];
2838 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics) 823467"];
2839 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 823468"];
2840 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 823469"];
2841 [label="param CompileSynthesizedMethods(this) 823470"];
2842 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 823471"];
2843 [label="var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics); 823472"];
2844 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 823473"];
2845 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 823474"];
2846 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 823475"];
2847 [label="return GetNeedsGeneratedAttributesInternal(); 823476"];
2848 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 823477"];
2849 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 823478"];
2850 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 823479"];
2851 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 823480"];
2852 [label="return; 823481"];
2853 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 823482"];
2854 [label="var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics); 823483"];
2855 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 823484"];
2856 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 823485"];
2857 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics) 823486"];
2858 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 823487"];
2859 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 823488"];
2860 [label="param CompileSynthesizedMethods(this) 823489"];
2861 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 823490"];
2862 [label="param GetPreviousAnonymousTypes(this) 823491"];
2863 [label="methodCompiler.WaitForWorkers(); 823492"];
2864 [label="var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass; 823493"];
2865 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 823494"];
2866 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 823495"];
2867 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 823496"];
2868 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 823497"];
2869 [label="GetBoundReferenceManager(); 823498"];
2870 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 823499"];
2871 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 823500"];
2872 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 823501"];
2873 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag) 823502"];
2874 [label="param GenerateModuleInitializer(PEModuleBuilder moduleBeingBuilt) 823503"];
2875 [label="param GenerateModuleInitializer(DiagnosticBag methodBodyDiagnosticBag) 823504"];
2876 [label="param GenerateModuleInitializer(this) 823505"];
2877 [label="Debug.Assert(_declarationDiagnosticsFrozen); 823506"];
2878 [label="if (_moduleInitializerMethods is object)\n            {\n                var ilBuilder = new ILBuilder(moduleBeingBuilt, new LocalSlotManager(slotAllocator: null), OptimizationLevel.Release, areLocalsZeroed: false);\n\n                foreach (MethodSymbol method in _moduleInitializerMethods.OrderBy<MethodSymbol>(LexicalOrderSymbolComparer.Instance))\n                {\n                    ilBuilder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n\n                    ilBuilder.EmitToken(\n                        moduleBeingBuilt.Translate(method, methodBodyDiagnosticBag, needDeclaration: true),\n                        CSharpSyntaxTree.Dummy.GetRoot(),\n                        methodBodyDiagnosticBag);\n                }\n\n                ilBuilder.EmitRet(isVoid: true);\n                ilBuilder.Realize();\n                moduleBeingBuilt.RootModuleType.SetStaticConstructorBody(ilBuilder.RealizedIL);\n            } 823507"];
2879 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 823508"];
2880 [label="if (hasDeclarationErrors || hasMethodBodyError)\n                {\n                    return false;\n                } 823509"];
2881 [label="return true; 823510"];
2882 [label="param GenerateResourcesAndDocumentationComments(Stream? xmlDocStream) 823511"];
2883 [label="DiagnosticBag? resourceDiagnostics = DiagnosticBag.GetInstance(); 823512"];
2884 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 823513"];
2885 [label="SourceAssembly 823514"];
2886 [label="GetBoundReferenceManager() 823515"];
2887 [label="GetBoundReferenceManager(); 823516"];
2888 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 823517"];
2889 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 823518"];
2890 [label="AddedModulesResourceNames(resourceDiagnostics) 823519"];
2891 [label="param AddedModulesResourceNames(DiagnosticBag diagnostics) 823520"];
2892 [label="SourceAssembly 823521"];
2893 [label="GetBoundReferenceManager() 823522"];
2894 [label="GetBoundReferenceManager(); 823523"];
2895 [label="ImmutableArray<ModuleSymbol> modules = SourceAssembly.Modules; 823524"];
2896 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 823525"];
2897 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 823526"];
2898 [label="param AddedModulesResourceNames(this) 823527"];
2899 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 823528"];
2900 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 823529"];
2901 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 823530"];
2902 [label="DiagnosticBag? xmlDiagnostics = DiagnosticBag.GetInstance(); 823531"];
2903 [label="string? assemblyName = FileNameUtilities.ChangeExtension(outputNameOverride, extension: null); 823532"];
2904 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 823533"];
2905 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 823534"];
2906 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken) 823535"];
2907 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 823536"];
2908 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 823537"];
2909 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 823538"];
2910 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 823539"];
2911 [label="StreamWriter writer = null; 823540"];
2912 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 823541"];
2913 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 823542"];
2914 [label="compilation.SourceAssembly 823543"];
2915 [label="GetBoundReferenceManager() 823544"];
2916 [label="GetBoundReferenceManager(); 823545"];
2917 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 823546"];
2918 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 823547"];
2919 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 823548"];
2920 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 823549"];
2921 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 823550"];
2922 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 823551"];
2923 [label="param DocumentationCommentCompiler(TextWriter writer) 823552"];
2924 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 823553"];
2925 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 823554"];
2926 [label="param DocumentationCommentCompiler(bool processIncludes) 823555"];
2927 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 823556"];
2928 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 823557"];
2929 [label="param DocumentationCommentCompiler(this) 823558"];
2930 [label="param DocumentationCommentCompiler(this) 823559"];
2931 [label="_assemblyName 823560"];
2932 [label="_compilation 823561"];
2933 [label="_writer 823562"];
2934 [label="_filterTree 823563"];
2935 [label="_filterSpanWithinTree 823564"];
2936 [label="_processIncludes 823565"];
2937 [label="_isForSingleSymbol 823566"];
2938 [label="_diagnostics 823567"];
2939 [label="_lazyComparer 823568"];
2940 [label="_includedFileCache 823569"];
2941 [label="_indentDepth 823570"];
2942 [label="_temporaryStringBuilders 823571"];
2943 [label="_writer 823572"];
2944 [label="_filterTree 823573"];
2945 [label="_filterSpanWithinTree 823574"];
2946 [label="_processIncludes 823575"];
2947 [label="_isForSingleSymbol 823576"];
2948 [label="_diagnostics 823577"];
2949 [label="compilation.SourceAssembly 823578"];
2950 [label="GetBoundReferenceManager() 823579"];
2951 [label="GetBoundReferenceManager(); 823580"];
2952 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 823581"];
2953 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 823582"];
2954 [label="Debug.Assert(_assemblyName != null); 823583"];
2955 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 823584"];
2956 [label="WriteLine('<?xml version=\\'1.0\\'?>') 823585"];
2957 [label="param WriteLine(string message) 823586"];
2958 [label="param WriteLine(this) 823587"];
2959 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823588"];
2960 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823589"];
2961 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823590"];
2962 [label="WriteLine('<doc>'); 823591"];
2963 [label="WriteLine('<doc>') 823592"];
2964 [label="param WriteLine(string message) 823593"];
2965 [label="param WriteLine(this) 823594"];
2966 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823595"];
2967 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823596"];
2968 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823597"];
2969 [label="Indent(); 823598"];
2970 [label="WriteLine('<assembly>'); 823599"];
2971 [label="WriteLine('<assembly>') 823600"];
2972 [label="param WriteLine(string message) 823601"];
2973 [label="param WriteLine(this) 823602"];
2974 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823603"];
2975 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823604"];
2976 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823605"];
2977 [label="Indent(); 823606"];
2978 [label="WriteLine('<name>{0}</name>', _assemblyName); 823607"];
2979 [label="WriteLine('<name>{0}</name>', _assemblyName) 823608"];
2980 [label="WriteLine('<name>{0}</name>', _assemblyName) 823609"];
2981 [label="param WriteLine(string format) 823610"];
2982 [label="param WriteLine(params object[] args) 823611"];
2983 [label="param WriteLine(this) 823612"];
2984 [label="WriteLine(string.Format(format, args)); 823613"];
2985 [label="WriteLine(string.Format(format, args)); 823614"];
2986 [label="WriteLine(string.Format(format, args)); 823615"];
2987 [label="WriteLine(string.Format(format, args)) 823616"];
2988 [label="param WriteLine(string message) 823617"];
2989 [label="param WriteLine(this) 823618"];
2990 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823619"];
2991 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823620"];
2992 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823621"];
2993 [label="WriteLine(string.Format(format, args)); 823622"];
2994 [label="Debug.Assert(_indentDepth >= 0); 823623"];
2995 [label="Unindent(); 823624"];
2996 [label="WriteLine('</assembly>'); 823625"];
2997 [label="WriteLine('</assembly>') 823626"];
2998 [label="param WriteLine(string message) 823627"];
2999 [label="param WriteLine(this) 823628"];
3000 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823629"];
3001 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823630"];
3002 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823631"];
3003 [label="WriteLine('<members>'); 823632"];
3004 [label="WriteLine('<members>') 823633"];
3005 [label="param WriteLine(string message) 823634"];
3006 [label="param WriteLine(this) 823635"];
3007 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823636"];
3008 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823637"];
3009 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823638"];
3010 [label="Indent(); 823639"];
3011 [label="Debug.Assert(!_isForSingleSymbol); 823640"];
3012 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 823641"];
3013 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 823642"];
3014 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 823643"];
3015 [label="DocumentationMode maxDocumentationMode; 823644"];
3016 [label="ImmutableArray<DocumentationCommentTriviaSyntax> docCommentNodes; 823645"];
3017 [label="docCommentNodes 823646"];
3018 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 823647"];
3019 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 823648"];
3020 [label="maxDocumentationMode = DocumentationMode.None; 823649"];
3021 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 823650"];
3022 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 823651"];
3023 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 823652"];
3024 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 823653"];
3025 [label="currDocumentationMode > maxDocumentationMode 823654"];
3026 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 823655"];
3027 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 823656"];
3028 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 823657"];
3029 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 823658"];
3030 [label="return true; 823659"];
3031 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 823660"];
3032 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 823661"];
3033 [label="return; 823662"];
3034 [label="Unindent(); 823663"];
3035 [label="WriteLine('</members>'); 823664"];
3036 [label="WriteLine('</members>') 823665"];
3037 [label="param WriteLine(string message) 823666"];
3038 [label="param WriteLine(this) 823667"];
3039 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823668"];
3040 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823669"];
3041 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823670"];
3042 [label="Unindent(); 823671"];
3043 [label="WriteLine('</doc>'); 823672"];
3044 [label="WriteLine('</doc>') 823673"];
3045 [label="param WriteLine(string message) 823674"];
3046 [label="param WriteLine(this) 823675"];
3047 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823676"];
3048 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823677"];
3049 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 823678"];
3050 [label="Debug.Assert(compiler._indentDepth == 0); 823679"];
3051 [label="Debug.Assert(compiler._indentDepth == 0); 823680"];
3052 [label="writer?.Flush(); 823681"];
3053 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 823682"];
3054 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 823683"];
3055 [label="compilation.SyntaxTrees 823684"];
3056 [label="_syntaxAndDeclarations.GetLazyState() 823685"];
3057 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 823686"];
3058 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 823687"];
3059 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 823688"];
3060 [label="param ReportUnprocessed(CancellationToken cancellationToken) 823689"];
3061 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 823690"];
3062 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 823691"];
3063 [label="param ReportUnusedImports(SyntaxTree? filterTree) 823692"];
3064 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 823693"];
3065 [label="param ReportUnusedImports(CancellationToken cancellationToken) 823694"];
3066 [label="param ReportUnusedImports(this) 823695"];
3067 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 823696"];
3068 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 823697"];
3069 [label="CompleteTrees(filterTree); 823698"];
3070 [label="CompleteTrees(filterTree) 823699"];
3071 [label="param CompleteTrees(SyntaxTree? filterTree) 823700"];
3072 [label="param CompleteTrees(this) 823701"];
3073 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 823702"];
3074 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 823703"];
3075 [label="CompleteTrees(filterTree); 823704"];
3076 [label="SourceAssembly 823705"];
3077 [label="GetBoundReferenceManager() 823706"];
3078 [label="GetBoundReferenceManager(); 823707"];
3079 [label="SourceAssembly.IsDelaySigned 823708"];
3080 [label="SourceAssembly 823709"];
3081 [label="GetBoundReferenceManager() 823710"];
3082 [label="GetBoundReferenceManager(); 823711"];
3083 [label="param GetCorLibraryReferenceToEmit(CodeAnalysis.Emit.EmitContext context) 823712"];
3084 [label="param GetCorLibraryReferenceToEmit(this) 823713"];
3085 [label="CorLibrary 823714"];
3086 [label="get { return SourceModule.ContainingSourceAssembly.CorLibrary; } 823715"];
3087 [label="return SourceModule.ContainingSourceAssembly.CorLibrary; 823716"];
3088 [label="AssemblySymbol corLibrary = CorLibrary; 823717"];
3089 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 823718"];
3090 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 823719"];
3091 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 823720"];
3092 [label="return null; 823721"];
3093 [label="param GetAssemblyReferencesFromAddedModules(DiagnosticBag diagnostics) 823722"];
3094 [label="ImmutableArray<ModuleSymbol> modules = SourceModule.ContainingAssembly.Modules; 823723"];
3095 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 823724"];
3096 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 823725"];
3097 [label="param GetAssemblyReferencesFromAddedModules(this) 823726"];
3098 [label="var modules = sourceAssSymbol.Modules; 823727"];
3099 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 823728"];
3100 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 823729"];
3101 [label="if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        } 823730"];
3102 [label="foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            } 823731"];
3103 [label="param GetAnonymousTypeDefinitions(EmitContext context) 823732"];
3104 [label="if (context.MetadataOnly)\n            {\n                return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>();\n            } 823733"];
3105 [label="Compilation.AnonymousTypeManager 823734"];
3106 [label="return Compilation.AnonymousTypeManager.GetAllCreatedTemplates()\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n\n#endif\n                   ; 823735"];
3107 [label="param GetAdditionalTopLevelTypeDefinitions(EmitContext context) 823736"];
3108 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 823737"];
3109 [label="GetAdditionalTopLevelTypes(context.Diagnostics) 823738"];
3110 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 823739"];
3111 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 823740"];
3112 [label="param GetEmbeddedTypeDefinitions(EmitContext context) 823741"];
3113 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 823742"];
3114 [label="GetEmbeddedTypes(context.Diagnostics) 823743"];
3115 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 823744"];
3116 [label="var builder = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 823745"];
3117 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 823746"];
3118 [label="CreateEmbeddedAttributesIfNeeded(diagnostics) 823747"];
3119 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 823748"];
3120 [label="GetNeedsGeneratedAttributes() 823749"];
3121 [label="_needsGeneratedAttributes_IsFrozen = true; 823750"];
3122 [label="GetNeedsGeneratedAttributesInternal() 823751"];
3123 [label="return GetNeedsGeneratedAttributesInternal(); 823752"];
3124 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 823753"];
3125 [label="ShouldEmitNullablePublicOnlyAttribute() 823754"];
3126 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 823755"];
3127 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 823756"];
3128 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 823757"];
3129 [label="return; 823758"];
3130 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 823759"];
3131 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 823760"];
3132 [label="builder.AddIfNotNull(_lazyIsReadOnlyAttribute); 823761"];
3133 [label="builder.AddIfNotNull(_lazyIsUnmanagedAttribute); 823762"];
3134 [label="builder.AddIfNotNull(_lazyIsByRefLikeAttribute); 823763"];
3135 [label="builder.AddIfNotNull(_lazyNullableAttribute); 823764"];
3136 [label="builder.AddIfNotNull(_lazyNullableContextAttribute); 823765"];
3137 [label="builder.AddIfNotNull(_lazyNullablePublicOnlyAttribute); 823766"];
3138 [label="builder.AddIfNotNull(_lazyNativeIntegerAttribute); 823767"];
3139 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 823768"];
3140 [label="param GetTopLevelSourceTypeDefinitions(EmitContext context) 823769"];
3141 [label="var namespacesToProcess = new Stack<NamespaceSymbol>(); 823770"];
3142 [label="while (namespacesToProcess.Count > 0)\n            {\n                var ns = namespacesToProcess.Pop();\n                foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                }\n            } 823771"];
3143 [label="param GetSynthesizedNestedTypes(NamedTypeSymbol container) 823772"];
3144 [label="param GetSynthesizedNestedTypes(this) 823773"];
3145 [label="return null; 823774"];
3146 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 823775"];
3147 [label="return SourceModule.ContainingSourceAssembly.GetSecurityAttributes(); 823776"];
3148 [label="return SourceModule.GetCustomAttributesToEmit(this); 823777"];
3149 [label="Debug.Assert(symbol.IsDefinition); 823778"];
3150 [label="SourceModule 823779"];
3151 [label="Assembly 823780"];
3152 [label="SourceAssembly 823781"];
3153 [label="GetBoundReferenceManager() 823782"];
3154 [label="GetBoundReferenceManager(); 823783"];
3155 [label="return Assembly.Modules[0]; 823784"];
3156 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 823785"];
3157 [label="EmitNullablePublicOnly 823786"];
3158 [label="param GetExportedTypes(DiagnosticBag diagnostics) 823787"];
3159 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 823788"];
3160 [label="if (!OutputKind.IsNetModule())\n            {\n                var modules = sourceAssembly.Modules;\n                for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                }\n            } 823789"];
3161 [label="var modules = sourceAssembly.Modules; 823790"];
3162 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 823791"];
3163 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 823792"];
3164 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 823793"];
3165 [label="sourceAssembly.DeclaringCompilation.Options 823794"];
3166 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 823795"];
3167 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 823796"];
3168 [label="var seenTopLevelForwardedTypes = new HashSet<NamedTypeSymbol>(); 823797"];
3169 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder) 823798"];
3170 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 823799"];
3171 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 823800"];
3172 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 823801"];
3173 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 823802"];
3174 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 823803"];
3175 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder); 823804"];
3176 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder) 823805"];
3177 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 823806"];
3178 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 823807"];
3179 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 823808"];
3180 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 823809"];
3181 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 823810"];
3182 [label="return seenTopLevelForwardedTypes; 823811"];
3183 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 823812"];
3184 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 823813"];
3185 [label="param AddEmbeddedResourcesFromAddedModules(ArrayBuilder<Cci.ManagedResource> builder) 823814"];
3186 [label="param AddEmbeddedResourcesFromAddedModules(DiagnosticBag diagnostics) 823815"];
3187 [label="param AddEmbeddedResourcesFromAddedModules(this) 823816"];
3188 [label="var modules = _sourceAssembly.Modules; 823817"];
3189 [label="int count = modules.Length; 823818"];
3190 [label="for (int i = 1; i < count; i++)\n            {\n                var file = (Cci.IFileReference)Translate(modules[i], diagnostics);\n\n                try\n                {\n                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow())\n                    {\n                        builder.Add(new Cci.ManagedResource(\n                            resource.Name,\n                            (resource.Attributes & ManifestResourceAttributes.Public) != 0,\n                            null,\n                            file,\n                            resource.Offset));\n                    }\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, modules[i]), NoLocation.Singleton);\n                }\n            } 823819"];
3191 [label="for (int i = 1; i < count; i++)\n            {\n                var file = (Cci.IFileReference)Translate(modules[i], diagnostics);\n\n                try\n                {\n                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow())\n                    {\n                        builder.Add(new Cci.ManagedResource(\n                            resource.Name,\n                            (resource.Attributes & ManifestResourceAttributes.Public) != 0,\n                            null,\n                            file,\n                            resource.Offset));\n                    }\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, modules[i]), NoLocation.Singleton);\n                }\n            } 823820"];
3192 [label="=> ImmutableArray<Cci.UsedNamespaceOrType>.Empty 823821"];
3193 [label="ImmutableArray<Cci.UsedNamespaceOrType>.Empty 823822"];
3194 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 823823"];
3195 [label="Debug.Assert(symbol.IsDefinition); 823824"];
3196 [label="GetBoundReferenceManager(); 823825"];
3197 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 823826"];
3198 [label="GetBoundReferenceManager(); 823827"];
3199 [label="CustomAssert.True(emitResult.Success, 'Diagnostics:\\r\\n' + string.Join('\\r\\n', emitResult.Diagnostics.Select(d => d.ToString()))); 823828"];
3200 [label="CustomAssert.True(emitResult.Success, 'Diagnostics:\\r\\n' + string.Join('\\r\\n', emitResult.Diagnostics.Select(d => d.ToString()))); 823829"];
3201 [label="if (expectedWarnings != null)\n            {\n                emitResult.Diagnostics.Verify(expectedWarnings);\n            } 823830"];
3202 [label="if (expectedWarnings != null)\n            {\n                emitResult.Diagnostics.Verify(expectedWarnings);\n            } 823831"];
3203 [label="return peStream.ToImmutable(); 823832"];
3204 [label="return peStream.ToImmutable(); 823833"];
3205 [label="if (comp.Options.OutputKind == OutputKind.NetModule)\n            {\n                return ModuleMetadata.CreateFromImage(image).GetReference(display: comp.MakeSourceModuleName());\n            }\n            else\n            {\n                return AssemblyMetadata.CreateFromImage(image).GetReference(aliases: aliases, embedInteropTypes: embedInteropTypes, display: comp.MakeSourceAssemblySimpleName());\n            } 823834"];
3206 [label="comp.Options 823835"];
3207 [label="get { return _options; } 823836"];
3208 [label="return AssemblyMetadata.CreateFromImage(image).GetReference(aliases: aliases, embedInteropTypes: embedInteropTypes, display: comp.MakeSourceAssemblySimpleName()); 823837"];
3209 [label="return AssemblyMetadata.CreateFromImage(image).GetReference(aliases: aliases, embedInteropTypes: embedInteropTypes, display: comp.MakeSourceAssemblySimpleName()); 823838"];
3210 [label="return AssemblyMetadata.CreateFromImage(image).GetReference(aliases: aliases, embedInteropTypes: embedInteropTypes, display: comp.MakeSourceAssemblySimpleName()); 823839"];
3211 [label="return AssemblyMetadata.CreateFromImage(image).GetReference(aliases: aliases, embedInteropTypes: embedInteropTypes, display: comp.MakeSourceAssemblySimpleName()); 823840"];
3212 [label="return AssemblyMetadata.CreateFromImage(image).GetReference(aliases: aliases, embedInteropTypes: embedInteropTypes, display: comp.MakeSourceAssemblySimpleName()); 823841"];
3213 [label="string useSource = @'\npublic interface IUsePlatform\n{\n    ITestPlatform M();\n}\n'; 823842"];
3214 [label="var useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { compRef },\n                options: TestOptions.ReleaseDll.WithPlatform(Platform.Itanium)); 823843"];
3215 [label="var useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { compRef },\n                options: TestOptions.ReleaseDll.WithPlatform(Platform.Itanium)); 823844"];
3216 [label="new MetadataReference[] { compRef } 823845"];
3217 [label="var useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { compRef },\n                options: TestOptions.ReleaseDll.WithPlatform(Platform.Itanium)); 823846"];
3218 [label="var useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { compRef },\n                options: TestOptions.ReleaseDll.WithPlatform(Platform.Itanium)); 823847"];
3219 [label="var useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { compRef },\n                options: TestOptions.ReleaseDll.WithPlatform(Platform.Itanium)); 823848"];
3220 [label="new CSharpTestSource(source) 823849"];
3221 [label="param CSharpTestSource(this) 823850"];
3222 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 823851"];
3223 [label="=> CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 823852"];
3224 [label="skipUsesIsNullable 823853"];
3225 [label="null 823854"];
3226 [label="experimentalFeature: null 823855"];
3227 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 823856"];
3228 [label="param CreateCompilationCore(bool skipUsesIsNullable) 823857"];
3229 [label="param CreateCompilationCore(MessageID? experimentalFeature) 823858"];
3230 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 823859"];
3231 [label="var stream = new MemoryStream(); 823860"];
3232 [label="var root = tree.GetRoot(); 823861"];
3233 [label="root.SerializeTo(stream); 823862"];
3234 [label="root.SerializeTo(stream); 823863"];
3235 [label="root.SerializeTo(stream); 823864"];
3236 [label="stream.Position = 0; 823865"];
3237 [label="stream.Position 823866"];
3238 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 823867"];
3239 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 823868"];
3240 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 823869"];
3241 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 823870"];
3242 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 823871"];
3243 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 823872"];
3244 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 823873"];
3245 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 823874"];
3246 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 823875"];
3247 [label="param ValidateIOperations(Func<Compilation> createCompilation) 823876"];
3248 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 823877"];
3249 [label="return; 823878"];
3250 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 823879"];
3251 [label="var compilation = createCompilationLambda(); 823880"];
3252 [label="return Guid.NewGuid().ToString('D'); 823881"];
3253 [label="var compilation = createCompilationLambda(); 823882"];
3254 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 823883"];
3255 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 823884"];
3256 [label="param Create(CSharpCompilation? previousSubmission) 823885"];
3257 [label="param Create(Type? returnType) 823886"];
3258 [label="param Create(Type? hostObjectType) 823887"];
3259 [label="param Create(bool isSubmission) 823888"];
3260 [label="RoslynDebug.Assert(options != null); 823889"];
3261 [label="RoslynDebug.Assert(options != null); 823890"];
3262 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 823891"];
3263 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 823892"];
3264 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 823893"];
3265 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 823894"];
3266 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 823895"];
3267 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 823896"];
3268 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 823897"];
3269 [label="new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null) 823898"];
3270 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 823899"];
3271 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 823900"];
3272 [label="param SyntaxAndDeclarationManager(bool isSubmission) 823901"];
3273 [label="param SyntaxAndDeclarationManager(State state) 823902"];
3274 [label="param SyntaxAndDeclarationManager(this) 823903"];
3275 [label="externalSyntaxTrees 823904"];
3276 [label="messageProvider 823905"];
3277 [label="isSubmission 823906"];
3278 [label="param SyntaxAndDeclarationManager(this) 823907"];
3279 [label="_lazyState 823908"];
3280 [label="_lazyState 823909"];
3281 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 823910"];
3282 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 823911"];
3283 [label="param CSharpCompilation(Type? submissionReturnType) 823912"];
3284 [label="param CSharpCompilation(Type? hostObjectType) 823913"];
3285 [label="param CSharpCompilation(bool isSubmission) 823914"];
3286 [label="param CSharpCompilation(ReferenceManager? referenceManager) 823915"];
3287 [label="param CSharpCompilation(bool reuseReferenceManager) 823916"];
3288 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 823917"];
3289 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 823918"];
3290 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 823919"];
3291 [label="param CSharpCompilation(this) 823920"];
3292 [label="previousSubmission 823921"];
3293 [label="submissionReturnType 823922"];
3294 [label="hostObjectType 823923"];
3295 [label="isSubmission 823924"];
3296 [label="referenceManager 823925"];
3297 [label="reuseReferenceManager 823926"];
3298 [label="syntaxAndDeclarations 823927"];
3299 [label="semanticModelProvider 823928"];
3300 [label="eventQueue 823929"];
3301 [label="param CSharpCompilation(this) 823930"];
3302 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 823931"];
3303 [label="param CSharpCompilation(Type? submissionReturnType) 823932"];
3304 [label="param CSharpCompilation(Type? hostObjectType) 823933"];
3305 [label="param CSharpCompilation(bool isSubmission) 823934"];
3306 [label="param CSharpCompilation(ReferenceManager? referenceManager) 823935"];
3307 [label="param CSharpCompilation(bool reuseReferenceManager) 823936"];
3308 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 823937"];
3309 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 823938"];
3310 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 823939"];
3311 [label="param CSharpCompilation(this) 823940"];
3312 [label="isSubmission 823941"];
3313 [label="semanticModelProvider 823942"];
3314 [label="eventQueue 823943"];
3315 [label="param CSharpCompilation(this) 823944"];
3316 [label="_options 823945"];
3317 [label="_globalImports 823946"];
3318 [label="_previousSubmissionImports 823947"];
3319 [label="_globalNamespaceAlias 823948"];
3320 [label="_scriptClass 823949"];
3321 [label="_lazyHostObjectTypeSymbol 823950"];
3322 [label="_lazyImportInfos 823951"];
3323 [label="_conversions 823952"];
3324 [label="_anonymousTypeManager 823953"];
3325 [label="_lazyGlobalNamespace 823954"];
3326 [label="builtInOperators 823955"];
3327 [label="_lazyAssemblySymbol 823956"];
3328 [label="_referenceManager 823957"];
3329 [label="_syntaxAndDeclarations 823958"];
3330 [label="_lazyEntryPoint 823959"];
3331 [label="_lazyEmitNullablePublicOnly 823960"];
3332 [label="_lazyCompilationUnitCompletedTrees 823961"];
3333 [label="NullableAnalysisData 823962"];
3334 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 823963"];
3335 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 823964"];
3336 [label="_externAliasTargets 823965"];
3337 [label="_moduleInitializerMethods 823966"];
3338 [label="_binderFactories 823967"];
3339 [label="_ignoreAccessibilityBinderFactories 823968"];
3340 [label="_lazyDeclarationDiagnostics 823969"];
3341 [label="_declarationDiagnosticsFrozen 823970"];
3342 [label="new DiagnosticBag() 823971"];
3343 [label="_additionalCodegenWarnings = new DiagnosticBag() 823972"];
3344 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 823973"];
3345 [label="this.builtInOperators = new BuiltInOperators(this); 823974"];
3346 [label="this.builtInOperators = new BuiltInOperators(this); 823975"];
3347 [label="new BuiltInOperators(this) 823976"];
3348 [label="param BuiltInOperators(CSharpCompilation compilation) 823977"];
3349 [label="param BuiltInOperators(this) 823978"];
3350 [label="_compilation 823979"];
3351 [label="_builtInUnaryOperators 823980"];
3352 [label="_builtInOperators 823981"];
3353 [label="_compilation 823982"];
3354 [label="this.builtInOperators 823983"];
3355 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 823984"];
3356 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 823985"];
3357 [label="LanguageVersion? result = null; 823986"];
3358 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 823987"];
3359 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 823988"];
3360 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 823989"];
3361 [label="this.LanguageVersion 823990"];
3362 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 823991"];
3363 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 823992"];
3364 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 823993"];
3365 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 823994"];
3366 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 823995"];
3367 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 823996"];
3368 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 823997"];
3369 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 823998"];
3370 [label="this.Options 823999"];
3371 [label="get\n            {\n                return _options;\n            } 824000"];
3372 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 824001"];
3373 [label="_syntaxAndDeclarations 824002"];
3374 [label="Debug.Assert(_lazyAssemblySymbol is null); 824003"];
3375 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 824004"];
3376 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 824005"];
3377 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 824006"];
3378 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 824007"];
3379 [label="int i = 0; 824008"];
3380 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 824009"];
3381 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 824010"];
3382 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 824011"];
3383 [label="i++; 824012"];
3384 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 824013"];
3385 [label="var scriptClassName = this.ScriptClassName; 824014"];
3386 [label="var resolver = this.Resolver; 824015"];
3387 [label="var messageProvider = this.MessageProvider; 824016"];
3388 [label="var isSubmission = this.IsSubmission; 824017"];
3389 [label="this.PreviousSubmission 824018"];
3390 [label="ScriptCompilationInfo 824019"];
3391 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 824020"];
3392 [label="param CSharpCompilation(Type? submissionReturnType) 824021"];
3393 [label="param CSharpCompilation(Type? hostObjectType) 824022"];
3394 [label="previousSubmission 824023"];
3395 [label="submissionReturnType 824024"];
3396 [label="hostObjectType 824025"];
3397 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 824026"];
3398 [label="param CSharpCompilation(Type? submissionReturnType) 824027"];
3399 [label="param CSharpCompilation(Type? hostObjectType) 824028"];
3400 [label="_compilation 824029"];
3401 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 824030"];
3402 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 824031"];
3403 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 824032"];
3404 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 824033"];
3405 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 824034"];
3406 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 824035"];
3407 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 824036"];
3408 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 824037"];
3409 [label="Debug.Assert(_lazyAssemblySymbol is null); 824038"];
3410 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 824039"];
3411 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 824040"];
3412 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 824041"];
3413 [label="IsNullableEnabled(compilation) 824042"];
3414 [label="compilation.SyntaxTrees 824043"];
3415 [label="_syntaxAndDeclarations.GetLazyState() 824044"];
3416 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 824045"];
3417 [label="param CreateState(SourceReferenceResolver resolver) 824046"];
3418 [label="param CreateState(CommonMessageProvider messageProvider) 824047"];
3419 [label="param AppendAllSyntaxTrees(SourceReferenceResolver resolver) 824048"];
3420 [label="param AppendAllSyntaxTrees(CommonMessageProvider messageProvider) 824049"];
3421 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMapBuilder) 824050"];
3422 [label="param AppendAllSyntaxTrees(IDictionary<string, SyntaxTree> loadedSyntaxTreeMapBuilder) 824051"];
3423 [label="var sourceCodeKind = tree.Options.Kind; 824052"];
3424 [label="if (sourceCodeKind == SourceCodeKind.Script)\n            {\n                AppendAllLoadedSyntaxTrees(treesBuilder, tree, scriptClassName, resolver, messageProvider, isSubmission, ordinalMapBuilder, loadDirectiveMapBuilder, loadedSyntaxTreeMapBuilder, declMapBuilder, ref declTable);\n            } 824053"];
3425 [label="OrdinalMap 824054"];
3426 [label="LoadDirectiveMap 824055"];
3427 [label="LoadedSyntaxTreeMap 824056"];
3428 [label="RootNamespaces 824057"];
3429 [label="DeclarationTable 824058"];
3430 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 824059"];
3431 [label="var options = (CSharpParseOptions)trees[0].Options; 824060"];
3432 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 824061"];
3433 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 824062"];
3434 [label="useCompilation.VerifyEmitDiagnostics(emitOptions); 824063"];
3435 [label="useCompilation.VerifyEmitDiagnostics(emitOptions); 824064"];
3436 [label="useCompilation.VerifyEmitDiagnostics(emitOptions); 824065"];
3437 [label="useCompilation.VerifyEmitDiagnostics(emitOptions) 824066"];
3438 [label="param VerifyEmitDiagnostics(this TCompilation c) 824067"];
3439 [label="param VerifyEmitDiagnostics(EmitOptions options) 824068"];
3440 [label="param VerifyEmitDiagnostics(params DiagnosticDescription[] expected) 824069"];
3441 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 824070"];
3442 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 824071"];
3443 [label="c.GetEmitDiagnostics(options: options) 824072"];
3444 [label="param GetEmitDiagnostics(EmitOptions options = null) 824073"];
3445 [label="param GetEmitDiagnostics(IEnumerable<ResourceDescription> manifestResources = null) 824074"];
3446 [label="MonoHelpers.IsRunningOnMono() 824075"];
3447 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 824076"];
3448 [label="var pdbStream = MonoHelpers.IsRunningOnMono() ? null : new MemoryStream(); 824077"];
3449 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 824078"];
3450 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 824079"];
3451 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 824080"];
3452 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 824081"];
3453 [label="param CreateModuleBuilder(IMethodSymbol? debugEntryPoint) 824082"];
3454 [label="param CreateModuleBuilder(IEnumerable<EmbeddedText>? embeddedTexts) 824083"];
3455 [label="param CreateModuleBuilder(CompilationTestData? testData) 824084"];
3456 [label="param CreateModuleBuilder(CancellationToken cancellationToken) 824085"];
3457 [label="Debug.Assert(!IsSubmission || HasCodeToEmit()); 824086"];
3458 [label="GetRuntimeMetadataVersion(emitOptions, diagnostics) 824087"];
3459 [label="GetRuntimeMetadataVersion(emitOptions) 824088"];
3460 [label="Assembly 824089"];
3461 [label="SourceAssembly 824090"];
3462 [label="GetBoundReferenceManager() 824091"];
3463 [label="get { return this.Compilation; } 824092"];
3464 [label="return this.Compilation; 824093"];
3465 [label="get { return this.Assembly.GetPublicSymbol(); } 824094"];
3466 [label="this.Assembly 824095"];
3467 [label="get\n            {\n                return SourceAssembly;\n            } 824096"];
3468 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 824097"];
3469 [label="return _referenceManager; 824098"];
3470 [label="GetBoundReferenceManager(); 824099"];
3471 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 824100"];
3472 [label="return this.Assembly.GetPublicSymbol(); 824101"];
3473 [label="GetBoundReferenceManager(); 824102"];
3474 [label="param MightContainNoPiaLocalTypes(this) 824103"];
3475 [label="SourceAssembly 824104"];
3476 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 824105"];
3477 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 824106"];
3478 [label="return _referenceManager; 824107"];
3479 [label="GetBoundReferenceManager(); 824108"];
3480 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 824109"];
3481 [label="return SourceAssembly.MightContainNoPiaLocalTypes(); 824110"];
3482 [label="get\n            {\n                return SourceAssembly.DeclaresTheObjectClass;\n            } 824111"];
3483 [label="SourceAssembly 824112"];
3484 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 824113"];
3485 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 824114"];
3486 [label="return _referenceManager; 824115"];
3487 [label="GetBoundReferenceManager(); 824116"];
3488 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 824117"];
3489 [label="return SourceAssembly.DeclaresTheObjectClass; 824118"];
3490 [label="GetBoundReferenceManager(); 824119"];
3491 [label="GetBoundReferenceManager(); 824120"];
3492 [label="GetBoundReferenceManager(); 824121"];
3493 [label="Debug.Assert(_lazyAssemblySymbol is object); 824122"];
3494 [label="GetBoundReferenceManager(); 824123"];
3495 [label="var corAssembly = Assembly.CorLibrary as Symbols.Metadata.PE.PEAssemblySymbol; 824124"];
3496 [label="if (corAssembly is object)\n            {\n                return corAssembly.Assembly.ManifestModule.MetadataVersion;\n            } 824125"];
3497 [label="if (runtimeMDVersion != null)\n            {\n                return runtimeMDVersion;\n            } 824126"];
3498 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 824127"];
3499 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 824128"];
3500 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 824129"];
3501 [label="SourceAssembly 824130"];
3502 [label="GetBoundReferenceManager() 824131"];
3503 [label="GetBoundReferenceManager(); 824132"];
3504 [label="SourceAssembly.IsDelaySigned 824133"];
3505 [label="Declarations 824134"];
3506 [label="_syntaxAndDeclarations.GetLazyState() 824135"];
3507 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 824136"];
3508 [label="return Declarations.GetMergedRoot(this); 824137"];
3509 [label="_syntaxAndDeclarations.GetLazyState() 824138"];
3510 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 824139"];
3511 [label="SourceAssembly 824140"];
3512 [label="GetBoundReferenceManager() 824141"];
3513 [label="GetBoundReferenceManager(); 824142"];
3514 [label="SourceAssembly.StrongNameKeys 824143"];
3515 [label="=> 0x30 824144"];
3516 [label="0x30 824145"];
3517 [label="if (manifestResources == null)\n            {\n                manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>();\n            } 824146"];
3518 [label="PEModuleBuilder moduleBeingBuilt; 824147"];
3519 [label="GetBoundReferenceManager(); 824148"];
3520 [label="get\n            {\n                return true;\n            } 824149"];
3521 [label="if (sourceModule.AnyReferencedAssembliesAreLinked)\n            {\n                _embeddedTypesManagerOpt = new NoPia.EmbeddedTypesManager(this);\n            } 824150"];
3522 [label="Debug.Assert(sourceAssembly is object); 824151"];
3523 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 824152"];
3524 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 824153"];
3525 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 824154"];
3526 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 824155"];
3527 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 824156"];
3528 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 824157"];
3529 [label="PooledHashSet<int>? excludeDiagnostics = null; 824158"];
3530 [label="if (emitMetadataOnly)\n            {\n                excludeDiagnostics = PooledHashSet<int>.GetInstance();\n                excludeDiagnostics.Add((int)ErrorCode.ERR_ConcreteMissingBody);\n            } 824159"];
3531 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 824160"];
3532 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 824161"];
3533 [label="GetDiagnostics(CompilationStage.Declare, true, cancellationToken) 824162"];
3534 [label="param GetDiagnostics(CompilationStage stage) 824163"];
3535 [label="param GetDiagnostics(bool includeEarlierStages) 824164"];
3536 [label="var diagnostics = DiagnosticBag.GetInstance(); 824165"];
3537 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 824166"];
3538 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 824167"];
3539 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 824168"];
3540 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 824169"];
3541 [label="param GetDiagnostics(CompilationStage stage) 824170"];
3542 [label="param GetDiagnostics(bool includeEarlierStages) 824171"];
3543 [label="param GetDiagnostics(DiagnosticBag diagnostics) 824172"];
3544 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 824173"];
3545 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 824174"];
3546 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 824175"];
3547 [label="this.SyntaxTrees 824176"];
3548 [label="_syntaxAndDeclarations.GetLazyState() 824177"];
3549 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 824178"];
3550 [label="this.Options 824179"];
3551 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 824180"];
3552 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 824181"];
3553 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 824182"];
3554 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 824183"];
3555 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 824184"];
3556 [label="CheckAssemblyName(builder); 824185"];
3557 [label="CheckAssemblyName(builder); 824186"];
3558 [label="Options 824187"];
3559 [label="Options 824188"];
3560 [label="get\n            {\n                return _options;\n            } 824189"];
3561 [label="return _options; 824190"];
3562 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 824191"];
3563 [label="GetBoundReferenceManager() 824192"];
3564 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 824193"];
3565 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 824194"];
3566 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 824195"];
3567 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 824196"];
3568 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 824197"];
3569 [label="GlobalImports 824198"];
3570 [label="_globalImports.Value 824199"];
3571 [label="Imports.FromGlobalUsings(this) 824200"];
3572 [label="SourceLocation? location = null; 824201"];
3573 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 824202"];
3574 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 824203"];
3575 [label="Assembly 824204"];
3576 [label="SourceAssembly 824205"];
3577 [label="GetBoundReferenceManager() 824206"];
3578 [label="GetBoundReferenceManager(); 824207"];
3579 [label="Assembly.ForceComplete(location, cancellationToken); 824208"];
3580 [label="Assembly.ForceComplete(location, cancellationToken); 824209"];
3581 [label="SourceAssembly 824210"];
3582 [label="GetBoundReferenceManager() 824211"];
3583 [label="GetBoundReferenceManager(); 824212"];
3584 [label="Declarations 824213"];
3585 [label="_syntaxAndDeclarations.GetLazyState() 824214"];
3586 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 824215"];
3587 [label="return Declarations.GetMergedRoot(this); 824216"];
3588 [label="_syntaxAndDeclarations.GetLazyState() 824217"];
3589 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 824218"];
3590 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 824219"];
3591 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 824220"];
3592 [label="param SymbolDeclaredEvent(Symbol symbol) 824221"];
3593 [label="param SymbolDeclaredEvent(this) 824222"];
3594 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 824223"];
3595 [label="param GetUnaliasedReferencedAssemblies(ArrayBuilder<AssemblySymbol> assemblies) 824224"];
3596 [label="param GetUnaliasedReferencedAssemblies(this) 824225"];
3597 [label="GetBoundReferenceManager() 824226"];
3598 [label="param GetBoundReferenceManager(this) 824227"];
3599 [label="var referenceManager = GetBoundReferenceManager(); 824228"];
3600 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 824229"];
3601 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 824230"];
3602 [label="if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                } 824231"];
3603 [label="assemblies.Add(referenceManager.ReferencedAssemblies[i]); 824232"];
3604 [label="assemblies.Add(referenceManager.ReferencedAssemblies[i]); 824233"];
3605 [label="GetBoundReferenceManager(); 824234"];
3606 [label="param GetBinder(CSharpSyntaxNode syntax) 824235"];
3607 [label="param GetBinder(this) 824236"];
3608 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 824237"];
3609 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 824238"];
3610 [label="GetBinderFactory(syntax.SyntaxTree) 824239"];
3611 [label="param GetBinderFactory(SyntaxTree syntaxTree) 824240"];
3612 [label="param GetBinderFactory(bool ignoreAccessibility = false) 824241"];
3613 [label="param GetBinderFactory(this) 824242"];
3614 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 824243"];
3615 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 824244"];
3616 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 824245"];
3617 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 824246"];
3618 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 824247"];
3619 [label="param GetBinderFactory(SyntaxTree syntaxTree) 824248"];
3620 [label="param GetBinderFactory(bool ignoreAccessibility) 824249"];
3621 [label="param GetBinderFactory(ref WeakReference<BinderFactory>[]? cachedBinderFactories) 824250"];
3622 [label="param GetBinderFactory(this) 824251"];
3623 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 824252"];
3624 [label="ignoreAccessibility 824253"];
3625 [label="_binderFactories 824254"];
3626 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 824255"];
3627 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 824256"];
3628 [label="var treeNum = GetSyntaxTreeOrdinal(syntaxTree); 824257"];
3629 [label="GetSyntaxTreeOrdinal(syntaxTree) 824258"];
3630 [label="param GetSyntaxTreeOrdinal(SyntaxTree tree) 824259"];
3631 [label="param GetSyntaxTreeOrdinal(this) 824260"];
3632 [label="Debug.Assert(this.ContainsSyntaxTree(tree)); 824261"];
3633 [label="this.ContainsSyntaxTree(tree) 824262"];
3634 [label="param ContainsSyntaxTree(SyntaxTree? syntaxTree) 824263"];
3635 [label="param ContainsSyntaxTree(this) 824264"];
3636 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 824265"];
3637 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 824266"];
3638 [label="_syntaxAndDeclarations.GetLazyState() 824267"];
3639 [label="param GetLazyState(this) 824268"];
3640 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 824269"];
3641 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 824270"];
3642 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 824271"];
3643 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 824272"];
3644 [label="_syntaxAndDeclarations.GetLazyState() 824273"];
3645 [label="param GetLazyState(this) 824274"];
3646 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 824275"];
3647 [label="return _syntaxAndDeclarations.GetLazyState().OrdinalMap[tree]; 824276"];
3648 [label="WeakReference<BinderFactory>[]? binderFactories = cachedBinderFactories; 824277"];
3649 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 824278"];
3650 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 824279"];
3651 [label="this.SyntaxTrees 824280"];
3652 [label="param GetLazyState(this) 824281"];
3653 [label="binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length]; 824282"];
3654 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 824283"];
3655 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 824284"];
3656 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 824285"];
3657 [label="BinderFactory? previousFactory; 824286"];
3658 [label="var previousWeakReference = binderFactories[treeNum]; 824287"];
3659 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 824288"];
3660 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 824289"];
3661 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 824290"];
3662 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 824291"];
3663 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 824292"];
3664 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 824293"];
3665 [label="param AddNewFactory(SyntaxTree syntaxTree) 824294"];
3666 [label="param AddNewFactory(bool ignoreAccessibility) 824295"];
3667 [label="param AddNewFactory([NotNull] ref WeakReference<BinderFactory>? slot) 824296"];
3668 [label="param AddNewFactory(this) 824297"];
3669 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 824298"];
3670 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 824299"];
3671 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 824300"];
3672 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 824301"];
3673 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 824302"];
3674 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 824303"];
3675 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 824304"];
3676 [label="BinderFactory? previousFactory; 824305"];
3677 [label="WeakReference<BinderFactory>? previousWeakReference = slot; 824306"];
3678 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 824307"];
3679 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 824308"];
3680 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 824309"];
3681 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 824310"];
3682 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 824311"];
3683 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 824312"];
3684 [label="return newFactory; 824313"];
3685 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 824314"];
3686 [label="get\n            {\n                if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                }\n\n                return _lazyGlobalNamespace;\n            } 824315"];
3687 [label="if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                } 824316"];
3688 [label="var modules = ArrayBuilder<ModuleSymbol>.GetInstance(); 824317"];
3689 [label="GetAllUnaliasedModules(modules); 824318"];
3690 [label="GetAllUnaliasedModules(modules) 824319"];
3691 [label="param GetAllUnaliasedModules(ArrayBuilder<ModuleSymbol> modules) 824320"];
3692 [label="param GetAllUnaliasedModules(this) 824321"];
3693 [label="Assembly 824322"];
3694 [label="get\n            {\n                return SourceAssembly;\n            } 824323"];
3695 [label="GetBoundReferenceManager(); 824324"];
3696 [label="modules.AddRange(Assembly.Modules); 824325"];
3697 [label="modules.AddRange(Assembly.Modules); 824326"];
3698 [label="GetBoundReferenceManager() 824327"];
3699 [label="param GetBoundReferenceManager(this) 824328"];
3700 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 824329"];
3701 [label="return _referenceManager; 824330"];
3702 [label="var referenceManager = GetBoundReferenceManager(); 824331"];
3703 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 824332"];
3704 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 824333"];
3705 [label="if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                } 824334"];
3706 [label="modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules); 824335"];
3707 [label="GetAllUnaliasedModules(modules); 824336"];
3708 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 824337"];
3709 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 824338"];
3710 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 824339"];
3711 [label="modules.Free(); 824340"];
3712 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 824341"];
3713 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 824342"];
3714 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 824343"];
3715 [label="return _lazyGlobalNamespace; 824344"];
3716 [label="Assembly 824345"];
3717 [label="SourceAssembly 824346"];
3718 [label="GetBoundReferenceManager() 824347"];
3719 [label="GetBoundReferenceManager(); 824348"];
3720 [label="return Assembly.Modules[0]; 824349"];
3721 [label="param IsNullableAnalysisEnabledIn(SyntaxNode syntax) 824350"];
3722 [label="param IsNullableAnalysisEnabledIn(this) 824351"];
3723 [label="return IsNullableAnalysisEnabledIn((CSharpSyntaxTree)syntax.SyntaxTree, syntax.Span); 824352"];
3724 [label="IsNullableAnalysisEnabledIn((CSharpSyntaxTree)syntax.SyntaxTree, syntax.Span) 824353"];
3725 [label="param IsNullableAnalysisEnabledIn(CSharpSyntaxTree tree) 824354"];
3726 [label="param IsNullableAnalysisEnabledIn(TextSpan span) 824355"];
3727 [label="param IsNullableAnalysisEnabledIn(this) 824356"];
3728 [label="GetNullableAnalysisValue() 824357"];
3729 [label="param GetNullableAnalysisValue(this) 824358"];
3730 [label="return Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            }; 824359"];
3731 [label="return Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            }; 824360"];
3732 [label="Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            } 824361"];
3733 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 824362"];
3734 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 824363"];
3735 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 824364"];
3736 [label="Options 824365"];
3737 [label="get\n            {\n                return _options;\n            } 824366"];
3738 [label="return _options; 824367"];
3739 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 824368"];
3740 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 824369"];
3741 [label="param GetBinderFactory(SyntaxTree syntaxTree) 824370"];
3742 [label="param GetBinderFactory(bool ignoreAccessibility = false) 824371"];
3743 [label="param GetBinderFactory(this) 824372"];
3744 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 824373"];
3745 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 824374"];
3746 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 824375"];
3747 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 824376"];
3748 [label="param GetBinderFactory(SyntaxTree syntaxTree) 824377"];
3749 [label="param GetBinderFactory(bool ignoreAccessibility) 824378"];
3750 [label="param GetBinderFactory(this) 824379"];
3751 [label="ignoreAccessibility 824380"];
3752 [label="var treeNum = GetSyntaxTreeOrdinal(syntaxTree); 824381"];
3753 [label="GetSyntaxTreeOrdinal(syntaxTree) 824382"];
3754 [label="param GetSyntaxTreeOrdinal(SyntaxTree tree) 824383"];
3755 [label="param GetSyntaxTreeOrdinal(this) 824384"];
3756 [label="Debug.Assert(this.ContainsSyntaxTree(tree)); 824385"];
3757 [label="this.ContainsSyntaxTree(tree) 824386"];
3758 [label="param ContainsSyntaxTree(SyntaxTree? syntaxTree) 824387"];
3759 [label="param ContainsSyntaxTree(this) 824388"];
3760 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 824389"];
3761 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 824390"];
3762 [label="_syntaxAndDeclarations.GetLazyState() 824391"];
3763 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 824392"];
3764 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 824393"];
3765 [label="_syntaxAndDeclarations.GetLazyState() 824394"];
3766 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 824395"];
3767 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 824396"];
3768 [label="BinderFactory? previousFactory; 824397"];
3769 [label="var previousWeakReference = binderFactories[treeNum]; 824398"];
3770 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 824399"];
3771 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 824400"];
3772 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 824401"];
3773 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 824402"];
3774 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 824403"];
3775 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 824404"];
3776 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 824405"];
3777 [label="param AddNewFactory(SyntaxTree syntaxTree) 824406"];
3778 [label="param AddNewFactory(bool ignoreAccessibility) 824407"];
3779 [label="param AddNewFactory(this) 824408"];
3780 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 824409"];
3781 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 824410"];
3782 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 824411"];
3783 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 824412"];
3784 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 824413"];
3785 [label="BinderFactory? previousFactory; 824414"];
3786 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 824415"];
3787 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 824416"];
3788 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 824417"];
3789 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 824418"];
3790 [label="get\n            {\n                if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                }\n\n                return _lazyGlobalNamespace;\n            } 824419"];
3791 [label="Assembly 824420"];
3792 [label="SourceAssembly 824421"];
3793 [label="GetBoundReferenceManager() 824422"];
3794 [label="GetBoundReferenceManager(); 824423"];
3795 [label="return Assembly.Modules[0]; 824424"];
3796 [label="param IsFeatureEnabled(this CSharpCompilation compilation) 824425"];
3797 [label="param IsFeatureEnabled(MessageID feature) 824426"];
3798 [label="compilation.SyntaxTrees 824427"];
3799 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 824428"];
3800 [label="_syntaxAndDeclarations.GetLazyState() 824429"];
3801 [label="param GetLazyState(this) 824430"];
3802 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 824431"];
3803 [label="return ((CSharpParseOptions)compilation.SyntaxTrees.FirstOrDefault()?.Options)?.IsFeatureEnabled(feature) == true; 824432"];
3804 [label="return ((CSharpParseOptions)compilation.SyntaxTrees.FirstOrDefault()?.Options)?.IsFeatureEnabled(feature) == true; 824433"];
3805 [label="return ((CSharpParseOptions)compilation.SyntaxTrees.FirstOrDefault()?.Options)?.IsFeatureEnabled(feature) == true; 824434"];
3806 [label="return ((CSharpParseOptions)compilation.SyntaxTrees.FirstOrDefault()?.Options)?.IsFeatureEnabled(feature) == true; 824435"];
3807 [label="param GetSpecialType(SpecialType specialType) 824436"];
3808 [label="param GetSpecialType(this) 824437"];
3809 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 824438"];
3810 [label="NamedTypeSymbol result; 824439"];
3811 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 824440"];
3812 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 824441"];
3813 [label="Assembly 824442"];
3814 [label="GetBoundReferenceManager(); 824443"];
3815 [label="result = Assembly.GetSpecialType(specialType); 824444"];
3816 [label="result = Assembly.GetSpecialType(specialType); 824445"];
3817 [label="Debug.Assert(result.SpecialType == specialType); 824446"];
3818 [label="return result; 824447"];
3819 [label="GetBoundReferenceManager(); 824448"];
3820 [label="Debug.Assert(symbol.IsDefinition); 824449"];
3821 [label="SourceModule 824450"];
3822 [label="Assembly 824451"];
3823 [label="SourceAssembly 824452"];
3824 [label="GetBoundReferenceManager() 824453"];
3825 [label="GetBoundReferenceManager(); 824454"];
3826 [label="return Assembly.Modules[0]; 824455"];
3827 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 824456"];
3828 [label="EmitNullablePublicOnly 824457"];
3829 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 824458"];
3830 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 824459"];
3831 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 824460"];
3832 [label="_declarationDiagnosticsFrozen = true; 824461"];
3833 [label="_needsGeneratedAttributes_IsFrozen = true; 824462"];
3834 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 824463"];
3835 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 824464"];
3836 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 824465"];
3837 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 824466"];
3838 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 824467"];
3839 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 824468"];
3840 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 824469"];
3841 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 824470"];
3842 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 824471"];
3843 [label="param CheckCompliance(DiagnosticBag diagnostics) 824472"];
3844 [label="GetBoundReferenceManager(); 824473"];
3845 [label="System.Diagnostics.Debug.Assert(symbol is SourceAssemblySymbol); 824474"];
3846 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 824475"];
3847 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 824476"];
3848 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 824477"];
3849 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 824478"];
3850 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 824479"];
3851 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 824480"];
3852 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 824481"];
3853 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 824482"];
3854 [label="Location ignoredLocation; 824483"];
3855 [label="param GetDeclaredCompliance(out Location attributeLocation) 824484"];
3856 [label="param GetDeclaredCompliance(this) 824485"];
3857 [label="attributeLocation = null; 824486"];
3858 [label="if (assemblyCompliance == Compliance.DeclaredFalse)\n            {\n                // Our interpretation of an assembly-level CLSCompliant attribute is as follows:\n                //   1) If true, then perform all CLS checks.\n                //   2) If false, then perform no CLS checks (dev11 still performs a few, mostly around\n                //      meaningless attributes).  Our interpretation is that the user ultimately wants\n                //      his code to be CLS-compliant, but is temporarily disabling the checks (e.g. during\n                //      refactoring/prototyping).\n                //   3) If absent, the perform all CLS checks.  Our interpretation is that - in the\n                //      absence of an assembly-level attribute - any CLS problems within the compilation\n                //      indicate that the user was trying to do something but didn't know how.  It would\n                //      be nice if the most common case (i.e. this one) was the cheapest, but we don't\n                //      want to confuse novice users.\n                return;\n            } 824487"];
3859 [label="bool assemblyComplianceValue = IsTrue(assemblyCompliance); 824488"];
3860 [label="IsTrue(assemblyCompliance) 824489"];
3861 [label="param IsTrue(Compliance compliance) 824490"];
3862 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 824491"];
3863 [label="return false; 824492"];
3864 [label="Location attributeLocation; 824493"];
3865 [label="param GetDeclaredCompliance(out Location attributeLocation) 824494"];
3866 [label="param GetDeclaredCompliance(this) 824495"];
3867 [label="attributeLocation = null; 824496"];
3868 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 824497"];
3869 [label="i == 0 824498"];
3870 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 824499"];
3871 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 824500"];
3872 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 824501"];
3873 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 824502"];
3874 [label="if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 824503"];
3875 [label="if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 824504"];
3876 [label="if (assemblyComplianceValue)\n            {\n                CheckForAttributeWithArrayArgument(symbol);\n            } 824505"];
3877 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 824506"];
3878 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 824507"];
3879 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 824508"];
3880 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 824509"];
3881 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 824510"];
3882 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 824511"];
3883 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 824512"];
3884 [label="System.Diagnostics.Debug.Assert(symbol.Kind != SymbolKind.Assembly); 824513"];
3885 [label="System.Diagnostics.Debug.Assert((object)containing != null); 824514"];
3886 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 824515"];
3887 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 824516"];
3888 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 824517"];
3889 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 824518"];
3890 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 824519"];
3891 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 824520"];
3892 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 824521"];
3893 [label="return compliance; 824522"];
3894 [label="IsTrue(GetInheritedCompliance(symbol)) 824523"];
3895 [label="param IsTrue(Compliance compliance) 824524"];
3896 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 824525"];
3897 [label="return false; 824526"];
3898 [label="IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)) 824527"];
3899 [label="param IsTrue(Compliance compliance) 824528"];
3900 [label="if (DoNotVisit(symbol)) return; 824529"];
3901 [label="DoNotVisit(symbol) 824530"];
3902 [label="param DoNotVisit(Symbol symbol) 824531"];
3903 [label="param DoNotVisit(this) 824532"];
3904 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                return false;\n            } 824533"];
3905 [label="return false; 824534"];
3906 [label="IsTrue(GetDeclaredOrInheritedCompliance(symbol)) 824535"];
3907 [label="param IsTrue(Compliance compliance) 824536"];
3908 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 824537"];
3909 [label="return false; 824538"];
3910 [label="if (tasks == null)\n            {\n                return;\n            } 824539"];
3911 [label="if (tasks == null)\n            {\n                return;\n            } 824540"];
3912 [label="checker.WaitForWorkers(); 824541"];
3913 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 824542"];
3914 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 824543"];
3915 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 824544"];
3916 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 824545"];
3917 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 824546"];
3918 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 824547"];
3919 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 824548"];
3920 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 824549"];
3921 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 824550"];
3922 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 824551"];
3923 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 824552"];
3924 [label="excludeDiagnostics?.Free(); 824553"];
3925 [label="param AddDebugSourceDocumentsForChecksumDirectives(DebugDocumentsBuilder documentsBuilder) 824554"];
3926 [label="param AddDebugSourceDocumentsForChecksumDirectives(DiagnosticBag diagnostics) 824555"];
3927 [label="param AddDebugSourceDocumentsForChecksumDirectives(this) 824556"];
3928 [label="foreach (var directive in checksumDirectives)\n            {\n                var checksumDirective = (PragmaChecksumDirectiveTriviaSyntax)directive;\n                var path = checksumDirective.File.ValueText;\n\n                var checksumText = checksumDirective.Bytes.ValueText;\n                var normalizedPath = documentsBuilder.NormalizeDebugDocumentPath(path, basePath: tree.FilePath);\n                var existingDoc = documentsBuilder.TryGetDebugDocumentForNormalizedPath(normalizedPath);\n\n                // duplicate checksum pragmas are valid as long as values match\n                // if we have seen this document already, check for matching values.\n                if (existingDoc != null)\n                {\n                    // pragma matches a file path on an actual tree.\n                    // Dev12 compiler just ignores the pragma in this case which means that\n                    // checksum of the actual tree always wins and no warning is given.\n                    // We will continue doing the same.\n                    if (existingDoc.IsComputedChecksum)\n                    {\n                        continue;\n                    }\n\n                    var sourceInfo = existingDoc.GetSourceInfo();\n                    if (ChecksumMatches(checksumText, sourceInfo.Checksum))\n                    {\n                        var guid = Guid.Parse(checksumDirective.Guid.ValueText);\n                        if (guid == sourceInfo.ChecksumAlgorithmId)\n                        {\n                            // all parts match, nothing to do\n                            continue;\n                        }\n                    }\n\n                    // did not match to an existing document\n                    // produce a warning and ignore the pragma\n                    diagnostics.Add(ErrorCode.WRN_ConflictingChecksum, new SourceLocation(checksumDirective), path);\n                }\n                else\n                {\n                    var newDocument = new Cci.DebugSourceDocument(\n                        normalizedPath,\n                        Cci.DebugSourceDocument.CorSymLanguageTypeCSharp,\n                        MakeChecksumBytes(checksumText),\n                        Guid.Parse(checksumDirective.Guid.ValueText));\n\n                    documentsBuilder.AddDebugDocument(newDocument);\n                }\n            } 824557"];
3929 [label="Debug.Assert(compilation != null); 824558"];
3930 [label="Debug.Assert(diagnostics != null); 824559"];
3931 [label="compilation.PreviousSubmission 824560"];
3932 [label="ScriptCompilationInfo 824561"];
3933 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 824562"];
3934 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 824563"];
3935 [label="MethodSymbol entryPoint = null; 824564"];
3936 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 824565"];
3937 [label="param GetEntryPoint(bool hasDeclarationErrors) 824566"];
3938 [label="param GetEntryPoint(CancellationToken cancellationToken) 824567"];
3939 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 824568"];
3940 [label="EntryPoint? entryPoint; 824569"];
3941 [label="GetBoundReferenceManager(); 824570"];
3942 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 824571"];
3943 [label="Debug.Assert(compilation != null); 824572"];
3944 [label="Debug.Assert(diagnostics != null); 824573"];
3945 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 824574"];
3946 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 824575"];
3947 [label="param SetGlobalErrorIfTrue(bool arg) 824576"];
3948 [label="param SetGlobalErrorIfTrue(this) 824577"];
3949 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 824578"];
3950 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 824579"];
3951 [label="GetBoundReferenceManager(); 824580"];
3952 [label="param VisitNamedType(TypeCompilationState arg) 824581"];
3953 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 824582"];
3954 [label="PassesFilter(_filterOpt, symbol) 824583"];
3955 [label="param PassesFilter(Predicate<Symbol> filterOpt) 824584"];
3956 [label="param PassesFilter(Symbol symbol) 824585"];
3957 [label="return (filterOpt == null) || filterOpt(symbol); 824586"];
3958 [label="return (filterOpt == null) || filterOpt(symbol); 824587"];
3959 [label="arg = null; 824588"];
3960 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 824589"];
3961 [label="if (tasks == null)\n            {\n                return;\n            } 824590"];
3962 [label="if (tasks == null)\n            {\n                return;\n            } 824591"];
3963 [label="methodCompiler.WaitForWorkers(); 824592"];
3964 [label="var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics); 824593"];
3965 [label="moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics) 824594"];
3966 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 824595"];
3967 [label="_additionalTypes 824596"];
3968 [label="var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics); 824597"];
3969 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 824598"];
3970 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 824599"];
3971 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics) 824600"];
3972 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 824601"];
3973 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 824602"];
3974 [label="param CompileSynthesizedMethods(this) 824603"];
3975 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 824604"];
3976 [label="var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics); 824605"];
3977 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 824606"];
3978 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 824607"];
3979 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 824608"];
3980 [label="return GetNeedsGeneratedAttributesInternal(); 824609"];
3981 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 824610"];
3982 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 824611"];
3983 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 824612"];
3984 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 824613"];
3985 [label="return; 824614"];
3986 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 824615"];
3987 [label="var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics); 824616"];
3988 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 824617"];
3989 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 824618"];
3990 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics) 824619"];
3991 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 824620"];
3992 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 824621"];
3993 [label="param CompileSynthesizedMethods(this) 824622"];
3994 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 824623"];
3995 [label="param GetPreviousAnonymousTypes(this) 824624"];
3996 [label="param GetNextAnonymousTypeIndex(this) 824625"];
3997 [label="methodCompiler.WaitForWorkers(); 824626"];
3998 [label="var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass; 824627"];
3999 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 824628"];
4000 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 824629"];
4001 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 824630"];
4002 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 824631"];
4003 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 824632"];
4004 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 824633"];
4005 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 824634"];
4006 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag) 824635"];
4007 [label="param GenerateModuleInitializer(PEModuleBuilder moduleBeingBuilt) 824636"];
4008 [label="param GenerateModuleInitializer(DiagnosticBag methodBodyDiagnosticBag) 824637"];
4009 [label="param GenerateModuleInitializer(this) 824638"];
4010 [label="Debug.Assert(_declarationDiagnosticsFrozen); 824639"];
4011 [label="if (_moduleInitializerMethods is object)\n            {\n                var ilBuilder = new ILBuilder(moduleBeingBuilt, new LocalSlotManager(slotAllocator: null), OptimizationLevel.Release, areLocalsZeroed: false);\n\n                foreach (MethodSymbol method in _moduleInitializerMethods.OrderBy<MethodSymbol>(LexicalOrderSymbolComparer.Instance))\n                {\n                    ilBuilder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n\n                    ilBuilder.EmitToken(\n                        moduleBeingBuilt.Translate(method, methodBodyDiagnosticBag, needDeclaration: true),\n                        CSharpSyntaxTree.Dummy.GetRoot(),\n                        methodBodyDiagnosticBag);\n                }\n\n                ilBuilder.EmitRet(isVoid: true);\n                ilBuilder.Realize();\n                moduleBeingBuilt.RootModuleType.SetStaticConstructorBody(ilBuilder.RealizedIL);\n            } 824640"];
4012 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 824641"];
4013 [label="if (hasDeclarationErrors || hasMethodBodyError)\n                {\n                    return false;\n                } 824642"];
4014 [label="return true; 824643"];
4015 [label="DiagnosticBag? resourceDiagnostics = DiagnosticBag.GetInstance(); 824644"];
4016 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 824645"];
4017 [label="SourceAssembly 824646"];
4018 [label="GetBoundReferenceManager() 824647"];
4019 [label="GetBoundReferenceManager(); 824648"];
4020 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 824649"];
4021 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 824650"];
4022 [label="AddedModulesResourceNames(resourceDiagnostics) 824651"];
4023 [label="param AddedModulesResourceNames(DiagnosticBag diagnostics) 824652"];
4024 [label="SourceAssembly 824653"];
4025 [label="GetBoundReferenceManager() 824654"];
4026 [label="GetBoundReferenceManager(); 824655"];
4027 [label="ImmutableArray<ModuleSymbol> modules = SourceAssembly.Modules; 824656"];
4028 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 824657"];
4029 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 824658"];
4030 [label="param AddedModulesResourceNames(this) 824659"];
4031 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 824660"];
4032 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 824661"];
4033 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 824662"];
4034 [label="DiagnosticBag? xmlDiagnostics = DiagnosticBag.GetInstance(); 824663"];
4035 [label="string? assemblyName = FileNameUtilities.ChangeExtension(outputNameOverride, extension: null); 824664"];
4036 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 824665"];
4037 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 824666"];
4038 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken) 824667"];
4039 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 824668"];
4040 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 824669"];
4041 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 824670"];
4042 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 824671"];
4043 [label="StreamWriter writer = null; 824672"];
4044 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 824673"];
4045 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 824674"];
4046 [label="compilation.SourceAssembly 824675"];
4047 [label="GetBoundReferenceManager() 824676"];
4048 [label="GetBoundReferenceManager(); 824677"];
4049 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 824678"];
4050 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 824679"];
4051 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 824680"];
4052 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 824681"];
4053 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 824682"];
4054 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 824683"];
4055 [label="param DocumentationCommentCompiler(TextWriter writer) 824684"];
4056 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 824685"];
4057 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 824686"];
4058 [label="param DocumentationCommentCompiler(bool processIncludes) 824687"];
4059 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 824688"];
4060 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 824689"];
4061 [label="param DocumentationCommentCompiler(this) 824690"];
4062 [label="param DocumentationCommentCompiler(this) 824691"];
4063 [label="_assemblyName 824692"];
4064 [label="_compilation 824693"];
4065 [label="_writer 824694"];
4066 [label="_filterTree 824695"];
4067 [label="_filterSpanWithinTree 824696"];
4068 [label="_processIncludes 824697"];
4069 [label="_isForSingleSymbol 824698"];
4070 [label="_diagnostics 824699"];
4071 [label="_lazyComparer 824700"];
4072 [label="_includedFileCache 824701"];
4073 [label="_indentDepth 824702"];
4074 [label="_temporaryStringBuilders 824703"];
4075 [label="_writer 824704"];
4076 [label="_filterTree 824705"];
4077 [label="_filterSpanWithinTree 824706"];
4078 [label="_processIncludes 824707"];
4079 [label="_isForSingleSymbol 824708"];
4080 [label="_diagnostics 824709"];
4081 [label="compilation.SourceAssembly 824710"];
4082 [label="GetBoundReferenceManager() 824711"];
4083 [label="GetBoundReferenceManager(); 824712"];
4084 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 824713"];
4085 [label="Debug.Assert(_assemblyName != null); 824714"];
4086 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 824715"];
4087 [label="WriteLine('<?xml version=\\'1.0\\'?>') 824716"];
4088 [label="param WriteLine(string message) 824717"];
4089 [label="param WriteLine(this) 824718"];
4090 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824719"];
4091 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824720"];
4092 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824721"];
4093 [label="WriteLine('<doc>'); 824722"];
4094 [label="WriteLine('<doc>') 824723"];
4095 [label="param WriteLine(string message) 824724"];
4096 [label="param WriteLine(this) 824725"];
4097 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824726"];
4098 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824727"];
4099 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824728"];
4100 [label="Indent(); 824729"];
4101 [label="WriteLine('<assembly>'); 824730"];
4102 [label="WriteLine('<assembly>') 824731"];
4103 [label="param WriteLine(string message) 824732"];
4104 [label="param WriteLine(this) 824733"];
4105 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824734"];
4106 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824735"];
4107 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824736"];
4108 [label="Indent(); 824737"];
4109 [label="WriteLine('<name>{0}</name>', _assemblyName); 824738"];
4110 [label="WriteLine('<name>{0}</name>', _assemblyName) 824739"];
4111 [label="WriteLine('<name>{0}</name>', _assemblyName) 824740"];
4112 [label="param WriteLine(string format) 824741"];
4113 [label="param WriteLine(params object[] args) 824742"];
4114 [label="param WriteLine(this) 824743"];
4115 [label="WriteLine(string.Format(format, args)); 824744"];
4116 [label="WriteLine(string.Format(format, args)); 824745"];
4117 [label="WriteLine(string.Format(format, args)); 824746"];
4118 [label="WriteLine(string.Format(format, args)) 824747"];
4119 [label="param WriteLine(string message) 824748"];
4120 [label="param WriteLine(this) 824749"];
4121 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824750"];
4122 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824751"];
4123 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824752"];
4124 [label="WriteLine(string.Format(format, args)); 824753"];
4125 [label="Debug.Assert(_indentDepth >= 0); 824754"];
4126 [label="Unindent(); 824755"];
4127 [label="WriteLine('</assembly>'); 824756"];
4128 [label="WriteLine('</assembly>') 824757"];
4129 [label="param WriteLine(string message) 824758"];
4130 [label="param WriteLine(this) 824759"];
4131 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824760"];
4132 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824761"];
4133 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824762"];
4134 [label="WriteLine('<members>'); 824763"];
4135 [label="WriteLine('<members>') 824764"];
4136 [label="param WriteLine(string message) 824765"];
4137 [label="param WriteLine(this) 824766"];
4138 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824767"];
4139 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824768"];
4140 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824769"];
4141 [label="Indent(); 824770"];
4142 [label="Debug.Assert(!_isForSingleSymbol); 824771"];
4143 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 824772"];
4144 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 824773"];
4145 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 824774"];
4146 [label="DocumentationMode maxDocumentationMode; 824775"];
4147 [label="ImmutableArray<DocumentationCommentTriviaSyntax> docCommentNodes; 824776"];
4148 [label="docCommentNodes 824777"];
4149 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 824778"];
4150 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 824779"];
4151 [label="maxDocumentationMode = DocumentationMode.None; 824780"];
4152 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 824781"];
4153 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 824782"];
4154 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 824783"];
4155 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 824784"];
4156 [label="currDocumentationMode > maxDocumentationMode 824785"];
4157 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 824786"];
4158 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 824787"];
4159 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 824788"];
4160 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 824789"];
4161 [label="return true; 824790"];
4162 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 824791"];
4163 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 824792"];
4164 [label="return; 824793"];
4165 [label="_cancellationToken.ThrowIfCancellationRequested(); 824794"];
4166 [label="member.Accept(this); 824795"];
4167 [label="member.Accept(this); 824796"];
4168 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 824797"];
4169 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 824798"];
4170 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 824799"];
4171 [label="DocumentationMode maxDocumentationMode; 824800"];
4172 [label="ImmutableArray<DocumentationCommentTriviaSyntax> docCommentNodes; 824801"];
4173 [label="docCommentNodes 824802"];
4174 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 824803"];
4175 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 824804"];
4176 [label="maxDocumentationMode = DocumentationMode.None; 824805"];
4177 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 824806"];
4178 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 824807"];
4179 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 824808"];
4180 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 824809"];
4181 [label="currDocumentationMode > maxDocumentationMode 824810"];
4182 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 824811"];
4183 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 824812"];
4184 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 824813"];
4185 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 824814"];
4186 [label="return true; 824815"];
4187 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 824816"];
4188 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 824817"];
4189 [label="return; 824818"];
4190 [label="Debug.Assert(_indentDepth >= 0); 824819"];
4191 [label="Unindent(); 824820"];
4192 [label="WriteLine('</members>'); 824821"];
4193 [label="WriteLine('</members>') 824822"];
4194 [label="param WriteLine(string message) 824823"];
4195 [label="param WriteLine(this) 824824"];
4196 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824825"];
4197 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824826"];
4198 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824827"];
4199 [label="Unindent(); 824828"];
4200 [label="WriteLine('</doc>'); 824829"];
4201 [label="WriteLine('</doc>') 824830"];
4202 [label="param WriteLine(string message) 824831"];
4203 [label="param WriteLine(this) 824832"];
4204 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824833"];
4205 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824834"];
4206 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 824835"];
4207 [label="Debug.Assert(compiler._indentDepth == 0); 824836"];
4208 [label="Debug.Assert(compiler._indentDepth == 0); 824837"];
4209 [label="writer?.Flush(); 824838"];
4210 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 824839"];
4211 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 824840"];
4212 [label="compilation.SyntaxTrees 824841"];
4213 [label="_syntaxAndDeclarations.GetLazyState() 824842"];
4214 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 824843"];
4215 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 824844"];
4216 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 824845"];
4217 [label="param ReportUnprocessed(CancellationToken cancellationToken) 824846"];
4218 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 824847"];
4219 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 824848"];
4220 [label="param ReportUnusedImports(SyntaxTree? filterTree) 824849"];
4221 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 824850"];
4222 [label="param ReportUnusedImports(CancellationToken cancellationToken) 824851"];
4223 [label="param ReportUnusedImports(this) 824852"];
4224 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 824853"];
4225 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 824854"];
4226 [label="CompleteTrees(filterTree); 824855"];
4227 [label="CompleteTrees(filterTree) 824856"];
4228 [label="param CompleteTrees(SyntaxTree? filterTree) 824857"];
4229 [label="param CompleteTrees(this) 824858"];
4230 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 824859"];
4231 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 824860"];
4232 [label="CompleteTrees(filterTree); 824861"];
4233 [label="this.SourceModule 824862"];
4234 [label="Assembly 824863"];
4235 [label="SourceAssembly 824864"];
4236 [label="GetBoundReferenceManager() 824865"];
4237 [label="GetBoundReferenceManager(); 824866"];
4238 [label="return Assembly.Modules[0]; 824867"];
4239 [label="SourceAssembly 824868"];
4240 [label="GetBoundReferenceManager() 824869"];
4241 [label="GetBoundReferenceManager(); 824870"];
4242 [label="SourceAssembly.IsDelaySigned 824871"];
4243 [label="SourceAssembly 824872"];
4244 [label="GetBoundReferenceManager() 824873"];
4245 [label="GetBoundReferenceManager(); 824874"];
4246 [label="param GetCorLibraryReferenceToEmit(CodeAnalysis.Emit.EmitContext context) 824875"];
4247 [label="param GetCorLibraryReferenceToEmit(this) 824876"];
4248 [label="CorLibrary 824877"];
4249 [label="get { return SourceModule.ContainingSourceAssembly.CorLibrary; } 824878"];
4250 [label="return SourceModule.ContainingSourceAssembly.CorLibrary; 824879"];
4251 [label="AssemblySymbol corLibrary = CorLibrary; 824880"];
4252 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 824881"];
4253 [label="return null; 824882"];
4254 [label="param GetAssemblyReferencesFromAddedModules(DiagnosticBag diagnostics) 824883"];
4255 [label="ImmutableArray<ModuleSymbol> modules = SourceModule.ContainingAssembly.Modules; 824884"];
4256 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 824885"];
4257 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 824886"];
4258 [label="param GetAssemblyReferencesFromAddedModules(this) 824887"];
4259 [label="var modules = sourceAssSymbol.Modules; 824888"];
4260 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 824889"];
4261 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 824890"];
4262 [label="if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        } 824891"];
4263 [label="foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            } 824892"];
4264 [label="param GetAnonymousTypeDefinitions(EmitContext context) 824893"];
4265 [label="if (context.MetadataOnly)\n            {\n                return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>();\n            } 824894"];
4266 [label="Compilation.AnonymousTypeManager 824895"];
4267 [label="return Compilation.AnonymousTypeManager.GetAllCreatedTemplates()\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n\n#endif\n                   ; 824896"];
4268 [label="param GetAdditionalTopLevelTypeDefinitions(EmitContext context) 824897"];
4269 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 824898"];
4270 [label="GetAdditionalTopLevelTypes(context.Diagnostics) 824899"];
4271 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 824900"];
4272 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 824901"];
4273 [label="param GetEmbeddedTypeDefinitions(EmitContext context) 824902"];
4274 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 824903"];
4275 [label="GetEmbeddedTypes(context.Diagnostics) 824904"];
4276 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 824905"];
4277 [label="var builder = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 824906"];
4278 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 824907"];
4279 [label="CreateEmbeddedAttributesIfNeeded(diagnostics) 824908"];
4280 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 824909"];
4281 [label="GetNeedsGeneratedAttributes() 824910"];
4282 [label="_needsGeneratedAttributes_IsFrozen = true; 824911"];
4283 [label="GetNeedsGeneratedAttributesInternal() 824912"];
4284 [label="return GetNeedsGeneratedAttributesInternal(); 824913"];
4285 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 824914"];
4286 [label="ShouldEmitNullablePublicOnlyAttribute() 824915"];
4287 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 824916"];
4288 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 824917"];
4289 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 824918"];
4290 [label="return; 824919"];
4291 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 824920"];
4292 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 824921"];
4293 [label="builder.AddIfNotNull(_lazyIsReadOnlyAttribute); 824922"];
4294 [label="builder.AddIfNotNull(_lazyIsUnmanagedAttribute); 824923"];
4295 [label="builder.AddIfNotNull(_lazyIsByRefLikeAttribute); 824924"];
4296 [label="builder.AddIfNotNull(_lazyNullableAttribute); 824925"];
4297 [label="builder.AddIfNotNull(_lazyNullableContextAttribute); 824926"];
4298 [label="builder.AddIfNotNull(_lazyNullablePublicOnlyAttribute); 824927"];
4299 [label="builder.AddIfNotNull(_lazyNativeIntegerAttribute); 824928"];
4300 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 824929"];
4301 [label="param GetTopLevelSourceTypeDefinitions(EmitContext context) 824930"];
4302 [label="var namespacesToProcess = new Stack<NamespaceSymbol>(); 824931"];
4303 [label="while (namespacesToProcess.Count > 0)\n            {\n                var ns = namespacesToProcess.Pop();\n                foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                }\n            } 824932"];
4304 [label="Debug.Assert(symbol.IsDefinition); 824933"];
4305 [label="SourceModule 824934"];
4306 [label="Assembly 824935"];
4307 [label="SourceAssembly 824936"];
4308 [label="GetBoundReferenceManager() 824937"];
4309 [label="GetBoundReferenceManager(); 824938"];
4310 [label="return Assembly.Modules[0]; 824939"];
4311 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 824940"];
4312 [label="EmitNullablePublicOnly 824941"];
4313 [label="param SynthesizeNullableAttributeIfNecessary(Symbol symbol) 824942"];
4314 [label="param SynthesizeNullableAttributeIfNecessary(byte? nullableContextValue) 824943"];
4315 [label="param SynthesizeNullableAttributeIfNecessary(TypeWithAnnotations type) 824944"];
4316 [label="param SynthesizeNullableAttributeIfNecessary(this) 824945"];
4317 [label="Compilation.SourceModule 824946"];
4318 [label="get\n            {\n                return Assembly.Modules[0];\n            } 824947"];
4319 [label="Assembly 824948"];
4320 [label="SourceAssembly 824949"];
4321 [label="GetBoundReferenceManager() 824950"];
4322 [label="GetBoundReferenceManager(); 824951"];
4323 [label="return Assembly.Modules[0]; 824952"];
4324 [label="if ((object)Compilation.SourceModule != symbol.ContainingModule)\n            {\n                // For symbols that are not defined in the same compilation (like NoPia), don't synthesize this attribute.\n                return null;\n            } 824953"];
4325 [label="if ((object)Compilation.SourceModule != symbol.ContainingModule)\n            {\n                // For symbols that are not defined in the same compilation (like NoPia), don't synthesize this attribute.\n                return null;\n            } 824954"];
4326 [label="var flagsBuilder = ArrayBuilder<byte>.GetInstance(); 824955"];
4327 [label="type.AddNullableTransforms(flagsBuilder); 824956"];
4328 [label="type.AddNullableTransforms(flagsBuilder); 824957"];
4329 [label="SynthesizedAttributeData attribute; 824958"];
4330 [label="if (!flagsBuilder.Any())\n            {\n                attribute = null;\n            }\n            else\n            {\n                Debug.Assert(flagsBuilder.All(f => f <= 2));\n                byte? commonValue = MostCommonNullableValueBuilder.GetCommonValue(flagsBuilder);\n                if (commonValue != null)\n                {\n                    attribute = SynthesizeNullableAttributeIfNecessary(nullableContextValue, commonValue.GetValueOrDefault());\n                }\n                else\n                {\n                    NamedTypeSymbol byteType = Compilation.GetSpecialType(SpecialType.System_Byte);\n                    var byteArrayType = ArrayTypeSymbol.CreateSZArray(byteType.ContainingAssembly, TypeWithAnnotations.Create(byteType));\n                    var value = flagsBuilder.SelectAsArray((flag, byteType) => new TypedConstant(byteType, TypedConstantKind.Primitive, flag), byteType);\n                    attribute = SynthesizeNullableAttribute(\n                        WellKnownMember.System_Runtime_CompilerServices_NullableAttribute__ctorTransformFlags,\n                        ImmutableArray.Create(new TypedConstant(byteArrayType, value)));\n                }\n            } 824959"];
4331 [label="Debug.Assert(flagsBuilder.All(f => f <= 2)); 824960"];
4332 [label="Debug.Assert(flagsBuilder.All(f => f <= 2)); 824961"];
4333 [label="byte? commonValue = MostCommonNullableValueBuilder.GetCommonValue(flagsBuilder); 824962"];
4334 [label="byte? commonValue = MostCommonNullableValueBuilder.GetCommonValue(flagsBuilder); 824963"];
4335 [label="if (commonValue != null)\n                {\n                    attribute = SynthesizeNullableAttributeIfNecessary(nullableContextValue, commonValue.GetValueOrDefault());\n                }\n                else\n                {\n                    NamedTypeSymbol byteType = Compilation.GetSpecialType(SpecialType.System_Byte);\n                    var byteArrayType = ArrayTypeSymbol.CreateSZArray(byteType.ContainingAssembly, TypeWithAnnotations.Create(byteType));\n                    var value = flagsBuilder.SelectAsArray((flag, byteType) => new TypedConstant(byteType, TypedConstantKind.Primitive, flag), byteType);\n                    attribute = SynthesizeNullableAttribute(\n                        WellKnownMember.System_Runtime_CompilerServices_NullableAttribute__ctorTransformFlags,\n                        ImmutableArray.Create(new TypedConstant(byteArrayType, value)));\n                } 824964"];
4336 [label="if (commonValue != null)\n                {\n                    attribute = SynthesizeNullableAttributeIfNecessary(nullableContextValue, commonValue.GetValueOrDefault());\n                }\n                else\n                {\n                    NamedTypeSymbol byteType = Compilation.GetSpecialType(SpecialType.System_Byte);\n                    var byteArrayType = ArrayTypeSymbol.CreateSZArray(byteType.ContainingAssembly, TypeWithAnnotations.Create(byteType));\n                    var value = flagsBuilder.SelectAsArray((flag, byteType) => new TypedConstant(byteType, TypedConstantKind.Primitive, flag), byteType);\n                    attribute = SynthesizeNullableAttribute(\n                        WellKnownMember.System_Runtime_CompilerServices_NullableAttribute__ctorTransformFlags,\n                        ImmutableArray.Create(new TypedConstant(byteArrayType, value)));\n                } 824965"];
4337 [label="attribute = SynthesizeNullableAttributeIfNecessary(nullableContextValue, commonValue.GetValueOrDefault()); 824966"];
4338 [label="attribute = SynthesizeNullableAttributeIfNecessary(nullableContextValue, commonValue.GetValueOrDefault()); 824967"];
4339 [label="SynthesizeNullableAttributeIfNecessary(nullableContextValue, commonValue.GetValueOrDefault()) 824968"];
4340 [label="param SynthesizeNullableAttributeIfNecessary(byte? nullableContextValue) 824969"];
4341 [label="param SynthesizeNullableAttributeIfNecessary(byte nullableValue) 824970"];
4342 [label="param SynthesizeNullableAttributeIfNecessary(this) 824971"];
4343 [label="if (nullableValue == nullableContextValue ||\n                (nullableContextValue == null && nullableValue == 0))\n            {\n                return null;\n            } 824972"];
4344 [label="return null; 824973"];
4345 [label="flagsBuilder.Free(); 824974"];
4346 [label="return attribute; 824975"];
4347 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 824976"];
4348 [label="param GetSynthesizedNestedTypes(NamedTypeSymbol container) 824977"];
4349 [label="param GetSynthesizedNestedTypes(this) 824978"];
4350 [label="return null; 824979"];
4351 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 824980"];
4352 [label="SourceAssembly 824981"];
4353 [label="GetBoundReferenceManager() 824982"];
4354 [label="GetBoundReferenceManager(); 824983"];
4355 [label="GetBoundReferenceManager() 824984"];
4356 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 824985"];
4357 [label="return SourceModule.ContainingSourceAssembly.GetSecurityAttributes(); 824986"];
4358 [label="return SourceModule.ContainingSourceAssembly.CorLibrary; 824987"];
4359 [label="AssemblySymbol corLibrary = CorLibrary; 824988"];
4360 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 824989"];
4361 [label="ImmutableArray<ModuleSymbol> modules = SourceModule.ContainingAssembly.Modules; 824990"];
4362 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 824991"];
4363 [label="return SourceModule.GetCustomAttributesToEmit(this); 824992"];
4364 [label="if (context.MetadataOnly)\n            {\n                return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>();\n            } 824993"];
4365 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 824994"];
4366 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 824995"];
4367 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 824996"];
4368 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 824997"];
4369 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 824998"];
4370 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 824999"];
4371 [label="return GetNeedsGeneratedAttributesInternal(); 825000"];
4372 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 825001"];
4373 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 825002"];
4374 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 825003"];
4375 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 825004"];
4376 [label="return; 825005"];
4377 [label="Debug.Assert(symbol.IsDefinition); 825006"];
4378 [label="GetBoundReferenceManager(); 825007"];
4379 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 825008"];
4380 [label="GetBoundReferenceManager(); 825009"];
4381 [label="if ((object)Compilation.SourceModule != symbol.ContainingModule)\n            {\n                // For symbols that are not defined in the same compilation (like NoPia), don't synthesize this attribute.\n                return null;\n            } 825010"];
4382 [label="if ((object)Compilation.SourceModule != symbol.ContainingModule)\n            {\n                // For symbols that are not defined in the same compilation (like NoPia), don't synthesize this attribute.\n                return null;\n            } 825011"];
4383 [label="param SynthesizeNullableAttributeIfNecessary(this) 825012"];
4384 [label="param Translate(TypeSymbol typeSymbol) 825013"];
4385 [label="param Translate(SyntaxNode syntaxNodeOpt) 825014"];
4386 [label="param Translate(DiagnosticBag diagnostics) 825015"];
4387 [label="param Translate(this) 825016"];
4388 [label="Debug.Assert(diagnostics != null); 825017"];
4389 [label="Debug.Assert(diagnostics != null); 825018"];
4390 [label="switch (typeSymbol.Kind)\n            {\n                case SymbolKind.DynamicType:\n                    return Translate((DynamicTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics);\n\n                case SymbolKind.ArrayType:\n                    return Translate((ArrayTypeSymbol)typeSymbol);\n\n                case SymbolKind.ErrorType:\n                case SymbolKind.NamedType:\n                    return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics);\n\n                case SymbolKind.PointerType:\n                    return Translate((PointerTypeSymbol)typeSymbol);\n\n                case SymbolKind.TypeParameter:\n                    return Translate((TypeParameterSymbol)typeSymbol);\n\n                case SymbolKind.FunctionPointerType:\n                    return Translate((FunctionPointerTypeSymbol)typeSymbol);\n            } 825019"];
4391 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 825020"];
4392 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 825021"];
4393 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 825022"];
4394 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 825023"];
4395 [label="Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics) 825024"];
4396 [label="param Translate(NamedTypeSymbol namedTypeSymbol) 825025"];
4397 [label="param Translate(SyntaxNode syntaxNodeOpt) 825026"];
4398 [label="param Translate(DiagnosticBag diagnostics) 825027"];
4399 [label="param Translate(bool fromImplements = false) 825028"];
4400 [label="param Translate(bool needDeclaration = false) 825029"];
4401 [label="param Translate(this) 825030"];
4402 [label="Debug.Assert(namedTypeSymbol.IsDefinitionOrDistinct()); 825031"];
4403 [label="Debug.Assert(diagnostics != null); 825032"];
4404 [label="Debug.Assert(diagnostics != null); 825033"];
4405 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 825034"];
4406 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 825035"];
4407 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 825036"];
4408 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 825037"];
4409 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 825038"];
4410 [label="object reference; 825039"];
4411 [label="Cci.INamedTypeReference typeRef; 825040"];
4412 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 825041"];
4413 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 825042"];
4414 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 825043"];
4415 [label="IsGenericType(container) 825044"];
4416 [label="param IsGenericType(NamedTypeSymbol toCheck) 825045"];
4417 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 825046"];
4418 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 825047"];
4419 [label="return false; 825048"];
4420 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 825049"];
4421 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 825050"];
4422 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 825051"];
4423 [label="return _embeddedTypesManagerOpt?.EmbedTypeIfNeedTo(namedTypeSymbol, fromImplements, syntaxNodeOpt, diagnostics) ?? namedTypeSymbol.GetCciAdapter(); 825052"];
4424 [label="return _embeddedTypesManagerOpt?.EmbedTypeIfNeedTo(namedTypeSymbol, fromImplements, syntaxNodeOpt, diagnostics) ?? namedTypeSymbol.GetCciAdapter(); 825053"];
4425 [label="param Translate(ModuleSymbol module) 825054"];
4426 [label="param Translate(DiagnosticBag diagnostics) 825055"];
4427 [label="param Translate(this) 825056"];
4428 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 825057"];
4429 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 825058"];
4430 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 825059"];
4431 [label="if ((object)module == null)\n            {\n                return null;\n            } 825060"];
4432 [label="if ((object)module == null)\n            {\n                return null;\n            } 825061"];
4433 [label="Cci.IModuleReference moduleRef; 825062"];
4434 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(module, out moduleRef))\n            {\n                return moduleRef;\n            } 825063"];
4435 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(module, out moduleRef))\n            {\n                return moduleRef;\n            } 825064"];
4436 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(module, out moduleRef))\n            {\n                return moduleRef;\n            } 825065"];
4437 [label="moduleRef = TranslateModule(module, diagnostics); 825066"];
4438 [label="moduleRef = TranslateModule(module, diagnostics); 825067"];
4439 [label="TranslateModule(module, diagnostics) 825068"];
4440 [label="param TranslateModule(ModuleSymbol module) 825069"];
4441 [label="param TranslateModule(DiagnosticBag diagnostics) 825070"];
4442 [label="param TranslateModule(this) 825071"];
4443 [label="AssemblySymbol container = module.ContainingAssembly; 825072"];
4444 [label="if ((object)container != null && ReferenceEquals(container.Modules[0], module))\n            {\n                Cci.IModuleReference moduleRef = new AssemblyReference(container);\n                Cci.IModuleReference cachedModuleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(container, moduleRef);\n\n                if (cachedModuleRef == moduleRef)\n                {\n                    ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics);\n                }\n                else\n                {\n                    moduleRef = cachedModuleRef;\n                }\n\n                return moduleRef;\n            }\n            else\n            {\n                return new ModuleReference(this, module);\n            } 825073"];
4445 [label="if ((object)container != null && ReferenceEquals(container.Modules[0], module))\n            {\n                Cci.IModuleReference moduleRef = new AssemblyReference(container);\n                Cci.IModuleReference cachedModuleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(container, moduleRef);\n\n                if (cachedModuleRef == moduleRef)\n                {\n                    ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics);\n                }\n                else\n                {\n                    moduleRef = cachedModuleRef;\n                }\n\n                return moduleRef;\n            }\n            else\n            {\n                return new ModuleReference(this, module);\n            } 825074"];
4446 [label="if ((object)container != null && ReferenceEquals(container.Modules[0], module))\n            {\n                Cci.IModuleReference moduleRef = new AssemblyReference(container);\n                Cci.IModuleReference cachedModuleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(container, moduleRef);\n\n                if (cachedModuleRef == moduleRef)\n                {\n                    ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics);\n                }\n                else\n                {\n                    moduleRef = cachedModuleRef;\n                }\n\n                return moduleRef;\n            }\n            else\n            {\n                return new ModuleReference(this, module);\n            } 825075"];
4447 [label="if ((object)container != null && ReferenceEquals(container.Modules[0], module))\n            {\n                Cci.IModuleReference moduleRef = new AssemblyReference(container);\n                Cci.IModuleReference cachedModuleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(container, moduleRef);\n\n                if (cachedModuleRef == moduleRef)\n                {\n                    ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics);\n                }\n                else\n                {\n                    moduleRef = cachedModuleRef;\n                }\n\n                return moduleRef;\n            }\n            else\n            {\n                return new ModuleReference(this, module);\n            } 825076"];
4448 [label="Cci.IModuleReference moduleRef = new AssemblyReference(container); 825077"];
4449 [label="Cci.IModuleReference moduleRef = new AssemblyReference(container); 825078"];
4450 [label="new AssemblyReference(container) 825079"];
4451 [label="param AssemblyReference(AssemblySymbol assemblySymbol) 825080"];
4452 [label="param AssemblyReference(this) 825081"];
4453 [label="_targetAssembly 825082"];
4454 [label="Debug.Assert((object)assemblySymbol != null); 825083"];
4455 [label="Debug.Assert((object)assemblySymbol != null); 825084"];
4456 [label="_targetAssembly 825085"];
4457 [label="Cci.IModuleReference cachedModuleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(container, moduleRef); 825086"];
4458 [label="Cci.IModuleReference cachedModuleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(container, moduleRef); 825087"];
4459 [label="Cci.IModuleReference cachedModuleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(container, moduleRef); 825088"];
4460 [label="if (cachedModuleRef == moduleRef)\n                {\n                    ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics);\n                }\n                else\n                {\n                    moduleRef = cachedModuleRef;\n                } 825089"];
4461 [label="ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics); 825090"];
4462 [label="ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics); 825091"];
4463 [label="ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics); 825092"];
4464 [label="ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics) 825093"];
4465 [label="param ValidateReferencedAssembly(AssemblySymbol assembly) 825094"];
4466 [label="param ValidateReferencedAssembly(AssemblyReference asmRef) 825095"];
4467 [label="param ValidateReferencedAssembly(DiagnosticBag diagnostics) 825096"];
4468 [label="param ValidateReferencedAssembly(this) 825097"];
4469 [label="AssemblyIdentity asmIdentity = SourceModule.ContainingAssembly.Identity; 825098"];
4470 [label="asmRef.Identity 825099"];
4471 [label="=> _targetAssembly.Identity 825100"];
4472 [label="_targetAssembly.Identity 825101"];
4473 [label="AssemblyIdentity refIdentity = asmRef.Identity; 825102"];
4474 [label="if (asmIdentity.IsStrongName && !refIdentity.IsStrongName &&\n                asmRef.Identity.ContentType != AssemblyContentType.WindowsRuntime)\n            {\n                // Dev12 reported error, we have changed it to a warning to allow referencing libraries \n                // built for platforms that don't support strong names.\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName, assembly), NoLocation.Singleton);\n            } 825103"];
4475 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 825104"];
4476 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 825105"];
4477 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 825106"];
4478 [label="var refMachine = assembly.Machine; 825107"];
4479 [label="assembly.Machine 825108"];
4480 [label="get\n            {\n                return _options;\n            } 825109"];
4481 [label="if ((object)assembly != (object)assembly.CorLibrary &&\n                !(refMachine == Machine.I386 && !assembly.Bit32Required))\n            {\n                var machine = SourceModule.Machine;\n\n                if (!(machine == Machine.I386 && !SourceModule.Bit32Required) &&\n                    machine != refMachine)\n                {\n                    // Different machine types, and neither is agnostic\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ConflictingMachineAssembly, assembly), NoLocation.Singleton);\n                }\n            } 825110"];
4482 [label="if ((object)assembly != (object)assembly.CorLibrary &&\n                !(refMachine == Machine.I386 && !assembly.Bit32Required))\n            {\n                var machine = SourceModule.Machine;\n\n                if (!(machine == Machine.I386 && !SourceModule.Bit32Required) &&\n                    machine != refMachine)\n                {\n                    // Different machine types, and neither is agnostic\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ConflictingMachineAssembly, assembly), NoLocation.Singleton);\n                }\n            } 825111"];
4483 [label="assembly.Bit32Required 825112"];
4484 [label="get\n            {\n                return _options;\n            } 825113"];
4485 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 825114"];
4486 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 825115"];
4487 [label="ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics); 825116"];
4488 [label="return moduleRef; 825117"];
4489 [label="moduleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(module, moduleRef); 825118"];
4490 [label="moduleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(module, moduleRef); 825119"];
4491 [label="moduleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(module, moduleRef); 825120"];
4492 [label="return moduleRef; 825121"];
4493 [label="=> _targetAssembly.Identity 825122"];
4494 [label="_targetAssembly.Identity 825123"];
4495 [label="param GetExportedTypes(DiagnosticBag diagnostics) 825124"];
4496 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 825125"];
4497 [label="if (!OutputKind.IsNetModule())\n            {\n                var modules = sourceAssembly.Modules;\n                for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                }\n            } 825126"];
4498 [label="var modules = sourceAssembly.Modules; 825127"];
4499 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 825128"];
4500 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 825129"];
4501 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 825130"];
4502 [label="sourceAssembly.DeclaringCompilation.Options 825131"];
4503 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 825132"];
4504 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 825133"];
4505 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder) 825134"];
4506 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 825135"];
4507 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 825136"];
4508 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 825137"];
4509 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 825138"];
4510 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 825139"];
4511 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder); 825140"];
4512 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder) 825141"];
4513 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 825142"];
4514 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 825143"];
4515 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 825144"];
4516 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 825145"];
4517 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 825146"];
4518 [label="return seenTopLevelForwardedTypes; 825147"];
4519 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 825148"];
4520 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 825149"];
4521 [label="param AddEmbeddedResourcesFromAddedModules(ArrayBuilder<Cci.ManagedResource> builder) 825150"];
4522 [label="param AddEmbeddedResourcesFromAddedModules(DiagnosticBag diagnostics) 825151"];
4523 [label="param AddEmbeddedResourcesFromAddedModules(this) 825152"];
4524 [label="var modules = _sourceAssembly.Modules; 825153"];
4525 [label="int count = modules.Length; 825154"];
4526 [label="for (int i = 1; i < count; i++)\n            {\n                var file = (Cci.IFileReference)Translate(modules[i], diagnostics);\n\n                try\n                {\n                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow())\n                    {\n                        builder.Add(new Cci.ManagedResource(\n                            resource.Name,\n                            (resource.Attributes & ManifestResourceAttributes.Public) != 0,\n                            null,\n                            file,\n                            resource.Offset));\n                    }\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, modules[i]), NoLocation.Singleton);\n                }\n            } 825155"];
4527 [label="for (int i = 1; i < count; i++)\n            {\n                var file = (Cci.IFileReference)Translate(modules[i], diagnostics);\n\n                try\n                {\n                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow())\n                    {\n                        builder.Add(new Cci.ManagedResource(\n                            resource.Name,\n                            (resource.Attributes & ManifestResourceAttributes.Public) != 0,\n                            null,\n                            file,\n                            resource.Offset));\n                    }\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, modules[i]), NoLocation.Singleton);\n                }\n            } 825156"];
4528 [label="=> ImmutableArray<Cci.UsedNamespaceOrType>.Empty 825157"];
4529 [label="ImmutableArray<Cci.UsedNamespaceOrType>.Empty 825158"];
4530 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 825159"];
4531 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 825160"];
4532 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 825161"];
4533 [label="param Translate(SyntaxNode syntaxNodeOpt) 825162"];
4534 [label="param Translate(DiagnosticBag diagnostics) 825163"];
4535 [label="param Translate(bool fromImplements = false) 825164"];
4536 [label="param Translate(bool needDeclaration = false) 825165"];
4537 [label="Debug.Assert(diagnostics != null); 825166"];
4538 [label="Debug.Assert(diagnostics != null); 825167"];
4539 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 825168"];
4540 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 825169"];
4541 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 825170"];
4542 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 825171"];
4543 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 825172"];
4544 [label="object reference; 825173"];
4545 [label="Cci.INamedTypeReference typeRef; 825174"];
4546 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 825175"];
4547 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 825176"];
4548 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 825177"];
4549 [label="IsGenericType(container) 825178"];
4550 [label="param IsGenericType(NamedTypeSymbol toCheck) 825179"];
4551 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 825180"];
4552 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 825181"];
4553 [label="return false; 825182"];
4554 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 825183"];
4555 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 825184"];
4556 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 825185"];
4557 [label="param IsPlatformType(Cci.ITypeReference typeRef) 825186"];
4558 [label="param IsPlatformType(Cci.PlatformType platformType) 825187"];
4559 [label="param IsPlatformType(this) 825188"];
4560 [label="var namedType = typeRef.GetInternalSymbol() as NamedTypeSymbol; 825189"];
4561 [label="if ((object)namedType != null)\n            {\n                if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                }\n\n                return namedType.SpecialType == (SpecialType)platformType;\n            } 825190"];
4562 [label="if ((object)namedType != null)\n            {\n                if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                }\n\n                return namedType.SpecialType == (SpecialType)platformType;\n            } 825191"];
4563 [label="if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                } 825192"];
4564 [label="return namedType.SpecialType == (SpecialType)platformType; 825193"];
4565 [label="if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                } 825194"];
4566 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 825195"];
4567 [label="return moduleRef; 825196"];
4568 [label="Debug.Assert(symbol.IsDefinition); 825197"];
4569 [label="GetBoundReferenceManager(); 825198"];
4570 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 825199"];
4571 [label="var result = new MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation>(); 825200"];
4572 [label="var namespacesAndTypesToProcess = new Stack<NamespaceOrTypeSymbol>(); 825201"];
4573 [label="Location location = null; 825202"];
4574 [label="while (namespacesAndTypesToProcess.Count > 0)\n            {\n                NamespaceOrTypeSymbol symbol = namespacesAndTypesToProcess.Pop();\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Namespace:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n\n                        // filtering out synthesized symbols not having real source \n                        // locations such as anonymous types, etc...\n                        if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    case SymbolKind.NamedType:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n                        if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n                }\n            } 825203"];
4575 [label="param GetSmallestSourceLocationOrNull(this) 825204"];
4576 [label="CSharpCompilation compilation = symbol.DeclaringCompilation; 825205"];
4577 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 825206"];
4578 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 825207"];
4579 [label="param AddSymbolLocation(MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation> result) 825208"];
4580 [label="param AddSymbolLocation(Cci.IDefinition definition) 825209"];
4581 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 825210"];
4582 [label="foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            } 825211"];
4583 [label="switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                } 825212"];
4584 [label="var method = (MethodSymbol)member; 825213"];
4585 [label="if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        } 825214"];
4586 [label="AddSymbolLocation(result, member); 825215"];
4587 [label="AddSymbolLocation(result, member); 825216"];
4588 [label="AddSymbolLocation(result, member) 825217"];
4589 [label="param AddSymbolLocation(MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation> result) 825218"];
4590 [label="param AddSymbolLocation(Symbol symbol) 825219"];
4591 [label="param AddSymbolLocation(this) 825220"];
4592 [label="var location = GetSmallestSourceLocationOrNull(symbol); 825221"];
4593 [label="GetSmallestSourceLocationOrNull(symbol) 825222"];
4594 [label="param GetSmallestSourceLocationOrNull(Symbol symbol) 825223"];
4595 [label="param GetSmallestSourceLocationOrNull(this) 825224"];
4596 [label="CSharpCompilation compilation = symbol.DeclaringCompilation; 825225"];
4597 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 825226"];
4598 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 825227"];
4599 [label="foreach (var loc in symbol.Locations)\n            {\n                if (loc.IsInSource && (result == null || compilation.CompareSourceLocations(result, loc) > 0))\n                {\n                    result = loc;\n                }\n            } 825228"];
4600 [label="if (location != null)\n            {\n                AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n            } 825229"];
4601 [label="if (location != null)\n            {\n                AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n            } 825230"];
4602 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()); 825231"];
4603 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()); 825232"];
4604 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()); 825233"];
4605 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()) 825234"];
4606 [label="param AddSymbolLocation(MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation> result) 825235"];
4607 [label="param AddSymbolLocation(Location location) 825236"];
4608 [label="param AddSymbolLocation(Cci.IDefinition definition) 825237"];
4609 [label="param AddSymbolLocation(this) 825238"];
4610 [label="Cci.DebugSourceDocument doc = DebugDocumentsBuilder.TryGetDebugDocument(span.Path, basePath: location.SourceTree.FilePath); 825239"];
4611 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 825240"];
4612 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 825241"];
4613 [label="AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter()); 825242"];
4614 [label="AddSymbolLocation(result, member); 825243"];
4615 [label="return result; 825244"];
4616 [label="GetBoundReferenceManager(); 825245"];
4617 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 825246"];
4618 [label="c.GetEmitDiagnostics(options: options).Verify(expected) 825247"];
4619 [label="param Verify(params DiagnosticDescription[] expected) 825248"];
4620 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 825249"];
4621 [label="Verify((IEnumerable<Diagnostic>)actual, expected) 825250"];
4622 [label="param Verify(params DiagnosticDescription[] expected) 825251"];
4623 [label="Verify(actual, expected, errorCodeOnly: false); 825252"];
4624 [label="Verify(actual, expected, errorCodeOnly: false); 825253"];
4625 [label="Verify(actual, expected, errorCodeOnly: false) 825254"];
4626 [label="param Verify(DiagnosticDescription[] expected) 825255"];
4627 [label="param Verify(bool errorCodeOnly) 825256"];
4628 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 825257"];
4629 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 825258"];
4630 [label="var includeDefaultSeverity = expected.Any() && expected.All(e => e.DefaultSeverity != null); 825259"];
4631 [label="var includeEffectiveSeverity = expected.Any() && expected.All(e => e.EffectiveSeverity != null); 825260"];
4632 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 825261"];
4633 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 825262"];
4634 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 825263"];
4635 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 825264"];
4636 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 825265"];
4637 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 825266"];
4638 [label="DiagnosticDescription.GetAssertText(expected, actual) 825267"];
4639 [label="param GetAssertText(DiagnosticDescription[] expected) 825268"];
4640 [label="const int CSharp = 1; 825269"];
4641 [label="const int VisualBasic = 2; 825270"];
4642 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 825271"];
4643 [label="actual.Any() && actual.First() is CSDiagnostic 825272"];
4644 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 825273"];
4645 [label="var includeDiagnosticMessagesAsComments = (language == CSharp); 825274"];
4646 [label="int indentDepth = (language == CSharp) ? 4 : 1; 825275"];
4647 [label="(language == CSharp) 825276"];
4648 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 825277"];
4649 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 825278"];
4650 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 825279"];
4651 [label="IsSortedOrEmpty(expected) 825280"];
4652 [label="param IsSortedOrEmpty(DiagnosticDescription[] diagnostics) 825281"];
4653 [label="var comparer = LinePositionComparer.Instance; 825282"];
4654 [label="DiagnosticDescription last = null; 825283"];
4655 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 825284"];
4656 [label="return true; 825285"];
4657 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 825286"];
4658 [label="Sort(actual) 825287"];
4659 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 825288"];
4660 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 825289"];
4661 [label="var assertText = new StringBuilder(); 825290"];
4662 [label="assertText.AppendLine(); 825291"];
4663 [label="int i; 825292"];
4664 [label="assertText.AppendLine('Expected:'); 825293"];
4665 [label="assertText.AppendLine('Expected:'); 825294"];
4666 [label="var expectedText = ArrayBuilder<string>.GetInstance(); 825295"];
4667 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 825296"];
4668 [label="GetCommaSeparatedLines(assertText, expectedText); 825297"];
4669 [label="GetCommaSeparatedLines(assertText, expectedText); 825298"];
4670 [label="GetCommaSeparatedLines(assertText, expectedText) 825299"];
4671 [label="param GetCommaSeparatedLines(StringBuilder sb) 825300"];
4672 [label="param GetCommaSeparatedLines(ArrayBuilder<string> lines) 825301"];
4673 [label="int n = lines.Count; 825302"];
4674 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 825303"];
4675 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 825304"];
4676 [label="GetCommaSeparatedLines(assertText, expectedText); 825305"];
4677 [label="assertText.AppendLine('Actual:'); 825306"];
4678 [label="assertText.AppendLine('Actual:'); 825307"];
4679 [label="var actualText = ArrayBuilder<string>.GetInstance(); 825308"];
4680 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 825309"];
4681 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 825310"];
4682 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 825311"];
4683 [label="assertText.AppendLine('Diff:'); 825312"];
4684 [label="assertText.AppendLine('Diff:'); 825313"];
4685 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 825314"];
4686 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 825315"];
4687 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 825316"];
4688 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 825317"];
4689 [label="DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine) 825318"];
4690 [label="param DiffReport(IEnumerable<T> expected) 825319"];
4691 [label="param DiffReport(IEnumerable<T> actual) 825320"];
4692 [label="param DiffReport(string separator) 825321"];
4693 [label="param DiffReport(IEqualityComparer<T> comparer = null) 825322"];
4694 [label="param DiffReport(Func<T, string> toString = null) 825323"];
4695 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 825324"];
4696 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 825325"];
4697 [label="(comparer != null) 825326"];
4698 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 825327"];
4699 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 825328"];
4700 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 825329"];
4701 [label="IList<T> expectedList = expected as IList<T> ?? new List<T>(expected); 825330"];
4702 [label="IList<T> actualList = actual as IList<T> ?? new List<T>(actual); 825331"];
4703 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 825332"];
4704 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 825333"];
4705 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 825334"];
4706 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 825335"];
4707 [label="lcs.CalculateDiff(expectedList, actualList, toString) 825336"];
4708 [label="param CalculateDiff(IList<T> sequenceA) 825337"];
4709 [label="param CalculateDiff(IList<T> sequenceB) 825338"];
4710 [label="param CalculateDiff(Func<T, string> toString) 825339"];
4711 [label="param CalculateDiff(this) 825340"];
4712 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 825341"];
4713 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 825342"];
4714 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 825343"];
4715 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 825344"];
4716 [label="GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count) 825345"];
4717 [label="param GetEdits(TSequence sequenceA) 825346"];
4718 [label="param GetEdits(int lengthA) 825347"];
4719 [label="param GetEdits(TSequence sequenceB) 825348"];
4720 [label="param GetEdits(int lengthB) 825349"];
4721 [label="param GetEdits(this) 825350"];
4722 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 825351"];
4723 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 825352"];
4724 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 825353"];
4725 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 825354"];
4726 [label="ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB) 825355"];
4727 [label="param ComputeCostMatrix(TSequence sequenceA) 825356"];
4728 [label="param ComputeCostMatrix(int lengthA) 825357"];
4729 [label="param ComputeCostMatrix(TSequence sequenceB) 825358"];
4730 [label="param ComputeCostMatrix(int lengthB) 825359"];
4731 [label="param ComputeCostMatrix(this) 825360"];
4732 [label="var la = lengthA + 1; 825361"];
4733 [label="var la = lengthA + 1; 825362"];
4734 [label="var lb = lengthB + 1; 825363"];
4735 [label="var lb = lengthB + 1; 825364"];
4736 [label="var d = new int[la, lb]; 825365"];
4737 [label="d[0, 0] = 0; 825366"];
4738 [label="d[0, 0] 825367"];
4739 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 825368"];
4740 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 825369"];
4741 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 825370"];
4742 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 825371"];
4743 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 825372"];
4744 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 825373"];
4745 [label="return d; 825374"];
4746 [label="int i = lengthA; 825375"];
4747 [label="int j = lengthB; 825376"];
4748 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 825377"];
4749 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 825378"];
4750 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 825379"];
4751 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 825380"];
4752 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 825381"];
4753 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 825382"];
4754 [label="param GetEdits(this) 825383"];
4755 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 825384"];
4756 [label="param CalculateDiff(this) 825385"];
4757 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 825386"];
4758 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 825387"];
4759 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 825388"];
4760 [label="actualText.Free(); 825389"];
4761 [label="expectedText.Free(); 825390"];
4762 [label="return assertText.ToString(); 825391"];
4763 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 825392"];
4764 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 825393"];
4765 [label="return c; 825394"];
4766 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { imageRef },\n                options: TestOptions.ReleaseDll.WithPlatform(Platform.Itanium)); 825395"];
4767 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { imageRef },\n                options: TestOptions.ReleaseDll.WithPlatform(Platform.Itanium)); 825396"];
4768 [label="new MetadataReference[] { imageRef } 825397"];
4769 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { imageRef },\n                options: TestOptions.ReleaseDll.WithPlatform(Platform.Itanium)); 825398"];
4770 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { imageRef },\n                options: TestOptions.ReleaseDll.WithPlatform(Platform.Itanium)); 825399"];
4771 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { imageRef },\n                options: TestOptions.ReleaseDll.WithPlatform(Platform.Itanium)); 825400"];
4772 [label="new CSharpTestSource(source) 825401"];
4773 [label="param CSharpTestSource(this) 825402"];
4774 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 825403"];
4775 [label="=> CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 825404"];
4776 [label="skipUsesIsNullable 825405"];
4777 [label="null 825406"];
4778 [label="experimentalFeature: null 825407"];
4779 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 825408"];
4780 [label="param CreateCompilationCore(bool skipUsesIsNullable) 825409"];
4781 [label="param CreateCompilationCore(MessageID? experimentalFeature) 825410"];
4782 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 825411"];
4783 [label="var stream = new MemoryStream(); 825412"];
4784 [label="var root = tree.GetRoot(); 825413"];
4785 [label="root.SerializeTo(stream); 825414"];
4786 [label="root.SerializeTo(stream); 825415"];
4787 [label="root.SerializeTo(stream); 825416"];
4788 [label="stream.Position = 0; 825417"];
4789 [label="stream.Position 825418"];
4790 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 825419"];
4791 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 825420"];
4792 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 825421"];
4793 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 825422"];
4794 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 825423"];
4795 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 825424"];
4796 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 825425"];
4797 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 825426"];
4798 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 825427"];
4799 [label="param ValidateIOperations(Func<Compilation> createCompilation) 825428"];
4800 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 825429"];
4801 [label="return; 825430"];
4802 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 825431"];
4803 [label="var compilation = createCompilationLambda(); 825432"];
4804 [label="return Guid.NewGuid().ToString('D'); 825433"];
4805 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 825434"];
4806 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 825435"];
4807 [label="param Create(CSharpCompilation? previousSubmission) 825436"];
4808 [label="param Create(Type? returnType) 825437"];
4809 [label="param Create(Type? hostObjectType) 825438"];
4810 [label="param Create(bool isSubmission) 825439"];
4811 [label="RoslynDebug.Assert(options != null); 825440"];
4812 [label="RoslynDebug.Assert(options != null); 825441"];
4813 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 825442"];
4814 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 825443"];
4815 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 825444"];
4816 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 825445"];
4817 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 825446"];
4818 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 825447"];
4819 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 825448"];
4820 [label="new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null) 825449"];
4821 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 825450"];
4822 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 825451"];
4823 [label="param SyntaxAndDeclarationManager(bool isSubmission) 825452"];
4824 [label="param SyntaxAndDeclarationManager(State state) 825453"];
4825 [label="param SyntaxAndDeclarationManager(this) 825454"];
4826 [label="externalSyntaxTrees 825455"];
4827 [label="messageProvider 825456"];
4828 [label="isSubmission 825457"];
4829 [label="param SyntaxAndDeclarationManager(this) 825458"];
4830 [label="_lazyState 825459"];
4831 [label="_lazyState 825460"];
4832 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 825461"];
4833 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 825462"];
4834 [label="param CSharpCompilation(Type? submissionReturnType) 825463"];
4835 [label="param CSharpCompilation(Type? hostObjectType) 825464"];
4836 [label="param CSharpCompilation(bool isSubmission) 825465"];
4837 [label="param CSharpCompilation(ReferenceManager? referenceManager) 825466"];
4838 [label="param CSharpCompilation(bool reuseReferenceManager) 825467"];
4839 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 825468"];
4840 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 825469"];
4841 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 825470"];
4842 [label="param CSharpCompilation(this) 825471"];
4843 [label="previousSubmission 825472"];
4844 [label="submissionReturnType 825473"];
4845 [label="hostObjectType 825474"];
4846 [label="isSubmission 825475"];
4847 [label="referenceManager 825476"];
4848 [label="reuseReferenceManager 825477"];
4849 [label="syntaxAndDeclarations 825478"];
4850 [label="semanticModelProvider 825479"];
4851 [label="eventQueue 825480"];
4852 [label="param CSharpCompilation(this) 825481"];
4853 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 825482"];
4854 [label="param CSharpCompilation(Type? submissionReturnType) 825483"];
4855 [label="param CSharpCompilation(Type? hostObjectType) 825484"];
4856 [label="param CSharpCompilation(bool isSubmission) 825485"];
4857 [label="param CSharpCompilation(ReferenceManager? referenceManager) 825486"];
4858 [label="param CSharpCompilation(bool reuseReferenceManager) 825487"];
4859 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 825488"];
4860 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 825489"];
4861 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 825490"];
4862 [label="param CSharpCompilation(this) 825491"];
4863 [label="isSubmission 825492"];
4864 [label="semanticModelProvider 825493"];
4865 [label="eventQueue 825494"];
4866 [label="param CSharpCompilation(this) 825495"];
4867 [label="_options 825496"];
4868 [label="_globalImports 825497"];
4869 [label="_previousSubmissionImports 825498"];
4870 [label="_globalNamespaceAlias 825499"];
4871 [label="_scriptClass 825500"];
4872 [label="_lazyHostObjectTypeSymbol 825501"];
4873 [label="_lazyImportInfos 825502"];
4874 [label="_conversions 825503"];
4875 [label="_anonymousTypeManager 825504"];
4876 [label="_lazyGlobalNamespace 825505"];
4877 [label="builtInOperators 825506"];
4878 [label="_lazyAssemblySymbol 825507"];
4879 [label="_referenceManager 825508"];
4880 [label="_syntaxAndDeclarations 825509"];
4881 [label="_lazyEntryPoint 825510"];
4882 [label="_lazyEmitNullablePublicOnly 825511"];
4883 [label="_lazyCompilationUnitCompletedTrees 825512"];
4884 [label="NullableAnalysisData 825513"];
4885 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 825514"];
4886 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 825515"];
4887 [label="_externAliasTargets 825516"];
4888 [label="_moduleInitializerMethods 825517"];
4889 [label="_binderFactories 825518"];
4890 [label="_ignoreAccessibilityBinderFactories 825519"];
4891 [label="_lazyDeclarationDiagnostics 825520"];
4892 [label="_declarationDiagnosticsFrozen 825521"];
4893 [label="new DiagnosticBag() 825522"];
4894 [label="_additionalCodegenWarnings = new DiagnosticBag() 825523"];
4895 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 825524"];
4896 [label="this.builtInOperators = new BuiltInOperators(this); 825525"];
4897 [label="this.builtInOperators = new BuiltInOperators(this); 825526"];
4898 [label="new BuiltInOperators(this) 825527"];
4899 [label="param BuiltInOperators(CSharpCompilation compilation) 825528"];
4900 [label="param BuiltInOperators(this) 825529"];
4901 [label="_compilation 825530"];
4902 [label="_builtInUnaryOperators 825531"];
4903 [label="_builtInOperators 825532"];
4904 [label="_compilation 825533"];
4905 [label="this.builtInOperators 825534"];
4906 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 825535"];
4907 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 825536"];
4908 [label="LanguageVersion? result = null; 825537"];
4909 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 825538"];
4910 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 825539"];
4911 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 825540"];
4912 [label="this.LanguageVersion 825541"];
4913 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 825542"];
4914 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 825543"];
4915 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 825544"];
4916 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 825545"];
4917 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 825546"];
4918 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 825547"];
4919 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 825548"];
4920 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 825549"];
4921 [label="this.Options 825550"];
4922 [label="get\n            {\n                return _options;\n            } 825551"];
4923 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 825552"];
4924 [label="_syntaxAndDeclarations 825553"];
4925 [label="Debug.Assert(_lazyAssemblySymbol is null); 825554"];
4926 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 825555"];
4927 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 825556"];
4928 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 825557"];
4929 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 825558"];
4930 [label="int i = 0; 825559"];
4931 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 825560"];
4932 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 825561"];
4933 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 825562"];
4934 [label="i++; 825563"];
4935 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 825564"];
4936 [label="var scriptClassName = this.ScriptClassName; 825565"];
4937 [label="var resolver = this.Resolver; 825566"];
4938 [label="var messageProvider = this.MessageProvider; 825567"];
4939 [label="var isSubmission = this.IsSubmission; 825568"];
4940 [label="this.PreviousSubmission 825569"];
4941 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 825570"];
4942 [label="param CSharpCompilation(Type? submissionReturnType) 825571"];
4943 [label="param CSharpCompilation(Type? hostObjectType) 825572"];
4944 [label="previousSubmission 825573"];
4945 [label="submissionReturnType 825574"];
4946 [label="hostObjectType 825575"];
4947 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 825576"];
4948 [label="param CSharpCompilation(Type? submissionReturnType) 825577"];
4949 [label="param CSharpCompilation(Type? hostObjectType) 825578"];
4950 [label="_compilation 825579"];
4951 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 825580"];
4952 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 825581"];
4953 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 825582"];
4954 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 825583"];
4955 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 825584"];
4956 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 825585"];
4957 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 825586"];
4958 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 825587"];
4959 [label="Debug.Assert(_lazyAssemblySymbol is null); 825588"];
4960 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 825589"];
4961 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 825590"];
4962 [label="IsNullableEnabled(compilation) 825591"];
4963 [label="compilation.SyntaxTrees 825592"];
4964 [label="_syntaxAndDeclarations.GetLazyState() 825593"];
4965 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 825594"];
4966 [label="param CreateState(CommonMessageProvider messageProvider) 825595"];
4967 [label="param AppendAllSyntaxTrees(SourceReferenceResolver resolver) 825596"];
4968 [label="param AppendAllSyntaxTrees(CommonMessageProvider messageProvider) 825597"];
4969 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMapBuilder) 825598"];
4970 [label="param AppendAllSyntaxTrees(IDictionary<string, SyntaxTree> loadedSyntaxTreeMapBuilder) 825599"];
4971 [label="var sourceCodeKind = tree.Options.Kind; 825600"];
4972 [label="if (sourceCodeKind == SourceCodeKind.Script)\n            {\n                AppendAllLoadedSyntaxTrees(treesBuilder, tree, scriptClassName, resolver, messageProvider, isSubmission, ordinalMapBuilder, loadDirectiveMapBuilder, loadedSyntaxTreeMapBuilder, declMapBuilder, ref declTable);\n            } 825601"];
4973 [label="OrdinalMap 825602"];
4974 [label="LoadDirectiveMap 825603"];
4975 [label="LoadedSyntaxTreeMap 825604"];
4976 [label="RootNamespaces 825605"];
4977 [label="DeclarationTable 825606"];
4978 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 825607"];
4979 [label="var options = (CSharpParseOptions)trees[0].Options; 825608"];
4980 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 825609"];
4981 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 825610"];
4982 [label="useCompilation.VerifyEmitDiagnostics(emitOptions); 825611"];
4983 [label="useCompilation.VerifyEmitDiagnostics(emitOptions); 825612"];
4984 [label="useCompilation.VerifyEmitDiagnostics(emitOptions); 825613"];
4985 [label="useCompilation.VerifyEmitDiagnostics(emitOptions) 825614"];
4986 [label="param VerifyEmitDiagnostics(this TCompilation c) 825615"];
4987 [label="param VerifyEmitDiagnostics(EmitOptions options) 825616"];
4988 [label="param VerifyEmitDiagnostics(params DiagnosticDescription[] expected) 825617"];
4989 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 825618"];
4990 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 825619"];
4991 [label="c.GetEmitDiagnostics(options: options) 825620"];
4992 [label="param GetEmitDiagnostics(EmitOptions options = null) 825621"];
4993 [label="param GetEmitDiagnostics(IEnumerable<ResourceDescription> manifestResources = null) 825622"];
4994 [label="MonoHelpers.IsRunningOnMono() 825623"];
4995 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 825624"];
4996 [label="var pdbStream = MonoHelpers.IsRunningOnMono() ? null : new MemoryStream(); 825625"];
4997 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 825626"];
4998 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 825627"];
4999 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 825628"];
5000 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 825629"];
5001 [label="param CreateModuleBuilder(IMethodSymbol? debugEntryPoint) 825630"];
5002 [label="param CreateModuleBuilder(IEnumerable<EmbeddedText>? embeddedTexts) 825631"];
5003 [label="param CreateModuleBuilder(CompilationTestData? testData) 825632"];
5004 [label="param CreateModuleBuilder(CancellationToken cancellationToken) 825633"];
5005 [label="Debug.Assert(!IsSubmission || HasCodeToEmit()); 825634"];
5006 [label="GetRuntimeMetadataVersion(emitOptions, diagnostics) 825635"];
5007 [label="GetRuntimeMetadataVersion(emitOptions) 825636"];
5008 [label="Assembly 825637"];
5009 [label="SourceAssembly 825638"];
5010 [label="GetBoundReferenceManager() 825639"];
5011 [label="Debug.Assert(_lazyAssemblySymbol is object); 825640"];
5012 [label="GetBoundReferenceManager(); 825641"];
5013 [label="var corAssembly = Assembly.CorLibrary as Symbols.Metadata.PE.PEAssemblySymbol; 825642"];
5014 [label="if (corAssembly is object)\n            {\n                return corAssembly.Assembly.ManifestModule.MetadataVersion;\n            } 825643"];
5015 [label="if (runtimeMDVersion != null)\n            {\n                return runtimeMDVersion;\n            } 825644"];
5016 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 825645"];
5017 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 825646"];
5018 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 825647"];
5019 [label="SourceAssembly 825648"];
5020 [label="GetBoundReferenceManager() 825649"];
5021 [label="GetBoundReferenceManager(); 825650"];
5022 [label="SourceAssembly.IsDelaySigned 825651"];
5023 [label="Declarations 825652"];
5024 [label="_syntaxAndDeclarations.GetLazyState() 825653"];
5025 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 825654"];
5026 [label="return Declarations.GetMergedRoot(this); 825655"];
5027 [label="_syntaxAndDeclarations.GetLazyState() 825656"];
5028 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 825657"];
5029 [label="SourceAssembly 825658"];
5030 [label="GetBoundReferenceManager() 825659"];
5031 [label="GetBoundReferenceManager(); 825660"];
5032 [label="SourceAssembly.StrongNameKeys 825661"];
5033 [label="=> 0x30 825662"];
5034 [label="0x30 825663"];
5035 [label="if (manifestResources == null)\n            {\n                manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>();\n            } 825664"];
5036 [label="PEModuleBuilder moduleBeingBuilt; 825665"];
5037 [label="GetBoundReferenceManager(); 825666"];
5038 [label="get\n            {\n                return true;\n            } 825667"];
5039 [label="if (sourceModule.AnyReferencedAssembliesAreLinked)\n            {\n                _embeddedTypesManagerOpt = new NoPia.EmbeddedTypesManager(this);\n            } 825668"];
5040 [label="Debug.Assert(sourceAssembly is object); 825669"];
5041 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 825670"];
5042 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 825671"];
5043 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 825672"];
5044 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 825673"];
5045 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 825674"];
5046 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 825675"];
5047 [label="PooledHashSet<int>? excludeDiagnostics = null; 825676"];
5048 [label="if (emitMetadataOnly)\n            {\n                excludeDiagnostics = PooledHashSet<int>.GetInstance();\n                excludeDiagnostics.Add((int)ErrorCode.ERR_ConcreteMissingBody);\n            } 825677"];
5049 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 825678"];
5050 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 825679"];
5051 [label="GetDiagnostics(CompilationStage.Declare, true, cancellationToken) 825680"];
5052 [label="param GetDiagnostics(CompilationStage stage) 825681"];
5053 [label="param GetDiagnostics(bool includeEarlierStages) 825682"];
5054 [label="var diagnostics = DiagnosticBag.GetInstance(); 825683"];
5055 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 825684"];
5056 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 825685"];
5057 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 825686"];
5058 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 825687"];
5059 [label="param GetDiagnostics(CompilationStage stage) 825688"];
5060 [label="param GetDiagnostics(bool includeEarlierStages) 825689"];
5061 [label="param GetDiagnostics(DiagnosticBag diagnostics) 825690"];
5062 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 825691"];
5063 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 825692"];
5064 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 825693"];
5065 [label="this.SyntaxTrees 825694"];
5066 [label="_syntaxAndDeclarations.GetLazyState() 825695"];
5067 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 825696"];
5068 [label="this.Options 825697"];
5069 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 825698"];
5070 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 825699"];
5071 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 825700"];
5072 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 825701"];
5073 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 825702"];
5074 [label="CheckAssemblyName(builder); 825703"];
5075 [label="CheckAssemblyName(builder); 825704"];
5076 [label="Options 825705"];
5077 [label="Options 825706"];
5078 [label="get\n            {\n                return _options;\n            } 825707"];
5079 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 825708"];
5080 [label="GetBoundReferenceManager() 825709"];
5081 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 825710"];
5082 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 825711"];
5083 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 825712"];
5084 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 825713"];
5085 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 825714"];
5086 [label="GlobalImports 825715"];
5087 [label="_globalImports.Value 825716"];
5088 [label="Imports.FromGlobalUsings(this) 825717"];
5089 [label="SourceLocation? location = null; 825718"];
5090 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 825719"];
5091 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 825720"];
5092 [label="Assembly 825721"];
5093 [label="SourceAssembly 825722"];
5094 [label="GetBoundReferenceManager() 825723"];
5095 [label="GetBoundReferenceManager(); 825724"];
5096 [label="Assembly.ForceComplete(location, cancellationToken); 825725"];
5097 [label="Assembly.ForceComplete(location, cancellationToken); 825726"];
5098 [label="SourceAssembly 825727"];
5099 [label="GetBoundReferenceManager() 825728"];
5100 [label="GetBoundReferenceManager(); 825729"];
5101 [label="Declarations 825730"];
5102 [label="_syntaxAndDeclarations.GetLazyState() 825731"];
5103 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 825732"];
5104 [label="return Declarations.GetMergedRoot(this); 825733"];
5105 [label="_syntaxAndDeclarations.GetLazyState() 825734"];
5106 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 825735"];
5107 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 825736"];
5108 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 825737"];
5109 [label="param SymbolDeclaredEvent(Symbol symbol) 825738"];
5110 [label="param SymbolDeclaredEvent(this) 825739"];
5111 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 825740"];
5112 [label="GetBoundReferenceManager() 825741"];
5113 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 825742"];
5114 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 825743"];
5115 [label="GetBinderFactory(syntax.SyntaxTree) 825744"];
5116 [label="param GetBinderFactory(bool ignoreAccessibility = false) 825745"];
5117 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 825746"];
5118 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 825747"];
5119 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 825748"];
5120 [label="param GetBinderFactory(bool ignoreAccessibility) 825749"];
5121 [label="ignoreAccessibility 825750"];
5122 [label="GetSyntaxTreeOrdinal(syntaxTree) 825751"];
5123 [label="this.ContainsSyntaxTree(tree) 825752"];
5124 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 825753"];
5125 [label="_syntaxAndDeclarations.GetLazyState() 825754"];
5126 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 825755"];
5127 [label="_syntaxAndDeclarations.GetLazyState() 825756"];
5128 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 825757"];
5129 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 825758"];
5130 [label="BinderFactory? previousFactory; 825759"];
5131 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 825760"];
5132 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 825761"];
5133 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 825762"];
5134 [label="param AddNewFactory(bool ignoreAccessibility) 825763"];
5135 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 825764"];
5136 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 825765"];
5137 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 825766"];
5138 [label="BinderFactory? previousFactory; 825767"];
5139 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 825768"];
5140 [label="Assembly 825769"];
5141 [label="SourceAssembly 825770"];
5142 [label="GetBoundReferenceManager() 825771"];
5143 [label="GetBoundReferenceManager(); 825772"];
5144 [label="return Assembly.Modules[0]; 825773"];
5145 [label="IsNullableAnalysisEnabledIn((CSharpSyntaxTree)syntax.SyntaxTree, syntax.Span) 825774"];
5146 [label="GetNullableAnalysisValue() 825775"];
5147 [label="return Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            }; 825776"];
5148 [label="Options 825777"];
5149 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 825778"];
5150 [label="param GetBinderFactory(bool ignoreAccessibility = false) 825779"];
5151 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 825780"];
5152 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 825781"];
5153 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 825782"];
5154 [label="param GetBinderFactory(bool ignoreAccessibility) 825783"];
5155 [label="ignoreAccessibility 825784"];
5156 [label="GetSyntaxTreeOrdinal(syntaxTree) 825785"];
5157 [label="this.ContainsSyntaxTree(tree) 825786"];
5158 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 825787"];
5159 [label="_syntaxAndDeclarations.GetLazyState() 825788"];
5160 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 825789"];
5161 [label="_syntaxAndDeclarations.GetLazyState() 825790"];
5162 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 825791"];
5163 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 825792"];
5164 [label="BinderFactory? previousFactory; 825793"];
5165 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 825794"];
5166 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 825795"];
5167 [label="return previousFactory; 825796"];
5168 [label="compilation.SyntaxTrees 825797"];
5169 [label="_syntaxAndDeclarations.GetLazyState() 825798"];
5170 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 825799"];
5171 [label="return ((CSharpParseOptions)compilation.SyntaxTrees.FirstOrDefault()?.Options)?.IsFeatureEnabled(feature) == true; 825800"];
5172 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 825801"];
5173 [label="NamedTypeSymbol result; 825802"];
5174 [label="GetBoundReferenceManager(); 825803"];
5175 [label="Debug.Assert(result.SpecialType == specialType); 825804"];
5176 [label="Assembly 825805"];
5177 [label="SourceAssembly 825806"];
5178 [label="GetBoundReferenceManager() 825807"];
5179 [label="GetBoundReferenceManager(); 825808"];
5180 [label="return Assembly.Modules[0]; 825809"];
5181 [label="Debug.Assert(symbol.IsDefinition); 825810"];
5182 [label="SourceModule 825811"];
5183 [label="Assembly 825812"];
5184 [label="SourceAssembly 825813"];
5185 [label="GetBoundReferenceManager() 825814"];
5186 [label="GetBoundReferenceManager(); 825815"];
5187 [label="return Assembly.Modules[0]; 825816"];
5188 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 825817"];
5189 [label="EmitNullablePublicOnly 825818"];
5190 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 825819"];
5191 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 825820"];
5192 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 825821"];
5193 [label="_declarationDiagnosticsFrozen = true; 825822"];
5194 [label="_needsGeneratedAttributes_IsFrozen = true; 825823"];
5195 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 825824"];
5196 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 825825"];
5197 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 825826"];
5198 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 825827"];
5199 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 825828"];
5200 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 825829"];
5201 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 825830"];
5202 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 825831"];
5203 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 825832"];
5204 [label="param CheckCompliance(DiagnosticBag diagnostics) 825833"];
5205 [label="System.Diagnostics.Debug.Assert(symbol is SourceAssemblySymbol); 825834"];
5206 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 825835"];
5207 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 825836"];
5208 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 825837"];
5209 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 825838"];
5210 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 825839"];
5211 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 825840"];
5212 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 825841"];
5213 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 825842"];
5214 [label="param GetDeclaredCompliance(out Location attributeLocation) 825843"];
5215 [label="param GetDeclaredCompliance(this) 825844"];
5216 [label="attributeLocation = null; 825845"];
5217 [label="if (assemblyCompliance == Compliance.DeclaredFalse)\n            {\n                // Our interpretation of an assembly-level CLSCompliant attribute is as follows:\n                //   1) If true, then perform all CLS checks.\n                //   2) If false, then perform no CLS checks (dev11 still performs a few, mostly around\n                //      meaningless attributes).  Our interpretation is that the user ultimately wants\n                //      his code to be CLS-compliant, but is temporarily disabling the checks (e.g. during\n                //      refactoring/prototyping).\n                //   3) If absent, the perform all CLS checks.  Our interpretation is that - in the\n                //      absence of an assembly-level attribute - any CLS problems within the compilation\n                //      indicate that the user was trying to do something but didn't know how.  It would\n                //      be nice if the most common case (i.e. this one) was the cheapest, but we don't\n                //      want to confuse novice users.\n                return;\n            } 825846"];
5218 [label="bool assemblyComplianceValue = IsTrue(assemblyCompliance); 825847"];
5219 [label="IsTrue(assemblyCompliance) 825848"];
5220 [label="param IsTrue(Compliance compliance) 825849"];
5221 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 825850"];
5222 [label="return false; 825851"];
5223 [label="Location attributeLocation; 825852"];
5224 [label="param GetDeclaredCompliance(out Location attributeLocation) 825853"];
5225 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 825854"];
5226 [label="i == 0 825855"];
5227 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 825856"];
5228 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 825857"];
5229 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 825858"];
5230 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 825859"];
5231 [label="if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 825860"];
5232 [label="if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 825861"];
5233 [label="if (assemblyComplianceValue)\n            {\n                CheckForAttributeWithArrayArgument(symbol);\n            } 825862"];
5234 [label="System.Diagnostics.Debug.Assert(symbol.Kind != SymbolKind.Assembly); 825863"];
5235 [label="System.Diagnostics.Debug.Assert((object)containing != null); 825864"];
5236 [label="return compliance; 825865"];
5237 [label="IsTrue(GetInheritedCompliance(symbol)) 825866"];
5238 [label="param IsTrue(Compliance compliance) 825867"];
5239 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 825868"];
5240 [label="return false; 825869"];
5241 [label="IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)) 825870"];
5242 [label="param IsTrue(Compliance compliance) 825871"];
5243 [label="if (DoNotVisit(symbol)) return; 825872"];
5244 [label="DoNotVisit(symbol) 825873"];
5245 [label="param DoNotVisit(Symbol symbol) 825874"];
5246 [label="param DoNotVisit(this) 825875"];
5247 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                return false;\n            } 825876"];
5248 [label="return false; 825877"];
5249 [label="IsTrue(GetDeclaredOrInheritedCompliance(symbol)) 825878"];
5250 [label="param IsTrue(Compliance compliance) 825879"];
5251 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 825880"];
5252 [label="return false; 825881"];
5253 [label="if (tasks == null)\n            {\n                return;\n            } 825882"];
5254 [label="checker.WaitForWorkers(); 825883"];
5255 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 825884"];
5256 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 825885"];
5257 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 825886"];
5258 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 825887"];
5259 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 825888"];
5260 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 825889"];
5261 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 825890"];
5262 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 825891"];
5263 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 825892"];
5264 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 825893"];
5265 [label="excludeDiagnostics?.Free(); 825894"];
5266 [label="param AddDebugSourceDocumentsForChecksumDirectives(DebugDocumentsBuilder documentsBuilder) 825895"];
5267 [label="param AddDebugSourceDocumentsForChecksumDirectives(DiagnosticBag diagnostics) 825896"];
5268 [label="param AddDebugSourceDocumentsForChecksumDirectives(this) 825897"];
5269 [label="foreach (var directive in checksumDirectives)\n            {\n                var checksumDirective = (PragmaChecksumDirectiveTriviaSyntax)directive;\n                var path = checksumDirective.File.ValueText;\n\n                var checksumText = checksumDirective.Bytes.ValueText;\n                var normalizedPath = documentsBuilder.NormalizeDebugDocumentPath(path, basePath: tree.FilePath);\n                var existingDoc = documentsBuilder.TryGetDebugDocumentForNormalizedPath(normalizedPath);\n\n                // duplicate checksum pragmas are valid as long as values match\n                // if we have seen this document already, check for matching values.\n                if (existingDoc != null)\n                {\n                    // pragma matches a file path on an actual tree.\n                    // Dev12 compiler just ignores the pragma in this case which means that\n                    // checksum of the actual tree always wins and no warning is given.\n                    // We will continue doing the same.\n                    if (existingDoc.IsComputedChecksum)\n                    {\n                        continue;\n                    }\n\n                    var sourceInfo = existingDoc.GetSourceInfo();\n                    if (ChecksumMatches(checksumText, sourceInfo.Checksum))\n                    {\n                        var guid = Guid.Parse(checksumDirective.Guid.ValueText);\n                        if (guid == sourceInfo.ChecksumAlgorithmId)\n                        {\n                            // all parts match, nothing to do\n                            continue;\n                        }\n                    }\n\n                    // did not match to an existing document\n                    // produce a warning and ignore the pragma\n                    diagnostics.Add(ErrorCode.WRN_ConflictingChecksum, new SourceLocation(checksumDirective), path);\n                }\n                else\n                {\n                    var newDocument = new Cci.DebugSourceDocument(\n                        normalizedPath,\n                        Cci.DebugSourceDocument.CorSymLanguageTypeCSharp,\n                        MakeChecksumBytes(checksumText),\n                        Guid.Parse(checksumDirective.Guid.ValueText));\n\n                    documentsBuilder.AddDebugDocument(newDocument);\n                }\n            } 825898"];
5270 [label="Debug.Assert(compilation != null); 825899"];
5271 [label="Debug.Assert(diagnostics != null); 825900"];
5272 [label="Debug.Assert(diagnostics != null); 825901"];
5273 [label="compilation.PreviousSubmission 825902"];
5274 [label="ScriptCompilationInfo 825903"];
5275 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 825904"];
5276 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 825905"];
5277 [label="MethodSymbol entryPoint = null; 825906"];
5278 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 825907"];
5279 [label="param GetEntryPoint(bool hasDeclarationErrors) 825908"];
5280 [label="param GetEntryPoint(CancellationToken cancellationToken) 825909"];
5281 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 825910"];
5282 [label="EntryPoint? entryPoint; 825911"];
5283 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 825912"];
5284 [label="Debug.Assert(compilation != null); 825913"];
5285 [label="Debug.Assert(diagnostics != null); 825914"];
5286 [label="Debug.Assert(diagnostics != null); 825915"];
5287 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 825916"];
5288 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 825917"];
5289 [label="param SetGlobalErrorIfTrue(bool arg) 825918"];
5290 [label="param SetGlobalErrorIfTrue(this) 825919"];
5291 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 825920"];
5292 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 825921"];
5293 [label="GetBoundReferenceManager(); 825922"];
5294 [label="param VisitNamedType(TypeCompilationState arg) 825923"];
5295 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 825924"];
5296 [label="PassesFilter(_filterOpt, symbol) 825925"];
5297 [label="param PassesFilter(Predicate<Symbol> filterOpt) 825926"];
5298 [label="param PassesFilter(Symbol symbol) 825927"];
5299 [label="return (filterOpt == null) || filterOpt(symbol); 825928"];
5300 [label="return (filterOpt == null) || filterOpt(symbol); 825929"];
5301 [label="arg = null; 825930"];
5302 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 825931"];
5303 [label="if (tasks == null)\n            {\n                return;\n            } 825932"];
5304 [label="if (tasks == null)\n            {\n                return;\n            } 825933"];
5305 [label="methodCompiler.WaitForWorkers(); 825934"];
5306 [label="var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics); 825935"];
5307 [label="moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics) 825936"];
5308 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 825937"];
5309 [label="_additionalTypes 825938"];
5310 [label="var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics); 825939"];
5311 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 825940"];
5312 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 825941"];
5313 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics) 825942"];
5314 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 825943"];
5315 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 825944"];
5316 [label="param CompileSynthesizedMethods(this) 825945"];
5317 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 825946"];
5318 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 825947"];
5319 [label="var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics); 825948"];
5320 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 825949"];
5321 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 825950"];
5322 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 825951"];
5323 [label="return GetNeedsGeneratedAttributesInternal(); 825952"];
5324 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 825953"];
5325 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 825954"];
5326 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 825955"];
5327 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 825956"];
5328 [label="return; 825957"];
5329 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 825958"];
5330 [label="var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics); 825959"];
5331 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 825960"];
5332 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 825961"];
5333 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics) 825962"];
5334 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 825963"];
5335 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 825964"];
5336 [label="param CompileSynthesizedMethods(this) 825965"];
5337 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 825966"];
5338 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 825967"];
5339 [label="param GetPreviousAnonymousTypes(this) 825968"];
5340 [label="param GetNextAnonymousTypeIndex(this) 825969"];
5341 [label="methodCompiler.WaitForWorkers(); 825970"];
5342 [label="var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass; 825971"];
5343 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 825972"];
5344 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 825973"];
5345 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 825974"];
5346 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 825975"];
5347 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 825976"];
5348 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 825977"];
5349 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 825978"];
5350 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag) 825979"];
5351 [label="param GenerateModuleInitializer(PEModuleBuilder moduleBeingBuilt) 825980"];
5352 [label="param GenerateModuleInitializer(DiagnosticBag methodBodyDiagnosticBag) 825981"];
5353 [label="param GenerateModuleInitializer(this) 825982"];
5354 [label="Debug.Assert(_declarationDiagnosticsFrozen); 825983"];
5355 [label="if (_moduleInitializerMethods is object)\n            {\n                var ilBuilder = new ILBuilder(moduleBeingBuilt, new LocalSlotManager(slotAllocator: null), OptimizationLevel.Release, areLocalsZeroed: false);\n\n                foreach (MethodSymbol method in _moduleInitializerMethods.OrderBy<MethodSymbol>(LexicalOrderSymbolComparer.Instance))\n                {\n                    ilBuilder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n\n                    ilBuilder.EmitToken(\n                        moduleBeingBuilt.Translate(method, methodBodyDiagnosticBag, needDeclaration: true),\n                        CSharpSyntaxTree.Dummy.GetRoot(),\n                        methodBodyDiagnosticBag);\n                }\n\n                ilBuilder.EmitRet(isVoid: true);\n                ilBuilder.Realize();\n                moduleBeingBuilt.RootModuleType.SetStaticConstructorBody(ilBuilder.RealizedIL);\n            } 825984"];
5356 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 825985"];
5357 [label="if (hasDeclarationErrors || hasMethodBodyError)\n                {\n                    return false;\n                } 825986"];
5358 [label="return true; 825987"];
5359 [label="DiagnosticBag? resourceDiagnostics = DiagnosticBag.GetInstance(); 825988"];
5360 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 825989"];
5361 [label="SourceAssembly 825990"];
5362 [label="GetBoundReferenceManager() 825991"];
5363 [label="GetBoundReferenceManager(); 825992"];
5364 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 825993"];
5365 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 825994"];
5366 [label="AddedModulesResourceNames(resourceDiagnostics) 825995"];
5367 [label="param AddedModulesResourceNames(DiagnosticBag diagnostics) 825996"];
5368 [label="SourceAssembly 825997"];
5369 [label="GetBoundReferenceManager() 825998"];
5370 [label="GetBoundReferenceManager(); 825999"];
5371 [label="ImmutableArray<ModuleSymbol> modules = SourceAssembly.Modules; 826000"];
5372 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 826001"];
5373 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 826002"];
5374 [label="param AddedModulesResourceNames(this) 826003"];
5375 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 826004"];
5376 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 826005"];
5377 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 826006"];
5378 [label="DiagnosticBag? xmlDiagnostics = DiagnosticBag.GetInstance(); 826007"];
5379 [label="string? assemblyName = FileNameUtilities.ChangeExtension(outputNameOverride, extension: null); 826008"];
5380 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 826009"];
5381 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 826010"];
5382 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken) 826011"];
5383 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 826012"];
5384 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 826013"];
5385 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 826014"];
5386 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 826015"];
5387 [label="StreamWriter writer = null; 826016"];
5388 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 826017"];
5389 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 826018"];
5390 [label="compilation.SourceAssembly 826019"];
5391 [label="GetBoundReferenceManager() 826020"];
5392 [label="GetBoundReferenceManager(); 826021"];
5393 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 826022"];
5394 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 826023"];
5395 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 826024"];
5396 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 826025"];
5397 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 826026"];
5398 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 826027"];
5399 [label="param DocumentationCommentCompiler(TextWriter writer) 826028"];
5400 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 826029"];
5401 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 826030"];
5402 [label="param DocumentationCommentCompiler(bool processIncludes) 826031"];
5403 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 826032"];
5404 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 826033"];
5405 [label="param DocumentationCommentCompiler(this) 826034"];
5406 [label="param DocumentationCommentCompiler(this) 826035"];
5407 [label="_assemblyName 826036"];
5408 [label="_compilation 826037"];
5409 [label="_writer 826038"];
5410 [label="_filterTree 826039"];
5411 [label="_filterSpanWithinTree 826040"];
5412 [label="_processIncludes 826041"];
5413 [label="_isForSingleSymbol 826042"];
5414 [label="_diagnostics 826043"];
5415 [label="_lazyComparer 826044"];
5416 [label="_includedFileCache 826045"];
5417 [label="_indentDepth 826046"];
5418 [label="_temporaryStringBuilders 826047"];
5419 [label="_writer 826048"];
5420 [label="_filterTree 826049"];
5421 [label="_filterSpanWithinTree 826050"];
5422 [label="_processIncludes 826051"];
5423 [label="_isForSingleSymbol 826052"];
5424 [label="_diagnostics 826053"];
5425 [label="compilation.SourceAssembly 826054"];
5426 [label="GetBoundReferenceManager() 826055"];
5427 [label="GetBoundReferenceManager(); 826056"];
5428 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 826057"];
5429 [label="Debug.Assert(_assemblyName != null); 826058"];
5430 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 826059"];
5431 [label="WriteLine('<?xml version=\\'1.0\\'?>') 826060"];
5432 [label="param WriteLine(string message) 826061"];
5433 [label="param WriteLine(this) 826062"];
5434 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826063"];
5435 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826064"];
5436 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826065"];
5437 [label="WriteLine('<doc>'); 826066"];
5438 [label="WriteLine('<doc>') 826067"];
5439 [label="param WriteLine(string message) 826068"];
5440 [label="param WriteLine(this) 826069"];
5441 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826070"];
5442 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826071"];
5443 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826072"];
5444 [label="Indent(); 826073"];
5445 [label="WriteLine('<assembly>'); 826074"];
5446 [label="WriteLine('<assembly>') 826075"];
5447 [label="param WriteLine(string message) 826076"];
5448 [label="param WriteLine(this) 826077"];
5449 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826078"];
5450 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826079"];
5451 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826080"];
5452 [label="Indent(); 826081"];
5453 [label="WriteLine('<name>{0}</name>', _assemblyName); 826082"];
5454 [label="WriteLine('<name>{0}</name>', _assemblyName) 826083"];
5455 [label="WriteLine('<name>{0}</name>', _assemblyName) 826084"];
5456 [label="param WriteLine(string format) 826085"];
5457 [label="param WriteLine(params object[] args) 826086"];
5458 [label="param WriteLine(this) 826087"];
5459 [label="WriteLine(string.Format(format, args)); 826088"];
5460 [label="WriteLine(string.Format(format, args)); 826089"];
5461 [label="WriteLine(string.Format(format, args)); 826090"];
5462 [label="WriteLine(string.Format(format, args)) 826091"];
5463 [label="param WriteLine(string message) 826092"];
5464 [label="param WriteLine(this) 826093"];
5465 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826094"];
5466 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826095"];
5467 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826096"];
5468 [label="WriteLine(string.Format(format, args)); 826097"];
5469 [label="Debug.Assert(_indentDepth >= 0); 826098"];
5470 [label="Unindent(); 826099"];
5471 [label="WriteLine('</assembly>'); 826100"];
5472 [label="WriteLine('</assembly>') 826101"];
5473 [label="param WriteLine(string message) 826102"];
5474 [label="param WriteLine(this) 826103"];
5475 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826104"];
5476 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826105"];
5477 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826106"];
5478 [label="WriteLine('<members>'); 826107"];
5479 [label="WriteLine('<members>') 826108"];
5480 [label="param WriteLine(string message) 826109"];
5481 [label="param WriteLine(this) 826110"];
5482 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826111"];
5483 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826112"];
5484 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826113"];
5485 [label="Indent(); 826114"];
5486 [label="Debug.Assert(!_isForSingleSymbol); 826115"];
5487 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 826116"];
5488 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 826117"];
5489 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 826118"];
5490 [label="DocumentationMode maxDocumentationMode; 826119"];
5491 [label="ImmutableArray<DocumentationCommentTriviaSyntax> docCommentNodes; 826120"];
5492 [label="docCommentNodes 826121"];
5493 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 826122"];
5494 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 826123"];
5495 [label="maxDocumentationMode = DocumentationMode.None; 826124"];
5496 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 826125"];
5497 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 826126"];
5498 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 826127"];
5499 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 826128"];
5500 [label="currDocumentationMode > maxDocumentationMode 826129"];
5501 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 826130"];
5502 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 826131"];
5503 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 826132"];
5504 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 826133"];
5505 [label="return true; 826134"];
5506 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 826135"];
5507 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 826136"];
5508 [label="return; 826137"];
5509 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 826138"];
5510 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 826139"];
5511 [label="currDocumentationMode > maxDocumentationMode 826140"];
5512 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 826141"];
5513 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 826142"];
5514 [label="Debug.Assert(_indentDepth >= 0); 826143"];
5515 [label="Unindent(); 826144"];
5516 [label="WriteLine('</members>'); 826145"];
5517 [label="WriteLine('</members>') 826146"];
5518 [label="param WriteLine(string message) 826147"];
5519 [label="param WriteLine(this) 826148"];
5520 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826149"];
5521 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826150"];
5522 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826151"];
5523 [label="Unindent(); 826152"];
5524 [label="WriteLine('</doc>'); 826153"];
5525 [label="WriteLine('</doc>') 826154"];
5526 [label="param WriteLine(string message) 826155"];
5527 [label="param WriteLine(this) 826156"];
5528 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826157"];
5529 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826158"];
5530 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 826159"];
5531 [label="Debug.Assert(compiler._indentDepth == 0); 826160"];
5532 [label="Debug.Assert(compiler._indentDepth == 0); 826161"];
5533 [label="writer?.Flush(); 826162"];
5534 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 826163"];
5535 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 826164"];
5536 [label="compilation.SyntaxTrees 826165"];
5537 [label="_syntaxAndDeclarations.GetLazyState() 826166"];
5538 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 826167"];
5539 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 826168"];
5540 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 826169"];
5541 [label="param ReportUnprocessed(CancellationToken cancellationToken) 826170"];
5542 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 826171"];
5543 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 826172"];
5544 [label="param ReportUnusedImports(SyntaxTree? filterTree) 826173"];
5545 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 826174"];
5546 [label="param ReportUnusedImports(CancellationToken cancellationToken) 826175"];
5547 [label="param ReportUnusedImports(this) 826176"];
5548 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 826177"];
5549 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 826178"];
5550 [label="CompleteTrees(filterTree); 826179"];
5551 [label="CompleteTrees(filterTree) 826180"];
5552 [label="param CompleteTrees(SyntaxTree? filterTree) 826181"];
5553 [label="param CompleteTrees(this) 826182"];
5554 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 826183"];
5555 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 826184"];
5556 [label="CompleteTrees(filterTree); 826185"];
5557 [label="this.SourceModule 826186"];
5558 [label="Assembly 826187"];
5559 [label="SourceAssembly 826188"];
5560 [label="GetBoundReferenceManager() 826189"];
5561 [label="GetBoundReferenceManager(); 826190"];
5562 [label="return Assembly.Modules[0]; 826191"];
5563 [label="SourceAssembly 826192"];
5564 [label="GetBoundReferenceManager() 826193"];
5565 [label="GetBoundReferenceManager(); 826194"];
5566 [label="SourceAssembly.IsDelaySigned 826195"];
5567 [label="SourceAssembly 826196"];
5568 [label="GetBoundReferenceManager() 826197"];
5569 [label="GetBoundReferenceManager(); 826198"];
5570 [label="param GetCorLibraryReferenceToEmit(CodeAnalysis.Emit.EmitContext context) 826199"];
5571 [label="param GetCorLibraryReferenceToEmit(this) 826200"];
5572 [label="CorLibrary 826201"];
5573 [label="get { return SourceModule.ContainingSourceAssembly.CorLibrary; } 826202"];
5574 [label="return SourceModule.ContainingSourceAssembly.CorLibrary; 826203"];
5575 [label="AssemblySymbol corLibrary = CorLibrary; 826204"];
5576 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 826205"];
5577 [label="return null; 826206"];
5578 [label="param GetAssemblyReferencesFromAddedModules(DiagnosticBag diagnostics) 826207"];
5579 [label="ImmutableArray<ModuleSymbol> modules = SourceModule.ContainingAssembly.Modules; 826208"];
5580 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 826209"];
5581 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                foreach (AssemblySymbol aRef in modules[i].GetReferencedAssemblySymbols())\n                {\n                    yield return Translate(aRef, diagnostics);\n                }\n            } 826210"];
5582 [label="param GetAssemblyReferencesFromAddedModules(this) 826211"];
5583 [label="var modules = sourceAssSymbol.Modules; 826212"];
5584 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 826213"];
5585 [label="for (int i = 1; i < modules.Length; i++)\n                        {\n                            builder.Add((Cci.IFileReference)Translate(modules[i], contxt.Diagnostics));\n                        } 826214"];
5586 [label="if (!contxt.IsRefAssembly)\n                        {\n                            // resources are not emitted into ref assemblies\n                            foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            }\n                        } 826215"];
5587 [label="foreach (ResourceDescription resource in ManifestResources)\n                            {\n                                if (!resource.IsEmbedded)\n                                {\n                                    builder.Add(resource);\n                                }\n                            } 826216"];
5588 [label="param GetAnonymousTypeDefinitions(EmitContext context) 826217"];
5589 [label="if (context.MetadataOnly)\n            {\n                return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>();\n            } 826218"];
5590 [label="Compilation.AnonymousTypeManager 826219"];
5591 [label="return Compilation.AnonymousTypeManager.GetAllCreatedTemplates()\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n\n#endif\n                   ; 826220"];
5592 [label="param GetAdditionalTopLevelTypeDefinitions(EmitContext context) 826221"];
5593 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 826222"];
5594 [label="GetAdditionalTopLevelTypes(context.Diagnostics) 826223"];
5595 [label="param GetAdditionalTopLevelTypes(DiagnosticBag diagnostics) 826224"];
5596 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 826225"];
5597 [label="param GetEmbeddedTypeDefinitions(EmitContext context) 826226"];
5598 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 826227"];
5599 [label="GetEmbeddedTypes(context.Diagnostics) 826228"];
5600 [label="param GetEmbeddedTypes(DiagnosticBag diagnostics) 826229"];
5601 [label="var builder = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 826230"];
5602 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 826231"];
5603 [label="CreateEmbeddedAttributesIfNeeded(diagnostics) 826232"];
5604 [label="param CreateEmbeddedAttributesIfNeeded(DiagnosticBag diagnostics) 826233"];
5605 [label="GetNeedsGeneratedAttributes() 826234"];
5606 [label="_needsGeneratedAttributes_IsFrozen = true; 826235"];
5607 [label="GetNeedsGeneratedAttributesInternal() 826236"];
5608 [label="return GetNeedsGeneratedAttributesInternal(); 826237"];
5609 [label="EmbeddableAttributes needsAttributes = GetNeedsGeneratedAttributes(); 826238"];
5610 [label="ShouldEmitNullablePublicOnlyAttribute() 826239"];
5611 [label="if (ShouldEmitNullablePublicOnlyAttribute() &&\n                Compilation.CheckIfAttributeShouldBeEmbedded(EmbeddableAttributes.NullablePublicOnlyAttribute, diagnostics, Location.None))\n            {\n                needsAttributes |= EmbeddableAttributes.NullablePublicOnlyAttribute;\n            }\n            else if (needsAttributes == 0)\n            {\n                return;\n            } 826240"];
5612 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 826241"];
5613 [label="if (needsAttributes == 0)\n            {\n                return;\n            } 826242"];
5614 [label="return; 826243"];
5615 [label="CreateEmbeddedAttributesIfNeeded(diagnostics); 826244"];
5616 [label="builder.AddIfNotNull(_lazyEmbeddedAttribute); 826245"];
5617 [label="builder.AddIfNotNull(_lazyIsReadOnlyAttribute); 826246"];
5618 [label="builder.AddIfNotNull(_lazyIsUnmanagedAttribute); 826247"];
5619 [label="builder.AddIfNotNull(_lazyIsByRefLikeAttribute); 826248"];
5620 [label="builder.AddIfNotNull(_lazyNullableAttribute); 826249"];
5621 [label="builder.AddIfNotNull(_lazyNullableContextAttribute); 826250"];
5622 [label="builder.AddIfNotNull(_lazyNullablePublicOnlyAttribute); 826251"];
5623 [label="builder.AddIfNotNull(_lazyNativeIntegerAttribute); 826252"];
5624 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 826253"];
5625 [label="param GetTopLevelSourceTypeDefinitions(EmitContext context) 826254"];
5626 [label="var namespacesToProcess = new Stack<NamespaceSymbol>(); 826255"];
5627 [label="while (namespacesToProcess.Count > 0)\n            {\n                var ns = namespacesToProcess.Pop();\n                foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                }\n            } 826256"];
5628 [label="Debug.Assert(symbol.IsDefinition); 826257"];
5629 [label="SourceModule 826258"];
5630 [label="Assembly 826259"];
5631 [label="SourceAssembly 826260"];
5632 [label="GetBoundReferenceManager() 826261"];
5633 [label="GetBoundReferenceManager(); 826262"];
5634 [label="return Assembly.Modules[0]; 826263"];
5635 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 826264"];
5636 [label="EmitNullablePublicOnly 826265"];
5637 [label="param SynthesizeNullableAttributeIfNecessary(Symbol symbol) 826266"];
5638 [label="Compilation.SourceModule 826267"];
5639 [label="Assembly 826268"];
5640 [label="SourceAssembly 826269"];
5641 [label="GetBoundReferenceManager() 826270"];
5642 [label="GetBoundReferenceManager(); 826271"];
5643 [label="return Assembly.Modules[0]; 826272"];
5644 [label="if ((object)Compilation.SourceModule != symbol.ContainingModule)\n            {\n                // For symbols that are not defined in the same compilation (like NoPia), don't synthesize this attribute.\n                return null;\n            } 826273"];
5645 [label="if ((object)Compilation.SourceModule != symbol.ContainingModule)\n            {\n                // For symbols that are not defined in the same compilation (like NoPia), don't synthesize this attribute.\n                return null;\n            } 826274"];
5646 [label="var flagsBuilder = ArrayBuilder<byte>.GetInstance(); 826275"];
5647 [label="type.AddNullableTransforms(flagsBuilder); 826276"];
5648 [label="SynthesizedAttributeData attribute; 826277"];
5649 [label="param SynthesizeNullableAttributeIfNecessary(this) 826278"];
5650 [label="param GetSynthesizedNestedTypes(NamedTypeSymbol container) 826279"];
5651 [label="param GetSynthesizedNestedTypes(this) 826280"];
5652 [label="return null; 826281"];
5653 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 826282"];
5654 [label="SourceAssembly 826283"];
5655 [label="GetBoundReferenceManager() 826284"];
5656 [label="GetBoundReferenceManager(); 826285"];
5657 [label="GetBoundReferenceManager() 826286"];
5658 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 826287"];
5659 [label="return SourceModule.ContainingSourceAssembly.GetSecurityAttributes(); 826288"];
5660 [label="return SourceModule.GetCustomAttributesToEmit(this); 826289"];
5661 [label="param Translate(SyntaxNode syntaxNodeOpt) 826290"];
5662 [label="param Translate(DiagnosticBag diagnostics) 826291"];
5663 [label="Debug.Assert(diagnostics != null); 826292"];
5664 [label="Debug.Assert(diagnostics != null); 826293"];
5665 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 826294"];
5666 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 826295"];
5667 [label="param Translate(SyntaxNode syntaxNodeOpt) 826296"];
5668 [label="param Translate(DiagnosticBag diagnostics) 826297"];
5669 [label="param Translate(bool fromImplements = false) 826298"];
5670 [label="param Translate(bool needDeclaration = false) 826299"];
5671 [label="Debug.Assert(diagnostics != null); 826300"];
5672 [label="Debug.Assert(diagnostics != null); 826301"];
5673 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 826302"];
5674 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 826303"];
5675 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 826304"];
5676 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 826305"];
5677 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 826306"];
5678 [label="object reference; 826307"];
5679 [label="Cci.INamedTypeReference typeRef; 826308"];
5680 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 826309"];
5681 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 826310"];
5682 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 826311"];
5683 [label="IsGenericType(container) 826312"];
5684 [label="param IsGenericType(NamedTypeSymbol toCheck) 826313"];
5685 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 826314"];
5686 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 826315"];
5687 [label="return false; 826316"];
5688 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 826317"];
5689 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 826318"];
5690 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 826319"];
5691 [label="param Translate(DiagnosticBag diagnostics) 826320"];
5692 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 826321"];
5693 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 826322"];
5694 [label="if ((object)module == null)\n            {\n                return null;\n            } 826323"];
5695 [label="if ((object)module == null)\n            {\n                return null;\n            } 826324"];
5696 [label="Cci.IModuleReference moduleRef; 826325"];
5697 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(module, out moduleRef))\n            {\n                return moduleRef;\n            } 826326"];
5698 [label="TranslateModule(module, diagnostics) 826327"];
5699 [label="param TranslateModule(DiagnosticBag diagnostics) 826328"];
5700 [label="if ((object)container != null && ReferenceEquals(container.Modules[0], module))\n            {\n                Cci.IModuleReference moduleRef = new AssemblyReference(container);\n                Cci.IModuleReference cachedModuleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(container, moduleRef);\n\n                if (cachedModuleRef == moduleRef)\n                {\n                    ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics);\n                }\n                else\n                {\n                    moduleRef = cachedModuleRef;\n                }\n\n                return moduleRef;\n            }\n            else\n            {\n                return new ModuleReference(this, module);\n            } 826329"];
5701 [label="_targetAssembly 826330"];
5702 [label="Debug.Assert((object)assemblySymbol != null); 826331"];
5703 [label="ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics); 826332"];
5704 [label="param ValidateReferencedAssembly(AssemblyReference asmRef) 826333"];
5705 [label="param ValidateReferencedAssembly(DiagnosticBag diagnostics) 826334"];
5706 [label="param ValidateReferencedAssembly(this) 826335"];
5707 [label="AssemblyIdentity asmIdentity = SourceModule.ContainingAssembly.Identity; 826336"];
5708 [label="asmRef.Identity 826337"];
5709 [label="=> _targetAssembly.Identity 826338"];
5710 [label="AssemblyIdentity refIdentity = asmRef.Identity; 826339"];
5711 [label="if (asmIdentity.IsStrongName && !refIdentity.IsStrongName &&\n                asmRef.Identity.ContentType != AssemblyContentType.WindowsRuntime)\n            {\n                // Dev12 reported error, we have changed it to a warning to allow referencing libraries \n                // built for platforms that don't support strong names.\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName, assembly), NoLocation.Singleton);\n            } 826340"];
5712 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 826341"];
5713 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 826342"];
5714 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 826343"];
5715 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 826344"];
5716 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 826345"];
5717 [label="param GetExportedTypes(DiagnosticBag diagnostics) 826346"];
5718 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 826347"];
5719 [label="if (!OutputKind.IsNetModule())\n            {\n                var modules = sourceAssembly.Modules;\n                for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                }\n            } 826348"];
5720 [label="var modules = sourceAssembly.Modules; 826349"];
5721 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 826350"];
5722 [label="for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                } 826351"];
5723 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 826352"];
5724 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 826353"];
5725 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder) 826354"];
5726 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 826355"];
5727 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 826356"];
5728 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 826357"];
5729 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 826358"];
5730 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 826359"];
5731 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetNetModuleDecodedWellKnownAttributeData(), builder) 826360"];
5732 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 826361"];
5733 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 826362"];
5734 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 826363"];
5735 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 826364"];
5736 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 826365"];
5737 [label="return seenTopLevelForwardedTypes; 826366"];
5738 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 826367"];
5739 [label="param AddEmbeddedResourcesFromAddedModules(ArrayBuilder<Cci.ManagedResource> builder) 826368"];
5740 [label="param AddEmbeddedResourcesFromAddedModules(DiagnosticBag diagnostics) 826369"];
5741 [label="param AddEmbeddedResourcesFromAddedModules(this) 826370"];
5742 [label="var modules = _sourceAssembly.Modules; 826371"];
5743 [label="int count = modules.Length; 826372"];
5744 [label="for (int i = 1; i < count; i++)\n            {\n                var file = (Cci.IFileReference)Translate(modules[i], diagnostics);\n\n                try\n                {\n                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow())\n                    {\n                        builder.Add(new Cci.ManagedResource(\n                            resource.Name,\n                            (resource.Attributes & ManifestResourceAttributes.Public) != 0,\n                            null,\n                            file,\n                            resource.Offset));\n                    }\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, modules[i]), NoLocation.Singleton);\n                }\n            } 826373"];
5745 [label="for (int i = 1; i < count; i++)\n            {\n                var file = (Cci.IFileReference)Translate(modules[i], diagnostics);\n\n                try\n                {\n                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow())\n                    {\n                        builder.Add(new Cci.ManagedResource(\n                            resource.Name,\n                            (resource.Attributes & ManifestResourceAttributes.Public) != 0,\n                            null,\n                            file,\n                            resource.Offset));\n                    }\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, modules[i]), NoLocation.Singleton);\n                }\n            } 826374"];
5746 [label="=> ImmutableArray<Cci.UsedNamespaceOrType>.Empty 826375"];
5747 [label="ImmutableArray<Cci.UsedNamespaceOrType>.Empty 826376"];
5748 [label="param IsPlatformType(this) 826377"];
5749 [label="if ((object)namedType != null)\n            {\n                if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                }\n\n                return namedType.SpecialType == (SpecialType)platformType;\n            } 826378"];
5750 [label="if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                } 826379"];
5751 [label="var result = new MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation>(); 826380"];
5752 [label="var namespacesAndTypesToProcess = new Stack<NamespaceOrTypeSymbol>(); 826381"];
5753 [label="Location location = null; 826382"];
5754 [label="while (namespacesAndTypesToProcess.Count > 0)\n            {\n                NamespaceOrTypeSymbol symbol = namespacesAndTypesToProcess.Pop();\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Namespace:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n\n                        // filtering out synthesized symbols not having real source \n                        // locations such as anonymous types, etc...\n                        if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    case SymbolKind.NamedType:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n                        if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n                }\n            } 826383"];
5755 [label="param GetSmallestSourceLocationOrNull(this) 826384"];
5756 [label="CSharpCompilation compilation = symbol.DeclaringCompilation; 826385"];
5757 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 826386"];
5758 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 826387"];
5759 [label="param AddSymbolLocation(MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation> result) 826388"];
5760 [label="param AddSymbolLocation(Cci.IDefinition definition) 826389"];
5761 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 826390"];
5762 [label="param AddSymbolLocation(MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation> result) 826391"];
5763 [label="param GetSmallestSourceLocationOrNull(this) 826392"];
5764 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 826393"];
5765 [label="param AddSymbolLocation(MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation> result) 826394"];
5766 [label="param AddSymbolLocation(Cci.IDefinition definition) 826395"];
5767 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 826396"];
5768 [label="return result; 826397"];
5769 [label="GetBoundReferenceManager(); 826398"];
5770 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 826399"];
5771 [label="c.GetEmitDiagnostics(options: options).Verify(expected) 826400"];
5772 [label="param Verify(params DiagnosticDescription[] expected) 826401"];
5773 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 826402"];
5774 [label="Verify((IEnumerable<Diagnostic>)actual, expected) 826403"];
5775 [label="param Verify(params DiagnosticDescription[] expected) 826404"];
5776 [label="Verify(actual, expected, errorCodeOnly: false); 826405"];
5777 [label="Verify(actual, expected, errorCodeOnly: false); 826406"];
5778 [label="Verify(actual, expected, errorCodeOnly: false) 826407"];
5779 [label="param Verify(DiagnosticDescription[] expected) 826408"];
5780 [label="param Verify(bool errorCodeOnly) 826409"];
5781 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 826410"];
5782 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 826411"];
5783 [label="var includeDefaultSeverity = expected.Any() && expected.All(e => e.DefaultSeverity != null); 826412"];
5784 [label="var includeEffectiveSeverity = expected.Any() && expected.All(e => e.EffectiveSeverity != null); 826413"];
5785 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 826414"];
5786 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 826415"];
5787 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 826416"];
5788 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 826417"];
5789 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 826418"];
5790 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 826419"];
5791 [label="DiagnosticDescription.GetAssertText(expected, actual) 826420"];
5792 [label="param GetAssertText(DiagnosticDescription[] expected) 826421"];
5793 [label="const int CSharp = 1; 826422"];
5794 [label="const int VisualBasic = 2; 826423"];
5795 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 826424"];
5796 [label="actual.Any() && actual.First() is CSDiagnostic 826425"];
5797 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 826426"];
5798 [label="var includeDiagnosticMessagesAsComments = (language == CSharp); 826427"];
5799 [label="int indentDepth = (language == CSharp) ? 4 : 1; 826428"];
5800 [label="(language == CSharp) 826429"];
5801 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 826430"];
5802 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 826431"];
5803 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 826432"];
5804 [label="IsSortedOrEmpty(expected) 826433"];
5805 [label="param IsSortedOrEmpty(DiagnosticDescription[] diagnostics) 826434"];
5806 [label="var comparer = LinePositionComparer.Instance; 826435"];
5807 [label="DiagnosticDescription last = null; 826436"];
5808 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 826437"];
5809 [label="return true; 826438"];
5810 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 826439"];
5811 [label="Sort(actual) 826440"];
5812 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 826441"];
5813 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 826442"];
5814 [label="var assertText = new StringBuilder(); 826443"];
5815 [label="assertText.AppendLine(); 826444"];
5816 [label="int i; 826445"];
5817 [label="assertText.AppendLine('Expected:'); 826446"];
5818 [label="assertText.AppendLine('Expected:'); 826447"];
5819 [label="var expectedText = ArrayBuilder<string>.GetInstance(); 826448"];
5820 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 826449"];
5821 [label="GetCommaSeparatedLines(assertText, expectedText); 826450"];
5822 [label="GetCommaSeparatedLines(assertText, expectedText); 826451"];
5823 [label="GetCommaSeparatedLines(assertText, expectedText) 826452"];
5824 [label="param GetCommaSeparatedLines(StringBuilder sb) 826453"];
5825 [label="param GetCommaSeparatedLines(ArrayBuilder<string> lines) 826454"];
5826 [label="int n = lines.Count; 826455"];
5827 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 826456"];
5828 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 826457"];
5829 [label="GetCommaSeparatedLines(assertText, expectedText); 826458"];
5830 [label="assertText.AppendLine('Actual:'); 826459"];
5831 [label="assertText.AppendLine('Actual:'); 826460"];
5832 [label="var actualText = ArrayBuilder<string>.GetInstance(); 826461"];
5833 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 826462"];
5834 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 826463"];
5835 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 826464"];
5836 [label="assertText.AppendLine('Diff:'); 826465"];
5837 [label="assertText.AppendLine('Diff:'); 826466"];
5838 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 826467"];
5839 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 826468"];
5840 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 826469"];
5841 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 826470"];
5842 [label="DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine) 826471"];
5843 [label="param DiffReport(IEnumerable<T> expected) 826472"];
5844 [label="param DiffReport(IEnumerable<T> actual) 826473"];
5845 [label="param DiffReport(string separator) 826474"];
5846 [label="param DiffReport(IEqualityComparer<T> comparer = null) 826475"];
5847 [label="param DiffReport(Func<T, string> toString = null) 826476"];
5848 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 826477"];
5849 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 826478"];
5850 [label="(comparer != null) 826479"];
5851 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 826480"];
5852 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 826481"];
5853 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 826482"];
5854 [label="IList<T> expectedList = expected as IList<T> ?? new List<T>(expected); 826483"];
5855 [label="IList<T> actualList = actual as IList<T> ?? new List<T>(actual); 826484"];
5856 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 826485"];
5857 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 826486"];
5858 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 826487"];
5859 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 826488"];
5860 [label="lcs.CalculateDiff(expectedList, actualList, toString) 826489"];
5861 [label="param CalculateDiff(IList<T> sequenceA) 826490"];
5862 [label="param CalculateDiff(IList<T> sequenceB) 826491"];
5863 [label="param CalculateDiff(Func<T, string> toString) 826492"];
5864 [label="param CalculateDiff(this) 826493"];
5865 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 826494"];
5866 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 826495"];
5867 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 826496"];
5868 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 826497"];
5869 [label="GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count) 826498"];
5870 [label="param GetEdits(TSequence sequenceA) 826499"];
5871 [label="param GetEdits(int lengthA) 826500"];
5872 [label="param GetEdits(TSequence sequenceB) 826501"];
5873 [label="param GetEdits(int lengthB) 826502"];
5874 [label="param GetEdits(this) 826503"];
5875 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 826504"];
5876 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 826505"];
5877 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 826506"];
5878 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 826507"];
5879 [label="ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB) 826508"];
5880 [label="param ComputeCostMatrix(TSequence sequenceA) 826509"];
5881 [label="param ComputeCostMatrix(int lengthA) 826510"];
5882 [label="param ComputeCostMatrix(TSequence sequenceB) 826511"];
5883 [label="param ComputeCostMatrix(int lengthB) 826512"];
5884 [label="param ComputeCostMatrix(this) 826513"];
5885 [label="var la = lengthA + 1; 826514"];
5886 [label="var la = lengthA + 1; 826515"];
5887 [label="var lb = lengthB + 1; 826516"];
5888 [label="var lb = lengthB + 1; 826517"];
5889 [label="var d = new int[la, lb]; 826518"];
5890 [label="d[0, 0] = 0; 826519"];
5891 [label="d[0, 0] 826520"];
5892 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 826521"];
5893 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 826522"];
5894 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 826523"];
5895 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 826524"];
5896 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 826525"];
5897 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 826526"];
5898 [label="return d; 826527"];
5899 [label="int i = lengthA; 826528"];
5900 [label="int j = lengthB; 826529"];
5901 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 826530"];
5902 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 826531"];
5903 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 826532"];
5904 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 826533"];
5905 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 826534"];
5906 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 826535"];
5907 [label="param GetEdits(this) 826536"];
5908 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 826537"];
5909 [label="param CalculateDiff(this) 826538"];
5910 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 826539"];
5911 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 826540"];
5912 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 826541"];
5913 [label="actualText.Free(); 826542"];
5914 [label="expectedText.Free(); 826543"];
5915 [label="return assertText.ToString(); 826544"];
5916 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 826545"];
5917 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 826546"];
5918 [label="return c; 826547"];
5919 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { compRef },\n                options: TestOptions.ReleaseModule.WithPlatform(Platform.Itanium)); 826548"];
5920 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { compRef },\n                options: TestOptions.ReleaseModule.WithPlatform(Platform.Itanium)); 826549"];
5921 [label="new MetadataReference[] { compRef } 826550"];
5922 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { compRef },\n                options: TestOptions.ReleaseModule.WithPlatform(Platform.Itanium)); 826551"];
5923 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { compRef },\n                options: TestOptions.ReleaseModule.WithPlatform(Platform.Itanium)); 826552"];
5924 [label="new CSharpTestSource(source) 826553"];
5925 [label="param CSharpTestSource(this) 826554"];
5926 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 826555"];
5927 [label="=> CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 826556"];
5928 [label="skipUsesIsNullable 826557"];
5929 [label="null 826558"];
5930 [label="experimentalFeature: null 826559"];
5931 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 826560"];
5932 [label="param CreateCompilationCore(bool skipUsesIsNullable) 826561"];
5933 [label="param CreateCompilationCore(MessageID? experimentalFeature) 826562"];
5934 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 826563"];
5935 [label="var stream = new MemoryStream(); 826564"];
5936 [label="var root = tree.GetRoot(); 826565"];
5937 [label="root.SerializeTo(stream); 826566"];
5938 [label="root.SerializeTo(stream); 826567"];
5939 [label="root.SerializeTo(stream); 826568"];
5940 [label="stream.Position = 0; 826569"];
5941 [label="stream.Position 826570"];
5942 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 826571"];
5943 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 826572"];
5944 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 826573"];
5945 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 826574"];
5946 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 826575"];
5947 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 826576"];
5948 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 826577"];
5949 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 826578"];
5950 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 826579"];
5951 [label="param ValidateIOperations(Func<Compilation> createCompilation) 826580"];
5952 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 826581"];
5953 [label="return; 826582"];
5954 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 826583"];
5955 [label="var compilation = createCompilationLambda(); 826584"];
5956 [label="return Guid.NewGuid().ToString('D'); 826585"];
5957 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 826586"];
5958 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 826587"];
5959 [label="param Create(CSharpCompilation? previousSubmission) 826588"];
5960 [label="param Create(Type? returnType) 826589"];
5961 [label="param Create(Type? hostObjectType) 826590"];
5962 [label="param Create(bool isSubmission) 826591"];
5963 [label="RoslynDebug.Assert(options != null); 826592"];
5964 [label="RoslynDebug.Assert(options != null); 826593"];
5965 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 826594"];
5966 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 826595"];
5967 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 826596"];
5968 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 826597"];
5969 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 826598"];
5970 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 826599"];
5971 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 826600"];
5972 [label="new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null) 826601"];
5973 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 826602"];
5974 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 826603"];
5975 [label="param SyntaxAndDeclarationManager(bool isSubmission) 826604"];
5976 [label="param SyntaxAndDeclarationManager(State state) 826605"];
5977 [label="param SyntaxAndDeclarationManager(this) 826606"];
5978 [label="externalSyntaxTrees 826607"];
5979 [label="messageProvider 826608"];
5980 [label="isSubmission 826609"];
5981 [label="param SyntaxAndDeclarationManager(this) 826610"];
5982 [label="_lazyState 826611"];
5983 [label="_lazyState 826612"];
5984 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 826613"];
5985 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 826614"];
5986 [label="param CSharpCompilation(Type? submissionReturnType) 826615"];
5987 [label="param CSharpCompilation(Type? hostObjectType) 826616"];
5988 [label="param CSharpCompilation(bool isSubmission) 826617"];
5989 [label="param CSharpCompilation(ReferenceManager? referenceManager) 826618"];
5990 [label="param CSharpCompilation(bool reuseReferenceManager) 826619"];
5991 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 826620"];
5992 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 826621"];
5993 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 826622"];
5994 [label="param CSharpCompilation(this) 826623"];
5995 [label="previousSubmission 826624"];
5996 [label="submissionReturnType 826625"];
5997 [label="hostObjectType 826626"];
5998 [label="isSubmission 826627"];
5999 [label="referenceManager 826628"];
6000 [label="reuseReferenceManager 826629"];
6001 [label="syntaxAndDeclarations 826630"];
6002 [label="semanticModelProvider 826631"];
6003 [label="eventQueue 826632"];
6004 [label="param CSharpCompilation(this) 826633"];
6005 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 826634"];
6006 [label="param CSharpCompilation(Type? submissionReturnType) 826635"];
6007 [label="param CSharpCompilation(Type? hostObjectType) 826636"];
6008 [label="param CSharpCompilation(bool isSubmission) 826637"];
6009 [label="param CSharpCompilation(ReferenceManager? referenceManager) 826638"];
6010 [label="param CSharpCompilation(bool reuseReferenceManager) 826639"];
6011 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 826640"];
6012 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 826641"];
6013 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 826642"];
6014 [label="param CSharpCompilation(this) 826643"];
6015 [label="isSubmission 826644"];
6016 [label="semanticModelProvider 826645"];
6017 [label="eventQueue 826646"];
6018 [label="param CSharpCompilation(this) 826647"];
6019 [label="_options 826648"];
6020 [label="_globalImports 826649"];
6021 [label="_previousSubmissionImports 826650"];
6022 [label="_globalNamespaceAlias 826651"];
6023 [label="_scriptClass 826652"];
6024 [label="_lazyHostObjectTypeSymbol 826653"];
6025 [label="_lazyImportInfos 826654"];
6026 [label="_conversions 826655"];
6027 [label="_anonymousTypeManager 826656"];
6028 [label="_lazyGlobalNamespace 826657"];
6029 [label="builtInOperators 826658"];
6030 [label="_lazyAssemblySymbol 826659"];
6031 [label="_referenceManager 826660"];
6032 [label="_syntaxAndDeclarations 826661"];
6033 [label="_lazyEntryPoint 826662"];
6034 [label="_lazyEmitNullablePublicOnly 826663"];
6035 [label="_lazyCompilationUnitCompletedTrees 826664"];
6036 [label="NullableAnalysisData 826665"];
6037 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 826666"];
6038 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 826667"];
6039 [label="_externAliasTargets 826668"];
6040 [label="_moduleInitializerMethods 826669"];
6041 [label="_binderFactories 826670"];
6042 [label="_ignoreAccessibilityBinderFactories 826671"];
6043 [label="_lazyDeclarationDiagnostics 826672"];
6044 [label="_declarationDiagnosticsFrozen 826673"];
6045 [label="new DiagnosticBag() 826674"];
6046 [label="_additionalCodegenWarnings = new DiagnosticBag() 826675"];
6047 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 826676"];
6048 [label="this.builtInOperators = new BuiltInOperators(this); 826677"];
6049 [label="this.builtInOperators = new BuiltInOperators(this); 826678"];
6050 [label="new BuiltInOperators(this) 826679"];
6051 [label="param BuiltInOperators(CSharpCompilation compilation) 826680"];
6052 [label="param BuiltInOperators(this) 826681"];
6053 [label="_compilation 826682"];
6054 [label="_builtInUnaryOperators 826683"];
6055 [label="_builtInOperators 826684"];
6056 [label="_compilation 826685"];
6057 [label="this.builtInOperators 826686"];
6058 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 826687"];
6059 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 826688"];
6060 [label="LanguageVersion? result = null; 826689"];
6061 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 826690"];
6062 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 826691"];
6063 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 826692"];
6064 [label="this.LanguageVersion 826693"];
6065 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 826694"];
6066 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 826695"];
6067 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 826696"];
6068 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 826697"];
6069 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 826698"];
6070 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 826699"];
6071 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 826700"];
6072 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 826701"];
6073 [label="this.Options 826702"];
6074 [label="get\n            {\n                return _options;\n            } 826703"];
6075 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 826704"];
6076 [label="_syntaxAndDeclarations 826705"];
6077 [label="Debug.Assert(_lazyAssemblySymbol is null); 826706"];
6078 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 826707"];
6079 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 826708"];
6080 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 826709"];
6081 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 826710"];
6082 [label="int i = 0; 826711"];
6083 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 826712"];
6084 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 826713"];
6085 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 826714"];
6086 [label="i++; 826715"];
6087 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 826716"];
6088 [label="var scriptClassName = this.ScriptClassName; 826717"];
6089 [label="var resolver = this.Resolver; 826718"];
6090 [label="var messageProvider = this.MessageProvider; 826719"];
6091 [label="var isSubmission = this.IsSubmission; 826720"];
6092 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 826721"];
6093 [label="param CSharpCompilation(Type? submissionReturnType) 826722"];
6094 [label="param CSharpCompilation(Type? hostObjectType) 826723"];
6095 [label="previousSubmission 826724"];
6096 [label="submissionReturnType 826725"];
6097 [label="hostObjectType 826726"];
6098 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 826727"];
6099 [label="param CSharpCompilation(Type? submissionReturnType) 826728"];
6100 [label="param CSharpCompilation(Type? hostObjectType) 826729"];
6101 [label="_compilation 826730"];
6102 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 826731"];
6103 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 826732"];
6104 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 826733"];
6105 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 826734"];
6106 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 826735"];
6107 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 826736"];
6108 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 826737"];
6109 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 826738"];
6110 [label="Debug.Assert(_lazyAssemblySymbol is null); 826739"];
6111 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 826740"];
6112 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 826741"];
6113 [label="IsNullableEnabled(compilation) 826742"];
6114 [label="compilation.SyntaxTrees 826743"];
6115 [label="_syntaxAndDeclarations.GetLazyState() 826744"];
6116 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 826745"];
6117 [label="param AppendAllSyntaxTrees(SourceReferenceResolver resolver) 826746"];
6118 [label="param AppendAllSyntaxTrees(CommonMessageProvider messageProvider) 826747"];
6119 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMapBuilder) 826748"];
6120 [label="param AppendAllSyntaxTrees(IDictionary<string, SyntaxTree> loadedSyntaxTreeMapBuilder) 826749"];
6121 [label="var sourceCodeKind = tree.Options.Kind; 826750"];
6122 [label="if (sourceCodeKind == SourceCodeKind.Script)\n            {\n                AppendAllLoadedSyntaxTrees(treesBuilder, tree, scriptClassName, resolver, messageProvider, isSubmission, ordinalMapBuilder, loadDirectiveMapBuilder, loadedSyntaxTreeMapBuilder, declMapBuilder, ref declTable);\n            } 826751"];
6123 [label="OrdinalMap 826752"];
6124 [label="LoadDirectiveMap 826753"];
6125 [label="LoadedSyntaxTreeMap 826754"];
6126 [label="RootNamespaces 826755"];
6127 [label="DeclarationTable 826756"];
6128 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 826757"];
6129 [label="var options = (CSharpParseOptions)trees[0].Options; 826758"];
6130 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 826759"];
6131 [label="useCompilation.VerifyEmitDiagnostics(emitOptions); 826760"];
6132 [label="useCompilation.VerifyEmitDiagnostics(emitOptions); 826761"];
6133 [label="useCompilation.VerifyEmitDiagnostics(emitOptions); 826762"];
6134 [label="useCompilation.VerifyEmitDiagnostics(emitOptions) 826763"];
6135 [label="param VerifyEmitDiagnostics(this TCompilation c) 826764"];
6136 [label="param VerifyEmitDiagnostics(EmitOptions options) 826765"];
6137 [label="param VerifyEmitDiagnostics(params DiagnosticDescription[] expected) 826766"];
6138 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 826767"];
6139 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 826768"];
6140 [label="c.GetEmitDiagnostics(options: options) 826769"];
6141 [label="param GetEmitDiagnostics(EmitOptions options = null) 826770"];
6142 [label="param GetEmitDiagnostics(IEnumerable<ResourceDescription> manifestResources = null) 826771"];
6143 [label="MonoHelpers.IsRunningOnMono() 826772"];
6144 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 826773"];
6145 [label="var pdbStream = MonoHelpers.IsRunningOnMono() ? null : new MemoryStream(); 826774"];
6146 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 826775"];
6147 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 826776"];
6148 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 826777"];
6149 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 826778"];
6150 [label="param CreateModuleBuilder(IMethodSymbol? debugEntryPoint) 826779"];
6151 [label="param CreateModuleBuilder(IEnumerable<EmbeddedText>? embeddedTexts) 826780"];
6152 [label="param CreateModuleBuilder(CompilationTestData? testData) 826781"];
6153 [label="param CreateModuleBuilder(CancellationToken cancellationToken) 826782"];
6154 [label="Debug.Assert(!IsSubmission || HasCodeToEmit()); 826783"];
6155 [label="GetRuntimeMetadataVersion(emitOptions, diagnostics) 826784"];
6156 [label="GetRuntimeMetadataVersion(emitOptions) 826785"];
6157 [label="Assembly 826786"];
6158 [label="SourceAssembly 826787"];
6159 [label="GetBoundReferenceManager() 826788"];
6160 [label="GetBoundReferenceManager(); 826789"];
6161 [label="Debug.Assert(_lazyAssemblySymbol is object); 826790"];
6162 [label="GetBoundReferenceManager(); 826791"];
6163 [label="var corAssembly = Assembly.CorLibrary as Symbols.Metadata.PE.PEAssemblySymbol; 826792"];
6164 [label="if (corAssembly is object)\n            {\n                return corAssembly.Assembly.ManifestModule.MetadataVersion;\n            } 826793"];
6165 [label="if (runtimeMDVersion != null)\n            {\n                return runtimeMDVersion;\n            } 826794"];
6166 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 826795"];
6167 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 826796"];
6168 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 826797"];
6169 [label="SourceAssembly 826798"];
6170 [label="GetBoundReferenceManager() 826799"];
6171 [label="GetBoundReferenceManager(); 826800"];
6172 [label="SourceAssembly.IsDelaySigned 826801"];
6173 [label="Declarations 826802"];
6174 [label="_syntaxAndDeclarations.GetLazyState() 826803"];
6175 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 826804"];
6176 [label="return Declarations.GetMergedRoot(this); 826805"];
6177 [label="_syntaxAndDeclarations.GetLazyState() 826806"];
6178 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 826807"];
6179 [label="=> 0x30 826808"];
6180 [label="0x30 826809"];
6181 [label="if (manifestResources == null)\n            {\n                manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>();\n            } 826810"];
6182 [label="PEModuleBuilder moduleBeingBuilt; 826811"];
6183 [label="SourceModule 826812"];
6184 [label="GetBoundReferenceManager(); 826813"];
6185 [label="moduleBeingBuilt = new PENetModuleBuilder(\n                    (SourceModuleSymbol)SourceModule,\n                    emitOptions,\n                    moduleProps,\n                    manifestResources); 826814"];
6186 [label="moduleBeingBuilt = new PENetModuleBuilder(\n                    (SourceModuleSymbol)SourceModule,\n                    emitOptions,\n                    moduleProps,\n                    manifestResources); 826815"];
6187 [label="new PENetModuleBuilder(\n                    (SourceModuleSymbol)SourceModule,\n                    emitOptions,\n                    moduleProps,\n                    manifestResources) 826816"];
6188 [label="param PENetModuleBuilder(SourceModuleSymbol sourceModule) 826817"];
6189 [label="param PENetModuleBuilder(EmitOptions emitOptions) 826818"];
6190 [label="param PENetModuleBuilder(Cci.ModulePropertiesForSerialization serializationProperties) 826819"];
6191 [label="param PENetModuleBuilder(IEnumerable<ResourceDescription> manifestResources) 826820"];
6192 [label="param PENetModuleBuilder(this) 826821"];
6193 [label="sourceModule 826822"];
6194 [label="emitOptions 826823"];
6195 [label="OutputKind.NetModule 826824"];
6196 [label="serializationProperties 826825"];
6197 [label="manifestResources 826826"];
6198 [label="param PENetModuleBuilder(this) 826827"];
6199 [label="param PEModuleBuilder(SourceModuleSymbol sourceModule) 826828"];
6200 [label="param PEModuleBuilder(EmitOptions emitOptions) 826829"];
6201 [label="param PEModuleBuilder(OutputKind outputKind) 826830"];
6202 [label="param PEModuleBuilder(Cci.ModulePropertiesForSerialization serializationProperties) 826831"];
6203 [label="param PEModuleBuilder(IEnumerable<ResourceDescription> manifestResources) 826832"];
6204 [label="param PEModuleBuilder(this) 826833"];
6205 [label="get\n            {\n                return true;\n            } 826834"];
6206 [label="if (sourceModule.AnyReferencedAssembliesAreLinked)\n            {\n                _embeddedTypesManagerOpt = new NoPia.EmbeddedTypesManager(this);\n            } 826835"];
6207 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 826836"];
6208 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 826837"];
6209 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 826838"];
6210 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 826839"];
6211 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 826840"];
6212 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 826841"];
6213 [label="PooledHashSet<int>? excludeDiagnostics = null; 826842"];
6214 [label="if (emitMetadataOnly)\n            {\n                excludeDiagnostics = PooledHashSet<int>.GetInstance();\n                excludeDiagnostics.Add((int)ErrorCode.ERR_ConcreteMissingBody);\n            } 826843"];
6215 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 826844"];
6216 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 826845"];
6217 [label="GetDiagnostics(CompilationStage.Declare, true, cancellationToken) 826846"];
6218 [label="param GetDiagnostics(CompilationStage stage) 826847"];
6219 [label="param GetDiagnostics(bool includeEarlierStages) 826848"];
6220 [label="var diagnostics = DiagnosticBag.GetInstance(); 826849"];
6221 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 826850"];
6222 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 826851"];
6223 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 826852"];
6224 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 826853"];
6225 [label="param GetDiagnostics(CompilationStage stage) 826854"];
6226 [label="param GetDiagnostics(bool includeEarlierStages) 826855"];
6227 [label="param GetDiagnostics(DiagnosticBag diagnostics) 826856"];
6228 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 826857"];
6229 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 826858"];
6230 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 826859"];
6231 [label="this.SyntaxTrees 826860"];
6232 [label="_syntaxAndDeclarations.GetLazyState() 826861"];
6233 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 826862"];
6234 [label="this.Options 826863"];
6235 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 826864"];
6236 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 826865"];
6237 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 826866"];
6238 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 826867"];
6239 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 826868"];
6240 [label="CheckAssemblyName(builder); 826869"];
6241 [label="CheckAssemblyName(builder); 826870"];
6242 [label="Options 826871"];
6243 [label="Options 826872"];
6244 [label="get\n            {\n                return _options;\n            } 826873"];
6245 [label="return _options; 826874"];
6246 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 826875"];
6247 [label="GetBoundReferenceManager() 826876"];
6248 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 826877"];
6249 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 826878"];
6250 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 826879"];
6251 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 826880"];
6252 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 826881"];
6253 [label="GlobalImports 826882"];
6254 [label="_globalImports.Value 826883"];
6255 [label="Imports.FromGlobalUsings(this) 826884"];
6256 [label="SourceLocation? location = null; 826885"];
6257 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 826886"];
6258 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 826887"];
6259 [label="Assembly 826888"];
6260 [label="SourceAssembly 826889"];
6261 [label="GetBoundReferenceManager() 826890"];
6262 [label="GetBoundReferenceManager(); 826891"];
6263 [label="Assembly.ForceComplete(location, cancellationToken); 826892"];
6264 [label="Assembly.ForceComplete(location, cancellationToken); 826893"];
6265 [label="Declarations 826894"];
6266 [label="_syntaxAndDeclarations.GetLazyState() 826895"];
6267 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 826896"];
6268 [label="return Declarations.GetMergedRoot(this); 826897"];
6269 [label="_syntaxAndDeclarations.GetLazyState() 826898"];
6270 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 826899"];
6271 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 826900"];
6272 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 826901"];
6273 [label="param SymbolDeclaredEvent(Symbol symbol) 826902"];
6274 [label="param SymbolDeclaredEvent(this) 826903"];
6275 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 826904"];
6276 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 826905"];
6277 [label="GetBinderFactory(syntax.SyntaxTree) 826906"];
6278 [label="param GetBinderFactory(bool ignoreAccessibility = false) 826907"];
6279 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 826908"];
6280 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 826909"];
6281 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 826910"];
6282 [label="param GetBinderFactory(bool ignoreAccessibility) 826911"];
6283 [label="ignoreAccessibility 826912"];
6284 [label="GetSyntaxTreeOrdinal(syntaxTree) 826913"];
6285 [label="this.ContainsSyntaxTree(tree) 826914"];
6286 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 826915"];
6287 [label="_syntaxAndDeclarations.GetLazyState() 826916"];
6288 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 826917"];
6289 [label="_syntaxAndDeclarations.GetLazyState() 826918"];
6290 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 826919"];
6291 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 826920"];
6292 [label="BinderFactory? previousFactory; 826921"];
6293 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 826922"];
6294 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 826923"];
6295 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 826924"];
6296 [label="param AddNewFactory(bool ignoreAccessibility) 826925"];
6297 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 826926"];
6298 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 826927"];
6299 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 826928"];
6300 [label="BinderFactory? previousFactory; 826929"];
6301 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 826930"];
6302 [label="GetBoundReferenceManager(); 826931"];
6303 [label="Assembly 826932"];
6304 [label="SourceAssembly 826933"];
6305 [label="GetBoundReferenceManager() 826934"];
6306 [label="GetBoundReferenceManager(); 826935"];
6307 [label="return Assembly.Modules[0]; 826936"];
6308 [label="IsNullableAnalysisEnabledIn((CSharpSyntaxTree)syntax.SyntaxTree, syntax.Span) 826937"];
6309 [label="GetNullableAnalysisValue() 826938"];
6310 [label="return Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            }; 826939"];
6311 [label="Options 826940"];
6312 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 826941"];
6313 [label="param GetBinderFactory(bool ignoreAccessibility = false) 826942"];
6314 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 826943"];
6315 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 826944"];
6316 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 826945"];
6317 [label="param GetBinderFactory(bool ignoreAccessibility) 826946"];
6318 [label="ignoreAccessibility 826947"];
6319 [label="GetSyntaxTreeOrdinal(syntaxTree) 826948"];
6320 [label="this.ContainsSyntaxTree(tree) 826949"];
6321 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 826950"];
6322 [label="_syntaxAndDeclarations.GetLazyState() 826951"];
6323 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 826952"];
6324 [label="_syntaxAndDeclarations.GetLazyState() 826953"];
6325 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 826954"];
6326 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 826955"];
6327 [label="BinderFactory? previousFactory; 826956"];
6328 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 826957"];
6329 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 826958"];
6330 [label="compilation.SyntaxTrees 826959"];
6331 [label="_syntaxAndDeclarations.GetLazyState() 826960"];
6332 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 826961"];
6333 [label="return ((CSharpParseOptions)compilation.SyntaxTrees.FirstOrDefault()?.Options)?.IsFeatureEnabled(feature) == true; 826962"];
6334 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 826963"];
6335 [label="NamedTypeSymbol result; 826964"];
6336 [label="Debug.Assert(result.SpecialType == specialType); 826965"];
6337 [label="Assembly 826966"];
6338 [label="SourceAssembly 826967"];
6339 [label="GetBoundReferenceManager() 826968"];
6340 [label="GetBoundReferenceManager(); 826969"];
6341 [label="return Assembly.Modules[0]; 826970"];
6342 [label="Debug.Assert(symbol.IsDefinition); 826971"];
6343 [label="SourceModule 826972"];
6344 [label="Assembly 826973"];
6345 [label="SourceAssembly 826974"];
6346 [label="GetBoundReferenceManager() 826975"];
6347 [label="GetBoundReferenceManager(); 826976"];
6348 [label="return Assembly.Modules[0]; 826977"];
6349 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 826978"];
6350 [label="EmitNullablePublicOnly 826979"];
6351 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 826980"];
6352 [label="_declarationDiagnosticsFrozen = true; 826981"];
6353 [label="_needsGeneratedAttributes_IsFrozen = true; 826982"];
6354 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 826983"];
6355 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 826984"];
6356 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 826985"];
6357 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 826986"];
6358 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 826987"];
6359 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 826988"];
6360 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 826989"];
6361 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 826990"];
6362 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 826991"];
6363 [label="param CheckCompliance(DiagnosticBag diagnostics) 826992"];
6364 [label="System.Diagnostics.Debug.Assert(symbol is SourceAssemblySymbol); 826993"];
6365 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 826994"];
6366 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 826995"];
6367 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 826996"];
6368 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 826997"];
6369 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 826998"];
6370 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 826999"];
6371 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 827000"];
6372 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 827001"];
6373 [label="param GetDeclaredCompliance(out Location attributeLocation) 827002"];
6374 [label="param GetDeclaredCompliance(this) 827003"];
6375 [label="attributeLocation = null; 827004"];
6376 [label="if (assemblyCompliance == Compliance.DeclaredFalse)\n            {\n                // Our interpretation of an assembly-level CLSCompliant attribute is as follows:\n                //   1) If true, then perform all CLS checks.\n                //   2) If false, then perform no CLS checks (dev11 still performs a few, mostly around\n                //      meaningless attributes).  Our interpretation is that the user ultimately wants\n                //      his code to be CLS-compliant, but is temporarily disabling the checks (e.g. during\n                //      refactoring/prototyping).\n                //   3) If absent, the perform all CLS checks.  Our interpretation is that - in the\n                //      absence of an assembly-level attribute - any CLS problems within the compilation\n                //      indicate that the user was trying to do something but didn't know how.  It would\n                //      be nice if the most common case (i.e. this one) was the cheapest, but we don't\n                //      want to confuse novice users.\n                return;\n            } 827005"];
6377 [label="bool assemblyComplianceValue = IsTrue(assemblyCompliance); 827006"];
6378 [label="IsTrue(assemblyCompliance) 827007"];
6379 [label="param IsTrue(Compliance compliance) 827008"];
6380 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 827009"];
6381 [label="return false; 827010"];
6382 [label="Location attributeLocation; 827011"];
6383 [label="param GetDeclaredCompliance(out Location attributeLocation) 827012"];
6384 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 827013"];
6385 [label="i == 0 827014"];
6386 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 827015"];
6387 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 827016"];
6388 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 827017"];
6389 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 827018"];
6390 [label="if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 827019"];
6391 [label="if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 827020"];
6392 [label="if (assemblyComplianceValue)\n            {\n                CheckForAttributeWithArrayArgument(symbol);\n            } 827021"];
6393 [label="System.Diagnostics.Debug.Assert(symbol.Kind != SymbolKind.Assembly); 827022"];
6394 [label="System.Diagnostics.Debug.Assert((object)containing != null); 827023"];
6395 [label="return compliance; 827024"];
6396 [label="IsTrue(GetInheritedCompliance(symbol)) 827025"];
6397 [label="param IsTrue(Compliance compliance) 827026"];
6398 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 827027"];
6399 [label="return false; 827028"];
6400 [label="IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)) 827029"];
6401 [label="param IsTrue(Compliance compliance) 827030"];
6402 [label="if (DoNotVisit(symbol)) return; 827031"];
6403 [label="DoNotVisit(symbol) 827032"];
6404 [label="param DoNotVisit(Symbol symbol) 827033"];
6405 [label="param DoNotVisit(this) 827034"];
6406 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                return false;\n            } 827035"];
6407 [label="return false; 827036"];
6408 [label="IsTrue(GetDeclaredOrInheritedCompliance(symbol)) 827037"];
6409 [label="param IsTrue(Compliance compliance) 827038"];
6410 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 827039"];
6411 [label="return false; 827040"];
6412 [label="if (tasks == null)\n            {\n                return;\n            } 827041"];
6413 [label="checker.WaitForWorkers(); 827042"];
6414 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 827043"];
6415 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 827044"];
6416 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 827045"];
6417 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 827046"];
6418 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 827047"];
6419 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 827048"];
6420 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 827049"];
6421 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 827050"];
6422 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 827051"];
6423 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 827052"];
6424 [label="excludeDiagnostics?.Free(); 827053"];
6425 [label="param AddDebugSourceDocumentsForChecksumDirectives(DebugDocumentsBuilder documentsBuilder) 827054"];
6426 [label="param AddDebugSourceDocumentsForChecksumDirectives(DiagnosticBag diagnostics) 827055"];
6427 [label="param AddDebugSourceDocumentsForChecksumDirectives(this) 827056"];
6428 [label="foreach (var directive in checksumDirectives)\n            {\n                var checksumDirective = (PragmaChecksumDirectiveTriviaSyntax)directive;\n                var path = checksumDirective.File.ValueText;\n\n                var checksumText = checksumDirective.Bytes.ValueText;\n                var normalizedPath = documentsBuilder.NormalizeDebugDocumentPath(path, basePath: tree.FilePath);\n                var existingDoc = documentsBuilder.TryGetDebugDocumentForNormalizedPath(normalizedPath);\n\n                // duplicate checksum pragmas are valid as long as values match\n                // if we have seen this document already, check for matching values.\n                if (existingDoc != null)\n                {\n                    // pragma matches a file path on an actual tree.\n                    // Dev12 compiler just ignores the pragma in this case which means that\n                    // checksum of the actual tree always wins and no warning is given.\n                    // We will continue doing the same.\n                    if (existingDoc.IsComputedChecksum)\n                    {\n                        continue;\n                    }\n\n                    var sourceInfo = existingDoc.GetSourceInfo();\n                    if (ChecksumMatches(checksumText, sourceInfo.Checksum))\n                    {\n                        var guid = Guid.Parse(checksumDirective.Guid.ValueText);\n                        if (guid == sourceInfo.ChecksumAlgorithmId)\n                        {\n                            // all parts match, nothing to do\n                            continue;\n                        }\n                    }\n\n                    // did not match to an existing document\n                    // produce a warning and ignore the pragma\n                    diagnostics.Add(ErrorCode.WRN_ConflictingChecksum, new SourceLocation(checksumDirective), path);\n                }\n                else\n                {\n                    var newDocument = new Cci.DebugSourceDocument(\n                        normalizedPath,\n                        Cci.DebugSourceDocument.CorSymLanguageTypeCSharp,\n                        MakeChecksumBytes(checksumText),\n                        Guid.Parse(checksumDirective.Guid.ValueText));\n\n                    documentsBuilder.AddDebugDocument(newDocument);\n                }\n            } 827057"];
6429 [label="Debug.Assert(compilation != null); 827058"];
6430 [label="Debug.Assert(diagnostics != null); 827059"];
6431 [label="compilation.PreviousSubmission 827060"];
6432 [label="ScriptCompilationInfo 827061"];
6433 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 827062"];
6434 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 827063"];
6435 [label="MethodSymbol entryPoint = null; 827064"];
6436 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 827065"];
6437 [label="param GetEntryPoint(bool hasDeclarationErrors) 827066"];
6438 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 827067"];
6439 [label="EntryPoint? entryPoint; 827068"];
6440 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 827069"];
6441 [label="Debug.Assert(compilation != null); 827070"];
6442 [label="Debug.Assert(diagnostics != null); 827071"];
6443 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 827072"];
6444 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 827073"];
6445 [label="param SetGlobalErrorIfTrue(bool arg) 827074"];
6446 [label="param SetGlobalErrorIfTrue(this) 827075"];
6447 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 827076"];
6448 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 827077"];
6449 [label="GetBoundReferenceManager(); 827078"];
6450 [label="param VisitNamedType(TypeCompilationState arg) 827079"];
6451 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 827080"];
6452 [label="PassesFilter(_filterOpt, symbol) 827081"];
6453 [label="param PassesFilter(Predicate<Symbol> filterOpt) 827082"];
6454 [label="param PassesFilter(Symbol symbol) 827083"];
6455 [label="return (filterOpt == null) || filterOpt(symbol); 827084"];
6456 [label="return (filterOpt == null) || filterOpt(symbol); 827085"];
6457 [label="arg = null; 827086"];
6458 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 827087"];
6459 [label="if (tasks == null)\n            {\n                return;\n            } 827088"];
6460 [label="if (tasks == null)\n            {\n                return;\n            } 827089"];
6461 [label="methodCompiler.WaitForWorkers(); 827090"];
6462 [label="var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics); 827091"];
6463 [label="var additionalTypes = moduleBeingBuiltOpt.GetAdditionalTopLevelTypes(diagnostics); 827092"];
6464 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 827093"];
6465 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 827094"];
6466 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics) 827095"];
6467 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 827096"];
6468 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 827097"];
6469 [label="param CompileSynthesizedMethods(this) 827098"];
6470 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 827099"];
6471 [label="var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics); 827100"];
6472 [label="var embeddedTypes = moduleBeingBuiltOpt.GetEmbeddedTypes(diagnostics); 827101"];
6473 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 827102"];
6474 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 827103"];
6475 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics) 827104"];
6476 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 827105"];
6477 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 827106"];
6478 [label="param CompileSynthesizedMethods(this) 827107"];
6479 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 827108"];
6480 [label="param GetPreviousAnonymousTypes(this) 827109"];
6481 [label="get { return _metadataName; } 827110"];
6482 [label="return _metadataName; 827111"];
6483 [label="param GetNextAnonymousTypeIndex(this) 827112"];
6484 [label="if (tasks == null)\n            {\n                return;\n            } 827113"];
6485 [label="methodCompiler.WaitForWorkers(); 827114"];
6486 [label="var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass; 827115"];
6487 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 827116"];
6488 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 827117"];
6489 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 827118"];
6490 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 827119"];
6491 [label="GetBoundReferenceManager(); 827120"];
6492 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 827121"];
6493 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 827122"];
6494 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 827123"];
6495 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag) 827124"];
6496 [label="param GenerateModuleInitializer(PEModuleBuilder moduleBeingBuilt) 827125"];
6497 [label="param GenerateModuleInitializer(DiagnosticBag methodBodyDiagnosticBag) 827126"];
6498 [label="param GenerateModuleInitializer(this) 827127"];
6499 [label="Debug.Assert(_declarationDiagnosticsFrozen); 827128"];
6500 [label="if (_moduleInitializerMethods is object)\n            {\n                var ilBuilder = new ILBuilder(moduleBeingBuilt, new LocalSlotManager(slotAllocator: null), OptimizationLevel.Release, areLocalsZeroed: false);\n\n                foreach (MethodSymbol method in _moduleInitializerMethods.OrderBy<MethodSymbol>(LexicalOrderSymbolComparer.Instance))\n                {\n                    ilBuilder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n\n                    ilBuilder.EmitToken(\n                        moduleBeingBuilt.Translate(method, methodBodyDiagnosticBag, needDeclaration: true),\n                        CSharpSyntaxTree.Dummy.GetRoot(),\n                        methodBodyDiagnosticBag);\n                }\n\n                ilBuilder.EmitRet(isVoid: true);\n                ilBuilder.Realize();\n                moduleBeingBuilt.RootModuleType.SetStaticConstructorBody(ilBuilder.RealizedIL);\n            } 827129"];
6501 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 827130"];
6502 [label="if (hasDeclarationErrors || hasMethodBodyError)\n                {\n                    return false;\n                } 827131"];
6503 [label="return true; 827132"];
6504 [label="DiagnosticBag? resourceDiagnostics = DiagnosticBag.GetInstance(); 827133"];
6505 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 827134"];
6506 [label="SourceAssembly 827135"];
6507 [label="GetBoundReferenceManager() 827136"];
6508 [label="GetBoundReferenceManager(); 827137"];
6509 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 827138"];
6510 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 827139"];
6511 [label="AddedModulesResourceNames(resourceDiagnostics) 827140"];
6512 [label="param AddedModulesResourceNames(DiagnosticBag diagnostics) 827141"];
6513 [label="SourceAssembly 827142"];
6514 [label="GetBoundReferenceManager() 827143"];
6515 [label="GetBoundReferenceManager(); 827144"];
6516 [label="ImmutableArray<ModuleSymbol> modules = SourceAssembly.Modules; 827145"];
6517 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 827146"];
6518 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 827147"];
6519 [label="param AddedModulesResourceNames(this) 827148"];
6520 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 827149"];
6521 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 827150"];
6522 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 827151"];
6523 [label="DiagnosticBag? xmlDiagnostics = DiagnosticBag.GetInstance(); 827152"];
6524 [label="string? assemblyName = FileNameUtilities.ChangeExtension(outputNameOverride, extension: null); 827153"];
6525 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 827154"];
6526 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 827155"];
6527 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken) 827156"];
6528 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 827157"];
6529 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 827158"];
6530 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 827159"];
6531 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 827160"];
6532 [label="StreamWriter writer = null; 827161"];
6533 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 827162"];
6534 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 827163"];
6535 [label="compilation.SourceAssembly 827164"];
6536 [label="GetBoundReferenceManager() 827165"];
6537 [label="GetBoundReferenceManager(); 827166"];
6538 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 827167"];
6539 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 827168"];
6540 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 827169"];
6541 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 827170"];
6542 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 827171"];
6543 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 827172"];
6544 [label="param DocumentationCommentCompiler(TextWriter writer) 827173"];
6545 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 827174"];
6546 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 827175"];
6547 [label="param DocumentationCommentCompiler(bool processIncludes) 827176"];
6548 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 827177"];
6549 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 827178"];
6550 [label="param DocumentationCommentCompiler(this) 827179"];
6551 [label="param DocumentationCommentCompiler(this) 827180"];
6552 [label="_assemblyName 827181"];
6553 [label="_compilation 827182"];
6554 [label="_writer 827183"];
6555 [label="_filterTree 827184"];
6556 [label="_filterSpanWithinTree 827185"];
6557 [label="_processIncludes 827186"];
6558 [label="_isForSingleSymbol 827187"];
6559 [label="_diagnostics 827188"];
6560 [label="_lazyComparer 827189"];
6561 [label="_includedFileCache 827190"];
6562 [label="_indentDepth 827191"];
6563 [label="_temporaryStringBuilders 827192"];
6564 [label="_writer 827193"];
6565 [label="_filterTree 827194"];
6566 [label="_filterSpanWithinTree 827195"];
6567 [label="_processIncludes 827196"];
6568 [label="_isForSingleSymbol 827197"];
6569 [label="_diagnostics 827198"];
6570 [label="compilation.SourceAssembly 827199"];
6571 [label="GetBoundReferenceManager() 827200"];
6572 [label="GetBoundReferenceManager(); 827201"];
6573 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 827202"];
6574 [label="Debug.Assert(_assemblyName != null); 827203"];
6575 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 827204"];
6576 [label="WriteLine('<?xml version=\\'1.0\\'?>') 827205"];
6577 [label="param WriteLine(string message) 827206"];
6578 [label="param WriteLine(this) 827207"];
6579 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827208"];
6580 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827209"];
6581 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827210"];
6582 [label="WriteLine('<doc>'); 827211"];
6583 [label="WriteLine('<doc>') 827212"];
6584 [label="param WriteLine(string message) 827213"];
6585 [label="param WriteLine(this) 827214"];
6586 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827215"];
6587 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827216"];
6588 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827217"];
6589 [label="Indent(); 827218"];
6590 [label="WriteLine('<members>'); 827219"];
6591 [label="WriteLine('<members>') 827220"];
6592 [label="param WriteLine(string message) 827221"];
6593 [label="param WriteLine(this) 827222"];
6594 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827223"];
6595 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827224"];
6596 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827225"];
6597 [label="Indent(); 827226"];
6598 [label="Debug.Assert(!_isForSingleSymbol); 827227"];
6599 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 827228"];
6600 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 827229"];
6601 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 827230"];
6602 [label="ImmutableArray<DocumentationCommentTriviaSyntax> docCommentNodes; 827231"];
6603 [label="docCommentNodes 827232"];
6604 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 827233"];
6605 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 827234"];
6606 [label="maxDocumentationMode = DocumentationMode.None; 827235"];
6607 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 827236"];
6608 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 827237"];
6609 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 827238"];
6610 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 827239"];
6611 [label="currDocumentationMode > maxDocumentationMode 827240"];
6612 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 827241"];
6613 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 827242"];
6614 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 827243"];
6615 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 827244"];
6616 [label="return true; 827245"];
6617 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 827246"];
6618 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 827247"];
6619 [label="return; 827248"];
6620 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 827249"];
6621 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 827250"];
6622 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 827251"];
6623 [label="currDocumentationMode > maxDocumentationMode 827252"];
6624 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 827253"];
6625 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 827254"];
6626 [label="Debug.Assert(_indentDepth >= 0); 827255"];
6627 [label="Unindent(); 827256"];
6628 [label="WriteLine('</members>'); 827257"];
6629 [label="WriteLine('</members>') 827258"];
6630 [label="param WriteLine(string message) 827259"];
6631 [label="param WriteLine(this) 827260"];
6632 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827261"];
6633 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827262"];
6634 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827263"];
6635 [label="Unindent(); 827264"];
6636 [label="WriteLine('</doc>'); 827265"];
6637 [label="WriteLine('</doc>') 827266"];
6638 [label="param WriteLine(string message) 827267"];
6639 [label="param WriteLine(this) 827268"];
6640 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827269"];
6641 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827270"];
6642 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 827271"];
6643 [label="Debug.Assert(compiler._indentDepth == 0); 827272"];
6644 [label="Debug.Assert(compiler._indentDepth == 0); 827273"];
6645 [label="writer?.Flush(); 827274"];
6646 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 827275"];
6647 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 827276"];
6648 [label="compilation.SyntaxTrees 827277"];
6649 [label="_syntaxAndDeclarations.GetLazyState() 827278"];
6650 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 827279"];
6651 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 827280"];
6652 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 827281"];
6653 [label="param ReportUnprocessed(CancellationToken cancellationToken) 827282"];
6654 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 827283"];
6655 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 827284"];
6656 [label="param ReportUnusedImports(SyntaxTree? filterTree) 827285"];
6657 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 827286"];
6658 [label="param ReportUnusedImports(CancellationToken cancellationToken) 827287"];
6659 [label="param ReportUnusedImports(this) 827288"];
6660 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 827289"];
6661 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 827290"];
6662 [label="CompleteTrees(filterTree); 827291"];
6663 [label="CompleteTrees(filterTree) 827292"];
6664 [label="param CompleteTrees(SyntaxTree? filterTree) 827293"];
6665 [label="param CompleteTrees(this) 827294"];
6666 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 827295"];
6667 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 827296"];
6668 [label="CompleteTrees(filterTree); 827297"];
6669 [label="this.SourceModule 827298"];
6670 [label="Assembly 827299"];
6671 [label="SourceAssembly 827300"];
6672 [label="GetBoundReferenceManager() 827301"];
6673 [label="GetBoundReferenceManager(); 827302"];
6674 [label="return Assembly.Modules[0]; 827303"];
6675 [label="SourceAssembly 827304"];
6676 [label="GetBoundReferenceManager() 827305"];
6677 [label="GetBoundReferenceManager(); 827306"];
6678 [label="SourceAssembly.IsDelaySigned 827307"];
6679 [label="param GetCorLibraryReferenceToEmit(CodeAnalysis.Emit.EmitContext context) 827308"];
6680 [label="param GetCorLibraryReferenceToEmit(this) 827309"];
6681 [label="CorLibrary 827310"];
6682 [label="get { return SourceModule.ContainingSourceAssembly.CorLibrary; } 827311"];
6683 [label="return SourceModule.ContainingSourceAssembly.CorLibrary; 827312"];
6684 [label="AssemblySymbol corLibrary = CorLibrary; 827313"];
6685 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 827314"];
6686 [label="return null; 827315"];
6687 [label="param GetFiles(EmitContext context) 827316"];
6688 [label="=> SpecializedCollections.EmptyEnumerable<Cci.IFileReference>() 827317"];
6689 [label="SpecializedCollections.EmptyEnumerable<Cci.IFileReference>() 827318"];
6690 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 827319"];
6691 [label="param GetAnonymousTypeDefinitions(EmitContext context) 827320"];
6692 [label="if (context.MetadataOnly)\n            {\n                return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>();\n            } 827321"];
6693 [label="Compilation.AnonymousTypeManager 827322"];
6694 [label="return Compilation.AnonymousTypeManager.GetAllCreatedTemplates()\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n\n#endif\n                   ; 827323"];
6695 [label="param GetAdditionalTopLevelTypeDefinitions(EmitContext context) 827324"];
6696 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 827325"];
6697 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 827326"];
6698 [label="param GetEmbeddedTypeDefinitions(EmitContext context) 827327"];
6699 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 827328"];
6700 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 827329"];
6701 [label="param GetTopLevelSourceTypeDefinitions(EmitContext context) 827330"];
6702 [label="var namespacesToProcess = new Stack<NamespaceSymbol>(); 827331"];
6703 [label="while (namespacesToProcess.Count > 0)\n            {\n                var ns = namespacesToProcess.Pop();\n                foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                }\n            } 827332"];
6704 [label="Debug.Assert(symbol.IsDefinition); 827333"];
6705 [label="SourceModule 827334"];
6706 [label="Assembly 827335"];
6707 [label="SourceAssembly 827336"];
6708 [label="GetBoundReferenceManager() 827337"];
6709 [label="GetBoundReferenceManager(); 827338"];
6710 [label="return Assembly.Modules[0]; 827339"];
6711 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 827340"];
6712 [label="EmitNullablePublicOnly 827341"];
6713 [label="param SynthesizeNullableAttributeIfNecessary(Symbol symbol) 827342"];
6714 [label="Compilation.SourceModule 827343"];
6715 [label="Assembly 827344"];
6716 [label="SourceAssembly 827345"];
6717 [label="GetBoundReferenceManager() 827346"];
6718 [label="GetBoundReferenceManager(); 827347"];
6719 [label="return Assembly.Modules[0]; 827348"];
6720 [label="if ((object)Compilation.SourceModule != symbol.ContainingModule)\n            {\n                // For symbols that are not defined in the same compilation (like NoPia), don't synthesize this attribute.\n                return null;\n            } 827349"];
6721 [label="if ((object)Compilation.SourceModule != symbol.ContainingModule)\n            {\n                // For symbols that are not defined in the same compilation (like NoPia), don't synthesize this attribute.\n                return null;\n            } 827350"];
6722 [label="var flagsBuilder = ArrayBuilder<byte>.GetInstance(); 827351"];
6723 [label="type.AddNullableTransforms(flagsBuilder); 827352"];
6724 [label="SynthesizedAttributeData attribute; 827353"];
6725 [label="param SynthesizeNullableAttributeIfNecessary(this) 827354"];
6726 [label="param GetSynthesizedNestedTypes(NamedTypeSymbol container) 827355"];
6727 [label="param GetSynthesizedNestedTypes(this) 827356"];
6728 [label="return null; 827357"];
6729 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 827358"];
6730 [label="return SourceModule.ContainingSourceAssembly.GetSecurityAttributes(); 827359"];
6731 [label="return SourceModule.ContainingSourceAssembly.CorLibrary; 827360"];
6732 [label="AssemblySymbol corLibrary = CorLibrary; 827361"];
6733 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 827362"];
6734 [label="return SourceModule.GetCustomAttributesToEmit(this); 827363"];
6735 [label="if (context.MetadataOnly)\n            {\n                return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>();\n            } 827364"];
6736 [label="param Translate(SyntaxNode syntaxNodeOpt) 827365"];
6737 [label="param Translate(DiagnosticBag diagnostics) 827366"];
6738 [label="Debug.Assert(diagnostics != null); 827367"];
6739 [label="Debug.Assert(diagnostics != null); 827368"];
6740 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 827369"];
6741 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 827370"];
6742 [label="param Translate(SyntaxNode syntaxNodeOpt) 827371"];
6743 [label="param Translate(DiagnosticBag diagnostics) 827372"];
6744 [label="param Translate(bool fromImplements = false) 827373"];
6745 [label="param Translate(bool needDeclaration = false) 827374"];
6746 [label="Debug.Assert(diagnostics != null); 827375"];
6747 [label="Debug.Assert(diagnostics != null); 827376"];
6748 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 827377"];
6749 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 827378"];
6750 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 827379"];
6751 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 827380"];
6752 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 827381"];
6753 [label="object reference; 827382"];
6754 [label="Cci.INamedTypeReference typeRef; 827383"];
6755 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 827384"];
6756 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 827385"];
6757 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 827386"];
6758 [label="IsGenericType(container) 827387"];
6759 [label="param IsGenericType(NamedTypeSymbol toCheck) 827388"];
6760 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 827389"];
6761 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 827390"];
6762 [label="return false; 827391"];
6763 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 827392"];
6764 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 827393"];
6765 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 827394"];
6766 [label="param Translate(DiagnosticBag diagnostics) 827395"];
6767 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 827396"];
6768 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 827397"];
6769 [label="if ((object)module == null)\n            {\n                return null;\n            } 827398"];
6770 [label="if ((object)module == null)\n            {\n                return null;\n            } 827399"];
6771 [label="Cci.IModuleReference moduleRef; 827400"];
6772 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(module, out moduleRef))\n            {\n                return moduleRef;\n            } 827401"];
6773 [label="TranslateModule(module, diagnostics) 827402"];
6774 [label="param TranslateModule(DiagnosticBag diagnostics) 827403"];
6775 [label="if ((object)container != null && ReferenceEquals(container.Modules[0], module))\n            {\n                Cci.IModuleReference moduleRef = new AssemblyReference(container);\n                Cci.IModuleReference cachedModuleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(container, moduleRef);\n\n                if (cachedModuleRef == moduleRef)\n                {\n                    ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics);\n                }\n                else\n                {\n                    moduleRef = cachedModuleRef;\n                }\n\n                return moduleRef;\n            }\n            else\n            {\n                return new ModuleReference(this, module);\n            } 827404"];
6776 [label="_targetAssembly 827405"];
6777 [label="Debug.Assert((object)assemblySymbol != null); 827406"];
6778 [label="ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics); 827407"];
6779 [label="param ValidateReferencedAssembly(AssemblyReference asmRef) 827408"];
6780 [label="param ValidateReferencedAssembly(DiagnosticBag diagnostics) 827409"];
6781 [label="param ValidateReferencedAssembly(this) 827410"];
6782 [label="AssemblyIdentity asmIdentity = SourceModule.ContainingAssembly.Identity; 827411"];
6783 [label="asmRef.Identity 827412"];
6784 [label="=> _targetAssembly.Identity 827413"];
6785 [label="AssemblyIdentity refIdentity = asmRef.Identity; 827414"];
6786 [label="if (asmIdentity.IsStrongName && !refIdentity.IsStrongName &&\n                asmRef.Identity.ContentType != AssemblyContentType.WindowsRuntime)\n            {\n                // Dev12 reported error, we have changed it to a warning to allow referencing libraries \n                // built for platforms that don't support strong names.\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName, assembly), NoLocation.Singleton);\n            } 827415"];
6787 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 827416"];
6788 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 827417"];
6789 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 827418"];
6790 [label="param GetExportedTypes(DiagnosticBag diagnostics) 827419"];
6791 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 827420"];
6792 [label="if (!OutputKind.IsNetModule())\n            {\n                var modules = sourceAssembly.Modules;\n                for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                }\n            } 827421"];
6793 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 827422"];
6794 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 827423"];
6795 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder) 827424"];
6796 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 827425"];
6797 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 827426"];
6798 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 827427"];
6799 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 827428"];
6800 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 827429"];
6801 [label="return seenTopLevelForwardedTypes; 827430"];
6802 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 827431"];
6803 [label="=> ImmutableArray<Cci.UsedNamespaceOrType>.Empty 827432"];
6804 [label="ImmutableArray<Cci.UsedNamespaceOrType>.Empty 827433"];
6805 [label="=> null 827434"];
6806 [label="null 827435"];
6807 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 827436"];
6808 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 827437"];
6809 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 827438"];
6810 [label="param Translate(SyntaxNode syntaxNodeOpt) 827439"];
6811 [label="param Translate(DiagnosticBag diagnostics) 827440"];
6812 [label="param Translate(bool fromImplements = false) 827441"];
6813 [label="param Translate(bool needDeclaration = false) 827442"];
6814 [label="Debug.Assert(diagnostics != null); 827443"];
6815 [label="Debug.Assert(diagnostics != null); 827444"];
6816 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 827445"];
6817 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 827446"];
6818 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 827447"];
6819 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 827448"];
6820 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 827449"];
6821 [label="object reference; 827450"];
6822 [label="Cci.INamedTypeReference typeRef; 827451"];
6823 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 827452"];
6824 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 827453"];
6825 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 827454"];
6826 [label="IsGenericType(container) 827455"];
6827 [label="param IsGenericType(NamedTypeSymbol toCheck) 827456"];
6828 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 827457"];
6829 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 827458"];
6830 [label="return false; 827459"];
6831 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 827460"];
6832 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 827461"];
6833 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 827462"];
6834 [label="param IsPlatformType(this) 827463"];
6835 [label="if ((object)namedType != null)\n            {\n                if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                }\n\n                return namedType.SpecialType == (SpecialType)platformType;\n            } 827464"];
6836 [label="if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                } 827465"];
6837 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 827466"];
6838 [label="Debug.Assert(symbol.IsDefinition); 827467"];
6839 [label="GetBoundReferenceManager(); 827468"];
6840 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 827469"];
6841 [label="var result = new MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation>(); 827470"];
6842 [label="var namespacesAndTypesToProcess = new Stack<NamespaceOrTypeSymbol>(); 827471"];
6843 [label="Location location = null; 827472"];
6844 [label="while (namespacesAndTypesToProcess.Count > 0)\n            {\n                NamespaceOrTypeSymbol symbol = namespacesAndTypesToProcess.Pop();\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Namespace:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n\n                        // filtering out synthesized symbols not having real source \n                        // locations such as anonymous types, etc...\n                        if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    case SymbolKind.NamedType:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n                        if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n                }\n            } 827473"];
6845 [label="param GetSmallestSourceLocationOrNull(this) 827474"];
6846 [label="CSharpCompilation compilation = symbol.DeclaringCompilation; 827475"];
6847 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 827476"];
6848 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 827477"];
6849 [label="param AddSymbolLocation(MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation> result) 827478"];
6850 [label="param AddSymbolLocation(Cci.IDefinition definition) 827479"];
6851 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 827480"];
6852 [label="param GetSmallestSourceLocationOrNull(this) 827481"];
6853 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 827482"];
6854 [label="return result; 827483"];
6855 [label="SourceAssembly 827484"];
6856 [label="GetBoundReferenceManager() 827485"];
6857 [label="GetBoundReferenceManager(); 827486"];
6858 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 827487"];
6859 [label="c.GetEmitDiagnostics(options: options).Verify(expected) 827488"];
6860 [label="param Verify(params DiagnosticDescription[] expected) 827489"];
6861 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 827490"];
6862 [label="Verify((IEnumerable<Diagnostic>)actual, expected) 827491"];
6863 [label="param Verify(params DiagnosticDescription[] expected) 827492"];
6864 [label="Verify(actual, expected, errorCodeOnly: false); 827493"];
6865 [label="Verify(actual, expected, errorCodeOnly: false); 827494"];
6866 [label="Verify(actual, expected, errorCodeOnly: false) 827495"];
6867 [label="param Verify(DiagnosticDescription[] expected) 827496"];
6868 [label="param Verify(bool errorCodeOnly) 827497"];
6869 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 827498"];
6870 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 827499"];
6871 [label="var includeDefaultSeverity = expected.Any() && expected.All(e => e.DefaultSeverity != null); 827500"];
6872 [label="var includeEffectiveSeverity = expected.Any() && expected.All(e => e.EffectiveSeverity != null); 827501"];
6873 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 827502"];
6874 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 827503"];
6875 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 827504"];
6876 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 827505"];
6877 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 827506"];
6878 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 827507"];
6879 [label="DiagnosticDescription.GetAssertText(expected, actual) 827508"];
6880 [label="param GetAssertText(DiagnosticDescription[] expected) 827509"];
6881 [label="const int CSharp = 1; 827510"];
6882 [label="const int VisualBasic = 2; 827511"];
6883 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 827512"];
6884 [label="actual.Any() && actual.First() is CSDiagnostic 827513"];
6885 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 827514"];
6886 [label="var includeDiagnosticMessagesAsComments = (language == CSharp); 827515"];
6887 [label="int indentDepth = (language == CSharp) ? 4 : 1; 827516"];
6888 [label="(language == CSharp) 827517"];
6889 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 827518"];
6890 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 827519"];
6891 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 827520"];
6892 [label="IsSortedOrEmpty(expected) 827521"];
6893 [label="param IsSortedOrEmpty(DiagnosticDescription[] diagnostics) 827522"];
6894 [label="var comparer = LinePositionComparer.Instance; 827523"];
6895 [label="DiagnosticDescription last = null; 827524"];
6896 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 827525"];
6897 [label="return true; 827526"];
6898 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 827527"];
6899 [label="Sort(actual) 827528"];
6900 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 827529"];
6901 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 827530"];
6902 [label="var assertText = new StringBuilder(); 827531"];
6903 [label="assertText.AppendLine(); 827532"];
6904 [label="int i; 827533"];
6905 [label="assertText.AppendLine('Expected:'); 827534"];
6906 [label="assertText.AppendLine('Expected:'); 827535"];
6907 [label="var expectedText = ArrayBuilder<string>.GetInstance(); 827536"];
6908 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 827537"];
6909 [label="GetCommaSeparatedLines(assertText, expectedText); 827538"];
6910 [label="GetCommaSeparatedLines(assertText, expectedText); 827539"];
6911 [label="GetCommaSeparatedLines(assertText, expectedText) 827540"];
6912 [label="param GetCommaSeparatedLines(StringBuilder sb) 827541"];
6913 [label="param GetCommaSeparatedLines(ArrayBuilder<string> lines) 827542"];
6914 [label="int n = lines.Count; 827543"];
6915 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 827544"];
6916 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 827545"];
6917 [label="GetCommaSeparatedLines(assertText, expectedText); 827546"];
6918 [label="assertText.AppendLine('Actual:'); 827547"];
6919 [label="assertText.AppendLine('Actual:'); 827548"];
6920 [label="var actualText = ArrayBuilder<string>.GetInstance(); 827549"];
6921 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 827550"];
6922 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 827551"];
6923 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 827552"];
6924 [label="assertText.AppendLine('Diff:'); 827553"];
6925 [label="assertText.AppendLine('Diff:'); 827554"];
6926 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 827555"];
6927 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 827556"];
6928 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 827557"];
6929 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 827558"];
6930 [label="DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine) 827559"];
6931 [label="param DiffReport(IEnumerable<T> expected) 827560"];
6932 [label="param DiffReport(IEnumerable<T> actual) 827561"];
6933 [label="param DiffReport(string separator) 827562"];
6934 [label="param DiffReport(IEqualityComparer<T> comparer = null) 827563"];
6935 [label="param DiffReport(Func<T, string> toString = null) 827564"];
6936 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 827565"];
6937 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 827566"];
6938 [label="(comparer != null) 827567"];
6939 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 827568"];
6940 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 827569"];
6941 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 827570"];
6942 [label="IList<T> expectedList = expected as IList<T> ?? new List<T>(expected); 827571"];
6943 [label="IList<T> actualList = actual as IList<T> ?? new List<T>(actual); 827572"];
6944 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 827573"];
6945 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 827574"];
6946 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 827575"];
6947 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 827576"];
6948 [label="lcs.CalculateDiff(expectedList, actualList, toString) 827577"];
6949 [label="param CalculateDiff(IList<T> sequenceA) 827578"];
6950 [label="param CalculateDiff(IList<T> sequenceB) 827579"];
6951 [label="param CalculateDiff(Func<T, string> toString) 827580"];
6952 [label="param CalculateDiff(this) 827581"];
6953 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 827582"];
6954 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 827583"];
6955 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 827584"];
6956 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 827585"];
6957 [label="GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count) 827586"];
6958 [label="param GetEdits(TSequence sequenceA) 827587"];
6959 [label="param GetEdits(int lengthA) 827588"];
6960 [label="param GetEdits(TSequence sequenceB) 827589"];
6961 [label="param GetEdits(int lengthB) 827590"];
6962 [label="param GetEdits(this) 827591"];
6963 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 827592"];
6964 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 827593"];
6965 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 827594"];
6966 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 827595"];
6967 [label="ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB) 827596"];
6968 [label="param ComputeCostMatrix(TSequence sequenceA) 827597"];
6969 [label="param ComputeCostMatrix(int lengthA) 827598"];
6970 [label="param ComputeCostMatrix(TSequence sequenceB) 827599"];
6971 [label="param ComputeCostMatrix(int lengthB) 827600"];
6972 [label="param ComputeCostMatrix(this) 827601"];
6973 [label="var la = lengthA + 1; 827602"];
6974 [label="var la = lengthA + 1; 827603"];
6975 [label="var lb = lengthB + 1; 827604"];
6976 [label="var lb = lengthB + 1; 827605"];
6977 [label="var d = new int[la, lb]; 827606"];
6978 [label="d[0, 0] = 0; 827607"];
6979 [label="d[0, 0] 827608"];
6980 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 827609"];
6981 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 827610"];
6982 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 827611"];
6983 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 827612"];
6984 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 827613"];
6985 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 827614"];
6986 [label="return d; 827615"];
6987 [label="int i = lengthA; 827616"];
6988 [label="int j = lengthB; 827617"];
6989 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 827618"];
6990 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 827619"];
6991 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 827620"];
6992 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 827621"];
6993 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 827622"];
6994 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 827623"];
6995 [label="param GetEdits(this) 827624"];
6996 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 827625"];
6997 [label="param CalculateDiff(this) 827626"];
6998 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 827627"];
6999 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 827628"];
7000 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 827629"];
7001 [label="actualText.Free(); 827630"];
7002 [label="expectedText.Free(); 827631"];
7003 [label="return assertText.ToString(); 827632"];
7004 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 827633"];
7005 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 827634"];
7006 [label="return c; 827635"];
7007 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { imageRef },\n                options: TestOptions.ReleaseModule.WithPlatform(Platform.Itanium)); 827636"];
7008 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { imageRef },\n                options: TestOptions.ReleaseModule.WithPlatform(Platform.Itanium)); 827637"];
7009 [label="new MetadataReference[] { imageRef } 827638"];
7010 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { imageRef },\n                options: TestOptions.ReleaseModule.WithPlatform(Platform.Itanium)); 827639"];
7011 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { imageRef },\n                options: TestOptions.ReleaseModule.WithPlatform(Platform.Itanium)); 827640"];
7012 [label="useCompilation = CreateEmptyCompilation(useSource,\n                new MetadataReference[] { imageRef },\n                options: TestOptions.ReleaseModule.WithPlatform(Platform.Itanium)); 827641"];
7013 [label="new CSharpTestSource(source) 827642"];
7014 [label="param CSharpTestSource(this) 827643"];
7015 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 827644"];
7016 [label="=> CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 827645"];
7017 [label="skipUsesIsNullable 827646"];
7018 [label="null 827647"];
7019 [label="experimentalFeature: null 827648"];
7020 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 827649"];
7021 [label="param CreateCompilationCore(bool skipUsesIsNullable) 827650"];
7022 [label="param CreateCompilationCore(MessageID? experimentalFeature) 827651"];
7023 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 827652"];
7024 [label="var stream = new MemoryStream(); 827653"];
7025 [label="var root = tree.GetRoot(); 827654"];
7026 [label="root.SerializeTo(stream); 827655"];
7027 [label="root.SerializeTo(stream); 827656"];
7028 [label="root.SerializeTo(stream); 827657"];
7029 [label="stream.Position = 0; 827658"];
7030 [label="stream.Position 827659"];
7031 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 827660"];
7032 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 827661"];
7033 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 827662"];
7034 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 827663"];
7035 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 827664"];
7036 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 827665"];
7037 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 827666"];
7038 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 827667"];
7039 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 827668"];
7040 [label="param ValidateIOperations(Func<Compilation> createCompilation) 827669"];
7041 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 827670"];
7042 [label="return; 827671"];
7043 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 827672"];
7044 [label="var compilation = createCompilationLambda(); 827673"];
7045 [label="return Guid.NewGuid().ToString('D'); 827674"];
7046 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 827675"];
7047 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 827676"];
7048 [label="param Create(CSharpCompilation? previousSubmission) 827677"];
7049 [label="param Create(Type? returnType) 827678"];
7050 [label="param Create(Type? hostObjectType) 827679"];
7051 [label="param Create(bool isSubmission) 827680"];
7052 [label="RoslynDebug.Assert(options != null); 827681"];
7053 [label="RoslynDebug.Assert(options != null); 827682"];
7054 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 827683"];
7055 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 827684"];
7056 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 827685"];
7057 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 827686"];
7058 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 827687"];
7059 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 827688"];
7060 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 827689"];
7061 [label="new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null) 827690"];
7062 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 827691"];
7063 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 827692"];
7064 [label="param SyntaxAndDeclarationManager(bool isSubmission) 827693"];
7065 [label="param SyntaxAndDeclarationManager(State state) 827694"];
7066 [label="param SyntaxAndDeclarationManager(this) 827695"];
7067 [label="externalSyntaxTrees 827696"];
7068 [label="messageProvider 827697"];
7069 [label="isSubmission 827698"];
7070 [label="param SyntaxAndDeclarationManager(this) 827699"];
7071 [label="_lazyState 827700"];
7072 [label="_lazyState 827701"];
7073 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 827702"];
7074 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 827703"];
7075 [label="param CSharpCompilation(Type? submissionReturnType) 827704"];
7076 [label="param CSharpCompilation(Type? hostObjectType) 827705"];
7077 [label="param CSharpCompilation(bool isSubmission) 827706"];
7078 [label="param CSharpCompilation(ReferenceManager? referenceManager) 827707"];
7079 [label="param CSharpCompilation(bool reuseReferenceManager) 827708"];
7080 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 827709"];
7081 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 827710"];
7082 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 827711"];
7083 [label="param CSharpCompilation(this) 827712"];
7084 [label="previousSubmission 827713"];
7085 [label="submissionReturnType 827714"];
7086 [label="hostObjectType 827715"];
7087 [label="isSubmission 827716"];
7088 [label="referenceManager 827717"];
7089 [label="reuseReferenceManager 827718"];
7090 [label="syntaxAndDeclarations 827719"];
7091 [label="semanticModelProvider 827720"];
7092 [label="eventQueue 827721"];
7093 [label="param CSharpCompilation(this) 827722"];
7094 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 827723"];
7095 [label="param CSharpCompilation(Type? submissionReturnType) 827724"];
7096 [label="param CSharpCompilation(Type? hostObjectType) 827725"];
7097 [label="param CSharpCompilation(bool isSubmission) 827726"];
7098 [label="param CSharpCompilation(ReferenceManager? referenceManager) 827727"];
7099 [label="param CSharpCompilation(bool reuseReferenceManager) 827728"];
7100 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 827729"];
7101 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 827730"];
7102 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 827731"];
7103 [label="param CSharpCompilation(this) 827732"];
7104 [label="isSubmission 827733"];
7105 [label="semanticModelProvider 827734"];
7106 [label="eventQueue 827735"];
7107 [label="param CSharpCompilation(this) 827736"];
7108 [label="_options 827737"];
7109 [label="_globalImports 827738"];
7110 [label="_previousSubmissionImports 827739"];
7111 [label="_globalNamespaceAlias 827740"];
7112 [label="_scriptClass 827741"];
7113 [label="_lazyHostObjectTypeSymbol 827742"];
7114 [label="_lazyImportInfos 827743"];
7115 [label="_conversions 827744"];
7116 [label="_anonymousTypeManager 827745"];
7117 [label="_lazyGlobalNamespace 827746"];
7118 [label="builtInOperators 827747"];
7119 [label="_lazyAssemblySymbol 827748"];
7120 [label="_referenceManager 827749"];
7121 [label="_syntaxAndDeclarations 827750"];
7122 [label="_lazyEntryPoint 827751"];
7123 [label="_lazyEmitNullablePublicOnly 827752"];
7124 [label="_lazyCompilationUnitCompletedTrees 827753"];
7125 [label="NullableAnalysisData 827754"];
7126 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 827755"];
7127 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 827756"];
7128 [label="_externAliasTargets 827757"];
7129 [label="_moduleInitializerMethods 827758"];
7130 [label="_binderFactories 827759"];
7131 [label="_ignoreAccessibilityBinderFactories 827760"];
7132 [label="_lazyDeclarationDiagnostics 827761"];
7133 [label="_declarationDiagnosticsFrozen 827762"];
7134 [label="new DiagnosticBag() 827763"];
7135 [label="_additionalCodegenWarnings = new DiagnosticBag() 827764"];
7136 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 827765"];
7137 [label="this.builtInOperators = new BuiltInOperators(this); 827766"];
7138 [label="this.builtInOperators = new BuiltInOperators(this); 827767"];
7139 [label="new BuiltInOperators(this) 827768"];
7140 [label="param BuiltInOperators(CSharpCompilation compilation) 827769"];
7141 [label="param BuiltInOperators(this) 827770"];
7142 [label="_compilation 827771"];
7143 [label="_builtInUnaryOperators 827772"];
7144 [label="_builtInOperators 827773"];
7145 [label="_compilation 827774"];
7146 [label="this.builtInOperators 827775"];
7147 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 827776"];
7148 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 827777"];
7149 [label="LanguageVersion? result = null; 827778"];
7150 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 827779"];
7151 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 827780"];
7152 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 827781"];
7153 [label="this.LanguageVersion 827782"];
7154 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 827783"];
7155 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 827784"];
7156 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 827785"];
7157 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 827786"];
7158 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 827787"];
7159 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 827788"];
7160 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 827789"];
7161 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 827790"];
7162 [label="this.Options 827791"];
7163 [label="get\n            {\n                return _options;\n            } 827792"];
7164 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 827793"];
7165 [label="_syntaxAndDeclarations 827794"];
7166 [label="Debug.Assert(_lazyAssemblySymbol is null); 827795"];
7167 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 827796"];
7168 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 827797"];
7169 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 827798"];
7170 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 827799"];
7171 [label="int i = 0; 827800"];
7172 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 827801"];
7173 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 827802"];
7174 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 827803"];
7175 [label="i++; 827804"];
7176 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 827805"];
7177 [label="var scriptClassName = this.ScriptClassName; 827806"];
7178 [label="var resolver = this.Resolver; 827807"];
7179 [label="var messageProvider = this.MessageProvider; 827808"];
7180 [label="var isSubmission = this.IsSubmission; 827809"];
7181 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 827810"];
7182 [label="param CSharpCompilation(Type? submissionReturnType) 827811"];
7183 [label="param CSharpCompilation(Type? hostObjectType) 827812"];
7184 [label="previousSubmission 827813"];
7185 [label="submissionReturnType 827814"];
7186 [label="hostObjectType 827815"];
7187 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 827816"];
7188 [label="param CSharpCompilation(Type? submissionReturnType) 827817"];
7189 [label="param CSharpCompilation(Type? hostObjectType) 827818"];
7190 [label="_compilation 827819"];
7191 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 827820"];
7192 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 827821"];
7193 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 827822"];
7194 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 827823"];
7195 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 827824"];
7196 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 827825"];
7197 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 827826"];
7198 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 827827"];
7199 [label="Debug.Assert(_lazyAssemblySymbol is null); 827828"];
7200 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 827829"];
7201 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 827830"];
7202 [label="IsNullableEnabled(compilation) 827831"];
7203 [label="compilation.SyntaxTrees 827832"];
7204 [label="_syntaxAndDeclarations.GetLazyState() 827833"];
7205 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 827834"];
7206 [label="param AppendAllSyntaxTrees(SourceReferenceResolver resolver) 827835"];
7207 [label="param AppendAllSyntaxTrees(CommonMessageProvider messageProvider) 827836"];
7208 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMapBuilder) 827837"];
7209 [label="param AppendAllSyntaxTrees(IDictionary<string, SyntaxTree> loadedSyntaxTreeMapBuilder) 827838"];
7210 [label="var sourceCodeKind = tree.Options.Kind; 827839"];
7211 [label="if (sourceCodeKind == SourceCodeKind.Script)\n            {\n                AppendAllLoadedSyntaxTrees(treesBuilder, tree, scriptClassName, resolver, messageProvider, isSubmission, ordinalMapBuilder, loadDirectiveMapBuilder, loadedSyntaxTreeMapBuilder, declMapBuilder, ref declTable);\n            } 827840"];
7212 [label="OrdinalMap 827841"];
7213 [label="LoadDirectiveMap 827842"];
7214 [label="LoadedSyntaxTreeMap 827843"];
7215 [label="RootNamespaces 827844"];
7216 [label="DeclarationTable 827845"];
7217 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 827846"];
7218 [label="var options = (CSharpParseOptions)trees[0].Options; 827847"];
7219 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 827848"];
7220 [label="useCompilation.VerifyEmitDiagnostics(emitOptions); 827849"];
7221 [label="useCompilation.VerifyEmitDiagnostics(emitOptions); 827850"];
7222 [label="useCompilation.VerifyEmitDiagnostics(emitOptions); 827851"];
7223 [label="useCompilation.VerifyEmitDiagnostics(emitOptions) 827852"];
7224 [label="param VerifyEmitDiagnostics(this TCompilation c) 827853"];
7225 [label="param VerifyEmitDiagnostics(EmitOptions options) 827854"];
7226 [label="param VerifyEmitDiagnostics(params DiagnosticDescription[] expected) 827855"];
7227 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 827856"];
7228 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 827857"];
7229 [label="c.GetEmitDiagnostics(options: options) 827858"];
7230 [label="param GetEmitDiagnostics(EmitOptions options = null) 827859"];
7231 [label="param GetEmitDiagnostics(IEnumerable<ResourceDescription> manifestResources = null) 827860"];
7232 [label="MonoHelpers.IsRunningOnMono() 827861"];
7233 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 827862"];
7234 [label="var pdbStream = MonoHelpers.IsRunningOnMono() ? null : new MemoryStream(); 827863"];
7235 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 827864"];
7236 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 827865"];
7237 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 827866"];
7238 [label="return c.Emit(new MemoryStream(), pdbStream: pdbStream, options: options, manifestResources: manifestResources).Diagnostics; 827867"];
7239 [label="param CreateModuleBuilder(IMethodSymbol? debugEntryPoint) 827868"];
7240 [label="param CreateModuleBuilder(IEnumerable<EmbeddedText>? embeddedTexts) 827869"];
7241 [label="param CreateModuleBuilder(CompilationTestData? testData) 827870"];
7242 [label="param CreateModuleBuilder(CancellationToken cancellationToken) 827871"];
7243 [label="Debug.Assert(!IsSubmission || HasCodeToEmit()); 827872"];
7244 [label="GetRuntimeMetadataVersion(emitOptions, diagnostics) 827873"];
7245 [label="GetRuntimeMetadataVersion(emitOptions) 827874"];
7246 [label="Assembly 827875"];
7247 [label="SourceAssembly 827876"];
7248 [label="GetBoundReferenceManager() 827877"];
7249 [label="Debug.Assert(_lazyAssemblySymbol is object); 827878"];
7250 [label="GetBoundReferenceManager(); 827879"];
7251 [label="var corAssembly = Assembly.CorLibrary as Symbols.Metadata.PE.PEAssemblySymbol; 827880"];
7252 [label="if (corAssembly is object)\n            {\n                return corAssembly.Assembly.ManifestModule.MetadataVersion;\n            } 827881"];
7253 [label="if (runtimeMDVersion != null)\n            {\n                return runtimeMDVersion;\n            } 827882"];
7254 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 827883"];
7255 [label="if (runtimeMDVersion == null)\n            {\n                return null;\n            } 827884"];
7256 [label="var moduleProps = ConstructModuleSerializationProperties(emitOptions, runtimeMDVersion); 827885"];
7257 [label="SourceAssembly 827886"];
7258 [label="GetBoundReferenceManager() 827887"];
7259 [label="GetBoundReferenceManager(); 827888"];
7260 [label="SourceAssembly.IsDelaySigned 827889"];
7261 [label="Declarations 827890"];
7262 [label="_syntaxAndDeclarations.GetLazyState() 827891"];
7263 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 827892"];
7264 [label="return Declarations.GetMergedRoot(this); 827893"];
7265 [label="_syntaxAndDeclarations.GetLazyState() 827894"];
7266 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 827895"];
7267 [label="=> 0x30 827896"];
7268 [label="0x30 827897"];
7269 [label="if (manifestResources == null)\n            {\n                manifestResources = SpecializedCollections.EmptyEnumerable<ResourceDescription>();\n            } 827898"];
7270 [label="PEModuleBuilder moduleBeingBuilt; 827899"];
7271 [label="GetBoundReferenceManager(); 827900"];
7272 [label="get\n            {\n                return true;\n            } 827901"];
7273 [label="if (sourceModule.AnyReferencedAssembliesAreLinked)\n            {\n                _embeddedTypesManagerOpt = new NoPia.EmbeddedTypesManager(this);\n            } 827902"];
7274 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 827903"];
7275 [label="if (debugEntryPoint != null)\n            {\n                moduleBeingBuilt.SetDebugEntryPoint(debugEntryPoint.GetSymbol(), diagnostics);\n            } 827904"];
7276 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 827905"];
7277 [label="if (embeddedTexts != null)\n            {\n                moduleBeingBuilt.EmbeddedTexts = embeddedTexts;\n            } 827906"];
7278 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 827907"];
7279 [label="if (testData != null)\n            {\n                moduleBeingBuilt.SetMethodTestData(testData.Methods);\n                testData.Module = moduleBeingBuilt;\n            } 827908"];
7280 [label="PooledHashSet<int>? excludeDiagnostics = null; 827909"];
7281 [label="if (emitMetadataOnly)\n            {\n                excludeDiagnostics = PooledHashSet<int>.GetInstance();\n                excludeDiagnostics.Add((int)ErrorCode.ERR_ConcreteMissingBody);\n            } 827910"];
7282 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 827911"];
7283 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 827912"];
7284 [label="GetDiagnostics(CompilationStage.Declare, true, cancellationToken) 827913"];
7285 [label="param GetDiagnostics(CompilationStage stage) 827914"];
7286 [label="param GetDiagnostics(bool includeEarlierStages) 827915"];
7287 [label="var diagnostics = DiagnosticBag.GetInstance(); 827916"];
7288 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 827917"];
7289 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 827918"];
7290 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 827919"];
7291 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 827920"];
7292 [label="param GetDiagnostics(CompilationStage stage) 827921"];
7293 [label="param GetDiagnostics(bool includeEarlierStages) 827922"];
7294 [label="param GetDiagnostics(DiagnosticBag diagnostics) 827923"];
7295 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 827924"];
7296 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 827925"];
7297 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 827926"];
7298 [label="this.SyntaxTrees 827927"];
7299 [label="_syntaxAndDeclarations.GetLazyState() 827928"];
7300 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 827929"];
7301 [label="this.Options 827930"];
7302 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 827931"];
7303 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 827932"];
7304 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 827933"];
7305 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 827934"];
7306 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 827935"];
7307 [label="CheckAssemblyName(builder); 827936"];
7308 [label="CheckAssemblyName(builder); 827937"];
7309 [label="Options 827938"];
7310 [label="Options 827939"];
7311 [label="get\n            {\n                return _options;\n            } 827940"];
7312 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 827941"];
7313 [label="GetBoundReferenceManager() 827942"];
7314 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 827943"];
7315 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 827944"];
7316 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 827945"];
7317 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 827946"];
7318 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 827947"];
7319 [label="GlobalImports 827948"];
7320 [label="_globalImports.Value 827949"];
7321 [label="Imports.FromGlobalUsings(this) 827950"];
7322 [label="SourceLocation? location = null; 827951"];
7323 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 827952"];
7324 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 827953"];
7325 [label="Assembly 827954"];
7326 [label="SourceAssembly 827955"];
7327 [label="GetBoundReferenceManager() 827956"];
7328 [label="GetBoundReferenceManager(); 827957"];
7329 [label="Assembly.ForceComplete(location, cancellationToken); 827958"];
7330 [label="Assembly.ForceComplete(location, cancellationToken); 827959"];
7331 [label="Declarations 827960"];
7332 [label="_syntaxAndDeclarations.GetLazyState() 827961"];
7333 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 827962"];
7334 [label="return Declarations.GetMergedRoot(this); 827963"];
7335 [label="_syntaxAndDeclarations.GetLazyState() 827964"];
7336 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 827965"];
7337 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 827966"];
7338 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 827967"];
7339 [label="param SymbolDeclaredEvent(Symbol symbol) 827968"];
7340 [label="param SymbolDeclaredEvent(this) 827969"];
7341 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 827970"];
7342 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 827971"];
7343 [label="GetBinderFactory(syntax.SyntaxTree) 827972"];
7344 [label="param GetBinderFactory(bool ignoreAccessibility = false) 827973"];
7345 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 827974"];
7346 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 827975"];
7347 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 827976"];
7348 [label="param GetBinderFactory(bool ignoreAccessibility) 827977"];
7349 [label="ignoreAccessibility 827978"];
7350 [label="GetSyntaxTreeOrdinal(syntaxTree) 827979"];
7351 [label="this.ContainsSyntaxTree(tree) 827980"];
7352 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 827981"];
7353 [label="_syntaxAndDeclarations.GetLazyState() 827982"];
7354 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 827983"];
7355 [label="_syntaxAndDeclarations.GetLazyState() 827984"];
7356 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 827985"];
7357 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 827986"];
7358 [label="BinderFactory? previousFactory; 827987"];
7359 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 827988"];
7360 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 827989"];
7361 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 827990"];
7362 [label="param AddNewFactory(bool ignoreAccessibility) 827991"];
7363 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 827992"];
7364 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 827993"];
7365 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 827994"];
7366 [label="BinderFactory? previousFactory; 827995"];
7367 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 827996"];
7368 [label="Assembly 827997"];
7369 [label="SourceAssembly 827998"];
7370 [label="GetBoundReferenceManager() 827999"];
7371 [label="GetBoundReferenceManager(); 828000"];
7372 [label="return Assembly.Modules[0]; 828001"];
7373 [label="IsNullableAnalysisEnabledIn((CSharpSyntaxTree)syntax.SyntaxTree, syntax.Span) 828002"];
7374 [label="GetNullableAnalysisValue() 828003"];
7375 [label="return Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            }; 828004"];
7376 [label="Options 828005"];
7377 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 828006"];
7378 [label="param GetBinderFactory(bool ignoreAccessibility = false) 828007"];
7379 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 828008"];
7380 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 828009"];
7381 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 828010"];
7382 [label="param GetBinderFactory(bool ignoreAccessibility) 828011"];
7383 [label="ignoreAccessibility 828012"];
7384 [label="GetSyntaxTreeOrdinal(syntaxTree) 828013"];
7385 [label="this.ContainsSyntaxTree(tree) 828014"];
7386 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 828015"];
7387 [label="_syntaxAndDeclarations.GetLazyState() 828016"];
7388 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 828017"];
7389 [label="_syntaxAndDeclarations.GetLazyState() 828018"];
7390 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 828019"];
7391 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 828020"];
7392 [label="BinderFactory? previousFactory; 828021"];
7393 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 828022"];
7394 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 828023"];
7395 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 828024"];
7396 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 828025"];
7397 [label="param AddNewFactory(bool ignoreAccessibility) 828026"];
7398 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 828027"];
7399 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 828028"];
7400 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 828029"];
7401 [label="BinderFactory? previousFactory; 828030"];
7402 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 828031"];
7403 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 828032"];
7404 [label="Assembly 828033"];
7405 [label="SourceAssembly 828034"];
7406 [label="GetBoundReferenceManager() 828035"];
7407 [label="GetBoundReferenceManager(); 828036"];
7408 [label="return Assembly.Modules[0]; 828037"];
7409 [label="compilation.SyntaxTrees 828038"];
7410 [label="_syntaxAndDeclarations.GetLazyState() 828039"];
7411 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 828040"];
7412 [label="return ((CSharpParseOptions)compilation.SyntaxTrees.FirstOrDefault()?.Options)?.IsFeatureEnabled(feature) == true; 828041"];
7413 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 828042"];
7414 [label="NamedTypeSymbol result; 828043"];
7415 [label="Debug.Assert(result.SpecialType == specialType); 828044"];
7416 [label="Debug.Assert(symbol.IsDefinition); 828045"];
7417 [label="SourceModule 828046"];
7418 [label="Assembly 828047"];
7419 [label="SourceAssembly 828048"];
7420 [label="GetBoundReferenceManager() 828049"];
7421 [label="GetBoundReferenceManager(); 828050"];
7422 [label="return Assembly.Modules[0]; 828051"];
7423 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 828052"];
7424 [label="EmitNullablePublicOnly 828053"];
7425 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 828054"];
7426 [label="_declarationDiagnosticsFrozen = true; 828055"];
7427 [label="_needsGeneratedAttributes_IsFrozen = true; 828056"];
7428 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 828057"];
7429 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 828058"];
7430 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 828059"];
7431 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 828060"];
7432 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 828061"];
7433 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 828062"];
7434 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 828063"];
7435 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 828064"];
7436 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 828065"];
7437 [label="param CheckCompliance(DiagnosticBag diagnostics) 828066"];
7438 [label="System.Diagnostics.Debug.Assert(symbol is SourceAssemblySymbol); 828067"];
7439 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 828068"];
7440 [label="System.Diagnostics.Debug.Assert(symbol.Kind == SymbolKind.NamedType || !((symbol is TypeSymbol)),\n                'Type kinds without declarations are handled elsewhere.'); 828069"];
7441 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                MethodSymbol method = (MethodSymbol)symbol;\n                Symbol associated = method.AssociatedSymbol;\n                if ((object)associated != null)\n                {\n                    // Don't bother storing entries for accessors - just go straight to the property/event.\n                    return GetDeclaredOrInheritedCompliance(associated);\n                }\n            } 828070"];
7442 [label="Debug.Assert(symbol.Kind != SymbolKind.Alias); 828071"];
7443 [label="Debug.Assert(symbol.Kind != SymbolKind.Label); 828072"];
7444 [label="Debug.Assert(symbol.Kind != SymbolKind.Namespace); 828073"];
7445 [label="Debug.Assert(symbol.Kind != SymbolKind.Parameter); 828074"];
7446 [label="Debug.Assert(symbol.Kind != SymbolKind.RangeVariable); 828075"];
7447 [label="param GetDeclaredCompliance(out Location attributeLocation) 828076"];
7448 [label="param GetDeclaredCompliance(this) 828077"];
7449 [label="attributeLocation = null; 828078"];
7450 [label="if (assemblyCompliance == Compliance.DeclaredFalse)\n            {\n                // Our interpretation of an assembly-level CLSCompliant attribute is as follows:\n                //   1) If true, then perform all CLS checks.\n                //   2) If false, then perform no CLS checks (dev11 still performs a few, mostly around\n                //      meaningless attributes).  Our interpretation is that the user ultimately wants\n                //      his code to be CLS-compliant, but is temporarily disabling the checks (e.g. during\n                //      refactoring/prototyping).\n                //   3) If absent, the perform all CLS checks.  Our interpretation is that - in the\n                //      absence of an assembly-level attribute - any CLS problems within the compilation\n                //      indicate that the user was trying to do something but didn't know how.  It would\n                //      be nice if the most common case (i.e. this one) was the cheapest, but we don't\n                //      want to confuse novice users.\n                return;\n            } 828079"];
7451 [label="bool assemblyComplianceValue = IsTrue(assemblyCompliance); 828080"];
7452 [label="IsTrue(assemblyCompliance) 828081"];
7453 [label="param IsTrue(Compliance compliance) 828082"];
7454 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 828083"];
7455 [label="return false; 828084"];
7456 [label="Location attributeLocation; 828085"];
7457 [label="param GetDeclaredCompliance(out Location attributeLocation) 828086"];
7458 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 828087"];
7459 [label="i == 0 828088"];
7460 [label="Location warningLocation = i == 0 ? attributeLocation : module.Locations[0]; 828089"];
7461 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 828090"];
7462 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 828091"];
7463 [label="System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null),\n                    'Can only be null when the source location is filtered out.'); 828092"];
7464 [label="if (moduleDeclaredCompliance.HasValue)\n                {\n                    if (warningLocation != null)\n                    {\n                        if (!IsDeclared(assemblyCompliance))\n                        {\n                            // This is not useful on non-source modules, but dev11 reports it anyway.\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules, warningLocation);\n                        }\n                        else if (assemblyComplianceValue != moduleDeclaredCompliance.GetValueOrDefault())\n                        {\n                            this.AddDiagnostic(ErrorCode.WRN_CLS_NotOnModules2, warningLocation);\n                        }\n                    }\n                }\n                else if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 828093"];
7465 [label="if (assemblyComplianceValue && i > 0)\n                {\n                    bool sawClsCompliantAttribute = false;\n                    var peModule = (Symbols.Metadata.PE.PEModuleSymbol)module;\n                    foreach (CSharpAttributeData assemblyLevelAttribute in peModule.GetAssemblyAttributes())\n                    {\n                        if (assemblyLevelAttribute.IsTargetAttribute(peModule, AttributeDescription.CLSCompliantAttribute))\n                        {\n                            sawClsCompliantAttribute = true;\n                            break;\n                        }\n                    }\n\n                    if (!sawClsCompliantAttribute)\n                    {\n                        this.AddDiagnostic(ErrorCode.WRN_CLS_ModuleMissingCLS, warningLocation);\n                    }\n                } 828094"];
7466 [label="if (assemblyComplianceValue)\n            {\n                CheckForAttributeWithArrayArgument(symbol);\n            } 828095"];
7467 [label="System.Diagnostics.Debug.Assert(symbol.Kind != SymbolKind.Assembly); 828096"];
7468 [label="System.Diagnostics.Debug.Assert((object)containing != null); 828097"];
7469 [label="return compliance; 828098"];
7470 [label="IsTrue(GetInheritedCompliance(symbol)) 828099"];
7471 [label="param IsTrue(Compliance compliance) 828100"];
7472 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 828101"];
7473 [label="return false; 828102"];
7474 [label="IsTrue(GetDeclaredOrInheritedCompliance(sourceModule)) 828103"];
7475 [label="param IsTrue(Compliance compliance) 828104"];
7476 [label="if (DoNotVisit(symbol)) return; 828105"];
7477 [label="DoNotVisit(symbol) 828106"];
7478 [label="param DoNotVisit(Symbol symbol) 828107"];
7479 [label="param DoNotVisit(this) 828108"];
7480 [label="if (symbol.Kind == SymbolKind.Namespace)\n            {\n                return false;\n            } 828109"];
7481 [label="return false; 828110"];
7482 [label="IsTrue(GetDeclaredOrInheritedCompliance(symbol)) 828111"];
7483 [label="param IsTrue(Compliance compliance) 828112"];
7484 [label="switch (compliance)\n            {\n                case Compliance.DeclaredTrue:\n                case Compliance.InheritedTrue:\n                    return true;\n                case Compliance.DeclaredFalse:\n                case Compliance.InheritedFalse:\n                case Compliance.ImpliedFalse:\n                    return false;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(compliance);\n            } 828113"];
7485 [label="return false; 828114"];
7486 [label="if (tasks == null)\n            {\n                return;\n            } 828115"];
7487 [label="checker.WaitForWorkers(); 828116"];
7488 [label="foreach (Diagnostic diag in queue)\n            {\n                diagnostics.Add(diag);\n            } 828117"];
7489 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 828118"];
7490 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 828119"];
7491 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 828120"];
7492 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 828121"];
7493 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 828122"];
7494 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 828123"];
7495 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 828124"];
7496 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 828125"];
7497 [label="bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics, GetDiagnostics(CompilationStage.Declare, true, cancellationToken), excludeDiagnostics, cancellationToken); 828126"];
7498 [label="excludeDiagnostics?.Free(); 828127"];
7499 [label="param AddDebugSourceDocumentsForChecksumDirectives(DebugDocumentsBuilder documentsBuilder) 828128"];
7500 [label="param AddDebugSourceDocumentsForChecksumDirectives(DiagnosticBag diagnostics) 828129"];
7501 [label="param AddDebugSourceDocumentsForChecksumDirectives(this) 828130"];
7502 [label="foreach (var directive in checksumDirectives)\n            {\n                var checksumDirective = (PragmaChecksumDirectiveTriviaSyntax)directive;\n                var path = checksumDirective.File.ValueText;\n\n                var checksumText = checksumDirective.Bytes.ValueText;\n                var normalizedPath = documentsBuilder.NormalizeDebugDocumentPath(path, basePath: tree.FilePath);\n                var existingDoc = documentsBuilder.TryGetDebugDocumentForNormalizedPath(normalizedPath);\n\n                // duplicate checksum pragmas are valid as long as values match\n                // if we have seen this document already, check for matching values.\n                if (existingDoc != null)\n                {\n                    // pragma matches a file path on an actual tree.\n                    // Dev12 compiler just ignores the pragma in this case which means that\n                    // checksum of the actual tree always wins and no warning is given.\n                    // We will continue doing the same.\n                    if (existingDoc.IsComputedChecksum)\n                    {\n                        continue;\n                    }\n\n                    var sourceInfo = existingDoc.GetSourceInfo();\n                    if (ChecksumMatches(checksumText, sourceInfo.Checksum))\n                    {\n                        var guid = Guid.Parse(checksumDirective.Guid.ValueText);\n                        if (guid == sourceInfo.ChecksumAlgorithmId)\n                        {\n                            // all parts match, nothing to do\n                            continue;\n                        }\n                    }\n\n                    // did not match to an existing document\n                    // produce a warning and ignore the pragma\n                    diagnostics.Add(ErrorCode.WRN_ConflictingChecksum, new SourceLocation(checksumDirective), path);\n                }\n                else\n                {\n                    var newDocument = new Cci.DebugSourceDocument(\n                        normalizedPath,\n                        Cci.DebugSourceDocument.CorSymLanguageTypeCSharp,\n                        MakeChecksumBytes(checksumText),\n                        Guid.Parse(checksumDirective.Guid.ValueText));\n\n                    documentsBuilder.AddDebugDocument(newDocument);\n                }\n            } 828131"];
7503 [label="Debug.Assert(compilation != null); 828132"];
7504 [label="Debug.Assert(diagnostics != null); 828133"];
7505 [label="compilation.PreviousSubmission 828134"];
7506 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 828135"];
7507 [label="if (compilation.PreviousSubmission != null)\n            {\n                // In case there is a previous submission, we should ensure\n                // it has already created anonymous type/delegates templates\n\n                // NOTE: if there are any errors, we will pick up what was created anyway\n                compilation.PreviousSubmission.EnsureAnonymousTypeTemplates(cancellationToken);\n\n                // TODO: revise to use a loop instead of a recursion\n            } 828136"];
7508 [label="MethodSymbol entryPoint = null; 828137"];
7509 [label="param GetEntryPoint(PEModuleBuilder moduleBeingBuilt) 828138"];
7510 [label="param GetEntryPoint(bool hasDeclarationErrors) 828139"];
7511 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 828140"];
7512 [label="EntryPoint? entryPoint; 828141"];
7513 [label="Debug.Assert(!entryPointAndDiagnostics.Diagnostics.IsDefault); 828142"];
7514 [label="Debug.Assert(compilation != null); 828143"];
7515 [label="Debug.Assert(diagnostics != null); 828144"];
7516 [label="SetGlobalErrorIfTrue(hasDeclarationErrors); 828145"];
7517 [label="SetGlobalErrorIfTrue(hasDeclarationErrors) 828146"];
7518 [label="param SetGlobalErrorIfTrue(bool arg) 828147"];
7519 [label="param SetGlobalErrorIfTrue(this) 828148"];
7520 [label="if (arg)\n            {\n                _globalHasErrors = true;\n            } 828149"];
7521 [label="param VisitNamedType(TypeCompilationState arg) 828150"];
7522 [label="if (!PassesFilter(_filterOpt, symbol))\n            {\n                return null;\n            } 828151"];
7523 [label="PassesFilter(_filterOpt, symbol) 828152"];
7524 [label="param PassesFilter(Predicate<Symbol> filterOpt) 828153"];
7525 [label="param PassesFilter(Symbol symbol) 828154"];
7526 [label="return (filterOpt == null) || filterOpt(symbol); 828155"];
7527 [label="return (filterOpt == null) || filterOpt(symbol); 828156"];
7528 [label="arg = null; 828157"];
7529 [label="param CompileNamedTypeAsync(NamedTypeSymbol symbol) 828158"];
7530 [label="if (tasks == null)\n            {\n                return;\n            } 828159"];
7531 [label="methodCompiler.WaitForWorkers(); 828160"];
7532 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics); 828161"];
7533 [label="methodCompiler.CompileSynthesizedMethods(additionalTypes, diagnostics) 828162"];
7534 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 828163"];
7535 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 828164"];
7536 [label="param CompileSynthesizedMethods(this) 828165"];
7537 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 828166"];
7538 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics); 828167"];
7539 [label="methodCompiler.CompileSynthesizedMethods(embeddedTypes, diagnostics) 828168"];
7540 [label="param CompileSynthesizedMethods(ImmutableArray<NamedTypeSymbol> additionalTypes) 828169"];
7541 [label="param CompileSynthesizedMethods(DiagnosticBag diagnostics) 828170"];
7542 [label="param CompileSynthesizedMethods(this) 828171"];
7543 [label="foreach (var additionalType in additionalTypes)\n            {\n                var compilationState = new TypeCompilationState(additionalType, _compilation, _moduleBeingBuiltOpt);\n                foreach (var method in additionalType.GetMethodsToEmit())\n                {\n                    method.GenerateMethodBody(compilationState, diagnostics);\n                }\n\n                if (!diagnostics.HasAnyErrors())\n                {\n                    CompileSynthesizedMethods(compilationState);\n                }\n\n                compilationState.Free();\n            } 828172"];
7544 [label="param GetPreviousAnonymousTypes(this) 828173"];
7545 [label="param GetNextAnonymousTypeIndex(this) 828174"];
7546 [label="methodCompiler.WaitForWorkers(); 828175"];
7547 [label="var privateImplClass = moduleBeingBuiltOpt.PrivateImplClass; 828176"];
7548 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 828177"];
7549 [label="if (privateImplClass != null)\n                {\n                    // all threads that were adding methods must be finished now, we can freeze the class:\n                    privateImplClass.Freeze();\n\n                    methodCompiler.CompileSynthesizedMethods(privateImplClass, diagnostics);\n                } 828178"];
7550 [label="if (moduleBeingBuiltOpt != null && (methodCompiler._globalHasErrors || moduleBeingBuiltOpt.SourceModule.HasBadAttributes) && !diagnostics.HasAnyErrors() && !hasDeclarationErrors)\n            {\n                var messageResourceName = methodCompiler._globalHasErrors ? nameof(CodeAnalysisResources.UnableToDetermineSpecificCauseOfFailure) : nameof(CodeAnalysisResources.ModuleHasInvalidAttributes);\n                diagnostics.Add(ErrorCode.ERR_ModuleEmitFailure, NoLocation.Singleton, ((Cci.INamedEntity)moduleBeingBuiltOpt).Name,\n                    new LocalizableResourceString(messageResourceName, CodeAnalysisResources.ResourceManager, typeof(CodeAnalysisResources)));\n            } 828179"];
7551 [label="if (moduleBeingBuiltOpt != null && entryPoint != null && compilation.Options.OutputKind.IsApplication())\n                {\n                    moduleBeingBuiltOpt.SetPEEntryPoint(entryPoint, diagnostics);\n                } 828180"];
7552 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag); 828181"];
7553 [label="GenerateModuleInitializer(moduleBeingBuilt, methodBodyDiagnosticBag) 828182"];
7554 [label="param GenerateModuleInitializer(PEModuleBuilder moduleBeingBuilt) 828183"];
7555 [label="param GenerateModuleInitializer(DiagnosticBag methodBodyDiagnosticBag) 828184"];
7556 [label="param GenerateModuleInitializer(this) 828185"];
7557 [label="Debug.Assert(_declarationDiagnosticsFrozen); 828186"];
7558 [label="if (_moduleInitializerMethods is object)\n            {\n                var ilBuilder = new ILBuilder(moduleBeingBuilt, new LocalSlotManager(slotAllocator: null), OptimizationLevel.Release, areLocalsZeroed: false);\n\n                foreach (MethodSymbol method in _moduleInitializerMethods.OrderBy<MethodSymbol>(LexicalOrderSymbolComparer.Instance))\n                {\n                    ilBuilder.EmitOpCode(ILOpCode.Call, stackAdjustment: 0);\n\n                    ilBuilder.EmitToken(\n                        moduleBeingBuilt.Translate(method, methodBodyDiagnosticBag, needDeclaration: true),\n                        CSharpSyntaxTree.Dummy.GetRoot(),\n                        methodBodyDiagnosticBag);\n                }\n\n                ilBuilder.EmitRet(isVoid: true);\n                ilBuilder.Realize();\n                moduleBeingBuilt.RootModuleType.SetStaticConstructorBody(ilBuilder.RealizedIL);\n            } 828187"];
7559 [label="if (hasDeclarationErrors || hasMethodBodyError)\n                {\n                    return false;\n                } 828188"];
7560 [label="return true; 828189"];
7561 [label="DiagnosticBag? resourceDiagnostics = DiagnosticBag.GetInstance(); 828190"];
7562 [label="SetupWin32Resources(moduleBuilder, win32Resources, resourceDiagnostics); 828191"];
7563 [label="SourceAssembly 828192"];
7564 [label="GetBoundReferenceManager() 828193"];
7565 [label="GetBoundReferenceManager(); 828194"];
7566 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 828195"];
7567 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 828196"];
7568 [label="AddedModulesResourceNames(resourceDiagnostics) 828197"];
7569 [label="param AddedModulesResourceNames(DiagnosticBag diagnostics) 828198"];
7570 [label="SourceAssembly 828199"];
7571 [label="GetBoundReferenceManager() 828200"];
7572 [label="GetBoundReferenceManager(); 828201"];
7573 [label="ImmutableArray<ModuleSymbol> modules = SourceAssembly.Modules; 828202"];
7574 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 828203"];
7575 [label="for (int i = 1; i < modules.Length; i++)\n            {\n                var m = (Symbols.Metadata.PE.PEModuleSymbol)modules[i];\n                ImmutableArray<EmbeddedResource> resources;\n\n                try\n                {\n                    resources = m.Module.GetEmbeddedResourcesOrThrow();\n                }\n                catch (BadImageFormatException)\n                {\n                    diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    continue;\n                }\n\n                foreach (var resource in resources)\n                {\n                    yield return resource.Name;\n                }\n            } 828204"];
7576 [label="param AddedModulesResourceNames(this) 828205"];
7577 [label="ReportManifestResourceDuplicates(\n                moduleBuilder.ManifestResources,\n                SourceAssembly.Modules.Skip(1).Select(m => m.Name),   //all modules except the first one\n                AddedModulesResourceNames(resourceDiagnostics),\n                resourceDiagnostics); 828206"];
7578 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 828207"];
7579 [label="if (!FilterAndAppendAndFreeDiagnostics(diagnostics, ref resourceDiagnostics, cancellationToken))\n            {\n                return false;\n            } 828208"];
7580 [label="DiagnosticBag? xmlDiagnostics = DiagnosticBag.GetInstance(); 828209"];
7581 [label="string? assemblyName = FileNameUtilities.ChangeExtension(outputNameOverride, extension: null); 828210"];
7582 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 828211"];
7583 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken); 828212"];
7584 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, assemblyName, xmlDocStream, xmlDiagnostics, cancellationToken) 828213"];
7585 [label="param WriteDocumentationCommentXml(Stream? xmlDocStream) 828214"];
7586 [label="param WriteDocumentationCommentXml(DiagnosticBag diagnostics) 828215"];
7587 [label="param WriteDocumentationCommentXml(SyntaxTree? filterTree = null) 828216"];
7588 [label="param WriteDocumentationCommentXml(TextSpan? filterSpanWithinTree = null) 828217"];
7589 [label="StreamWriter writer = null; 828218"];
7590 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 828219"];
7591 [label="if (xmlDocStream != null && xmlDocStream.CanWrite)\n            {\n                writer = new StreamWriter(\n                    stream: xmlDocStream,\n                    encoding: new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false),\n                    bufferSize: 0x400, // Default.\n                    leaveOpen: true); // Don't close caller's stream.\n            } 828220"];
7592 [label="compilation.SourceAssembly 828221"];
7593 [label="GetBoundReferenceManager() 828222"];
7594 [label="GetBoundReferenceManager(); 828223"];
7595 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 828224"];
7596 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 828225"];
7597 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 828226"];
7598 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 828227"];
7599 [label="var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken); 828228"];
7600 [label="new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name, compilation, writer, filterTree, filterSpanWithinTree,\n                        processIncludes: true, isForSingleSymbol: false, diagnostics: diagnostics, cancellationToken: cancellationToken) 828229"];
7601 [label="param DocumentationCommentCompiler(TextWriter writer) 828230"];
7602 [label="param DocumentationCommentCompiler(SyntaxTree filterTree) 828231"];
7603 [label="param DocumentationCommentCompiler(TextSpan? filterSpanWithinTree) 828232"];
7604 [label="param DocumentationCommentCompiler(bool processIncludes) 828233"];
7605 [label="param DocumentationCommentCompiler(bool isForSingleSymbol) 828234"];
7606 [label="param DocumentationCommentCompiler(DiagnosticBag diagnostics) 828235"];
7607 [label="param DocumentationCommentCompiler(this) 828236"];
7608 [label="param DocumentationCommentCompiler(this) 828237"];
7609 [label="_assemblyName 828238"];
7610 [label="_compilation 828239"];
7611 [label="_writer 828240"];
7612 [label="_filterTree 828241"];
7613 [label="_filterSpanWithinTree 828242"];
7614 [label="_processIncludes 828243"];
7615 [label="_isForSingleSymbol 828244"];
7616 [label="_diagnostics 828245"];
7617 [label="_lazyComparer 828246"];
7618 [label="_includedFileCache 828247"];
7619 [label="_indentDepth 828248"];
7620 [label="_temporaryStringBuilders 828249"];
7621 [label="_writer 828250"];
7622 [label="_filterTree 828251"];
7623 [label="_filterSpanWithinTree 828252"];
7624 [label="_processIncludes 828253"];
7625 [label="_isForSingleSymbol 828254"];
7626 [label="_diagnostics 828255"];
7627 [label="compilation.SourceAssembly 828256"];
7628 [label="GetBoundReferenceManager() 828257"];
7629 [label="GetBoundReferenceManager(); 828258"];
7630 [label="compiler.Visit(compilation.SourceAssembly.GlobalNamespace); 828259"];
7631 [label="Debug.Assert(_assemblyName != null); 828260"];
7632 [label="WriteLine('<?xml version=\\'1.0\\'?>'); 828261"];
7633 [label="WriteLine('<?xml version=\\'1.0\\'?>') 828262"];
7634 [label="param WriteLine(string message) 828263"];
7635 [label="param WriteLine(this) 828264"];
7636 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828265"];
7637 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828266"];
7638 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828267"];
7639 [label="WriteLine('<doc>'); 828268"];
7640 [label="WriteLine('<doc>') 828269"];
7641 [label="param WriteLine(string message) 828270"];
7642 [label="param WriteLine(this) 828271"];
7643 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828272"];
7644 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828273"];
7645 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828274"];
7646 [label="Indent(); 828275"];
7647 [label="WriteLine('<members>'); 828276"];
7648 [label="WriteLine('<members>') 828277"];
7649 [label="param WriteLine(string message) 828278"];
7650 [label="param WriteLine(this) 828279"];
7651 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828280"];
7652 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828281"];
7653 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828282"];
7654 [label="Indent(); 828283"];
7655 [label="Debug.Assert(!_isForSingleSymbol); 828284"];
7656 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 828285"];
7657 [label="if (_filterTree != null && !symbol.IsDefinedInSourceTree(_filterTree, _filterSpanWithinTree))\n            {\n                return;\n            } 828286"];
7658 [label="if (isPartialMethodDefinitionPart)\n            {\n                MethodSymbol implementationPart = ((MethodSymbol)symbol).PartialImplementationPart;\n                if ((object)implementationPart != null)\n                {\n                    Visit(implementationPart);\n                }\n            } 828287"];
7659 [label="docCommentNodes 828288"];
7660 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 828289"];
7661 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 828290"];
7662 [label="maxDocumentationMode = DocumentationMode.None; 828291"];
7663 [label="nodes = default(ImmutableArray<DocumentationCommentTriviaSyntax>); 828292"];
7664 [label="ArrayBuilder<DocumentationCommentTriviaSyntax> builder = null; 828293"];
7665 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 828294"];
7666 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 828295"];
7667 [label="currDocumentationMode > maxDocumentationMode 828296"];
7668 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 828297"];
7669 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 828298"];
7670 [label="if (builder == null)\n            {\n                nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty;\n            }\n            else\n            {\n                builder.Sort(Comparer);\n                nodes = builder.ToImmutableAndFree();\n            } 828299"];
7671 [label="nodes = ImmutableArray<DocumentationCommentTriviaSyntax>.Empty; 828300"];
7672 [label="return true; 828301"];
7673 [label="if (docCommentNodes.IsEmpty)\n            {\n                if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                }\n                return;\n            } 828302"];
7674 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 828303"];
7675 [label="return; 828304"];
7676 [label="param TryGetDocumentationCommentNodes(out DocumentationMode maxDocumentationMode) 828305"];
7677 [label="param TryGetDocumentationCommentNodes(out ImmutableArray<DocumentationCommentTriviaSyntax> nodes) 828306"];
7678 [label="DocumentationMode currDocumentationMode = reference.SyntaxTree.Options.DocumentationMode; 828307"];
7679 [label="maxDocumentationMode = currDocumentationMode > maxDocumentationMode ? currDocumentationMode : maxDocumentationMode; 828308"];
7680 [label="currDocumentationMode > maxDocumentationMode 828309"];
7681 [label="foreach (var trivia in triviaList)\n                {\n                    if (ContainsXmlParseDiagnostic(trivia))\n                    {\n                        if (builder != null)\n                        {\n                            builder.Free();\n                        }\n                        return false;\n                    }\n\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<DocumentationCommentTriviaSyntax>.GetInstance();\n                    }\n                    builder.Add(trivia);\n                } 828310"];
7682 [label="if (maxDocumentationMode >= DocumentationMode.Diagnose && RequiresDocumentationComment(symbol))\n                {\n                    // Report the error at a location in the tree that was parsing doc comments.\n                    Location location = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol);\n                    if (location != null)\n                    {\n                        _diagnostics.Add(ErrorCode.WRN_MissingXMLComment, location, symbol);\n                    }\n                } 828311"];
7683 [label="Debug.Assert(_indentDepth >= 0); 828312"];
7684 [label="Unindent(); 828313"];
7685 [label="WriteLine('</members>'); 828314"];
7686 [label="WriteLine('</members>') 828315"];
7687 [label="param WriteLine(string message) 828316"];
7688 [label="param WriteLine(this) 828317"];
7689 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828318"];
7690 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828319"];
7691 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828320"];
7692 [label="Unindent(); 828321"];
7693 [label="WriteLine('</doc>'); 828322"];
7694 [label="WriteLine('</doc>') 828323"];
7695 [label="param WriteLine(string message) 828324"];
7696 [label="param WriteLine(this) 828325"];
7697 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828326"];
7698 [label="if (_temporaryStringBuilders?.Count > 0)\n            {\n                StringBuilder builder = _temporaryStringBuilders.Peek().Pooled.Builder;\n                builder.Append(MakeIndent(_indentDepth));\n                builder.AppendLine(message);\n            }\n            else if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828327"];
7699 [label="if (_writer != null)\n            {\n                _writer.Write(MakeIndent(_indentDepth));\n                _writer.WriteLine(message);\n            } 828328"];
7700 [label="Debug.Assert(compiler._indentDepth == 0); 828329"];
7701 [label="Debug.Assert(compiler._indentDepth == 0); 828330"];
7702 [label="writer?.Flush(); 828331"];
7703 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 828332"];
7704 [label="if (filterTree != null)\n            {\n                // Will respect the DocumentationMode.\n                UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree, filterSpanWithinTree, diagnostics, cancellationToken);\n            }\n            else\n            {\n                foreach (SyntaxTree tree in compilation.SyntaxTrees)\n                {\n                    // Will respect the DocumentationMode.\n                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(tree, null, diagnostics, cancellationToken);\n                }\n            } 828333"];
7705 [label="compilation.SyntaxTrees 828334"];
7706 [label="_syntaxAndDeclarations.GetLazyState() 828335"];
7707 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 828336"];
7708 [label="param ReportUnprocessed(TextSpan? filterSpanWithinTree) 828337"];
7709 [label="param ReportUnprocessed(DiagnosticBag diagnostics) 828338"];
7710 [label="param ReportUnprocessed(CancellationToken cancellationToken) 828339"];
7711 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 828340"];
7712 [label="return FilterAndAppendAndFreeDiagnostics(diagnostics, ref xmlDiagnostics, cancellationToken); 828341"];
7713 [label="param ReportUnusedImports(SyntaxTree? filterTree) 828342"];
7714 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 828343"];
7715 [label="param ReportUnusedImports(CancellationToken cancellationToken) 828344"];
7716 [label="param ReportUnusedImports(this) 828345"];
7717 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 828346"];
7718 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 828347"];
7719 [label="CompleteTrees(filterTree); 828348"];
7720 [label="CompleteTrees(filterTree) 828349"];
7721 [label="param CompleteTrees(SyntaxTree? filterTree) 828350"];
7722 [label="param CompleteTrees(this) 828351"];
7723 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 828352"];
7724 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 828353"];
7725 [label="CompleteTrees(filterTree); 828354"];
7726 [label="this.SourceModule 828355"];
7727 [label="Assembly 828356"];
7728 [label="SourceAssembly 828357"];
7729 [label="GetBoundReferenceManager() 828358"];
7730 [label="GetBoundReferenceManager(); 828359"];
7731 [label="return Assembly.Modules[0]; 828360"];
7732 [label="SourceAssembly 828361"];
7733 [label="GetBoundReferenceManager() 828362"];
7734 [label="GetBoundReferenceManager(); 828363"];
7735 [label="SourceAssembly.IsDelaySigned 828364"];
7736 [label="param GetCorLibraryReferenceToEmit(CodeAnalysis.Emit.EmitContext context) 828365"];
7737 [label="param GetCorLibraryReferenceToEmit(this) 828366"];
7738 [label="CorLibrary 828367"];
7739 [label="get { return SourceModule.ContainingSourceAssembly.CorLibrary; } 828368"];
7740 [label="return SourceModule.ContainingSourceAssembly.CorLibrary; 828369"];
7741 [label="AssemblySymbol corLibrary = CorLibrary; 828370"];
7742 [label="if (!corLibrary.IsMissing &&\n                !corLibrary.IsLinked &&\n                !ReferenceEquals(corLibrary, SourceModule.ContainingAssembly))\n            {\n                return Translate(corLibrary, context.Diagnostics);\n            } 828371"];
7743 [label="return null; 828372"];
7744 [label="param GetFiles(EmitContext context) 828373"];
7745 [label="=> SpecializedCollections.EmptyEnumerable<Cci.IFileReference>() 828374"];
7746 [label="SpecializedCollections.EmptyEnumerable<Cci.IFileReference>() 828375"];
7747 [label="param GetAnonymousTypeDefinitions(EmitContext context) 828376"];
7748 [label="if (context.MetadataOnly)\n            {\n                return SpecializedCollections.EmptyEnumerable<Cci.INamespaceTypeDefinition>();\n            } 828377"];
7749 [label="Compilation.AnonymousTypeManager 828378"];
7750 [label="return Compilation.AnonymousTypeManager.GetAllCreatedTemplates()\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n\n#endif\n                   ; 828379"];
7751 [label="return GetAdditionalTopLevelTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 828380"];
7752 [label="return GetEmbeddedTypes(context.Diagnostics)\n#if DEBUG\n                   .Select(type => type.GetCciAdapter())\n#endif\n                   ; 828381"];
7753 [label="param GetTopLevelSourceTypeDefinitions(EmitContext context) 828382"];
7754 [label="var namespacesToProcess = new Stack<NamespaceSymbol>(); 828383"];
7755 [label="while (namespacesToProcess.Count > 0)\n            {\n                var ns = namespacesToProcess.Pop();\n                foreach (var member in ns.GetMembers())\n                {\n                    if (member.Kind == SymbolKind.Namespace)\n                    {\n                        namespacesToProcess.Push((NamespaceSymbol)member);\n                    }\n                    else\n                    {\n                        yield return ((NamedTypeSymbol)member).GetCciAdapter();\n                    }\n                }\n            } 828384"];
7756 [label="Debug.Assert(symbol.IsDefinition); 828385"];
7757 [label="SourceModule 828386"];
7758 [label="Assembly 828387"];
7759 [label="SourceAssembly 828388"];
7760 [label="GetBoundReferenceManager() 828389"];
7761 [label="GetBoundReferenceManager(); 828390"];
7762 [label="return Assembly.Modules[0]; 828391"];
7763 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 828392"];
7764 [label="EmitNullablePublicOnly 828393"];
7765 [label="param SynthesizeNullableAttributeIfNecessary(Symbol symbol) 828394"];
7766 [label="Compilation.SourceModule 828395"];
7767 [label="Assembly 828396"];
7768 [label="SourceAssembly 828397"];
7769 [label="GetBoundReferenceManager() 828398"];
7770 [label="GetBoundReferenceManager(); 828399"];
7771 [label="return Assembly.Modules[0]; 828400"];
7772 [label="if ((object)Compilation.SourceModule != symbol.ContainingModule)\n            {\n                // For symbols that are not defined in the same compilation (like NoPia), don't synthesize this attribute.\n                return null;\n            } 828401"];
7773 [label="if ((object)Compilation.SourceModule != symbol.ContainingModule)\n            {\n                // For symbols that are not defined in the same compilation (like NoPia), don't synthesize this attribute.\n                return null;\n            } 828402"];
7774 [label="var flagsBuilder = ArrayBuilder<byte>.GetInstance(); 828403"];
7775 [label="type.AddNullableTransforms(flagsBuilder); 828404"];
7776 [label="SynthesizedAttributeData attribute; 828405"];
7777 [label="param SynthesizeNullableAttributeIfNecessary(this) 828406"];
7778 [label="param GetSynthesizedNestedTypes(NamedTypeSymbol container) 828407"];
7779 [label="param GetSynthesizedNestedTypes(this) 828408"];
7780 [label="return null; 828409"];
7781 [label="return SourceModule.ContainingSourceAssembly\n                .GetCustomAttributesToEmit(this, isRefAssembly, emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); 828410"];
7782 [label="return SourceModule.ContainingSourceAssembly.GetSecurityAttributes(); 828411"];
7783 [label="return SourceModule.GetCustomAttributesToEmit(this); 828412"];
7784 [label="param Translate(SyntaxNode syntaxNodeOpt) 828413"];
7785 [label="param Translate(DiagnosticBag diagnostics) 828414"];
7786 [label="Debug.Assert(diagnostics != null); 828415"];
7787 [label="Debug.Assert(diagnostics != null); 828416"];
7788 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 828417"];
7789 [label="return Translate((NamedTypeSymbol)typeSymbol, syntaxNodeOpt, diagnostics); 828418"];
7790 [label="param Translate(SyntaxNode syntaxNodeOpt) 828419"];
7791 [label="param Translate(DiagnosticBag diagnostics) 828420"];
7792 [label="param Translate(bool fromImplements = false) 828421"];
7793 [label="param Translate(bool needDeclaration = false) 828422"];
7794 [label="Debug.Assert(diagnostics != null); 828423"];
7795 [label="Debug.Assert(diagnostics != null); 828424"];
7796 [label="if (namedTypeSymbol.IsAnonymousType)\n            {\n                Debug.Assert(!needDeclaration);\n                namedTypeSymbol = AnonymousTypeManager.TranslateAnonymousTypeSymbol(namedTypeSymbol);\n            }\n            else if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 828425"];
7797 [label="if (namedTypeSymbol.IsTupleType)\n            {\n                CheckTupleUnderlyingType(namedTypeSymbol, syntaxNodeOpt, diagnostics);\n            } 828426"];
7798 [label="if (namedTypeSymbol.OriginalDefinition.Kind == SymbolKind.ErrorType)\n            {\n                ErrorTypeSymbol errorType = (ErrorTypeSymbol)namedTypeSymbol.OriginalDefinition;\n                DiagnosticInfo diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n\n                if (diagInfo == null && namedTypeSymbol.Kind == SymbolKind.ErrorType)\n                {\n                    errorType = (ErrorTypeSymbol)namedTypeSymbol;\n                    diagInfo = errorType.GetUseSiteDiagnostic() ?? errorType.ErrorInfo;\n                }\n\n                // Try to decrease noise by not complaining about the same type over and over again.\n                if (_reportedErrorTypesMap.Add(errorType))\n                {\n                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty), syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location));\n                }\n\n                return CodeAnalysis.Emit.ErrorType.Singleton;\n            } 828427"];
7799 [label="if (!namedTypeSymbol.IsDefinition)\n            {\n                // generic instantiation for sure\n                Debug.Assert(!needDeclaration);\n\n                if (namedTypeSymbol.IsUnboundGenericType)\n                {\n                    namedTypeSymbol = namedTypeSymbol.OriginalDefinition;\n                }\n                else\n                {\n                    return (Cci.INamedTypeReference)GetCciAdapter(namedTypeSymbol);\n                }\n            }\n            else if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 828428"];
7800 [label="if (!needDeclaration)\n            {\n                object reference;\n                Cci.INamedTypeReference typeRef;\n\n                NamedTypeSymbol container = namedTypeSymbol.ContainingType;\n\n                if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                }\n            } 828429"];
7801 [label="object reference; 828430"];
7802 [label="Cci.INamedTypeReference typeRef; 828431"];
7803 [label="NamedTypeSymbol container = namedTypeSymbol.ContainingType; 828432"];
7804 [label="if (namedTypeSymbol.Arity > 0)\n                {\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    if ((object)container != null)\n                    {\n                        if (IsGenericType(container))\n                        {\n                            // Container is a generic instance too.\n                            typeRef = new SpecializedGenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                        else\n                        {\n                            typeRef = new GenericNestedTypeInstanceReference(namedTypeSymbol);\n                        }\n                    }\n                    else\n                    {\n                        typeRef = new GenericNamespaceTypeInstanceReference(namedTypeSymbol);\n                    }\n\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 828433"];
7805 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 828434"];
7806 [label="IsGenericType(container) 828435"];
7807 [label="param IsGenericType(NamedTypeSymbol toCheck) 828436"];
7808 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 828437"];
7809 [label="while ((object)toCheck != null)\n            {\n                if (toCheck.Arity > 0)\n                {\n                    return true;\n                }\n\n                toCheck = toCheck.ContainingType;\n            } 828438"];
7810 [label="return false; 828439"];
7811 [label="if (IsGenericType(container))\n                {\n                    Debug.Assert((object)container != null);\n\n                    if (_genericInstanceMap.TryGetValue(namedTypeSymbol, out reference))\n                    {\n                        return (Cci.INamedTypeReference)reference;\n                    }\n\n                    typeRef = new SpecializedNestedTypeReference(namedTypeSymbol);\n                    typeRef = (Cci.INamedTypeReference)_genericInstanceMap.GetOrAdd(namedTypeSymbol, typeRef);\n\n                    return typeRef;\n                }\n                else if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 828440"];
7812 [label="if (namedTypeSymbol.NativeIntegerUnderlyingType is NamedTypeSymbol underlyingType)\n                {\n                    namedTypeSymbol = underlyingType;\n                } 828441"];
7813 [label="Debug.Assert(namedTypeSymbol.IsDefinition); 828442"];
7814 [label="param Translate(DiagnosticBag diagnostics) 828443"];
7815 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 828444"];
7816 [label="if (ReferenceEquals(SourceModule, module))\n            {\n                return this;\n            } 828445"];
7817 [label="if ((object)module == null)\n            {\n                return null;\n            } 828446"];
7818 [label="if ((object)module == null)\n            {\n                return null;\n            } 828447"];
7819 [label="Cci.IModuleReference moduleRef; 828448"];
7820 [label="if (AssemblyOrModuleSymbolToModuleRefMap.TryGetValue(module, out moduleRef))\n            {\n                return moduleRef;\n            } 828449"];
7821 [label="TranslateModule(module, diagnostics) 828450"];
7822 [label="param TranslateModule(DiagnosticBag diagnostics) 828451"];
7823 [label="if ((object)container != null && ReferenceEquals(container.Modules[0], module))\n            {\n                Cci.IModuleReference moduleRef = new AssemblyReference(container);\n                Cci.IModuleReference cachedModuleRef = AssemblyOrModuleSymbolToModuleRefMap.GetOrAdd(container, moduleRef);\n\n                if (cachedModuleRef == moduleRef)\n                {\n                    ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics);\n                }\n                else\n                {\n                    moduleRef = cachedModuleRef;\n                }\n\n                return moduleRef;\n            }\n            else\n            {\n                return new ModuleReference(this, module);\n            } 828452"];
7824 [label="_targetAssembly 828453"];
7825 [label="Debug.Assert((object)assemblySymbol != null); 828454"];
7826 [label="ValidateReferencedAssembly(container, (AssemblyReference)moduleRef, diagnostics); 828455"];
7827 [label="param ValidateReferencedAssembly(AssemblyReference asmRef) 828456"];
7828 [label="param ValidateReferencedAssembly(DiagnosticBag diagnostics) 828457"];
7829 [label="param ValidateReferencedAssembly(this) 828458"];
7830 [label="AssemblyIdentity asmIdentity = SourceModule.ContainingAssembly.Identity; 828459"];
7831 [label="asmRef.Identity 828460"];
7832 [label="=> _targetAssembly.Identity 828461"];
7833 [label="AssemblyIdentity refIdentity = asmRef.Identity; 828462"];
7834 [label="if (asmIdentity.IsStrongName && !refIdentity.IsStrongName &&\n                asmRef.Identity.ContentType != AssemblyContentType.WindowsRuntime)\n            {\n                // Dev12 reported error, we have changed it to a warning to allow referencing libraries \n                // built for platforms that don't support strong names.\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName, assembly), NoLocation.Singleton);\n            } 828463"];
7835 [label="if (OutputKind != OutputKind.NetModule &&\n               !string.IsNullOrEmpty(refIdentity.CultureName) &&\n               !string.Equals(refIdentity.CultureName, asmIdentity.CultureName, StringComparison.OrdinalIgnoreCase))\n            {\n                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch, assembly, refIdentity.CultureName), NoLocation.Singleton);\n            } 828464"];
7836 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 828465"];
7837 [label="if (_embeddedTypesManagerOpt != null && _embeddedTypesManagerOpt.IsFrozen)\n            {\n                _embeddedTypesManagerOpt.ReportIndirectReferencesToLinkedAssemblies(assembly, diagnostics);\n            } 828466"];
7838 [label="param GetExportedTypes(DiagnosticBag diagnostics) 828467"];
7839 [label="Debug.Assert(HaveDeterminedTopLevelTypes); 828468"];
7840 [label="if (!OutputKind.IsNetModule())\n            {\n                var modules = sourceAssembly.Modules;\n                for (int i = 1; i < modules.Length; i++) //NOTE: skipping modules[0]\n                {\n                    GetExportedTypes(modules[i].GlobalNamespace, -1, builder);\n                }\n            } 828469"];
7841 [label="Debug.Assert(OutputKind.IsNetModule() == sourceAssembly.DeclaringCompilation.Options.OutputKind.IsNetModule()); 828470"];
7842 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 828471"];
7843 [label="GetForwardedTypes(seenTopLevelForwardedTypes, sourceAssembly.GetSourceDecodedWellKnownAttributeData(), builder) 828472"];
7844 [label="param GetForwardedTypes(HashSet<NamedTypeSymbol> seenTopLevelTypes) 828473"];
7845 [label="param GetForwardedTypes(CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData) 828474"];
7846 [label="param GetForwardedTypes(ArrayBuilder<Cci.ExportedType>? builder) 828475"];
7847 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 828476"];
7848 [label="if (wellKnownAttributeData != null && wellKnownAttributeData.ForwardedTypes != null && wellKnownAttributeData.ForwardedTypes.Count > 0)\n            {\n                // (type, index of the parent exported type in builder, or -1 if the type is a top-level type)\n                var stack = ArrayBuilder<(NamedTypeSymbol type, int parentIndex)>.GetInstance();\n\n                // Hashset enumeration is not guaranteed to be deterministic. Emitting in the order of fully qualified names.\n                IEnumerable<NamedTypeSymbol> orderedForwardedTypes = wellKnownAttributeData.ForwardedTypes;\n\n                if (builder is object)\n                {\n                    orderedForwardedTypes = orderedForwardedTypes.OrderBy(t => t.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.QualifiedNameArityFormat));\n                }\n\n                foreach (NamedTypeSymbol forwardedType in orderedForwardedTypes)\n                {\n                    NamedTypeSymbol originalDefinition = forwardedType.OriginalDefinition;\n                    Debug.Assert((object)originalDefinition.ContainingType == null, 'How did a nested type get forwarded?');\n\n                    // Since we need to allow multiple constructions of the same generic type at the source\n                    // level, we need to de-dup the original definitions before emitting.\n                    if (!seenTopLevelTypes.Add(originalDefinition)) continue;\n\n                    if (builder is object)\n                    {\n                        // Return all nested types.\n                        // Note the order: depth first, children in reverse order (to match dev10, not a requirement).\n                        Debug.Assert(stack.Count == 0);\n                        stack.Push((originalDefinition, -1));\n\n                        while (stack.Count > 0)\n                        {\n                            var (type, parentIndex) = stack.Pop();\n\n                            // In general, we don't want private types to appear in the ExportedTypes table.\n                            // BREAK: dev11 emits these types.  The problem was discovered in dev10, but failed\n                            // to meet the bar Bug: Dev10/258038 and was left as-is.\n                            if (type.DeclaredAccessibility == Accessibility.Private)\n                            {\n                                // NOTE: this will also exclude nested types of type\n                                continue;\n                            }\n\n                            // NOTE: not bothering to put nested types in seenTypes - the top-level type is adequate protection.\n\n                            int index = builder.Count;\n                            builder.Add(new Cci.ExportedType(type.GetCciAdapter(), parentIndex, isForwarder: true));\n\n                            // Iterate backwards so they get popped in forward order.\n                            ImmutableArray<NamedTypeSymbol> nested = type.GetTypeMembers(); // Ordered.\n                            for (int i = nested.Length - 1; i >= 0; i--)\n                            {\n                                stack.Push((nested[i], index));\n                            }\n                        }\n                    }\n                }\n\n                stack.Free();\n            } 828477"];
7849 [label="return seenTopLevelForwardedTypes; 828478"];
7850 [label="if (_lazyExportedTypes.Length > 0)\n                {\n                    ReportExportedTypeNameCollisions(_lazyExportedTypes, diagnostics);\n                } 828479"];
7851 [label="=> ImmutableArray<Cci.UsedNamespaceOrType>.Empty 828480"];
7852 [label="ImmutableArray<Cci.UsedNamespaceOrType>.Empty 828481"];
7853 [label="=> null 828482"];
7854 [label="null 828483"];
7855 [label="param IsPlatformType(this) 828484"];
7856 [label="if ((object)namedType != null)\n            {\n                if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                }\n\n                return namedType.SpecialType == (SpecialType)platformType;\n            } 828485"];
7857 [label="if (platformType == Cci.PlatformType.SystemType)\n                {\n                    return (object)namedType == (object)Compilation.GetWellKnownType(WellKnownType.System_Type);\n                } 828486"];
7858 [label="var result = new MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation>(); 828487"];
7859 [label="var namespacesAndTypesToProcess = new Stack<NamespaceOrTypeSymbol>(); 828488"];
7860 [label="Location location = null; 828489"];
7861 [label="while (namespacesAndTypesToProcess.Count > 0)\n            {\n                NamespaceOrTypeSymbol symbol = namespacesAndTypesToProcess.Pop();\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Namespace:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n\n                        // filtering out synthesized symbols not having real source \n                        // locations such as anonymous types, etc...\n                        if (location != null)\n                        {\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.Namespace:\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    case SymbolKind.NamedType:\n                        location = GetSmallestSourceLocationOrNull(symbol);\n                        if (location != null)\n                        {\n                            //  add this named type location\n                            AddSymbolLocation(result, location, (Cci.IDefinition)symbol.GetCciAdapter());\n\n                            foreach (var member in symbol.GetMembers())\n                            {\n                                switch (member.Kind)\n                                {\n                                    case SymbolKind.NamedType:\n                                        namespacesAndTypesToProcess.Push((NamespaceOrTypeSymbol)member);\n                                        break;\n\n                                    case SymbolKind.Method:\n                                        // NOTE: Dev11 does not add synthesized static constructors to this map,\n                                        //       but adds synthesized instance constructors, Roslyn adds both\n                                        var method = (MethodSymbol)member;\n                                        if (!method.ShouldEmit())\n                                        {\n                                            break;\n                                        }\n\n                                        AddSymbolLocation(result, member);\n                                        break;\n\n                                    case SymbolKind.Property:\n                                        AddSymbolLocation(result, member);\n                                        break;\n                                    case SymbolKind.Field:\n                                        // NOTE: Dev11 does not add synthesized backing fields for properties,\n                                        //       but adds backing fields for events, Roslyn adds both\n                                        {\n                                            var field = (FieldSymbol)member;\n                                            AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                        }\n                                        break;\n\n                                    case SymbolKind.Event:\n                                        AddSymbolLocation(result, member);\n                                        //  event backing fields do not show up in GetMembers\n                                        {\n                                            FieldSymbol field = ((EventSymbol)member).AssociatedField;\n                                            if ((object)field != null)\n                                            {\n                                                AddSymbolLocation(result, field.TupleUnderlyingField ?? field);\n                                            }\n                                        }\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(member.Kind);\n                                }\n                            }\n                        }\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n                }\n            } 828490"];
7862 [label="param GetSmallestSourceLocationOrNull(this) 828491"];
7863 [label="CSharpCompilation compilation = symbol.DeclaringCompilation; 828492"];
7864 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 828493"];
7865 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 828494"];
7866 [label="param AddSymbolLocation(MultiDictionary<Cci.DebugSourceDocument, Cci.DefinitionWithLocation> result) 828495"];
7867 [label="param AddSymbolLocation(Cci.IDefinition definition) 828496"];
7868 [label="if (doc != null)\n            {\n                result.Add(doc,\n                           new Cci.DefinitionWithLocation(\n                               definition,\n                               span.StartLinePosition.Line,\n                               span.StartLinePosition.Character,\n                               span.EndLinePosition.Line,\n                               span.EndLinePosition.Character));\n            } 828497"];
7869 [label="param GetSmallestSourceLocationOrNull(this) 828498"];
7870 [label="Debug.Assert(Compilation == compilation, 'How did we get symbol from different compilation?'); 828499"];
7871 [label="return result; 828500"];
7872 [label="SourceAssembly 828501"];
7873 [label="GetBoundReferenceManager() 828502"];
7874 [label="GetBoundReferenceManager(); 828503"];
7875 [label="c.GetEmitDiagnostics(options: options).Verify(expected); 828504"];
7876 [label="c.GetEmitDiagnostics(options: options).Verify(expected) 828505"];
7877 [label="param Verify(params DiagnosticDescription[] expected) 828506"];
7878 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 828507"];
7879 [label="Verify((IEnumerable<Diagnostic>)actual, expected) 828508"];
7880 [label="param Verify(params DiagnosticDescription[] expected) 828509"];
7881 [label="Verify(actual, expected, errorCodeOnly: false); 828510"];
7882 [label="Verify(actual, expected, errorCodeOnly: false); 828511"];
7883 [label="Verify(actual, expected, errorCodeOnly: false) 828512"];
7884 [label="param Verify(DiagnosticDescription[] expected) 828513"];
7885 [label="param Verify(bool errorCodeOnly) 828514"];
7886 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 828515"];
7887 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 828516"];
7888 [label="var includeDefaultSeverity = expected.Any() && expected.All(e => e.DefaultSeverity != null); 828517"];
7889 [label="var includeEffectiveSeverity = expected.Any() && expected.All(e => e.EffectiveSeverity != null); 828518"];
7890 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 828519"];
7891 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 828520"];
7892 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 828521"];
7893 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 828522"];
7894 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 828523"];
7895 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 828524"];
7896 [label="DiagnosticDescription.GetAssertText(expected, actual) 828525"];
7897 [label="param GetAssertText(DiagnosticDescription[] expected) 828526"];
7898 [label="const int CSharp = 1; 828527"];
7899 [label="const int VisualBasic = 2; 828528"];
7900 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 828529"];
7901 [label="actual.Any() && actual.First() is CSDiagnostic 828530"];
7902 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 828531"];
7903 [label="var includeDiagnosticMessagesAsComments = (language == CSharp); 828532"];
7904 [label="int indentDepth = (language == CSharp) ? 4 : 1; 828533"];
7905 [label="(language == CSharp) 828534"];
7906 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 828535"];
7907 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 828536"];
7908 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 828537"];
7909 [label="IsSortedOrEmpty(expected) 828538"];
7910 [label="param IsSortedOrEmpty(DiagnosticDescription[] diagnostics) 828539"];
7911 [label="var comparer = LinePositionComparer.Instance; 828540"];
7912 [label="DiagnosticDescription last = null; 828541"];
7913 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 828542"];
7914 [label="return true; 828543"];
7915 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 828544"];
7916 [label="Sort(actual) 828545"];
7917 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 828546"];
7918 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 828547"];
7919 [label="var assertText = new StringBuilder(); 828548"];
7920 [label="assertText.AppendLine(); 828549"];
7921 [label="int i; 828550"];
7922 [label="assertText.AppendLine('Expected:'); 828551"];
7923 [label="assertText.AppendLine('Expected:'); 828552"];
7924 [label="var expectedText = ArrayBuilder<string>.GetInstance(); 828553"];
7925 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 828554"];
7926 [label="GetCommaSeparatedLines(assertText, expectedText); 828555"];
7927 [label="GetCommaSeparatedLines(assertText, expectedText); 828556"];
7928 [label="GetCommaSeparatedLines(assertText, expectedText) 828557"];
7929 [label="param GetCommaSeparatedLines(StringBuilder sb) 828558"];
7930 [label="param GetCommaSeparatedLines(ArrayBuilder<string> lines) 828559"];
7931 [label="int n = lines.Count; 828560"];
7932 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 828561"];
7933 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 828562"];
7934 [label="GetCommaSeparatedLines(assertText, expectedText); 828563"];
7935 [label="assertText.AppendLine('Actual:'); 828564"];
7936 [label="assertText.AppendLine('Actual:'); 828565"];
7937 [label="var actualText = ArrayBuilder<string>.GetInstance(); 828566"];
7938 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 828567"];
7939 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 828568"];
7940 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 828569"];
7941 [label="assertText.AppendLine('Diff:'); 828570"];
7942 [label="assertText.AppendLine('Diff:'); 828571"];
7943 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 828572"];
7944 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 828573"];
7945 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 828574"];
7946 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 828575"];
7947 [label="DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine) 828576"];
7948 [label="param DiffReport(IEnumerable<T> expected) 828577"];
7949 [label="param DiffReport(IEnumerable<T> actual) 828578"];
7950 [label="param DiffReport(string separator) 828579"];
7951 [label="param DiffReport(IEqualityComparer<T> comparer = null) 828580"];
7952 [label="param DiffReport(Func<T, string> toString = null) 828581"];
7953 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 828582"];
7954 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 828583"];
7955 [label="(comparer != null) 828584"];
7956 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 828585"];
7957 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 828586"];
7958 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 828587"];
7959 [label="IList<T> expectedList = expected as IList<T> ?? new List<T>(expected); 828588"];
7960 [label="IList<T> actualList = actual as IList<T> ?? new List<T>(actual); 828589"];
7961 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 828590"];
7962 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 828591"];
7963 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 828592"];
7964 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 828593"];
7965 [label="lcs.CalculateDiff(expectedList, actualList, toString) 828594"];
7966 [label="param CalculateDiff(IList<T> sequenceA) 828595"];
7967 [label="param CalculateDiff(IList<T> sequenceB) 828596"];
7968 [label="param CalculateDiff(Func<T, string> toString) 828597"];
7969 [label="param CalculateDiff(this) 828598"];
7970 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 828599"];
7971 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 828600"];
7972 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 828601"];
7973 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 828602"];
7974 [label="GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count) 828603"];
7975 [label="param GetEdits(TSequence sequenceA) 828604"];
7976 [label="param GetEdits(int lengthA) 828605"];
7977 [label="param GetEdits(TSequence sequenceB) 828606"];
7978 [label="param GetEdits(int lengthB) 828607"];
7979 [label="param GetEdits(this) 828608"];
7980 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 828609"];
7981 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 828610"];
7982 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 828611"];
7983 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 828612"];
7984 [label="ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB) 828613"];
7985 [label="param ComputeCostMatrix(TSequence sequenceA) 828614"];
7986 [label="param ComputeCostMatrix(int lengthA) 828615"];
7987 [label="param ComputeCostMatrix(TSequence sequenceB) 828616"];
7988 [label="param ComputeCostMatrix(int lengthB) 828617"];
7989 [label="param ComputeCostMatrix(this) 828618"];
7990 [label="var la = lengthA + 1; 828619"];
7991 [label="var la = lengthA + 1; 828620"];
7992 [label="var lb = lengthB + 1; 828621"];
7993 [label="var lb = lengthB + 1; 828622"];
7994 [label="var d = new int[la, lb]; 828623"];
7995 [label="d[0, 0] = 0; 828624"];
7996 [label="d[0, 0] 828625"];
7997 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 828626"];
7998 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 828627"];
7999 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 828628"];
8000 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 828629"];
8001 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 828630"];
8002 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 828631"];
8003 [label="return d; 828632"];
8004 [label="int i = lengthA; 828633"];
8005 [label="int j = lengthB; 828634"];
8006 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 828635"];
8007 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 828636"];
8008 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 828637"];
8009 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 828638"];
8010 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 828639"];
8011 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 828640"];
8012 [label="param GetEdits(this) 828641"];
8013 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 828642"];
8014 [label="param CalculateDiff(this) 828643"];
8015 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 828644"];
8016 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 828645"];
8017 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 828646"];
8018 [label="actualText.Free(); 828647"];
8019 [label="expectedText.Free(); 828648"];
8020 [label="return assertText.ToString(); 828649"];
8021 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 828650"];
8022 [label="Verify((IEnumerable<Diagnostic>)actual, expected); 828651"];
8023 [label="return c; 828652"];
2 -> 0;
2 -> 1;
3 -> 1;
4 -> 3;
5 -> 4;
6 -> 5;
7 -> 6;
8 -> 7;
8 -> 6;
9 -> 1;
9 -> 2;
9 -> 8;
10 -> 1;
11 -> 1;
12 -> 1;
13 -> 12;
13 -> 1;
14 -> 0;
14 -> 1;
15 -> 1;
16 -> 13;
16 -> 15;
17 -> 16;
17 -> 15;
18 -> 15;
19 -> 17;
19 -> 18;
20 -> 18;
21 -> 19;
21 -> 20;
21 -> 18;
22 -> 13;
22 -> 15;
23 -> 13;
23 -> 15;
24 -> 13;
24 -> 15;
25 -> 13;
25 -> 15;
26 -> 13;
26 -> 15;
27 -> 13;
27 -> 15;
28 -> 13;
28 -> 15;
29 -> 13;
29 -> 15;
30 -> 22;
30 -> 15;
31 -> 23;
31 -> 15;
32 -> 24;
32 -> 15;
33 -> 25;
33 -> 15;
34 -> 26;
34 -> 15;
35 -> 27;
35 -> 15;
36 -> 28;
36 -> 15;
37 -> 15;
38 -> 37;
38 -> 15;
39 -> 15;
40 -> 30;
40 -> 39;
41 -> 31;
41 -> 39;
42 -> 32;
42 -> 39;
43 -> 33;
43 -> 39;
44 -> 34;
44 -> 39;
45 -> 35;
45 -> 39;
46 -> 36;
46 -> 39;
47 -> 38;
47 -> 39;
48 -> 43;
48 -> 39;
49 -> 45;
49 -> 39;
50 -> 39;
51 -> 48;
51 -> 50;
52 -> 49;
52 -> 50;
53 -> 40;
53 -> 50;
54 -> 53;
54 -> 21;
54 -> 50;
55 -> 54;
56 -> 52;
56 -> 54;
57 -> 51;
57 -> 54;
58 -> 54;
59 -> 55;
59 -> 58;
60 -> 56;
60 -> 58;
61 -> 57;
61 -> 58;
62 -> 55;
62 -> 58;
63 -> 58;
64 -> 61;
64 -> 63;
64 -> 58;
65 -> 0;
65 -> 64;
66 -> 59;
66 -> 58;
67 -> 0;
67 -> 58;
68 -> 67;
68 -> 62;
68 -> 58;
69 -> 58;
70 -> 66;
70 -> 68;
70 -> 69;
70 -> 0;
70 -> 58;
71 -> 70;
71 -> 58;
72 -> 65;
72 -> 58;
73 -> 60;
73 -> 58;
74 -> 58;
75 -> 71;
75 -> 72;
75 -> 73;
75 -> 74;
75 -> 70;
75 -> 0;
75 -> 58;
76 -> 58;
77 -> 75;
77 -> 76;
78 -> 76;
79 -> 76;
80 -> 77;
80 -> 75;
80 -> 79;
80 -> 76;
81 -> 78;
81 -> 76;
82 -> 76;
83 -> 80;
83 -> 75;
83 -> 79;
83 -> 81;
83 -> 82;
83 -> 78;
83 -> 76;
84 -> 76;
85 -> 84;
85 -> 78;
85 -> 76;
86 -> 78;
86 -> 76;
87 -> 76;
88 -> 86;
88 -> 87;
88 -> 78;
88 -> 85;
88 -> 76;
89 -> 77;
89 -> 76;
90 -> 89;
90 -> 55;
90 -> 54;
91 -> 55;
91 -> 39;
92 -> 39;
93 -> 42;
93 -> 92;
93 -> 39;
94 -> 0;
94 -> 39;
95 -> 47;
95 -> 39;
96 -> 44;
96 -> 91;
96 -> 41;
96 -> 42;
96 -> 39;
97 -> 96;
97 -> 39;
98 -> 39;
99 -> 97;
99 -> 98;
100 -> 0;
100 -> 98;
101 -> 100;
102 -> 39;
103 -> 0;
105 -> 103;
105 -> 104;
106 -> 105;
107 -> 0;
109 -> 107;
109 -> 108;
111 -> 109;
111 -> 110;
112 -> 111;
113 -> 96;
113 -> 55;
113 -> 90;
113 -> 75;
113 -> 21;
113 -> 39;
114 -> 39;
115 -> 113;
115 -> 114;
116 -> 113;
116 -> 114;
117 -> 113;
117 -> 114;
118 -> 113;
118 -> 114;
119 -> 115;
119 -> 114;
120 -> 118;
120 -> 114;
121 -> 116;
121 -> 114;
122 -> 117;
122 -> 114;
123 -> 114;
124 -> 114;
125 -> 119;
125 -> 124;
126 -> 120;
126 -> 124;
127 -> 121;
127 -> 124;
128 -> 122;
128 -> 124;
129 -> 123;
129 -> 124;
130 -> 123;
130 -> 124;
131 -> 123;
131 -> 124;
132 -> 123;
132 -> 124;
133 -> 124;
134 -> 126;
134 -> 133;
134 -> 124;
135 -> 132;
135 -> 124;
136 -> 128;
136 -> 124;
137 -> 125;
137 -> 124;
138 -> 126;
138 -> 124;
139 -> 136;
139 -> 124;
140 -> 129;
140 -> 124;
141 -> 130;
141 -> 124;
142 -> 131;
142 -> 124;
143 -> 132;
143 -> 124;
144 -> 124;
145 -> 0;
145 -> 124;
146 -> 126;
146 -> 136;
146 -> 124;
147 -> 124;
148 -> 145;
148 -> 147;
149 -> 146;
149 -> 147;
150 -> 146;
150 -> 147;
151 -> 145;
151 -> 147;
152 -> 143;
152 -> 147;
153 -> 144;
153 -> 147;
154 -> 144;
154 -> 147;
155 -> 148;
155 -> 147;
156 -> 149;
156 -> 147;
157 -> 150;
157 -> 147;
158 -> 151;
158 -> 147;
159 -> 152;
159 -> 147;
160 -> 147;
161 -> 160;
161 -> 155;
161 -> 156;
161 -> 157;
161 -> 158;
161 -> 159;
161 -> 0;
161 -> 136;
161 -> 147;
162 -> 160;
162 -> 147;
163 -> 153;
163 -> 160;
163 -> 147;
164 -> 124;
165 -> 137;
165 -> 164;
166 -> 138;
166 -> 164;
167 -> 139;
167 -> 164;
168 -> 140;
168 -> 164;
169 -> 141;
169 -> 164;
170 -> 142;
170 -> 164;
171 -> 143;
171 -> 164;
172 -> 144;
172 -> 164;
173 -> 144;
173 -> 164;
174 -> 144;
174 -> 164;
175 -> 144;
175 -> 164;
176 -> 144;
176 -> 164;
177 -> 144;
177 -> 164;
178 -> 165;
178 -> 164;
179 -> 166;
179 -> 164;
180 -> 167;
180 -> 164;
181 -> 168;
181 -> 164;
182 -> 169;
182 -> 164;
183 -> 170;
183 -> 164;
184 -> 171;
184 -> 164;
185 -> 172;
185 -> 164;
186 -> 173;
186 -> 164;
187 -> 174;
187 -> 164;
188 -> 174;
188 -> 161;
188 -> 164;
189 -> 188;
189 -> 161;
189 -> 162;
189 -> 163;
189 -> 164;
190 -> 175;
190 -> 164;
191 -> 176;
191 -> 164;
192 -> 164;
193 -> 178;
193 -> 192;
194 -> 179;
194 -> 192;
195 -> 180;
195 -> 192;
196 -> 181;
196 -> 192;
197 -> 182;
197 -> 192;
198 -> 183;
198 -> 192;
199 -> 184;
199 -> 192;
200 -> 185;
200 -> 192;
201 -> 186;
201 -> 192;
202 -> 187;
202 -> 192;
203 -> 189;
203 -> 192;
204 -> 190;
204 -> 192;
205 -> 191;
205 -> 192;
206 -> 177;
206 -> 192;
207 -> 193;
207 -> 192;
208 -> 195;
208 -> 192;
209 -> 203;
209 -> 192;
210 -> 199;
210 -> 192;
211 -> 204;
211 -> 192;
212 -> 205;
212 -> 192;
213 -> 192;
214 -> 213;
214 -> 207;
214 -> 208;
214 -> 209;
214 -> 210;
214 -> 211;
214 -> 212;
214 -> 136;
214 -> 189;
214 -> 192;
215 -> 213;
215 -> 192;
216 -> 213;
216 -> 192;
217 -> 213;
217 -> 192;
218 -> 213;
218 -> 192;
219 -> 213;
219 -> 192;
220 -> 213;
220 -> 192;
221 -> 213;
221 -> 192;
222 -> 213;
222 -> 192;
223 -> 213;
223 -> 192;
224 -> 213;
224 -> 192;
225 -> 213;
225 -> 192;
226 -> 213;
226 -> 192;
227 -> 213;
227 -> 192;
228 -> 213;
228 -> 192;
229 -> 213;
229 -> 192;
230 -> 213;
230 -> 192;
231 -> 213;
231 -> 192;
232 -> 213;
232 -> 192;
233 -> 213;
233 -> 192;
234 -> 213;
234 -> 192;
235 -> 213;
235 -> 192;
236 -> 213;
236 -> 192;
237 -> 213;
237 -> 192;
238 -> 213;
238 -> 192;
239 -> 213;
239 -> 192;
240 -> 213;
240 -> 192;
241 -> 192;
242 -> 241;
242 -> 213;
242 -> 192;
243 -> 213;
243 -> 192;
244 -> 243;
244 -> 214;
244 -> 215;
244 -> 216;
244 -> 217;
244 -> 218;
244 -> 219;
244 -> 220;
244 -> 221;
244 -> 222;
244 -> 223;
244 -> 224;
244 -> 225;
244 -> 226;
244 -> 227;
244 -> 228;
244 -> 229;
244 -> 230;
244 -> 231;
244 -> 232;
244 -> 233;
244 -> 234;
244 -> 235;
244 -> 236;
244 -> 237;
244 -> 238;
244 -> 239;
244 -> 240;
244 -> 242;
244 -> 241;
244 -> 192;
245 -> 244;
245 -> 213;
245 -> 192;
246 -> 194;
246 -> 213;
246 -> 192;
247 -> 213;
247 -> 192;
248 -> 192;
249 -> 192;
250 -> 247;
250 -> 249;
251 -> 248;
251 -> 249;
252 -> 251;
252 -> 249;
253 -> 251;
253 -> 249;
254 -> 251;
254 -> 249;
255 -> 250;
255 -> 251;
255 -> 249;
256 -> 248;
256 -> 213;
256 -> 192;
257 -> 213;
257 -> 244;
257 -> 192;
258 -> 257;
258 -> 244;
258 -> 245;
258 -> 246;
258 -> 256;
258 -> 255;
258 -> 253;
258 -> 254;
258 -> 192;
259 -> 258;
259 -> 213;
259 -> 192;
260 -> 213;
260 -> 258;
260 -> 192;
261 -> 260;
261 -> 258;
261 -> 259;
261 -> 192;
262 -> 261;
262 -> 213;
262 -> 192;
263 -> 213;
263 -> 261;
263 -> 192;
264 -> 263;
264 -> 261;
264 -> 262;
264 -> 192;
265 -> 264;
265 -> 213;
265 -> 192;
266 -> 213;
266 -> 264;
266 -> 192;
267 -> 266;
267 -> 264;
267 -> 265;
267 -> 192;
268 -> 267;
268 -> 213;
268 -> 192;
269 -> 213;
269 -> 192;
270 -> 269;
270 -> 267;
270 -> 268;
270 -> 192;
271 -> 270;
271 -> 213;
271 -> 192;
272 -> 202;
272 -> 270;
272 -> 192;
273 -> 192;
274 -> 272;
274 -> 273;
275 -> 273;
276 -> 274;
276 -> 273;
277 -> 276;
277 -> 270;
277 -> 271;
277 -> 273;
278 -> 0;
278 -> 273;
279 -> 278;
279 -> 275;
279 -> 273;
280 -> 279;
280 -> 192;
281 -> 280;
281 -> 213;
281 -> 192;
282 -> 199;
282 -> 192;
283 -> 282;
284 -> 196;
284 -> 283;
284 -> 282;
285 -> 197;
285 -> 283;
285 -> 282;
286 -> 284;
286 -> 285;
286 -> 282;
287 -> 198;
287 -> 283;
287 -> 282;
288 -> 286;
288 -> 287;
288 -> 282;
289 -> 201;
289 -> 192;
290 -> 213;
290 -> 270;
290 -> 271;
290 -> 281;
290 -> 289;
291 -> 289;
292 -> 213;
292 -> 291;
293 -> 292;
293 -> 290;
293 -> 291;
294 -> 200;
294 -> 289;
295 -> 290;
295 -> 293;
295 -> 294;
295 -> 289;
296 -> 295;
296 -> 213;
296 -> 289;
297 -> 202;
297 -> 213;
297 -> 192;
298 -> 213;
298 -> 295;
298 -> 192;
299 -> 192;
300 -> 213;
300 -> 295;
300 -> 299;
300 -> 192;
301 -> 124;
302 -> 127;
302 -> 301;
302 -> 124;
303 -> 127;
303 -> 302;
304 -> 302;
305 -> 303;
305 -> 304;
306 -> 144;
306 -> 304;
307 -> 304;
308 -> 305;
308 -> 307;
308 -> 304;
309 -> 305;
309 -> 304;
310 -> 309;
310 -> 295;
310 -> 296;
310 -> 297;
310 -> 304;
311 -> 304;
312 -> 306;
312 -> 310;
312 -> 304;
313 -> 311;
313 -> 304;
314 -> 312;
314 -> 310;
314 -> 304;
315 -> 313;
315 -> 314;
315 -> 311;
315 -> 310;
315 -> 304;
316 -> 304;
317 -> 304;
318 -> 305;
318 -> 304;
319 -> 318;
319 -> 315;
319 -> 304;
320 -> 319;
321 -> 319;
322 -> 319;
323 -> 306;
323 -> 322;
323 -> 319;
324 -> 319;
325 -> 311;
325 -> 324;
325 -> 322;
325 -> 319;
326 -> 316;
326 -> 319;
326 -> 325;
327 -> 317;
327 -> 319;
328 -> 311;
328 -> 325;
328 -> 304;
329 -> 306;
329 -> 328;
329 -> 304;
330 -> 305;
330 -> 304;
331 -> 304;
332 -> 330;
332 -> 331;
333 -> 312;
333 -> 331;
334 -> 333;
334 -> 328;
334 -> 331;
335 -> 333;
335 -> 328;
335 -> 331;
336 -> 333;
336 -> 328;
336 -> 331;
337 -> 333;
337 -> 328;
337 -> 331;
338 -> 333;
338 -> 328;
338 -> 331;
339 -> 332;
339 -> 331;
340 -> 333;
340 -> 328;
340 -> 339;
340 -> 331;
341 -> 331;
342 -> 338;
342 -> 341;
342 -> 331;
343 -> 340;
343 -> 342;
344 -> 342;
345 -> 343;
345 -> 344;
346 -> 333;
346 -> 344;
347 -> 345;
347 -> 344;
348 -> 346;
348 -> 340;
348 -> 344;
349 -> 344;
350 -> 344;
351 -> 347;
351 -> 350;
352 -> 348;
352 -> 350;
353 -> 348;
353 -> 350;
354 -> 348;
354 -> 350;
355 -> 348;
355 -> 350;
356 -> 349;
356 -> 350;
357 -> 349;
357 -> 350;
358 -> 350;
358 -> 351;
358 -> 352;
358 -> 353;
358 -> 354;
358 -> 355;
358 -> 340;
359 -> 349;
359 -> 342;
360 -> 359;
360 -> 304;
361 -> 306;
361 -> 358;
361 -> 304;
362 -> 326;
362 -> 304;
363 -> 360;
363 -> 304;
364 -> 304;
365 -> 361;
365 -> 364;
366 -> 362;
366 -> 364;
367 -> 363;
367 -> 364;
368 -> 306;
368 -> 364;
369 -> 368;
369 -> 358;
369 -> 364;
370 -> 364;
371 -> 368;
371 -> 370;
372 -> 371;
372 -> 358;
372 -> 370;
373 -> 372;
373 -> 370;
374 -> 373;
374 -> 364;
375 -> 368;
375 -> 358;
375 -> 350;
375 -> 356;
375 -> 364;
376 -> 364;
377 -> 375;
377 -> 376;
378 -> 377;
378 -> 375;
378 -> 376;
379 -> 364;
380 -> 378;
380 -> 379;
381 -> 365;
381 -> 364;
382 -> 366;
382 -> 364;
383 -> 367;
383 -> 364;
384 -> 364;
385 -> 364;
386 -> 369;
386 -> 385;
387 -> 369;
387 -> 385;
388 -> 369;
388 -> 385;
389 -> 374;
389 -> 385;
390 -> 378;
390 -> 385;
391 -> 380;
391 -> 385;
392 -> 380;
392 -> 385;
393 -> 381;
393 -> 385;
394 -> 382;
394 -> 385;
395 -> 383;
395 -> 385;
396 -> 380;
396 -> 385;
397 -> 384;
397 -> 385;
398 -> 384;
398 -> 385;
399 -> 389;
399 -> 385;
400 -> 390;
400 -> 385;
401 -> 391;
401 -> 385;
402 -> 395;
402 -> 380;
402 -> 385;
403 -> 397;
403 -> 385;
404 -> 385;
405 -> 399;
405 -> 404;
406 -> 400;
406 -> 404;
407 -> 401;
407 -> 404;
408 -> 403;
408 -> 404;
409 -> 398;
409 -> 404;
410 -> 408;
410 -> 404;
411 -> 404;
412 -> 411;
412 -> 404;
413 -> 411;
413 -> 404;
414 -> 411;
414 -> 404;
415 -> 411;
415 -> 404;
416 -> 411;
416 -> 404;
417 -> 411;
417 -> 404;
418 -> 411;
418 -> 404;
419 -> 411;
419 -> 404;
420 -> 411;
420 -> 404;
421 -> 411;
421 -> 404;
422 -> 411;
422 -> 404;
423 -> 411;
423 -> 404;
424 -> 411;
424 -> 404;
425 -> 411;
425 -> 404;
426 -> 411;
426 -> 404;
427 -> 411;
427 -> 404;
428 -> 411;
428 -> 404;
429 -> 411;
429 -> 404;
430 -> 411;
430 -> 404;
431 -> 411;
431 -> 404;
432 -> 411;
432 -> 404;
433 -> 411;
433 -> 404;
434 -> 411;
434 -> 404;
435 -> 411;
435 -> 404;
436 -> 411;
436 -> 404;
437 -> 411;
437 -> 404;
438 -> 404;
439 -> 438;
439 -> 411;
439 -> 404;
440 -> 411;
440 -> 404;
441 -> 411;
441 -> 404;
442 -> 404;
443 -> 404;
444 -> 441;
444 -> 443;
445 -> 442;
445 -> 443;
446 -> 445;
446 -> 443;
447 -> 445;
447 -> 443;
448 -> 445;
448 -> 443;
449 -> 444;
449 -> 445;
449 -> 443;
450 -> 442;
450 -> 411;
450 -> 404;
451 -> 411;
451 -> 404;
452 -> 404;
453 -> 402;
453 -> 452;
454 -> 452;
455 -> 453;
455 -> 452;
456 -> 455;
456 -> 402;
457 -> 455;
458 -> 456;
458 -> 457;
459 -> 392;
459 -> 404;
460 -> 459;
461 -> 405;
461 -> 460;
461 -> 459;
462 -> 406;
462 -> 460;
462 -> 459;
463 -> 461;
463 -> 462;
463 -> 459;
464 -> 407;
464 -> 460;
464 -> 459;
465 -> 463;
465 -> 464;
465 -> 459;
466 -> 393;
466 -> 394;
467 -> 411;
467 -> 394;
468 -> 393;
468 -> 467;
468 -> 402;
468 -> 458;
468 -> 394;
469 -> 393;
469 -> 411;
469 -> 394;
470 -> 411;
470 -> 468;
470 -> 404;
471 -> 404;
472 -> 411;
472 -> 468;
472 -> 471;
472 -> 404;
473 -> 384;
473 -> 304;
474 -> 473;
474 -> 302;
475 -> 474;
475 -> 468;
475 -> 124;
476 -> 474;
476 -> 124;
477 -> 113;
477 -> 476;
477 -> 468;
477 -> 469;
477 -> 395;
477 -> 39;
478 -> 477;
478 -> 39;
479 -> 39;
480 -> 478;
480 -> 479;
481 -> 479;
482 -> 480;
482 -> 481;
483 -> 481;
484 -> 482;
484 -> 477;
484 -> 483;
485 -> 483;
486 -> 484;
486 -> 477;
486 -> 485;
486 -> 483;
487 -> 484;
487 -> 477;
487 -> 486;
488 -> 486;
489 -> 487;
489 -> 488;
490 -> 487;
490 -> 488;
491 -> 487;
491 -> 488;
492 -> 487;
492 -> 488;
493 -> 487;
493 -> 488;
494 -> 488;
495 -> 488;
496 -> 488;
497 -> 488;
498 -> 488;
499 -> 0;
499 -> 488;
500 -> 489;
500 -> 488;
501 -> 494;
501 -> 500;
502 -> 500;
503 -> 490;
503 -> 500;
504 -> 491;
504 -> 500;
505 -> 492;
505 -> 500;
506 -> 493;
506 -> 500;
507 -> 495;
507 -> 500;
508 -> 496;
508 -> 500;
509 -> 497;
509 -> 500;
510 -> 498;
510 -> 500;
511 -> 499;
511 -> 500;
512 -> 500;
513 -> 501;
513 -> 512;
514 -> 502;
514 -> 512;
515 -> 503;
515 -> 512;
516 -> 504;
516 -> 512;
517 -> 505;
517 -> 512;
518 -> 506;
518 -> 512;
519 -> 507;
519 -> 512;
520 -> 508;
520 -> 512;
521 -> 509;
521 -> 512;
522 -> 510;
522 -> 512;
523 -> 511;
523 -> 512;
524 -> 514;
524 -> 477;
524 -> 512;
525 -> 524;
525 -> 0;
525 -> 512;
526 -> 514;
526 -> 512;
527 -> 515;
527 -> 512;
528 -> 518;
528 -> 512;
529 -> 522;
529 -> 512;
530 -> 523;
530 -> 512;
531 -> 512;
532 -> 526;
532 -> 531;
533 -> 527;
533 -> 531;
534 -> 528;
534 -> 531;
535 -> 529;
535 -> 531;
536 -> 530;
536 -> 531;
537 -> 532;
537 -> 533;
537 -> 534;
537 -> 531;
538 -> 532;
538 -> 531;
539 -> 537;
539 -> 531;
540 -> 535;
540 -> 538;
540 -> 539;
540 -> 498;
540 -> 537;
540 -> 531;
541 -> 537;
541 -> 531;
542 -> 536;
542 -> 541;
542 -> 0;
542 -> 540;
542 -> 531;
543 -> 512;
544 -> 514;
544 -> 512;
545 -> 513;
545 -> 544;
545 -> 494;
545 -> 542;
545 -> 512;
546 -> 514;
546 -> 512;
547 -> 519;
547 -> 495;
547 -> 512;
548 -> 519;
548 -> 546;
548 -> 547;
548 -> 495;
548 -> 545;
548 -> 512;
549 -> 494;
549 -> 548;
549 -> 488;
550 -> 495;
550 -> 548;
550 -> 488;
551 -> 496;
551 -> 488;
552 -> 497;
552 -> 488;
553 -> 542;
553 -> 488;
554 -> 488;
555 -> 488;
556 -> 549;
556 -> 555;
557 -> 550;
557 -> 555;
558 -> 551;
558 -> 555;
559 -> 552;
559 -> 555;
560 -> 550;
560 -> 555;
561 -> 553;
561 -> 555;
562 -> 554;
562 -> 555;
563 -> 562;
563 -> 555;
564 -> 562;
564 -> 555;
565 -> 562;
565 -> 555;
566 -> 562;
566 -> 555;
567 -> 562;
567 -> 555;
568 -> 556;
568 -> 555;
569 -> 556;
569 -> 549;
569 -> 555;
570 -> 556;
570 -> 555;
571 -> 560;
571 -> 568;
571 -> 555;
572 -> 0;
572 -> 555;
573 -> 556;
573 -> 562;
573 -> 555;
574 -> 557;
574 -> 562;
574 -> 555;
575 -> 558;
575 -> 562;
575 -> 555;
576 -> 559;
576 -> 562;
576 -> 555;
577 -> 560;
577 -> 562;
577 -> 555;
578 -> 561;
578 -> 562;
578 -> 555;
579 -> 554;
579 -> 486;
580 -> 486;
581 -> 487;
581 -> 579;
581 -> 580;
581 -> 574;
581 -> 575;
581 -> 576;
581 -> 577;
581 -> 578;
581 -> 573;
581 -> 571;
581 -> 549;
581 -> 551;
581 -> 552;
581 -> 486;
582 -> 484;
582 -> 581;
582 -> 483;
583 -> 582;
583 -> 481;
584 -> 583;
584 -> 479;
585 -> 584;
585 -> 581;
585 -> 479;
586 -> 479;
587 -> 584;
587 -> 586;
587 -> 581;
587 -> 479;
588 -> 0;
588 -> 479;
589 -> 587;
589 -> 588;
589 -> 479;
590 -> 46;
590 -> 589;
590 -> 39;
591 -> 477;
591 -> 39;
592 -> 13;
592 -> 591;
592 -> 589;
592 -> 1;
593 -> 592;
593 -> 1;
594 -> 11;
594 -> 1;
595 -> 1;
596 -> 1;
597 -> 593;
597 -> 596;
598 -> 594;
598 -> 596;
599 -> 595;
599 -> 596;
600 -> 597;
600 -> 596;
601 -> 598;
601 -> 596;
602 -> 596;
603 -> 596;
604 -> 600;
604 -> 603;
605 -> 601;
605 -> 603;
606 -> 602;
606 -> 603;
607 -> 603;
608 -> 0;
608 -> 607;
609 -> 608;
609 -> 603;
610 -> 603;
611 -> 609;
611 -> 603;
612 -> 605;
612 -> 603;
613 -> 606;
613 -> 603;
614 -> 610;
614 -> 611;
614 -> 613;
614 -> 612;
614 -> 604;
614 -> 609;
614 -> 11;
614 -> 592;
614 -> 603;
615 -> 614;
615 -> 610;
616 -> 615;
616 -> 614;
616 -> 610;
617 -> 614;
617 -> 610;
618 -> 617;
618 -> 616;
618 -> 610;
619 -> 614;
619 -> 610;
620 -> 614;
620 -> 610;
621 -> 614;
621 -> 610;
622 -> 614;
622 -> 610;
623 -> 614;
623 -> 610;
624 -> 614;
624 -> 610;
625 -> 614;
625 -> 610;
626 -> 614;
626 -> 610;
627 -> 614;
627 -> 610;
628 -> 627;
628 -> 618;
628 -> 610;
629 -> 619;
629 -> 610;
630 -> 625;
630 -> 610;
631 -> 610;
632 -> 629;
632 -> 631;
633 -> 630;
633 -> 631;
634 -> 627;
634 -> 631;
635 -> 632;
635 -> 631;
636 -> 631;
637 -> 635;
637 -> 636;
638 -> 634;
638 -> 636;
639 -> 636;
640 -> 638;
640 -> 639;
641 -> 639;
642 -> 640;
642 -> 641;
643 -> 641;
644 -> 642;
644 -> 643;
645 -> 644;
645 -> 618;
645 -> 643;
646 -> 644;
646 -> 645;
647 -> 645;
648 -> 646;
648 -> 647;
649 -> 647;
650 -> 648;
650 -> 649;
651 -> 649;
652 -> 650;
652 -> 646;
652 -> 651;
653 -> 652;
653 -> 649;
654 -> 653;
654 -> 647;
655 -> 646;
655 -> 647;
656 -> 647;
657 -> 644;
657 -> 654;
657 -> 645;
658 -> 644;
658 -> 654;
658 -> 643;
659 -> 658;
659 -> 641;
660 -> 642;
660 -> 654;
660 -> 641;
661 -> 642;
661 -> 660;
661 -> 641;
662 -> 661;
662 -> 639;
663 -> 662;
663 -> 636;
664 -> 663;
664 -> 636;
665 -> 637;
665 -> 660;
665 -> 636;
666 -> 631;
667 -> 665;
667 -> 666;
667 -> 631;
668 -> 665;
668 -> 667;
669 -> 610;
670 -> 668;
670 -> 669;
670 -> 610;
671 -> 619;
671 -> 610;
672 -> 668;
672 -> 610;
673 -> 610;
674 -> 672;
674 -> 673;
675 -> 673;
676 -> 674;
676 -> 675;
677 -> 675;
678 -> 676;
678 -> 672;
678 -> 677;
679 -> 678;
679 -> 675;
680 -> 676;
680 -> 675;
681 -> 680;
681 -> 673;
682 -> 673;
683 -> 681;
683 -> 682;
684 -> 681;
684 -> 682;
685 -> 682;
686 -> 684;
686 -> 685;
687 -> 685;
688 -> 687;
689 -> 686;
689 -> 682;
690 -> 684;
690 -> 682;
691 -> 682;
692 -> 691;
693 -> 692;
694 -> 672;
694 -> 673;
695 -> 673;
696 -> 694;
696 -> 695;
697 -> 695;
698 -> 696;
698 -> 689;
698 -> 697;
699 -> 696;
699 -> 689;
699 -> 697;
700 -> 699;
700 -> 695;
701 -> 696;
701 -> 689;
701 -> 695;
702 -> 701;
702 -> 673;
703 -> 673;
704 -> 702;
704 -> 703;
705 -> 672;
705 -> 673;
706 -> 673;
707 -> 672;
707 -> 706;
707 -> 704;
707 -> 610;
708 -> 610;
709 -> 623;
709 -> 708;
709 -> 610;
710 -> 709;
711 -> 610;
712 -> 627;
712 -> 707;
712 -> 610;
713 -> 627;
713 -> 707;
713 -> 712;
714 -> 713;
714 -> 712;
715 -> 627;
715 -> 707;
715 -> 714;
716 -> 712;
717 -> 716;
717 -> 707;
718 -> 717;
718 -> 716;
719 -> 716;
719 -> 707;
719 -> 715;
720 -> 719;
720 -> 712;
721 -> 619;
721 -> 712;
722 -> 715;
722 -> 712;
723 -> 707;
723 -> 712;
724 -> 710;
724 -> 712;
725 -> 712;
726 -> 712;
727 -> 720;
727 -> 726;
728 -> 721;
728 -> 726;
729 -> 722;
729 -> 726;
730 -> 723;
730 -> 726;
731 -> 724;
731 -> 726;
732 -> 725;
732 -> 726;
733 -> 727;
733 -> 726;
734 -> 728;
734 -> 726;
735 -> 729;
735 -> 726;
736 -> 730;
736 -> 726;
737 -> 731;
737 -> 726;
738 -> 0;
738 -> 726;
739 -> 726;
740 -> 733;
740 -> 739;
741 -> 734;
741 -> 739;
742 -> 735;
742 -> 739;
743 -> 736;
743 -> 739;
744 -> 737;
744 -> 739;
745 -> 738;
745 -> 739;
746 -> 732;
746 -> 739;
747 -> 739;
748 -> 740;
748 -> 719;
748 -> 747;
748 -> 739;
749 -> 741;
749 -> 739;
750 -> 742;
750 -> 739;
751 -> 743;
751 -> 739;
752 -> 744;
752 -> 739;
753 -> 739;
754 -> 748;
754 -> 753;
755 -> 749;
755 -> 753;
756 -> 750;
756 -> 753;
757 -> 751;
757 -> 753;
758 -> 752;
758 -> 753;
759 -> 746;
759 -> 753;
760 -> 754;
760 -> 748;
760 -> 753;
761 -> 754;
761 -> 753;
762 -> 757;
762 -> 753;
763 -> 758;
763 -> 753;
764 -> 756;
764 -> 753;
765 -> 755;
765 -> 753;
766 -> 753;
767 -> 766;
768 -> 753;
769 -> 768;
769 -> 760;
769 -> 761;
769 -> 762;
769 -> 763;
769 -> 764;
769 -> 765;
769 -> 766;
769 -> 748;
769 -> 710;
769 -> 767;
769 -> 753;
770 -> 769;
770 -> 768;
771 -> 768;
772 -> 769;
772 -> 771;
772 -> 753;
773 -> 753;
774 -> 773;
774 -> 768;
774 -> 753;
775 -> 0;
775 -> 753;
776 -> 775;
776 -> 0;
776 -> 753;
777 -> 776;
777 -> 768;
777 -> 753;
778 -> 753;
779 -> 778;
779 -> 768;
779 -> 753;
780 -> 768;
780 -> 753;
781 -> 768;
781 -> 753;
782 -> 768;
782 -> 753;
783 -> 768;
783 -> 753;
784 -> 768;
784 -> 753;
785 -> 754;
785 -> 772;
785 -> 753;
786 -> 785;
786 -> 0;
786 -> 753;
787 -> 786;
787 -> 753;
788 -> 787;
788 -> 768;
788 -> 753;
789 -> 768;
789 -> 772;
789 -> 774;
789 -> 753;
790 -> 754;
790 -> 753;
791 -> 768;
791 -> 753;
792 -> 789;
792 -> 790;
792 -> 791;
792 -> 772;
792 -> 774;
792 -> 777;
792 -> 779;
792 -> 780;
792 -> 781;
792 -> 788;
792 -> 782;
792 -> 783;
792 -> 784;
792 -> 773;
792 -> 776;
792 -> 778;
792 -> 753;
793 -> 754;
793 -> 792;
793 -> 753;
794 -> 746;
794 -> 739;
795 -> 746;
795 -> 739;
796 -> 746;
796 -> 739;
797 -> 746;
797 -> 739;
798 -> 746;
798 -> 739;
799 -> 746;
799 -> 739;
800 -> 746;
800 -> 739;
801 -> 746;
801 -> 739;
802 -> 746;
802 -> 739;
803 -> 746;
803 -> 739;
804 -> 740;
804 -> 739;
805 -> 740;
805 -> 746;
805 -> 739;
806 -> 745;
806 -> 739;
807 -> 806;
807 -> 746;
807 -> 739;
808 -> 739;
809 -> 741;
809 -> 792;
809 -> 808;
809 -> 739;
810 -> 809;
810 -> 739;
811 -> 740;
811 -> 792;
811 -> 810;
812 -> 740;
812 -> 792;
812 -> 811;
812 -> 746;
812 -> 739;
813 -> 746;
813 -> 792;
813 -> 739;
814 -> 740;
814 -> 739;
815 -> 746;
815 -> 739;
816 -> 813;
816 -> 814;
816 -> 815;
816 -> 792;
816 -> 794;
816 -> 805;
816 -> 795;
816 -> 796;
816 -> 797;
816 -> 798;
816 -> 799;
816 -> 800;
816 -> 801;
816 -> 802;
816 -> 803;
816 -> 812;
816 -> 807;
816 -> 811;
816 -> 806;
816 -> 739;
817 -> 610;
818 -> 620;
818 -> 817;
818 -> 610;
819 -> 621;
819 -> 725;
819 -> 610;
820 -> 610;
821 -> 622;
821 -> 820;
821 -> 610;
822 -> 610;
823 -> 624;
823 -> 822;
823 -> 610;
824 -> 725;
824 -> 610;
825 -> 614;
825 -> 824;
825 -> 816;
825 -> 819;
825 -> 603;
826 -> 614;
826 -> 610;
827 -> 614;
827 -> 610;
828 -> 614;
828 -> 610;
829 -> 614;
829 -> 610;
830 -> 614;
830 -> 610;
831 -> 614;
831 -> 610;
832 -> 614;
832 -> 610;
833 -> 614;
833 -> 610;
834 -> 610;
835 -> 828;
835 -> 610;
836 -> 830;
836 -> 610;
837 -> 0;
837 -> 610;
838 -> 610;
839 -> 832;
839 -> 610;
840 -> 610;
841 -> 837;
841 -> 840;
842 -> 838;
842 -> 840;
843 -> 839;
843 -> 840;
844 -> 833;
844 -> 840;
845 -> 840;
846 -> 841;
846 -> 840;
847 -> 842;
847 -> 840;
848 -> 845;
848 -> 840;
849 -> 843;
849 -> 840;
850 -> 840;
851 -> 846;
851 -> 850;
852 -> 847;
852 -> 850;
853 -> 848;
853 -> 850;
854 -> 849;
854 -> 850;
855 -> 844;
855 -> 850;
856 -> 850;
857 -> 851;
857 -> 0;
857 -> 850;
858 -> 857;
858 -> 852;
858 -> 850;
859 -> 858;
860 -> 855;
860 -> 859;
861 -> 859;
862 -> 860;
862 -> 825;
862 -> 861;
863 -> 861;
864 -> 862;
864 -> 858;
865 -> 858;
866 -> 855;
866 -> 865;
867 -> 866;
867 -> 825;
867 -> 865;
868 -> 867;
868 -> 858;
869 -> 868;
870 -> 864;
870 -> 825;
870 -> 868;
871 -> 854;
871 -> 868;
872 -> 869;
872 -> 870;
872 -> 871;
872 -> 825;
872 -> 868;
873 -> 872;
873 -> 869;
874 -> 872;
874 -> 869;
875 -> 872;
875 -> 869;
876 -> 872;
876 -> 869;
877 -> 869;
878 -> 877;
878 -> 869;
879 -> 869;
880 -> 874;
880 -> 879;
881 -> 880;
881 -> 869;
882 -> 875;
882 -> 869;
883 -> 877;
883 -> 869;
884 -> 881;
884 -> 872;
884 -> 882;
884 -> 883;
884 -> 878;
884 -> 869;
885 -> 858;
886 -> 864;
886 -> 858;
887 -> 854;
887 -> 825;
887 -> 884;
887 -> 886;
888 -> 886;
888 -> 825;
888 -> 887;
889 -> 851;
889 -> 0;
889 -> 850;
890 -> 856;
890 -> 889;
891 -> 890;
891 -> 855;
891 -> 856;
891 -> 887;
891 -> 889;
892 -> 889;
893 -> 889;
894 -> 855;
894 -> 893;
895 -> 894;
895 -> 891;
895 -> 893;
896 -> 895;
896 -> 889;
897 -> 889;
898 -> 855;
898 -> 897;
899 -> 898;
899 -> 896;
899 -> 897;
900 -> 899;
900 -> 889;
901 -> 854;
901 -> 896;
901 -> 889;
902 -> 889;
903 -> 855;
903 -> 902;
904 -> 903;
904 -> 901;
904 -> 902;
905 -> 903;
905 -> 901;
905 -> 902;
906 -> 905;
906 -> 889;
907 -> 854;
907 -> 906;
907 -> 889;
908 -> 854;
908 -> 889;
909 -> 889;
910 -> 889;
911 -> 909;
911 -> 910;
912 -> 909;
912 -> 910;
913 -> 909;
913 -> 910;
914 -> 908;
914 -> 910;
915 -> 855;
915 -> 910;
916 -> 910;
917 -> 915;
917 -> 916;
918 -> 917;
918 -> 907;
918 -> 916;
919 -> 916;
920 -> 918;
920 -> 919;
921 -> 920;
921 -> 919;
922 -> 921;
922 -> 918;
922 -> 919;
923 -> 919;
924 -> 922;
924 -> 923;
925 -> 924;
925 -> 922;
925 -> 923;
926 -> 925;
926 -> 923;
927 -> 926;
927 -> 910;
928 -> 914;
928 -> 910;
929 -> 927;
929 -> 928;
929 -> 926;
929 -> 907;
929 -> 910;
930 -> 910;
931 -> 910;
932 -> 911;
932 -> 931;
932 -> 910;
933 -> 910;
934 -> 915;
934 -> 933;
935 -> 933;
936 -> 934;
936 -> 935;
937 -> 935;
938 -> 936;
938 -> 937;
939 -> 938;
939 -> 929;
939 -> 937;
940 -> 938;
940 -> 929;
940 -> 937;
941 -> 940;
941 -> 935;
942 -> 936;
942 -> 929;
942 -> 935;
943 -> 942;
943 -> 933;
944 -> 943;
944 -> 910;
945 -> 930;
945 -> 910;
946 -> 914;
946 -> 910;
947 -> 945;
947 -> 946;
947 -> 944;
947 -> 907;
947 -> 942;
947 -> 910;
948 -> 910;
949 -> 948;
950 -> 949;
951 -> 947;
951 -> 949;
952 -> 948;
953 -> 952;
954 -> 953;
955 -> 948;
956 -> 955;
957 -> 956;
958 -> 947;
958 -> 948;
959 -> 958;
959 -> 947;
959 -> 948;
960 -> 948;
961 -> 958;
961 -> 947;
961 -> 960;
961 -> 948;
962 -> 961;
963 -> 958;
963 -> 947;
963 -> 961;
964 -> 962;
964 -> 961;
965 -> 961;
966 -> 958;
966 -> 964;
966 -> 948;
967 -> 947;
967 -> 948;
968 -> 947;
968 -> 948;
969 -> 968;
969 -> 966;
969 -> 948;
970 -> 947;
970 -> 948;
971 -> 947;
971 -> 948;
972 -> 948;
973 -> 971;
973 -> 972;
974 -> 973;
974 -> 966;
974 -> 972;
975 -> 973;
975 -> 966;
975 -> 972;
976 -> 975;
976 -> 948;
977 -> 948;
978 -> 977;
978 -> 976;
978 -> 966;
978 -> 948;
979 -> 966;
979 -> 949;
980 -> 947;
980 -> 948;
981 -> 980;
981 -> 966;
981 -> 948;
982 -> 981;
982 -> 949;
983 -> 973;
983 -> 981;
983 -> 972;
984 -> 973;
984 -> 981;
984 -> 972;
985 -> 984;
985 -> 948;
986 -> 977;
986 -> 985;
986 -> 981;
986 -> 948;
987 -> 947;
987 -> 948;
988 -> 947;
988 -> 948;
989 -> 987;
989 -> 948;
990 -> 989;
990 -> 981;
990 -> 948;
991 -> 987;
991 -> 990;
991 -> 948;
992 -> 948;
993 -> 988;
993 -> 992;
994 -> 992;
995 -> 993;
995 -> 994;
996 -> 994;
997 -> 996;
998 -> 995;
998 -> 990;
998 -> 997;
999 -> 995;
999 -> 990;
999 -> 997;
1000 -> 999;
1000 -> 996;
1001 -> 995;
1001 -> 990;
1001 -> 996;
1002 -> 1001;
1002 -> 992;
1003 -> 992;
1004 -> 1002;
1004 -> 948;
1005 -> 948;
1006 -> 988;
1006 -> 1005;
1007 -> 1006;
1007 -> 1002;
1007 -> 1005;
1008 -> 1007;
1009 -> 1008;
1009 -> 1007;
1010 -> 1007;
1011 -> 1009;
1011 -> 1010;
1011 -> 1007;
1012 -> 1011;
1012 -> 1007;
1013 -> 1012;
1013 -> 1006;
1013 -> 1007;
1014 -> 1006;
1014 -> 1011;
1014 -> 1013;
1014 -> 1005;
1015 -> 1014;
1015 -> 948;
1016 -> 1015;
1017 -> 987;
1017 -> 1016;
1017 -> 948;
1018 -> 1016;
1018 -> 996;
1019 -> 1016;
1019 -> 948;
1020 -> 968;
1020 -> 1016;
1020 -> 948;
1021 -> 958;
1021 -> 1016;
1021 -> 948;
1022 -> 911;
1022 -> 910;
1023 -> 1022;
1024 -> 1023;
1024 -> 915;
1024 -> 1022;
1025 -> 1022;
1026 -> 1025;
1026 -> 915;
1026 -> 1022;
1027 -> 915;
1027 -> 1016;
1027 -> 1024;
1027 -> 1026;
1027 -> 910;
1028 -> 910;
1029 -> 913;
1029 -> 1028;
1029 -> 910;
1030 -> 911;
1030 -> 910;
1031 -> 912;
1031 -> 910;
1032 -> 914;
1032 -> 910;
1033 -> 910;
1034 -> 1030;
1034 -> 1033;
1035 -> 1031;
1035 -> 1033;
1036 -> 1032;
1036 -> 1033;
1037 -> 915;
1037 -> 1033;
1038 -> 1033;
1039 -> 1034;
1039 -> 1038;
1039 -> 1033;
1040 -> 1037;
1040 -> 1027;
1040 -> 1033;
1041 -> 1040;
1042 -> 1037;
1042 -> 1040;
1043 -> 1041;
1043 -> 1040;
1044 -> 1036;
1044 -> 1040;
1045 -> 1040;
1046 -> 1040;
1047 -> 1042;
1047 -> 1046;
1048 -> 1043;
1048 -> 1046;
1049 -> 1044;
1049 -> 1046;
1050 -> 1045;
1050 -> 1046;
1051 -> 1045;
1051 -> 1046;
1052 -> 1046;
1053 -> 1047;
1053 -> 1046;
1054 -> 1050;
1054 -> 1046;
1055 -> 1051;
1055 -> 1046;
1056 -> 1052;
1056 -> 1046;
1057 -> 1049;
1057 -> 1046;
1058 -> 1046;
1059 -> 1046;
1060 -> 1053;
1060 -> 1059;
1061 -> 1054;
1061 -> 1059;
1062 -> 1055;
1062 -> 1059;
1063 -> 1056;
1063 -> 1059;
1064 -> 1057;
1064 -> 1059;
1065 -> 1058;
1065 -> 1059;
1066 -> 1059;
1067 -> 1066;
1067 -> 1059;
1068 -> 1066;
1068 -> 1059;
1069 -> 1066;
1069 -> 1059;
1070 -> 1066;
1070 -> 1059;
1071 -> 1066;
1071 -> 1059;
1072 -> 1066;
1072 -> 1059;
1073 -> 1060;
1073 -> 1066;
1073 -> 1059;
1074 -> 1061;
1074 -> 1066;
1074 -> 1059;
1075 -> 1062;
1075 -> 1066;
1075 -> 1059;
1076 -> 1063;
1076 -> 1066;
1076 -> 1059;
1077 -> 1064;
1077 -> 1066;
1077 -> 1059;
1078 -> 0;
1078 -> 1059;
1079 -> 1078;
1079 -> 1066;
1079 -> 1059;
1080 -> 1059;
1081 -> 1066;
1081 -> 1080;
1082 -> 1080;
1083 -> 1081;
1083 -> 1066;
1083 -> 1068;
1083 -> 1074;
1083 -> 1082;
1083 -> 1080;
1084 -> 1080;
1085 -> 1081;
1085 -> 1066;
1085 -> 1067;
1085 -> 1073;
1085 -> 1084;
1086 -> 1085;
1086 -> 1066;
1086 -> 1078;
1086 -> 1084;
1087 -> 1083;
1087 -> 1086;
1087 -> 1066;
1087 -> 1078;
1087 -> 1080;
1088 -> 1087;
1088 -> 1059;
1089 -> 1088;
1090 -> 1089;
1090 -> 1066;
1090 -> 1088;
1091 -> 1046;
1092 -> 1047;
1092 -> 1091;
1093 -> 1092;
1093 -> 1078;
1093 -> 1091;
1094 -> 1092;
1094 -> 1078;
1094 -> 1091;
1095 -> 1094;
1095 -> 1091;
1096 -> 1092;
1096 -> 1078;
1096 -> 1091;
1097 -> 1096;
1097 -> 1046;
1098 -> 1097;
1098 -> 1058;
1098 -> 1096;
1098 -> 1066;
1098 -> 1067;
1098 -> 1073;
1098 -> 1068;
1098 -> 1074;
1098 -> 1069;
1098 -> 1075;
1098 -> 1070;
1098 -> 1076;
1098 -> 1071;
1098 -> 1079;
1098 -> 1072;
1098 -> 1090;
1098 -> 1077;
1098 -> 1045;
1098 -> 1052;
1098 -> 907;
1098 -> 1089;
1098 -> 1046;
1099 -> 1046;
1100 -> 1098;
1100 -> 1099;
1101 -> 1098;
1101 -> 1099;
1102 -> 1101;
1102 -> 1098;
1102 -> 1099;
1103 -> 1100;
1103 -> 1099;
1104 -> 1100;
1104 -> 1099;
1105 -> 1099;
1106 -> 1104;
1106 -> 1105;
1107 -> 1101;
1107 -> 1105;
1108 -> 1106;
1108 -> 1102;
1108 -> 0;
1108 -> 1105;
1109 -> 1105;
1110 -> 1106;
1110 -> 1102;
1110 -> 0;
1110 -> 1105;
1111 -> 1106;
1111 -> 1102;
1111 -> 0;
1111 -> 1110;
1112 -> 1106;
1112 -> 1102;
1112 -> 0;
1112 -> 1105;
1113 -> 1106;
1113 -> 1102;
1113 -> 0;
1113 -> 1105;
1114 -> 1106;
1114 -> 1102;
1114 -> 0;
1114 -> 1105;
1115 -> 1106;
1115 -> 1102;
1115 -> 0;
1115 -> 1105;
1116 -> 1106;
1116 -> 1102;
1116 -> 0;
1116 -> 1105;
1117 -> 1105;
1118 -> 1106;
1118 -> 1105;
1119 -> 1117;
1119 -> 1105;
1120 -> 1107;
1120 -> 1102;
1120 -> 1118;
1120 -> 1119;
1120 -> 1105;
1121 -> 1105;
1122 -> 1106;
1122 -> 1105;
1123 -> 1121;
1123 -> 1105;
1124 -> 1105;
1125 -> 1122;
1125 -> 1124;
1126 -> 1123;
1126 -> 1124;
1127 -> 1107;
1127 -> 1124;
1128 -> 1124;
1129 -> 1125;
1129 -> 1120;
1129 -> 1124;
1130 -> 1124;
1131 -> 1130;
1131 -> 1105;
1132 -> 1131;
1132 -> 1105;
1133 -> 1106;
1133 -> 1129;
1133 -> 0;
1133 -> 1132;
1134 -> 0;
1134 -> 1133;
1135 -> 1106;
1135 -> 1129;
1135 -> 0;
1135 -> 1105;
1136 -> 1135;
1136 -> 1105;
1137 -> 1134;
1137 -> 1136;
1138 -> 1137;
1138 -> 0;
1138 -> 1099;
1139 -> 1137;
1139 -> 1099;
1140 -> 1099;
1141 -> 1139;
1141 -> 1140;
1142 -> 1141;
1142 -> 1140;
1143 -> 1142;
1144 -> 1099;
1145 -> 1144;
1145 -> 1100;
1145 -> 1137;
1145 -> 1099;
1146 -> 1100;
1146 -> 1137;
1146 -> 1144;
1146 -> 1145;
1147 -> 1145;
1148 -> 1146;
1148 -> 1145;
1149 -> 1147;
1149 -> 1145;
1150 -> 1145;
1151 -> 1148;
1151 -> 1150;
1152 -> 1149;
1152 -> 1150;
1153 -> 1101;
1153 -> 1150;
1154 -> 1150;
1155 -> 1150;
1155 -> 1145;
1156 -> 1145;
1157 -> 1156;
1157 -> 1145;
1158 -> 1154;
1158 -> 1157;
1159 -> 1145;
1160 -> 1158;
1160 -> 1159;
1160 -> 1145;
1161 -> 1160;
1161 -> 1155;
1161 -> 1145;
1162 -> 1155;
1162 -> 1145;
1163 -> 1143;
1163 -> 1162;
1164 -> 1143;
1164 -> 1099;
1165 -> 1099;
1166 -> 1100;
1166 -> 1151;
1166 -> 1165;
1166 -> 1099;
1167 -> 1166;
1167 -> 1099;
1168 -> 1099;
1169 -> 1167;
1169 -> 1168;
1170 -> 1101;
1170 -> 1168;
1171 -> 1169;
1171 -> 1166;
1171 -> 0;
1171 -> 1168;
1172 -> 1168;
1173 -> 1169;
1173 -> 1166;
1173 -> 0;
1173 -> 1168;
1174 -> 1169;
1174 -> 1166;
1174 -> 0;
1174 -> 1173;
1175 -> 1169;
1175 -> 1166;
1175 -> 0;
1175 -> 1168;
1176 -> 1169;
1176 -> 1166;
1176 -> 0;
1176 -> 1168;
1177 -> 1169;
1177 -> 1166;
1177 -> 0;
1177 -> 1168;
1178 -> 1169;
1178 -> 1166;
1178 -> 0;
1178 -> 1168;
1179 -> 1169;
1179 -> 1166;
1179 -> 0;
1179 -> 1168;
1180 -> 1168;
1181 -> 1180;
1181 -> 1168;
1182 -> 1168;
1183 -> 1182;
1183 -> 1168;
1184 -> 1168;
1185 -> 1183;
1185 -> 1184;
1186 -> 1170;
1186 -> 1184;
1187 -> 1184;
1188 -> 1184;
1189 -> 1188;
1189 -> 1168;
1190 -> 1189;
1190 -> 1168;
1191 -> 1169;
1192 -> 1169;
1193 -> 1191;
1193 -> 1192;
1194 -> 1170;
1194 -> 1192;
1195 -> 1193;
1195 -> 1169;
1195 -> 0;
1195 -> 1192;
1196 -> 1193;
1196 -> 1169;
1196 -> 1192;
1197 -> 1192;
1198 -> 1196;
1198 -> 1197;
1198 -> 1192;
1199 -> 1196;
1199 -> 1192;
1200 -> 1192;
1201 -> 1199;
1201 -> 1200;
1202 -> 1194;
1202 -> 1200;
1203 -> 1201;
1203 -> 1169;
1203 -> 0;
1203 -> 1200;
1204 -> 1200;
1205 -> 1201;
1205 -> 1169;
1205 -> 0;
1205 -> 1200;
1206 -> 1201;
1206 -> 1169;
1206 -> 0;
1206 -> 1205;
1207 -> 1201;
1207 -> 1169;
1207 -> 0;
1207 -> 1200;
1208 -> 1201;
1208 -> 1169;
1208 -> 0;
1208 -> 1200;
1209 -> 1201;
1209 -> 1169;
1209 -> 0;
1209 -> 1200;
1210 -> 1201;
1210 -> 1169;
1210 -> 0;
1210 -> 1200;
1211 -> 1201;
1211 -> 1169;
1211 -> 0;
1211 -> 1200;
1212 -> 1202;
1212 -> 1169;
1212 -> 1201;
1212 -> 1200;
1213 -> 1212;
1214 -> 1169;
1215 -> 1213;
1215 -> 1214;
1216 -> 1215;
1216 -> 1214;
1217 -> 1216;
1218 -> 1099;
1219 -> 1217;
1219 -> 1218;
1220 -> 1100;
1220 -> 1212;
1220 -> 1099;
1221 -> 1099;
1222 -> 1220;
1222 -> 1221;
1223 -> 1220;
1223 -> 1221;
1224 -> 1223;
1224 -> 1220;
1224 -> 1221;
1225 -> 1222;
1225 -> 1221;
1226 -> 1221;
1227 -> 1225;
1227 -> 1226;
1228 -> 1223;
1228 -> 1226;
1229 -> 1227;
1229 -> 1224;
1229 -> 0;
1229 -> 1226;
1230 -> 1229;
1231 -> 1222;
1231 -> 1221;
1232 -> 1221;
1233 -> 1231;
1233 -> 1232;
1234 -> 1223;
1234 -> 1232;
1235 -> 1233;
1235 -> 1224;
1235 -> 0;
1235 -> 1232;
1236 -> 1232;
1237 -> 1233;
1237 -> 1224;
1237 -> 0;
1237 -> 1232;
1238 -> 1233;
1238 -> 1224;
1238 -> 1237;
1239 -> 1237;
1240 -> 1238;
1240 -> 1239;
1241 -> 1240;
1241 -> 1224;
1241 -> 0;
1241 -> 1239;
1242 -> 1239;
1243 -> 1240;
1243 -> 1224;
1243 -> 0;
1244 -> 1240;
1244 -> 1224;
1244 -> 0;
1244 -> 1239;
1245 -> 1240;
1245 -> 1224;
1245 -> 0;
1245 -> 1239;
1246 -> 1240;
1246 -> 1224;
1246 -> 0;
1246 -> 1239;
1247 -> 1240;
1247 -> 1224;
1247 -> 0;
1247 -> 1239;
1248 -> 1240;
1248 -> 1224;
1248 -> 0;
1248 -> 1239;
1249 -> 1240;
1250 -> 1221;
1251 -> 1249;
1251 -> 1250;
1252 -> 1251;
1252 -> 1250;
1253 -> 1252;
1254 -> 1221;
1255 -> 1223;
1255 -> 1254;
1256 -> 1254;
1257 -> 1255;
1257 -> 1240;
1257 -> 1256;
1257 -> 1254;
1258 -> 1254;
1259 -> 1255;
1259 -> 1240;
1259 -> 1258;
1260 -> 1257;
1260 -> 1221;
1261 -> 1222;
1261 -> 1260;
1262 -> 1260;
1263 -> 1261;
1263 -> 1262;
1264 -> 1223;
1264 -> 1262;
1265 -> 1263;
1265 -> 1240;
1265 -> 1262;
1266 -> 1265;
1267 -> 1264;
1267 -> 1265;
1268 -> 1260;
1269 -> 1046;
1270 -> 1058;
1270 -> 1269;
1271 -> 1270;
1271 -> 1267;
1271 -> 1269;
1272 -> 1269;
1273 -> 1271;
1273 -> 1272;
1273 -> 1269;
1274 -> 1269;
1275 -> 1271;
1275 -> 1274;
1275 -> 1267;
1275 -> 1269;
1276 -> 1275;
1277 -> 1046;
1278 -> 1052;
1278 -> 1046;
1279 -> 1278;
1279 -> 1276;
1279 -> 1046;
1280 -> 1037;
1280 -> 1276;
1280 -> 1040;
1281 -> 1041;
1281 -> 1040;
1282 -> 1280;
1282 -> 1281;
1282 -> 1276;
1282 -> 1040;
1283 -> 1037;
1283 -> 1282;
1283 -> 1033;
1284 -> 1037;
1284 -> 1282;
1284 -> 1033;
1285 -> 1027;
1285 -> 910;
1286 -> 1285;
1286 -> 1282;
1286 -> 910;
1287 -> 1284;
1287 -> 910;
1288 -> 889;
1289 -> 855;
1289 -> 1287;
1289 -> 1288;
1289 -> 889;
1290 -> 854;
1290 -> 1287;
1290 -> 850;
1291 -> 851;
1291 -> 0;
1291 -> 850;
1292 -> 853;
1292 -> 850;
1293 -> 856;
1293 -> 850;
1294 -> 854;
1294 -> 850;
1295 -> 1292;
1295 -> 1293;
1295 -> 1294;
1295 -> 855;
1295 -> 845;
1295 -> 1290;
1295 -> 850;
1296 -> 850;
1297 -> 840;
1298 -> 845;
1298 -> 1295;
1298 -> 840;
1299 -> 834;
1299 -> 610;
1300 -> 836;
1300 -> 1298;
1300 -> 1299;
1300 -> 839;
1300 -> 833;
1300 -> 825;
1300 -> 610;
1301 -> 834;
1301 -> 610;
1302 -> 826;
1302 -> 610;
1303 -> 828;
1303 -> 610;
1304 -> 827;
1304 -> 1303;
1305 -> 1302;
1305 -> 1300;
1305 -> 1303;
1306 -> 830;
1306 -> 1303;
1307 -> 1303;
1308 -> 1305;
1308 -> 1307;
1309 -> 1307;
1310 -> 1308;
1310 -> 1309;
1311 -> 1310;
1311 -> 1307;
1312 -> 1305;
1312 -> 1307;
1313 -> 1305;
1313 -> 1307;
1314 -> 1305;
1314 -> 1307;
1315 -> 1305;
1315 -> 1307;
1316 -> 1307;
1317 -> 1313;
1317 -> 1311;
1317 -> 1316;
1317 -> 1307;
1318 -> 0;
1318 -> 1307;
1319 -> 1317;
1319 -> 1307;
1320 -> 1304;
1320 -> 1317;
1320 -> 1303;
1321 -> 1303;
1322 -> 833;
1322 -> 1303;
1323 -> 1302;
1323 -> 1303;
1324 -> 827;
1324 -> 1303;
1325 -> 829;
1325 -> 1303;
1326 -> 1300;
1326 -> 1303;
1327 -> 1321;
1327 -> 1303;
1328 -> 831;
1328 -> 1303;
1329 -> 832;
1329 -> 1303;
1330 -> 1303;
1331 -> 1322;
1331 -> 1330;
1332 -> 1323;
1332 -> 1330;
1333 -> 1324;
1333 -> 1330;
1334 -> 1325;
1334 -> 1330;
1335 -> 1326;
1335 -> 1330;
1336 -> 1327;
1336 -> 1330;
1337 -> 1328;
1337 -> 1330;
1338 -> 1329;
1338 -> 1330;
1339 -> 1330;
1340 -> 1331;
1340 -> 1339;
1340 -> 1330;
1341 -> 1330;
1342 -> 1336;
1342 -> 1341;
1342 -> 1330;
1343 -> 1330;
1344 -> 1331;
1344 -> 1343;
1345 -> 1344;
1345 -> 1317;
1345 -> 1343;
1346 -> 1345;
1346 -> 1330;
1347 -> 1330;
1348 -> 1330;
1349 -> 1337;
1349 -> 1330;
1350 -> 1331;
1350 -> 1349;
1351 -> 1332;
1351 -> 1349;
1352 -> 1335;
1352 -> 1349;
1353 -> 1336;
1353 -> 1349;
1354 -> 1338;
1354 -> 1349;
1355 -> 1349;
1356 -> 1350;
1356 -> 1355;
1357 -> 1351;
1357 -> 1355;
1358 -> 1352;
1358 -> 1355;
1359 -> 1353;
1359 -> 1355;
1360 -> 1354;
1360 -> 1355;
1361 -> 1360;
1361 -> 1355;
1362 -> 1355;
1363 -> 1361;
1363 -> 1362;
1364 -> 1356;
1364 -> 1362;
1365 -> 1362;
1366 -> 1364;
1366 -> 1317;
1366 -> 1365;
1366 -> 1362;
1367 -> 1366;
1368 -> 1364;
1368 -> 1366;
1369 -> 1366;
1370 -> 1368;
1370 -> 1369;
1371 -> 1366;
1372 -> 1371;
1372 -> 1368;
1373 -> 1372;
1373 -> 1366;
1374 -> 1366;
1375 -> 1364;
1375 -> 1374;
1376 -> 1375;
1376 -> 1368;
1376 -> 1374;
1377 -> 1374;
1378 -> 1376;
1378 -> 1377;
1379 -> 1378;
1379 -> 1376;
1379 -> 1377;
1380 -> 1377;
1381 -> 1379;
1381 -> 1380;
1382 -> 1380;
1383 -> 1381;
1383 -> 1382;
1384 -> 1383;
1384 -> 1382;
1385 -> 1383;
1385 -> 1380;
1386 -> 1385;
1386 -> 1366;
1387 -> 1373;
1387 -> 1386;
1387 -> 1366;
1388 -> 1368;
1388 -> 1387;
1390 -> 0;
1392 -> 1389;
1392 -> 1391;
1393 -> 1390;
1393 -> 1391;
1394 -> 1391;
1395 -> 1394;
1395 -> 1391;
1396 -> 1392;
1396 -> 1394;
1396 -> 1391;
1397 -> 1393;
1397 -> 1394;
1397 -> 1391;
1398 -> 1391;
1399 -> 1398;
1399 -> 1388;
1400 -> 1364;
1400 -> 1385;
1400 -> 1366;
1401 -> 1399;
1401 -> 1366;
1402 -> 1366;
1403 -> 1400;
1403 -> 1401;
1403 -> 1402;
1403 -> 1396;
1403 -> 1397;
1403 -> 1385;
1403 -> 0;
1403 -> 1366;
1404 -> 1364;
1404 -> 1403;
1404 -> 1362;
1405 -> 1404;
1405 -> 1355;
1406 -> 1405;
1406 -> 1403;
1406 -> 1355;
1407 -> 1405;
1407 -> 1403;
1407 -> 1355;
1408 -> 1359;
1408 -> 1407;
1408 -> 1321;
1408 -> 1403;
1408 -> 1355;
1409 -> 1405;
1409 -> 1408;
1409 -> 1355;
1410 -> 1355;
1411 -> 1409;
1411 -> 1410;
1411 -> 1355;
1412 -> 1411;
1413 -> 1331;
1413 -> 1330;
1414 -> 1332;
1414 -> 1330;
1415 -> 1333;
1415 -> 1330;
1416 -> 1334;
1416 -> 1330;
1417 -> 1335;
1417 -> 1330;
1418 -> 1336;
1418 -> 1330;
1419 -> 1337;
1419 -> 1330;
1420 -> 1412;
1420 -> 1330;
1421 -> 1338;
1421 -> 1330;
1422 -> 1330;
1423 -> 1330;
1424 -> 1413;
1424 -> 1423;
1425 -> 1414;
1425 -> 1423;
1426 -> 1415;
1426 -> 1423;
1427 -> 1416;
1427 -> 1423;
1428 -> 1417;
1428 -> 1423;
1429 -> 1418;
1429 -> 1423;
1430 -> 1419;
1430 -> 1423;
1431 -> 1420;
1431 -> 1423;
1432 -> 1421;
1432 -> 1423;
1433 -> 1422;
1433 -> 1423;
1434 -> 1423;
1435 -> 1434;
1435 -> 1423;
1436 -> 1434;
1436 -> 1423;
1437 -> 1434;
1437 -> 1423;
1438 -> 1434;
1438 -> 1423;
1439 -> 1434;
1439 -> 1423;
1440 -> 1434;
1440 -> 1423;
1441 -> 1434;
1441 -> 1423;
1442 -> 1434;
1442 -> 1423;
1443 -> 1434;
1443 -> 1423;
1444 -> 1434;
1444 -> 1423;
1445 -> 1434;
1445 -> 1423;
1446 -> 1423;
1447 -> 1424;
1447 -> 1446;
1447 -> 1423;
1448 -> 1423;
1449 -> 1429;
1449 -> 1448;
1449 -> 1423;
1450 -> 1424;
1450 -> 1434;
1450 -> 1423;
1451 -> 1425;
1451 -> 1434;
1451 -> 1423;
1452 -> 1426;
1452 -> 1434;
1452 -> 1423;
1453 -> 1432;
1453 -> 1434;
1453 -> 1423;
1454 -> 1429;
1454 -> 1434;
1454 -> 1423;
1455 -> 1430;
1455 -> 1434;
1455 -> 1423;
1456 -> 1431;
1456 -> 1434;
1456 -> 1423;
1457 -> 1428;
1457 -> 1434;
1457 -> 1423;
1458 -> 1428;
1458 -> 1423;
1459 -> 1423;
1460 -> 1458;
1460 -> 1459;
1461 -> 1434;
1461 -> 1459;
1462 -> 1460;
1462 -> 1459;
1463 -> 1423;
1464 -> 1426;
1464 -> 1423;
1465 -> 1425;
1465 -> 1408;
1465 -> 1464;
1466 -> 1465;
1466 -> 1434;
1466 -> 1464;
1467 -> 1427;
1467 -> 1434;
1467 -> 1423;
1468 -> 1330;
1469 -> 1331;
1469 -> 1468;
1470 -> 1469;
1470 -> 1408;
1470 -> 1468;
1471 -> 1470;
1471 -> 1330;
1472 -> 1471;
1473 -> 1472;
1473 -> 1422;
1473 -> 1471;
1474 -> 1330;
1475 -> 1331;
1475 -> 1474;
1476 -> 1474;
1477 -> 1475;
1477 -> 1476;
1478 -> 1476;
1479 -> 1477;
1479 -> 1478;
1480 -> 1478;
1481 -> 1479;
1481 -> 1480;
1482 -> 1481;
1482 -> 1408;
1482 -> 1480;
1483 -> 1481;
1483 -> 1408;
1483 -> 1480;
1484 -> 1483;
1484 -> 1478;
1485 -> 1479;
1485 -> 1408;
1485 -> 1478;
1486 -> 1474;
1487 -> 1485;
1487 -> 1330;
1488 -> 1330;
1489 -> 1487;
1489 -> 1488;
1490 -> 1422;
1490 -> 1488;
1491 -> 1489;
1491 -> 1485;
1491 -> 1488;
1492 -> 1490;
1492 -> 1491;
1493 -> 1491;
1494 -> 1492;
1494 -> 1493;
1494 -> 1491;
1494 -> 1434;
1494 -> 1435;
1494 -> 1450;
1494 -> 1436;
1494 -> 1452;
1494 -> 1437;
1494 -> 1467;
1494 -> 1438;
1494 -> 1454;
1494 -> 1439;
1494 -> 1457;
1494 -> 1440;
1494 -> 1451;
1494 -> 1441;
1494 -> 1455;
1494 -> 1442;
1494 -> 1466;
1494 -> 1443;
1494 -> 1456;
1494 -> 1444;
1494 -> 1473;
1494 -> 1445;
1494 -> 1453;
1494 -> 825;
1494 -> 1465;
1494 -> 1472;
1495 -> 1494;
1495 -> 1493;
1496 -> 1494;
1496 -> 1493;
1497 -> 1494;
1497 -> 1493;
1498 -> 1497;
1498 -> 1494;
1498 -> 1493;
1499 -> 1495;
1499 -> 1493;
1500 -> 1493;
1501 -> 1498;
1501 -> 1500;
1502 -> 1499;
1502 -> 1500;
1503 -> 1500;
1504 -> 1501;
1504 -> 1503;
1504 -> 1500;
1505 -> 1493;
1506 -> 1497;
1506 -> 1494;
1506 -> 1493;
1507 -> 1493;
1508 -> 1497;
1508 -> 1506;
1508 -> 1507;
1509 -> 1508;
1509 -> 1493;
1510 -> 1495;
1510 -> 1509;
1511 -> 1509;
1512 -> 1510;
1512 -> 1511;
1513 -> 1497;
1513 -> 1511;
1514 -> 1511;
1515 -> 1513;
1515 -> 1506;
1515 -> 1511;
1516 -> 1515;
1516 -> 1509;
1517 -> 1516;
1517 -> 1509;
1518 -> 1493;
1519 -> 1494;
1519 -> 1518;
1519 -> 1517;
1519 -> 1491;
1520 -> 1330;
1521 -> 1330;
1522 -> 1422;
1522 -> 1521;
1523 -> 1522;
1523 -> 1519;
1523 -> 1521;
1524 -> 1521;
1525 -> 1523;
1525 -> 1524;
1525 -> 1521;
1526 -> 1521;
1527 -> 1526;
1527 -> 1521;
1528 -> 1523;
1528 -> 1527;
1528 -> 1519;
1528 -> 1521;
1529 -> 1528;
1530 -> 1330;
1531 -> 1330;
1532 -> 1332;
1532 -> 1531;
1532 -> 1330;
1533 -> 1336;
1533 -> 1532;
1534 -> 1532;
1535 -> 1533;
1535 -> 1534;
1536 -> 1332;
1536 -> 1534;
1537 -> 1536;
1537 -> 1529;
1537 -> 1534;
1538 -> 1537;
1538 -> 1532;
1539 -> 1538;
1539 -> 1532;
1540 -> 1336;
1540 -> 1532;
1541 -> 1532;
1542 -> 1539;
1542 -> 1541;
1543 -> 1540;
1543 -> 1541;
1544 -> 1422;
1544 -> 1541;
1545 -> 1542;
1545 -> 1541;
1546 -> 1532;
1547 -> 1336;
1547 -> 1532;
1548 -> 1532;
1549 -> 1547;
1549 -> 1548;
1550 -> 1332;
1550 -> 1548;
1551 -> 1548;
1552 -> 1549;
1552 -> 1548;
1553 -> 1548;
1554 -> 1552;
1554 -> 1553;
1555 -> 1550;
1555 -> 1553;
1556 -> 1553;
1557 -> 1555;
1557 -> 1556;
1558 -> 1556;
1559 -> 1558;
1559 -> 1557;
1559 -> 1556;
1560 -> 1556;
1561 -> 1557;
1561 -> 1560;
1562 -> 1561;
1562 -> 1529;
1562 -> 1559;
1562 -> 1560;
1563 -> 1562;
1563 -> 1556;
1564 -> 1563;
1564 -> 1553;
1565 -> 1553;
1566 -> 1555;
1566 -> 1565;
1567 -> 1566;
1567 -> 1562;
1567 -> 1565;
1568 -> 1567;
1568 -> 1553;
1569 -> 1568;
1570 -> 1564;
1570 -> 1569;
1570 -> 1568;
1571 -> 1570;
1572 -> 1548;
1573 -> 1551;
1573 -> 1548;
1574 -> 1550;
1574 -> 1567;
1574 -> 1548;
1575 -> 1573;
1575 -> 1574;
1575 -> 1551;
1575 -> 1567;
1575 -> 1548;
1576 -> 1551;
1576 -> 1548;
1577 -> 1550;
1577 -> 1575;
1577 -> 1548;
1578 -> 1551;
1578 -> 1548;
1579 -> 1550;
1579 -> 1577;
1579 -> 1548;
1580 -> 1551;
1580 -> 1548;
1581 -> 1550;
1581 -> 1579;
1581 -> 1548;
1582 -> 1551;
1582 -> 1548;
1583 -> 1550;
1583 -> 1581;
1583 -> 1548;
1584 -> 1551;
1584 -> 1548;
1585 -> 1550;
1585 -> 1583;
1585 -> 1548;
1586 -> 1551;
1586 -> 1548;
1587 -> 1550;
1587 -> 1585;
1587 -> 1548;
1588 -> 1551;
1588 -> 1548;
1589 -> 1550;
1589 -> 1587;
1589 -> 1548;
1590 -> 1551;
1590 -> 1589;
1590 -> 1548;
1591 -> 1590;
1591 -> 1532;
1592 -> 1591;
1592 -> 1532;
1593 -> 1336;
1593 -> 1532;
1594 -> 1532;
1595 -> 1592;
1595 -> 1594;
1596 -> 1593;
1596 -> 1594;
1597 -> 1422;
1597 -> 1594;
1598 -> 1595;
1598 -> 1594;
1599 -> 1532;
1600 -> 1532;
1601 -> 1331;
1601 -> 1600;
1602 -> 1601;
1602 -> 1589;
1602 -> 1600;
1603 -> 1602;
1603 -> 1532;
1604 -> 1422;
1604 -> 1532;
1605 -> 1332;
1605 -> 1532;
1606 -> 1336;
1606 -> 1532;
1607 -> 1532;
1608 -> 1603;
1608 -> 1607;
1609 -> 0;
1609 -> 1607;
1610 -> 1603;
1610 -> 1609;
1610 -> 0;
1610 -> 1532;
1611 -> 1603;
1611 -> 1607;
1612 -> 1607;
1613 -> 1603;
1613 -> 1612;
1613 -> 1610;
1613 -> 1532;
1614 -> 1532;
1615 -> 1422;
1615 -> 1614;
1616 -> 1615;
1616 -> 1613;
1616 -> 1614;
1617 -> 1614;
1618 -> 1616;
1618 -> 1617;
1618 -> 1614;
1619 -> 1614;
1620 -> 1619;
1620 -> 1614;
1621 -> 1532;
1622 -> 1332;
1622 -> 1616;
1622 -> 1532;
1623 -> 1532;
1624 -> 1622;
1624 -> 1623;
1624 -> 1532;
1625 -> 1330;
1626 -> 1332;
1626 -> 1625;
1626 -> 1330;
1627 -> 1422;
1627 -> 1616;
1627 -> 1332;
1627 -> 1330;
1628 -> 1330;
1629 -> 1331;
1629 -> 1628;
1630 -> 1629;
1630 -> 1616;
1630 -> 1628;
1631 -> 1630;
1631 -> 1330;
1632 -> 1330;
1633 -> 1337;
1633 -> 1632;
1633 -> 1330;
1634 -> 1331;
1634 -> 1633;
1635 -> 1336;
1635 -> 1633;
1636 -> 1338;
1636 -> 1633;
1637 -> 1633;
1638 -> 1634;
1638 -> 1637;
1639 -> 1635;
1639 -> 1637;
1640 -> 1636;
1640 -> 1637;
1641 -> 1637;
1642 -> 1638;
1642 -> 1641;
1643 -> 1641;
1644 -> 1642;
1644 -> 1643;
1645 -> 1643;
1646 -> 1644;
1646 -> 1645;
1647 -> 1646;
1647 -> 1631;
1647 -> 1645;
1648 -> 1646;
1648 -> 1631;
1648 -> 1645;
1649 -> 1648;
1649 -> 1643;
1650 -> 1644;
1650 -> 1631;
1650 -> 1643;
1651 -> 1650;
1651 -> 1637;
1652 -> 1640;
1652 -> 1637;
1653 -> 1652;
1653 -> 1651;
1653 -> 825;
1653 -> 1650;
1653 -> 1637;
1654 -> 1637;
1655 -> 1639;
1655 -> 1653;
1655 -> 1637;
1656 -> 1633;
1657 -> 1633;
1658 -> 1332;
1658 -> 1657;
1658 -> 1633;
1659 -> 1412;
1659 -> 1657;
1659 -> 1633;
1660 -> 1658;
1660 -> 1659;
1660 -> 1633;
1661 -> 1303;
1662 -> 1321;
1662 -> 1303;
1663 -> 1662;
1663 -> 1655;
1663 -> 1303;
1664 -> 1302;
1664 -> 1663;
1665 -> 1321;
1665 -> 1663;
1666 -> 1663;
1667 -> 1664;
1667 -> 1666;
1668 -> 1665;
1668 -> 1666;
1669 -> 833;
1669 -> 1666;
1670 -> 1669;
1670 -> 1663;
1670 -> 1666;
1671 -> 1669;
1671 -> 1663;
1671 -> 1666;
1672 -> 1663;
1673 -> 830;
1673 -> 1303;
1674 -> 1321;
1674 -> 1303;
1675 -> 832;
1675 -> 1303;
1676 -> 1673;
1676 -> 1674;
1676 -> 1675;
1676 -> 833;
1676 -> 1663;
1676 -> 825;
1676 -> 1303;
1677 -> 1303;
1678 -> 1300;
1678 -> 1676;
1678 -> 1303;
1679 -> 610;
1680 -> 614;
1680 -> 1679;
1680 -> 1676;
1680 -> 603;
1681 -> 614;
1681 -> 610;
1682 -> 614;
1682 -> 610;
1683 -> 614;
1683 -> 610;
1684 -> 614;
1684 -> 610;
1685 -> 614;
1685 -> 610;
1686 -> 614;
1686 -> 610;
1687 -> 614;
1687 -> 610;
1688 -> 610;
1689 -> 1681;
1689 -> 610;
1690 -> 1683;
1690 -> 610;
1691 -> 1688;
1691 -> 610;
1692 -> 1687;
1692 -> 1689;
1692 -> 1690;
1692 -> 1691;
1692 -> 1680;
1692 -> 1688;
1692 -> 610;
1693 -> 1681;
1693 -> 1692;
1693 -> 610;
1694 -> 610;
1695 -> 1687;
1695 -> 1694;
1696 -> 1694;
1697 -> 1695;
1697 -> 1696;
1698 -> 1697;
1698 -> 1692;
1698 -> 1696;
1699 -> 1697;
1699 -> 1692;
1699 -> 1696;
1700 -> 1699;
1700 -> 1694;
1701 -> 1695;
1701 -> 1692;
1701 -> 1694;
1702 -> 1701;
1702 -> 610;
1703 -> 610;
1704 -> 1688;
1704 -> 610;
1705 -> 610;
1706 -> 1704;
1706 -> 1705;
1707 -> 1687;
1707 -> 1705;
1708 -> 1705;
1709 -> 1707;
1709 -> 1708;
1710 -> 1708;
1711 -> 1709;
1711 -> 1710;
1712 -> 1711;
1712 -> 1702;
1712 -> 1710;
1713 -> 1711;
1713 -> 1702;
1713 -> 1710;
1714 -> 1713;
1714 -> 1708;
1715 -> 1709;
1715 -> 1702;
1715 -> 1708;
1716 -> 1715;
1716 -> 1705;
1717 -> 1705;
1718 -> 1717;
1718 -> 1716;
1718 -> 1715;
1718 -> 1705;
1719 -> 1705;
1720 -> 1719;
1720 -> 610;
1721 -> 1685;
1721 -> 610;
1722 -> 1688;
1722 -> 610;
1723 -> 1686;
1723 -> 610;
1724 -> 1721;
1724 -> 1722;
1724 -> 1723;
1724 -> 1687;
1724 -> 1715;
1724 -> 1680;
1724 -> 610;
1725 -> 610;
1726 -> 1686;
1726 -> 1680;
1726 -> 1724;
1726 -> 610;
1727 -> 610;
1728 -> 1684;
1728 -> 610;
1729 -> 610;
1734 -> 1731;
1734 -> 1730;
1735 -> 1732;
1735 -> 1730;
1736 -> 1733;
1736 -> 1730;
1737 -> 1730;
1738 -> 1687;
1738 -> 610;
1739 -> 1728;
1739 -> 610;
1740 -> 1682;
1740 -> 610;
1741 -> 1727;
1741 -> 610;
1742 -> 1686;
1742 -> 610;
1743 -> 610;
1744 -> 610;
1745 -> 1738;
1745 -> 1744;
1746 -> 1739;
1746 -> 1744;
1747 -> 1740;
1747 -> 1744;
1748 -> 1741;
1748 -> 1744;
1749 -> 1742;
1749 -> 1744;
1750 -> 1743;
1750 -> 1744;
1751 -> 1743;
1751 -> 1744;
1752 -> 1744;
1753 -> 1744;
1754 -> 1747;
1754 -> 1753;
1754 -> 1744;
1755 -> 1744;
1756 -> 1745;
1756 -> 1755;
1757 -> 1755;
1758 -> 1756;
1758 -> 1757;
1759 -> 1758;
1759 -> 1726;
1759 -> 1757;
1760 -> 1758;
1760 -> 1726;
1760 -> 1757;
1761 -> 1760;
1761 -> 1755;
1762 -> 1756;
1762 -> 1726;
1762 -> 1755;
1763 -> 1762;
1763 -> 1744;
1764 -> 1763;
1764 -> 1746;
1764 -> 1744;
1765 -> 1745;
1765 -> 1744;
1766 -> 1752;
1766 -> 1744;
1767 -> 1750;
1767 -> 1744;
1768 -> 1751;
1768 -> 1744;
1769 -> 1744;
1770 -> 1748;
1770 -> 1744;
1771 -> 1749;
1771 -> 1744;
1772 -> 1744;
1773 -> 1764;
1773 -> 1772;
1774 -> 1765;
1774 -> 1772;
1775 -> 1766;
1775 -> 1772;
1776 -> 1767;
1776 -> 1772;
1777 -> 1768;
1777 -> 1772;
1778 -> 1769;
1778 -> 1772;
1779 -> 1769;
1779 -> 1772;
1780 -> 1770;
1780 -> 1772;
1781 -> 1771;
1781 -> 1772;
1782 -> 1769;
1782 -> 1772;
1783 -> 1772;
1784 -> 1783;
1784 -> 1772;
1785 -> 1783;
1785 -> 1772;
1786 -> 1783;
1786 -> 1772;
1787 -> 1783;
1787 -> 1772;
1788 -> 1783;
1788 -> 1772;
1789 -> 1783;
1789 -> 1772;
1790 -> 1783;
1790 -> 1772;
1791 -> 1783;
1791 -> 1772;
1792 -> 1783;
1792 -> 1772;
1793 -> 1783;
1793 -> 1772;
1794 -> 1783;
1794 -> 1772;
1795 -> 1783;
1795 -> 1772;
1796 -> 1773;
1796 -> 1783;
1796 -> 1772;
1797 -> 1774;
1797 -> 1783;
1797 -> 1772;
1798 -> 1775;
1798 -> 1783;
1798 -> 1772;
1799 -> 1776;
1799 -> 1783;
1799 -> 1772;
1800 -> 1777;
1800 -> 1783;
1800 -> 1772;
1801 -> 1778;
1801 -> 1783;
1801 -> 1772;
1802 -> 1779;
1802 -> 1783;
1802 -> 1772;
1803 -> 1780;
1803 -> 1783;
1803 -> 1772;
1804 -> 1781;
1804 -> 1783;
1804 -> 1772;
1805 -> 1744;
1806 -> 1745;
1806 -> 1805;
1807 -> 1805;
1808 -> 1806;
1808 -> 1807;
1809 -> 1808;
1809 -> 1762;
1809 -> 1807;
1810 -> 1808;
1810 -> 1762;
1810 -> 1807;
1811 -> 1810;
1811 -> 1805;
1812 -> 1806;
1812 -> 1762;
1812 -> 1805;
1813 -> 1812;
1813 -> 1744;
1814 -> 1813;
1814 -> 1769;
1814 -> 1812;
1814 -> 1783;
1814 -> 1784;
1814 -> 1796;
1814 -> 1785;
1814 -> 1797;
1814 -> 1786;
1814 -> 1798;
1814 -> 1787;
1814 -> 1799;
1814 -> 1788;
1814 -> 1800;
1814 -> 1789;
1814 -> 1801;
1814 -> 1790;
1814 -> 1802;
1814 -> 1791;
1814 -> 1803;
1814 -> 1792;
1814 -> 1793;
1814 -> 1794;
1814 -> 1795;
1814 -> 1804;
1814 -> 1743;
1814 -> 1727;
1814 -> 1726;
1814 -> 1744;
1815 -> 1744;
1816 -> 1814;
1816 -> 1815;
1817 -> 1814;
1817 -> 1815;
1818 -> 1817;
1818 -> 1814;
1818 -> 1815;
1819 -> 1816;
1819 -> 1818;
1819 -> 1815;
1820 -> 1819;
1821 -> 1819;
1822 -> 1819;
1823 -> 1821;
1823 -> 1822;
1824 -> 1817;
1824 -> 1822;
1825 -> 1824;
1825 -> 1818;
1825 -> 1822;
1826 -> 1822;
1827 -> 1825;
1828 -> 1819;
1829 -> 1819;
1830 -> 1828;
1830 -> 1829;
1831 -> 1817;
1831 -> 1829;
1832 -> 1831;
1832 -> 1818;
1832 -> 1829;
1833 -> 1829;
1834 -> 1832;
1835 -> 1819;
1836 -> 1817;
1836 -> 1835;
1837 -> 1836;
1837 -> 1818;
1837 -> 1835;
1838 -> 1819;
1839 -> 1819;
1840 -> 1839;
1840 -> 1819;
1841 -> 1840;
1842 -> 1840;
1843 -> 1841;
1843 -> 1842;
1844 -> 1817;
1844 -> 1842;
1845 -> 1844;
1845 -> 1818;
1845 -> 1842;
1846 -> 1842;
1847 -> 1845;
1848 -> 1840;
1849 -> 1817;
1849 -> 1848;
1850 -> 1849;
1850 -> 1818;
1850 -> 1837;
1850 -> 1848;
1851 -> 1840;
1852 -> 1840;
1853 -> 1817;
1853 -> 1818;
1853 -> 1852;
1853 -> 1840;
1854 -> 1840;
1855 -> 1852;
1855 -> 1854;
1856 -> 1852;
1856 -> 1854;
1857 -> 1817;
1857 -> 1854;
1858 -> 1855;
1858 -> 1854;
1859 -> 1856;
1859 -> 1854;
1860 -> 1858;
1860 -> 1859;
1860 -> 1854;
1861 -> 1854;
1862 -> 1860;
1862 -> 1861;
1863 -> 1857;
1863 -> 1861;
1864 -> 1863;
1864 -> 1818;
1864 -> 1861;
1865 -> 1861;
1866 -> 1864;
1867 -> 1854;
1868 -> 1840;
1869 -> 1817;
1869 -> 1868;
1870 -> 1869;
1870 -> 1818;
1870 -> 1837;
1870 -> 1850;
1870 -> 1868;
1871 -> 1868;
1872 -> 1869;
1872 -> 1818;
1872 -> 1837;
1872 -> 1850;
1872 -> 1870;
1872 -> 1871;
1872 -> 1868;
1873 -> 1840;
1874 -> 1840;
1875 -> 1840;
1876 -> 1874;
1876 -> 1875;
1877 -> 1817;
1877 -> 1875;
1878 -> 1877;
1878 -> 1818;
1878 -> 1875;
1879 -> 1875;
1880 -> 1878;
1881 -> 1819;
1882 -> 1819;
1883 -> 1881;
1883 -> 1882;
1884 -> 1817;
1884 -> 1882;
1885 -> 1884;
1885 -> 1818;
1885 -> 1882;
1886 -> 1882;
1887 -> 1885;
1888 -> 1819;
1889 -> 1817;
1889 -> 1888;
1890 -> 1889;
1890 -> 1818;
1890 -> 1837;
1890 -> 1850;
1890 -> 1870;
1890 -> 1888;
1891 -> 1819;
1892 -> 1817;
1892 -> 1818;
1892 -> 1815;
1893 -> 1816;
1893 -> 1818;
1893 -> 1837;
1893 -> 1850;
1893 -> 1870;
1893 -> 1890;
1893 -> 1815;
1894 -> 1817;
1894 -> 1818;
1894 -> 1837;
1894 -> 1850;
1894 -> 1870;
1894 -> 1890;
1894 -> 1893;
1895 -> 1817;
1895 -> 1893;
1896 -> 1895;
1896 -> 1893;
1896 -> 1894;
1896 -> 1818;
1896 -> 1837;
1896 -> 1850;
1896 -> 1870;
1896 -> 1890;
1897 -> 1893;
1898 -> 1896;
1898 -> 1897;
1899 -> 1896;
1899 -> 1897;
1900 -> 1899;
1900 -> 1896;
1900 -> 1897;
1901 -> 1897;
1902 -> 1899;
1902 -> 1900;
1902 -> 1901;
1902 -> 1897;
1903 -> 1898;
1903 -> 1897;
1904 -> 1897;
1905 -> 1903;
1905 -> 1904;
1906 -> 1899;
1906 -> 1904;
1907 -> 1906;
1907 -> 1900;
1907 -> 1904;
1908 -> 1905;
1908 -> 1904;
1909 -> 1904;
1910 -> 1908;
1910 -> 1909;
1911 -> 1910;
1911 -> 1909;
1912 -> 1911;
1912 -> 1907;
1912 -> 1909;
1913 -> 1904;
1914 -> 1906;
1914 -> 1912;
1914 -> 1913;
1914 -> 1904;
1915 -> 1905;
1915 -> 1904;
1916 -> 1915;
1916 -> 1912;
1916 -> 1904;
1917 -> 1916;
1917 -> 1904;
1918 -> 1904;
1919 -> 1904;
1920 -> 1919;
1920 -> 1904;
1921 -> 1905;
1921 -> 1904;
1922 -> 1918;
1922 -> 1904;
1923 -> 1919;
1923 -> 1904;
1924 -> 1904;
1925 -> 1921;
1925 -> 1924;
1926 -> 1922;
1926 -> 1924;
1927 -> 1923;
1927 -> 1924;
1928 -> 1906;
1928 -> 1924;
1929 -> 0;
1929 -> 1924;
1930 -> 1924;
1931 -> 1924;
1932 -> 1925;
1932 -> 1916;
1932 -> 1924;
1933 -> 1932;
1933 -> 1916;
1934 -> 1933;
1934 -> 1929;
1934 -> 1932;
1935 -> 1934;
1935 -> 1932;
1936 -> 1932;
1937 -> 1928;
1937 -> 1936;
1937 -> 1932;
1938 -> 1937;
1938 -> 1932;
1939 -> 1924;
1940 -> 1931;
1940 -> 1939;
1940 -> 1924;
1941 -> 0;
1941 -> 1940;
1942 -> 1924;
1943 -> 1942;
1943 -> 1904;
1944 -> 1941;
1944 -> 0;
1944 -> 1904;
1945 -> 1935;
1945 -> 0;
1945 -> 1944;
1946 -> 1944;
1947 -> 1897;
1948 -> 1899;
1948 -> 1937;
1948 -> 1897;
1949 -> 1898;
1949 -> 1937;
1949 -> 1948;
1950 -> 1816;
1950 -> 1949;
1950 -> 1815;
1951 -> 1950;
1952 -> 1951;
1953 -> 1950;
1954 -> 1950;
1955 -> 1950;
1956 -> 1954;
1956 -> 1955;
1957 -> 1817;
1957 -> 1955;
1958 -> 1957;
1958 -> 1949;
1958 -> 1955;
1959 -> 1955;
1960 -> 1958;
1961 -> 1950;
1962 -> 1961;
1962 -> 1949;
1962 -> 1951;
1963 -> 1961;
1964 -> 1961;
1964 -> 1949;
1964 -> 1951;
1964 -> 1962;
1964 -> 1963;
1965 -> 1950;
1966 -> 1950;
1967 -> 1950;
1968 -> 1966;
1968 -> 1967;
1969 -> 1817;
1969 -> 1967;
1970 -> 1969;
1970 -> 1949;
1970 -> 1967;
1971 -> 1967;
1972 -> 1970;
1973 -> 1744;
1974 -> 1769;
1974 -> 1962;
1974 -> 1973;
1974 -> 1744;
1975 -> 1752;
1975 -> 1744;
1976 -> 1744;
1977 -> 1750;
1977 -> 1976;
1977 -> 1744;
1978 -> 1977;
1979 -> 1745;
1979 -> 1978;
1980 -> 1978;
1981 -> 1979;
1981 -> 1962;
1981 -> 1980;
1982 -> 1980;
1983 -> 1981;
1983 -> 1977;
1984 -> 1983;
1985 -> 1748;
1985 -> 1983;
1986 -> 1749;
1986 -> 1983;
1987 -> 1983;
1988 -> 1984;
1988 -> 1987;
1989 -> 1984;
1989 -> 1987;
1990 -> 1985;
1990 -> 1987;
1991 -> 1986;
1991 -> 1987;
1992 -> 1988;
1992 -> 1987;
1993 -> 1685;
1993 -> 610;
1994 -> 1727;
1994 -> 610;
1995 -> 1686;
1995 -> 610;
1996 -> 1993;
1996 -> 1994;
1996 -> 1995;
1996 -> 1687;
1996 -> 1992;
1996 -> 610;
1997 -> 610;
1998 -> 614;
1998 -> 610;
1999 -> 614;
1999 -> 610;
2000 -> 614;
2000 -> 610;
2001 -> 614;
2001 -> 610;
2002 -> 610;
2003 -> 2001;
2003 -> 1996;
2003 -> 2002;
2003 -> 610;
2004 -> 1998;
2004 -> 610;
2005 -> 610;
2006 -> 2004;
2006 -> 2005;
2007 -> 2001;
2007 -> 2005;
2008 -> 2005;
2009 -> 2007;
2009 -> 1996;
2009 -> 2008;
2009 -> 2005;
2010 -> 610;
2011 -> 614;
2011 -> 610;
2012 -> 610;
2013 -> 2011;
2013 -> 2012;
2014 -> 2012;
2015 -> 2013;
2015 -> 2014;
2016 -> 2014;
2017 -> 2015;
2017 -> 2016;
2018 -> 2016;
2019 -> 2017;
2019 -> 2018;
2020 -> 1996;
2020 -> 2016;
2021 -> 2012;
2022 -> 614;
2022 -> 610;
2023 -> 610;
2024 -> 2022;
2024 -> 2023;
2025 -> 2023;
2026 -> 2024;
2026 -> 2025;
2027 -> 1996;
2027 -> 2023;
2028 -> 610;
2029 -> 614;
2029 -> 610;
2030 -> 610;
2031 -> 2029;
2031 -> 2030;
2032 -> 2030;
2033 -> 2031;
2033 -> 2032;
2034 -> 1996;
2034 -> 2030;
2035 -> 614;
2035 -> 610;
2036 -> 614;
2036 -> 610;
2037 -> 610;
2038 -> 2036;
2038 -> 2037;
2039 -> 2038;
2039 -> 1996;
2039 -> 2037;
2040 -> 2039;
2040 -> 610;
2041 -> 2040;
2041 -> 1996;
2041 -> 610;
2042 -> 2040;
2042 -> 610;
2043 -> 2036;
2043 -> 1996;
2043 -> 610;
2044 -> 610;
2045 -> 614;
2045 -> 2044;
2045 -> 1996;
2045 -> 603;
2046 -> 614;
2046 -> 610;
2047 -> 614;
2047 -> 610;
2048 -> 2047;
2048 -> 2045;
2048 -> 610;
2049 -> 610;
2050 -> 2049;
2050 -> 2048;
2050 -> 2045;
2050 -> 610;
2051 -> 610;
2052 -> 614;
2052 -> 2051;
2052 -> 2045;
2052 -> 603;
2053 -> 614;
2053 -> 610;
2054 -> 614;
2054 -> 610;
2055 -> 2053;
2055 -> 2052;
2055 -> 610;
2056 -> 2054;
2056 -> 2052;
2056 -> 2055;
2057 -> 2053;
2057 -> 2055;
2058 -> 2055;
2059 -> 2056;
2059 -> 2058;
2060 -> 2057;
2060 -> 2058;
2061 -> 2054;
2061 -> 2058;
2062 -> 2059;
2062 -> 2052;
2062 -> 2058;
2063 -> 2062;
2064 -> 2059;
2064 -> 2052;
2064 -> 2062;
2065 -> 2062;
2066 -> 2065;
2066 -> 2064;
2066 -> 2052;
2066 -> 2062;
2067 -> 2060;
2067 -> 2052;
2067 -> 2062;
2068 -> 2061;
2068 -> 2052;
2068 -> 2067;
2069 -> 2059;
2069 -> 2062;
2070 -> 2063;
2070 -> 2062;
2071 -> 2062;
2072 -> 2063;
2072 -> 2070;
2072 -> 2062;
2073 -> 2070;
2073 -> 2058;
2074 -> 614;
2074 -> 2073;
2074 -> 2072;
2074 -> 2070;
2074 -> 603;
2075 -> 614;
2075 -> 610;
2076 -> 2075;
2076 -> 2074;
2076 -> 610;
2077 -> 614;
2077 -> 610;
2078 -> 614;
2078 -> 610;
2079 -> 2077;
2079 -> 2076;
2079 -> 610;
2080 -> 610;
2081 -> 2078;
2081 -> 2076;
2081 -> 2080;
2082 -> 2081;
2082 -> 610;
2083 -> 610;
2084 -> 614;
2084 -> 610;
2085 -> 614;
2085 -> 610;
2086 -> 2084;
2086 -> 2082;
2086 -> 610;
2087 -> 610;
2088 -> 2086;
2088 -> 2087;
2089 -> 2085;
2089 -> 2087;
2090 -> 2089;
2090 -> 2082;
2090 -> 2087;
2091 -> 2090;
2091 -> 610;
2092 -> 610;
2093 -> 614;
2093 -> 610;
2094 -> 614;
2094 -> 610;
2095 -> 2093;
2095 -> 2091;
2095 -> 610;
2096 -> 610;
2097 -> 2095;
2097 -> 2096;
2098 -> 2094;
2098 -> 2096;
2099 -> 2096;
2100 -> 2097;
2100 -> 2096;
2101 -> 2096;
2102 -> 2100;
2102 -> 2101;
2103 -> 2098;
2103 -> 2101;
2104 -> 2101;
2105 -> 2103;
2105 -> 2104;
2106 -> 2104;
2107 -> 2106;
2107 -> 2105;
2107 -> 2104;
2108 -> 2104;
2109 -> 2105;
2109 -> 2108;
2110 -> 2109;
2110 -> 2091;
2110 -> 2107;
2110 -> 2108;
2111 -> 2110;
2111 -> 2104;
2112 -> 2111;
2112 -> 2101;
2113 -> 2101;
2114 -> 2103;
2114 -> 2113;
2115 -> 2110;
2115 -> 2101;
2116 -> 2115;
2117 -> 2112;
2117 -> 2116;
2117 -> 2115;
2118 -> 2117;
2119 -> 2096;
2120 -> 2099;
2120 -> 2096;
2121 -> 2099;
2121 -> 2096;
2122 -> 2099;
2122 -> 2096;
2123 -> 2099;
2123 -> 2096;
2124 -> 2099;
2124 -> 2096;
2125 -> 2099;
2125 -> 2096;
2126 -> 2099;
2126 -> 2096;
2127 -> 2099;
2127 -> 2096;
2128 -> 2099;
2128 -> 2110;
2128 -> 2096;
2129 -> 2128;
2129 -> 610;
2130 -> 610;
2131 -> 614;
2131 -> 610;
2132 -> 614;
2132 -> 610;
2133 -> 610;
2134 -> 2132;
2134 -> 2129;
2134 -> 610;
2135 -> 2133;
2135 -> 2134;
2135 -> 2129;
2135 -> 610;
2136 -> 610;
2137 -> 2133;
2137 -> 2135;
2137 -> 2136;
2137 -> 610;
2138 -> 2133;
2138 -> 2135;
2138 -> 2137;
2139 -> 2138;
2139 -> 2137;
2140 -> 2139;
2140 -> 2138;
2140 -> 0;
2141 -> 2140;
2142 -> 2139;
2142 -> 2138;
2142 -> 2140;
2144 -> 2143;
2145 -> 2143;
2146 -> 614;
2146 -> 610;
2147 -> 614;
2147 -> 610;
2148 -> 610;
2149 -> 614;
2149 -> 2148;
2149 -> 2141;
2149 -> 603;
2150 -> 614;
2150 -> 610;
2151 -> 614;
2151 -> 610;
2152 -> 2151;
2152 -> 610;
2153 -> 2150;
2153 -> 610;
2154 -> 2151;
2154 -> 2149;
2154 -> 610;
2155 -> 2152;
2155 -> 2153;
2155 -> 2154;
2155 -> 2151;
2155 -> 2149;
2155 -> 610;
2156 -> 610;
2157 -> 2156;
2158 -> 2157;
2159 -> 2155;
2159 -> 2157;
2160 -> 2155;
2160 -> 2156;
2161 -> 2155;
2161 -> 2156;
2162 -> 2156;
2163 -> 2161;
2163 -> 2162;
2164 -> 2163;
2164 -> 2156;
2165 -> 2156;
2166 -> 2165;
2166 -> 2164;
2166 -> 2155;
2166 -> 2156;
2167 -> 614;
2167 -> 610;
2168 -> 2167;
2168 -> 2155;
2168 -> 610;
2169 -> 610;
2170 -> 2038;
2170 -> 2168;
2170 -> 2037;
2171 -> 2170;
2171 -> 610;
2172 -> 2171;
2172 -> 2168;
2172 -> 610;
2173 -> 2171;
2173 -> 610;
2174 -> 2036;
2174 -> 2168;
2174 -> 610;
2175 -> 2047;
2175 -> 2168;
2175 -> 610;
2176 -> 2049;
2176 -> 2175;
2176 -> 2168;
2176 -> 610;
2177 -> 614;
2177 -> 610;
2178 -> 2177;
2178 -> 610;
2179 -> 2178;
2179 -> 2177;
2179 -> 2168;
2179 -> 610;
2180 -> 610;
2181 -> 2077;
2181 -> 2179;
2181 -> 610;
2182 -> 2084;
2182 -> 2179;
2182 -> 610;
2183 -> 2182;
2183 -> 2087;
2184 -> 2093;
2184 -> 2179;
2184 -> 610;
2185 -> 2184;
2185 -> 2096;
2186 -> 2185;
2186 -> 2096;
2187 -> 2186;
2187 -> 2101;
2188 -> 2179;
2188 -> 2104;
2189 -> 2188;
2189 -> 2101;
2190 -> 2179;
2190 -> 2101;
2191 -> 2190;
2192 -> 2189;
2192 -> 2191;
2192 -> 2190;
2193 -> 2192;
2194 -> 614;
2194 -> 610;
2195 -> 614;
2195 -> 610;
2196 -> 2194;
2196 -> 610;
2197 -> 2194;
2197 -> 2179;
2197 -> 610;
2198 -> 610;
2199 -> 2195;
2199 -> 2198;
2200 -> 2198;
2201 -> 2199;
2201 -> 2200;
2202 -> 2200;
2203 -> 2201;
2203 -> 2202;
2204 -> 2202;
2205 -> 2203;
2205 -> 2204;
2206 -> 2179;
2206 -> 2202;
2207 -> 2198;
2208 -> 2179;
2208 -> 610;
2209 -> 610;
2210 -> 2195;
2210 -> 2209;
2211 -> 614;
2211 -> 610;
2212 -> 614;
2212 -> 610;
2213 -> 2212;
2213 -> 2179;
2213 -> 610;
2214 -> 2212;
2214 -> 2179;
2214 -> 610;
2215 -> 2214;
2216 -> 2212;
2216 -> 2215;
2217 -> 2216;
2217 -> 2179;
2217 -> 2215;
2218 -> 2215;
2219 -> 2216;
2219 -> 2179;
2219 -> 2215;
2220 -> 2217;
2220 -> 2179;
2220 -> 2219;
2221 -> 2219;
2222 -> 2221;
2222 -> 2220;
2222 -> 2179;
2222 -> 2219;
2223 -> 2216;
2223 -> 2179;
2223 -> 2215;
2224 -> 2215;
2225 -> 2217;
2225 -> 2179;
2225 -> 2224;
2226 -> 2225;
2226 -> 2215;
2227 -> 2217;
2227 -> 2215;
2228 -> 2218;
2228 -> 2215;
2229 -> 2215;
2230 -> 2227;
2230 -> 2229;
2231 -> 2228;
2231 -> 2229;
2232 -> 2229;
2233 -> 2232;
2233 -> 2229;
2234 -> 2230;
2234 -> 2179;
2234 -> 2229;
2235 -> 2231;
2235 -> 2229;
2236 -> 2229;
2237 -> 2233;
2237 -> 2236;
2238 -> 2234;
2238 -> 2236;
2239 -> 2235;
2239 -> 2236;
2240 -> 2236;
2241 -> 2238;
2241 -> 2240;
2241 -> 2236;
2242 -> 2229;
2243 -> 2229;
2244 -> 2230;
2244 -> 2234;
2244 -> 2243;
2245 -> 2244;
2245 -> 2229;
2246 -> 2232;
2246 -> 2245;
2247 -> 2230;
2247 -> 2234;
2247 -> 2245;
2248 -> 2231;
2248 -> 2245;
2249 -> 2245;
2250 -> 2246;
2250 -> 2249;
2251 -> 2247;
2251 -> 2249;
2252 -> 2248;
2252 -> 2249;
2253 -> 2249;
2254 -> 2251;
2254 -> 2253;
2254 -> 2249;
2255 -> 2245;
2256 -> 2232;
2256 -> 2229;
2257 -> 2256;
2257 -> 2215;
2258 -> 2218;
2258 -> 2215;
2259 -> 2258;
2259 -> 2214;
2260 -> 2259;
2260 -> 2212;
2260 -> 2214;
2261 -> 2214;
2262 -> 2212;
2262 -> 2247;
2262 -> 2260;
2262 -> 2258;
2262 -> 2261;
2262 -> 2214;
2263 -> 2212;
2263 -> 2247;
2263 -> 2260;
2263 -> 610;
2264 -> 614;
2264 -> 610;
2265 -> 614;
2265 -> 610;
2266 -> 614;
2266 -> 610;
2267 -> 2266;
2267 -> 2263;
2267 -> 610;
2268 -> 2267;
2268 -> 2263;
2268 -> 610;
2269 -> 610;
2270 -> 2269;
2270 -> 2268;
2270 -> 610;
2271 -> 614;
2271 -> 610;
2272 -> 0;
2272 -> 610;
2273 -> 614;
2273 -> 2272;
2273 -> 2263;
2273 -> 0;
2273 -> 603;
2274 -> 614;
2274 -> 610;
2275 -> 2274;
2275 -> 2273;
2275 -> 610;
2276 -> 614;
2276 -> 610;
2277 -> 2276;
2277 -> 2275;
2277 -> 610;
2278 -> 2212;
2278 -> 2277;
2278 -> 610;
2279 -> 614;
2279 -> 610;
2280 -> 2279;
2280 -> 2277;
2280 -> 610;
2281 -> 614;
2281 -> 610;
2282 -> 2281;
2282 -> 2280;
2282 -> 610;
2283 -> 0;
2283 -> 2282;
2284 -> 2194;
2284 -> 2283;
2284 -> 610;
2285 -> 2283;
2285 -> 2202;
2286 -> 2283;
2286 -> 610;
2287 -> 614;
2287 -> 610;
2288 -> 610;
2289 -> 610;
2290 -> 2287;
2290 -> 2283;
2290 -> 610;
2291 -> 2289;
2291 -> 2290;
2291 -> 2283;
2291 -> 610;
2292 -> 610;
2293 -> 610;
2294 -> 2289;
2294 -> 2291;
2294 -> 2293;
2294 -> 610;
2295 -> 2289;
2295 -> 2291;
2295 -> 2294;
2296 -> 2295;
2296 -> 2294;
2297 -> 2295;
2297 -> 2296;
2298 -> 2296;
2299 -> 2297;
2299 -> 2298;
2300 -> 2287;
2300 -> 2298;
2301 -> 2299;
2301 -> 2295;
2301 -> 2298;
2302 -> 2300;
2302 -> 2295;
2302 -> 2301;
2302 -> 2298;
2303 -> 2298;
2304 -> 2298;
2305 -> 2299;
2305 -> 2295;
2305 -> 2298;
2306 -> 2305;
2307 -> 2304;
2307 -> 2306;
2307 -> 2305;
2308 -> 2305;
2308 -> 2307;
2309 -> 2308;
2309 -> 2298;
2310 -> 2296;
2311 -> 2309;
2311 -> 2310;
2311 -> 2296;
2312 -> 2295;
2312 -> 2311;
2313 -> 2312;
2313 -> 2295;
2314 -> 2312;
2314 -> 2313;
2315 -> 2314;
2316 -> 2314;
2317 -> 2315;
2317 -> 2316;
2318 -> 2287;
2318 -> 2316;
2319 -> 2317;
2319 -> 2314;
2319 -> 2316;
2320 -> 2318;
2320 -> 2314;
2320 -> 2319;
2320 -> 2316;
2321 -> 2316;
2322 -> 2314;
2323 -> 2317;
2323 -> 2322;
2323 -> 2314;
2324 -> 2288;
2324 -> 2323;
2325 -> 2317;
2325 -> 2323;
2326 -> 2314;
2326 -> 2323;
2327 -> 2323;
2328 -> 2324;
2328 -> 2327;
2329 -> 2325;
2329 -> 2327;
2330 -> 2326;
2330 -> 2327;
2331 -> 2287;
2331 -> 2327;
2332 -> 2329;
2332 -> 2326;
2332 -> 2327;
2333 -> 2332;
2333 -> 2327;
2334 -> 2329;
2334 -> 2332;
2334 -> 2327;
2335 -> 2331;
2335 -> 2332;
2335 -> 2333;
2335 -> 2334;
2335 -> 2327;
2336 -> 2327;
2337 -> 2335;
2337 -> 2336;
2337 -> 2327;
2338 -> 2323;
2339 -> 2314;
2339 -> 2335;
2339 -> 2323;
2340 -> 2288;
2340 -> 610;
2341 -> 614;
2341 -> 2340;
2341 -> 2335;
2341 -> 2288;
2341 -> 603;
2342 -> 2341;
2342 -> 2030;
2343 -> 599;
2343 -> 596;
2344 -> 596;
2345 -> 2341;
2345 -> 2344;
2346 -> 2343;
2346 -> 2344;
2347 -> 2345;
2347 -> 2344;
2348 -> 2346;
2348 -> 2344;
2349 -> 2344;
2350 -> 2347;
2350 -> 2349;
2351 -> 2348;
2351 -> 2349;
2352 -> 2350;
2352 -> 2349;
2353 -> 2351;
2353 -> 2349;
2354 -> 2349;
2355 -> 2349;
2356 -> 2352;
2356 -> 2355;
2357 -> 2353;
2357 -> 2355;
2358 -> 2354;
2358 -> 2355;
2359 -> 2355;
2360 -> 2357;
2360 -> 2359;
2360 -> 2355;
2361 -> 2357;
2361 -> 2355;
2362 -> 2357;
2362 -> 2355;
2363 -> 2356;
2363 -> 2355;
2364 -> 2358;
2364 -> 2361;
2364 -> 2362;
2364 -> 2355;
2365 -> 2363;
2365 -> 2364;
2365 -> 2355;
2366 -> 2357;
2366 -> 2355;
2367 -> 2355;
2368 -> 2365;
2368 -> 2367;
2368 -> 2355;
2369 -> 2355;
2371 -> 2370;
2373 -> 2372;
2374 -> 2357;
2374 -> 2355;
2375 -> 2356;
2375 -> 2355;
2376 -> 2355;
2377 -> 2374;
2377 -> 2376;
2378 -> 2375;
2378 -> 2376;
2379 -> 2376;
2380 -> 2376;
2381 -> 2378;
2381 -> 2376;
2382 -> 2381;
2382 -> 2365;
2382 -> 2376;
2383 -> 2382;
2383 -> 2376;
2384 -> 2380;
2384 -> 2383;
2385 -> 2384;
2385 -> 2379;
2385 -> 2376;
2386 -> 2384;
2386 -> 2379;
2386 -> 2376;
2387 -> 2386;
2387 -> 2376;
2388 -> 2377;
2388 -> 2376;
2389 -> 2377;
2389 -> 2376;
2390 -> 2377;
2390 -> 2376;
2391 -> 2376;
2392 -> 2390;
2392 -> 2391;
2394 -> 2393;
2395 -> 2393;
2396 -> 2395;
2396 -> 2391;
2397 -> 2391;
2398 -> 2392;
2398 -> 2391;
2399 -> 2391;
2400 -> 2399;
2400 -> 2376;
2401 -> 2378;
2401 -> 2400;
2402 -> 2400;
2403 -> 2401;
2403 -> 2402;
2404 -> 2403;
2404 -> 2402;
2405 -> 2402;
2406 -> 2395;
2406 -> 2402;
2407 -> 2404;
2407 -> 2405;
2407 -> 2406;
2407 -> 2365;
2407 -> 2402;
2408 -> 2376;
2409 -> 2408;
2409 -> 2376;
2410 -> 2376;
2411 -> 2376;
2412 -> 2408;
2412 -> 2411;
2412 -> 2409;
2412 -> 2376;
2413 -> 2376;
2414 -> 2377;
2414 -> 2376;
2415 -> 2408;
2415 -> 2376;
2416 -> 2413;
2416 -> 2376;
2417 -> 2376;
2418 -> 2415;
2418 -> 2417;
2419 -> 2416;
2419 -> 2417;
2420 -> 2419;
2420 -> 2413;
2420 -> 2417;
2421 -> 2417;
2422 -> 2421;
2422 -> 2420;
2422 -> 2417;
2423 -> 2376;
2424 -> 2376;
2425 -> 2408;
2425 -> 2424;
2425 -> 2412;
2425 -> 2376;
2426 -> 2376;
2427 -> 2407;
2427 -> 2376;
2428 -> 2376;
2429 -> 2427;
2429 -> 2376;
2430 -> 2376;
2431 -> 2428;
2431 -> 2430;
2431 -> 2376;
2432 -> 2376;
2433 -> 2408;
2433 -> 2432;
2433 -> 2425;
2433 -> 2376;
2434 -> 2413;
2434 -> 2376;
2435 -> 2426;
2435 -> 2376;
2439 -> 2437;
2439 -> 2436;
2440 -> 2438;
2440 -> 2436;
2441 -> 2436;
2442 -> 0;
2442 -> 2376;
2443 -> 2376;
2444 -> 2376;
2445 -> 2434;
2445 -> 2444;
2446 -> 2435;
2446 -> 2444;
2447 -> 2442;
2447 -> 2444;
2448 -> 2443;
2448 -> 2444;
2449 -> 2443;
2449 -> 2444;
2450 -> 2444;
2451 -> 2448;
2451 -> 2450;
2451 -> 2444;
2452 -> 2451;
2452 -> 2444;
2453 -> 0;
2455 -> 2453;
2455 -> 2454;
2456 -> 2454;
2458 -> 2457;
2460 -> 2459;
2462 -> 2461;
2463 -> 2456;
2464 -> 2456;
2464 -> 2454;
2465 -> 2455;
2465 -> 2456;
2465 -> 2454;
2466 -> 2454;
2467 -> 2444;
2468 -> 2467;
2468 -> 2449;
2468 -> 2444;
2469 -> 2445;
2469 -> 2444;
2470 -> 2446;
2470 -> 2444;
2471 -> 2447;
2471 -> 2444;
2472 -> 2469;
2472 -> 2444;
2473 -> 2470;
2473 -> 2444;
2474 -> 2468;
2474 -> 2444;
2475 -> 2444;
2476 -> 2472;
2476 -> 2475;
2477 -> 2473;
2477 -> 2475;
2478 -> 2474;
2478 -> 2475;
2479 -> 2452;
2479 -> 2475;
2480 -> 2476;
2480 -> 2475;
2481 -> 2476;
2481 -> 2469;
2481 -> 2475;
2482 -> 2477;
2482 -> 2475;
2483 -> 2477;
2483 -> 2470;
2483 -> 2475;
2484 -> 2475;
2485 -> 2480;
2485 -> 2484;
2486 -> 2481;
2486 -> 2484;
2487 -> 2482;
2487 -> 2484;
2488 -> 2483;
2488 -> 2484;
2489 -> 2479;
2489 -> 2484;
2490 -> 2485;
2490 -> 2484;
2491 -> 2486;
2491 -> 2484;
2492 -> 2487;
2492 -> 2484;
2493 -> 2488;
2493 -> 2484;
2494 -> 2484;
2495 -> 2490;
2495 -> 2494;
2496 -> 2491;
2496 -> 2494;
2497 -> 2492;
2497 -> 2494;
2498 -> 2493;
2498 -> 2494;
2499 -> 2489;
2499 -> 2494;
2500 -> 2494;
2501 -> 2496;
2501 -> 2500;
2501 -> 2494;
2502 -> 2494;
2503 -> 2498;
2503 -> 2502;
2503 -> 2494;
2504 -> 2501;
2504 -> 2503;
2504 -> 2494;
2505 -> 2494;
2506 -> 2505;
2506 -> 2504;
2506 -> 2494;
2507 -> 2494;
2508 -> 2507;
2508 -> 2496;
2508 -> 2494;
2509 -> 2494;
2510 -> 2509;
2510 -> 2498;
2510 -> 2494;
2511 -> 2494;
2512 -> 2511;
2512 -> 2496;
2512 -> 2494;
2513 -> 2504;
2513 -> 2494;
2514 -> 2486;
2514 -> 2484;
2515 -> 2488;
2515 -> 2484;
2516 -> 2484;
2517 -> 2514;
2517 -> 2516;
2517 -> 2484;
2518 -> 2484;
2519 -> 2514;
2519 -> 2518;
2519 -> 2484;
2520 -> 2484;
2521 -> 2515;
2521 -> 2520;
2521 -> 2484;
2522 -> 2484;
2523 -> 2522;
2523 -> 2475;
2524 -> 2475;
2525 -> 2524;
2525 -> 2444;
2526 -> 2471;
2526 -> 2525;
2526 -> 2444;
2527 -> 2408;
2527 -> 2526;
2527 -> 2433;
2527 -> 2376;
2528 -> 2426;
2528 -> 2376;
2529 -> 2413;
2529 -> 2376;
2530 -> 2408;
2530 -> 2527;
2530 -> 2376;
2531 -> 2530;
2531 -> 2355;
2532 -> 2344;
2533 -> 597;
2533 -> 596;
2534 -> 592;
2534 -> 1;
2535 -> 1;
2536 -> 1;
2537 -> 2534;
2537 -> 2536;
2538 -> 2535;
2538 -> 2536;
2539 -> 2535;
2539 -> 2536;
2540 -> 2535;
2540 -> 2536;
2541 -> 2537;
2541 -> 2536;
2542 -> 2538;
2542 -> 2536;
2543 -> 2539;
2543 -> 2536;
2544 -> 2541;
2544 -> 2542;
2544 -> 2543;
2544 -> 2429;
2544 -> 2535;
2544 -> 2536;
2545 -> 2536;
2546 -> 2536;
2547 -> 2546;
2547 -> 2544;
2547 -> 2536;
2548 -> 2546;
2548 -> 2536;
2549 -> 2537;
2549 -> 2546;
2549 -> 2536;
2550 -> 592;
2550 -> 1;
2551 -> 1;
2552 -> 1;
2553 -> 2550;
2553 -> 2552;
2554 -> 2551;
2554 -> 2552;
2555 -> 2551;
2555 -> 2552;
2556 -> 2551;
2556 -> 2552;
2557 -> 2551;
2557 -> 2552;
2558 -> 2553;
2558 -> 2552;
2559 -> 2554;
2559 -> 2552;
2560 -> 2555;
2560 -> 2552;
2561 -> 2556;
2561 -> 2552;
2562 -> 2557;
2562 -> 2552;
2563 -> 2552;
2564 -> 2558;
2564 -> 2563;
2565 -> 2559;
2565 -> 2563;
2566 -> 2560;
2566 -> 2563;
2567 -> 2561;
2567 -> 2563;
2568 -> 2562;
2568 -> 2563;
2569 -> 2564;
2569 -> 2563;
2570 -> 2565;
2570 -> 2563;
2571 -> 2568;
2571 -> 2563;
2572 -> 2563;
2573 -> 2563;
2574 -> 2569;
2574 -> 2573;
2575 -> 2570;
2575 -> 2573;
2576 -> 2572;
2576 -> 2573;
2577 -> 2571;
2577 -> 2573;
2578 -> 2572;
2578 -> 2573;
2579 -> 2572;
2579 -> 2573;
2580 -> 2572;
2580 -> 2573;
2581 -> 2572;
2581 -> 2573;
2582 -> 2572;
2582 -> 2573;
2583 -> 2572;
2583 -> 2573;
2584 -> 2573;
2585 -> 2573;
2586 -> 2578;
2586 -> 2585;
2586 -> 2573;
2587 -> 2574;
2587 -> 2547;
2587 -> 2548;
2587 -> 2549;
2587 -> 2573;
2588 -> 2573;
2589 -> 2587;
2589 -> 2588;
2590 -> 2586;
2590 -> 2589;
2590 -> 2573;
2591 -> 2584;
2591 -> 2573;
2592 -> 2583;
2592 -> 2573;
2593 -> 2578;
2593 -> 2573;
2594 -> 2573;
2595 -> 2582;
2595 -> 2573;
2596 -> 2575;
2596 -> 2573;
2597 -> 2579;
2597 -> 2573;
2598 -> 2580;
2598 -> 2573;
2599 -> 2581;
2599 -> 2573;
2600 -> 2576;
2600 -> 2573;
2601 -> 2591;
2601 -> 2592;
2601 -> 2593;
2601 -> 2594;
2601 -> 2595;
2601 -> 2596;
2601 -> 2597;
2601 -> 2598;
2601 -> 2599;
2601 -> 2600;
2601 -> 2574;
2601 -> 2584;
2601 -> 2589;
2601 -> 2573;
2602 -> 2601;
2602 -> 2594;
2603 -> 2601;
2603 -> 2594;
2604 -> 2601;
2604 -> 2594;
2605 -> 2601;
2605 -> 2594;
2606 -> 2601;
2606 -> 2594;
2607 -> 2601;
2607 -> 2594;
2608 -> 2594;
2609 -> 2605;
2609 -> 2608;
2610 -> 2608;
2611 -> 2610;
2612 -> 2611;
2613 -> 2612;
2614 -> 2601;
2614 -> 2612;
2615 -> 2601;
2615 -> 2610;
2616 -> 2615;
2616 -> 2610;
2617 -> 2608;
2618 -> 2608;
2619 -> 2618;
2619 -> 2608;
2620 -> 0;
2620 -> 2608;
2621 -> 2609;
2621 -> 2608;
2622 -> 2618;
2622 -> 2608;
2623 -> 0;
2623 -> 2608;
2624 -> 2621;
2624 -> 2622;
2624 -> 2623;
2624 -> 2601;
2624 -> 0;
2624 -> 2619;
2624 -> 2608;
2625 -> 2608;
2627 -> 2626;
2628 -> 2624;
2628 -> 2625;
2629 -> 2624;
2629 -> 2625;
2630 -> 2624;
2630 -> 2625;
2631 -> 2624;
2631 -> 2625;
2632 -> 2624;
2632 -> 2625;
2633 -> 2624;
2633 -> 2625;
2634 -> 2624;
2634 -> 2625;
2635 -> 2625;
2636 -> 2628;
2636 -> 2635;
2636 -> 2625;
2637 -> 2628;
2637 -> 2624;
2637 -> 2636;
2638 -> 2628;
2638 -> 2637;
2638 -> 0;
2639 -> 2625;
2640 -> 2625;
2641 -> 2627;
2641 -> 2625;
2642 -> 2628;
2642 -> 2637;
2642 -> 2625;
2643 -> 2625;
2644 -> 2641;
2644 -> 2642;
2644 -> 2643;
2644 -> 2626;
2644 -> 2625;
2645 -> 2628;
2645 -> 2637;
2645 -> 2644;
2646 -> 2629;
2646 -> 2644;
2647 -> 2630;
2647 -> 2644;
2648 -> 2631;
2648 -> 2644;
2649 -> 2632;
2649 -> 2644;
2650 -> 2633;
2650 -> 2644;
2651 -> 2634;
2651 -> 2644;
2652 -> 2640;
2652 -> 2644;
2653 -> 2644;
2654 -> 2645;
2654 -> 2653;
2655 -> 2645;
2655 -> 2653;
2656 -> 2645;
2656 -> 2653;
2657 -> 2645;
2657 -> 2653;
2658 -> 2645;
2658 -> 2653;
2659 -> 2645;
2659 -> 2653;
2660 -> 2646;
2660 -> 2653;
2661 -> 2647;
2661 -> 2653;
2662 -> 2648;
2662 -> 2653;
2663 -> 2649;
2663 -> 2653;
2664 -> 2650;
2664 -> 2653;
2665 -> 2651;
2665 -> 2653;
2666 -> 2652;
2666 -> 2653;
2667 -> 2653;
2668 -> 2658;
2668 -> 2637;
2668 -> 2653;
2669 -> 2658;
2669 -> 2637;
2669 -> 2653;
2670 -> 2658;
2670 -> 2637;
2670 -> 2653;
2671 -> 2656;
2671 -> 2653;
2672 -> 2671;
2672 -> 2653;
2673 -> 2657;
2673 -> 2660;
2673 -> 2653;
2674 -> 2653;
2675 -> 2653;
2676 -> 2653;
2677 -> 2656;
2677 -> 2653;
2678 -> 2674;
2678 -> 2653;
2679 -> 2663;
2679 -> 2677;
2679 -> 2678;
2679 -> 2637;
2679 -> 2653;
2680 -> 2653;
2681 -> 2664;
2681 -> 2680;
2681 -> 2653;
2682 -> 2675;
2682 -> 2653;
2683 -> 2655;
2683 -> 2682;
2684 -> 0;
2684 -> 2683;
2685 -> 2684;
2685 -> 0;
2685 -> 2653;
2686 -> 2669;
2686 -> 2653;
2687 -> 0;
2687 -> 2653;
2688 -> 2686;
2688 -> 0;
2688 -> 2653;
2689 -> 2686;
2689 -> 0;
2689 -> 2653;
2690 -> 2684;
2690 -> 0;
2690 -> 2689;
2691 -> 2684;
2691 -> 2653;
2692 -> 2662;
2692 -> 2691;
2693 -> 2684;
2693 -> 2653;
2694 -> 2667;
2694 -> 2625;
2695 -> 2693;
2695 -> 2625;
2696 -> 2628;
2696 -> 2695;
2696 -> 2679;
2696 -> 2625;
2697 -> 0;
2697 -> 2608;
2698 -> 2697;
2698 -> 2594;
2699 -> 2594;
2700 -> 2698;
2700 -> 2699;
2700 -> 2594;
2701 -> 2698;
2701 -> 2594;
2702 -> 2594;
2703 -> 2601;
2703 -> 2701;
2703 -> 2702;
2703 -> 2696;
2703 -> 2594;
2704 -> 2702;
2705 -> 2704;
2706 -> 2703;
2706 -> 2704;
2707 -> 2702;
2708 -> 2702;
2709 -> 2708;
2710 -> 2703;
2710 -> 2708;
2711 -> 2703;
2711 -> 2702;
2712 -> 2702;
2713 -> 2594;
2714 -> 2594;
2715 -> 2703;
2716 -> 2703;
2717 -> 2703;
2718 -> 2703;
2719 -> 2594;
2720 -> 2602;
2720 -> 2719;
2720 -> 2594;
2721 -> 2594;
2722 -> 2603;
2722 -> 2721;
2722 -> 2594;
2723 -> 2594;
2724 -> 2604;
2724 -> 2723;
2724 -> 2594;
2725 -> 2594;
2726 -> 2601;
2726 -> 2594;
2727 -> 0;
2727 -> 2594;
2728 -> 2594;
2729 -> 2594;
2730 -> 2727;
2730 -> 2729;
2731 -> 2728;
2731 -> 2729;
2732 -> 2729;
2733 -> 2730;
2733 -> 2729;
2734 -> 2731;
2734 -> 2729;
2735 -> 2732;
2735 -> 2729;
2736 -> 2729;
2737 -> 2733;
2737 -> 2736;
2738 -> 2734;
2738 -> 2736;
2739 -> 2735;
2739 -> 2736;
2740 -> 2736;
2741 -> 2737;
2741 -> 0;
2741 -> 2736;
2742 -> 2741;
2742 -> 2738;
2742 -> 2736;
2743 -> 2742;
2744 -> 2743;
2745 -> 2744;
2746 -> 2742;
2747 -> 2703;
2748 -> 2703;
2749 -> 2742;
2750 -> 2703;
2751 -> 2737;
2751 -> 0;
2751 -> 2736;
2752 -> 2740;
2752 -> 2751;
2753 -> 2751;
2754 -> 2751;
2755 -> 2751;
2756 -> 2601;
2756 -> 2755;
2757 -> 2756;
2757 -> 2703;
2757 -> 2755;
2758 -> 2757;
2758 -> 2751;
2759 -> 2751;
2760 -> 2751;
2761 -> 2751;
2762 -> 2760;
2762 -> 2761;
2763 -> 2760;
2763 -> 2761;
2764 -> 2760;
2764 -> 2761;
2765 -> 2761;
2766 -> 2761;
2767 -> 2761;
2768 -> 2762;
2768 -> 2767;
2768 -> 2761;
2769 -> 2761;
2770 -> 2769;
2771 -> 2770;
2772 -> 2703;
2772 -> 2770;
2773 -> 2766;
2773 -> 2761;
2774 -> 2762;
2774 -> 2761;
2775 -> 2774;
2776 -> 2774;
2777 -> 2761;
2778 -> 2764;
2778 -> 2777;
2778 -> 2761;
2779 -> 2762;
2779 -> 2761;
2780 -> 2763;
2780 -> 2761;
2781 -> 2761;
2782 -> 2779;
2782 -> 2781;
2783 -> 2780;
2783 -> 2781;
2784 -> 2781;
2785 -> 2782;
2785 -> 2784;
2785 -> 2781;
2786 -> 2601;
2786 -> 2703;
2786 -> 2781;
2787 -> 2751;
2788 -> 2601;
2788 -> 2703;
2788 -> 2787;
2788 -> 2751;
2789 -> 2737;
2789 -> 0;
2789 -> 2736;
2790 -> 2739;
2790 -> 2736;
2791 -> 2740;
2791 -> 2736;
2792 -> 2736;
2793 -> 2729;
2794 -> 2725;
2794 -> 2594;
2795 -> 2725;
2795 -> 2594;
2796 -> 2601;
2797 -> 2601;
2798 -> 2601;
2799 -> 2798;
2799 -> 2703;
2800 -> 2799;
2800 -> 2601;
2801 -> 2601;
2802 -> 2601;
2803 -> 2601;
2804 -> 2703;
2804 -> 2601;
2805 -> 2601;
2806 -> 2805;
2806 -> 2601;
2807 -> 2703;
2807 -> 2601;
2808 -> 2601;
2809 -> 2601;
2810 -> 2703;
2810 -> 2601;
2811 -> 2601;
2812 -> 2810;
2812 -> 2811;
2813 -> 2601;
2813 -> 2811;
2814 -> 2812;
2814 -> 2811;
2815 -> 2601;
2816 -> 2703;
2816 -> 2601;
2817 -> 2703;
2818 -> 2703;
2819 -> 2703;
2820 -> 2817;
2820 -> 2703;
2821 -> 2703;
2822 -> 2819;
2822 -> 2821;
2823 -> 2820;
2823 -> 2821;
2824 -> 2821;
2825 -> 2822;
2825 -> 2824;
2825 -> 2821;
2826 -> 2703;
2827 -> 2817;
2827 -> 2703;
2828 -> 2601;
2829 -> 2817;
2829 -> 2828;
2829 -> 2601;
2830 -> 2601;
2831 -> 2601;
2832 -> 2601;
2833 -> 2831;
2833 -> 2832;
2834 -> 2832;
2834 -> 2817;
2835 -> 2834;
2835 -> 2601;
2836 -> 2835;
2836 -> 2601;
2837 -> 2601;
2838 -> 2601;
2839 -> 2836;
2839 -> 2838;
2840 -> 2837;
2840 -> 2838;
2841 -> 2601;
2841 -> 2838;
2842 -> 2839;
2842 -> 2838;
2843 -> 2601;
2844 -> 2843;
2844 -> 2601;
2845 -> 2844;
2845 -> 2601;
2846 -> 2845;
2846 -> 2601;
2847 -> 2817;
2847 -> 2601;
2848 -> 2847;
2848 -> 2601;
2849 -> 2817;
2849 -> 2601;
2850 -> 2849;
2851 -> 2848;
2851 -> 2850;
2851 -> 2849;
2852 -> 2851;
2853 -> 2601;
2854 -> 2817;
2854 -> 2601;
2855 -> 2854;
2855 -> 2601;
2856 -> 2601;
2857 -> 2601;
2858 -> 2855;
2858 -> 2857;
2859 -> 2856;
2859 -> 2857;
2860 -> 2601;
2860 -> 2857;
2861 -> 2858;
2861 -> 2857;
2862 -> 2817;
2862 -> 2601;
2863 -> 2601;
2864 -> 2601;
2864 -> 2817;
2865 -> 2601;
2866 -> 2864;
2866 -> 2865;
2866 -> 2601;
2867 -> 2601;
2868 -> 2601;
2868 -> 2817;
2869 -> 2817;
2869 -> 2601;
2870 -> 2601;
2871 -> 2703;
2871 -> 2870;
2871 -> 2601;
2872 -> 2601;
2872 -> 2817;
2873 -> 2817;
2874 -> 2872;
2874 -> 2873;
2875 -> 2872;
2875 -> 2873;
2876 -> 2601;
2876 -> 2873;
2877 -> 2876;
2877 -> 2817;
2877 -> 2873;
2878 -> 2876;
2878 -> 2817;
2878 -> 2873;
2879 -> 2817;
2880 -> 2703;
2880 -> 2817;
2880 -> 2601;
2881 -> 2594;
2882 -> 2601;
2882 -> 2594;
2883 -> 2594;
2884 -> 2883;
2884 -> 2594;
2885 -> 2594;
2886 -> 2885;
2887 -> 2817;
2887 -> 2885;
2888 -> 2594;
2889 -> 2883;
2889 -> 2594;
2890 -> 2594;
2891 -> 2889;
2891 -> 2890;
2892 -> 2890;
2893 -> 2892;
2894 -> 2817;
2894 -> 2892;
2895 -> 2817;
2895 -> 2890;
2896 -> 2890;
2897 -> 2896;
2897 -> 2895;
2897 -> 2817;
2897 -> 2890;
2898 -> 2890;
2899 -> 2898;
2899 -> 2594;
2900 -> 2883;
2900 -> 2594;
2901 -> 2594;
2902 -> 2594;
2903 -> 2594;
2904 -> 2902;
2904 -> 2594;
2905 -> 2594;
2906 -> 2594;
2907 -> 2882;
2907 -> 2906;
2908 -> 2904;
2908 -> 2906;
2909 -> 2905;
2909 -> 2906;
2910 -> 2905;
2910 -> 2906;
2911 -> 2906;
2912 -> 2906;
2913 -> 2907;
2913 -> 2912;
2913 -> 2906;
2914 -> 2906;
2915 -> 2914;
2916 -> 2817;
2916 -> 2914;
2917 -> 2911;
2917 -> 2906;
2918 -> 2909;
2918 -> 2906;
2919 -> 2910;
2919 -> 2906;
2920 -> 2906;
2921 -> 2908;
2921 -> 2906;
2922 -> 2906;
2923 -> 2917;
2923 -> 2922;
2924 -> 2918;
2924 -> 2922;
2925 -> 2919;
2925 -> 2922;
2926 -> 2920;
2926 -> 2922;
2927 -> 2920;
2927 -> 2922;
2928 -> 2921;
2928 -> 2922;
2929 -> 2920;
2929 -> 2922;
2930 -> 2922;
2931 -> 2930;
2931 -> 2922;
2932 -> 2930;
2932 -> 2922;
2933 -> 2930;
2933 -> 2922;
2934 -> 2930;
2934 -> 2922;
2935 -> 2930;
2935 -> 2922;
2936 -> 2930;
2936 -> 2922;
2937 -> 2930;
2937 -> 2922;
2938 -> 2930;
2938 -> 2922;
2939 -> 2930;
2939 -> 2922;
2940 -> 2930;
2940 -> 2922;
2941 -> 2930;
2941 -> 2922;
2942 -> 2930;
2942 -> 2922;
2943 -> 2923;
2943 -> 2930;
2943 -> 2922;
2944 -> 2924;
2944 -> 2930;
2944 -> 2922;
2945 -> 2925;
2945 -> 2930;
2945 -> 2922;
2946 -> 2926;
2946 -> 2930;
2946 -> 2922;
2947 -> 2927;
2947 -> 2930;
2947 -> 2922;
2948 -> 2928;
2948 -> 2930;
2948 -> 2922;
2949 -> 2906;
2950 -> 2949;
2951 -> 2817;
2951 -> 2949;
2952 -> 2817;
2952 -> 2920;
2952 -> 2930;
2952 -> 2931;
2952 -> 2932;
2952 -> 2601;
2952 -> 2933;
2952 -> 2943;
2952 -> 2934;
2952 -> 2944;
2952 -> 2935;
2952 -> 2945;
2952 -> 2936;
2952 -> 2946;
2952 -> 2937;
2952 -> 2947;
2952 -> 2938;
2952 -> 2948;
2952 -> 2939;
2952 -> 2940;
2952 -> 2941;
2952 -> 2942;
2952 -> 2882;
2952 -> 2905;
2952 -> 2902;
2952 -> 2906;
2953 -> 2906;
2954 -> 2952;
2955 -> 2952;
2956 -> 2952;
2957 -> 2955;
2957 -> 2956;
2958 -> 2952;
2958 -> 2956;
2959 -> 2958;
2959 -> 2952;
2959 -> 2956;
2960 -> 2956;
2961 -> 2959;
2962 -> 2952;
2963 -> 2952;
2964 -> 2962;
2964 -> 2963;
2965 -> 2952;
2965 -> 2963;
2966 -> 2965;
2966 -> 2952;
2966 -> 2963;
2967 -> 2963;
2968 -> 2966;
2969 -> 2952;
2970 -> 2952;
2971 -> 2952;
2972 -> 2970;
2972 -> 2971;
2973 -> 2952;
2973 -> 2971;
2974 -> 2973;
2974 -> 2952;
2974 -> 2971;
2975 -> 2971;
2976 -> 2974;
2977 -> 2952;
2978 -> 2952;
2979 -> 2952;
2979 -> 2978;
2980 -> 2952;
2981 -> 2978;
2981 -> 2980;
2982 -> 2978;
2982 -> 2980;
2983 -> 2952;
2983 -> 2980;
2984 -> 2981;
2984 -> 2980;
2985 -> 2982;
2985 -> 2980;
2986 -> 2984;
2986 -> 2985;
2986 -> 2980;
2987 -> 2980;
2988 -> 2986;
2988 -> 2987;
2989 -> 2983;
2989 -> 2987;
2990 -> 2989;
2990 -> 2952;
2990 -> 2987;
2991 -> 2987;
2992 -> 2990;
2993 -> 2980;
2994 -> 2952;
2995 -> 2952;
2996 -> 2952;
2997 -> 2952;
2998 -> 2996;
2998 -> 2997;
2999 -> 2952;
2999 -> 2997;
3000 -> 2999;
3000 -> 2952;
3000 -> 2997;
3001 -> 2997;
3002 -> 3000;
3003 -> 2952;
3004 -> 2952;
3005 -> 3003;
3005 -> 3004;
3006 -> 2952;
3006 -> 3004;
3007 -> 3006;
3007 -> 2952;
3007 -> 3004;
3008 -> 3004;
3009 -> 3007;
3010 -> 2952;
3011 -> 2952;
3011 -> 2953;
3012 -> 2952;
3013 -> 2952;
3014 -> 2952;
3015 -> 2952;
3016 -> 2952;
3017 -> 3016;
3017 -> 2952;
3018 -> 3015;
3018 -> 2952;
3019 -> 3016;
3019 -> 2952;
3020 -> 0;
3020 -> 2952;
3021 -> 2952;
3022 -> 2952;
3023 -> 2952;
3024 -> 3023;
3024 -> 3020;
3024 -> 2952;
3025 -> 3024;
3025 -> 2952;
3026 -> 2952;
3027 -> 2952;
3028 -> 3022;
3028 -> 3027;
3028 -> 2952;
3029 -> 0;
3029 -> 3028;
3030 -> 2952;
3031 -> 3029;
3031 -> 0;
3031 -> 2952;
3032 -> 3025;
3032 -> 0;
3032 -> 3031;
3033 -> 3031;
3034 -> 2952;
3035 -> 2952;
3036 -> 2952;
3037 -> 3035;
3037 -> 3036;
3038 -> 2952;
3038 -> 3036;
3039 -> 3038;
3039 -> 2952;
3039 -> 3036;
3040 -> 3036;
3041 -> 3039;
3042 -> 2952;
3043 -> 2952;
3044 -> 2952;
3045 -> 3043;
3045 -> 3044;
3046 -> 2952;
3046 -> 3044;
3047 -> 3046;
3047 -> 2952;
3047 -> 3044;
3048 -> 3044;
3049 -> 3047;
3050 -> 2906;
3051 -> 2920;
3051 -> 2952;
3051 -> 3050;
3051 -> 2906;
3052 -> 2911;
3052 -> 2906;
3053 -> 2906;
3054 -> 2909;
3054 -> 3053;
3054 -> 2906;
3055 -> 3054;
3056 -> 3055;
3057 -> 3056;
3058 -> 2952;
3059 -> 2952;
3060 -> 2952;
3061 -> 2902;
3061 -> 2594;
3062 -> 2594;
3063 -> 2601;
3063 -> 2594;
3064 -> 2601;
3064 -> 2594;
3065 -> 2601;
3065 -> 2594;
3066 -> 2601;
3066 -> 2594;
3067 -> 2594;
3068 -> 3066;
3068 -> 2952;
3068 -> 3067;
3068 -> 2594;
3069 -> 3063;
3069 -> 2594;
3070 -> 2594;
3071 -> 3069;
3071 -> 3070;
3072 -> 3066;
3072 -> 3070;
3073 -> 3070;
3074 -> 3072;
3074 -> 2952;
3074 -> 3073;
3074 -> 3070;
3075 -> 2594;
3076 -> 2594;
3077 -> 3076;
3078 -> 2952;
3078 -> 3076;
3079 -> 2594;
3080 -> 2594;
3081 -> 3080;
3082 -> 2952;
3082 -> 3080;
3083 -> 2601;
3083 -> 2594;
3084 -> 2601;
3084 -> 2594;
3085 -> 2594;
3086 -> 3084;
3086 -> 3085;
3087 -> 3086;
3087 -> 2952;
3087 -> 3085;
3088 -> 3087;
3088 -> 2594;
3089 -> 3088;
3089 -> 2952;
3089 -> 2594;
3090 -> 3088;
3090 -> 2594;
3091 -> 3084;
3091 -> 2952;
3091 -> 2594;
3092 -> 2594;
3093 -> 2601;
3093 -> 2594;
3094 -> 2601;
3094 -> 2952;
3094 -> 2594;
3095 -> 2594;
3096 -> 3095;
3096 -> 3094;
3096 -> 2952;
3096 -> 2594;
3097 -> 2594;
3098 -> 2952;
3099 -> 2952;
3100 -> 3099;
3100 -> 3098;
3100 -> 2952;
3101 -> 2952;
3102 -> 2952;
3102 -> 3101;
3103 -> 2601;
3103 -> 2594;
3104 -> 3103;
3104 -> 2952;
3104 -> 2594;
3105 -> 2594;
3106 -> 2594;
3107 -> 2601;
3107 -> 2594;
3108 -> 3107;
3108 -> 2952;
3108 -> 2594;
3109 -> 2594;
3110 -> 3108;
3110 -> 3109;
3111 -> 2594;
3112 -> 2601;
3112 -> 2594;
3113 -> 3112;
3113 -> 2952;
3113 -> 2594;
3114 -> 2594;
3115 -> 3113;
3115 -> 3114;
3116 -> 3114;
3117 -> 3115;
3117 -> 3114;
3118 -> 3114;
3119 -> 3117;
3119 -> 3118;
3120 -> 3118;
3121 -> 3120;
3122 -> 3120;
3123 -> 2952;
3123 -> 3120;
3124 -> 3123;
3124 -> 3118;
3125 -> 3118;
3126 -> 2952;
3126 -> 3118;
3127 -> 3126;
3128 -> 3124;
3128 -> 3127;
3128 -> 3126;
3129 -> 3128;
3130 -> 3114;
3131 -> 3116;
3131 -> 3114;
3132 -> 3116;
3132 -> 3114;
3133 -> 3116;
3133 -> 3114;
3134 -> 3116;
3134 -> 3114;
3135 -> 3116;
3135 -> 3114;
3136 -> 3116;
3136 -> 3114;
3137 -> 3116;
3137 -> 3114;
3138 -> 3116;
3138 -> 3114;
3139 -> 2594;
3140 -> 2601;
3140 -> 2594;
3141 -> 2594;
3142 -> 2594;
3143 -> 2601;
3143 -> 2594;
3144 -> 2601;
3144 -> 2594;
3145 -> 2594;
3146 -> 2594;
3147 -> 2594;
3148 -> 2594;
3149 -> 2601;
3149 -> 2952;
3149 -> 2594;
3150 -> 2594;
3151 -> 3150;
3152 -> 3151;
3153 -> 3152;
3154 -> 2952;
3154 -> 3152;
3155 -> 3150;
3156 -> 2952;
3156 -> 2594;
3157 -> 2594;
3158 -> 2601;
3158 -> 2594;
3159 -> 2601;
3159 -> 2952;
3159 -> 2594;
3160 -> 2952;
3161 -> 2952;
3161 -> 3160;
3162 -> 3160;
3163 -> 3162;
3163 -> 3161;
3163 -> 2952;
3163 -> 3160;
3164 -> 2952;
3165 -> 2952;
3166 -> 3165;
3166 -> 2952;
3167 -> 2952;
3168 -> 2952;
3169 -> 2952;
3170 -> 3168;
3170 -> 3169;
3171 -> 3168;
3171 -> 3169;
3172 -> 3167;
3172 -> 3169;
3173 -> 3169;
3174 -> 3171;
3174 -> 3173;
3174 -> 3169;
3175 -> 3167;
3175 -> 3168;
3176 -> 3168;
3177 -> 3168;
3177 -> 3176;
3178 -> 3168;
3178 -> 3176;
3179 -> 3175;
3179 -> 3176;
3180 -> 3176;
3181 -> 3178;
3181 -> 3180;
3181 -> 3176;
3182 -> 3168;
3182 -> 2952;
3183 -> 2952;
3184 -> 2601;
3184 -> 3168;
3184 -> 2952;
3184 -> 3183;
3185 -> 2601;
3185 -> 2594;
3186 -> 2601;
3186 -> 2594;
3187 -> 2601;
3187 -> 2594;
3188 -> 3187;
3188 -> 3168;
3188 -> 2594;
3189 -> 3188;
3189 -> 3168;
3189 -> 2594;
3190 -> 2594;
3191 -> 3190;
3191 -> 3189;
3191 -> 2594;
3192 -> 2601;
3192 -> 2594;
3193 -> 0;
3193 -> 2594;
3194 -> 2601;
3194 -> 3168;
3194 -> 2594;
3195 -> 2601;
3195 -> 3168;
3195 -> 2594;
3196 -> 3168;
3196 -> 3152;
3197 -> 3168;
3197 -> 2594;
3198 -> 3168;
3198 -> 3080;
3199 -> 3168;
3199 -> 2573;
3200 -> 2573;
3201 -> 2573;
3202 -> 2577;
3202 -> 3201;
3202 -> 2573;
3203 -> 2584;
3203 -> 2573;
3204 -> 3203;
3204 -> 3168;
3204 -> 2573;
3205 -> 2564;
3205 -> 3204;
3205 -> 2563;
3206 -> 2563;
3207 -> 3205;
3207 -> 3206;
3208 -> 3204;
3208 -> 3207;
3209 -> 2567;
3209 -> 3207;
3210 -> 2566;
3210 -> 3207;
3211 -> 3207;
3212 -> 3208;
3212 -> 3211;
3212 -> 3209;
3212 -> 3210;
3212 -> 2551;
3212 -> 3207;
3213 -> 1;
3214 -> 3213;
3214 -> 1;
3215 -> 1;
3216 -> 2535;
3216 -> 3215;
3216 -> 1;
3217 -> 0;
3217 -> 1;
3218 -> 0;
3218 -> 3217;
3218 -> 3212;
3218 -> 1;
3219 -> 3214;
3219 -> 3215;
3219 -> 3218;
3219 -> 3216;
3219 -> 1;
3220 -> 3215;
3221 -> 3220;
3222 -> 3219;
3222 -> 3215;
3223 -> 3219;
3223 -> 3215;
3224 -> 3222;
3224 -> 3215;
3225 -> 3215;
3226 -> 3225;
3226 -> 3215;
3227 -> 3215;
3228 -> 3224;
3228 -> 3227;
3229 -> 3226;
3229 -> 3227;
3230 -> 3227;
3231 -> 3219;
3232 -> 3219;
3233 -> 3231;
3233 -> 3219;
3234 -> 3219;
3235 -> 3232;
3235 -> 3219;
3235 -> 3233;
3235 -> 3234;
3235 -> 3231;
3236 -> 3219;
3237 -> 3236;
3237 -> 3231;
3237 -> 3219;
3238 -> 3231;
3238 -> 3219;
3239 -> 3219;
3240 -> 3238;
3240 -> 3239;
3240 -> 3231;
3240 -> 3237;
3240 -> 3219;
3241 -> 3227;
3242 -> 3219;
3242 -> 3241;
3242 -> 3227;
3243 -> 0;
3243 -> 3227;
3244 -> 3229;
3244 -> 3227;
3245 -> 3219;
3245 -> 3227;
3246 -> 3227;
3247 -> 3245;
3247 -> 3246;
3248 -> 0;
3248 -> 3246;
3249 -> 3248;
3250 -> 3227;
3251 -> 3227;
3252 -> 3251;
3253 -> 3219;
3253 -> 3252;
3253 -> 3227;
3254 -> 3251;
3255 -> 3251;
3256 -> 3254;
3256 -> 3255;
3257 -> 3254;
3257 -> 3255;
3258 -> 3254;
3258 -> 3255;
3259 -> 3254;
3259 -> 3255;
3260 -> 3255;
3261 -> 3219;
3261 -> 3260;
3261 -> 3255;
3262 -> 3259;
3262 -> 3255;
3263 -> 3256;
3263 -> 3255;
3264 -> 3257;
3264 -> 3255;
3265 -> 3258;
3265 -> 3255;
3266 -> 3259;
3266 -> 3255;
3267 -> 3255;
3268 -> 0;
3268 -> 3255;
3269 -> 3255;
3270 -> 3268;
3270 -> 3269;
3271 -> 3268;
3271 -> 3269;
3272 -> 3266;
3272 -> 3269;
3273 -> 3267;
3273 -> 3269;
3274 -> 3267;
3274 -> 3269;
3275 -> 3270;
3275 -> 3269;
3276 -> 3271;
3276 -> 3269;
3277 -> 3272;
3277 -> 3269;
3278 -> 3269;
3279 -> 3278;
3279 -> 3269;
3280 -> 3273;
3280 -> 3278;
3280 -> 3269;
3281 -> 3255;
3282 -> 3263;
3282 -> 3281;
3283 -> 3264;
3283 -> 3281;
3284 -> 3265;
3284 -> 3281;
3285 -> 3266;
3285 -> 3281;
3286 -> 3267;
3286 -> 3281;
3287 -> 3267;
3287 -> 3281;
3288 -> 3267;
3288 -> 3281;
3289 -> 3267;
3289 -> 3281;
3290 -> 3267;
3290 -> 3281;
3291 -> 3267;
3291 -> 3281;
3292 -> 3282;
3292 -> 3281;
3293 -> 3283;
3293 -> 3281;
3294 -> 3284;
3294 -> 3281;
3295 -> 3285;
3295 -> 3281;
3296 -> 3286;
3296 -> 3281;
3297 -> 3287;
3297 -> 3281;
3298 -> 3288;
3298 -> 3281;
3299 -> 3289;
3299 -> 3281;
3300 -> 3290;
3300 -> 3281;
3301 -> 3281;
3302 -> 3292;
3302 -> 3301;
3303 -> 3293;
3303 -> 3301;
3304 -> 3294;
3304 -> 3301;
3305 -> 3295;
3305 -> 3301;
3306 -> 3296;
3306 -> 3301;
3307 -> 3297;
3307 -> 3301;
3308 -> 3298;
3308 -> 3301;
3309 -> 3299;
3309 -> 3301;
3310 -> 3300;
3310 -> 3301;
3311 -> 3291;
3311 -> 3301;
3312 -> 3305;
3312 -> 3301;
3313 -> 3309;
3313 -> 3301;
3314 -> 3310;
3314 -> 3301;
3315 -> 3301;
3316 -> 3315;
3316 -> 3301;
3317 -> 3315;
3317 -> 3301;
3318 -> 3315;
3318 -> 3301;
3319 -> 3315;
3319 -> 3301;
3320 -> 3315;
3320 -> 3301;
3321 -> 3315;
3321 -> 3301;
3322 -> 3315;
3322 -> 3301;
3323 -> 3315;
3323 -> 3301;
3324 -> 3315;
3324 -> 3301;
3325 -> 3315;
3325 -> 3301;
3326 -> 3315;
3326 -> 3301;
3327 -> 3315;
3327 -> 3301;
3328 -> 3315;
3328 -> 3301;
3329 -> 3315;
3329 -> 3301;
3330 -> 3315;
3330 -> 3301;
3331 -> 3315;
3331 -> 3301;
3332 -> 3315;
3332 -> 3301;
3333 -> 3315;
3333 -> 3301;
3334 -> 3315;
3334 -> 3301;
3335 -> 3315;
3335 -> 3301;
3336 -> 3315;
3336 -> 3301;
3337 -> 3315;
3337 -> 3301;
3338 -> 3315;
3338 -> 3301;
3339 -> 3315;
3339 -> 3301;
3340 -> 3315;
3340 -> 3301;
3341 -> 3315;
3341 -> 3301;
3342 -> 3301;
3343 -> 3342;
3343 -> 3315;
3343 -> 3301;
3344 -> 3315;
3344 -> 3301;
3345 -> 3315;
3345 -> 3301;
3346 -> 3301;
3347 -> 3301;
3348 -> 3345;
3348 -> 3347;
3349 -> 3346;
3349 -> 3347;
3350 -> 3349;
3350 -> 3347;
3351 -> 3349;
3351 -> 3347;
3352 -> 3349;
3352 -> 3347;
3353 -> 3348;
3353 -> 3349;
3353 -> 3347;
3354 -> 3346;
3354 -> 3315;
3354 -> 3301;
3355 -> 3315;
3355 -> 3301;
3356 -> 3301;
3357 -> 3356;
3358 -> 0;
3358 -> 3356;
3359 -> 3358;
3359 -> 3357;
3359 -> 3356;
3360 -> 3359;
3360 -> 3301;
3361 -> 3360;
3361 -> 3315;
3361 -> 3301;
3362 -> 3305;
3362 -> 3301;
3363 -> 3362;
3364 -> 3302;
3364 -> 3363;
3364 -> 3362;
3365 -> 3303;
3365 -> 3363;
3365 -> 3362;
3366 -> 3364;
3366 -> 3365;
3366 -> 3362;
3367 -> 3304;
3367 -> 3363;
3367 -> 3362;
3368 -> 3366;
3368 -> 3367;
3368 -> 3362;
3369 -> 3307;
3369 -> 3301;
3370 -> 3369;
3371 -> 3315;
3371 -> 3370;
3372 -> 3306;
3372 -> 3369;
3373 -> 3308;
3373 -> 3315;
3373 -> 3301;
3374 -> 3315;
3374 -> 3253;
3374 -> 3301;
3375 -> 3301;
3376 -> 3315;
3376 -> 3253;
3376 -> 3375;
3376 -> 3301;
3377 -> 3255;
3378 -> 3219;
3379 -> 3219;
3380 -> 3253;
3381 -> 3253;
3382 -> 3219;
3382 -> 3253;
3383 -> 3379;
3383 -> 3253;
3384 -> 3219;
3384 -> 3253;
3385 -> 3253;
3385 -> 3219;
3386 -> 3253;
3386 -> 3219;
3387 -> 3253;
3387 -> 3219;
3388 -> 3253;
3388 -> 3219;
3389 -> 3219;
3390 -> 3389;
3390 -> 3253;
3391 -> 3390;
3391 -> 3219;
3392 -> 3253;
3392 -> 3219;
3393 -> 3253;
3393 -> 3219;
3394 -> 3391;
3394 -> 3219;
3395 -> 3392;
3395 -> 3219;
3396 -> 3393;
3396 -> 3219;
3397 -> 3394;
3397 -> 3219;
3398 -> 3395;
3398 -> 3219;
3399 -> 3396;
3399 -> 3219;
3400 -> 3219;
3401 -> 3253;
3401 -> 3219;
3402 -> 3401;
3403 -> 3397;
3403 -> 3402;
3403 -> 3401;
3404 -> 3398;
3404 -> 3402;
3404 -> 3401;
3405 -> 3403;
3405 -> 3404;
3405 -> 3401;
3406 -> 3399;
3406 -> 3402;
3406 -> 3401;
3407 -> 3405;
3407 -> 3406;
3407 -> 3401;
3408 -> 3253;
3409 -> 3219;
3409 -> 3253;
3410 -> 3219;
3411 -> 3219;
3411 -> 3253;
3411 -> 3410;
3412 -> 3219;
3412 -> 3253;
3412 -> 3255;
3413 -> 3227;
3414 -> 3413;
3415 -> 3414;
3416 -> 3415;
3417 -> 3253;
3418 -> 3253;
3419 -> 3417;
3419 -> 3253;
3420 -> 3418;
3420 -> 3253;
3421 -> 3417;
3421 -> 3253;
3422 -> 3417;
3422 -> 3253;
3423 -> 3253;
3424 -> 3423;
3424 -> 0;
3424 -> 3253;
3425 -> 3417;
3425 -> 3253;
3426 -> 3417;
3426 -> 3253;
3427 -> 3417;
3427 -> 3253;
3428 -> 3417;
3428 -> 3253;
3429 -> 3417;
3429 -> 3253;
3430 -> 3417;
3430 -> 3413;
3431 -> 3413;
3432 -> 0;
3432 -> 3413;
3433 -> 3228;
3433 -> 3417;
3433 -> 3227;
3434 -> 3417;
3434 -> 1;
3435 -> 11;
3435 -> 1;
3436 -> 1;
3437 -> 1;
3438 -> 3434;
3438 -> 3437;
3439 -> 3435;
3439 -> 3437;
3440 -> 3436;
3440 -> 3437;
3441 -> 3439;
3441 -> 3437;
3442 -> 3437;
3443 -> 3437;
3444 -> 3441;
3444 -> 3443;
3445 -> 3442;
3445 -> 3443;
3446 -> 3443;
3447 -> 0;
3447 -> 3446;
3448 -> 3447;
3448 -> 3443;
3449 -> 3443;
3450 -> 3448;
3450 -> 3443;
3451 -> 3444;
3451 -> 3443;
3452 -> 3445;
3452 -> 3443;
3453 -> 3438;
3453 -> 3449;
3454 -> 3438;
3454 -> 3449;
3455 -> 3438;
3455 -> 3449;
3456 -> 3438;
3456 -> 3449;
3457 -> 3438;
3457 -> 3449;
3458 -> 3449;
3459 -> 3458;
3460 -> 3459;
3461 -> 3460;
3462 -> 3461;
3463 -> 3438;
3464 -> 3463;
3464 -> 3438;
3465 -> 3438;
3466 -> 3438;
3467 -> 3465;
3467 -> 3466;
3468 -> 3467;
3468 -> 3464;
3468 -> 3466;
3469 -> 3467;
3469 -> 3464;
3469 -> 3466;
3470 -> 3469;
3470 -> 3466;
3471 -> 3467;
3471 -> 3464;
3471 -> 3466;
3472 -> 3471;
3472 -> 3438;
3473 -> 3472;
3473 -> 3466;
3474 -> 3438;
3475 -> 3438;
3476 -> 3474;
3476 -> 3475;
3477 -> 3476;
3477 -> 3472;
3477 -> 3475;
3478 -> 3476;
3478 -> 3472;
3478 -> 3475;
3479 -> 3478;
3479 -> 3475;
3480 -> 3476;
3480 -> 3472;
3480 -> 3475;
3481 -> 3480;
3481 -> 3438;
3482 -> 3438;
3483 -> 3438;
3484 -> 3482;
3484 -> 3483;
3485 -> 3484;
3485 -> 3481;
3485 -> 3483;
3486 -> 3484;
3486 -> 3481;
3486 -> 3483;
3487 -> 3486;
3487 -> 3483;
3488 -> 3484;
3488 -> 3481;
3488 -> 3483;
3489 -> 3488;
3489 -> 3438;
3490 -> 3489;
3490 -> 3475;
3491 -> 3489;
3491 -> 3466;
3492 -> 3489;
3492 -> 3438;
3493 -> 3438;
3493 -> 3489;
3494 -> 3489;
3494 -> 3461;
3495 -> 3489;
3495 -> 3459;
3496 -> 3495;
3496 -> 3459;
3497 -> 3458;
3498 -> 3449;
3499 -> 3489;
3499 -> 3498;
3499 -> 3449;
3500 -> 3449;
3501 -> 3500;
3502 -> 3501;
3503 -> 3489;
3503 -> 3501;
3504 -> 3500;
3505 -> 3504;
3506 -> 3505;
3507 -> 3506;
3508 -> 3504;
3509 -> 3508;
3510 -> 3509;
3511 -> 3500;
3512 -> 3511;
3513 -> 3489;
3513 -> 3511;
3514 -> 3500;
3515 -> 3489;
3515 -> 3500;
3516 -> 3500;
3517 -> 3449;
3518 -> 3449;
3519 -> 3489;
3520 -> 3489;
3521 -> 3489;
3522 -> 3489;
3523 -> 3449;
3524 -> 3453;
3524 -> 3523;
3524 -> 3449;
3525 -> 3449;
3526 -> 3454;
3526 -> 3525;
3526 -> 3449;
3527 -> 3449;
3528 -> 3455;
3528 -> 3527;
3528 -> 3449;
3529 -> 3449;
3530 -> 3438;
3530 -> 3449;
3531 -> 0;
3531 -> 3449;
3532 -> 3449;
3533 -> 3449;
3534 -> 3531;
3534 -> 3533;
3535 -> 3532;
3535 -> 3533;
3536 -> 3533;
3537 -> 3534;
3537 -> 3533;
3538 -> 3535;
3538 -> 3533;
3539 -> 3536;
3539 -> 3533;
3540 -> 3533;
3541 -> 3537;
3541 -> 3540;
3542 -> 3538;
3542 -> 3540;
3543 -> 3539;
3543 -> 3540;
3544 -> 3540;
3545 -> 3541;
3545 -> 0;
3545 -> 3540;
3546 -> 3545;
3546 -> 3542;
3546 -> 3540;
3547 -> 3546;
3548 -> 3547;
3549 -> 3548;
3550 -> 3546;
3551 -> 3489;
3552 -> 3489;
3553 -> 3546;
3554 -> 3489;
3555 -> 3541;
3555 -> 0;
3555 -> 3540;
3556 -> 3544;
3556 -> 3555;
3557 -> 3555;
3558 -> 3555;
3559 -> 3555;
3560 -> 3438;
3560 -> 3559;
3561 -> 3560;
3561 -> 3489;
3561 -> 3559;
3562 -> 3561;
3562 -> 3555;
3563 -> 3555;
3564 -> 3555;
3565 -> 3555;
3566 -> 3564;
3566 -> 3565;
3567 -> 3564;
3567 -> 3565;
3568 -> 3564;
3568 -> 3565;
3569 -> 3565;
3570 -> 3569;
3571 -> 3570;
3572 -> 3565;
3573 -> 3565;
3574 -> 3566;
3574 -> 3573;
3574 -> 3565;
3575 -> 3565;
3576 -> 3575;
3577 -> 3576;
3578 -> 3489;
3578 -> 3576;
3579 -> 3572;
3579 -> 3565;
3580 -> 3565;
3581 -> 3580;
3582 -> 3581;
3583 -> 3489;
3583 -> 3581;
3584 -> 3580;
3585 -> 3584;
3586 -> 3585;
3587 -> 3580;
3588 -> 3587;
3589 -> 3588;
3590 -> 3489;
3590 -> 3580;
3591 -> 3580;
3592 -> 3489;
3592 -> 3580;
3593 -> 3489;
3593 -> 3580;
3594 -> 3593;
3594 -> 3489;
3594 -> 3580;
3595 -> 3489;
3595 -> 3580;
3596 -> 3489;
3596 -> 3580;
3597 -> 3580;
3598 -> 3596;
3598 -> 3597;
3599 -> 3598;
3599 -> 3580;
3600 -> 3580;
3601 -> 3600;
3601 -> 3599;
3601 -> 3489;
3601 -> 3580;
3602 -> 3600;
3602 -> 3601;
3603 -> 3599;
3603 -> 3602;
3603 -> 3600;
3604 -> 3595;
3604 -> 3603;
3604 -> 3602;
3605 -> 3604;
3605 -> 3581;
3606 -> 3489;
3606 -> 3580;
3607 -> 3489;
3607 -> 3580;
3608 -> 3606;
3608 -> 3604;
3608 -> 3580;
3609 -> 3580;
3610 -> 3580;
3611 -> 3608;
3611 -> 3610;
3612 -> 3609;
3612 -> 3610;
3613 -> 3607;
3613 -> 3610;
3614 -> 3612;
3614 -> 3610;
3615 -> 3611;
3615 -> 3610;
3616 -> 3610;
3617 -> 3613;
3617 -> 3604;
3617 -> 3610;
3618 -> 3610;
3619 -> 3615;
3619 -> 3618;
3620 -> 3616;
3620 -> 3618;
3621 -> 3617;
3621 -> 3618;
3622 -> 3613;
3622 -> 3618;
3623 -> 3621;
3623 -> 3618;
3624 -> 3620;
3624 -> 3618;
3625 -> 3622;
3625 -> 3604;
3625 -> 3624;
3626 -> 3622;
3626 -> 3604;
3626 -> 3625;
3626 -> 3618;
3627 -> 3623;
3627 -> 3626;
3627 -> 3604;
3627 -> 3625;
3627 -> 3618;
3628 -> 3619;
3628 -> 3618;
3629 -> 3618;
3630 -> 3628;
3630 -> 3629;
3631 -> 3622;
3631 -> 3629;
3632 -> 3630;
3632 -> 3629;
3633 -> 3629;
3634 -> 3632;
3634 -> 3633;
3635 -> 3631;
3635 -> 3633;
3636 -> 3633;
3637 -> 3634;
3637 -> 3636;
3637 -> 3633;
3638 -> 3633;
3639 -> 3635;
3639 -> 3627;
3639 -> 3638;
3640 -> 3638;
3641 -> 3639;
3641 -> 3633;
3642 -> 3634;
3642 -> 3633;
3643 -> 3641;
3643 -> 3627;
3643 -> 3642;
3643 -> 3633;
3644 -> 3629;
3645 -> 3631;
3645 -> 3643;
3645 -> 3644;
3646 -> 3644;
3647 -> 3645;
3647 -> 3629;
3648 -> 3627;
3648 -> 3618;
3649 -> 3618;
3650 -> 3648;
3650 -> 3649;
3650 -> 3618;
3651 -> 3650;
3652 -> 3651;
3652 -> 3647;
3653 -> 3652;
3653 -> 3650;
3654 -> 3627;
3654 -> 3650;
3655 -> 3653;
3655 -> 3650;
3656 -> 3650;
3657 -> 3618;
3658 -> 3655;
3658 -> 3647;
3658 -> 3618;
3659 -> 3618;
3660 -> 3658;
3660 -> 3659;
3660 -> 3618;
3661 -> 3619;
3661 -> 3618;
3662 -> 3620;
3662 -> 3618;
3663 -> 3655;
3663 -> 3647;
3663 -> 3618;
3664 -> 3618;
3665 -> 3661;
3665 -> 3664;
3666 -> 3662;
3666 -> 3664;
3667 -> 3663;
3667 -> 3664;
3668 -> 3622;
3668 -> 3664;
3669 -> 3668;
3669 -> 3664;
3670 -> 3665;
3670 -> 3664;
3671 -> 3666;
3671 -> 3664;
3672 -> 3669;
3672 -> 3670;
3672 -> 3671;
3672 -> 3655;
3672 -> 3664;
3673 -> 3664;
3674 -> 3672;
3674 -> 3664;
3675 -> 3664;
3676 -> 3675;
3677 -> 3667;
3677 -> 3675;
3678 -> 3675;
3679 -> 3677;
3679 -> 3678;
3679 -> 3675;
3680 -> 3667;
3680 -> 3675;
3681 -> 3674;
3681 -> 3675;
3682 -> 3677;
3682 -> 3675;
3683 -> 3680;
3683 -> 3681;
3683 -> 3682;
3683 -> 3674;
3683 -> 3675;
3684 -> 3672;
3684 -> 3683;
3685 -> 3606;
3685 -> 3580;
3686 -> 3684;
3686 -> 3609;
3687 -> 3686;
3687 -> 3684;
3687 -> 3609;
3688 -> 3687;
3689 -> 3688;
3689 -> 3687;
3690 -> 3687;
3691 -> 3689;
3691 -> 3690;
3692 -> 3686;
3692 -> 3690;
3693 -> 3690;
3694 -> 3692;
3694 -> 3693;
3695 -> 3694;
3695 -> 3693;
3696 -> 3694;
3696 -> 3690;
3697 -> 3691;
3697 -> 3696;
3697 -> 3688;
3697 -> 3694;
3697 -> 3690;
3698 -> 3690;
3699 -> 3692;
3699 -> 3698;
3700 -> 3699;
3700 -> 3697;
3700 -> 3698;
3701 -> 3699;
3701 -> 3697;
3701 -> 3698;
3702 -> 3701;
3702 -> 3690;
3703 -> 3690;
3704 -> 3703;
3704 -> 3702;
3704 -> 3697;
3704 -> 3690;
3705 -> 3703;
3705 -> 3704;
3706 -> 3702;
3706 -> 3705;
3706 -> 3703;
3707 -> 3687;
3708 -> 3686;
3708 -> 3687;
3709 -> 3708;
3709 -> 3706;
3709 -> 3687;
3710 -> 3687;
3711 -> 3688;
3711 -> 3709;
3711 -> 3687;
3712 -> 3686;
3712 -> 3711;
3712 -> 3687;
3713 -> 3709;
3713 -> 3687;
3714 -> 3687;
3715 -> 3686;
3715 -> 3712;
3715 -> 3609;
3716 -> 3609;
3717 -> 3716;
3718 -> 3717;
3719 -> 3715;
3719 -> 3717;
3720 -> 3609;
3721 -> 3489;
3721 -> 3580;
3722 -> 3489;
3722 -> 3580;
3723 -> 3721;
3723 -> 3715;
3723 -> 3580;
3724 -> 3580;
3725 -> 3723;
3725 -> 3724;
3726 -> 3723;
3726 -> 3724;
3727 -> 3722;
3727 -> 3724;
3728 -> 3724;
3729 -> 3727;
3729 -> 3728;
3730 -> 3728;
3731 -> 3729;
3731 -> 3730;
3731 -> 3715;
3731 -> 3728;
3732 -> 3731;
3732 -> 3728;
3733 -> 3732;
3733 -> 3724;
3734 -> 3726;
3734 -> 3724;
3735 -> 3725;
3735 -> 3734;
3735 -> 3731;
3735 -> 3715;
3735 -> 3724;
3736 -> 3724;
3737 -> 3727;
3737 -> 3736;
3738 -> 3737;
3738 -> 3735;
3738 -> 3736;
3739 -> 3724;
3740 -> 3738;
3740 -> 3733;
3740 -> 3724;
3741 -> 3489;
3741 -> 3580;
3742 -> 3489;
3742 -> 3580;
3743 -> 3489;
3743 -> 3580;
3744 -> 3742;
3744 -> 3580;
3745 -> 3741;
3745 -> 3580;
3746 -> 3580;
3747 -> 3580;
3748 -> 3745;
3748 -> 3747;
3749 -> 3746;
3749 -> 3747;
3750 -> 3743;
3750 -> 3747;
3751 -> 3749;
3751 -> 3747;
3752 -> 3748;
3752 -> 3747;
3753 -> 3747;
3754 -> 3752;
3754 -> 3753;
3755 -> 3750;
3755 -> 3753;
3756 -> 3754;
3756 -> 3753;
3757 -> 3753;
3758 -> 3756;
3758 -> 3757;
3759 -> 3755;
3759 -> 3757;
3760 -> 3757;
3761 -> 3758;
3761 -> 3760;
3761 -> 3757;
3762 -> 3757;
3763 -> 3762;
3764 -> 3758;
3764 -> 3757;
3765 -> 3753;
3766 -> 3765;
3767 -> 3747;
3768 -> 3747;
3769 -> 3740;
3769 -> 3747;
3770 -> 3747;
3771 -> 3769;
3771 -> 3770;
3771 -> 3747;
3772 -> 3768;
3772 -> 3747;
3773 -> 3769;
3773 -> 3772;
3773 -> 3740;
3773 -> 3747;
3774 -> 3748;
3774 -> 3747;
3775 -> 3749;
3775 -> 3747;
3776 -> 3747;
3777 -> 3774;
3777 -> 3776;
3778 -> 3775;
3778 -> 3776;
3779 -> 3750;
3779 -> 3776;
3780 -> 3779;
3780 -> 3776;
3781 -> 3777;
3781 -> 3776;
3782 -> 3778;
3782 -> 3776;
3783 -> 3776;
3784 -> 3776;
3785 -> 3784;
3786 -> 3784;
3787 -> 3773;
3787 -> 3786;
3787 -> 3784;
3788 -> 3785;
3788 -> 3784;
3789 -> 3773;
3789 -> 3788;
3789 -> 3784;
3790 -> 3489;
3790 -> 3580;
3791 -> 3580;
3792 -> 3791;
3793 -> 3792;
3794 -> 3789;
3794 -> 3792;
3795 -> 3580;
3796 -> 3489;
3796 -> 3580;
3797 -> 3489;
3797 -> 3580;
3798 -> 3580;
3799 -> 3796;
3799 -> 3798;
3800 -> 3798;
3801 -> 3799;
3801 -> 3789;
3801 -> 3800;
3802 -> 3800;
3803 -> 3801;
3803 -> 3580;
3804 -> 3797;
3804 -> 3580;
3805 -> 3803;
3805 -> 3804;
3805 -> 3580;
3806 -> 3580;
3807 -> 3489;
3807 -> 3580;
3808 -> 3489;
3808 -> 3580;
3809 -> 3807;
3809 -> 0;
3809 -> 3580;
3810 -> 3580;
3811 -> 3807;
3811 -> 3580;
3812 -> 3808;
3812 -> 3811;
3812 -> 3805;
3812 -> 3580;
3813 -> 3812;
3814 -> 3813;
3815 -> 3813;
3815 -> 3812;
3816 -> 3807;
3816 -> 3812;
3817 -> 3815;
3817 -> 3807;
3817 -> 3580;
3818 -> 3815;
3818 -> 3580;
3819 -> 3818;
3819 -> 3792;
3820 -> 3489;
3820 -> 3818;
3820 -> 3580;
3821 -> 3580;
3822 -> 3821;
3823 -> 3822;
3824 -> 3823;
3825 -> 3818;
3825 -> 3823;
3826 -> 3821;
3827 -> 3818;
3827 -> 3580;
3828 -> 3580;
3829 -> 3593;
3829 -> 3818;
3829 -> 3580;
3830 -> 3489;
3830 -> 3818;
3830 -> 3580;
3831 -> 3566;
3831 -> 3565;
3832 -> 3831;
3833 -> 3831;
3834 -> 3565;
3835 -> 3568;
3835 -> 3834;
3835 -> 3565;
3836 -> 3566;
3836 -> 3565;
3837 -> 3567;
3837 -> 3565;
3838 -> 3565;
3839 -> 3836;
3839 -> 3838;
3840 -> 3837;
3840 -> 3838;
3841 -> 3838;
3842 -> 3839;
3842 -> 3841;
3842 -> 3838;
3843 -> 3818;
3844 -> 3818;
3845 -> 3818;
3846 -> 3818;
3846 -> 0;
3847 -> 3818;
3848 -> 3818;
3848 -> 0;
3849 -> 3818;
3849 -> 0;
3850 -> 3818;
3850 -> 0;
3851 -> 3818;
3851 -> 0;
3852 -> 3818;
3852 -> 0;
3853 -> 3818;
3853 -> 0;
3854 -> 3818;
3855 -> 3854;
3855 -> 3818;
3856 -> 3818;
3857 -> 3818;
3858 -> 3854;
3858 -> 0;
3858 -> 3818;
3859 -> 3854;
3859 -> 3818;
3860 -> 3818;
3861 -> 3859;
3861 -> 3860;
3862 -> 3861;
3862 -> 3860;
3863 -> 3862;
3864 -> 3854;
3865 -> 3864;
3865 -> 3854;
3866 -> 3818;
3866 -> 3854;
3867 -> 3854;
3868 -> 3854;
3869 -> 3868;
3869 -> 3854;
3870 -> 3867;
3870 -> 3869;
3871 -> 3854;
3872 -> 3870;
3872 -> 3871;
3872 -> 3854;
3873 -> 3872;
3873 -> 3864;
3873 -> 3854;
3874 -> 3864;
3874 -> 3854;
3875 -> 3863;
3875 -> 3874;
3876 -> 3863;
3876 -> 3818;
3877 -> 3854;
3877 -> 0;
3877 -> 3818;
3878 -> 3854;
3878 -> 0;
3879 -> 3854;
3879 -> 0;
3879 -> 3818;
3880 -> 3854;
3880 -> 0;
3880 -> 3818;
3881 -> 3854;
3881 -> 0;
3881 -> 3818;
3882 -> 3854;
3882 -> 0;
3882 -> 3818;
3883 -> 3854;
3883 -> 0;
3883 -> 3818;
3884 -> 3854;
3884 -> 0;
3885 -> 3854;
3886 -> 3854;
3886 -> 0;
3887 -> 3854;
3888 -> 3854;
3888 -> 0;
3889 -> 3854;
3889 -> 0;
3890 -> 3854;
3890 -> 0;
3891 -> 3854;
3891 -> 0;
3892 -> 3854;
3892 -> 0;
3893 -> 3854;
3894 -> 3854;
3895 -> 3893;
3895 -> 3894;
3896 -> 3895;
3896 -> 3894;
3897 -> 3896;
3898 -> 3818;
3899 -> 3897;
3899 -> 3898;
3900 -> 3854;
3901 -> 3854;
3902 -> 3900;
3902 -> 3901;
3903 -> 3854;
3903 -> 3901;
3904 -> 3902;
3904 -> 3854;
3904 -> 0;
3904 -> 3901;
3905 -> 3904;
3906 -> 3854;
3907 -> 3893;
3907 -> 3906;
3908 -> 3907;
3908 -> 3906;
3909 -> 3908;
3910 -> 3818;
3911 -> 3854;
3911 -> 3910;
3911 -> 3818;
3912 -> 3818;
3913 -> 3818;
3914 -> 3913;
3914 -> 3854;
3914 -> 3818;
3915 -> 3438;
3915 -> 3854;
3915 -> 3838;
3916 -> 3555;
3917 -> 3438;
3917 -> 3854;
3917 -> 3916;
3917 -> 3555;
3918 -> 3541;
3918 -> 0;
3918 -> 3540;
3919 -> 3543;
3919 -> 3540;
3920 -> 3544;
3920 -> 3540;
3921 -> 3540;
3922 -> 3533;
3923 -> 3529;
3923 -> 3449;
3924 -> 3529;
3924 -> 3449;
3925 -> 3854;
3925 -> 3438;
3926 -> 3854;
3926 -> 3438;
3927 -> 3854;
3927 -> 3438;
3928 -> 3854;
3928 -> 3438;
3929 -> 3438;
3930 -> 3438;
3931 -> 3438;
3932 -> 3931;
3932 -> 3854;
3933 -> 3932;
3933 -> 3438;
3934 -> 3438;
3935 -> 3438;
3936 -> 3438;
3937 -> 3854;
3937 -> 3438;
3938 -> 3438;
3939 -> 3938;
3939 -> 3438;
3940 -> 3854;
3941 -> 3854;
3942 -> 3854;
3942 -> 3438;
3943 -> 3438;
3944 -> 3438;
3945 -> 3854;
3945 -> 3438;
3946 -> 3438;
3947 -> 3945;
3947 -> 3946;
3948 -> 3438;
3948 -> 3946;
3949 -> 3947;
3949 -> 3946;
3950 -> 3438;
3951 -> 3854;
3951 -> 3466;
3952 -> 3854;
3953 -> 3854;
3954 -> 3854;
3955 -> 3953;
3955 -> 3954;
3956 -> 3953;
3956 -> 3954;
3957 -> 3954;
3958 -> 3955;
3958 -> 3957;
3958 -> 3954;
3959 -> 3854;
3960 -> 3854;
3961 -> 3438;
3962 -> 3854;
3962 -> 3961;
3962 -> 3438;
3963 -> 3438;
3964 -> 3438;
3965 -> 3438;
3966 -> 3964;
3966 -> 3965;
3967 -> 3965;
3967 -> 3854;
3968 -> 3967;
3968 -> 3438;
3969 -> 3968;
3969 -> 3438;
3970 -> 3438;
3971 -> 3438;
3972 -> 3969;
3972 -> 3971;
3973 -> 3970;
3973 -> 3971;
3974 -> 3438;
3974 -> 3971;
3975 -> 3972;
3975 -> 3971;
3976 -> 3438;
3977 -> 3976;
3977 -> 3438;
3978 -> 3977;
3978 -> 3438;
3979 -> 3978;
3979 -> 3438;
3980 -> 3854;
3980 -> 3438;
3981 -> 3980;
3981 -> 3438;
3982 -> 3854;
3982 -> 3438;
3983 -> 3982;
3984 -> 3981;
3984 -> 3983;
3984 -> 3982;
3985 -> 3984;
3986 -> 3438;
3987 -> 3854;
3987 -> 3438;
3988 -> 3987;
3988 -> 3438;
3989 -> 3438;
3990 -> 3438;
3991 -> 3988;
3991 -> 3990;
3992 -> 3989;
3992 -> 3990;
3993 -> 3438;
3993 -> 3990;
3994 -> 3991;
3994 -> 3990;
3995 -> 3854;
3995 -> 3438;
3996 -> 3854;
3996 -> 3438;
3997 -> 3438;
3998 -> 3438;
3998 -> 3854;
3999 -> 3438;
4000 -> 3998;
4000 -> 3999;
4000 -> 3438;
4001 -> 3438;
4002 -> 3438;
4002 -> 3854;
4003 -> 3438;
4004 -> 3854;
4004 -> 4003;
4004 -> 3438;
4005 -> 3438;
4005 -> 3854;
4006 -> 3854;
4007 -> 4005;
4007 -> 4006;
4008 -> 4005;
4008 -> 4006;
4009 -> 3438;
4009 -> 4006;
4010 -> 4009;
4010 -> 3854;
4010 -> 4006;
4011 -> 4009;
4011 -> 3854;
4011 -> 4006;
4012 -> 3854;
4013 -> 3854;
4013 -> 3438;
4014 -> 3449;
4015 -> 3449;
4016 -> 4015;
4016 -> 3449;
4017 -> 3449;
4018 -> 4017;
4019 -> 3854;
4019 -> 4017;
4020 -> 3449;
4021 -> 4015;
4021 -> 3449;
4022 -> 3449;
4023 -> 4021;
4023 -> 4022;
4024 -> 4022;
4025 -> 4024;
4026 -> 3854;
4026 -> 4024;
4027 -> 3854;
4027 -> 4022;
4028 -> 4022;
4029 -> 4028;
4029 -> 4027;
4029 -> 3854;
4029 -> 4022;
4030 -> 4022;
4031 -> 4030;
4031 -> 3449;
4032 -> 4015;
4032 -> 3449;
4033 -> 3449;
4034 -> 3449;
4035 -> 3449;
4036 -> 4034;
4036 -> 3449;
4037 -> 3449;
4038 -> 3449;
4039 -> 3438;
4039 -> 4038;
4040 -> 4036;
4040 -> 4038;
4041 -> 4037;
4041 -> 4038;
4042 -> 4037;
4042 -> 4038;
4043 -> 4038;
4044 -> 4038;
4045 -> 4039;
4045 -> 4044;
4045 -> 4038;
4046 -> 4038;
4047 -> 4046;
4048 -> 3854;
4048 -> 4046;
4049 -> 4043;
4049 -> 4038;
4050 -> 4041;
4050 -> 4038;
4051 -> 4042;
4051 -> 4038;
4052 -> 4038;
4053 -> 4040;
4053 -> 4038;
4054 -> 4038;
4055 -> 4049;
4055 -> 4054;
4056 -> 4050;
4056 -> 4054;
4057 -> 4051;
4057 -> 4054;
4058 -> 4052;
4058 -> 4054;
4059 -> 4052;
4059 -> 4054;
4060 -> 4053;
4060 -> 4054;
4061 -> 4052;
4061 -> 4054;
4062 -> 4054;
4063 -> 4062;
4063 -> 4054;
4064 -> 4062;
4064 -> 4054;
4065 -> 4062;
4065 -> 4054;
4066 -> 4062;
4066 -> 4054;
4067 -> 4062;
4067 -> 4054;
4068 -> 4062;
4068 -> 4054;
4069 -> 4062;
4069 -> 4054;
4070 -> 4062;
4070 -> 4054;
4071 -> 4062;
4071 -> 4054;
4072 -> 4062;
4072 -> 4054;
4073 -> 4062;
4073 -> 4054;
4074 -> 4062;
4074 -> 4054;
4075 -> 4055;
4075 -> 4062;
4075 -> 4054;
4076 -> 4056;
4076 -> 4062;
4076 -> 4054;
4077 -> 4057;
4077 -> 4062;
4077 -> 4054;
4078 -> 4058;
4078 -> 4062;
4078 -> 4054;
4079 -> 4059;
4079 -> 4062;
4079 -> 4054;
4080 -> 4060;
4080 -> 4062;
4080 -> 4054;
4081 -> 4038;
4082 -> 4081;
4083 -> 3854;
4083 -> 4081;
4084 -> 4038;
4085 -> 3854;
4086 -> 3854;
4087 -> 3854;
4088 -> 4086;
4088 -> 4087;
4089 -> 3854;
4089 -> 4087;
4090 -> 4089;
4090 -> 3854;
4090 -> 4087;
4091 -> 4087;
4092 -> 4090;
4093 -> 3854;
4094 -> 3854;
4095 -> 4093;
4095 -> 4094;
4096 -> 3854;
4096 -> 4094;
4097 -> 4096;
4097 -> 3854;
4097 -> 4094;
4098 -> 4094;
4099 -> 4097;
4100 -> 3854;
4101 -> 3854;
4102 -> 3854;
4103 -> 4101;
4103 -> 4102;
4104 -> 3854;
4104 -> 4102;
4105 -> 4104;
4105 -> 3854;
4105 -> 4102;
4106 -> 4102;
4107 -> 4105;
4108 -> 3854;
4109 -> 3854;
4110 -> 3854;
4110 -> 4109;
4111 -> 3854;
4112 -> 4109;
4112 -> 4111;
4113 -> 4109;
4113 -> 4111;
4114 -> 3854;
4114 -> 4111;
4115 -> 4112;
4115 -> 4111;
4116 -> 4113;
4116 -> 4111;
4117 -> 4115;
4117 -> 4116;
4117 -> 4111;
4118 -> 4111;
4119 -> 4117;
4119 -> 4118;
4120 -> 4114;
4120 -> 4118;
4121 -> 4120;
4121 -> 3854;
4121 -> 4118;
4122 -> 4118;
4123 -> 4121;
4124 -> 4111;
4125 -> 3854;
4126 -> 3854;
4127 -> 3854;
4128 -> 3854;
4129 -> 4127;
4129 -> 4128;
4130 -> 3854;
4130 -> 4128;
4131 -> 4130;
4131 -> 3854;
4131 -> 4128;
4132 -> 4128;
4133 -> 4131;
4134 -> 3854;
4135 -> 3854;
4136 -> 4134;
4136 -> 4135;
4137 -> 3854;
4137 -> 4135;
4138 -> 4137;
4138 -> 3854;
4138 -> 4135;
4139 -> 4135;
4140 -> 4138;
4141 -> 3854;
4142 -> 3854;
4142 -> 4084;
4143 -> 3854;
4144 -> 3854;
4145 -> 3854;
4146 -> 3854;
4147 -> 3854;
4148 -> 4147;
4148 -> 3854;
4149 -> 4146;
4149 -> 3854;
4150 -> 4147;
4150 -> 3854;
4151 -> 0;
4151 -> 3854;
4152 -> 3854;
4153 -> 3854;
4154 -> 3854;
4155 -> 4154;
4155 -> 4151;
4155 -> 3854;
4156 -> 4155;
4156 -> 3854;
4157 -> 3854;
4158 -> 3854;
4159 -> 4153;
4159 -> 4158;
4159 -> 3854;
4160 -> 0;
4160 -> 4159;
4161 -> 3854;
4162 -> 4160;
4162 -> 0;
4162 -> 3854;
4163 -> 4156;
4163 -> 0;
4163 -> 4162;
4164 -> 4162;
4165 -> 3854;
4166 -> 3854;
4167 -> 4166;
4167 -> 3854;
4167 -> 4165;
4168 -> 4166;
4169 -> 4167;
4169 -> 4168;
4169 -> 4166;
4170 -> 4167;
4170 -> 4166;
4171 -> 4166;
4172 -> 4166;
4173 -> 4172;
4173 -> 4166;
4174 -> 4171;
4174 -> 4166;
4175 -> 4172;
4175 -> 4166;
4176 -> 0;
4176 -> 4166;
4177 -> 4166;
4178 -> 4166;
4179 -> 4167;
4180 -> 4179;
4180 -> 4176;
4180 -> 4167;
4181 -> 4180;
4181 -> 4167;
4182 -> 4167;
4183 -> 4166;
4184 -> 4178;
4184 -> 4183;
4184 -> 4166;
4185 -> 0;
4185 -> 4184;
4186 -> 4166;
4187 -> 4185;
4187 -> 0;
4187 -> 4166;
4188 -> 4181;
4188 -> 0;
4188 -> 4187;
4189 -> 4187;
4190 -> 4167;
4191 -> 4167;
4192 -> 4167;
4193 -> 4167;
4194 -> 4192;
4194 -> 4193;
4195 -> 3854;
4195 -> 4193;
4196 -> 4195;
4196 -> 4167;
4196 -> 4193;
4197 -> 4193;
4198 -> 4196;
4199 -> 4167;
4200 -> 4167;
4201 -> 4167;
4202 -> 4200;
4202 -> 4201;
4203 -> 3854;
4203 -> 4201;
4204 -> 4203;
4204 -> 4167;
4204 -> 4201;
4205 -> 4201;
4206 -> 4204;
4207 -> 4038;
4208 -> 4052;
4208 -> 4167;
4208 -> 4207;
4208 -> 4038;
4209 -> 4043;
4209 -> 4038;
4210 -> 4038;
4211 -> 4041;
4211 -> 4210;
4211 -> 4038;
4212 -> 4211;
4213 -> 4212;
4214 -> 4213;
4215 -> 4167;
4216 -> 4167;
4217 -> 4167;
4218 -> 4034;
4218 -> 3449;
4219 -> 3449;
4220 -> 3438;
4220 -> 3449;
4221 -> 3438;
4221 -> 3449;
4222 -> 3438;
4222 -> 3449;
4223 -> 3438;
4223 -> 3449;
4224 -> 3449;
4225 -> 4223;
4225 -> 4167;
4225 -> 4224;
4225 -> 3449;
4226 -> 4220;
4226 -> 3449;
4227 -> 3449;
4228 -> 4226;
4228 -> 4227;
4229 -> 4223;
4229 -> 4227;
4230 -> 4227;
4231 -> 4229;
4231 -> 4167;
4231 -> 4230;
4231 -> 4227;
4232 -> 3449;
4233 -> 3449;
4234 -> 4233;
4235 -> 4234;
4236 -> 4235;
4237 -> 4167;
4237 -> 4235;
4238 -> 4233;
4239 -> 3449;
4240 -> 4239;
4241 -> 4167;
4241 -> 4239;
4242 -> 3449;
4243 -> 3449;
4244 -> 4243;
4245 -> 4167;
4245 -> 4243;
4246 -> 3438;
4246 -> 3449;
4247 -> 3438;
4247 -> 3449;
4248 -> 3449;
4249 -> 4247;
4249 -> 4248;
4250 -> 4249;
4250 -> 4167;
4250 -> 4248;
4251 -> 4250;
4251 -> 3449;
4252 -> 4251;
4252 -> 4167;
4252 -> 3449;
4253 -> 3449;
4254 -> 3438;
4254 -> 3449;
4255 -> 3438;
4255 -> 4167;
4255 -> 3449;
4256 -> 3449;
4257 -> 4256;
4257 -> 4255;
4257 -> 4167;
4257 -> 3449;
4258 -> 3449;
4259 -> 4167;
4260 -> 4167;
4261 -> 4260;
4261 -> 4259;
4261 -> 4167;
4262 -> 4167;
4263 -> 4167;
4263 -> 4262;
4264 -> 3438;
4264 -> 3449;
4265 -> 4264;
4265 -> 4167;
4265 -> 3449;
4266 -> 3449;
4267 -> 3449;
4268 -> 3438;
4268 -> 3449;
4269 -> 4268;
4269 -> 4167;
4269 -> 3449;
4270 -> 3449;
4271 -> 4269;
4271 -> 4270;
4272 -> 3449;
4273 -> 3438;
4273 -> 3449;
4274 -> 4273;
4274 -> 4167;
4274 -> 3449;
4275 -> 3449;
4276 -> 4274;
4276 -> 4275;
4277 -> 4275;
4278 -> 4276;
4278 -> 4275;
4279 -> 4275;
4280 -> 4278;
4280 -> 4279;
4281 -> 4279;
4282 -> 4281;
4283 -> 4281;
4284 -> 4167;
4284 -> 4281;
4285 -> 4284;
4285 -> 4279;
4286 -> 4279;
4287 -> 4167;
4287 -> 4279;
4288 -> 4287;
4289 -> 4285;
4289 -> 4288;
4289 -> 4287;
4290 -> 4289;
4291 -> 4275;
4292 -> 4277;
4292 -> 4275;
4293 -> 4277;
4293 -> 4275;
4294 -> 4277;
4294 -> 4275;
4295 -> 4277;
4295 -> 4275;
4296 -> 4277;
4296 -> 4275;
4297 -> 4277;
4297 -> 4275;
4298 -> 4277;
4298 -> 4275;
4299 -> 4277;
4299 -> 4275;
4300 -> 3449;
4301 -> 3438;
4301 -> 3449;
4302 -> 3449;
4303 -> 3449;
4304 -> 3438;
4304 -> 4167;
4304 -> 3449;
4305 -> 3449;
4306 -> 4305;
4307 -> 4306;
4308 -> 4307;
4309 -> 4167;
4309 -> 4307;
4310 -> 4305;
4311 -> 4167;
4311 -> 3449;
4312 -> 3449;
4313 -> 3438;
4313 -> 3449;
4314 -> 3438;
4314 -> 3449;
4315 -> 3438;
4315 -> 3449;
4316 -> 3438;
4316 -> 3449;
4317 -> 3449;
4318 -> 4316;
4318 -> 4167;
4318 -> 4317;
4319 -> 4317;
4320 -> 4319;
4321 -> 4320;
4322 -> 4318;
4322 -> 4320;
4323 -> 4317;
4324 -> 4318;
4324 -> 3449;
4325 -> 4324;
4325 -> 4313;
4325 -> 4318;
4325 -> 3449;
4326 -> 3449;
4327 -> 4326;
4327 -> 3449;
4328 -> 4315;
4328 -> 4327;
4328 -> 4167;
4328 -> 4326;
4328 -> 4318;
4328 -> 3449;
4329 -> 3449;
4330 -> 4326;
4330 -> 4328;
4330 -> 3449;
4331 -> 4326;
4331 -> 4330;
4332 -> 4330;
4333 -> 4326;
4333 -> 4330;
4334 -> 4333;
4334 -> 4331;
4334 -> 4330;
4335 -> 4330;
4336 -> 4334;
4336 -> 4335;
4336 -> 4330;
4337 -> 4314;
4337 -> 4336;
4338 -> 4334;
4338 -> 4336;
4339 -> 4336;
4340 -> 4337;
4340 -> 4339;
4341 -> 4338;
4341 -> 4339;
4342 -> 4316;
4342 -> 4339;
4343 -> 4341;
4343 -> 4340;
4343 -> 4339;
4344 -> 4343;
4345 -> 4326;
4345 -> 4334;
4345 -> 3449;
4346 -> 4344;
4346 -> 3449;
4347 -> 3438;
4347 -> 4346;
4347 -> 4345;
4347 -> 3443;
4348 -> 3438;
4348 -> 3449;
4349 -> 3438;
4349 -> 3449;
4350 -> 3449;
4351 -> 3449;
4352 -> 4351;
4353 -> 4352;
4354 -> 4347;
4354 -> 4352;
4355 -> 4351;
4356 -> 4351;
4357 -> 3449;
4358 -> 4249;
4358 -> 4347;
4358 -> 4248;
4359 -> 4358;
4359 -> 3449;
4360 -> 4359;
4360 -> 4347;
4360 -> 3449;
4361 -> 3438;
4361 -> 4347;
4361 -> 3449;
4362 -> 4256;
4362 -> 4361;
4362 -> 4347;
4362 -> 3449;
4363 -> 3449;
4364 -> 4264;
4364 -> 4347;
4364 -> 3449;
4365 -> 4268;
4365 -> 4347;
4365 -> 3449;
4366 -> 4365;
4366 -> 4270;
4367 -> 4273;
4367 -> 4347;
4367 -> 3449;
4368 -> 4367;
4368 -> 4275;
4369 -> 4368;
4369 -> 4275;
4370 -> 4369;
4370 -> 4279;
4371 -> 4347;
4371 -> 4281;
4372 -> 4371;
4372 -> 4279;
4373 -> 4347;
4373 -> 4279;
4374 -> 4373;
4375 -> 4372;
4375 -> 4374;
4375 -> 4373;
4376 -> 4375;
4377 -> 3438;
4377 -> 4347;
4377 -> 3449;
4378 -> 4347;
4378 -> 4307;
4379 -> 4347;
4379 -> 3449;
4380 -> 4347;
4380 -> 4320;
4381 -> 4347;
4381 -> 3449;
4382 -> 4381;
4382 -> 4313;
4382 -> 4347;
4382 -> 3449;
4383 -> 4316;
4383 -> 4347;
4384 -> 3438;
4384 -> 3449;
4385 -> 3438;
4385 -> 3449;
4386 -> 3438;
4386 -> 3449;
4387 -> 3438;
4387 -> 3449;
4388 -> 3449;
4389 -> 4386;
4389 -> 4388;
4389 -> 3449;
4390 -> 4384;
4390 -> 4347;
4390 -> 3449;
4391 -> 4384;
4391 -> 4390;
4392 -> 4385;
4392 -> 4390;
4393 -> 4386;
4393 -> 4390;
4394 -> 4390;
4395 -> 4390;
4396 -> 4391;
4396 -> 4395;
4397 -> 4392;
4397 -> 4395;
4398 -> 4393;
4398 -> 4395;
4399 -> 4394;
4399 -> 4395;
4400 -> 4394;
4400 -> 4395;
4401 -> 4387;
4401 -> 4395;
4402 -> 4396;
4402 -> 4347;
4402 -> 4395;
4403 -> 4395;
4404 -> 4398;
4404 -> 4403;
4404 -> 4395;
4405 -> 4396;
4405 -> 4402;
4405 -> 4395;
4406 -> 4396;
4406 -> 4402;
4406 -> 4405;
4407 -> 4396;
4407 -> 4402;
4407 -> 0;
4407 -> 4395;
4408 -> 4396;
4408 -> 4402;
4408 -> 4395;
4409 -> 4400;
4409 -> 4408;
4410 -> 4409;
4411 -> 4409;
4412 -> 4396;
4412 -> 4402;
4412 -> 4409;
4413 -> 4409;
4414 -> 4412;
4414 -> 4413;
4415 -> 4413;
4416 -> 4414;
4416 -> 4415;
4417 -> 4415;
4418 -> 4416;
4418 -> 4417;
4418 -> 4415;
4419 -> 4415;
4420 -> 4419;
4420 -> 4413;
4421 -> 4396;
4421 -> 4402;
4421 -> 4420;
4422 -> 4396;
4422 -> 4402;
4422 -> 4395;
4423 -> 4401;
4423 -> 4402;
4423 -> 4395;
4424 -> 4396;
4424 -> 4402;
4424 -> 4395;
4425 -> 3438;
4425 -> 3449;
4426 -> 3438;
4426 -> 3449;
4427 -> 3438;
4427 -> 3449;
4428 -> 4427;
4428 -> 4423;
4428 -> 3449;
4429 -> 4425;
4429 -> 3449;
4430 -> 4428;
4430 -> 4429;
4430 -> 3449;
4431 -> 3449;
4432 -> 4425;
4432 -> 4431;
4432 -> 3449;
4433 -> 3449;
4434 -> 4425;
4434 -> 3449;
4435 -> 4433;
4435 -> 3449;
4436 -> 4427;
4436 -> 4423;
4436 -> 4434;
4436 -> 4435;
4436 -> 3449;
4437 -> 4425;
4437 -> 3449;
4438 -> 4426;
4438 -> 3449;
4439 -> 3449;
4440 -> 4437;
4440 -> 4439;
4441 -> 4438;
4441 -> 4439;
4442 -> 4427;
4442 -> 4439;
4443 -> 4440;
4443 -> 4436;
4443 -> 4439;
4444 -> 4439;
4445 -> 4443;
4445 -> 4444;
4445 -> 4439;
4446 -> 4443;
4446 -> 4436;
4446 -> 4444;
4446 -> 4439;
4447 -> 4440;
4447 -> 4439;
4448 -> 4443;
4448 -> 4445;
4449 -> 4445;
4450 -> 4445;
4451 -> 4448;
4451 -> 4450;
4452 -> 4449;
4452 -> 4450;
4453 -> 4452;
4453 -> 4450;
4454 -> 4450;
4455 -> 4451;
4455 -> 4454;
4455 -> 4450;
4456 -> 4451;
4456 -> 4452;
4456 -> 4450;
4457 -> 4443;
4457 -> 4445;
4458 -> 4449;
4458 -> 4445;
4459 -> 4442;
4459 -> 4446;
4459 -> 4457;
4459 -> 4458;
4459 -> 4456;
4459 -> 4445;
4460 -> 4459;
4460 -> 4449;
4460 -> 4445;
4461 -> 4443;
4461 -> 4460;
4462 -> 4449;
4462 -> 4460;
4463 -> 4441;
4463 -> 4460;
4464 -> 4460;
4465 -> 4461;
4465 -> 4464;
4466 -> 4462;
4466 -> 4464;
4467 -> 4463;
4467 -> 4464;
4468 -> 4442;
4468 -> 4464;
4469 -> 4468;
4469 -> 4459;
4469 -> 4464;
4470 -> 4464;
4471 -> 4466;
4471 -> 4470;
4472 -> 4471;
4472 -> 4459;
4472 -> 4470;
4473 -> 4472;
4473 -> 4464;
4474 -> 4469;
4474 -> 4459;
4474 -> 4464;
4475 -> 4468;
4475 -> 4459;
4475 -> 0;
4475 -> 4464;
4476 -> 4473;
4476 -> 4459;
4476 -> 4464;
4477 -> 4475;
4477 -> 4476;
4477 -> 4464;
4478 -> 4465;
4478 -> 4459;
4478 -> 4464;
4479 -> 4464;
4480 -> 4478;
4480 -> 4479;
4481 -> 4465;
4481 -> 4480;
4481 -> 4464;
4482 -> 4480;
4482 -> 0;
4482 -> 4464;
4483 -> 4464;
4484 -> 4481;
4484 -> 4483;
4485 -> 4464;
4486 -> 4468;
4486 -> 4484;
4486 -> 4485;
4486 -> 4464;
4487 -> 4460;
4488 -> 4449;
4488 -> 4445;
4489 -> 4425;
4489 -> 3449;
4490 -> 4488;
4490 -> 3449;
4491 -> 4427;
4491 -> 4484;
4491 -> 4489;
4491 -> 4490;
4491 -> 3449;
4492 -> 4491;
4492 -> 3449;
4493 -> 3438;
4493 -> 3449;
4494 -> 4493;
4494 -> 4492;
4494 -> 3449;
4495 -> 3438;
4495 -> 3449;
4496 -> 3438;
4496 -> 4494;
4496 -> 3449;
4497 -> 4494;
4498 -> 4494;
4498 -> 4497;
4499 -> 4497;
4500 -> 4499;
4500 -> 4498;
4500 -> 4494;
4500 -> 4497;
4501 -> 4494;
4502 -> 4494;
4503 -> 4502;
4503 -> 4494;
4504 -> 4494;
4505 -> 4494;
4506 -> 4494;
4506 -> 4505;
4507 -> 4494;
4507 -> 4505;
4508 -> 4504;
4508 -> 4505;
4509 -> 4505;
4510 -> 4507;
4510 -> 4509;
4510 -> 4505;
4511 -> 4504;
4511 -> 4502;
4512 -> 4502;
4513 -> 4502;
4513 -> 4512;
4514 -> 4502;
4514 -> 4512;
4515 -> 4511;
4515 -> 4512;
4516 -> 4512;
4517 -> 4514;
4517 -> 4516;
4517 -> 4512;
4518 -> 4494;
4519 -> 4494;
4520 -> 3438;
4520 -> 4502;
4520 -> 4494;
4520 -> 4519;
4521 -> 3438;
4521 -> 3449;
4522 -> 3438;
4522 -> 3449;
4523 -> 3438;
4523 -> 3449;
4524 -> 4523;
4524 -> 4502;
4524 -> 3449;
4525 -> 4524;
4525 -> 4502;
4525 -> 3449;
4526 -> 3449;
4527 -> 4526;
4527 -> 4525;
4527 -> 3449;
4528 -> 3438;
4528 -> 3449;
4529 -> 0;
4529 -> 3449;
4530 -> 3438;
4530 -> 4502;
4530 -> 3449;
4531 -> 4385;
4531 -> 4502;
4532 -> 4386;
4532 -> 4502;
4533 -> 4531;
4533 -> 4502;
4534 -> 4532;
4534 -> 4502;
4535 -> 4502;
4536 -> 4502;
4537 -> 4502;
4538 -> 4534;
4538 -> 4537;
4538 -> 4502;
4539 -> 4502;
4540 -> 4502;
4540 -> 4539;
4541 -> 4502;
4541 -> 0;
4542 -> 4502;
4543 -> 4536;
4543 -> 4542;
4544 -> 4543;
4545 -> 4543;
4546 -> 4502;
4546 -> 4543;
4547 -> 4543;
4548 -> 4546;
4548 -> 4547;
4549 -> 4547;
4550 -> 4548;
4550 -> 4549;
4551 -> 4549;
4552 -> 4550;
4552 -> 4551;
4552 -> 4549;
4553 -> 4549;
4554 -> 4553;
4554 -> 4547;
4555 -> 4502;
4555 -> 4554;
4556 -> 4502;
4557 -> 3438;
4557 -> 3449;
4558 -> 3438;
4558 -> 3449;
4559 -> 3438;
4559 -> 3449;
4560 -> 4557;
4560 -> 4502;
4560 -> 3449;
4561 -> 3449;
4562 -> 4560;
4562 -> 4561;
4562 -> 3449;
4563 -> 4558;
4563 -> 0;
4563 -> 4562;
4564 -> 4560;
4564 -> 4558;
4564 -> 4562;
4565 -> 4558;
4565 -> 0;
4565 -> 4564;
4566 -> 4427;
4566 -> 4564;
4566 -> 3449;
4567 -> 4564;
4568 -> 3438;
4568 -> 4567;
4568 -> 3449;
4569 -> 4567;
4569 -> 4307;
4570 -> 4567;
4570 -> 3449;
4571 -> 3449;
4572 -> 3449;
4573 -> 3449;
4574 -> 3449;
4575 -> 3438;
4575 -> 4567;
4576 -> 4567;
4577 -> 4575;
4577 -> 4567;
4577 -> 4576;
4578 -> 4567;
4579 -> 4567;
4580 -> 4567;
4581 -> 4567;
4582 -> 4567;
4583 -> 4582;
4583 -> 4567;
4584 -> 4582;
4584 -> 4583;
4585 -> 4584;
4585 -> 4583;
4586 -> 4571;
4586 -> 4583;
4587 -> 4582;
4587 -> 4583;
4588 -> 4583;
4589 -> 4586;
4589 -> 4588;
4590 -> 4587;
4590 -> 4588;
4591 -> 3438;
4591 -> 4588;
4592 -> 4590;
4592 -> 4588;
4593 -> 4588;
4594 -> 4592;
4594 -> 4593;
4595 -> 4591;
4595 -> 4593;
4596 -> 4594;
4596 -> 4585;
4596 -> 4593;
4597 -> 4595;
4597 -> 4585;
4597 -> 4596;
4597 -> 4593;
4598 -> 4593;
4599 -> 4594;
4599 -> 4585;
4599 -> 4593;
4600 -> 4588;
4601 -> 4599;
4601 -> 4600;
4601 -> 4588;
4602 -> 4589;
4602 -> 4601;
4603 -> 4599;
4603 -> 4601;
4604 -> 4590;
4604 -> 4585;
4604 -> 4601;
4605 -> 4601;
4606 -> 4602;
4606 -> 4605;
4607 -> 4603;
4607 -> 4605;
4608 -> 4604;
4608 -> 4605;
4609 -> 4591;
4609 -> 4605;
4610 -> 4609;
4610 -> 4607;
4610 -> 4605;
4611 -> 4605;
4612 -> 4610;
4612 -> 4611;
4612 -> 4605;
4613 -> 4601;
4614 -> 4583;
4615 -> 4571;
4615 -> 3449;
4616 -> 4610;
4616 -> 4243;
4617 -> 3440;
4617 -> 3437;
4618 -> 3437;
4619 -> 4617;
4619 -> 4618;
4620 -> 4619;
4620 -> 4618;
4621 -> 4618;
4622 -> 4620;
4622 -> 4621;
4623 -> 4622;
4623 -> 4621;
4624 -> 4621;
4625 -> 4621;
4626 -> 4623;
4626 -> 4625;
4627 -> 4624;
4627 -> 4625;
4628 -> 4625;
4629 -> 4626;
4629 -> 4628;
4629 -> 4625;
4630 -> 4626;
4630 -> 4625;
4631 -> 4626;
4631 -> 4625;
4632 -> 4627;
4632 -> 4630;
4632 -> 4631;
4632 -> 4625;
4633 -> 4626;
4633 -> 4625;
4634 -> 4625;
4635 -> 4610;
4635 -> 4634;
4635 -> 4625;
4636 -> 4625;
4637 -> 4626;
4637 -> 4625;
4638 -> 4625;
4639 -> 4637;
4639 -> 4638;
4640 -> 4638;
4641 -> 4638;
4642 -> 4610;
4642 -> 4638;
4643 -> 4642;
4643 -> 4638;
4644 -> 4641;
4644 -> 4643;
4645 -> 4644;
4645 -> 4640;
4645 -> 4638;
4646 -> 4644;
4646 -> 4640;
4646 -> 4638;
4647 -> 4646;
4647 -> 4638;
4648 -> 4639;
4648 -> 4638;
4649 -> 4639;
4649 -> 4638;
4650 -> 4639;
4650 -> 4638;
4651 -> 4638;
4652 -> 4650;
4652 -> 4651;
4653 -> 2395;
4653 -> 4651;
4654 -> 4651;
4655 -> 4652;
4655 -> 4651;
4656 -> 4651;
4657 -> 4656;
4657 -> 4638;
4658 -> 4657;
4659 -> 4658;
4660 -> 2395;
4660 -> 4658;
4661 -> 4638;
4662 -> 4661;
4662 -> 4638;
4663 -> 4638;
4664 -> 4638;
4665 -> 4661;
4665 -> 4664;
4665 -> 4662;
4665 -> 4638;
4666 -> 4638;
4667 -> 4639;
4667 -> 4638;
4668 -> 4661;
4668 -> 4638;
4669 -> 4666;
4669 -> 4638;
4670 -> 4638;
4671 -> 4668;
4671 -> 4670;
4672 -> 4669;
4672 -> 4670;
4673 -> 4672;
4673 -> 4666;
4673 -> 4670;
4674 -> 4670;
4675 -> 4674;
4675 -> 4673;
4675 -> 4670;
4676 -> 4638;
4677 -> 4638;
4678 -> 4661;
4678 -> 4677;
4678 -> 4665;
4678 -> 4638;
4679 -> 4638;
4680 -> 4638;
4681 -> 4638;
4682 -> 4680;
4682 -> 4681;
4682 -> 4638;
4683 -> 4638;
4684 -> 4661;
4684 -> 4683;
4684 -> 4678;
4684 -> 4638;
4685 -> 4666;
4685 -> 4638;
4686 -> 4679;
4686 -> 4638;
4687 -> 0;
4687 -> 4638;
4688 -> 4638;
4689 -> 4638;
4690 -> 4685;
4690 -> 4689;
4691 -> 4686;
4691 -> 4689;
4692 -> 4687;
4692 -> 4689;
4693 -> 4688;
4693 -> 4689;
4694 -> 4688;
4694 -> 4689;
4695 -> 4689;
4696 -> 4693;
4696 -> 4695;
4696 -> 4689;
4697 -> 4696;
4697 -> 4689;
4698 -> 2452;
4698 -> 4697;
4699 -> 4689;
4700 -> 4699;
4700 -> 4694;
4700 -> 4689;
4701 -> 4690;
4701 -> 4689;
4702 -> 4691;
4702 -> 4689;
4703 -> 4692;
4703 -> 4689;
4704 -> 4701;
4704 -> 4689;
4705 -> 4702;
4705 -> 4689;
4706 -> 4700;
4706 -> 4689;
4707 -> 4689;
4708 -> 4704;
4708 -> 4707;
4709 -> 4705;
4709 -> 4707;
4710 -> 4706;
4710 -> 4707;
4711 -> 4698;
4711 -> 4707;
4712 -> 4708;
4712 -> 4707;
4713 -> 4708;
4713 -> 4701;
4713 -> 4707;
4714 -> 4709;
4714 -> 4707;
4715 -> 4709;
4715 -> 4702;
4715 -> 4707;
4716 -> 4707;
4717 -> 4712;
4717 -> 4716;
4718 -> 4713;
4718 -> 4716;
4719 -> 4714;
4719 -> 4716;
4720 -> 4715;
4720 -> 4716;
4721 -> 4711;
4721 -> 4716;
4722 -> 4717;
4722 -> 4716;
4723 -> 4718;
4723 -> 4716;
4724 -> 4719;
4724 -> 4716;
4725 -> 4720;
4725 -> 4716;
4726 -> 4716;
4727 -> 4722;
4727 -> 4726;
4728 -> 4723;
4728 -> 4726;
4729 -> 4724;
4729 -> 4726;
4730 -> 4725;
4730 -> 4726;
4731 -> 4721;
4731 -> 4726;
4732 -> 4726;
4733 -> 4728;
4733 -> 4732;
4733 -> 4726;
4734 -> 4726;
4735 -> 4730;
4735 -> 4734;
4735 -> 4726;
4736 -> 4733;
4736 -> 4735;
4736 -> 4726;
4737 -> 4726;
4738 -> 4737;
4738 -> 4736;
4738 -> 4726;
4739 -> 4726;
4740 -> 4739;
4740 -> 4728;
4740 -> 4726;
4741 -> 4726;
4742 -> 4741;
4742 -> 4730;
4742 -> 4726;
4743 -> 4726;
4744 -> 4743;
4744 -> 4728;
4744 -> 4726;
4745 -> 4736;
4745 -> 4726;
4746 -> 4718;
4746 -> 4716;
4747 -> 4720;
4747 -> 4716;
4748 -> 4716;
4749 -> 4746;
4749 -> 4748;
4749 -> 4716;
4750 -> 4716;
4751 -> 4746;
4751 -> 4750;
4751 -> 4716;
4752 -> 4716;
4753 -> 4747;
4753 -> 4752;
4753 -> 4716;
4754 -> 4716;
4755 -> 4754;
4755 -> 4707;
4756 -> 4707;
4757 -> 4756;
4757 -> 4689;
4758 -> 4703;
4758 -> 4757;
4758 -> 4689;
4759 -> 4661;
4759 -> 4758;
4759 -> 4684;
4759 -> 4638;
4760 -> 4679;
4760 -> 4638;
4761 -> 4666;
4761 -> 4638;
4762 -> 4661;
4762 -> 4759;
4762 -> 4638;
4763 -> 4762;
4763 -> 4625;
4764 -> 4618;
4765 -> 3438;
4765 -> 3437;
4766 -> 3213;
4766 -> 1;
4767 -> 1;
4768 -> 3212;
4768 -> 4767;
4768 -> 1;
4769 -> 0;
4769 -> 1;
4770 -> 0;
4770 -> 4769;
4770 -> 4610;
4770 -> 1;
4771 -> 4766;
4771 -> 4767;
4771 -> 4770;
4771 -> 4768;
4771 -> 1;
4772 -> 4767;
4773 -> 4772;
4774 -> 4771;
4774 -> 4767;
4775 -> 4771;
4775 -> 4767;
4776 -> 4774;
4776 -> 4767;
4777 -> 4767;
4778 -> 4777;
4778 -> 4767;
4779 -> 4767;
4780 -> 4776;
4780 -> 4779;
4781 -> 4778;
4781 -> 4779;
4782 -> 4779;
4783 -> 4771;
4784 -> 4771;
4785 -> 4783;
4785 -> 4771;
4786 -> 4771;
4787 -> 4784;
4787 -> 4771;
4787 -> 4785;
4787 -> 4786;
4787 -> 4783;
4788 -> 4771;
4789 -> 4788;
4789 -> 4783;
4789 -> 4771;
4790 -> 4783;
4790 -> 4771;
4791 -> 4771;
4792 -> 4790;
4792 -> 4791;
4792 -> 4783;
4792 -> 4789;
4792 -> 4771;
4793 -> 4779;
4794 -> 4771;
4794 -> 4793;
4794 -> 4779;
4795 -> 0;
4795 -> 4779;
4796 -> 4781;
4796 -> 4779;
4797 -> 4771;
4797 -> 4779;
4798 -> 4779;
4799 -> 4797;
4799 -> 4798;
4800 -> 0;
4800 -> 4798;
4801 -> 4800;
4802 -> 4779;
4803 -> 4779;
4804 -> 4803;
4805 -> 4803;
4806 -> 4803;
4807 -> 4805;
4807 -> 4806;
4808 -> 4805;
4808 -> 4806;
4809 -> 4805;
4809 -> 4806;
4810 -> 4805;
4810 -> 4806;
4811 -> 4806;
4812 -> 4771;
4812 -> 4811;
4812 -> 4806;
4813 -> 4810;
4813 -> 4806;
4814 -> 4807;
4814 -> 4806;
4815 -> 4808;
4815 -> 4806;
4816 -> 4809;
4816 -> 4806;
4817 -> 4810;
4817 -> 4806;
4818 -> 4806;
4819 -> 0;
4819 -> 4806;
4820 -> 4806;
4821 -> 4819;
4821 -> 4820;
4822 -> 4819;
4822 -> 4820;
4823 -> 4817;
4823 -> 4820;
4824 -> 4818;
4824 -> 4820;
4825 -> 4818;
4825 -> 4820;
4826 -> 4821;
4826 -> 4820;
4827 -> 4822;
4827 -> 4820;
4828 -> 4823;
4828 -> 4820;
4829 -> 4820;
4830 -> 4829;
4830 -> 4820;
4831 -> 4824;
4831 -> 4829;
4831 -> 4820;
4832 -> 4806;
4833 -> 4814;
4833 -> 4832;
4834 -> 4815;
4834 -> 4832;
4835 -> 4816;
4835 -> 4832;
4836 -> 4817;
4836 -> 4832;
4837 -> 4818;
4837 -> 4832;
4838 -> 4818;
4838 -> 4832;
4839 -> 4818;
4839 -> 4832;
4840 -> 4818;
4840 -> 4832;
4841 -> 4818;
4841 -> 4832;
4842 -> 4818;
4842 -> 4832;
4843 -> 4833;
4843 -> 4832;
4844 -> 4834;
4844 -> 4832;
4845 -> 4835;
4845 -> 4832;
4846 -> 4836;
4846 -> 4832;
4847 -> 4837;
4847 -> 4832;
4848 -> 4838;
4848 -> 4832;
4849 -> 4839;
4849 -> 4832;
4850 -> 4840;
4850 -> 4832;
4851 -> 4841;
4851 -> 4832;
4852 -> 4832;
4853 -> 4843;
4853 -> 4852;
4854 -> 4844;
4854 -> 4852;
4855 -> 4845;
4855 -> 4852;
4856 -> 4846;
4856 -> 4852;
4857 -> 4847;
4857 -> 4852;
4858 -> 4848;
4858 -> 4852;
4859 -> 4849;
4859 -> 4852;
4860 -> 4850;
4860 -> 4852;
4861 -> 4851;
4861 -> 4852;
4862 -> 4842;
4862 -> 4852;
4863 -> 4856;
4863 -> 4852;
4864 -> 4860;
4864 -> 4852;
4865 -> 4861;
4865 -> 4852;
4866 -> 4852;
4867 -> 4866;
4867 -> 4852;
4868 -> 4866;
4868 -> 4852;
4869 -> 4866;
4869 -> 4852;
4870 -> 4866;
4870 -> 4852;
4871 -> 4866;
4871 -> 4852;
4872 -> 4866;
4872 -> 4852;
4873 -> 4866;
4873 -> 4852;
4874 -> 4866;
4874 -> 4852;
4875 -> 4866;
4875 -> 4852;
4876 -> 4866;
4876 -> 4852;
4877 -> 4866;
4877 -> 4852;
4878 -> 4866;
4878 -> 4852;
4879 -> 4866;
4879 -> 4852;
4880 -> 4866;
4880 -> 4852;
4881 -> 4866;
4881 -> 4852;
4882 -> 4866;
4882 -> 4852;
4883 -> 4866;
4883 -> 4852;
4884 -> 4866;
4884 -> 4852;
4885 -> 4866;
4885 -> 4852;
4886 -> 4866;
4886 -> 4852;
4887 -> 4866;
4887 -> 4852;
4888 -> 4866;
4888 -> 4852;
4889 -> 4866;
4889 -> 4852;
4890 -> 4866;
4890 -> 4852;
4891 -> 4866;
4891 -> 4852;
4892 -> 4866;
4892 -> 4852;
4893 -> 4852;
4894 -> 4893;
4894 -> 4866;
4894 -> 4852;
4895 -> 4866;
4895 -> 4852;
4896 -> 4866;
4896 -> 4852;
4897 -> 4852;
4898 -> 4852;
4899 -> 4896;
4899 -> 4898;
4900 -> 4897;
4900 -> 4898;
4901 -> 4900;
4901 -> 4898;
4902 -> 4900;
4902 -> 4898;
4903 -> 4900;
4903 -> 4898;
4904 -> 4899;
4904 -> 4900;
4904 -> 4898;
4905 -> 4897;
4905 -> 4866;
4905 -> 4852;
4906 -> 4866;
4906 -> 4852;
4907 -> 4852;
4908 -> 4907;
4909 -> 0;
4909 -> 4907;
4910 -> 4909;
4910 -> 4908;
4910 -> 4907;
4911 -> 4910;
4911 -> 4852;
4912 -> 4911;
4912 -> 4866;
4912 -> 4852;
4913 -> 4856;
4913 -> 4852;
4914 -> 4913;
4915 -> 4853;
4915 -> 4914;
4915 -> 4913;
4916 -> 4854;
4916 -> 4914;
4916 -> 4913;
4917 -> 4915;
4917 -> 4916;
4917 -> 4913;
4918 -> 4855;
4918 -> 4914;
4918 -> 4913;
4919 -> 4917;
4919 -> 4918;
4919 -> 4913;
4920 -> 4858;
4920 -> 4852;
4921 -> 4920;
4922 -> 4866;
4922 -> 4921;
4923 -> 4857;
4923 -> 4920;
4924 -> 4859;
4924 -> 4866;
4924 -> 4852;
4925 -> 4866;
4925 -> 4771;
4925 -> 4852;
4926 -> 4852;
4927 -> 4866;
4927 -> 4771;
4927 -> 4926;
4927 -> 4852;
4928 -> 4806;
4929 -> 4771;
4930 -> 4771;
4931 -> 4771;
4932 -> 4771;
4933 -> 4771;
4934 -> 4930;
4934 -> 4771;
4935 -> 4771;
4936 -> 4771;
4937 -> 4771;
4938 -> 4771;
4939 -> 4771;
4940 -> 4771;
4941 -> 4940;
4941 -> 4771;
4942 -> 4940;
4942 -> 4771;
4943 -> 4940;
4943 -> 4771;
4944 -> 4941;
4944 -> 4771;
4945 -> 4942;
4945 -> 4771;
4946 -> 4943;
4946 -> 4771;
4947 -> 4944;
4947 -> 4940;
4948 -> 4945;
4948 -> 4940;
4949 -> 4946;
4949 -> 4940;
4950 -> 4940;
4951 -> 4940;
4952 -> 4951;
4953 -> 4947;
4953 -> 4952;
4953 -> 4951;
4954 -> 4948;
4954 -> 4952;
4954 -> 4951;
4955 -> 4953;
4955 -> 4954;
4955 -> 4951;
4956 -> 4949;
4956 -> 4952;
4956 -> 4951;
4957 -> 4955;
4957 -> 4956;
4957 -> 4951;
4958 -> 4940;
4959 -> 4940;
4960 -> 4940;
4961 -> 4940;
4961 -> 4806;
4962 -> 4779;
4963 -> 4962;
4964 -> 4963;
4965 -> 4964;
4966 -> 4940;
4967 -> 4940;
4968 -> 4966;
4968 -> 4940;
4969 -> 4966;
4969 -> 4940;
4970 -> 4966;
4970 -> 4940;
4971 -> 4940;
4972 -> 4971;
4972 -> 0;
4972 -> 4940;
4973 -> 4966;
4973 -> 4940;
4974 -> 4966;
4974 -> 4940;
4975 -> 4966;
4975 -> 4940;
4976 -> 4966;
4976 -> 4940;
4977 -> 4966;
4977 -> 4940;
4978 -> 4966;
4978 -> 4962;
4979 -> 4962;
4980 -> 0;
4980 -> 4962;
4981 -> 4780;
4981 -> 4966;
4981 -> 4779;
4982 -> 4966;
4982 -> 1;
4983 -> 11;
4983 -> 1;
4984 -> 1;
4985 -> 1;
4986 -> 4982;
4986 -> 4985;
4987 -> 4983;
4987 -> 4985;
4988 -> 4984;
4988 -> 4985;
4989 -> 4987;
4989 -> 4985;
4990 -> 4985;
4991 -> 4985;
4992 -> 4989;
4992 -> 4991;
4993 -> 4990;
4993 -> 4991;
4994 -> 4991;
4995 -> 0;
4995 -> 4994;
4996 -> 4995;
4996 -> 4991;
4997 -> 4991;
4998 -> 4996;
4998 -> 4991;
4999 -> 4992;
4999 -> 4991;
5000 -> 4993;
5000 -> 4991;
5001 -> 4986;
5001 -> 4997;
5002 -> 4986;
5002 -> 4997;
5003 -> 4986;
5003 -> 4997;
5004 -> 4986;
5004 -> 4997;
5005 -> 4986;
5005 -> 4997;
5006 -> 4997;
5007 -> 5006;
5008 -> 5007;
5009 -> 5008;
5010 -> 5009;
5011 -> 4986;
5012 -> 4986;
5012 -> 5009;
5013 -> 4986;
5013 -> 5007;
5014 -> 5013;
5014 -> 5007;
5015 -> 5006;
5016 -> 4997;
5017 -> 4986;
5017 -> 5016;
5017 -> 4997;
5018 -> 4997;
5019 -> 5018;
5020 -> 5019;
5021 -> 4986;
5021 -> 5019;
5022 -> 5018;
5023 -> 5022;
5024 -> 5023;
5025 -> 5024;
5026 -> 5022;
5027 -> 5026;
5028 -> 5027;
5029 -> 5018;
5030 -> 5029;
5031 -> 4986;
5031 -> 5029;
5032 -> 5018;
5033 -> 4986;
5033 -> 5018;
5034 -> 5018;
5035 -> 4997;
5036 -> 4997;
5037 -> 4986;
5038 -> 4986;
5039 -> 4986;
5040 -> 4986;
5041 -> 4997;
5042 -> 5001;
5042 -> 5041;
5042 -> 4997;
5043 -> 4997;
5044 -> 5002;
5044 -> 5043;
5044 -> 4997;
5045 -> 4997;
5046 -> 5003;
5046 -> 5045;
5046 -> 4997;
5047 -> 4997;
5048 -> 4986;
5048 -> 4997;
5049 -> 0;
5049 -> 4997;
5050 -> 4997;
5051 -> 4997;
5052 -> 5049;
5052 -> 5051;
5053 -> 5050;
5053 -> 5051;
5054 -> 5051;
5055 -> 5052;
5055 -> 5051;
5056 -> 5053;
5056 -> 5051;
5057 -> 5054;
5057 -> 5051;
5058 -> 5051;
5059 -> 5055;
5059 -> 5058;
5060 -> 5056;
5060 -> 5058;
5061 -> 5057;
5061 -> 5058;
5062 -> 5058;
5063 -> 5059;
5063 -> 0;
5063 -> 5058;
5064 -> 5063;
5064 -> 5060;
5064 -> 5058;
5065 -> 5064;
5066 -> 5065;
5067 -> 5066;
5068 -> 5064;
5069 -> 4986;
5070 -> 4986;
5071 -> 5064;
5072 -> 4986;
5073 -> 5059;
5073 -> 0;
5073 -> 5058;
5074 -> 5062;
5074 -> 5073;
5075 -> 5073;
5076 -> 5073;
5077 -> 5073;
5078 -> 4986;
5078 -> 5077;
5079 -> 5078;
5079 -> 5073;
5080 -> 5073;
5081 -> 5073;
5082 -> 5073;
5083 -> 5081;
5083 -> 5082;
5084 -> 5081;
5084 -> 5082;
5085 -> 5081;
5085 -> 5082;
5086 -> 5082;
5087 -> 5086;
5088 -> 5087;
5089 -> 5082;
5090 -> 5082;
5091 -> 5083;
5091 -> 5090;
5091 -> 5082;
5092 -> 5082;
5093 -> 5092;
5094 -> 5093;
5095 -> 4986;
5095 -> 5093;
5096 -> 5089;
5096 -> 5082;
5097 -> 5082;
5098 -> 5097;
5099 -> 5098;
5100 -> 4986;
5100 -> 5098;
5101 -> 5097;
5102 -> 5101;
5103 -> 5102;
5104 -> 5097;
5105 -> 5104;
5106 -> 5105;
5107 -> 4986;
5107 -> 5097;
5108 -> 5097;
5109 -> 4986;
5109 -> 5097;
5110 -> 4986;
5110 -> 5097;
5111 -> 5110;
5111 -> 4986;
5111 -> 5097;
5112 -> 5097;
5113 -> 5097;
5114 -> 5097;
5115 -> 5097;
5116 -> 5114;
5116 -> 5115;
5117 -> 5116;
5117 -> 5115;
5118 -> 5115;
5119 -> 5115;
5120 -> 5118;
5120 -> 5119;
5121 -> 5120;
5121 -> 5119;
5122 -> 5119;
5123 -> 5122;
5124 -> 5123;
5125 -> 5123;
5126 -> 5125;
5127 -> 5122;
5128 -> 5127;
5129 -> 5119;
5130 -> 5119;
5131 -> 5119;
5132 -> 5120;
5132 -> 5119;
5133 -> 5119;
5134 -> 5132;
5134 -> 5133;
5135 -> 5134;
5135 -> 5133;
5136 -> 5133;
5137 -> 5133;
5138 -> 5137;
5139 -> 5137;
5140 -> 5114;
5141 -> 5140;
5142 -> 5141;
5143 -> 4986;
5143 -> 5141;
5144 -> 5114;
5145 -> 5097;
5146 -> 5145;
5147 -> 5146;
5148 -> 5145;
5149 -> 5145;
5150 -> 4986;
5150 -> 5097;
5151 -> 5150;
5151 -> 5097;
5152 -> 5097;
5153 -> 5097;
5154 -> 5152;
5154 -> 5153;
5155 -> 5154;
5155 -> 5153;
5156 -> 5153;
5157 -> 5156;
5158 -> 5157;
5159 -> 5157;
5160 -> 5159;
5161 -> 5156;
5162 -> 5161;
5163 -> 5153;
5164 -> 5153;
5165 -> 5153;
5166 -> 5164;
5166 -> 5153;
5167 -> 4986;
5168 -> 5097;
5169 -> 5168;
5170 -> 5169;
5171 -> 5097;
5172 -> 4986;
5172 -> 0;
5172 -> 5097;
5173 -> 5097;
5174 -> 5167;
5175 -> 5167;
5175 -> 4986;
5175 -> 5097;
5176 -> 5097;
5177 -> 5176;
5178 -> 5177;
5179 -> 5167;
5179 -> 5177;
5180 -> 5097;
5181 -> 4986;
5181 -> 5167;
5181 -> 5097;
5182 -> 5097;
5183 -> 5182;
5184 -> 5183;
5185 -> 5184;
5186 -> 5167;
5186 -> 5184;
5187 -> 5182;
5188 -> 5167;
5188 -> 5097;
5189 -> 5097;
5190 -> 5110;
5190 -> 5167;
5190 -> 5097;
5191 -> 4986;
5191 -> 5167;
5191 -> 5097;
5192 -> 5083;
5192 -> 5082;
5193 -> 5192;
5194 -> 5192;
5195 -> 5082;
5196 -> 5085;
5196 -> 5195;
5196 -> 5082;
5197 -> 5083;
5197 -> 5082;
5198 -> 5084;
5198 -> 5082;
5199 -> 5082;
5200 -> 5197;
5200 -> 5199;
5201 -> 5198;
5201 -> 5199;
5202 -> 5199;
5203 -> 5200;
5203 -> 5202;
5203 -> 5199;
5204 -> 5167;
5205 -> 5167;
5206 -> 5167;
5206 -> 0;
5207 -> 5167;
5208 -> 5167;
5208 -> 0;
5209 -> 5167;
5209 -> 0;
5210 -> 5167;
5210 -> 0;
5211 -> 5167;
5211 -> 0;
5212 -> 5167;
5212 -> 0;
5213 -> 5167;
5213 -> 0;
5214 -> 5167;
5215 -> 5167;
5216 -> 5167;
5217 -> 5167;
5217 -> 0;
5218 -> 5167;
5219 -> 5167;
5220 -> 5218;
5220 -> 5219;
5221 -> 5220;
5221 -> 5219;
5222 -> 5221;
5223 -> 5167;
5224 -> 5223;
5224 -> 5167;
5225 -> 5167;
5226 -> 5225;
5226 -> 5167;
5227 -> 5216;
5227 -> 5226;
5228 -> 5167;
5229 -> 5227;
5229 -> 5228;
5229 -> 5167;
5230 -> 5229;
5230 -> 5223;
5230 -> 5167;
5231 -> 5223;
5231 -> 5167;
5232 -> 5222;
5232 -> 5231;
5233 -> 5222;
5233 -> 5167;
5234 -> 5167;
5234 -> 0;
5235 -> 5167;
5236 -> 5167;
5237 -> 5167;
5238 -> 5236;
5238 -> 5237;
5239 -> 5238;
5239 -> 5237;
5240 -> 5239;
5241 -> 5167;
5242 -> 5240;
5242 -> 5241;
5243 -> 5167;
5244 -> 5167;
5245 -> 5243;
5245 -> 5244;
5246 -> 5167;
5246 -> 5244;
5247 -> 5245;
5247 -> 5167;
5247 -> 0;
5247 -> 5244;
5248 -> 5247;
5249 -> 5167;
5250 -> 5236;
5250 -> 5249;
5251 -> 5250;
5251 -> 5249;
5252 -> 5251;
5253 -> 5167;
5254 -> 5167;
5255 -> 5167;
5256 -> 4986;
5256 -> 5167;
5256 -> 5199;
5257 -> 5073;
5258 -> 4986;
5258 -> 5167;
5258 -> 5257;
5258 -> 5073;
5259 -> 5059;
5259 -> 0;
5259 -> 5058;
5260 -> 5061;
5260 -> 5058;
5261 -> 5062;
5261 -> 5058;
5262 -> 5058;
5263 -> 5051;
5264 -> 5047;
5264 -> 4997;
5265 -> 5047;
5265 -> 4997;
5266 -> 5167;
5267 -> 5167;
5268 -> 5167;
5269 -> 5167;
5270 -> 4986;
5271 -> 4986;
5272 -> 5167;
5272 -> 5271;
5272 -> 4986;
5273 -> 4986;
5274 -> 5273;
5274 -> 5167;
5275 -> 5274;
5275 -> 4986;
5276 -> 4986;
5277 -> 4986;
5278 -> 5167;
5279 -> 5167;
5280 -> 5167;
5281 -> 5280;
5281 -> 5167;
5282 -> 5167;
5283 -> 5280;
5283 -> 5167;
5284 -> 4986;
5285 -> 4986;
5286 -> 5167;
5286 -> 5285;
5286 -> 4986;
5287 -> 5167;
5287 -> 4986;
5288 -> 4986;
5289 -> 5287;
5289 -> 5288;
5290 -> 5167;
5290 -> 5288;
5291 -> 5289;
5291 -> 5288;
5292 -> 4986;
5293 -> 5280;
5293 -> 5167;
5294 -> 5280;
5295 -> 5280;
5296 -> 5280;
5297 -> 5295;
5297 -> 5296;
5298 -> 5295;
5298 -> 5296;
5299 -> 5296;
5300 -> 5297;
5300 -> 5299;
5300 -> 5296;
5301 -> 5280;
5302 -> 5280;
5303 -> 4986;
5304 -> 5280;
5304 -> 5303;
5304 -> 4986;
5305 -> 4986;
5306 -> 5167;
5306 -> 4986;
5307 -> 4986;
5308 -> 5306;
5308 -> 5307;
5309 -> 5307;
5309 -> 5280;
5310 -> 5309;
5310 -> 4986;
5311 -> 5310;
5311 -> 4986;
5312 -> 5167;
5312 -> 4986;
5313 -> 4986;
5314 -> 5311;
5314 -> 5313;
5315 -> 5312;
5315 -> 5313;
5316 -> 5167;
5316 -> 5313;
5317 -> 5314;
5317 -> 5313;
5318 -> 4986;
5319 -> 5167;
5319 -> 4986;
5320 -> 5319;
5320 -> 4986;
5321 -> 5320;
5321 -> 4986;
5322 -> 5321;
5322 -> 4986;
5323 -> 5280;
5323 -> 4986;
5324 -> 5323;
5324 -> 4986;
5325 -> 5280;
5325 -> 4986;
5326 -> 5325;
5327 -> 5324;
5327 -> 5326;
5327 -> 5325;
5328 -> 5327;
5329 -> 4986;
5330 -> 5280;
5330 -> 4986;
5331 -> 5330;
5331 -> 4986;
5332 -> 5167;
5332 -> 4986;
5333 -> 4986;
5334 -> 5331;
5334 -> 5333;
5335 -> 5332;
5335 -> 5333;
5336 -> 5167;
5336 -> 5333;
5337 -> 5334;
5337 -> 5333;
5338 -> 4986;
5339 -> 5280;
5339 -> 5167;
5340 -> 5280;
5340 -> 5167;
5341 -> 4986;
5342 -> 4986;
5342 -> 5280;
5343 -> 4986;
5344 -> 5342;
5344 -> 5343;
5344 -> 4986;
5345 -> 4986;
5346 -> 5167;
5346 -> 5280;
5346 -> 4986;
5347 -> 5167;
5348 -> 5280;
5348 -> 5347;
5348 -> 5167;
5349 -> 4986;
5349 -> 5280;
5350 -> 5280;
5351 -> 5349;
5351 -> 5350;
5352 -> 5349;
5352 -> 5350;
5353 -> 4986;
5353 -> 5350;
5354 -> 5353;
5354 -> 5280;
5354 -> 5350;
5355 -> 5353;
5355 -> 5280;
5355 -> 5350;
5356 -> 5280;
5357 -> 5167;
5357 -> 5280;
5357 -> 4986;
5358 -> 4997;
5359 -> 4997;
5360 -> 5359;
5360 -> 4997;
5361 -> 4997;
5362 -> 5361;
5363 -> 5280;
5363 -> 5361;
5364 -> 4997;
5365 -> 5359;
5365 -> 4997;
5366 -> 4997;
5367 -> 5365;
5367 -> 5366;
5368 -> 5366;
5369 -> 5368;
5370 -> 5280;
5370 -> 5368;
5371 -> 5280;
5371 -> 5366;
5372 -> 5366;
5373 -> 5372;
5373 -> 5371;
5373 -> 5280;
5373 -> 5366;
5374 -> 5366;
5375 -> 5374;
5375 -> 4997;
5376 -> 5359;
5376 -> 4997;
5377 -> 4997;
5378 -> 4997;
5379 -> 4997;
5380 -> 5378;
5380 -> 4997;
5381 -> 4997;
5382 -> 4997;
5383 -> 4986;
5383 -> 5382;
5384 -> 5380;
5384 -> 5382;
5385 -> 5381;
5385 -> 5382;
5386 -> 5381;
5386 -> 5382;
5387 -> 5382;
5388 -> 5382;
5389 -> 5383;
5389 -> 5388;
5389 -> 5382;
5390 -> 5382;
5391 -> 5390;
5392 -> 5280;
5392 -> 5390;
5393 -> 5387;
5393 -> 5382;
5394 -> 5385;
5394 -> 5382;
5395 -> 5386;
5395 -> 5382;
5396 -> 5382;
5397 -> 5384;
5397 -> 5382;
5398 -> 5382;
5399 -> 5393;
5399 -> 5398;
5400 -> 5394;
5400 -> 5398;
5401 -> 5395;
5401 -> 5398;
5402 -> 5396;
5402 -> 5398;
5403 -> 5396;
5403 -> 5398;
5404 -> 5397;
5404 -> 5398;
5405 -> 5396;
5405 -> 5398;
5406 -> 5398;
5407 -> 5406;
5407 -> 5398;
5408 -> 5406;
5408 -> 5398;
5409 -> 5406;
5409 -> 5398;
5410 -> 5406;
5410 -> 5398;
5411 -> 5406;
5411 -> 5398;
5412 -> 5406;
5412 -> 5398;
5413 -> 5406;
5413 -> 5398;
5414 -> 5406;
5414 -> 5398;
5415 -> 5406;
5415 -> 5398;
5416 -> 5406;
5416 -> 5398;
5417 -> 5406;
5417 -> 5398;
5418 -> 5406;
5418 -> 5398;
5419 -> 5399;
5419 -> 5406;
5419 -> 5398;
5420 -> 5400;
5420 -> 5406;
5420 -> 5398;
5421 -> 5401;
5421 -> 5406;
5421 -> 5398;
5422 -> 5402;
5422 -> 5406;
5422 -> 5398;
5423 -> 5403;
5423 -> 5406;
5423 -> 5398;
5424 -> 5404;
5424 -> 5406;
5424 -> 5398;
5425 -> 5382;
5426 -> 5425;
5427 -> 5280;
5427 -> 5425;
5428 -> 5382;
5429 -> 5280;
5430 -> 5280;
5431 -> 5280;
5432 -> 5430;
5432 -> 5431;
5433 -> 5280;
5433 -> 5431;
5434 -> 5433;
5434 -> 5280;
5434 -> 5431;
5435 -> 5431;
5436 -> 5434;
5437 -> 5280;
5438 -> 5280;
5439 -> 5437;
5439 -> 5438;
5440 -> 5280;
5440 -> 5438;
5441 -> 5440;
5441 -> 5280;
5441 -> 5438;
5442 -> 5438;
5443 -> 5441;
5444 -> 5280;
5445 -> 5280;
5446 -> 5280;
5447 -> 5445;
5447 -> 5446;
5448 -> 5280;
5448 -> 5446;
5449 -> 5448;
5449 -> 5280;
5449 -> 5446;
5450 -> 5446;
5451 -> 5449;
5452 -> 5280;
5453 -> 5280;
5454 -> 5280;
5454 -> 5453;
5455 -> 5280;
5456 -> 5453;
5456 -> 5455;
5457 -> 5453;
5457 -> 5455;
5458 -> 5280;
5458 -> 5455;
5459 -> 5456;
5459 -> 5455;
5460 -> 5457;
5460 -> 5455;
5461 -> 5459;
5461 -> 5460;
5461 -> 5455;
5462 -> 5455;
5463 -> 5461;
5463 -> 5462;
5464 -> 5458;
5464 -> 5462;
5465 -> 5464;
5465 -> 5280;
5465 -> 5462;
5466 -> 5462;
5467 -> 5465;
5468 -> 5455;
5469 -> 5280;
5470 -> 5280;
5471 -> 5280;
5472 -> 5280;
5473 -> 5471;
5473 -> 5472;
5474 -> 5280;
5474 -> 5472;
5475 -> 5474;
5475 -> 5280;
5475 -> 5472;
5476 -> 5472;
5477 -> 5475;
5478 -> 5280;
5479 -> 5280;
5480 -> 5478;
5480 -> 5479;
5481 -> 5280;
5481 -> 5479;
5482 -> 5481;
5482 -> 5280;
5482 -> 5479;
5483 -> 5479;
5484 -> 5482;
5485 -> 5280;
5486 -> 5280;
5486 -> 5428;
5487 -> 5280;
5488 -> 5280;
5489 -> 5280;
5490 -> 5280;
5491 -> 5280;
5492 -> 5491;
5492 -> 5280;
5493 -> 5490;
5493 -> 5280;
5494 -> 5491;
5494 -> 5280;
5495 -> 0;
5495 -> 5280;
5496 -> 5280;
5497 -> 5280;
5498 -> 5280;
5499 -> 5498;
5499 -> 5495;
5499 -> 5280;
5500 -> 5499;
5500 -> 5280;
5501 -> 5280;
5502 -> 5280;
5503 -> 5497;
5503 -> 5502;
5503 -> 5280;
5504 -> 0;
5504 -> 5503;
5505 -> 5280;
5506 -> 5504;
5506 -> 0;
5506 -> 5280;
5507 -> 5500;
5507 -> 0;
5507 -> 5506;
5508 -> 5506;
5509 -> 5490;
5509 -> 5280;
5510 -> 5509;
5510 -> 5495;
5510 -> 5490;
5511 -> 5510;
5511 -> 5490;
5512 -> 5490;
5513 -> 5511;
5513 -> 0;
5513 -> 5506;
5514 -> 5490;
5515 -> 5490;
5516 -> 5490;
5517 -> 5490;
5518 -> 5516;
5518 -> 5517;
5519 -> 5280;
5519 -> 5517;
5520 -> 5519;
5520 -> 5490;
5520 -> 5517;
5521 -> 5517;
5522 -> 5520;
5523 -> 5490;
5524 -> 5490;
5525 -> 5490;
5526 -> 5524;
5526 -> 5525;
5527 -> 5280;
5527 -> 5525;
5528 -> 5527;
5528 -> 5490;
5528 -> 5525;
5529 -> 5525;
5530 -> 5528;
5531 -> 5382;
5532 -> 5396;
5532 -> 5490;
5532 -> 5531;
5532 -> 5382;
5533 -> 5387;
5533 -> 5382;
5534 -> 5382;
5535 -> 5385;
5535 -> 5534;
5535 -> 5382;
5536 -> 5535;
5537 -> 5536;
5538 -> 5537;
5539 -> 5490;
5540 -> 5490;
5541 -> 5490;
5542 -> 5378;
5542 -> 4997;
5543 -> 4997;
5544 -> 4986;
5544 -> 4997;
5545 -> 4986;
5545 -> 4997;
5546 -> 4986;
5546 -> 4997;
5547 -> 4986;
5547 -> 4997;
5548 -> 4997;
5549 -> 5547;
5549 -> 5490;
5549 -> 5548;
5549 -> 4997;
5550 -> 5544;
5550 -> 4997;
5551 -> 4997;
5552 -> 5550;
5552 -> 5551;
5553 -> 5547;
5553 -> 5551;
5554 -> 5551;
5555 -> 5553;
5555 -> 5490;
5555 -> 5554;
5555 -> 5551;
5556 -> 4997;
5557 -> 4997;
5558 -> 5557;
5559 -> 5558;
5560 -> 5559;
5561 -> 5490;
5561 -> 5559;
5562 -> 5557;
5563 -> 4997;
5564 -> 5563;
5565 -> 5490;
5565 -> 5563;
5566 -> 4997;
5567 -> 4997;
5568 -> 5567;
5569 -> 5490;
5569 -> 5567;
5570 -> 4986;
5570 -> 4997;
5571 -> 4986;
5571 -> 4997;
5572 -> 4997;
5573 -> 5571;
5573 -> 5572;
5574 -> 5573;
5574 -> 5490;
5574 -> 5572;
5575 -> 5574;
5575 -> 4997;
5576 -> 5575;
5576 -> 5490;
5576 -> 4997;
5577 -> 4997;
5578 -> 4986;
5578 -> 4997;
5579 -> 4986;
5579 -> 5490;
5579 -> 4997;
5580 -> 4997;
5581 -> 5580;
5581 -> 5579;
5581 -> 5490;
5581 -> 4997;
5582 -> 4997;
5583 -> 5490;
5584 -> 5490;
5585 -> 5584;
5585 -> 5583;
5585 -> 5490;
5586 -> 5490;
5587 -> 5490;
5587 -> 5586;
5588 -> 4986;
5588 -> 4997;
5589 -> 5588;
5589 -> 5490;
5589 -> 4997;
5590 -> 4997;
5591 -> 4997;
5592 -> 4986;
5592 -> 4997;
5593 -> 5592;
5593 -> 5490;
5593 -> 4997;
5594 -> 4997;
5595 -> 5593;
5595 -> 5594;
5596 -> 4997;
5597 -> 4986;
5597 -> 4997;
5598 -> 5597;
5598 -> 5490;
5598 -> 4997;
5599 -> 4997;
5600 -> 5598;
5600 -> 5599;
5601 -> 5599;
5602 -> 5600;
5602 -> 5599;
5603 -> 5599;
5604 -> 5602;
5604 -> 5603;
5605 -> 5603;
5606 -> 5605;
5607 -> 5605;
5608 -> 5490;
5608 -> 5605;
5609 -> 5608;
5609 -> 5603;
5610 -> 5603;
5611 -> 5490;
5611 -> 5603;
5612 -> 5611;
5613 -> 5609;
5613 -> 5612;
5613 -> 5611;
5614 -> 5613;
5615 -> 5599;
5616 -> 5601;
5616 -> 5599;
5617 -> 5601;
5617 -> 5599;
5618 -> 5601;
5618 -> 5599;
5619 -> 5601;
5619 -> 5599;
5620 -> 5601;
5620 -> 5599;
5621 -> 5601;
5621 -> 5599;
5622 -> 5601;
5622 -> 5599;
5623 -> 5601;
5623 -> 5599;
5624 -> 4997;
5625 -> 4986;
5625 -> 4997;
5626 -> 4997;
5627 -> 4997;
5628 -> 4986;
5628 -> 5490;
5628 -> 4997;
5629 -> 4997;
5630 -> 5629;
5631 -> 5630;
5632 -> 5631;
5633 -> 5490;
5633 -> 5631;
5634 -> 5629;
5635 -> 5490;
5635 -> 4997;
5636 -> 4997;
5637 -> 4986;
5637 -> 4997;
5638 -> 4997;
5639 -> 5638;
5640 -> 5639;
5641 -> 5640;
5642 -> 5490;
5642 -> 5640;
5643 -> 5638;
5644 -> 5490;
5644 -> 4997;
5645 -> 5644;
5645 -> 5637;
5645 -> 5490;
5645 -> 4997;
5646 -> 4997;
5647 -> 5646;
5647 -> 4997;
5648 -> 4997;
5649 -> 4986;
5649 -> 5490;
5650 -> 4986;
5650 -> 4997;
5651 -> 4986;
5651 -> 4997;
5652 -> 4997;
5653 -> 4997;
5654 -> 5653;
5655 -> 5654;
5656 -> 5490;
5656 -> 5654;
5657 -> 5653;
5658 -> 5653;
5659 -> 4997;
5660 -> 4997;
5661 -> 4986;
5661 -> 4997;
5662 -> 4986;
5662 -> 4997;
5663 -> 4997;
5664 -> 5662;
5664 -> 5663;
5664 -> 4997;
5665 -> 5661;
5665 -> 5490;
5666 -> 5662;
5666 -> 5490;
5667 -> 5665;
5667 -> 5490;
5668 -> 5666;
5668 -> 5490;
5669 -> 5490;
5670 -> 5490;
5671 -> 5490;
5672 -> 5668;
5672 -> 5671;
5672 -> 5490;
5673 -> 5490;
5674 -> 5490;
5674 -> 5673;
5675 -> 5490;
5675 -> 0;
5676 -> 5490;
5677 -> 5670;
5677 -> 5676;
5678 -> 5677;
5679 -> 5677;
5680 -> 5490;
5680 -> 5677;
5681 -> 5677;
5682 -> 5680;
5682 -> 5681;
5683 -> 5681;
5684 -> 5682;
5684 -> 5683;
5685 -> 5683;
5686 -> 5684;
5686 -> 5685;
5686 -> 5683;
5687 -> 5683;
5688 -> 5687;
5688 -> 5681;
5689 -> 5490;
5689 -> 5688;
5690 -> 5490;
5691 -> 4986;
5691 -> 4997;
5692 -> 4986;
5692 -> 5490;
5692 -> 4997;
5693 -> 4986;
5693 -> 4997;
5694 -> 4997;
5695 -> 4986;
5695 -> 5694;
5695 -> 4997;
5696 -> 4997;
5697 -> 5696;
5697 -> 4997;
5698 -> 4997;
5699 -> 5691;
5699 -> 5698;
5700 -> 5698;
5701 -> 5490;
5702 -> 5490;
5703 -> 5699;
5703 -> 5490;
5704 -> 5490;
5705 -> 5703;
5705 -> 5490;
5706 -> 4986;
5706 -> 5490;
5707 -> 5706;
5707 -> 5490;
5708 -> 5490;
5709 -> 5704;
5709 -> 5708;
5710 -> 5709;
5710 -> 5490;
5711 -> 5707;
5711 -> 5490;
5712 -> 5706;
5712 -> 5490;
5712 -> 0;
5713 -> 5710;
5713 -> 5490;
5714 -> 5712;
5714 -> 5713;
5714 -> 5490;
5715 -> 5490;
5716 -> 5706;
5716 -> 5490;
5716 -> 5715;
5717 -> 4986;
5717 -> 4997;
5718 -> 4986;
5718 -> 5490;
5718 -> 4997;
5719 -> 5490;
5720 -> 5490;
5720 -> 5719;
5721 -> 5719;
5722 -> 5721;
5722 -> 5720;
5722 -> 5490;
5722 -> 5719;
5723 -> 5490;
5724 -> 5490;
5725 -> 5490;
5726 -> 5490;
5726 -> 5725;
5727 -> 5490;
5727 -> 5725;
5728 -> 5724;
5728 -> 5725;
5729 -> 5725;
5730 -> 5727;
5730 -> 5729;
5730 -> 5725;
5731 -> 5490;
5732 -> 5490;
5732 -> 5731;
5733 -> 5490;
5733 -> 5731;
5734 -> 5724;
5734 -> 5731;
5735 -> 5731;
5736 -> 5733;
5736 -> 5735;
5736 -> 5731;
5737 -> 5490;
5738 -> 5490;
5739 -> 4986;
5739 -> 4997;
5740 -> 4986;
5740 -> 4997;
5741 -> 4986;
5741 -> 4997;
5742 -> 5741;
5742 -> 5490;
5742 -> 4997;
5743 -> 5742;
5743 -> 5490;
5743 -> 4997;
5744 -> 4997;
5745 -> 5744;
5745 -> 5743;
5745 -> 4997;
5746 -> 4986;
5746 -> 4997;
5747 -> 0;
5747 -> 4997;
5748 -> 4986;
5748 -> 4997;
5749 -> 4997;
5750 -> 4986;
5750 -> 0;
5750 -> 5490;
5751 -> 4997;
5752 -> 4997;
5753 -> 4997;
5754 -> 4997;
5755 -> 4986;
5755 -> 5490;
5756 -> 5490;
5757 -> 5755;
5757 -> 5490;
5757 -> 5756;
5758 -> 5490;
5759 -> 5490;
5760 -> 5490;
5761 -> 5490;
5762 -> 5490;
5763 -> 5490;
5764 -> 5763;
5764 -> 5490;
5764 -> 5756;
5765 -> 5762;
5765 -> 5490;
5766 -> 5762;
5766 -> 5490;
5767 -> 5762;
5767 -> 5761;
5767 -> 5490;
5768 -> 5751;
5768 -> 4997;
5769 -> 5762;
5769 -> 5567;
5770 -> 4988;
5770 -> 4985;
5771 -> 4985;
5772 -> 5770;
5772 -> 5771;
5773 -> 5772;
5773 -> 5771;
5774 -> 5771;
5775 -> 5773;
5775 -> 5774;
5776 -> 5775;
5776 -> 5774;
5777 -> 5774;
5778 -> 5774;
5779 -> 5776;
5779 -> 5778;
5780 -> 5777;
5780 -> 5778;
5781 -> 5778;
5782 -> 5779;
5782 -> 5781;
5782 -> 5778;
5783 -> 5779;
5783 -> 5778;
5784 -> 5779;
5784 -> 5778;
5785 -> 5780;
5785 -> 5783;
5785 -> 5784;
5785 -> 5778;
5786 -> 5779;
5786 -> 5778;
5787 -> 5778;
5788 -> 5762;
5788 -> 5787;
5788 -> 5778;
5789 -> 5778;
5790 -> 5779;
5790 -> 5778;
5791 -> 5778;
5792 -> 5790;
5792 -> 5791;
5793 -> 5791;
5794 -> 5791;
5795 -> 5762;
5795 -> 5791;
5796 -> 5795;
5796 -> 5791;
5797 -> 5794;
5797 -> 5796;
5798 -> 5797;
5798 -> 5793;
5798 -> 5791;
5799 -> 5797;
5799 -> 5793;
5799 -> 5791;
5800 -> 5799;
5800 -> 5791;
5801 -> 5792;
5801 -> 5791;
5802 -> 5792;
5802 -> 5791;
5803 -> 5792;
5803 -> 5791;
5804 -> 5791;
5805 -> 5803;
5805 -> 5804;
5806 -> 2395;
5806 -> 5804;
5807 -> 5804;
5808 -> 5805;
5808 -> 5804;
5809 -> 5804;
5810 -> 5809;
5810 -> 5791;
5811 -> 5810;
5812 -> 5811;
5813 -> 2395;
5813 -> 5811;
5814 -> 5791;
5815 -> 5814;
5815 -> 5791;
5816 -> 5791;
5817 -> 5791;
5818 -> 5814;
5818 -> 5817;
5818 -> 5815;
5818 -> 5791;
5819 -> 5791;
5820 -> 5792;
5820 -> 5791;
5821 -> 5814;
5821 -> 5791;
5822 -> 5819;
5822 -> 5791;
5823 -> 5791;
5824 -> 5821;
5824 -> 5823;
5825 -> 5822;
5825 -> 5823;
5826 -> 5825;
5826 -> 5819;
5826 -> 5823;
5827 -> 5823;
5828 -> 5827;
5828 -> 5826;
5828 -> 5823;
5829 -> 5791;
5830 -> 5791;
5831 -> 5814;
5831 -> 5830;
5831 -> 5818;
5831 -> 5791;
5832 -> 5791;
5833 -> 5791;
5834 -> 5791;
5835 -> 5833;
5835 -> 5834;
5835 -> 5791;
5836 -> 5791;
5837 -> 5814;
5837 -> 5836;
5837 -> 5831;
5837 -> 5791;
5838 -> 5819;
5838 -> 5791;
5839 -> 5832;
5839 -> 5791;
5840 -> 0;
5840 -> 5791;
5841 -> 5791;
5842 -> 5791;
5843 -> 5838;
5843 -> 5842;
5844 -> 5839;
5844 -> 5842;
5845 -> 5840;
5845 -> 5842;
5846 -> 5841;
5846 -> 5842;
5847 -> 5841;
5847 -> 5842;
5848 -> 5842;
5849 -> 5846;
5849 -> 5848;
5849 -> 5842;
5850 -> 5849;
5850 -> 5842;
5851 -> 4698;
5851 -> 5850;
5852 -> 5842;
5853 -> 5852;
5853 -> 5847;
5853 -> 5842;
5854 -> 5843;
5854 -> 5842;
5855 -> 5844;
5855 -> 5842;
5856 -> 5845;
5856 -> 5842;
5857 -> 5854;
5857 -> 5842;
5858 -> 5855;
5858 -> 5842;
5859 -> 5853;
5859 -> 5842;
5860 -> 5842;
5861 -> 5857;
5861 -> 5860;
5862 -> 5858;
5862 -> 5860;
5863 -> 5859;
5863 -> 5860;
5864 -> 5851;
5864 -> 5860;
5865 -> 5861;
5865 -> 5860;
5866 -> 5861;
5866 -> 5854;
5866 -> 5860;
5867 -> 5862;
5867 -> 5860;
5868 -> 5862;
5868 -> 5855;
5868 -> 5860;
5869 -> 5860;
5870 -> 5865;
5870 -> 5869;
5871 -> 5866;
5871 -> 5869;
5872 -> 5867;
5872 -> 5869;
5873 -> 5868;
5873 -> 5869;
5874 -> 5864;
5874 -> 5869;
5875 -> 5870;
5875 -> 5869;
5876 -> 5871;
5876 -> 5869;
5877 -> 5872;
5877 -> 5869;
5878 -> 5873;
5878 -> 5869;
5879 -> 5869;
5880 -> 5875;
5880 -> 5879;
5881 -> 5876;
5881 -> 5879;
5882 -> 5877;
5882 -> 5879;
5883 -> 5878;
5883 -> 5879;
5884 -> 5874;
5884 -> 5879;
5885 -> 5879;
5886 -> 5881;
5886 -> 5885;
5886 -> 5879;
5887 -> 5879;
5888 -> 5883;
5888 -> 5887;
5888 -> 5879;
5889 -> 5886;
5889 -> 5888;
5889 -> 5879;
5890 -> 5879;
5891 -> 5890;
5891 -> 5889;
5891 -> 5879;
5892 -> 5879;
5893 -> 5892;
5893 -> 5881;
5893 -> 5879;
5894 -> 5879;
5895 -> 5894;
5895 -> 5883;
5895 -> 5879;
5896 -> 5879;
5897 -> 5896;
5897 -> 5881;
5897 -> 5879;
5898 -> 5889;
5898 -> 5879;
5899 -> 5871;
5899 -> 5869;
5900 -> 5873;
5900 -> 5869;
5901 -> 5869;
5902 -> 5899;
5902 -> 5901;
5902 -> 5869;
5903 -> 5869;
5904 -> 5899;
5904 -> 5903;
5904 -> 5869;
5905 -> 5869;
5906 -> 5900;
5906 -> 5905;
5906 -> 5869;
5907 -> 5869;
5908 -> 5907;
5908 -> 5860;
5909 -> 5860;
5910 -> 5909;
5910 -> 5842;
5911 -> 5856;
5911 -> 5910;
5911 -> 5842;
5912 -> 5814;
5912 -> 5911;
5912 -> 5837;
5912 -> 5791;
5913 -> 5832;
5913 -> 5791;
5914 -> 5819;
5914 -> 5791;
5915 -> 5814;
5915 -> 5912;
5915 -> 5791;
5916 -> 5915;
5916 -> 5778;
5917 -> 5771;
5918 -> 4986;
5918 -> 4985;
5919 -> 3213;
5919 -> 1;
5920 -> 1;
5921 -> 2535;
5921 -> 5920;
5921 -> 1;
5922 -> 0;
5922 -> 1;
5923 -> 5919;
5923 -> 5920;
5923 -> 5922;
5923 -> 5921;
5923 -> 5762;
5923 -> 1;
5924 -> 5920;
5925 -> 5924;
5926 -> 5923;
5926 -> 5920;
5927 -> 5923;
5927 -> 5920;
5928 -> 5926;
5928 -> 5920;
5929 -> 5920;
5930 -> 5929;
5930 -> 5920;
5931 -> 5920;
5932 -> 5928;
5932 -> 5931;
5933 -> 5930;
5933 -> 5931;
5934 -> 5931;
5935 -> 5923;
5936 -> 5923;
5937 -> 5935;
5937 -> 5923;
5938 -> 5923;
5939 -> 5936;
5939 -> 5923;
5939 -> 5937;
5939 -> 5938;
5939 -> 5935;
5940 -> 5923;
5941 -> 5940;
5941 -> 5935;
5941 -> 5923;
5942 -> 5935;
5942 -> 5923;
5943 -> 5923;
5944 -> 5942;
5944 -> 5943;
5944 -> 5935;
5944 -> 5941;
5944 -> 5923;
5945 -> 5931;
5946 -> 5923;
5946 -> 5945;
5946 -> 5931;
5947 -> 0;
5947 -> 5931;
5948 -> 5933;
5948 -> 5931;
5949 -> 5923;
5949 -> 5931;
5950 -> 5931;
5951 -> 5949;
5951 -> 5950;
5952 -> 0;
5952 -> 5950;
5953 -> 5952;
5954 -> 5931;
5955 -> 5931;
5956 -> 5955;
5957 -> 5955;
5958 -> 5955;
5959 -> 5957;
5959 -> 5958;
5960 -> 5957;
5960 -> 5958;
5961 -> 5957;
5961 -> 5958;
5962 -> 5957;
5962 -> 5958;
5963 -> 5958;
5964 -> 5923;
5964 -> 5963;
5964 -> 5958;
5965 -> 5962;
5965 -> 5958;
5966 -> 5959;
5966 -> 5958;
5967 -> 5960;
5967 -> 5958;
5968 -> 5961;
5968 -> 5958;
5969 -> 5962;
5969 -> 5958;
5970 -> 5958;
5971 -> 0;
5971 -> 5958;
5972 -> 5958;
5973 -> 5971;
5973 -> 5972;
5974 -> 5971;
5974 -> 5972;
5975 -> 5969;
5975 -> 5972;
5976 -> 5970;
5976 -> 5972;
5977 -> 5970;
5977 -> 5972;
5978 -> 5973;
5978 -> 5972;
5979 -> 5974;
5979 -> 5972;
5980 -> 5975;
5980 -> 5972;
5981 -> 5972;
5982 -> 5981;
5982 -> 5972;
5983 -> 5976;
5983 -> 5981;
5983 -> 5972;
5984 -> 5958;
5985 -> 5966;
5985 -> 5984;
5986 -> 5967;
5986 -> 5984;
5987 -> 5968;
5987 -> 5984;
5988 -> 5969;
5988 -> 5984;
5989 -> 5970;
5989 -> 5984;
5990 -> 5970;
5990 -> 5984;
5991 -> 5970;
5991 -> 5984;
5992 -> 5970;
5992 -> 5984;
5993 -> 5970;
5993 -> 5984;
5994 -> 5970;
5994 -> 5984;
5995 -> 5985;
5995 -> 5984;
5996 -> 5986;
5996 -> 5984;
5997 -> 5987;
5997 -> 5984;
5998 -> 5988;
5998 -> 5984;
5999 -> 5989;
5999 -> 5984;
6000 -> 5990;
6000 -> 5984;
6001 -> 5991;
6001 -> 5984;
6002 -> 5992;
6002 -> 5984;
6003 -> 5993;
6003 -> 5984;
6004 -> 5984;
6005 -> 5995;
6005 -> 6004;
6006 -> 5996;
6006 -> 6004;
6007 -> 5997;
6007 -> 6004;
6008 -> 5998;
6008 -> 6004;
6009 -> 5999;
6009 -> 6004;
6010 -> 6000;
6010 -> 6004;
6011 -> 6001;
6011 -> 6004;
6012 -> 6002;
6012 -> 6004;
6013 -> 6003;
6013 -> 6004;
6014 -> 5994;
6014 -> 6004;
6015 -> 6008;
6015 -> 6004;
6016 -> 6012;
6016 -> 6004;
6017 -> 6013;
6017 -> 6004;
6018 -> 6004;
6019 -> 6018;
6019 -> 6004;
6020 -> 6018;
6020 -> 6004;
6021 -> 6018;
6021 -> 6004;
6022 -> 6018;
6022 -> 6004;
6023 -> 6018;
6023 -> 6004;
6024 -> 6018;
6024 -> 6004;
6025 -> 6018;
6025 -> 6004;
6026 -> 6018;
6026 -> 6004;
6027 -> 6018;
6027 -> 6004;
6028 -> 6018;
6028 -> 6004;
6029 -> 6018;
6029 -> 6004;
6030 -> 6018;
6030 -> 6004;
6031 -> 6018;
6031 -> 6004;
6032 -> 6018;
6032 -> 6004;
6033 -> 6018;
6033 -> 6004;
6034 -> 6018;
6034 -> 6004;
6035 -> 6018;
6035 -> 6004;
6036 -> 6018;
6036 -> 6004;
6037 -> 6018;
6037 -> 6004;
6038 -> 6018;
6038 -> 6004;
6039 -> 6018;
6039 -> 6004;
6040 -> 6018;
6040 -> 6004;
6041 -> 6018;
6041 -> 6004;
6042 -> 6018;
6042 -> 6004;
6043 -> 6018;
6043 -> 6004;
6044 -> 6018;
6044 -> 6004;
6045 -> 6004;
6046 -> 6045;
6046 -> 6018;
6046 -> 6004;
6047 -> 6018;
6047 -> 6004;
6048 -> 6018;
6048 -> 6004;
6049 -> 6004;
6050 -> 6004;
6051 -> 6048;
6051 -> 6050;
6052 -> 6049;
6052 -> 6050;
6053 -> 6052;
6053 -> 6050;
6054 -> 6052;
6054 -> 6050;
6055 -> 6052;
6055 -> 6050;
6056 -> 6051;
6056 -> 6052;
6056 -> 6050;
6057 -> 6049;
6057 -> 6018;
6057 -> 6004;
6058 -> 6018;
6058 -> 6004;
6059 -> 6004;
6060 -> 6059;
6061 -> 0;
6061 -> 6059;
6062 -> 6061;
6062 -> 6060;
6062 -> 6059;
6063 -> 6062;
6063 -> 6004;
6064 -> 6063;
6064 -> 6018;
6064 -> 6004;
6065 -> 6008;
6065 -> 6004;
6066 -> 6065;
6067 -> 6005;
6067 -> 6066;
6067 -> 6065;
6068 -> 6006;
6068 -> 6066;
6068 -> 6065;
6069 -> 6067;
6069 -> 6068;
6069 -> 6065;
6070 -> 6007;
6070 -> 6066;
6070 -> 6065;
6071 -> 6069;
6071 -> 6070;
6071 -> 6065;
6072 -> 6010;
6072 -> 6004;
6073 -> 6072;
6074 -> 6018;
6074 -> 6073;
6075 -> 6009;
6075 -> 6072;
6076 -> 6011;
6076 -> 6018;
6076 -> 6004;
6077 -> 6018;
6077 -> 5923;
6077 -> 6004;
6078 -> 6004;
6079 -> 6018;
6079 -> 5923;
6079 -> 6078;
6079 -> 6004;
6080 -> 5958;
6081 -> 5923;
6082 -> 5923;
6083 -> 5923;
6084 -> 5923;
6085 -> 5923;
6086 -> 6082;
6086 -> 5923;
6087 -> 5923;
6088 -> 5923;
6089 -> 5923;
6090 -> 5923;
6091 -> 5923;
6092 -> 5923;
6093 -> 5923;
6094 -> 5923;
6095 -> 6092;
6095 -> 5923;
6096 -> 6093;
6096 -> 5923;
6097 -> 6094;
6097 -> 5923;
6098 -> 6095;
6098 -> 5923;
6099 -> 6096;
6099 -> 5923;
6100 -> 6097;
6100 -> 5923;
6101 -> 5923;
6102 -> 5923;
6103 -> 6102;
6104 -> 6098;
6104 -> 6103;
6104 -> 6102;
6105 -> 6099;
6105 -> 6103;
6105 -> 6102;
6106 -> 6104;
6106 -> 6105;
6106 -> 6102;
6107 -> 6100;
6107 -> 6103;
6107 -> 6102;
6108 -> 6106;
6108 -> 6107;
6108 -> 6102;
6109 -> 5923;
6110 -> 5923;
6111 -> 5923;
6112 -> 5923;
6112 -> 5958;
6113 -> 5931;
6114 -> 6113;
6115 -> 6114;
6116 -> 6115;
6117 -> 5923;
6118 -> 5923;
6119 -> 5923;
6120 -> 5923;
6121 -> 5923;
6122 -> 6121;
6122 -> 0;
6122 -> 5923;
6123 -> 5923;
6124 -> 5923;
6125 -> 5923;
6126 -> 5923;
6127 -> 5923;
6128 -> 5923;
6128 -> 6113;
6129 -> 6113;
6130 -> 0;
6130 -> 6113;
6131 -> 5923;
6131 -> 1;
6132 -> 11;
6132 -> 1;
6133 -> 1;
6134 -> 1;
6135 -> 6131;
6135 -> 6134;
6136 -> 6132;
6136 -> 6134;
6137 -> 6133;
6137 -> 6134;
6138 -> 6136;
6138 -> 6134;
6139 -> 6134;
6140 -> 6134;
6141 -> 6138;
6141 -> 6140;
6142 -> 6139;
6142 -> 6140;
6143 -> 6140;
6144 -> 0;
6144 -> 6143;
6145 -> 6144;
6145 -> 6140;
6146 -> 6140;
6147 -> 6145;
6147 -> 6140;
6148 -> 6141;
6148 -> 6140;
6149 -> 6142;
6149 -> 6140;
6150 -> 6135;
6150 -> 6146;
6151 -> 6135;
6151 -> 6146;
6152 -> 6135;
6152 -> 6146;
6153 -> 6135;
6153 -> 6146;
6154 -> 6135;
6154 -> 6146;
6155 -> 6146;
6156 -> 6155;
6157 -> 6156;
6158 -> 6157;
6159 -> 6158;
6160 -> 6135;
6161 -> 6135;
6162 -> 6135;
6162 -> 6158;
6163 -> 6135;
6163 -> 6156;
6164 -> 6163;
6164 -> 6156;
6165 -> 6155;
6166 -> 6146;
6167 -> 6135;
6167 -> 6166;
6167 -> 6146;
6168 -> 6146;
6169 -> 6168;
6170 -> 6169;
6171 -> 6135;
6171 -> 6169;
6172 -> 6168;
6173 -> 6172;
6174 -> 6173;
6175 -> 6174;
6176 -> 6172;
6177 -> 6176;
6178 -> 6177;
6179 -> 6135;
6179 -> 6168;
6180 -> 6168;
6181 -> 6146;
6182 -> 6146;
6183 -> 6135;
6184 -> 6183;
6185 -> 6183;
6185 -> 6135;
6186 -> 6135;
6187 -> 6135;
6188 -> 6185;
6188 -> 6187;
6189 -> 6186;
6189 -> 6187;
6190 -> 6186;
6190 -> 6187;
6191 -> 6186;
6191 -> 6187;
6192 -> 6186;
6192 -> 6187;
6193 -> 6188;
6193 -> 6187;
6194 -> 6189;
6194 -> 6187;
6195 -> 0;
6195 -> 6187;
6196 -> 6190;
6196 -> 6187;
6197 -> 6191;
6197 -> 6187;
6198 -> 6187;
6199 -> 6193;
6199 -> 6198;
6200 -> 6194;
6200 -> 6198;
6201 -> 6195;
6201 -> 6198;
6202 -> 6196;
6202 -> 6198;
6203 -> 6197;
6203 -> 6198;
6204 -> 6198;
6204 -> 6199;
6204 -> 6202;
6204 -> 6203;
6204 -> 6201;
6204 -> 6200;
6204 -> 6183;
6204 -> 6135;
6205 -> 6204;
6205 -> 6198;
6206 -> 6199;
6206 -> 6204;
6206 -> 6198;
6207 -> 6146;
6208 -> 6150;
6208 -> 6207;
6208 -> 6146;
6209 -> 6146;
6210 -> 6151;
6210 -> 6209;
6210 -> 6146;
6211 -> 6146;
6212 -> 6152;
6212 -> 6211;
6212 -> 6146;
6213 -> 6146;
6214 -> 6135;
6214 -> 6146;
6215 -> 0;
6215 -> 6146;
6216 -> 6146;
6217 -> 6146;
6218 -> 6215;
6218 -> 6217;
6219 -> 6216;
6219 -> 6217;
6220 -> 6217;
6221 -> 6218;
6221 -> 6217;
6222 -> 6219;
6222 -> 6217;
6223 -> 6220;
6223 -> 6217;
6224 -> 6217;
6225 -> 6221;
6225 -> 6224;
6226 -> 6222;
6226 -> 6224;
6227 -> 6223;
6227 -> 6224;
6228 -> 6224;
6229 -> 6225;
6229 -> 0;
6229 -> 6224;
6230 -> 6229;
6230 -> 6226;
6230 -> 6224;
6231 -> 6230;
6232 -> 6231;
6233 -> 6232;
6234 -> 6230;
6235 -> 6204;
6236 -> 6204;
6237 -> 6230;
6238 -> 6204;
6239 -> 6225;
6239 -> 0;
6239 -> 6224;
6240 -> 6228;
6240 -> 6239;
6241 -> 6239;
6242 -> 6239;
6243 -> 6239;
6244 -> 6135;
6244 -> 6243;
6245 -> 6244;
6245 -> 6204;
6245 -> 6243;
6246 -> 6245;
6246 -> 6239;
6247 -> 6239;
6248 -> 6239;
6249 -> 6239;
6250 -> 6248;
6250 -> 6249;
6251 -> 6248;
6251 -> 6249;
6252 -> 6248;
6252 -> 6249;
6253 -> 6249;
6254 -> 6253;
6255 -> 6254;
6256 -> 6249;
6257 -> 6249;
6258 -> 6250;
6258 -> 6257;
6258 -> 6249;
6259 -> 6249;
6260 -> 6259;
6261 -> 6260;
6262 -> 6204;
6262 -> 6260;
6263 -> 6256;
6263 -> 6249;
6264 -> 6249;
6265 -> 6264;
6266 -> 6265;
6267 -> 6266;
6268 -> 6264;
6269 -> 6268;
6270 -> 6269;
6271 -> 6204;
6271 -> 6264;
6272 -> 6264;
6273 -> 6204;
6273 -> 6264;
6274 -> 6204;
6274 -> 6264;
6275 -> 6274;
6275 -> 6204;
6275 -> 6264;
6276 -> 6264;
6277 -> 6264;
6278 -> 6276;
6278 -> 6277;
6279 -> 6278;
6279 -> 6277;
6280 -> 6277;
6281 -> 6277;
6282 -> 6280;
6282 -> 6281;
6283 -> 6282;
6283 -> 6281;
6284 -> 6281;
6285 -> 6284;
6286 -> 6285;
6287 -> 6285;
6288 -> 6287;
6289 -> 6284;
6290 -> 6289;
6291 -> 6281;
6292 -> 6281;
6293 -> 6281;
6294 -> 6282;
6294 -> 6281;
6295 -> 6281;
6296 -> 6294;
6296 -> 6295;
6297 -> 6296;
6297 -> 6295;
6298 -> 6295;
6299 -> 6295;
6300 -> 6299;
6301 -> 6299;
6302 -> 6204;
6303 -> 6276;
6304 -> 6303;
6305 -> 6304;
6306 -> 6204;
6306 -> 6304;
6307 -> 6276;
6308 -> 6264;
6309 -> 6308;
6310 -> 6309;
6311 -> 6308;
6312 -> 6308;
6313 -> 6204;
6313 -> 6264;
6314 -> 6313;
6314 -> 6264;
6315 -> 6264;
6316 -> 6264;
6317 -> 6315;
6317 -> 6316;
6318 -> 6317;
6318 -> 6316;
6319 -> 6316;
6320 -> 6319;
6321 -> 6320;
6322 -> 6320;
6323 -> 6322;
6324 -> 6319;
6325 -> 6324;
6326 -> 6316;
6327 -> 6316;
6328 -> 6316;
6329 -> 6327;
6329 -> 6316;
6330 -> 6264;
6331 -> 6330;
6332 -> 6331;
6333 -> 6264;
6334 -> 6204;
6334 -> 0;
6334 -> 6264;
6335 -> 6264;
6336 -> 6204;
6336 -> 6264;
6337 -> 6264;
6338 -> 6337;
6339 -> 6338;
6340 -> 6204;
6340 -> 6338;
6341 -> 6264;
6342 -> 6204;
6342 -> 6264;
6343 -> 6264;
6344 -> 6343;
6345 -> 6344;
6346 -> 6345;
6347 -> 6204;
6347 -> 6345;
6348 -> 6343;
6349 -> 6204;
6349 -> 6264;
6350 -> 6264;
6351 -> 6250;
6351 -> 6249;
6352 -> 6351;
6353 -> 6351;
6354 -> 6249;
6355 -> 6252;
6355 -> 6354;
6355 -> 6249;
6356 -> 6250;
6356 -> 6249;
6357 -> 6251;
6357 -> 6249;
6358 -> 6249;
6359 -> 6356;
6359 -> 6358;
6360 -> 6357;
6360 -> 6358;
6361 -> 6358;
6362 -> 6359;
6362 -> 6361;
6362 -> 6358;
6363 -> 6204;
6364 -> 6204;
6365 -> 6204;
6365 -> 0;
6366 -> 6204;
6367 -> 6204;
6367 -> 0;
6368 -> 6204;
6368 -> 0;
6369 -> 6204;
6369 -> 0;
6370 -> 6204;
6370 -> 0;
6371 -> 6204;
6371 -> 0;
6372 -> 6204;
6372 -> 0;
6373 -> 6204;
6374 -> 6204;
6375 -> 6204;
6376 -> 6204;
6376 -> 0;
6377 -> 6204;
6378 -> 6204;
6379 -> 6377;
6379 -> 6378;
6380 -> 6379;
6380 -> 6378;
6381 -> 6380;
6382 -> 6204;
6383 -> 6382;
6383 -> 6204;
6384 -> 6204;
6385 -> 6384;
6385 -> 6204;
6386 -> 6375;
6386 -> 6385;
6387 -> 6204;
6388 -> 6386;
6388 -> 6387;
6388 -> 6204;
6389 -> 6388;
6389 -> 6382;
6389 -> 6204;
6390 -> 6382;
6390 -> 6204;
6391 -> 6381;
6391 -> 6390;
6392 -> 6381;
6392 -> 6204;
6393 -> 6204;
6393 -> 0;
6394 -> 6204;
6395 -> 6204;
6396 -> 6204;
6397 -> 6395;
6397 -> 6396;
6398 -> 6397;
6398 -> 6396;
6399 -> 6398;
6400 -> 6204;
6401 -> 6399;
6401 -> 6400;
6402 -> 6204;
6403 -> 6204;
6404 -> 6402;
6404 -> 6403;
6405 -> 6204;
6405 -> 6403;
6406 -> 6404;
6406 -> 6204;
6406 -> 0;
6406 -> 6403;
6407 -> 6406;
6408 -> 6204;
6409 -> 6395;
6409 -> 6408;
6410 -> 6409;
6410 -> 6408;
6411 -> 6410;
6412 -> 6204;
6413 -> 6204;
6414 -> 6204;
6415 -> 6135;
6415 -> 6204;
6415 -> 6358;
6416 -> 6239;
6417 -> 6135;
6417 -> 6204;
6417 -> 6416;
6417 -> 6239;
6418 -> 6225;
6418 -> 0;
6418 -> 6224;
6419 -> 6227;
6419 -> 6224;
6420 -> 6228;
6420 -> 6224;
6421 -> 6224;
6422 -> 6217;
6423 -> 6213;
6423 -> 6146;
6424 -> 6213;
6424 -> 6146;
6425 -> 6204;
6425 -> 6135;
6426 -> 6204;
6426 -> 6135;
6427 -> 6204;
6427 -> 6135;
6428 -> 6204;
6428 -> 6135;
6429 -> 6135;
6430 -> 6135;
6431 -> 6135;
6432 -> 6431;
6432 -> 6204;
6433 -> 6432;
6433 -> 6135;
6434 -> 6135;
6435 -> 6135;
6436 -> 6135;
6437 -> 6204;
6437 -> 6135;
6438 -> 6135;
6439 -> 6204;
6440 -> 6204;
6440 -> 6135;
6441 -> 6135;
6442 -> 6135;
6443 -> 6204;
6443 -> 6135;
6444 -> 6135;
6445 -> 6443;
6445 -> 6444;
6446 -> 6135;
6446 -> 6444;
6447 -> 6445;
6447 -> 6444;
6448 -> 6135;
6449 -> 6204;
6449 -> 6183;
6450 -> 6204;
6451 -> 6204;
6452 -> 6204;
6453 -> 6451;
6453 -> 6452;
6454 -> 6451;
6454 -> 6452;
6455 -> 6452;
6456 -> 6453;
6456 -> 6455;
6456 -> 6452;
6457 -> 6204;
6458 -> 6204;
6459 -> 6135;
6460 -> 6204;
6460 -> 6459;
6460 -> 6135;
6461 -> 6135;
6462 -> 6135;
6463 -> 6135;
6463 -> 6462;
6463 -> 6204;
6464 -> 6463;
6464 -> 6135;
6465 -> 6135;
6466 -> 6135;
6467 -> 6464;
6467 -> 6466;
6468 -> 6465;
6468 -> 6466;
6469 -> 6135;
6469 -> 6466;
6470 -> 6467;
6470 -> 6466;
6471 -> 6135;
6472 -> 6135;
6472 -> 6471;
6472 -> 6463;
6473 -> 6472;
6473 -> 6135;
6474 -> 6135;
6475 -> 6135;
6476 -> 6473;
6476 -> 6475;
6477 -> 6474;
6477 -> 6475;
6478 -> 6135;
6478 -> 6475;
6479 -> 6476;
6479 -> 6475;
6480 -> 6472;
6480 -> 6135;
6481 -> 6472;
6481 -> 6135;
6482 -> 6481;
6482 -> 6472;
6482 -> 6135;
6483 -> 6472;
6483 -> 6135;
6484 -> 6482;
6484 -> 6459;
6484 -> 6135;
6485 -> 6135;
6486 -> 6135;
6486 -> 6482;
6487 -> 6135;
6488 -> 6486;
6488 -> 6487;
6488 -> 6135;
6489 -> 6135;
6490 -> 6135;
6490 -> 6482;
6491 -> 6482;
6491 -> 6183;
6492 -> 6135;
6493 -> 6204;
6493 -> 6492;
6493 -> 6135;
6494 -> 6135;
6494 -> 6482;
6495 -> 6482;
6496 -> 6494;
6496 -> 6495;
6497 -> 6494;
6497 -> 6495;
6498 -> 6135;
6498 -> 6495;
6499 -> 6498;
6499 -> 6482;
6499 -> 6495;
6500 -> 6498;
6500 -> 6482;
6500 -> 6495;
6501 -> 6482;
6502 -> 6204;
6502 -> 6482;
6502 -> 6135;
6503 -> 6146;
6504 -> 6146;
6505 -> 6504;
6505 -> 6146;
6506 -> 6146;
6507 -> 6506;
6508 -> 6482;
6508 -> 6506;
6509 -> 6146;
6510 -> 6504;
6510 -> 6146;
6511 -> 6146;
6512 -> 6510;
6512 -> 6511;
6513 -> 6511;
6514 -> 6513;
6515 -> 6482;
6515 -> 6513;
6516 -> 6482;
6516 -> 6511;
6517 -> 6511;
6518 -> 6517;
6518 -> 6516;
6518 -> 6482;
6518 -> 6511;
6519 -> 6511;
6520 -> 6519;
6520 -> 6146;
6521 -> 6504;
6521 -> 6146;
6522 -> 6146;
6523 -> 6146;
6524 -> 6146;
6525 -> 6523;
6525 -> 6146;
6526 -> 6146;
6527 -> 6146;
6528 -> 6135;
6528 -> 6527;
6529 -> 6525;
6529 -> 6527;
6530 -> 6526;
6530 -> 6527;
6531 -> 6526;
6531 -> 6527;
6532 -> 6527;
6533 -> 6527;
6534 -> 6528;
6534 -> 6533;
6534 -> 6527;
6535 -> 6527;
6536 -> 6535;
6537 -> 6482;
6537 -> 6535;
6538 -> 6532;
6538 -> 6527;
6539 -> 6530;
6539 -> 6527;
6540 -> 6531;
6540 -> 6527;
6541 -> 6527;
6542 -> 6529;
6542 -> 6527;
6543 -> 6527;
6544 -> 6538;
6544 -> 6543;
6545 -> 6539;
6545 -> 6543;
6546 -> 6540;
6546 -> 6543;
6547 -> 6541;
6547 -> 6543;
6548 -> 6541;
6548 -> 6543;
6549 -> 6542;
6549 -> 6543;
6550 -> 6541;
6550 -> 6543;
6551 -> 6543;
6552 -> 6551;
6552 -> 6543;
6553 -> 6551;
6553 -> 6543;
6554 -> 6551;
6554 -> 6543;
6555 -> 6551;
6555 -> 6543;
6556 -> 6551;
6556 -> 6543;
6557 -> 6551;
6557 -> 6543;
6558 -> 6551;
6558 -> 6543;
6559 -> 6551;
6559 -> 6543;
6560 -> 6551;
6560 -> 6543;
6561 -> 6551;
6561 -> 6543;
6562 -> 6551;
6562 -> 6543;
6563 -> 6551;
6563 -> 6543;
6564 -> 6544;
6564 -> 6551;
6564 -> 6543;
6565 -> 6545;
6565 -> 6551;
6565 -> 6543;
6566 -> 6546;
6566 -> 6551;
6566 -> 6543;
6567 -> 6547;
6567 -> 6551;
6567 -> 6543;
6568 -> 6548;
6568 -> 6551;
6568 -> 6543;
6569 -> 6549;
6569 -> 6551;
6569 -> 6543;
6570 -> 6527;
6571 -> 6570;
6572 -> 6482;
6572 -> 6570;
6573 -> 6527;
6574 -> 6482;
6575 -> 6482;
6576 -> 6482;
6577 -> 6575;
6577 -> 6576;
6578 -> 6482;
6578 -> 6576;
6579 -> 6578;
6579 -> 6482;
6579 -> 6576;
6580 -> 6576;
6581 -> 6579;
6582 -> 6482;
6583 -> 6482;
6584 -> 6582;
6584 -> 6583;
6585 -> 6482;
6585 -> 6583;
6586 -> 6585;
6586 -> 6482;
6586 -> 6583;
6587 -> 6583;
6588 -> 6586;
6589 -> 6482;
6590 -> 6482;
6591 -> 6482;
6592 -> 6590;
6592 -> 6591;
6593 -> 6482;
6593 -> 6591;
6594 -> 6593;
6594 -> 6482;
6594 -> 6591;
6595 -> 6591;
6596 -> 6594;
6597 -> 6482;
6598 -> 6482;
6598 -> 6573;
6599 -> 6482;
6600 -> 6482;
6601 -> 6482;
6602 -> 6482;
6603 -> 6602;
6603 -> 6482;
6604 -> 6482;
6605 -> 6602;
6605 -> 6482;
6606 -> 0;
6606 -> 6482;
6607 -> 6482;
6608 -> 6482;
6609 -> 6482;
6610 -> 6609;
6610 -> 6606;
6610 -> 6482;
6611 -> 6610;
6611 -> 6482;
6612 -> 6482;
6613 -> 6482;
6614 -> 6608;
6614 -> 6613;
6614 -> 6482;
6615 -> 0;
6615 -> 6614;
6616 -> 6482;
6617 -> 6615;
6617 -> 0;
6617 -> 6482;
6618 -> 6611;
6618 -> 0;
6618 -> 6617;
6619 -> 6617;
6620 -> 6602;
6620 -> 6482;
6621 -> 6602;
6621 -> 6482;
6622 -> 6621;
6622 -> 6606;
6622 -> 6602;
6623 -> 6622;
6623 -> 6602;
6624 -> 6602;
6625 -> 6623;
6625 -> 0;
6625 -> 6617;
6626 -> 6602;
6627 -> 6602;
6628 -> 6602;
6629 -> 6602;
6630 -> 6628;
6630 -> 6629;
6631 -> 6482;
6631 -> 6629;
6632 -> 6631;
6632 -> 6602;
6632 -> 6629;
6633 -> 6629;
6634 -> 6632;
6635 -> 6602;
6636 -> 6602;
6637 -> 6602;
6638 -> 6636;
6638 -> 6637;
6639 -> 6482;
6639 -> 6637;
6640 -> 6639;
6640 -> 6602;
6640 -> 6637;
6641 -> 6637;
6642 -> 6640;
6643 -> 6527;
6644 -> 6541;
6644 -> 6602;
6644 -> 6643;
6644 -> 6527;
6645 -> 6532;
6645 -> 6527;
6646 -> 6527;
6647 -> 6530;
6647 -> 6646;
6647 -> 6527;
6648 -> 6647;
6649 -> 6648;
6650 -> 6649;
6651 -> 6602;
6652 -> 6602;
6653 -> 6602;
6654 -> 6523;
6654 -> 6146;
6655 -> 6146;
6656 -> 6135;
6656 -> 6146;
6657 -> 6135;
6657 -> 6146;
6658 -> 6135;
6658 -> 6146;
6659 -> 6135;
6659 -> 6146;
6660 -> 6146;
6661 -> 6659;
6661 -> 6602;
6661 -> 6660;
6661 -> 6146;
6662 -> 6656;
6662 -> 6146;
6663 -> 6146;
6664 -> 6662;
6664 -> 6663;
6665 -> 6659;
6665 -> 6663;
6666 -> 6663;
6667 -> 6665;
6667 -> 6602;
6667 -> 6666;
6667 -> 6663;
6668 -> 6146;
6669 -> 6146;
6670 -> 6669;
6671 -> 6670;
6672 -> 6671;
6673 -> 6602;
6673 -> 6671;
6674 -> 6669;
6675 -> 6146;
6676 -> 6675;
6677 -> 6602;
6677 -> 6675;
6678 -> 6146;
6679 -> 6135;
6679 -> 6146;
6680 -> 6135;
6680 -> 6146;
6681 -> 6146;
6682 -> 6680;
6682 -> 6681;
6683 -> 6682;
6683 -> 6602;
6683 -> 6681;
6684 -> 6683;
6684 -> 6146;
6685 -> 6684;
6685 -> 6602;
6685 -> 6146;
6686 -> 6146;
6687 -> 6135;
6687 -> 6146;
6688 -> 6135;
6688 -> 6146;
6689 -> 6146;
6690 -> 6135;
6690 -> 6689;
6690 -> 6602;
6690 -> 6140;
6691 -> 6135;
6691 -> 6146;
6692 -> 6691;
6692 -> 6690;
6692 -> 6146;
6693 -> 6146;
6694 -> 6146;
6695 -> 6135;
6695 -> 6146;
6696 -> 6695;
6696 -> 6690;
6696 -> 6146;
6697 -> 6146;
6698 -> 6135;
6698 -> 6146;
6699 -> 6698;
6699 -> 6696;
6699 -> 6146;
6700 -> 6146;
6701 -> 6135;
6701 -> 6146;
6702 -> 6146;
6703 -> 6146;
6704 -> 6135;
6704 -> 6699;
6704 -> 6146;
6705 -> 6146;
6706 -> 6705;
6707 -> 6706;
6708 -> 6707;
6709 -> 6699;
6709 -> 6707;
6710 -> 6705;
6711 -> 6699;
6711 -> 6146;
6712 -> 6146;
6713 -> 6135;
6713 -> 6146;
6714 -> 6146;
6715 -> 6714;
6716 -> 6715;
6717 -> 6716;
6718 -> 6699;
6718 -> 6716;
6719 -> 6714;
6720 -> 6699;
6720 -> 6146;
6721 -> 6720;
6721 -> 6713;
6721 -> 6699;
6721 -> 6146;
6722 -> 6146;
6723 -> 6722;
6723 -> 6146;
6724 -> 6146;
6725 -> 6135;
6725 -> 6699;
6726 -> 6135;
6726 -> 6146;
6727 -> 6135;
6727 -> 6146;
6728 -> 6146;
6729 -> 6146;
6730 -> 6146;
6731 -> 6682;
6731 -> 6699;
6731 -> 6681;
6732 -> 6731;
6732 -> 6146;
6733 -> 6732;
6733 -> 6699;
6733 -> 6146;
6734 -> 6146;
6735 -> 6691;
6735 -> 6699;
6735 -> 6146;
6736 -> 6135;
6736 -> 6146;
6737 -> 6135;
6737 -> 6146;
6738 -> 6146;
6739 -> 6737;
6739 -> 6738;
6739 -> 6146;
6740 -> 6736;
6740 -> 6699;
6741 -> 6737;
6741 -> 6699;
6742 -> 6740;
6742 -> 6699;
6743 -> 6741;
6743 -> 6699;
6744 -> 6699;
6745 -> 6699;
6746 -> 6699;
6747 -> 6743;
6747 -> 6746;
6747 -> 6699;
6748 -> 6699;
6749 -> 6699;
6749 -> 6748;
6750 -> 6699;
6750 -> 0;
6751 -> 6699;
6752 -> 6745;
6752 -> 6751;
6753 -> 6752;
6754 -> 6752;
6755 -> 6699;
6755 -> 6752;
6756 -> 6752;
6757 -> 6755;
6757 -> 6756;
6758 -> 6756;
6759 -> 6757;
6759 -> 6758;
6760 -> 6758;
6761 -> 6759;
6761 -> 6760;
6761 -> 6758;
6762 -> 6758;
6763 -> 6762;
6763 -> 6756;
6764 -> 6699;
6764 -> 6763;
6765 -> 6699;
6766 -> 6135;
6766 -> 6146;
6767 -> 6135;
6767 -> 6699;
6767 -> 6146;
6768 -> 6135;
6768 -> 6146;
6769 -> 6146;
6770 -> 6135;
6770 -> 6769;
6770 -> 6146;
6771 -> 6146;
6772 -> 6771;
6772 -> 6146;
6773 -> 6146;
6774 -> 6766;
6774 -> 6773;
6775 -> 6773;
6776 -> 6699;
6777 -> 6699;
6778 -> 6774;
6778 -> 6699;
6779 -> 6699;
6780 -> 6778;
6780 -> 6699;
6781 -> 6135;
6781 -> 6699;
6782 -> 6781;
6782 -> 6699;
6783 -> 6699;
6784 -> 6779;
6784 -> 6783;
6785 -> 6784;
6785 -> 6699;
6786 -> 6782;
6786 -> 6699;
6787 -> 6781;
6787 -> 6699;
6787 -> 0;
6788 -> 6699;
6789 -> 6781;
6789 -> 6699;
6789 -> 6788;
6790 -> 6135;
6790 -> 6146;
6791 -> 6135;
6791 -> 6699;
6791 -> 6146;
6792 -> 6699;
6793 -> 6699;
6794 -> 6699;
6795 -> 6699;
6796 -> 6699;
6796 -> 6795;
6797 -> 6699;
6797 -> 6795;
6798 -> 6794;
6798 -> 6795;
6799 -> 6795;
6800 -> 6797;
6800 -> 6799;
6800 -> 6795;
6801 -> 6699;
6802 -> 6699;
6803 -> 6135;
6803 -> 6146;
6804 -> 0;
6804 -> 6146;
6805 -> 6135;
6805 -> 6146;
6806 -> 6146;
6807 -> 6135;
6807 -> 6806;
6807 -> 6699;
6807 -> 6140;
6808 -> 6736;
6808 -> 6807;
6809 -> 6737;
6809 -> 6807;
6810 -> 6808;
6810 -> 6807;
6811 -> 6809;
6811 -> 6807;
6812 -> 6807;
6813 -> 6807;
6814 -> 6807;
6815 -> 6811;
6815 -> 6814;
6815 -> 6807;
6816 -> 6807;
6817 -> 6807;
6817 -> 6816;
6818 -> 6807;
6818 -> 0;
6819 -> 6807;
6820 -> 6813;
6820 -> 6819;
6821 -> 6820;
6822 -> 6820;
6823 -> 6807;
6823 -> 6820;
6824 -> 6820;
6825 -> 6823;
6825 -> 6824;
6826 -> 6824;
6827 -> 6825;
6827 -> 6826;
6828 -> 6826;
6829 -> 6827;
6829 -> 6828;
6829 -> 6826;
6830 -> 6826;
6831 -> 6830;
6831 -> 6824;
6832 -> 6807;
6832 -> 6831;
6833 -> 6807;
6834 -> 6135;
6834 -> 6146;
6835 -> 6146;
6836 -> 6135;
6836 -> 0;
6836 -> 6807;
6837 -> 6135;
6837 -> 6807;
6837 -> 6146;
6838 -> 6135;
6838 -> 6807;
6838 -> 6146;
6839 -> 6807;
6839 -> 6707;
6840 -> 6807;
6840 -> 6146;
6841 -> 6146;
6842 -> 6146;
6843 -> 6146;
6844 -> 6146;
6845 -> 6135;
6845 -> 6807;
6846 -> 6807;
6847 -> 6845;
6847 -> 6807;
6847 -> 6846;
6848 -> 6807;
6849 -> 6807;
6850 -> 6807;
6851 -> 6807;
6852 -> 6807;
6853 -> 6852;
6853 -> 6807;
6853 -> 6846;
6854 -> 6841;
6854 -> 6146;
6855 -> 6146;
6856 -> 6855;
6857 -> 6807;
6857 -> 6855;
6858 -> 6137;
6858 -> 6134;
6859 -> 6134;
6860 -> 6858;
6860 -> 6859;
6861 -> 6860;
6861 -> 6859;
6862 -> 6859;
6863 -> 6861;
6863 -> 6862;
6864 -> 6863;
6864 -> 6862;
6865 -> 6862;
6866 -> 6862;
6867 -> 6864;
6867 -> 6866;
6868 -> 6865;
6868 -> 6866;
6869 -> 6866;
6870 -> 6867;
6870 -> 6869;
6870 -> 6866;
6871 -> 6867;
6871 -> 6866;
6872 -> 6867;
6872 -> 6866;
6873 -> 6868;
6873 -> 6871;
6873 -> 6872;
6873 -> 6866;
6874 -> 6867;
6874 -> 6866;
6875 -> 6866;
6876 -> 6807;
6876 -> 6875;
6876 -> 6866;
6877 -> 6866;
6878 -> 6867;
6878 -> 6866;
6879 -> 6866;
6880 -> 6878;
6880 -> 6879;
6881 -> 6879;
6882 -> 6879;
6883 -> 6807;
6883 -> 6879;
6884 -> 6883;
6884 -> 6879;
6885 -> 6882;
6885 -> 6884;
6886 -> 6885;
6886 -> 6881;
6886 -> 6879;
6887 -> 6885;
6887 -> 6881;
6887 -> 6879;
6888 -> 6887;
6888 -> 6879;
6889 -> 6880;
6889 -> 6879;
6890 -> 6880;
6890 -> 6879;
6891 -> 6880;
6891 -> 6879;
6892 -> 6879;
6893 -> 6891;
6893 -> 6892;
6894 -> 2395;
6894 -> 6892;
6895 -> 6892;
6896 -> 6893;
6896 -> 6892;
6897 -> 6892;
6898 -> 6897;
6898 -> 6879;
6899 -> 6898;
6900 -> 6899;
6901 -> 2395;
6901 -> 6899;
6902 -> 6879;
6903 -> 6902;
6903 -> 6879;
6904 -> 6879;
6905 -> 6879;
6906 -> 6902;
6906 -> 6905;
6906 -> 6903;
6906 -> 6879;
6907 -> 6879;
6908 -> 6880;
6908 -> 6879;
6909 -> 6902;
6909 -> 6879;
6910 -> 6907;
6910 -> 6879;
6911 -> 6879;
6912 -> 6909;
6912 -> 6911;
6913 -> 6910;
6913 -> 6911;
6914 -> 6913;
6914 -> 6907;
6914 -> 6911;
6915 -> 6911;
6916 -> 6915;
6916 -> 6914;
6916 -> 6911;
6917 -> 6879;
6918 -> 6879;
6919 -> 6902;
6919 -> 6918;
6919 -> 6906;
6919 -> 6879;
6920 -> 6879;
6921 -> 6879;
6922 -> 6879;
6923 -> 6921;
6923 -> 6922;
6923 -> 6879;
6924 -> 6879;
6925 -> 6902;
6925 -> 6924;
6925 -> 6919;
6925 -> 6879;
6926 -> 6907;
6926 -> 6879;
6927 -> 6920;
6927 -> 6879;
6928 -> 0;
6928 -> 6879;
6929 -> 6879;
6930 -> 6879;
6931 -> 6926;
6931 -> 6930;
6932 -> 6927;
6932 -> 6930;
6933 -> 6928;
6933 -> 6930;
6934 -> 6929;
6934 -> 6930;
6935 -> 6929;
6935 -> 6930;
6936 -> 6930;
6937 -> 6934;
6937 -> 6936;
6937 -> 6930;
6938 -> 6937;
6938 -> 6930;
6939 -> 5851;
6939 -> 6938;
6940 -> 6930;
6941 -> 6940;
6941 -> 6935;
6941 -> 6930;
6942 -> 6931;
6942 -> 6930;
6943 -> 6932;
6943 -> 6930;
6944 -> 6933;
6944 -> 6930;
6945 -> 6942;
6945 -> 6930;
6946 -> 6943;
6946 -> 6930;
6947 -> 6941;
6947 -> 6930;
6948 -> 6930;
6949 -> 6945;
6949 -> 6948;
6950 -> 6946;
6950 -> 6948;
6951 -> 6947;
6951 -> 6948;
6952 -> 6939;
6952 -> 6948;
6953 -> 6949;
6953 -> 6948;
6954 -> 6949;
6954 -> 6942;
6954 -> 6948;
6955 -> 6950;
6955 -> 6948;
6956 -> 6950;
6956 -> 6943;
6956 -> 6948;
6957 -> 6948;
6958 -> 6953;
6958 -> 6957;
6959 -> 6954;
6959 -> 6957;
6960 -> 6955;
6960 -> 6957;
6961 -> 6956;
6961 -> 6957;
6962 -> 6952;
6962 -> 6957;
6963 -> 6958;
6963 -> 6957;
6964 -> 6959;
6964 -> 6957;
6965 -> 6960;
6965 -> 6957;
6966 -> 6961;
6966 -> 6957;
6967 -> 6957;
6968 -> 6963;
6968 -> 6967;
6969 -> 6964;
6969 -> 6967;
6970 -> 6965;
6970 -> 6967;
6971 -> 6966;
6971 -> 6967;
6972 -> 6962;
6972 -> 6967;
6973 -> 6967;
6974 -> 6969;
6974 -> 6973;
6974 -> 6967;
6975 -> 6967;
6976 -> 6971;
6976 -> 6975;
6976 -> 6967;
6977 -> 6974;
6977 -> 6976;
6977 -> 6967;
6978 -> 6967;
6979 -> 6978;
6979 -> 6977;
6979 -> 6967;
6980 -> 6967;
6981 -> 6980;
6981 -> 6969;
6981 -> 6967;
6982 -> 6967;
6983 -> 6982;
6983 -> 6971;
6983 -> 6967;
6984 -> 6967;
6985 -> 6984;
6985 -> 6969;
6985 -> 6967;
6986 -> 6977;
6986 -> 6967;
6987 -> 6959;
6987 -> 6957;
6988 -> 6961;
6988 -> 6957;
6989 -> 6957;
6990 -> 6987;
6990 -> 6989;
6990 -> 6957;
6991 -> 6957;
6992 -> 6987;
6992 -> 6991;
6992 -> 6957;
6993 -> 6957;
6994 -> 6988;
6994 -> 6993;
6994 -> 6957;
6995 -> 6957;
6996 -> 6995;
6996 -> 6948;
6997 -> 6948;
6998 -> 6997;
6998 -> 6930;
6999 -> 6944;
6999 -> 6998;
6999 -> 6930;
7000 -> 6902;
7000 -> 6999;
7000 -> 6925;
7000 -> 6879;
7001 -> 6920;
7001 -> 6879;
7002 -> 6907;
7002 -> 6879;
7003 -> 6902;
7003 -> 7000;
7003 -> 6879;
7004 -> 7003;
7004 -> 6866;
7005 -> 6859;
7006 -> 6135;
7006 -> 6134;
7007 -> 3213;
7007 -> 1;
7008 -> 1;
7009 -> 3212;
7009 -> 7008;
7009 -> 1;
7010 -> 0;
7010 -> 1;
7011 -> 0;
7011 -> 7010;
7011 -> 6807;
7011 -> 1;
7012 -> 7007;
7012 -> 7008;
7012 -> 7011;
7012 -> 7009;
7012 -> 1;
7013 -> 7008;
7014 -> 7013;
7015 -> 7012;
7015 -> 7008;
7016 -> 7012;
7016 -> 7008;
7017 -> 7015;
7017 -> 7008;
7018 -> 7008;
7019 -> 7018;
7019 -> 7008;
7020 -> 7008;
7021 -> 7017;
7021 -> 7020;
7022 -> 7019;
7022 -> 7020;
7023 -> 7020;
7024 -> 7012;
7025 -> 7012;
7026 -> 7024;
7026 -> 7012;
7027 -> 7012;
7028 -> 7025;
7028 -> 7012;
7028 -> 7026;
7028 -> 7027;
7028 -> 7024;
7029 -> 7012;
7030 -> 7029;
7030 -> 7024;
7030 -> 7012;
7031 -> 7024;
7031 -> 7012;
7032 -> 7012;
7033 -> 7031;
7033 -> 7032;
7033 -> 7024;
7033 -> 7030;
7033 -> 7012;
7034 -> 7020;
7035 -> 7012;
7035 -> 7034;
7035 -> 7020;
7036 -> 0;
7036 -> 7020;
7037 -> 7022;
7037 -> 7020;
7038 -> 7012;
7038 -> 7020;
7039 -> 7020;
7040 -> 7038;
7040 -> 7039;
7041 -> 0;
7041 -> 7039;
7042 -> 7041;
7043 -> 7020;
7044 -> 7020;
7045 -> 7044;
7046 -> 7044;
7047 -> 7044;
7048 -> 7046;
7048 -> 7047;
7049 -> 7046;
7049 -> 7047;
7050 -> 7046;
7050 -> 7047;
7051 -> 7046;
7051 -> 7047;
7052 -> 7047;
7053 -> 7012;
7053 -> 7052;
7053 -> 7047;
7054 -> 7051;
7054 -> 7047;
7055 -> 7048;
7055 -> 7047;
7056 -> 7049;
7056 -> 7047;
7057 -> 7050;
7057 -> 7047;
7058 -> 7051;
7058 -> 7047;
7059 -> 7047;
7060 -> 0;
7060 -> 7047;
7061 -> 7047;
7062 -> 7060;
7062 -> 7061;
7063 -> 7060;
7063 -> 7061;
7064 -> 7058;
7064 -> 7061;
7065 -> 7059;
7065 -> 7061;
7066 -> 7059;
7066 -> 7061;
7067 -> 7062;
7067 -> 7061;
7068 -> 7063;
7068 -> 7061;
7069 -> 7064;
7069 -> 7061;
7070 -> 7061;
7071 -> 7070;
7071 -> 7061;
7072 -> 7065;
7072 -> 7070;
7072 -> 7061;
7073 -> 7047;
7074 -> 7055;
7074 -> 7073;
7075 -> 7056;
7075 -> 7073;
7076 -> 7057;
7076 -> 7073;
7077 -> 7058;
7077 -> 7073;
7078 -> 7059;
7078 -> 7073;
7079 -> 7059;
7079 -> 7073;
7080 -> 7059;
7080 -> 7073;
7081 -> 7059;
7081 -> 7073;
7082 -> 7059;
7082 -> 7073;
7083 -> 7059;
7083 -> 7073;
7084 -> 7074;
7084 -> 7073;
7085 -> 7075;
7085 -> 7073;
7086 -> 7076;
7086 -> 7073;
7087 -> 7077;
7087 -> 7073;
7088 -> 7078;
7088 -> 7073;
7089 -> 7079;
7089 -> 7073;
7090 -> 7080;
7090 -> 7073;
7091 -> 7081;
7091 -> 7073;
7092 -> 7082;
7092 -> 7073;
7093 -> 7073;
7094 -> 7084;
7094 -> 7093;
7095 -> 7085;
7095 -> 7093;
7096 -> 7086;
7096 -> 7093;
7097 -> 7087;
7097 -> 7093;
7098 -> 7088;
7098 -> 7093;
7099 -> 7089;
7099 -> 7093;
7100 -> 7090;
7100 -> 7093;
7101 -> 7091;
7101 -> 7093;
7102 -> 7092;
7102 -> 7093;
7103 -> 7083;
7103 -> 7093;
7104 -> 7097;
7104 -> 7093;
7105 -> 7101;
7105 -> 7093;
7106 -> 7102;
7106 -> 7093;
7107 -> 7093;
7108 -> 7107;
7108 -> 7093;
7109 -> 7107;
7109 -> 7093;
7110 -> 7107;
7110 -> 7093;
7111 -> 7107;
7111 -> 7093;
7112 -> 7107;
7112 -> 7093;
7113 -> 7107;
7113 -> 7093;
7114 -> 7107;
7114 -> 7093;
7115 -> 7107;
7115 -> 7093;
7116 -> 7107;
7116 -> 7093;
7117 -> 7107;
7117 -> 7093;
7118 -> 7107;
7118 -> 7093;
7119 -> 7107;
7119 -> 7093;
7120 -> 7107;
7120 -> 7093;
7121 -> 7107;
7121 -> 7093;
7122 -> 7107;
7122 -> 7093;
7123 -> 7107;
7123 -> 7093;
7124 -> 7107;
7124 -> 7093;
7125 -> 7107;
7125 -> 7093;
7126 -> 7107;
7126 -> 7093;
7127 -> 7107;
7127 -> 7093;
7128 -> 7107;
7128 -> 7093;
7129 -> 7107;
7129 -> 7093;
7130 -> 7107;
7130 -> 7093;
7131 -> 7107;
7131 -> 7093;
7132 -> 7107;
7132 -> 7093;
7133 -> 7107;
7133 -> 7093;
7134 -> 7093;
7135 -> 7134;
7135 -> 7107;
7135 -> 7093;
7136 -> 7107;
7136 -> 7093;
7137 -> 7107;
7137 -> 7093;
7138 -> 7093;
7139 -> 7093;
7140 -> 7137;
7140 -> 7139;
7141 -> 7138;
7141 -> 7139;
7142 -> 7141;
7142 -> 7139;
7143 -> 7141;
7143 -> 7139;
7144 -> 7141;
7144 -> 7139;
7145 -> 7140;
7145 -> 7141;
7145 -> 7139;
7146 -> 7138;
7146 -> 7107;
7146 -> 7093;
7147 -> 7107;
7147 -> 7093;
7148 -> 7093;
7149 -> 7148;
7150 -> 0;
7150 -> 7148;
7151 -> 7150;
7151 -> 7149;
7151 -> 7148;
7152 -> 7151;
7152 -> 7093;
7153 -> 7152;
7153 -> 7107;
7153 -> 7093;
7154 -> 7097;
7154 -> 7093;
7155 -> 7154;
7156 -> 7094;
7156 -> 7155;
7156 -> 7154;
7157 -> 7095;
7157 -> 7155;
7157 -> 7154;
7158 -> 7156;
7158 -> 7157;
7158 -> 7154;
7159 -> 7096;
7159 -> 7155;
7159 -> 7154;
7160 -> 7158;
7160 -> 7159;
7160 -> 7154;
7161 -> 7099;
7161 -> 7093;
7162 -> 7161;
7163 -> 7107;
7163 -> 7162;
7164 -> 7098;
7164 -> 7161;
7165 -> 7100;
7165 -> 7107;
7165 -> 7093;
7166 -> 7107;
7166 -> 7012;
7166 -> 7093;
7167 -> 7093;
7168 -> 7107;
7168 -> 7012;
7168 -> 7167;
7168 -> 7093;
7169 -> 7047;
7170 -> 7012;
7171 -> 7012;
7172 -> 7012;
7173 -> 7012;
7174 -> 7012;
7175 -> 7171;
7175 -> 7012;
7176 -> 7012;
7177 -> 7012;
7178 -> 7012;
7179 -> 7012;
7180 -> 7012;
7181 -> 7012;
7182 -> 7012;
7183 -> 7012;
7184 -> 7181;
7184 -> 7012;
7185 -> 7182;
7185 -> 7012;
7186 -> 7183;
7186 -> 7012;
7187 -> 7184;
7187 -> 7012;
7188 -> 7185;
7188 -> 7012;
7189 -> 7186;
7189 -> 7012;
7190 -> 7012;
7191 -> 7012;
7192 -> 7191;
7193 -> 7187;
7193 -> 7192;
7193 -> 7191;
7194 -> 7188;
7194 -> 7192;
7194 -> 7191;
7195 -> 7193;
7195 -> 7194;
7195 -> 7191;
7196 -> 7189;
7196 -> 7192;
7196 -> 7191;
7197 -> 7195;
7197 -> 7196;
7197 -> 7191;
7198 -> 7012;
7199 -> 7012;
7200 -> 7012;
7201 -> 7012;
7201 -> 7047;
7202 -> 7020;
7203 -> 7202;
7204 -> 7203;
7205 -> 7204;
7206 -> 7012;
7207 -> 7012;
7208 -> 7012;
7209 -> 7012;
7210 -> 7012;
7211 -> 7210;
7211 -> 0;
7211 -> 7012;
7212 -> 7012;
7213 -> 7012;
7214 -> 7012;
7215 -> 7012;
7216 -> 7012;
7217 -> 7012;
7217 -> 7202;
7218 -> 7202;
7219 -> 0;
7219 -> 7202;
7220 -> 7012;
7220 -> 1;
7221 -> 11;
7221 -> 1;
7222 -> 1;
7223 -> 1;
7224 -> 7220;
7224 -> 7223;
7225 -> 7221;
7225 -> 7223;
7226 -> 7222;
7226 -> 7223;
7227 -> 7225;
7227 -> 7223;
7228 -> 7223;
7229 -> 7223;
7230 -> 7227;
7230 -> 7229;
7231 -> 7228;
7231 -> 7229;
7232 -> 7229;
7233 -> 0;
7233 -> 7232;
7234 -> 7233;
7234 -> 7229;
7235 -> 7229;
7236 -> 7234;
7236 -> 7229;
7237 -> 7230;
7237 -> 7229;
7238 -> 7231;
7238 -> 7229;
7239 -> 7224;
7239 -> 7235;
7240 -> 7224;
7240 -> 7235;
7241 -> 7224;
7241 -> 7235;
7242 -> 7224;
7242 -> 7235;
7243 -> 7224;
7243 -> 7235;
7244 -> 7235;
7245 -> 7244;
7246 -> 7245;
7247 -> 7246;
7248 -> 7247;
7249 -> 7224;
7250 -> 7224;
7250 -> 7247;
7251 -> 7224;
7251 -> 7245;
7252 -> 7251;
7252 -> 7245;
7253 -> 7244;
7254 -> 7235;
7255 -> 7224;
7255 -> 7254;
7255 -> 7235;
7256 -> 7235;
7257 -> 7256;
7258 -> 7257;
7259 -> 7224;
7259 -> 7257;
7260 -> 7256;
7261 -> 7260;
7262 -> 7261;
7263 -> 7262;
7264 -> 7260;
7265 -> 7264;
7266 -> 7265;
7267 -> 7224;
7267 -> 7256;
7268 -> 7256;
7269 -> 7235;
7270 -> 7235;
7271 -> 7224;
7272 -> 7224;
7273 -> 7224;
7274 -> 7235;
7275 -> 7239;
7275 -> 7274;
7275 -> 7235;
7276 -> 7235;
7277 -> 7240;
7277 -> 7276;
7277 -> 7235;
7278 -> 7235;
7279 -> 7241;
7279 -> 7278;
7279 -> 7235;
7280 -> 7235;
7281 -> 7224;
7281 -> 7235;
7282 -> 0;
7282 -> 7235;
7283 -> 7235;
7284 -> 7235;
7285 -> 7282;
7285 -> 7284;
7286 -> 7283;
7286 -> 7284;
7287 -> 7284;
7288 -> 7285;
7288 -> 7284;
7289 -> 7286;
7289 -> 7284;
7290 -> 7287;
7290 -> 7284;
7291 -> 7284;
7292 -> 7288;
7292 -> 7291;
7293 -> 7289;
7293 -> 7291;
7294 -> 7290;
7294 -> 7291;
7295 -> 7291;
7296 -> 7292;
7296 -> 0;
7296 -> 7291;
7297 -> 7296;
7297 -> 7293;
7297 -> 7291;
7298 -> 7297;
7299 -> 7298;
7300 -> 7299;
7301 -> 7297;
7302 -> 7224;
7303 -> 7224;
7304 -> 7297;
7305 -> 7224;
7306 -> 7292;
7306 -> 0;
7306 -> 7291;
7307 -> 7295;
7307 -> 7306;
7308 -> 7306;
7309 -> 7306;
7310 -> 7306;
7311 -> 7224;
7311 -> 7310;
7312 -> 7311;
7312 -> 7306;
7313 -> 7306;
7314 -> 7306;
7315 -> 7306;
7316 -> 7314;
7316 -> 7315;
7317 -> 7314;
7317 -> 7315;
7318 -> 7314;
7318 -> 7315;
7319 -> 7315;
7320 -> 7319;
7321 -> 7320;
7322 -> 7315;
7323 -> 7315;
7324 -> 7316;
7324 -> 7323;
7324 -> 7315;
7325 -> 7315;
7326 -> 7325;
7327 -> 7326;
7328 -> 7224;
7328 -> 7326;
7329 -> 7322;
7329 -> 7315;
7330 -> 7315;
7331 -> 7330;
7332 -> 7331;
7333 -> 7332;
7334 -> 7330;
7335 -> 7334;
7336 -> 7335;
7337 -> 7224;
7337 -> 7330;
7338 -> 7330;
7339 -> 7224;
7339 -> 7330;
7340 -> 7224;
7340 -> 7330;
7341 -> 7340;
7341 -> 7224;
7341 -> 7330;
7342 -> 7330;
7343 -> 7330;
7344 -> 7342;
7344 -> 7343;
7345 -> 7344;
7345 -> 7343;
7346 -> 7343;
7347 -> 7343;
7348 -> 7346;
7348 -> 7347;
7349 -> 7348;
7349 -> 7347;
7350 -> 7347;
7351 -> 7350;
7352 -> 7351;
7353 -> 7351;
7354 -> 7353;
7355 -> 7350;
7356 -> 7355;
7357 -> 7347;
7358 -> 7347;
7359 -> 7347;
7360 -> 7348;
7360 -> 7347;
7361 -> 7347;
7362 -> 7360;
7362 -> 7361;
7363 -> 7362;
7363 -> 7361;
7364 -> 7361;
7365 -> 7361;
7366 -> 7365;
7367 -> 7365;
7368 -> 7342;
7369 -> 7368;
7370 -> 7369;
7371 -> 7224;
7371 -> 7369;
7372 -> 7342;
7373 -> 7330;
7374 -> 7373;
7375 -> 7374;
7376 -> 7373;
7377 -> 7373;
7378 -> 7224;
7378 -> 7330;
7379 -> 7378;
7379 -> 7330;
7380 -> 7330;
7381 -> 7330;
7382 -> 7380;
7382 -> 7381;
7383 -> 7382;
7383 -> 7381;
7384 -> 7381;
7385 -> 7384;
7386 -> 7385;
7387 -> 7385;
7388 -> 7387;
7389 -> 7384;
7390 -> 7389;
7391 -> 7381;
7392 -> 7381;
7393 -> 7381;
7394 -> 7392;
7394 -> 7381;
7395 -> 7382;
7395 -> 7381;
7396 -> 7381;
7397 -> 7395;
7397 -> 7396;
7398 -> 7397;
7398 -> 7396;
7399 -> 7396;
7400 -> 7396;
7401 -> 7400;
7402 -> 7400;
7403 -> 7401;
7403 -> 7400;
7404 -> 7330;
7405 -> 7404;
7406 -> 7405;
7407 -> 7224;
7407 -> 7405;
7408 -> 7330;
7409 -> 7330;
7410 -> 7409;
7411 -> 7410;
7412 -> 7330;
7413 -> 7224;
7413 -> 0;
7413 -> 7330;
7414 -> 7330;
7415 -> 7224;
7415 -> 7330;
7416 -> 7224;
7416 -> 7330;
7417 -> 7330;
7418 -> 7417;
7419 -> 7418;
7420 -> 7419;
7421 -> 7224;
7421 -> 7419;
7422 -> 7417;
7423 -> 7224;
7423 -> 7330;
7424 -> 7330;
7425 -> 7316;
7425 -> 7315;
7426 -> 7425;
7427 -> 7425;
7428 -> 7315;
7429 -> 7318;
7429 -> 7428;
7429 -> 7315;
7430 -> 7316;
7430 -> 7315;
7431 -> 7317;
7431 -> 7315;
7432 -> 7315;
7433 -> 7430;
7433 -> 7432;
7434 -> 7431;
7434 -> 7432;
7435 -> 7432;
7436 -> 7433;
7436 -> 7435;
7436 -> 7432;
7437 -> 7224;
7438 -> 7224;
7439 -> 7224;
7439 -> 0;
7440 -> 7224;
7441 -> 7224;
7441 -> 0;
7442 -> 7224;
7442 -> 0;
7443 -> 7224;
7443 -> 0;
7444 -> 7224;
7444 -> 0;
7445 -> 7224;
7445 -> 0;
7446 -> 7224;
7446 -> 0;
7447 -> 7224;
7448 -> 7224;
7449 -> 7224;
7450 -> 7224;
7450 -> 0;
7451 -> 7224;
7452 -> 7224;
7453 -> 7451;
7453 -> 7452;
7454 -> 7453;
7454 -> 7452;
7455 -> 7454;
7456 -> 7224;
7457 -> 7456;
7457 -> 7224;
7458 -> 7224;
7459 -> 7458;
7459 -> 7224;
7460 -> 7449;
7460 -> 7459;
7461 -> 7224;
7462 -> 7460;
7462 -> 7461;
7462 -> 7224;
7463 -> 7462;
7463 -> 7456;
7463 -> 7224;
7464 -> 7456;
7464 -> 7224;
7465 -> 7455;
7465 -> 7464;
7466 -> 7455;
7466 -> 7224;
7467 -> 7224;
7467 -> 0;
7468 -> 7224;
7469 -> 7224;
7470 -> 7224;
7471 -> 7469;
7471 -> 7470;
7472 -> 7471;
7472 -> 7470;
7473 -> 7472;
7474 -> 7224;
7475 -> 7473;
7475 -> 7474;
7476 -> 7224;
7477 -> 7224;
7478 -> 7476;
7478 -> 7477;
7479 -> 7224;
7479 -> 7477;
7480 -> 7478;
7480 -> 7224;
7480 -> 0;
7480 -> 7477;
7481 -> 7480;
7482 -> 7224;
7483 -> 7469;
7483 -> 7482;
7484 -> 7483;
7484 -> 7482;
7485 -> 7484;
7486 -> 7224;
7487 -> 7224;
7488 -> 7224;
7489 -> 7224;
7489 -> 7432;
7490 -> 7306;
7491 -> 7224;
7491 -> 7490;
7491 -> 7306;
7492 -> 7292;
7492 -> 0;
7492 -> 7291;
7493 -> 7294;
7493 -> 7291;
7494 -> 7295;
7494 -> 7291;
7495 -> 7291;
7496 -> 7284;
7497 -> 7280;
7497 -> 7235;
7498 -> 7280;
7498 -> 7235;
7499 -> 7224;
7500 -> 7224;
7501 -> 7224;
7502 -> 7224;
7503 -> 7224;
7504 -> 7224;
7505 -> 7224;
7506 -> 7505;
7506 -> 7224;
7507 -> 7224;
7508 -> 7224;
7509 -> 7224;
7510 -> 7224;
7511 -> 7224;
7512 -> 7224;
7513 -> 7224;
7514 -> 7224;
7515 -> 7224;
7516 -> 7224;
7517 -> 7224;
7518 -> 7516;
7518 -> 7517;
7519 -> 7224;
7519 -> 7517;
7520 -> 7518;
7520 -> 7517;
7521 -> 7224;
7522 -> 7224;
7523 -> 7224;
7524 -> 7522;
7524 -> 7523;
7525 -> 7522;
7525 -> 7523;
7526 -> 7523;
7527 -> 7524;
7527 -> 7526;
7527 -> 7523;
7528 -> 7224;
7529 -> 7224;
7530 -> 7224;
7531 -> 7224;
7532 -> 7224;
7533 -> 7224;
7534 -> 7532;
7534 -> 7533;
7535 -> 7532;
7535 -> 7533;
7536 -> 7224;
7536 -> 7533;
7537 -> 7534;
7537 -> 7533;
7538 -> 7224;
7539 -> 7224;
7540 -> 7538;
7540 -> 7539;
7541 -> 7538;
7541 -> 7539;
7542 -> 7224;
7542 -> 7539;
7543 -> 7540;
7543 -> 7539;
7544 -> 7224;
7545 -> 7224;
7546 -> 7224;
7547 -> 7224;
7548 -> 7224;
7549 -> 7547;
7549 -> 7548;
7549 -> 7224;
7550 -> 7224;
7551 -> 7224;
7552 -> 7224;
7553 -> 7224;
7554 -> 7552;
7554 -> 7553;
7555 -> 7552;
7555 -> 7553;
7556 -> 7224;
7556 -> 7553;
7557 -> 7556;
7557 -> 7224;
7557 -> 7553;
7558 -> 7556;
7558 -> 7224;
7558 -> 7553;
7559 -> 7224;
7560 -> 7235;
7561 -> 7235;
7562 -> 7561;
7562 -> 7235;
7563 -> 7235;
7564 -> 7563;
7565 -> 7224;
7565 -> 7563;
7566 -> 7235;
7567 -> 7561;
7567 -> 7235;
7568 -> 7235;
7569 -> 7567;
7569 -> 7568;
7570 -> 7568;
7571 -> 7570;
7572 -> 7224;
7572 -> 7570;
7573 -> 7224;
7573 -> 7568;
7574 -> 7568;
7575 -> 7574;
7575 -> 7573;
7575 -> 7224;
7575 -> 7568;
7576 -> 7568;
7577 -> 7576;
7577 -> 7235;
7578 -> 7561;
7578 -> 7235;
7579 -> 7235;
7580 -> 7235;
7581 -> 7235;
7582 -> 7580;
7582 -> 7235;
7583 -> 7235;
7584 -> 7235;
7585 -> 7224;
7585 -> 7584;
7586 -> 7582;
7586 -> 7584;
7587 -> 7583;
7587 -> 7584;
7588 -> 7583;
7588 -> 7584;
7589 -> 7584;
7590 -> 7584;
7591 -> 7585;
7591 -> 7590;
7591 -> 7584;
7592 -> 7584;
7593 -> 7592;
7594 -> 7224;
7594 -> 7592;
7595 -> 7589;
7595 -> 7584;
7596 -> 7587;
7596 -> 7584;
7597 -> 7588;
7597 -> 7584;
7598 -> 7584;
7599 -> 7586;
7599 -> 7584;
7600 -> 7584;
7601 -> 7595;
7601 -> 7600;
7602 -> 7596;
7602 -> 7600;
7603 -> 7597;
7603 -> 7600;
7604 -> 7598;
7604 -> 7600;
7605 -> 7598;
7605 -> 7600;
7606 -> 7599;
7606 -> 7600;
7607 -> 7598;
7607 -> 7600;
7608 -> 7600;
7609 -> 7608;
7609 -> 7600;
7610 -> 7608;
7610 -> 7600;
7611 -> 7608;
7611 -> 7600;
7612 -> 7608;
7612 -> 7600;
7613 -> 7608;
7613 -> 7600;
7614 -> 7608;
7614 -> 7600;
7615 -> 7608;
7615 -> 7600;
7616 -> 7608;
7616 -> 7600;
7617 -> 7608;
7617 -> 7600;
7618 -> 7608;
7618 -> 7600;
7619 -> 7608;
7619 -> 7600;
7620 -> 7608;
7620 -> 7600;
7621 -> 7601;
7621 -> 7608;
7621 -> 7600;
7622 -> 7602;
7622 -> 7608;
7622 -> 7600;
7623 -> 7603;
7623 -> 7608;
7623 -> 7600;
7624 -> 7604;
7624 -> 7608;
7624 -> 7600;
7625 -> 7605;
7625 -> 7608;
7625 -> 7600;
7626 -> 7606;
7626 -> 7608;
7626 -> 7600;
7627 -> 7584;
7628 -> 7627;
7629 -> 7224;
7629 -> 7627;
7630 -> 7584;
7631 -> 7224;
7632 -> 7224;
7633 -> 7224;
7634 -> 7632;
7634 -> 7633;
7635 -> 7224;
7635 -> 7633;
7636 -> 7635;
7636 -> 7224;
7636 -> 7633;
7637 -> 7633;
7638 -> 7636;
7639 -> 7224;
7640 -> 7224;
7641 -> 7639;
7641 -> 7640;
7642 -> 7224;
7642 -> 7640;
7643 -> 7642;
7643 -> 7224;
7643 -> 7640;
7644 -> 7640;
7645 -> 7643;
7646 -> 7224;
7647 -> 7224;
7648 -> 7224;
7649 -> 7647;
7649 -> 7648;
7650 -> 7224;
7650 -> 7648;
7651 -> 7650;
7651 -> 7224;
7651 -> 7648;
7652 -> 7648;
7653 -> 7651;
7654 -> 7224;
7655 -> 7224;
7655 -> 7630;
7656 -> 7224;
7657 -> 7224;
7658 -> 7224;
7659 -> 7224;
7660 -> 7224;
7661 -> 7224;
7662 -> 0;
7662 -> 7224;
7663 -> 7224;
7664 -> 7224;
7665 -> 7224;
7666 -> 7665;
7666 -> 7662;
7666 -> 7224;
7667 -> 7666;
7667 -> 7224;
7668 -> 7224;
7669 -> 7224;
7670 -> 7664;
7670 -> 7669;
7670 -> 7224;
7671 -> 0;
7671 -> 7670;
7672 -> 7224;
7673 -> 7671;
7673 -> 0;
7673 -> 7224;
7674 -> 7667;
7674 -> 0;
7674 -> 7673;
7675 -> 7673;
7676 -> 7672;
7676 -> 7224;
7677 -> 7672;
7677 -> 7224;
7678 -> 7672;
7678 -> 7224;
7679 -> 7678;
7679 -> 7662;
7679 -> 7672;
7680 -> 7679;
7680 -> 7672;
7681 -> 7672;
7682 -> 7680;
7682 -> 0;
7682 -> 7673;
7683 -> 7672;
7684 -> 7672;
7685 -> 7672;
7686 -> 7672;
7687 -> 7685;
7687 -> 7686;
7688 -> 7224;
7688 -> 7686;
7689 -> 7688;
7689 -> 7672;
7689 -> 7686;
7690 -> 7686;
7691 -> 7689;
7692 -> 7672;
7693 -> 7672;
7694 -> 7672;
7695 -> 7693;
7695 -> 7694;
7696 -> 7224;
7696 -> 7694;
7697 -> 7696;
7697 -> 7672;
7697 -> 7694;
7698 -> 7694;
7699 -> 7697;
7700 -> 7584;
7701 -> 7598;
7701 -> 7672;
7701 -> 7700;
7701 -> 7584;
7702 -> 7589;
7702 -> 7584;
7703 -> 7584;
7704 -> 7587;
7704 -> 7703;
7704 -> 7584;
7705 -> 7704;
7706 -> 7705;
7707 -> 7706;
7708 -> 7672;
7709 -> 7672;
7710 -> 7672;
7711 -> 7580;
7711 -> 7235;
7712 -> 7235;
7713 -> 7224;
7713 -> 7235;
7714 -> 7224;
7714 -> 7235;
7715 -> 7224;
7715 -> 7235;
7716 -> 7224;
7716 -> 7235;
7717 -> 7235;
7718 -> 7716;
7718 -> 7672;
7718 -> 7717;
7718 -> 7235;
7719 -> 7713;
7719 -> 7235;
7720 -> 7235;
7721 -> 7719;
7721 -> 7720;
7722 -> 7716;
7722 -> 7720;
7723 -> 7720;
7724 -> 7722;
7724 -> 7672;
7724 -> 7723;
7724 -> 7720;
7725 -> 7235;
7726 -> 7235;
7727 -> 7726;
7728 -> 7727;
7729 -> 7728;
7730 -> 7672;
7730 -> 7728;
7731 -> 7726;
7732 -> 7235;
7733 -> 7732;
7734 -> 7672;
7734 -> 7732;
7735 -> 7235;
7736 -> 7224;
7736 -> 7235;
7737 -> 7224;
7737 -> 7235;
7738 -> 7235;
7739 -> 7737;
7739 -> 7738;
7740 -> 7739;
7740 -> 7672;
7740 -> 7738;
7741 -> 7740;
7741 -> 7235;
7742 -> 7741;
7742 -> 7672;
7742 -> 7235;
7743 -> 7235;
7744 -> 7224;
7744 -> 7235;
7745 -> 7224;
7745 -> 7235;
7746 -> 7235;
7747 -> 7224;
7747 -> 7235;
7748 -> 7747;
7748 -> 7672;
7748 -> 7235;
7749 -> 7235;
7750 -> 7235;
7751 -> 7235;
7752 -> 7235;
7753 -> 7224;
7753 -> 7235;
7754 -> 7235;
7755 -> 7235;
7756 -> 7224;
7756 -> 7672;
7756 -> 7235;
7757 -> 7235;
7758 -> 7757;
7759 -> 7758;
7760 -> 7759;
7761 -> 7672;
7761 -> 7759;
7762 -> 7757;
7763 -> 7672;
7763 -> 7235;
7764 -> 7235;
7765 -> 7224;
7765 -> 7235;
7766 -> 7235;
7767 -> 7766;
7768 -> 7767;
7769 -> 7768;
7770 -> 7672;
7770 -> 7768;
7771 -> 7766;
7772 -> 7672;
7772 -> 7235;
7773 -> 7772;
7773 -> 7765;
7773 -> 7672;
7773 -> 7235;
7774 -> 7235;
7775 -> 7774;
7775 -> 7235;
7776 -> 7235;
7777 -> 7224;
7777 -> 7672;
7778 -> 7224;
7778 -> 7235;
7779 -> 7224;
7779 -> 7235;
7780 -> 7235;
7781 -> 7235;
7782 -> 7235;
7783 -> 7235;
7784 -> 7224;
7784 -> 7235;
7785 -> 7224;
7785 -> 7235;
7786 -> 7235;
7787 -> 7785;
7787 -> 7786;
7787 -> 7235;
7788 -> 7784;
7788 -> 7672;
7789 -> 7785;
7789 -> 7672;
7790 -> 7788;
7790 -> 7672;
7791 -> 7789;
7791 -> 7672;
7792 -> 7672;
7793 -> 7672;
7794 -> 7672;
7795 -> 7791;
7795 -> 7794;
7795 -> 7672;
7796 -> 7672;
7797 -> 7672;
7797 -> 7796;
7798 -> 7672;
7798 -> 0;
7799 -> 7672;
7800 -> 7793;
7800 -> 7799;
7801 -> 7800;
7802 -> 7800;
7803 -> 7672;
7803 -> 7800;
7804 -> 7800;
7805 -> 7803;
7805 -> 7804;
7806 -> 7804;
7807 -> 7805;
7807 -> 7806;
7808 -> 7806;
7809 -> 7807;
7809 -> 7808;
7809 -> 7806;
7810 -> 7806;
7811 -> 7810;
7811 -> 7804;
7812 -> 7672;
7812 -> 7811;
7813 -> 7672;
7814 -> 7224;
7814 -> 7235;
7815 -> 7224;
7815 -> 7672;
7815 -> 7235;
7816 -> 7224;
7816 -> 7235;
7817 -> 7235;
7818 -> 7224;
7818 -> 7817;
7818 -> 7235;
7819 -> 7235;
7820 -> 7819;
7820 -> 7235;
7821 -> 7235;
7822 -> 7814;
7822 -> 7821;
7823 -> 7821;
7824 -> 7672;
7825 -> 7672;
7826 -> 7822;
7826 -> 7672;
7827 -> 7672;
7828 -> 7826;
7828 -> 7672;
7829 -> 7224;
7829 -> 7672;
7830 -> 7829;
7830 -> 7672;
7831 -> 7672;
7832 -> 7827;
7832 -> 7831;
7833 -> 7832;
7833 -> 7672;
7834 -> 7830;
7834 -> 7672;
7835 -> 7829;
7835 -> 7672;
7835 -> 0;
7836 -> 7672;
7837 -> 7829;
7837 -> 7672;
7837 -> 7836;
7838 -> 7224;
7838 -> 7235;
7839 -> 7224;
7839 -> 7672;
7839 -> 7235;
7840 -> 7672;
7841 -> 7672;
7842 -> 7672;
7843 -> 7672;
7844 -> 7672;
7844 -> 7843;
7845 -> 7672;
7845 -> 7843;
7846 -> 7842;
7846 -> 7843;
7847 -> 7843;
7848 -> 7845;
7848 -> 7847;
7848 -> 7843;
7849 -> 7672;
7850 -> 7672;
7851 -> 7224;
7851 -> 7235;
7852 -> 0;
7852 -> 7235;
7853 -> 7224;
7853 -> 7235;
7854 -> 7235;
7855 -> 7224;
7855 -> 7235;
7856 -> 7235;
7857 -> 7224;
7857 -> 0;
7857 -> 7672;
7858 -> 7235;
7859 -> 7235;
7860 -> 7235;
7861 -> 7235;
7862 -> 7224;
7862 -> 7672;
7863 -> 7672;
7864 -> 7862;
7864 -> 7672;
7864 -> 7863;
7865 -> 7672;
7866 -> 7672;
7867 -> 7672;
7868 -> 7672;
7869 -> 7672;
7870 -> 7869;
7870 -> 7672;
7870 -> 7863;
7871 -> 7858;
7871 -> 7235;
7872 -> 7235;
7873 -> 7872;
7874 -> 7672;
7874 -> 7872;
7875 -> 7226;
7875 -> 7223;
7876 -> 7223;
7877 -> 7875;
7877 -> 7876;
7878 -> 7877;
7878 -> 7876;
7879 -> 7876;
7880 -> 7878;
7880 -> 7879;
7881 -> 7880;
7881 -> 7879;
7882 -> 7879;
7883 -> 7879;
7884 -> 7881;
7884 -> 7883;
7885 -> 7882;
7885 -> 7883;
7886 -> 7883;
7887 -> 7884;
7887 -> 7886;
7887 -> 7883;
7888 -> 7884;
7888 -> 7883;
7889 -> 7884;
7889 -> 7883;
7890 -> 7885;
7890 -> 7888;
7890 -> 7889;
7890 -> 7883;
7891 -> 7884;
7891 -> 7883;
7892 -> 7883;
7893 -> 7672;
7893 -> 7892;
7893 -> 7883;
7894 -> 7883;
7895 -> 7884;
7895 -> 7883;
7896 -> 7883;
7897 -> 7895;
7897 -> 7896;
7898 -> 7896;
7899 -> 7896;
7900 -> 7672;
7900 -> 7896;
7901 -> 7900;
7901 -> 7896;
7902 -> 7899;
7902 -> 7901;
7903 -> 7902;
7903 -> 7898;
7903 -> 7896;
7904 -> 7902;
7904 -> 7898;
7904 -> 7896;
7905 -> 7904;
7905 -> 7896;
7906 -> 7897;
7906 -> 7896;
7907 -> 7897;
7907 -> 7896;
7908 -> 7897;
7908 -> 7896;
7909 -> 7896;
7910 -> 7908;
7910 -> 7909;
7911 -> 2395;
7911 -> 7909;
7912 -> 7909;
7913 -> 7910;
7913 -> 7909;
7914 -> 7909;
7915 -> 7914;
7915 -> 7896;
7916 -> 7915;
7917 -> 7916;
7918 -> 2395;
7918 -> 7916;
7919 -> 7896;
7920 -> 7919;
7920 -> 7896;
7921 -> 7896;
7922 -> 7896;
7923 -> 7919;
7923 -> 7922;
7923 -> 7920;
7923 -> 7896;
7924 -> 7896;
7925 -> 7897;
7925 -> 7896;
7926 -> 7919;
7926 -> 7896;
7927 -> 7924;
7927 -> 7896;
7928 -> 7896;
7929 -> 7926;
7929 -> 7928;
7930 -> 7927;
7930 -> 7928;
7931 -> 7930;
7931 -> 7924;
7931 -> 7928;
7932 -> 7928;
7933 -> 7932;
7933 -> 7931;
7933 -> 7928;
7934 -> 7896;
7935 -> 7896;
7936 -> 7919;
7936 -> 7935;
7936 -> 7923;
7936 -> 7896;
7937 -> 7896;
7938 -> 7896;
7939 -> 7896;
7940 -> 7938;
7940 -> 7939;
7940 -> 7896;
7941 -> 7896;
7942 -> 7919;
7942 -> 7941;
7942 -> 7936;
7942 -> 7896;
7943 -> 7924;
7943 -> 7896;
7944 -> 7937;
7944 -> 7896;
7945 -> 0;
7945 -> 7896;
7946 -> 7896;
7947 -> 7896;
7948 -> 7943;
7948 -> 7947;
7949 -> 7944;
7949 -> 7947;
7950 -> 7945;
7950 -> 7947;
7951 -> 7946;
7951 -> 7947;
7952 -> 7946;
7952 -> 7947;
7953 -> 7947;
7954 -> 7951;
7954 -> 7953;
7954 -> 7947;
7955 -> 7954;
7955 -> 7947;
7956 -> 6939;
7956 -> 7955;
7957 -> 7947;
7958 -> 7957;
7958 -> 7952;
7958 -> 7947;
7959 -> 7948;
7959 -> 7947;
7960 -> 7949;
7960 -> 7947;
7961 -> 7950;
7961 -> 7947;
7962 -> 7959;
7962 -> 7947;
7963 -> 7960;
7963 -> 7947;
7964 -> 7958;
7964 -> 7947;
7965 -> 7947;
7966 -> 7962;
7966 -> 7965;
7967 -> 7963;
7967 -> 7965;
7968 -> 7964;
7968 -> 7965;
7969 -> 7956;
7969 -> 7965;
7970 -> 7966;
7970 -> 7965;
7971 -> 7966;
7971 -> 7959;
7971 -> 7965;
7972 -> 7967;
7972 -> 7965;
7973 -> 7967;
7973 -> 7960;
7973 -> 7965;
7974 -> 7965;
7975 -> 7970;
7975 -> 7974;
7976 -> 7971;
7976 -> 7974;
7977 -> 7972;
7977 -> 7974;
7978 -> 7973;
7978 -> 7974;
7979 -> 7969;
7979 -> 7974;
7980 -> 7975;
7980 -> 7974;
7981 -> 7976;
7981 -> 7974;
7982 -> 7977;
7982 -> 7974;
7983 -> 7978;
7983 -> 7974;
7984 -> 7974;
7985 -> 7980;
7985 -> 7984;
7986 -> 7981;
7986 -> 7984;
7987 -> 7982;
7987 -> 7984;
7988 -> 7983;
7988 -> 7984;
7989 -> 7979;
7989 -> 7984;
7990 -> 7984;
7991 -> 7986;
7991 -> 7990;
7991 -> 7984;
7992 -> 7984;
7993 -> 7988;
7993 -> 7992;
7993 -> 7984;
7994 -> 7991;
7994 -> 7993;
7994 -> 7984;
7995 -> 7984;
7996 -> 7995;
7996 -> 7994;
7996 -> 7984;
7997 -> 7984;
7998 -> 7997;
7998 -> 7986;
7998 -> 7984;
7999 -> 7984;
8000 -> 7999;
8000 -> 7988;
8000 -> 7984;
8001 -> 7984;
8002 -> 8001;
8002 -> 7986;
8002 -> 7984;
8003 -> 7994;
8003 -> 7984;
8004 -> 7976;
8004 -> 7974;
8005 -> 7978;
8005 -> 7974;
8006 -> 7974;
8007 -> 8004;
8007 -> 8006;
8007 -> 7974;
8008 -> 7974;
8009 -> 8004;
8009 -> 8008;
8009 -> 7974;
8010 -> 7974;
8011 -> 8005;
8011 -> 8010;
8011 -> 7974;
8012 -> 7974;
8013 -> 8012;
8013 -> 7965;
8014 -> 7965;
8015 -> 8014;
8015 -> 7947;
8016 -> 7961;
8016 -> 8015;
8016 -> 7947;
8017 -> 7919;
8017 -> 8016;
8017 -> 7942;
8017 -> 7896;
8018 -> 7937;
8018 -> 7896;
8019 -> 7924;
8019 -> 7896;
8020 -> 7919;
8020 -> 8017;
8020 -> 7896;
8021 -> 8020;
8021 -> 7883;
8022 -> 7876;
8023 -> 7224;
8023 -> 7223;
}