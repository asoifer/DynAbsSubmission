digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 159798"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 159799"];
3 [label="RuntimeHelpers.RunModuleConstructor(typeof(TestBase).Module.ModuleHandle); 159800"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 159801"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 159802"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 159803"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 159804"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 159805"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 159806"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 159807"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 159808"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 159809"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 159810"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 159811"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 159812"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 159813"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 159814"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 159815"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 159816"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 159817"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 159818"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 159819"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 159820"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 159821"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 159822"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 159823"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 159824"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 159825"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 159826"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 159827"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 159828"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 159829"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 159830"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 159831"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 159832"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 159833"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 159834"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 159835"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 159836"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 159837"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 159838"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 159839"];
43 [label="LazyThreadSafetyMode.PublicationOnly 159840"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 159841"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 159842"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 159843"];
47 [label="LazyThreadSafetyMode.PublicationOnly 159844"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 159845"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 159846"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 159847"];
51 [label="'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' 159848"];
52 [label="new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51') 159849"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 159850"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 159851"];
55 [label="LazyThreadSafetyMode.PublicationOnly 159852"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 159853"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 159854"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 159855"];
59 [label="LazyThreadSafetyMode.PublicationOnly 159856"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 159857"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 159858"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 159859"];
63 [label="LazyThreadSafetyMode.PublicationOnly 159860"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 159861"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 159862"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 159863"];
67 [label="LazyThreadSafetyMode.PublicationOnly 159864"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159865"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159866"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 159867"];
71 [label="LazyThreadSafetyMode.PublicationOnly 159868"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159869"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159870"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 159871"];
75 [label="LazyThreadSafetyMode.PublicationOnly 159872"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159873"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159874"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 159875"];
79 [label="LazyThreadSafetyMode.PublicationOnly 159876"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159877"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159878"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 159879"];
83 [label="LazyThreadSafetyMode.PublicationOnly 159880"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159881"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159882"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 159883"];
87 [label="LazyThreadSafetyMode.PublicationOnly 159884"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159885"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159886"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 159887"];
91 [label="LazyThreadSafetyMode.PublicationOnly 159888"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159889"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159890"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 159891"];
95 [label="LazyThreadSafetyMode.PublicationOnly 159892"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 159893"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 159894"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 159895"];
99 [label="LazyThreadSafetyMode.PublicationOnly 159896"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 159897"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 159898"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 159899"];
103 [label="LazyThreadSafetyMode.PublicationOnly 159900"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159901"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159902"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 159903"];
107 [label="LazyThreadSafetyMode.PublicationOnly 159904"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159905"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159906"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 159907"];
111 [label="LazyThreadSafetyMode.PublicationOnly 159908"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159909"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159910"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 159911"];
115 [label="LazyThreadSafetyMode.PublicationOnly 159912"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159913"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159914"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 159915"];
119 [label="LazyThreadSafetyMode.PublicationOnly 159916"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 159917"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 159918"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 159919"];
123 [label="LazyThreadSafetyMode.PublicationOnly 159920"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159921"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159922"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 159923"];
127 [label="LazyThreadSafetyMode.PublicationOnly 159924"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159925"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159926"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 159927"];
131 [label="LazyThreadSafetyMode.PublicationOnly 159928"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159929"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159930"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 159931"];
135 [label="LazyThreadSafetyMode.PublicationOnly 159932"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159933"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159934"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 159935"];
139 [label="LazyThreadSafetyMode.PublicationOnly 159936"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159937"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159938"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 159939"];
143 [label="LazyThreadSafetyMode.PublicationOnly 159940"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159941"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159942"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 159943"];
147 [label="LazyThreadSafetyMode.PublicationOnly 159944"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159945"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159946"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 159947"];
151 [label="LazyThreadSafetyMode.PublicationOnly 159948"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159949"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159950"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 159951"];
155 [label="LazyThreadSafetyMode.PublicationOnly 159952"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159953"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159954"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 159955"];
159 [label="LazyThreadSafetyMode.PublicationOnly 159956"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159957"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159958"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 159959"];
163 [label="LazyThreadSafetyMode.PublicationOnly 159960"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159961"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159962"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 159963"];
167 [label="LazyThreadSafetyMode.PublicationOnly 159964"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159965"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159966"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 159967"];
171 [label="LazyThreadSafetyMode.PublicationOnly 159968"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159969"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 159970"];
174 [label="@'R:\\Invalid.dll' 159971"];
175 [label="fullPath: @'R:\\Invalid.dll' 159972"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 159973"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 159974"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 159975"];
179 [label="MscorlibRef_v4_0_30316_17626 159976"];
180 [label="Net451.mscorlib 159977"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 159978"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 159979"];
183 [label="'/*<bind>*/' 159980"];
184 [label="StartString = '/*<bind>*/' 159981"];
185 [label="'/*</bind>*/' 159982"];
186 [label="EndString = '/*</bind>*/' 159983"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 159984"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 159985"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 159986"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 159987"];
191 [label="param StatementParsingTests(ITestOutputHelper output) 159988"];
192 [label="param StatementParsingTests(this) 159989"];
193 [label="output 159990"];
194 [label="param ParsingTests(ITestOutputHelper output) 159991"];
195 [label="param ParsingTests(this) 159992"];
196 [label="param CSharpTestBase(this) 159993"];
197 [label="param CommonTestBase(this) 159994"];
198 [label="param TestBase(this) 159995"];
199 [label="_temp 159996"];
200 [label="_node 159997"];
201 [label="_treeEnumerator 159998"];
202 [label="_output 159999"];
203 [label="this._output 160000"];
204 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 160001"];
205 [label="param TestSwitchWithMultipleLabelsOnOneCase(this) 160002"];
206 [label="var text = 'switch (a) { case b: case c:; }'; 160003"];
207 [label="var statement = this.ParseStatement(text); 160004"];
208 [label="var statement = this.ParseStatement(text); 160005"];
209 [label="this.ParseStatement(text) 160006"];
210 [label="param ParseStatement(string text) 160007"];
211 [label="param ParseStatement(int offset = 0) 160008"];
212 [label="param ParseStatement(ParseOptions options = null) 160009"];
213 [label="param ParseStatement(this) 160010"];
214 [label="'\\r\\n' 160011"];
215 [label="CrLf = '\\r\\n' 160012"];
216 [label="CrLf 160013"];
217 [label="EndOfLine(CrLf) 160014"];
218 [label="param EndOfLine(string text) 160015"];
219 [label="param EndOfLine(bool elastic = false) 160016"];
220 [label="SyntaxTrivia trivia = null; 160017"];
221 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 160018"];
222 [label="elastic 160019"];
223 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 160020"];
224 [label="if (trivia != null)\n            {\n                return trivia;\n            } 160021"];
225 [label="if (trivia != null)\n            {\n                return trivia;\n            } 160022"];
226 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTrivia), r => new SyntaxTrivia(r)); 160023"];
227 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160024"];
228 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160025"];
229 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 160026"];
230 [label="param Create(SyntaxKind kind) 160027"];
231 [label="param Create(string text) 160028"];
232 [label="return new SyntaxTrivia(kind, text); 160029"];
233 [label="return new SyntaxTrivia(kind, text); 160030"];
234 [label="return new SyntaxTrivia(kind, text); 160031"];
235 [label="new SyntaxTrivia(kind, text) 160032"];
236 [label="param SyntaxTrivia(SyntaxKind kind) 160033"];
237 [label="param SyntaxTrivia(string text) 160034"];
238 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 160035"];
239 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 160036"];
240 [label="param SyntaxTrivia(this) 160037"];
241 [label="kind 160038"];
242 [label="diagnostics 160039"];
243 [label="annotations 160040"];
244 [label="new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 160041"];
245 [label="s_structuresTable\n            = new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 160042"];
246 [label="text 160043"];
247 [label="param SyntaxTrivia(this) 160044"];
248 [label="param CSharpSyntaxNode(SyntaxKind kind) 160045"];
249 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 160046"];
250 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 160047"];
251 [label="param CSharpSyntaxNode(int fullWidth) 160048"];
252 [label="param CSharpSyntaxNode(this) 160049"];
253 [label="kind 160050"];
254 [label="diagnostics 160051"];
255 [label="annotations 160052"];
256 [label="fullWidth 160053"];
257 [label="param CSharpSyntaxNode(this) 160054"];
258 [label="param CSharpSyntaxNode(this) 160055"];
259 [label="GreenStats.NoteGreen(this); 160056"];
260 [label="GreenStats.NoteGreen(this); 160057"];
261 [label="Text 160058"];
262 [label="this.Text 160059"];
263 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160060"];
264 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160061"];
265 [label="if (!elastic)\n            {\n                return trivia;\n            } 160062"];
266 [label="return trivia; 160063"];
267 [label="CarriageReturnLineFeed = EndOfLine(CrLf) 160064"];
268 [label="'\\n' 160065"];
269 [label="EndOfLine('\\n') 160066"];
270 [label="param EndOfLine(string text) 160067"];
271 [label="param EndOfLine(bool elastic = false) 160068"];
272 [label="SyntaxTrivia trivia = null; 160069"];
273 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 160070"];
274 [label="elastic 160071"];
275 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 160072"];
276 [label="if (trivia != null)\n            {\n                return trivia;\n            } 160073"];
277 [label="if (trivia != null)\n            {\n                return trivia;\n            } 160074"];
278 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160075"];
279 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160076"];
280 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 160077"];
281 [label="param Create(SyntaxKind kind) 160078"];
282 [label="param Create(string text) 160079"];
283 [label="return new SyntaxTrivia(kind, text); 160080"];
284 [label="return new SyntaxTrivia(kind, text); 160081"];
285 [label="return new SyntaxTrivia(kind, text); 160082"];
286 [label="new SyntaxTrivia(kind, text) 160083"];
287 [label="param SyntaxTrivia(SyntaxKind kind) 160084"];
288 [label="param SyntaxTrivia(string text) 160085"];
289 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 160086"];
290 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 160087"];
291 [label="param SyntaxTrivia(this) 160088"];
292 [label="kind 160089"];
293 [label="diagnostics 160090"];
294 [label="annotations 160091"];
295 [label="text 160092"];
296 [label="param SyntaxTrivia(this) 160093"];
297 [label="param CSharpSyntaxNode(SyntaxKind kind) 160094"];
298 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 160095"];
299 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 160096"];
300 [label="param CSharpSyntaxNode(int fullWidth) 160097"];
301 [label="param CSharpSyntaxNode(this) 160098"];
302 [label="kind 160099"];
303 [label="diagnostics 160100"];
304 [label="annotations 160101"];
305 [label="fullWidth 160102"];
306 [label="param CSharpSyntaxNode(this) 160103"];
307 [label="param CSharpSyntaxNode(this) 160104"];
308 [label="GreenStats.NoteGreen(this); 160105"];
309 [label="GreenStats.NoteGreen(this); 160106"];
310 [label="Text 160107"];
311 [label="this.Text 160108"];
312 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160109"];
313 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160110"];
314 [label="if (!elastic)\n            {\n                return trivia;\n            } 160111"];
315 [label="return trivia; 160112"];
316 [label="LineFeed = EndOfLine('\\n') 160113"];
317 [label="'\\r' 160114"];
318 [label="EndOfLine('\\r') 160115"];
319 [label="param EndOfLine(string text) 160116"];
320 [label="param EndOfLine(bool elastic = false) 160117"];
321 [label="SyntaxTrivia trivia = null; 160118"];
322 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 160119"];
323 [label="elastic 160120"];
324 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 160121"];
325 [label="if (trivia != null)\n            {\n                return trivia;\n            } 160122"];
326 [label="if (trivia != null)\n            {\n                return trivia;\n            } 160123"];
327 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160124"];
328 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160125"];
329 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 160126"];
330 [label="param Create(SyntaxKind kind) 160127"];
331 [label="param Create(string text) 160128"];
332 [label="return new SyntaxTrivia(kind, text); 160129"];
333 [label="return new SyntaxTrivia(kind, text); 160130"];
334 [label="return new SyntaxTrivia(kind, text); 160131"];
335 [label="new SyntaxTrivia(kind, text) 160132"];
336 [label="param SyntaxTrivia(SyntaxKind kind) 160133"];
337 [label="param SyntaxTrivia(string text) 160134"];
338 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 160135"];
339 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 160136"];
340 [label="param SyntaxTrivia(this) 160137"];
341 [label="kind 160138"];
342 [label="diagnostics 160139"];
343 [label="annotations 160140"];
344 [label="text 160141"];
345 [label="param SyntaxTrivia(this) 160142"];
346 [label="param CSharpSyntaxNode(SyntaxKind kind) 160143"];
347 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 160144"];
348 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 160145"];
349 [label="param CSharpSyntaxNode(int fullWidth) 160146"];
350 [label="param CSharpSyntaxNode(this) 160147"];
351 [label="kind 160148"];
352 [label="diagnostics 160149"];
353 [label="annotations 160150"];
354 [label="fullWidth 160151"];
355 [label="param CSharpSyntaxNode(this) 160152"];
356 [label="param CSharpSyntaxNode(this) 160153"];
357 [label="GreenStats.NoteGreen(this); 160154"];
358 [label="GreenStats.NoteGreen(this); 160155"];
359 [label="Text 160156"];
360 [label="this.Text 160157"];
361 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160158"];
362 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160159"];
363 [label="if (!elastic)\n            {\n                return trivia;\n            } 160160"];
364 [label="return trivia; 160161"];
365 [label="CarriageReturn = EndOfLine('\\r') 160162"];
366 [label="' ' 160163"];
367 [label="Whitespace(' ') 160164"];
368 [label="param Whitespace(string text) 160165"];
369 [label="param Whitespace(bool elastic = false) 160166"];
370 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160167"];
371 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160168"];
372 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 160169"];
373 [label="param Create(SyntaxKind kind) 160170"];
374 [label="param Create(string text) 160171"];
375 [label="return new SyntaxTrivia(kind, text); 160172"];
376 [label="return new SyntaxTrivia(kind, text); 160173"];
377 [label="return new SyntaxTrivia(kind, text); 160174"];
378 [label="new SyntaxTrivia(kind, text) 160175"];
379 [label="param SyntaxTrivia(SyntaxKind kind) 160176"];
380 [label="param SyntaxTrivia(string text) 160177"];
381 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 160178"];
382 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 160179"];
383 [label="param SyntaxTrivia(this) 160180"];
384 [label="kind 160181"];
385 [label="diagnostics 160182"];
386 [label="annotations 160183"];
387 [label="text 160184"];
388 [label="param SyntaxTrivia(this) 160185"];
389 [label="param CSharpSyntaxNode(SyntaxKind kind) 160186"];
390 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 160187"];
391 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 160188"];
392 [label="param CSharpSyntaxNode(int fullWidth) 160189"];
393 [label="param CSharpSyntaxNode(this) 160190"];
394 [label="kind 160191"];
395 [label="diagnostics 160192"];
396 [label="annotations 160193"];
397 [label="fullWidth 160194"];
398 [label="param CSharpSyntaxNode(this) 160195"];
399 [label="param CSharpSyntaxNode(this) 160196"];
400 [label="GreenStats.NoteGreen(this); 160197"];
401 [label="GreenStats.NoteGreen(this); 160198"];
402 [label="Text 160199"];
403 [label="this.Text 160200"];
404 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160201"];
405 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160202"];
406 [label="if (!elastic)\n            {\n                return trivia;\n            } 160203"];
407 [label="return trivia; 160204"];
408 [label="Space = Whitespace(' ') 160205"];
409 [label="'\\t' 160206"];
410 [label="Whitespace('\\t') 160207"];
411 [label="param Whitespace(string text) 160208"];
412 [label="param Whitespace(bool elastic = false) 160209"];
413 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160210"];
414 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160211"];
415 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 160212"];
416 [label="param Create(SyntaxKind kind) 160213"];
417 [label="param Create(string text) 160214"];
418 [label="return new SyntaxTrivia(kind, text); 160215"];
419 [label="return new SyntaxTrivia(kind, text); 160216"];
420 [label="return new SyntaxTrivia(kind, text); 160217"];
421 [label="new SyntaxTrivia(kind, text) 160218"];
422 [label="param SyntaxTrivia(SyntaxKind kind) 160219"];
423 [label="param SyntaxTrivia(string text) 160220"];
424 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 160221"];
425 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 160222"];
426 [label="param SyntaxTrivia(this) 160223"];
427 [label="kind 160224"];
428 [label="diagnostics 160225"];
429 [label="annotations 160226"];
430 [label="text 160227"];
431 [label="param SyntaxTrivia(this) 160228"];
432 [label="param CSharpSyntaxNode(SyntaxKind kind) 160229"];
433 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 160230"];
434 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 160231"];
435 [label="param CSharpSyntaxNode(int fullWidth) 160232"];
436 [label="param CSharpSyntaxNode(this) 160233"];
437 [label="kind 160234"];
438 [label="diagnostics 160235"];
439 [label="annotations 160236"];
440 [label="fullWidth 160237"];
441 [label="param CSharpSyntaxNode(this) 160238"];
442 [label="param CSharpSyntaxNode(this) 160239"];
443 [label="GreenStats.NoteGreen(this); 160240"];
444 [label="GreenStats.NoteGreen(this); 160241"];
445 [label="Text 160242"];
446 [label="this.Text 160243"];
447 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160244"];
448 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160245"];
449 [label="if (!elastic)\n            {\n                return trivia;\n            } 160246"];
450 [label="return trivia; 160247"];
451 [label="Tab = Whitespace('\\t') 160248"];
452 [label="CrLf 160249"];
453 [label="true 160250"];
454 [label="elastic: true 160251"];
455 [label="EndOfLine(CrLf, elastic: true) 160252"];
456 [label="param EndOfLine(string text) 160253"];
457 [label="param EndOfLine(bool elastic = false) 160254"];
458 [label="SyntaxTrivia trivia = null; 160255"];
459 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 160256"];
460 [label="elastic 160257"];
461 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 160258"];
462 [label="if (trivia != null)\n            {\n                return trivia;\n            } 160259"];
463 [label="if (trivia != null)\n            {\n                return trivia;\n            } 160260"];
464 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160261"];
465 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160262"];
466 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 160263"];
467 [label="param Create(SyntaxKind kind) 160264"];
468 [label="param Create(string text) 160265"];
469 [label="return new SyntaxTrivia(kind, text); 160266"];
470 [label="return new SyntaxTrivia(kind, text); 160267"];
471 [label="return new SyntaxTrivia(kind, text); 160268"];
472 [label="new SyntaxTrivia(kind, text) 160269"];
473 [label="param SyntaxTrivia(SyntaxKind kind) 160270"];
474 [label="param SyntaxTrivia(string text) 160271"];
475 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 160272"];
476 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 160273"];
477 [label="param SyntaxTrivia(this) 160274"];
478 [label="kind 160275"];
479 [label="diagnostics 160276"];
480 [label="annotations 160277"];
481 [label="text 160278"];
482 [label="param SyntaxTrivia(this) 160279"];
483 [label="param CSharpSyntaxNode(SyntaxKind kind) 160280"];
484 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 160281"];
485 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 160282"];
486 [label="param CSharpSyntaxNode(int fullWidth) 160283"];
487 [label="param CSharpSyntaxNode(this) 160284"];
488 [label="kind 160285"];
489 [label="diagnostics 160286"];
490 [label="annotations 160287"];
491 [label="fullWidth 160288"];
492 [label="param CSharpSyntaxNode(this) 160289"];
493 [label="param CSharpSyntaxNode(this) 160290"];
494 [label="GreenStats.NoteGreen(this); 160291"];
495 [label="GreenStats.NoteGreen(this); 160292"];
496 [label="Text 160293"];
497 [label="this.Text 160294"];
498 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160295"];
499 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160296"];
500 [label="if (!elastic)\n            {\n                return trivia;\n            } 160297"];
501 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160298"];
502 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160299"];
503 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 160300"];
504 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160301"];
505 [label="param SetAnnotations(SyntaxAnnotation[]? annotations) 160302"];
506 [label="param SetAnnotations(this) 160303"];
507 [label="this.Kind 160304"];
508 [label="get { return (SyntaxKind)this.RawKind; } 160305"];
509 [label="return (SyntaxKind)this.RawKind; 160306"];
510 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 160307"];
511 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 160308"];
512 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 160309"];
513 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 160310"];
514 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 160311"];
515 [label="param SyntaxTrivia(SyntaxKind kind) 160312"];
516 [label="param SyntaxTrivia(string text) 160313"];
517 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 160314"];
518 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 160315"];
519 [label="param SyntaxTrivia(this) 160316"];
520 [label="param SyntaxTrivia(this) 160317"];
521 [label="param CSharpSyntaxNode(this) 160318"];
522 [label="param CSharpSyntaxNode(this) 160319"];
523 [label="param CSharpSyntaxNode(this) 160320"];
524 [label="GreenStats.NoteGreen(this); 160321"];
525 [label="Text 160322"];
526 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160323"];
527 [label="ElasticCarriageReturnLineFeed = EndOfLine(CrLf, elastic: true) 160324"];
528 [label="'\\n' 160325"];
529 [label="true 160326"];
530 [label="elastic: true 160327"];
531 [label="EndOfLine('\\n', elastic: true) 160328"];
532 [label="param EndOfLine(string text) 160329"];
533 [label="param EndOfLine(bool elastic = false) 160330"];
534 [label="SyntaxTrivia trivia = null; 160331"];
535 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 160332"];
536 [label="elastic 160333"];
537 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 160334"];
538 [label="if (trivia != null)\n            {\n                return trivia;\n            } 160335"];
539 [label="if (trivia != null)\n            {\n                return trivia;\n            } 160336"];
540 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160337"];
541 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160338"];
542 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 160339"];
543 [label="param Create(SyntaxKind kind) 160340"];
544 [label="param Create(string text) 160341"];
545 [label="return new SyntaxTrivia(kind, text); 160342"];
546 [label="return new SyntaxTrivia(kind, text); 160343"];
547 [label="return new SyntaxTrivia(kind, text); 160344"];
548 [label="new SyntaxTrivia(kind, text) 160345"];
549 [label="param SyntaxTrivia(SyntaxKind kind) 160346"];
550 [label="param SyntaxTrivia(string text) 160347"];
551 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 160348"];
552 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 160349"];
553 [label="param SyntaxTrivia(this) 160350"];
554 [label="kind 160351"];
555 [label="diagnostics 160352"];
556 [label="annotations 160353"];
557 [label="text 160354"];
558 [label="param SyntaxTrivia(this) 160355"];
559 [label="param CSharpSyntaxNode(SyntaxKind kind) 160356"];
560 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 160357"];
561 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 160358"];
562 [label="param CSharpSyntaxNode(int fullWidth) 160359"];
563 [label="param CSharpSyntaxNode(this) 160360"];
564 [label="kind 160361"];
565 [label="diagnostics 160362"];
566 [label="annotations 160363"];
567 [label="fullWidth 160364"];
568 [label="param CSharpSyntaxNode(this) 160365"];
569 [label="param CSharpSyntaxNode(this) 160366"];
570 [label="GreenStats.NoteGreen(this); 160367"];
571 [label="GreenStats.NoteGreen(this); 160368"];
572 [label="Text 160369"];
573 [label="this.Text 160370"];
574 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160371"];
575 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160372"];
576 [label="if (!elastic)\n            {\n                return trivia;\n            } 160373"];
577 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160374"];
578 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160375"];
579 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 160376"];
580 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160377"];
581 [label="this.Kind 160378"];
582 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 160379"];
583 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 160380"];
584 [label="param SyntaxTrivia(this) 160381"];
585 [label="param SyntaxTrivia(this) 160382"];
586 [label="param CSharpSyntaxNode(this) 160383"];
587 [label="param CSharpSyntaxNode(this) 160384"];
588 [label="GreenStats.NoteGreen(this); 160385"];
589 [label="Text 160386"];
590 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160387"];
591 [label="ElasticLineFeed = EndOfLine('\\n', elastic: true) 160388"];
592 [label="'\\r' 160389"];
593 [label="true 160390"];
594 [label="elastic: true 160391"];
595 [label="EndOfLine('\\r', elastic: true) 160392"];
596 [label="param EndOfLine(string text) 160393"];
597 [label="param EndOfLine(bool elastic = false) 160394"];
598 [label="SyntaxTrivia trivia = null; 160395"];
599 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 160396"];
600 [label="elastic 160397"];
601 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 160398"];
602 [label="if (trivia != null)\n            {\n                return trivia;\n            } 160399"];
603 [label="if (trivia != null)\n            {\n                return trivia;\n            } 160400"];
604 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160401"];
605 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160402"];
606 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 160403"];
607 [label="param Create(SyntaxKind kind) 160404"];
608 [label="param Create(string text) 160405"];
609 [label="return new SyntaxTrivia(kind, text); 160406"];
610 [label="return new SyntaxTrivia(kind, text); 160407"];
611 [label="return new SyntaxTrivia(kind, text); 160408"];
612 [label="new SyntaxTrivia(kind, text) 160409"];
613 [label="param SyntaxTrivia(SyntaxKind kind) 160410"];
614 [label="param SyntaxTrivia(string text) 160411"];
615 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 160412"];
616 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 160413"];
617 [label="param SyntaxTrivia(this) 160414"];
618 [label="kind 160415"];
619 [label="diagnostics 160416"];
620 [label="annotations 160417"];
621 [label="text 160418"];
622 [label="param SyntaxTrivia(this) 160419"];
623 [label="param CSharpSyntaxNode(SyntaxKind kind) 160420"];
624 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 160421"];
625 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 160422"];
626 [label="param CSharpSyntaxNode(int fullWidth) 160423"];
627 [label="param CSharpSyntaxNode(this) 160424"];
628 [label="kind 160425"];
629 [label="diagnostics 160426"];
630 [label="annotations 160427"];
631 [label="fullWidth 160428"];
632 [label="param CSharpSyntaxNode(this) 160429"];
633 [label="param CSharpSyntaxNode(this) 160430"];
634 [label="GreenStats.NoteGreen(this); 160431"];
635 [label="GreenStats.NoteGreen(this); 160432"];
636 [label="Text 160433"];
637 [label="this.Text 160434"];
638 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160435"];
639 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 160436"];
640 [label="if (!elastic)\n            {\n                return trivia;\n            } 160437"];
641 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160438"];
642 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160439"];
643 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 160440"];
644 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160441"];
645 [label="this.Kind 160442"];
646 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 160443"];
647 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 160444"];
648 [label="param SyntaxTrivia(this) 160445"];
649 [label="param SyntaxTrivia(this) 160446"];
650 [label="param CSharpSyntaxNode(this) 160447"];
651 [label="param CSharpSyntaxNode(this) 160448"];
652 [label="GreenStats.NoteGreen(this); 160449"];
653 [label="Text 160450"];
654 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160451"];
655 [label="ElasticCarriageReturn = EndOfLine('\\r', elastic: true) 160452"];
656 [label="' ' 160453"];
657 [label="true 160454"];
658 [label="elastic: true 160455"];
659 [label="Whitespace(' ', elastic: true) 160456"];
660 [label="param Whitespace(string text) 160457"];
661 [label="param Whitespace(bool elastic = false) 160458"];
662 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160459"];
663 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160460"];
664 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 160461"];
665 [label="param Create(SyntaxKind kind) 160462"];
666 [label="param Create(string text) 160463"];
667 [label="return new SyntaxTrivia(kind, text); 160464"];
668 [label="return new SyntaxTrivia(kind, text); 160465"];
669 [label="return new SyntaxTrivia(kind, text); 160466"];
670 [label="new SyntaxTrivia(kind, text) 160467"];
671 [label="param SyntaxTrivia(SyntaxKind kind) 160468"];
672 [label="param SyntaxTrivia(string text) 160469"];
673 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 160470"];
674 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 160471"];
675 [label="param SyntaxTrivia(this) 160472"];
676 [label="kind 160473"];
677 [label="diagnostics 160474"];
678 [label="annotations 160475"];
679 [label="text 160476"];
680 [label="param SyntaxTrivia(this) 160477"];
681 [label="param CSharpSyntaxNode(SyntaxKind kind) 160478"];
682 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 160479"];
683 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 160480"];
684 [label="param CSharpSyntaxNode(int fullWidth) 160481"];
685 [label="param CSharpSyntaxNode(this) 160482"];
686 [label="kind 160483"];
687 [label="diagnostics 160484"];
688 [label="annotations 160485"];
689 [label="fullWidth 160486"];
690 [label="param CSharpSyntaxNode(this) 160487"];
691 [label="param CSharpSyntaxNode(this) 160488"];
692 [label="GreenStats.NoteGreen(this); 160489"];
693 [label="GreenStats.NoteGreen(this); 160490"];
694 [label="Text 160491"];
695 [label="this.Text 160492"];
696 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160493"];
697 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160494"];
698 [label="if (!elastic)\n            {\n                return trivia;\n            } 160495"];
699 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160496"];
700 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160497"];
701 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 160498"];
702 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160499"];
703 [label="this.Kind 160500"];
704 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 160501"];
705 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 160502"];
706 [label="param SyntaxTrivia(this) 160503"];
707 [label="param SyntaxTrivia(this) 160504"];
708 [label="param CSharpSyntaxNode(this) 160505"];
709 [label="param CSharpSyntaxNode(this) 160506"];
710 [label="GreenStats.NoteGreen(this); 160507"];
711 [label="Text 160508"];
712 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160509"];
713 [label="ElasticSpace = Whitespace(' ', elastic: true) 160510"];
714 [label="'\\t' 160511"];
715 [label="true 160512"];
716 [label="elastic: true 160513"];
717 [label="Whitespace('\\t', elastic: true) 160514"];
718 [label="param Whitespace(string text) 160515"];
719 [label="param Whitespace(bool elastic = false) 160516"];
720 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160517"];
721 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160518"];
722 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 160519"];
723 [label="param Create(SyntaxKind kind) 160520"];
724 [label="param Create(string text) 160521"];
725 [label="return new SyntaxTrivia(kind, text); 160522"];
726 [label="return new SyntaxTrivia(kind, text); 160523"];
727 [label="return new SyntaxTrivia(kind, text); 160524"];
728 [label="new SyntaxTrivia(kind, text) 160525"];
729 [label="param SyntaxTrivia(SyntaxKind kind) 160526"];
730 [label="param SyntaxTrivia(string text) 160527"];
731 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 160528"];
732 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 160529"];
733 [label="param SyntaxTrivia(this) 160530"];
734 [label="kind 160531"];
735 [label="diagnostics 160532"];
736 [label="annotations 160533"];
737 [label="text 160534"];
738 [label="param SyntaxTrivia(this) 160535"];
739 [label="param CSharpSyntaxNode(SyntaxKind kind) 160536"];
740 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 160537"];
741 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 160538"];
742 [label="param CSharpSyntaxNode(int fullWidth) 160539"];
743 [label="param CSharpSyntaxNode(this) 160540"];
744 [label="kind 160541"];
745 [label="diagnostics 160542"];
746 [label="annotations 160543"];
747 [label="fullWidth 160544"];
748 [label="param CSharpSyntaxNode(this) 160545"];
749 [label="param CSharpSyntaxNode(this) 160546"];
750 [label="GreenStats.NoteGreen(this); 160547"];
751 [label="GreenStats.NoteGreen(this); 160548"];
752 [label="Text 160549"];
753 [label="this.Text 160550"];
754 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160551"];
755 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160552"];
756 [label="if (!elastic)\n            {\n                return trivia;\n            } 160553"];
757 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160554"];
758 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160555"];
759 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 160556"];
760 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160557"];
761 [label="this.Kind 160558"];
762 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 160559"];
763 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 160560"];
764 [label="param SyntaxTrivia(this) 160561"];
765 [label="param SyntaxTrivia(this) 160562"];
766 [label="param CSharpSyntaxNode(this) 160563"];
767 [label="param CSharpSyntaxNode(this) 160564"];
768 [label="GreenStats.NoteGreen(this); 160565"];
769 [label="Text 160566"];
770 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160567"];
771 [label="ElasticTab = Whitespace('\\t', elastic: true) 160568"];
772 [label="string.Empty 160569"];
773 [label="true 160570"];
774 [label="elastic: true 160571"];
775 [label="Whitespace(string.Empty, elastic: true) 160572"];
776 [label="param Whitespace(string text) 160573"];
777 [label="param Whitespace(bool elastic = false) 160574"];
778 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160575"];
779 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160576"];
780 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 160577"];
781 [label="param Create(SyntaxKind kind) 160578"];
782 [label="param Create(string text) 160579"];
783 [label="return new SyntaxTrivia(kind, text); 160580"];
784 [label="return new SyntaxTrivia(kind, text); 160581"];
785 [label="return new SyntaxTrivia(kind, text); 160582"];
786 [label="new SyntaxTrivia(kind, text) 160583"];
787 [label="param SyntaxTrivia(SyntaxKind kind) 160584"];
788 [label="param SyntaxTrivia(string text) 160585"];
789 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 160586"];
790 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 160587"];
791 [label="param SyntaxTrivia(this) 160588"];
792 [label="kind 160589"];
793 [label="diagnostics 160590"];
794 [label="annotations 160591"];
795 [label="text 160592"];
796 [label="param SyntaxTrivia(this) 160593"];
797 [label="param CSharpSyntaxNode(SyntaxKind kind) 160594"];
798 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 160595"];
799 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 160596"];
800 [label="param CSharpSyntaxNode(int fullWidth) 160597"];
801 [label="param CSharpSyntaxNode(this) 160598"];
802 [label="kind 160599"];
803 [label="diagnostics 160600"];
804 [label="annotations 160601"];
805 [label="fullWidth 160602"];
806 [label="param CSharpSyntaxNode(this) 160603"];
807 [label="param CSharpSyntaxNode(this) 160604"];
808 [label="GreenStats.NoteGreen(this); 160605"];
809 [label="GreenStats.NoteGreen(this); 160606"];
810 [label="Text 160607"];
811 [label="this.Text 160608"];
812 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160609"];
813 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 160610"];
814 [label="if (!elastic)\n            {\n                return trivia;\n            } 160611"];
815 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160612"];
816 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160613"];
817 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 160614"];
818 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 160615"];
819 [label="this.Kind 160616"];
820 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 160617"];
821 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 160618"];
822 [label="param SyntaxTrivia(this) 160619"];
823 [label="param SyntaxTrivia(this) 160620"];
824 [label="param CSharpSyntaxNode(this) 160621"];
825 [label="param CSharpSyntaxNode(this) 160622"];
826 [label="GreenStats.NoteGreen(this); 160623"];
827 [label="Text 160624"];
828 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 160625"];
829 [label="ElasticZeroSpace = Whitespace(string.Empty, elastic: true) 160626"];
830 [label="s_xmlCarriageReturnLineFeed 160627"];
831 [label="public static SyntaxTrivia CarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed; 160628"];
832 [label="param operator(SyntaxTrivia trivia) 160629"];
833 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160630"];
834 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160631"];
835 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160632"];
836 [label="public static SyntaxTrivia LineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.LineFeed; 160633"];
837 [label="param operator(SyntaxTrivia trivia) 160634"];
838 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160635"];
839 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160636"];
840 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160637"];
841 [label="public static SyntaxTrivia CarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn; 160638"];
842 [label="param operator(SyntaxTrivia trivia) 160639"];
843 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160640"];
844 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160641"];
845 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160642"];
846 [label="public static SyntaxTrivia Space { get; } = Syntax.InternalSyntax.SyntaxFactory.Space; 160643"];
847 [label="param operator(SyntaxTrivia trivia) 160644"];
848 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160645"];
849 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160646"];
850 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160647"];
851 [label="public static SyntaxTrivia Tab { get; } = Syntax.InternalSyntax.SyntaxFactory.Tab; 160648"];
852 [label="param operator(SyntaxTrivia trivia) 160649"];
853 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160650"];
854 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160651"];
855 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160652"];
856 [label="public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed; 160653"];
857 [label="param operator(SyntaxTrivia trivia) 160654"];
858 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160655"];
859 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160656"];
860 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160657"];
861 [label="public static SyntaxTrivia ElasticLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed; 160658"];
862 [label="param operator(SyntaxTrivia trivia) 160659"];
863 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160660"];
864 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160661"];
865 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160662"];
866 [label="public static SyntaxTrivia ElasticCarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn; 160663"];
867 [label="param operator(SyntaxTrivia trivia) 160664"];
868 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160665"];
869 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160666"];
870 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160667"];
871 [label="public static SyntaxTrivia ElasticSpace { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace; 160668"];
872 [label="param operator(SyntaxTrivia trivia) 160669"];
873 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160670"];
874 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160671"];
875 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160672"];
876 [label="public static SyntaxTrivia ElasticTab { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticTab; 160673"];
877 [label="param operator(SyntaxTrivia trivia) 160674"];
878 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160675"];
879 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160676"];
880 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160677"];
881 [label="public static SyntaxTrivia ElasticMarker { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace; 160678"];
882 [label="param operator(SyntaxTrivia trivia) 160679"];
883 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160680"];
884 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160681"];
885 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 160682"];
886 [label="return SyntaxFactory.ParseStatement(text, offset, options); 160683"];
887 [label="return SyntaxFactory.ParseStatement(text, offset, options); 160684"];
888 [label="return SyntaxFactory.ParseStatement(text, offset, options); 160685"];
889 [label="return SyntaxFactory.ParseStatement(text, offset, options); 160686"];
890 [label="SyntaxFactory.ParseStatement(text, offset, options) 160687"];
891 [label="param ParseStatement(string text) 160688"];
892 [label="param ParseStatement(int offset = 0) 160689"];
893 [label="param ParseStatement(ParseOptions? options = null) 160690"];
894 [label="param ParseStatement(bool consumeFullText = true) 160691"];
895 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 160692"];
896 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 160693"];
897 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 160694"];
898 [label="MakeLexer(text, offset, (CSharpParseOptions?)options) 160695"];
899 [label="param MakeLexer(string text) 160696"];
900 [label="param MakeLexer(int offset) 160697"];
901 [label="param MakeLexer(CSharpParseOptions? options = null) 160698"];
902 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 160699"];
903 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 160700"];
904 [label="MakeSourceText(text, offset) 160701"];
905 [label="param MakeSourceText(string text) 160702"];
906 [label="param MakeSourceText(int offset) 160703"];
907 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 160704"];
908 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 160705"];
909 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 160706"];
910 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 160707"];
911 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 160708"];
912 [label="new CSharpParseOptions() 160709"];
913 [label="param CSharpParseOptions(LanguageVersion languageVersion = LanguageVersion.Default) 160710"];
914 [label="param CSharpParseOptions(DocumentationMode documentationMode = DocumentationMode.Parse) 160711"];
915 [label="param CSharpParseOptions(SourceCodeKind kind = SourceCodeKind.Regular) 160712"];
916 [label="param CSharpParseOptions(IEnumerable<string>? preprocessorSymbols = null) 160713"];
917 [label="param CSharpParseOptions(this) 160714"];
918 [label="languageVersion 160715"];
919 [label="documentationMode 160716"];
920 [label="kind 160717"];
921 [label="preprocessorSymbols 160718"];
922 [label="preprocessorSymbols.ToImmutableArrayOrEmpty() 160719"];
923 [label="ImmutableDictionary<string, string>.Empty 160720"];
924 [label="param CSharpParseOptions(LanguageVersion languageVersion) 160721"];
925 [label="param CSharpParseOptions(DocumentationMode documentationMode) 160722"];
926 [label="param CSharpParseOptions(SourceCodeKind kind) 160723"];
927 [label="param CSharpParseOptions(ImmutableArray<string> preprocessorSymbols) 160724"];
928 [label="param CSharpParseOptions(IReadOnlyDictionary<string, string>? features) 160725"];
929 [label="param CSharpParseOptions(this) 160726"];
930 [label="kind 160727"];
931 [label="documentationMode 160728"];
932 [label="param CSharpParseOptions(this) 160729"];
933 [label="_features 160730"];
934 [label="public LanguageVersion LanguageVersion { get; private set; } 160731"];
935 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 160732"];
936 [label="this.SpecifiedLanguageVersion 160733"];
937 [label="this.LanguageVersion = languageVersion.MapSpecifiedToEffectiveVersion(); 160734"];
938 [label="languageVersion.MapSpecifiedToEffectiveVersion() 160735"];
939 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 160736"];
940 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 160737"];
941 [label="return LanguageVersion.CSharp9; 160738"];
942 [label="this.LanguageVersion 160739"];
943 [label="this.PreprocessorSymbols = preprocessorSymbols.ToImmutableArrayOrEmpty(); 160740"];
944 [label="this.PreprocessorSymbols 160741"];
945 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 160742"];
946 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 160743"];
947 [label="_features 160744"];
948 [label="public static CSharpParseOptions Default { get; } = new CSharpParseOptions(); 160745"];
949 [label="8 160746"];
950 [label="TriviaListInitialCapacity = 8 160747"];
951 [label="TokensLexed 160748"];
952 [label="'<<<<<<<' 160749"];
953 [label="s_conflictMarkerLength = '<<<<<<<'.Length 160750"];
954 [label="42 160751"];
955 [label="MaxCachedTokenSize = 42 160752"];
956 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 160753"];
957 [label="{\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            } 160754"];
958 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 160755"];
959 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 160756"];
960 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 160757"];
961 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 160758"];
962 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 160759"];
963 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 160760"];
964 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 160761"];
965 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 160762"];
966 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 160763"];
967 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 160764"];
968 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 160765"];
969 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 160766"];
970 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 160767"];
971 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 160768"];
972 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 160769"];
973 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 160770"];
974 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 160771"];
975 [label="s_stateTransitions = new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 160772"];
976 [label="new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 160773"];
977 [label="s_charProperties = new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 160774"];
978 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 160775"];
979 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 160776"];
980 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 160777"];
981 [label="new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default) 160778"];
982 [label="param Lexer(SourceText text) 160779"];
983 [label="param Lexer(CSharpParseOptions options) 160780"];
984 [label="param Lexer(bool allowPreprocessorDirectives = true) 160781"];
985 [label="param Lexer(bool interpolationFollowedByColon = false) 160782"];
986 [label="param Lexer(this) 160783"];
987 [label="text 160784"];
988 [label="param Lexer(this) 160785"];
989 [label="param AbstractLexer(SourceText text) 160786"];
990 [label="param AbstractLexer(this) 160787"];
991 [label="TextWindow 160788"];
992 [label="_errors 160789"];
993 [label="InvalidCharacter = char.MaxValue 160790"];
994 [label="2048 160791"];
995 [label="DefaultWindowLength = 2048 160792"];
996 [label="() => new char[DefaultWindowLength] 160793"];
997 [label="new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 160794"];
998 [label="s_windowPool = new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 160795"];
999 [label="this.TextWindow = new SlidingTextWindow(text); 160796"];
1000 [label="this.TextWindow = new SlidingTextWindow(text); 160797"];
1001 [label="new SlidingTextWindow(text) 160798"];
1002 [label="param SlidingTextWindow(SourceText text) 160799"];
1003 [label="param SlidingTextWindow(this) 160800"];
1004 [label="_text 160801"];
1005 [label="_basis 160802"];
1006 [label="_offset 160803"];
1007 [label="_textEnd 160804"];
1008 [label="_characterWindow 160805"];
1009 [label="_characterWindowCount 160806"];
1010 [label="_lexemeStart 160807"];
1011 [label="_strings 160808"];
1012 [label="_text 160809"];
1013 [label="_basis = 0; 160810"];
1014 [label="_basis 160811"];
1015 [label="_offset = 0; 160812"];
1016 [label="_offset 160813"];
1017 [label="_textEnd 160814"];
1018 [label="_strings = StringTable.GetInstance(); 160815"];
1019 [label="_strings 160816"];
1020 [label="_characterWindow = s_windowPool.Allocate(); 160817"];
1021 [label="_characterWindow 160818"];
1022 [label="_lexemeStart = 0; 160819"];
1023 [label="_lexemeStart 160820"];
1024 [label="this.TextWindow 160821"];
1025 [label="_options 160822"];
1026 [label="_mode 160823"];
1027 [label="_builder 160824"];
1028 [label="_identBuffer 160825"];
1029 [label="_identLen 160826"];
1030 [label="_cache 160827"];
1031 [label="_allowPreprocessorDirectives 160828"];
1032 [label="_interpolationFollowedByColon 160829"];
1033 [label="_xmlParser 160830"];
1034 [label="_badTokenCount 160831"];
1035 [label="10 160832"];
1036 [label="new SyntaxListBuilder(10) 160833"];
1037 [label="_leadingTriviaCache = new SyntaxListBuilder(10) 160834"];
1038 [label="10 160835"];
1039 [label="new SyntaxListBuilder(10) 160836"];
1040 [label="_trailingTriviaCache = new SyntaxListBuilder(10) 160837"];
1041 [label="_createWhitespaceTriviaFunction 160838"];
1042 [label="_createQuickTokenFunction 160839"];
1043 [label="Debug.Assert(options != null); 160840"];
1044 [label="Debug.Assert(options != null); 160841"];
1045 [label="_options 160842"];
1046 [label="_builder = new StringBuilder(); 160843"];
1047 [label="_builder 160844"];
1048 [label="_identBuffer = new char[32]; 160845"];
1049 [label="_identBuffer 160846"];
1050 [label="512 160847"];
1051 [label="(key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            } 160848"];
1052 [label="CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 160849"];
1053 [label="s_keywordKindPool =\n            CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 160850"];
1054 [label="10 160851"];
1055 [label="MaxKeywordLength = 10 160852"];
1056 [label="_cache = new LexerCache(); 160853"];
1057 [label="new LexerCache() 160854"];
1058 [label="param LexerCache(this) 160855"];
1059 [label="_triviaMap 160856"];
1060 [label="_tokenMap 160857"];
1061 [label="_keywordKindMap 160858"];
1062 [label="_triviaMap = TextKeyedCache<SyntaxTrivia>.GetInstance(); 160859"];
1063 [label="_triviaMap 160860"];
1064 [label="_tokenMap = TextKeyedCache<SyntaxToken>.GetInstance(); 160861"];
1065 [label="_tokenMap 160862"];
1066 [label="_keywordKindMap = s_keywordKindPool.Allocate(); 160863"];
1067 [label="_keywordKindMap 160864"];
1068 [label="_cache 160865"];
1069 [label="_createQuickTokenFunction 160866"];
1070 [label="_allowPreprocessorDirectives 160867"];
1071 [label="_interpolationFollowedByColon 160868"];
1072 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 160869"];
1073 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 160870"];
1074 [label="MakeParser(lexer) 160871"];
1075 [label="param MakeParser(InternalSyntax.Lexer lexer) 160872"];
1076 [label="LastTerminatorState = (int)TerminatorState.IsEndOfRecordSignature 160873"];
1077 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 160874"];
1078 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 160875"];
1079 [label="new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null) 160876"];
1080 [label="param LanguageParser(Lexer lexer) 160877"];
1081 [label="param LanguageParser(CSharp.CSharpSyntaxNode oldTree) 160878"];
1082 [label="param LanguageParser(IEnumerable<TextChangeRange> changes) 160879"];
1083 [label="param LanguageParser(LexerMode lexerMode = LexerMode.Syntax) 160880"];
1084 [label="param LanguageParser(CancellationToken cancellationToken = default(CancellationToken)) 160881"];
1085 [label="param LanguageParser(this) 160882"];
1086 [label="() => new BlendedNode[32] 160883"];
1087 [label="2 160884"];
1088 [label="new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 160885"];
1089 [label="s_blendedNodesPool = new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 160886"];
1090 [label="lexer 160887"];
1091 [label="lexerMode 160888"];
1092 [label="oldTree 160889"];
1093 [label="changes 160890"];
1094 [label="false 160891"];
1095 [label="true 160892"];
1096 [label="cancellationToken 160893"];
1097 [label="param LanguageParser(this) 160894"];
1098 [label="param SyntaxParser(Lexer lexer) 160895"];
1099 [label="param SyntaxParser(LexerMode mode) 160896"];
1100 [label="param SyntaxParser(CSharp.CSharpSyntaxNode oldTree) 160897"];
1101 [label="param SyntaxParser(IEnumerable<TextChangeRange> changes) 160898"];
1102 [label="param SyntaxParser(bool allowModeReset) 160899"];
1103 [label="param SyntaxParser(bool preLexIfNotIncremental = false) 160900"];
1104 [label="param SyntaxParser(CancellationToken cancellationToken = default(CancellationToken)) 160901"];
1105 [label="param SyntaxParser(this) 160902"];
1106 [label="lexer 160903"];
1107 [label="_isIncremental 160904"];
1108 [label="_allowModeReset 160905"];
1109 [label="_mode 160906"];
1110 [label="_currentToken 160907"];
1111 [label="_lexedTokens 160908"];
1112 [label="_prevTokenTrailingTrivia 160909"];
1113 [label="_firstToken 160910"];
1114 [label="_tokenOffset 160911"];
1115 [label="_tokenCount 160912"];
1116 [label="_resetCount 160913"];
1117 [label="_resetStart 160914"];
1118 [label="_blendedTokens 160915"];
1119 [label="this.lexer 160916"];
1120 [label="_mode 160917"];
1121 [label="_allowModeReset 160918"];
1122 [label="this.cancellationToken 160919"];
1123 [label="_currentNode = default(BlendedNode); 160920"];
1124 [label="_currentNode 160921"];
1125 [label="_isIncremental = oldTree != null; 160922"];
1126 [label="_isIncremental = oldTree != null; 160923"];
1127 [label="_isIncremental 160924"];
1128 [label="this.IsIncremental 160925"];
1129 [label="get\n            {\n                return _isIncremental;\n            } 160926"];
1130 [label="return _isIncremental; 160927"];
1131 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 160928"];
1132 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 160929"];
1133 [label="_firstBlender = default(Blender); 160930"];
1134 [label="_firstBlender 160931"];
1135 [label="_lexedTokens = new ArrayElement<SyntaxToken>[32]; 160932"];
1136 [label="_lexedTokens 160933"];
1137 [label="this.IsIncremental 160934"];
1138 [label="get\n            {\n                return _isIncremental;\n            } 160935"];
1139 [label="return _isIncremental; 160936"];
1140 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 160937"];
1141 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 160938"];
1142 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 160939"];
1143 [label="this.PreLex() 160940"];
1144 [label="param PreLex(this) 160941"];
1145 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 160942"];
1146 [label="this.lexer.TextWindow.Text 160943"];
1147 [label="=> _text 160944"];
1148 [label="_text 160945"];
1149 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 160946"];
1150 [label="_lexedTokens = new ArrayElement<SyntaxToken>[size]; 160947"];
1151 [label="_lexedTokens 160948"];
1152 [label="var lexer = this.lexer; 160949"];
1153 [label="var mode = _mode; 160950"];
1154 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 160951"];
1155 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 160952"];
1156 [label="var token = lexer.Lex(mode); 160953"];
1157 [label="lexer.Lex(mode) 160954"];
1158 [label="param Lex(LexerMode mode) 160955"];
1159 [label="param Lex(this) 160956"];
1160 [label="TokensLexed++; 160957"];
1161 [label="_mode 160958"];
1162 [label="switch (_mode)\n            {\n                case LexerMode.Syntax:\n                case LexerMode.DebuggerSyntax:\n                    return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();\n                case LexerMode.Directive:\n                    return this.LexDirectiveToken();\n            } 160959"];
1163 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 160960"];
1164 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 160961"];
1165 [label="param Start(this) 160962"];
1166 [label="TextWindow.Start() 160963"];
1167 [label="param Start(this) 160964"];
1168 [label="_lexemeStart 160965"];
1169 [label="TextWindow.Start(); 160966"];
1170 [label="_errors = null; 160967"];
1171 [label="_errors 160968"];
1172 [label="get\n            {\n                return _offset;\n            } 160969"];
1173 [label="return _offset; 160970"];
1174 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 160971"];
1175 [label="get\n            {\n                return _characterWindowCount;\n            } 160972"];
1176 [label="return _characterWindowCount; 160973"];
1177 [label="get\n            {\n                return _characterWindow;\n            } 160974"];
1178 [label="return _characterWindow; 160975"];
1179 [label="param AdvanceChar(int n) 160976"];
1180 [label="param AdvanceChar(this) 160977"];
1181 [label="_offset += n; 160978"];
1182 [label="_offset 160979"];
1183 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 160980"];
1184 [label="return _basis + _lexemeStart; 160981"];
1185 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 160982"];
1186 [label="param Reset(int position) 160983"];
1187 [label="param Reset(this) 160984"];
1188 [label="int relative = position - _basis; 160985"];
1189 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 160986"];
1190 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 160987"];
1191 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 160988"];
1192 [label="_offset 160989"];
1193 [label="this.LexSyntaxToken() 160990"];
1194 [label="param LexSyntaxToken(this) 160991"];
1195 [label="_leadingTriviaCache.Clear(); 160992"];
1196 [label="TextWindow.Position 160993"];
1197 [label="get\n            {\n                return _basis + _offset;\n            } 160994"];
1198 [label="return _basis + _offset; 160995"];
1199 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 160996"];
1200 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 160997"];
1201 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 160998"];
1202 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache) 160999"];
1203 [label="param LexSyntaxTrivia(bool afterFirstToken) 161000"];
1204 [label="param LexSyntaxTrivia(bool isTrailing) 161001"];
1205 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 161002"];
1206 [label="param LexSyntaxTrivia(this) 161003"];
1207 [label="bool onlyWhitespaceOnLine = !isTrailing; 161004"];
1208 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 161005"];
1209 [label="this.Start() 161006"];
1210 [label="param Start(this) 161007"];
1211 [label="TextWindow.Start() 161008"];
1212 [label="param Start(this) 161009"];
1213 [label="TextWindow.Start(); 161010"];
1214 [label="_errors = null; 161011"];
1215 [label="_errors 161012"];
1216 [label="this.Start(); 161013"];
1217 [label="TextWindow.PeekChar() 161014"];
1218 [label="param PeekChar(this) 161015"];
1219 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 161016"];
1220 [label="MoreChars() 161017"];
1221 [label="param MoreChars(this) 161018"];
1222 [label="if (_offset >= _characterWindowCount)\n            {\n                if (this.Position >= _textEnd)\n                {\n                    return false;\n                }\n\n                // if lexeme scanning is sufficiently into the char buffer, \n                // then refocus the window onto the lexeme\n                if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                }\n\n                if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                }\n\n                int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount);\n                _text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead);\n                _characterWindowCount += amountToRead;\n                return amountToRead > 0;\n            } 161019"];
1223 [label="this.Position 161020"];
1224 [label="get\n            {\n                return _basis + _offset;\n            } 161021"];
1225 [label="return _basis + _offset; 161022"];
1226 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 161023"];
1227 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 161024"];
1228 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 161025"];
1229 [label="if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                } 161026"];
1230 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 161027"];
1231 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 161028"];
1232 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 161029"];
1233 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 161030"];
1234 [label="_characterWindowCount += amountToRead; 161031"];
1235 [label="_characterWindowCount 161032"];
1236 [label="return amountToRead > 0; 161033"];
1237 [label="return amountToRead > 0; 161034"];
1238 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 161035"];
1239 [label="return _characterWindow[_offset]; 161036"];
1240 [label="char ch = TextWindow.PeekChar(); 161037"];
1241 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 161038"];
1242 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 161039"];
1243 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 161040"];
1244 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 161041"];
1245 [label="return; 161042"];
1246 [label="var leading = _leadingTriviaCache; 161043"];
1247 [label="var tokenInfo = default(TokenInfo); 161044"];
1248 [label="this.Start() 161045"];
1249 [label="param Start(this) 161046"];
1250 [label="TextWindow.Start() 161047"];
1251 [label="param Start(this) 161048"];
1252 [label="TextWindow.Start(); 161049"];
1253 [label="_errors = null; 161050"];
1254 [label="_errors 161051"];
1255 [label="this.Start(); 161052"];
1256 [label="this.ScanSyntaxToken(ref tokenInfo); 161053"];
1257 [label="this.ScanSyntaxToken(ref tokenInfo); 161054"];
1258 [label="this.ScanSyntaxToken(ref tokenInfo); 161055"];
1259 [label="get\n            {\n                return _basis + _offset;\n            } 161056"];
1260 [label="return _basis + _offset; 161057"];
1261 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 161058"];
1262 [label="return _characterWindow[_offset]; 161059"];
1263 [label="param ScanIdentifierOrKeyword(ref TokenInfo info) 161060"];
1264 [label="param ScanIdentifierOrKeyword(this) 161061"];
1265 [label="info.ContextualKind 161062"];
1266 [label="if (this.ScanIdentifier(ref info))\n            {\n                // check to see if it is an actual keyword\n                if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                }\n\n                return true;\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                return false;\n            } 161063"];
1267 [label="this.ScanIdentifier(ref info) 161064"];
1268 [label="param ScanIdentifier(ref TokenInfo info) 161065"];
1269 [label="param ScanIdentifier(this) 161066"];
1270 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 161067"];
1271 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 161068"];
1272 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 161069"];
1273 [label="param Intern(char[] array) 161070"];
1274 [label="param Intern(int start) 161071"];
1275 [label="param Intern(int length) 161072"];
1276 [label="param Intern(this) 161073"];
1277 [label="return _strings.Add(array, start, length); 161074"];
1278 [label="return _strings.Add(array, start, length); 161075"];
1279 [label="return _strings.Add(array, start, length); 161076"];
1280 [label="return _strings.Add(array, start, length); 161077"];
1281 [label="if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                } 161078"];
1282 [label="if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    } 161079"];
1283 [label="this.ModeIs(LexerMode.Directive) 161080"];
1284 [label="param ModeIs(LexerMode mode) 161081"];
1285 [label="param ModeIs(this) 161082"];
1286 [label="return ModeOf(_mode) == mode; 161083"];
1287 [label="ModeOf(_mode) 161084"];
1288 [label="param ModeOf(LexerMode mode) 161085"];
1289 [label="return mode & LexerMode.MaskLexMode; 161086"];
1290 [label="return ModeOf(_mode) == mode; 161087"];
1291 [label="if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 161088"];
1292 [label="_cache.TryGetKeywordKind(info.Text, out info.Kind) 161089"];
1293 [label="param TryGetKeywordKind(string key) 161090"];
1294 [label="param TryGetKeywordKind(out SyntaxKind kind) 161091"];
1295 [label="param TryGetKeywordKind(this) 161092"];
1296 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 161093"];
1297 [label="new SyntaxKindEqualityComparer() 161094"];
1298 [label="param SyntaxKindEqualityComparer(this) 161095"];
1299 [label="public static IEqualityComparer<SyntaxKind> EqualityComparer { get; } = new SyntaxKindEqualityComparer(); 161096"];
1300 [label="kind = _keywordKindMap.GetOrMakeValue(key); 161097"];
1301 [label="kind = _keywordKindMap.GetOrMakeValue(key); 161098"];
1302 [label="kind = _keywordKindMap.GetOrMakeValue(key); 161099"];
1303 [label="param GetKeywordKind(string text) 161100"];
1304 [label="switch (text)\n            {\n                case 'bool':\n                    return SyntaxKind.BoolKeyword;\n                case 'byte':\n                    return SyntaxKind.ByteKeyword;\n                case 'sbyte':\n                    return SyntaxKind.SByteKeyword;\n                case 'short':\n                    return SyntaxKind.ShortKeyword;\n                case 'ushort':\n                    return SyntaxKind.UShortKeyword;\n                case 'int':\n                    return SyntaxKind.IntKeyword;\n                case 'uint':\n                    return SyntaxKind.UIntKeyword;\n                case 'long':\n                    return SyntaxKind.LongKeyword;\n                case 'ulong':\n                    return SyntaxKind.ULongKeyword;\n                case 'double':\n                    return SyntaxKind.DoubleKeyword;\n                case 'float':\n                    return SyntaxKind.FloatKeyword;\n                case 'decimal':\n                    return SyntaxKind.DecimalKeyword;\n                case 'string':\n                    return SyntaxKind.StringKeyword;\n                case 'char':\n                    return SyntaxKind.CharKeyword;\n                case 'void':\n                    return SyntaxKind.VoidKeyword;\n                case 'object':\n                    return SyntaxKind.ObjectKeyword;\n                case 'typeof':\n                    return SyntaxKind.TypeOfKeyword;\n                case 'sizeof':\n                    return SyntaxKind.SizeOfKeyword;\n                case 'null':\n                    return SyntaxKind.NullKeyword;\n                case 'true':\n                    return SyntaxKind.TrueKeyword;\n                case 'false':\n                    return SyntaxKind.FalseKeyword;\n                case 'if':\n                    return SyntaxKind.IfKeyword;\n                case 'else':\n                    return SyntaxKind.ElseKeyword;\n                case 'while':\n                    return SyntaxKind.WhileKeyword;\n                case 'for':\n                    return SyntaxKind.ForKeyword;\n                case 'foreach':\n                    return SyntaxKind.ForEachKeyword;\n                case 'do':\n                    return SyntaxKind.DoKeyword;\n                case 'switch':\n                    return SyntaxKind.SwitchKeyword;\n                case 'case':\n                    return SyntaxKind.CaseKeyword;\n                case 'default':\n                    return SyntaxKind.DefaultKeyword;\n                case 'lock':\n                    return SyntaxKind.LockKeyword;\n                case 'try':\n                    return SyntaxKind.TryKeyword;\n                case 'throw':\n                    return SyntaxKind.ThrowKeyword;\n                case 'catch':\n                    return SyntaxKind.CatchKeyword;\n                case 'finally':\n                    return SyntaxKind.FinallyKeyword;\n                case 'goto':\n                    return SyntaxKind.GotoKeyword;\n                case 'break':\n                    return SyntaxKind.BreakKeyword;\n                case 'continue':\n                    return SyntaxKind.ContinueKeyword;\n                case 'return':\n                    return SyntaxKind.ReturnKeyword;\n                case 'public':\n                    return SyntaxKind.PublicKeyword;\n                case 'private':\n                    return SyntaxKind.PrivateKeyword;\n                case 'internal':\n                    return SyntaxKind.InternalKeyword;\n                case 'protected':\n                    return SyntaxKind.ProtectedKeyword;\n                case 'static':\n                    return SyntaxKind.StaticKeyword;\n                case 'readonly':\n                    return SyntaxKind.ReadOnlyKeyword;\n                case 'sealed':\n                    return SyntaxKind.SealedKeyword;\n                case 'const':\n                    return SyntaxKind.ConstKeyword;\n                case 'fixed':\n                    return SyntaxKind.FixedKeyword;\n                case 'stackalloc':\n                    return SyntaxKind.StackAllocKeyword;\n                case 'volatile':\n                    return SyntaxKind.VolatileKeyword;\n                case 'new':\n                    return SyntaxKind.NewKeyword;\n                case 'override':\n                    return SyntaxKind.OverrideKeyword;\n                case 'abstract':\n                    return SyntaxKind.AbstractKeyword;\n                case 'virtual':\n                    return SyntaxKind.VirtualKeyword;\n                case 'event':\n                    return SyntaxKind.EventKeyword;\n                case 'extern':\n                    return SyntaxKind.ExternKeyword;\n                case 'ref':\n                    return SyntaxKind.RefKeyword;\n                case 'out':\n                    return SyntaxKind.OutKeyword;\n                case 'in':\n                    return SyntaxKind.InKeyword;\n                case 'is':\n                    return SyntaxKind.IsKeyword;\n                case 'as':\n                    return SyntaxKind.AsKeyword;\n                case 'params':\n                    return SyntaxKind.ParamsKeyword;\n                case '__arglist':\n                    return SyntaxKind.ArgListKeyword;\n                case '__makeref':\n                    return SyntaxKind.MakeRefKeyword;\n                case '__reftype':\n                    return SyntaxKind.RefTypeKeyword;\n                case '__refvalue':\n                    return SyntaxKind.RefValueKeyword;\n                case 'this':\n                    return SyntaxKind.ThisKeyword;\n                case 'base':\n                    return SyntaxKind.BaseKeyword;\n                case 'namespace':\n                    return SyntaxKind.NamespaceKeyword;\n                case 'using':\n                    return SyntaxKind.UsingKeyword;\n                case 'class':\n                    return SyntaxKind.ClassKeyword;\n                case 'struct':\n                    return SyntaxKind.StructKeyword;\n                case 'interface':\n                    return SyntaxKind.InterfaceKeyword;\n                case 'enum':\n                    return SyntaxKind.EnumKeyword;\n                case 'delegate':\n                    return SyntaxKind.DelegateKeyword;\n                case 'checked':\n                    return SyntaxKind.CheckedKeyword;\n                case 'unchecked':\n                    return SyntaxKind.UncheckedKeyword;\n                case 'unsafe':\n                    return SyntaxKind.UnsafeKeyword;\n                case 'operator':\n                    return SyntaxKind.OperatorKeyword;\n                case 'implicit':\n                    return SyntaxKind.ImplicitKeyword;\n                case 'explicit':\n                    return SyntaxKind.ExplicitKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 161101"];
1305 [label="return SyntaxKind.SwitchKeyword; 161102"];
1306 [label="return kind != SyntaxKind.None; 161103"];
1307 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 161104"];
1308 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 161105"];
1309 [label="param IsContextualKeyword(SyntaxKind kind) 161106"];
1310 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 161107"];
1311 [label="return false; 161108"];
1312 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 161109"];
1313 [label="return true; 161110"];
1314 [label="this.ScanSyntaxToken(ref tokenInfo); 161111"];
1315 [label="var errors = this.GetErrors(GetFullWidth(leading)); 161112"];
1316 [label="GetFullWidth(leading) 161113"];
1317 [label="param GetFullWidth(SyntaxListBuilder builder) 161114"];
1318 [label="int width = 0; 161115"];
1319 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 161116"];
1320 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 161117"];
1321 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 161118"];
1322 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 161119"];
1323 [label="return width; 161120"];
1324 [label="var errors = this.GetErrors(GetFullWidth(leading)); 161121"];
1325 [label="this.GetErrors(GetFullWidth(leading)) 161122"];
1326 [label="param GetErrors(int leadingTriviaWidth) 161123"];
1327 [label="param GetErrors(this) 161124"];
1328 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 161125"];
1329 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 161126"];
1330 [label="return null; 161127"];
1331 [label="var errors = this.GetErrors(GetFullWidth(leading)); 161128"];
1332 [label="_trailingTriviaCache.Clear(); 161129"];
1333 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 161130"];
1334 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 161131"];
1335 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache) 161132"];
1336 [label="param LexSyntaxTrivia(bool afterFirstToken) 161133"];
1337 [label="param LexSyntaxTrivia(bool isTrailing) 161134"];
1338 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 161135"];
1339 [label="param LexSyntaxTrivia(this) 161136"];
1340 [label="bool onlyWhitespaceOnLine = !isTrailing; 161137"];
1341 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 161138"];
1342 [label="this.Start() 161139"];
1343 [label="param Start(this) 161140"];
1344 [label="TextWindow.Start() 161141"];
1345 [label="param Start(this) 161142"];
1346 [label="TextWindow.Start(); 161143"];
1347 [label="_errors = null; 161144"];
1348 [label="_errors 161145"];
1349 [label="this.Start(); 161146"];
1350 [label="TextWindow.PeekChar() 161147"];
1351 [label="param PeekChar(this) 161148"];
1352 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 161149"];
1353 [label="char ch = TextWindow.PeekChar(); 161150"];
1354 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 161151"];
1355 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 161152"];
1356 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 161153"];
1357 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 161154"];
1358 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 161155"];
1359 [label="param AdvanceChar(this) 161156"];
1360 [label="_offset 161157"];
1361 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 161158"];
1362 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 161159"];
1363 [label="return _offset - _lexemeStart; 161160"];
1364 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 161161"];
1365 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList) 161162"];
1366 [label="param AddTrivia(CSharpSyntaxNode trivia) 161163"];
1367 [label="param AddTrivia(ref SyntaxListBuilder list) 161164"];
1368 [label="param AddTrivia(this) 161165"];
1369 [label="this.HasErrors 161166"];
1370 [label="get { return _errors != null; } 161167"];
1371 [label="return _errors != null; 161168"];
1372 [label="return _errors != null; 161169"];
1373 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 161170"];
1374 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 161171"];
1375 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 161172"];
1376 [label="list.Add(trivia); 161173"];
1377 [label="list.Add(trivia); 161174"];
1378 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 161175"];
1379 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 161176"];
1380 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 161177"];
1381 [label="return; 161178"];
1382 [label="var trailing = _trailingTriviaCache; 161179"];
1383 [label="return Create(ref tokenInfo, leading, trailing, errors); 161180"];
1384 [label="return Create(ref tokenInfo, leading, trailing, errors); 161181"];
1385 [label="return Create(ref tokenInfo, leading, trailing, errors); 161182"];
1386 [label="return Create(ref tokenInfo, leading, trailing, errors); 161183"];
1387 [label="Create(ref tokenInfo, leading, trailing, errors) 161184"];
1388 [label="param Create(ref TokenInfo info) 161185"];
1389 [label="param Create(SyntaxListBuilder leading) 161186"];
1390 [label="param Create(SyntaxListBuilder trailing) 161187"];
1391 [label="param Create(SyntaxDiagnosticInfo[] errors) 161188"];
1392 [label="param Create(this) 161189"];
1393 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 161190"];
1394 [label="var leadingNode = leading?.ToListNode(); 161191"];
1395 [label="var trailingNode = trailing?.ToListNode(); 161192"];
1396 [label="SyntaxToken token; 161193"];
1397 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 161194"];
1398 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 161195"];
1399 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 161196"];
1400 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 161197"];
1401 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 161198"];
1402 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 161199"];
1403 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 161200"];
1404 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 161201"];
1405 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 161202"];
1406 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 161203"];
1407 [label="param Token(GreenNode leading) 161204"];
1408 [label="param Token(SyntaxKind kind) 161205"];
1409 [label="param Token(GreenNode trailing) 161206"];
1410 [label="FirstTokenWithWellKnownText = SyntaxKind.TildeToken 161207"];
1411 [label="LastTokenWithWellKnownText = SyntaxKind.EndOfFileToken 161208"];
1412 [label="1 161209"];
1413 [label="(int)LastTokenWithWellKnownText + 1 161210"];
1414 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 161211"];
1415 [label="s_tokensWithNoTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 161212"];
1416 [label="1 161213"];
1417 [label="(int)LastTokenWithWellKnownText + 1 161214"];
1418 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 161215"];
1419 [label="s_tokensWithElasticTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 161216"];
1420 [label="1 161217"];
1421 [label="(int)LastTokenWithWellKnownText + 1 161218"];
1422 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 161219"];
1423 [label="s_tokensWithSingleTrailingSpace = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 161220"];
1424 [label="1 161221"];
1425 [label="(int)LastTokenWithWellKnownText + 1 161222"];
1426 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 161223"];
1427 [label="s_tokensWithSingleTrailingCRLF = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 161224"];
1428 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxToken), r => new SyntaxToken(r)); 161225"];
1429 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 161226"];
1430 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 161227"];
1431 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 161228"];
1432 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 161229"];
1433 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 161230"];
1434 [label="new SyntaxToken(kind) 161231"];
1435 [label="param SyntaxToken(SyntaxKind kind) 161232"];
1436 [label="param SyntaxToken(this) 161233"];
1437 [label="kind 161234"];
1438 [label="param SyntaxToken(this) 161235"];
1439 [label="param CSharpSyntaxNode(SyntaxKind kind) 161236"];
1440 [label="param CSharpSyntaxNode(this) 161237"];
1441 [label="kind 161238"];
1442 [label="param CSharpSyntaxNode(this) 161239"];
1443 [label="param CSharpSyntaxNode(this) 161240"];
1444 [label="GreenStats.NoteGreen(this); 161241"];
1445 [label="GreenStats.NoteGreen(this); 161242"];
1446 [label="this.Text 161243"];
1447 [label="get { return SyntaxFacts.GetText(this.Kind); } 161244"];
1448 [label="this.Kind 161245"];
1449 [label="get { return (SyntaxKind)this.RawKind; } 161246"];
1450 [label="return (SyntaxKind)this.RawKind; 161247"];
1451 [label="return SyntaxFacts.GetText(this.Kind); 161248"];
1452 [label="SyntaxFacts.GetText(this.Kind) 161249"];
1453 [label="param GetText(SyntaxKind kind) 161250"];
1454 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 161251"];
1455 [label="return '~'; 161252"];
1456 [label="FullWidth = this.Text.Length; 161253"];
1457 [label="FullWidth 161254"];
1458 [label="this.flags |= NodeFlags.IsNotMissing; 161255"];
1459 [label="this.flags 161256"];
1460 [label="s_tokensWithNoTrivia[(int)kind].Value 161257"];
1461 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithTrivia), r => new SyntaxTokenWithTrivia(r)); 161258"];
1462 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 161259"];
1463 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 161260"];
1464 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 161261"];
1465 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 161262"];
1466 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 161263"];
1467 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 161264"];
1468 [label="param SyntaxTokenWithTrivia(GreenNode leading) 161265"];
1469 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 161266"];
1470 [label="param SyntaxTokenWithTrivia(this) 161267"];
1471 [label="kind 161268"];
1472 [label="param SyntaxTokenWithTrivia(this) 161269"];
1473 [label="param SyntaxToken(SyntaxKind kind) 161270"];
1474 [label="param SyntaxToken(this) 161271"];
1475 [label="kind 161272"];
1476 [label="param SyntaxToken(this) 161273"];
1477 [label="param CSharpSyntaxNode(SyntaxKind kind) 161274"];
1478 [label="param CSharpSyntaxNode(this) 161275"];
1479 [label="kind 161276"];
1480 [label="param CSharpSyntaxNode(this) 161277"];
1481 [label="param CSharpSyntaxNode(this) 161278"];
1482 [label="GreenStats.NoteGreen(this); 161279"];
1483 [label="GreenStats.NoteGreen(this); 161280"];
1484 [label="this.Text 161281"];
1485 [label="get { return SyntaxFacts.GetText(this.Kind); } 161282"];
1486 [label="this.Kind 161283"];
1487 [label="get { return (SyntaxKind)this.RawKind; } 161284"];
1488 [label="return (SyntaxKind)this.RawKind; 161285"];
1489 [label="return SyntaxFacts.GetText(this.Kind); 161286"];
1490 [label="SyntaxFacts.GetText(this.Kind) 161287"];
1491 [label="param GetText(SyntaxKind kind) 161288"];
1492 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 161289"];
1493 [label="return '~'; 161290"];
1494 [label="FullWidth = this.Text.Length; 161291"];
1495 [label="FullWidth 161292"];
1496 [label="this.flags |= NodeFlags.IsNotMissing; 161293"];
1497 [label="this.flags 161294"];
1498 [label="LeadingField 161295"];
1499 [label="TrailingField 161296"];
1500 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 161297"];
1501 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 161298"];
1502 [label="this.AdjustFlagsAndWidth(leading); 161299"];
1503 [label="this.AdjustFlagsAndWidth(leading); 161300"];
1504 [label="this.LeadingField 161301"];
1505 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 161302"];
1506 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 161303"];
1507 [label="this.AdjustFlagsAndWidth(trailing); 161304"];
1508 [label="this.AdjustFlagsAndWidth(trailing); 161305"];
1509 [label="this.TrailingField 161306"];
1510 [label="s_tokensWithElasticTrivia[(int)kind].Value 161307"];
1511 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 161308"];
1512 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 161309"];
1513 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 161310"];
1514 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 161311"];
1515 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 161312"];
1516 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 161313"];
1517 [label="param SyntaxTokenWithTrivia(GreenNode leading) 161314"];
1518 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 161315"];
1519 [label="param SyntaxTokenWithTrivia(this) 161316"];
1520 [label="kind 161317"];
1521 [label="param SyntaxTokenWithTrivia(this) 161318"];
1522 [label="param SyntaxToken(SyntaxKind kind) 161319"];
1523 [label="param SyntaxToken(this) 161320"];
1524 [label="kind 161321"];
1525 [label="param SyntaxToken(this) 161322"];
1526 [label="param CSharpSyntaxNode(SyntaxKind kind) 161323"];
1527 [label="param CSharpSyntaxNode(this) 161324"];
1528 [label="kind 161325"];
1529 [label="param CSharpSyntaxNode(this) 161326"];
1530 [label="param CSharpSyntaxNode(this) 161327"];
1531 [label="GreenStats.NoteGreen(this); 161328"];
1532 [label="GreenStats.NoteGreen(this); 161329"];
1533 [label="this.Text 161330"];
1534 [label="get { return SyntaxFacts.GetText(this.Kind); } 161331"];
1535 [label="this.Kind 161332"];
1536 [label="get { return (SyntaxKind)this.RawKind; } 161333"];
1537 [label="return (SyntaxKind)this.RawKind; 161334"];
1538 [label="return SyntaxFacts.GetText(this.Kind); 161335"];
1539 [label="SyntaxFacts.GetText(this.Kind) 161336"];
1540 [label="param GetText(SyntaxKind kind) 161337"];
1541 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 161338"];
1542 [label="return '~'; 161339"];
1543 [label="FullWidth = this.Text.Length; 161340"];
1544 [label="FullWidth 161341"];
1545 [label="this.flags |= NodeFlags.IsNotMissing; 161342"];
1546 [label="this.flags 161343"];
1547 [label="LeadingField 161344"];
1548 [label="TrailingField 161345"];
1549 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 161346"];
1550 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 161347"];
1551 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 161348"];
1552 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 161349"];
1553 [label="this.AdjustFlagsAndWidth(trailing); 161350"];
1554 [label="this.AdjustFlagsAndWidth(trailing); 161351"];
1555 [label="this.TrailingField 161352"];
1556 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 161353"];
1557 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 161354"];
1558 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 161355"];
1559 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 161356"];
1560 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 161357"];
1561 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 161358"];
1562 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 161359"];
1563 [label="param SyntaxTokenWithTrivia(GreenNode leading) 161360"];
1564 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 161361"];
1565 [label="param SyntaxTokenWithTrivia(this) 161362"];
1566 [label="kind 161363"];
1567 [label="param SyntaxTokenWithTrivia(this) 161364"];
1568 [label="param SyntaxToken(SyntaxKind kind) 161365"];
1569 [label="param SyntaxToken(this) 161366"];
1570 [label="kind 161367"];
1571 [label="param SyntaxToken(this) 161368"];
1572 [label="param CSharpSyntaxNode(SyntaxKind kind) 161369"];
1573 [label="param CSharpSyntaxNode(this) 161370"];
1574 [label="kind 161371"];
1575 [label="param CSharpSyntaxNode(this) 161372"];
1576 [label="param CSharpSyntaxNode(this) 161373"];
1577 [label="GreenStats.NoteGreen(this); 161374"];
1578 [label="GreenStats.NoteGreen(this); 161375"];
1579 [label="this.Text 161376"];
1580 [label="get { return SyntaxFacts.GetText(this.Kind); } 161377"];
1581 [label="this.Kind 161378"];
1582 [label="get { return (SyntaxKind)this.RawKind; } 161379"];
1583 [label="return (SyntaxKind)this.RawKind; 161380"];
1584 [label="return SyntaxFacts.GetText(this.Kind); 161381"];
1585 [label="SyntaxFacts.GetText(this.Kind) 161382"];
1586 [label="param GetText(SyntaxKind kind) 161383"];
1587 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 161384"];
1588 [label="return '~'; 161385"];
1589 [label="FullWidth = this.Text.Length; 161386"];
1590 [label="FullWidth 161387"];
1591 [label="this.flags |= NodeFlags.IsNotMissing; 161388"];
1592 [label="this.flags 161389"];
1593 [label="LeadingField 161390"];
1594 [label="TrailingField 161391"];
1595 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 161392"];
1596 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 161393"];
1597 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 161394"];
1598 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 161395"];
1599 [label="this.AdjustFlagsAndWidth(trailing); 161396"];
1600 [label="this.AdjustFlagsAndWidth(trailing); 161397"];
1601 [label="this.TrailingField 161398"];
1602 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 161399"];
1603 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 161400"];
1604 [label="param SyntaxToken(SyntaxKind kind) 161401"];
1605 [label="kind 161402"];
1606 [label="param CSharpSyntaxNode(SyntaxKind kind) 161403"];
1607 [label="kind 161404"];
1608 [label="param CSharpSyntaxNode(this) 161405"];
1609 [label="GreenStats.NoteGreen(this); 161406"];
1610 [label="return (SyntaxKind)this.RawKind; 161407"];
1611 [label="return SyntaxFacts.GetText(this.Kind); 161408"];
1612 [label="param GetText(SyntaxKind kind) 161409"];
1613 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 161410"];
1614 [label="return '!'; 161411"];
1615 [label="FullWidth = this.Text.Length; 161412"];
1616 [label="FullWidth 161413"];
1617 [label="this.flags |= NodeFlags.IsNotMissing; 161414"];
1618 [label="this.flags 161415"];
1619 [label="s_tokensWithNoTrivia[(int)kind].Value 161416"];
1620 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 161417"];
1621 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 161418"];
1622 [label="kind 161419"];
1623 [label="param SyntaxToken(SyntaxKind kind) 161420"];
1624 [label="kind 161421"];
1625 [label="param CSharpSyntaxNode(SyntaxKind kind) 161422"];
1626 [label="kind 161423"];
1627 [label="param CSharpSyntaxNode(this) 161424"];
1628 [label="GreenStats.NoteGreen(this); 161425"];
1629 [label="return (SyntaxKind)this.RawKind; 161426"];
1630 [label="return SyntaxFacts.GetText(this.Kind); 161427"];
1631 [label="param GetText(SyntaxKind kind) 161428"];
1632 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 161429"];
1633 [label="return '!'; 161430"];
1634 [label="FullWidth = this.Text.Length; 161431"];
1635 [label="FullWidth 161432"];
1636 [label="this.flags |= NodeFlags.IsNotMissing; 161433"];
1637 [label="this.flags 161434"];
1638 [label="this.AdjustFlagsAndWidth(leading); 161435"];
1639 [label="s_tokensWithElasticTrivia[(int)kind].Value 161436"];
1640 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 161437"];
1641 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 161438"];
1642 [label="kind 161439"];
1643 [label="param SyntaxToken(SyntaxKind kind) 161440"];
1644 [label="kind 161441"];
1645 [label="param CSharpSyntaxNode(SyntaxKind kind) 161442"];
1646 [label="kind 161443"];
1647 [label="param CSharpSyntaxNode(this) 161444"];
1648 [label="GreenStats.NoteGreen(this); 161445"];
1649 [label="return (SyntaxKind)this.RawKind; 161446"];
1650 [label="return SyntaxFacts.GetText(this.Kind); 161447"];
1651 [label="param GetText(SyntaxKind kind) 161448"];
1652 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 161449"];
1653 [label="return '!'; 161450"];
1654 [label="FullWidth = this.Text.Length; 161451"];
1655 [label="FullWidth 161452"];
1656 [label="this.flags |= NodeFlags.IsNotMissing; 161453"];
1657 [label="this.flags 161454"];
1658 [label="this.AdjustFlagsAndWidth(trailing); 161455"];
1659 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 161456"];
1660 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 161457"];
1661 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 161458"];
1662 [label="kind 161459"];
1663 [label="param SyntaxToken(SyntaxKind kind) 161460"];
1664 [label="kind 161461"];
1665 [label="param CSharpSyntaxNode(SyntaxKind kind) 161462"];
1666 [label="kind 161463"];
1667 [label="param CSharpSyntaxNode(this) 161464"];
1668 [label="GreenStats.NoteGreen(this); 161465"];
1669 [label="return (SyntaxKind)this.RawKind; 161466"];
1670 [label="return SyntaxFacts.GetText(this.Kind); 161467"];
1671 [label="param GetText(SyntaxKind kind) 161468"];
1672 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 161469"];
1673 [label="return '!'; 161470"];
1674 [label="FullWidth = this.Text.Length; 161471"];
1675 [label="FullWidth 161472"];
1676 [label="this.flags |= NodeFlags.IsNotMissing; 161473"];
1677 [label="this.flags 161474"];
1678 [label="this.AdjustFlagsAndWidth(trailing); 161475"];
1679 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 161476"];
1680 [label="return '$'; 161477"];
1681 [label="FullWidth = this.Text.Length; 161478"];
1682 [label="FullWidth 161479"];
1683 [label="return '$'; 161480"];
1684 [label="FullWidth = this.Text.Length; 161481"];
1685 [label="FullWidth 161482"];
1686 [label="this.AdjustFlagsAndWidth(leading); 161483"];
1687 [label="return '$'; 161484"];
1688 [label="FullWidth = this.Text.Length; 161485"];
1689 [label="FullWidth 161486"];
1690 [label="this.AdjustFlagsAndWidth(trailing); 161487"];
1691 [label="return '$'; 161488"];
1692 [label="FullWidth = this.Text.Length; 161489"];
1693 [label="FullWidth 161490"];
1694 [label="this.AdjustFlagsAndWidth(trailing); 161491"];
1695 [label="return '%'; 161492"];
1696 [label="FullWidth = this.Text.Length; 161493"];
1697 [label="FullWidth 161494"];
1698 [label="return '%'; 161495"];
1699 [label="FullWidth = this.Text.Length; 161496"];
1700 [label="FullWidth 161497"];
1701 [label="this.AdjustFlagsAndWidth(leading); 161498"];
1702 [label="return '%'; 161499"];
1703 [label="FullWidth = this.Text.Length; 161500"];
1704 [label="FullWidth 161501"];
1705 [label="this.AdjustFlagsAndWidth(trailing); 161502"];
1706 [label="return '%'; 161503"];
1707 [label="FullWidth = this.Text.Length; 161504"];
1708 [label="FullWidth 161505"];
1709 [label="this.AdjustFlagsAndWidth(trailing); 161506"];
1710 [label="return '^'; 161507"];
1711 [label="FullWidth = this.Text.Length; 161508"];
1712 [label="FullWidth 161509"];
1713 [label="return '^'; 161510"];
1714 [label="FullWidth = this.Text.Length; 161511"];
1715 [label="FullWidth 161512"];
1716 [label="this.AdjustFlagsAndWidth(leading); 161513"];
1717 [label="return '^'; 161514"];
1718 [label="FullWidth = this.Text.Length; 161515"];
1719 [label="FullWidth 161516"];
1720 [label="this.AdjustFlagsAndWidth(trailing); 161517"];
1721 [label="return '^'; 161518"];
1722 [label="FullWidth = this.Text.Length; 161519"];
1723 [label="FullWidth 161520"];
1724 [label="this.AdjustFlagsAndWidth(trailing); 161521"];
1725 [label="return '&'; 161522"];
1726 [label="FullWidth = this.Text.Length; 161523"];
1727 [label="FullWidth 161524"];
1728 [label="return '&'; 161525"];
1729 [label="FullWidth = this.Text.Length; 161526"];
1730 [label="FullWidth 161527"];
1731 [label="this.AdjustFlagsAndWidth(leading); 161528"];
1732 [label="return '&'; 161529"];
1733 [label="FullWidth = this.Text.Length; 161530"];
1734 [label="FullWidth 161531"];
1735 [label="this.AdjustFlagsAndWidth(trailing); 161532"];
1736 [label="return '&'; 161533"];
1737 [label="FullWidth = this.Text.Length; 161534"];
1738 [label="FullWidth 161535"];
1739 [label="this.AdjustFlagsAndWidth(trailing); 161536"];
1740 [label="return '*'; 161537"];
1741 [label="FullWidth = this.Text.Length; 161538"];
1742 [label="FullWidth 161539"];
1743 [label="return '*'; 161540"];
1744 [label="FullWidth = this.Text.Length; 161541"];
1745 [label="FullWidth 161542"];
1746 [label="this.AdjustFlagsAndWidth(leading); 161543"];
1747 [label="return '*'; 161544"];
1748 [label="FullWidth = this.Text.Length; 161545"];
1749 [label="FullWidth 161546"];
1750 [label="this.AdjustFlagsAndWidth(trailing); 161547"];
1751 [label="return '*'; 161548"];
1752 [label="FullWidth = this.Text.Length; 161549"];
1753 [label="FullWidth 161550"];
1754 [label="this.AdjustFlagsAndWidth(trailing); 161551"];
1755 [label="return '('; 161552"];
1756 [label="FullWidth = this.Text.Length; 161553"];
1757 [label="FullWidth 161554"];
1758 [label="return '('; 161555"];
1759 [label="FullWidth = this.Text.Length; 161556"];
1760 [label="FullWidth 161557"];
1761 [label="this.AdjustFlagsAndWidth(leading); 161558"];
1762 [label="return '('; 161559"];
1763 [label="FullWidth = this.Text.Length; 161560"];
1764 [label="FullWidth 161561"];
1765 [label="this.AdjustFlagsAndWidth(trailing); 161562"];
1766 [label="return '('; 161563"];
1767 [label="FullWidth = this.Text.Length; 161564"];
1768 [label="FullWidth 161565"];
1769 [label="this.AdjustFlagsAndWidth(trailing); 161566"];
1770 [label="return ')'; 161567"];
1771 [label="FullWidth = this.Text.Length; 161568"];
1772 [label="FullWidth 161569"];
1773 [label="return ')'; 161570"];
1774 [label="FullWidth = this.Text.Length; 161571"];
1775 [label="FullWidth 161572"];
1776 [label="this.AdjustFlagsAndWidth(leading); 161573"];
1777 [label="return ')'; 161574"];
1778 [label="FullWidth = this.Text.Length; 161575"];
1779 [label="FullWidth 161576"];
1780 [label="this.AdjustFlagsAndWidth(trailing); 161577"];
1781 [label="return ')'; 161578"];
1782 [label="FullWidth = this.Text.Length; 161579"];
1783 [label="FullWidth 161580"];
1784 [label="this.AdjustFlagsAndWidth(trailing); 161581"];
1785 [label="return '-'; 161582"];
1786 [label="FullWidth = this.Text.Length; 161583"];
1787 [label="FullWidth 161584"];
1788 [label="return '-'; 161585"];
1789 [label="FullWidth = this.Text.Length; 161586"];
1790 [label="FullWidth 161587"];
1791 [label="this.AdjustFlagsAndWidth(leading); 161588"];
1792 [label="return '-'; 161589"];
1793 [label="FullWidth = this.Text.Length; 161590"];
1794 [label="FullWidth 161591"];
1795 [label="this.AdjustFlagsAndWidth(trailing); 161592"];
1796 [label="return '-'; 161593"];
1797 [label="FullWidth = this.Text.Length; 161594"];
1798 [label="FullWidth 161595"];
1799 [label="this.AdjustFlagsAndWidth(trailing); 161596"];
1800 [label="return '+'; 161597"];
1801 [label="FullWidth = this.Text.Length; 161598"];
1802 [label="FullWidth 161599"];
1803 [label="return '+'; 161600"];
1804 [label="FullWidth = this.Text.Length; 161601"];
1805 [label="FullWidth 161602"];
1806 [label="this.AdjustFlagsAndWidth(leading); 161603"];
1807 [label="return '+'; 161604"];
1808 [label="FullWidth = this.Text.Length; 161605"];
1809 [label="FullWidth 161606"];
1810 [label="this.AdjustFlagsAndWidth(trailing); 161607"];
1811 [label="return '+'; 161608"];
1812 [label="FullWidth = this.Text.Length; 161609"];
1813 [label="FullWidth 161610"];
1814 [label="this.AdjustFlagsAndWidth(trailing); 161611"];
1815 [label="return '='; 161612"];
1816 [label="FullWidth = this.Text.Length; 161613"];
1817 [label="FullWidth 161614"];
1818 [label="return '='; 161615"];
1819 [label="FullWidth = this.Text.Length; 161616"];
1820 [label="FullWidth 161617"];
1821 [label="this.AdjustFlagsAndWidth(leading); 161618"];
1822 [label="return '='; 161619"];
1823 [label="FullWidth = this.Text.Length; 161620"];
1824 [label="FullWidth 161621"];
1825 [label="this.AdjustFlagsAndWidth(trailing); 161622"];
1826 [label="return '='; 161623"];
1827 [label="FullWidth = this.Text.Length; 161624"];
1828 [label="FullWidth 161625"];
1829 [label="this.AdjustFlagsAndWidth(trailing); 161626"];
1830 [label="return '{'; 161627"];
1831 [label="FullWidth = this.Text.Length; 161628"];
1832 [label="FullWidth 161629"];
1833 [label="return '{'; 161630"];
1834 [label="FullWidth = this.Text.Length; 161631"];
1835 [label="FullWidth 161632"];
1836 [label="this.AdjustFlagsAndWidth(leading); 161633"];
1837 [label="return '{'; 161634"];
1838 [label="FullWidth = this.Text.Length; 161635"];
1839 [label="FullWidth 161636"];
1840 [label="this.AdjustFlagsAndWidth(trailing); 161637"];
1841 [label="return '{'; 161638"];
1842 [label="FullWidth = this.Text.Length; 161639"];
1843 [label="FullWidth 161640"];
1844 [label="this.AdjustFlagsAndWidth(trailing); 161641"];
1845 [label="return '}'; 161642"];
1846 [label="FullWidth = this.Text.Length; 161643"];
1847 [label="FullWidth 161644"];
1848 [label="return '}'; 161645"];
1849 [label="FullWidth = this.Text.Length; 161646"];
1850 [label="FullWidth 161647"];
1851 [label="this.AdjustFlagsAndWidth(leading); 161648"];
1852 [label="return '}'; 161649"];
1853 [label="FullWidth = this.Text.Length; 161650"];
1854 [label="FullWidth 161651"];
1855 [label="this.AdjustFlagsAndWidth(trailing); 161652"];
1856 [label="return '}'; 161653"];
1857 [label="FullWidth = this.Text.Length; 161654"];
1858 [label="FullWidth 161655"];
1859 [label="this.AdjustFlagsAndWidth(trailing); 161656"];
1860 [label="return '['; 161657"];
1861 [label="FullWidth = this.Text.Length; 161658"];
1862 [label="FullWidth 161659"];
1863 [label="return '['; 161660"];
1864 [label="FullWidth = this.Text.Length; 161661"];
1865 [label="FullWidth 161662"];
1866 [label="this.AdjustFlagsAndWidth(leading); 161663"];
1867 [label="return '['; 161664"];
1868 [label="FullWidth = this.Text.Length; 161665"];
1869 [label="FullWidth 161666"];
1870 [label="this.AdjustFlagsAndWidth(trailing); 161667"];
1871 [label="return '['; 161668"];
1872 [label="FullWidth = this.Text.Length; 161669"];
1873 [label="FullWidth 161670"];
1874 [label="this.AdjustFlagsAndWidth(trailing); 161671"];
1875 [label="return ']'; 161672"];
1876 [label="FullWidth = this.Text.Length; 161673"];
1877 [label="FullWidth 161674"];
1878 [label="return ']'; 161675"];
1879 [label="FullWidth = this.Text.Length; 161676"];
1880 [label="FullWidth 161677"];
1881 [label="this.AdjustFlagsAndWidth(leading); 161678"];
1882 [label="return ']'; 161679"];
1883 [label="FullWidth = this.Text.Length; 161680"];
1884 [label="FullWidth 161681"];
1885 [label="this.AdjustFlagsAndWidth(trailing); 161682"];
1886 [label="return ']'; 161683"];
1887 [label="FullWidth = this.Text.Length; 161684"];
1888 [label="FullWidth 161685"];
1889 [label="this.AdjustFlagsAndWidth(trailing); 161686"];
1890 [label="return '|'; 161687"];
1891 [label="FullWidth = this.Text.Length; 161688"];
1892 [label="FullWidth 161689"];
1893 [label="return '|'; 161690"];
1894 [label="FullWidth = this.Text.Length; 161691"];
1895 [label="FullWidth 161692"];
1896 [label="this.AdjustFlagsAndWidth(leading); 161693"];
1897 [label="return '|'; 161694"];
1898 [label="FullWidth = this.Text.Length; 161695"];
1899 [label="FullWidth 161696"];
1900 [label="this.AdjustFlagsAndWidth(trailing); 161697"];
1901 [label="return '|'; 161698"];
1902 [label="FullWidth = this.Text.Length; 161699"];
1903 [label="FullWidth 161700"];
1904 [label="this.AdjustFlagsAndWidth(trailing); 161701"];
1905 [label="return '\\\\'; 161702"];
1906 [label="FullWidth = this.Text.Length; 161703"];
1907 [label="FullWidth 161704"];
1908 [label="return '\\\\'; 161705"];
1909 [label="FullWidth = this.Text.Length; 161706"];
1910 [label="FullWidth 161707"];
1911 [label="this.AdjustFlagsAndWidth(leading); 161708"];
1912 [label="return '\\\\'; 161709"];
1913 [label="FullWidth = this.Text.Length; 161710"];
1914 [label="FullWidth 161711"];
1915 [label="this.AdjustFlagsAndWidth(trailing); 161712"];
1916 [label="return '\\\\'; 161713"];
1917 [label="FullWidth = this.Text.Length; 161714"];
1918 [label="FullWidth 161715"];
1919 [label="this.AdjustFlagsAndWidth(trailing); 161716"];
1920 [label="return ':'; 161717"];
1921 [label="FullWidth = this.Text.Length; 161718"];
1922 [label="FullWidth 161719"];
1923 [label="return ':'; 161720"];
1924 [label="FullWidth = this.Text.Length; 161721"];
1925 [label="FullWidth 161722"];
1926 [label="this.AdjustFlagsAndWidth(leading); 161723"];
1927 [label="return ':'; 161724"];
1928 [label="FullWidth = this.Text.Length; 161725"];
1929 [label="FullWidth 161726"];
1930 [label="this.AdjustFlagsAndWidth(trailing); 161727"];
1931 [label="return ':'; 161728"];
1932 [label="FullWidth = this.Text.Length; 161729"];
1933 [label="FullWidth 161730"];
1934 [label="this.AdjustFlagsAndWidth(trailing); 161731"];
1935 [label="return ';'; 161732"];
1936 [label="FullWidth = this.Text.Length; 161733"];
1937 [label="FullWidth 161734"];
1938 [label="return ';'; 161735"];
1939 [label="FullWidth = this.Text.Length; 161736"];
1940 [label="FullWidth 161737"];
1941 [label="this.AdjustFlagsAndWidth(leading); 161738"];
1942 [label="return ';'; 161739"];
1943 [label="FullWidth = this.Text.Length; 161740"];
1944 [label="FullWidth 161741"];
1945 [label="this.AdjustFlagsAndWidth(trailing); 161742"];
1946 [label="return ';'; 161743"];
1947 [label="FullWidth = this.Text.Length; 161744"];
1948 [label="FullWidth 161745"];
1949 [label="this.AdjustFlagsAndWidth(trailing); 161746"];
1950 [label="return '\\''; 161747"];
1951 [label="FullWidth = this.Text.Length; 161748"];
1952 [label="FullWidth 161749"];
1953 [label="return '\\''; 161750"];
1954 [label="FullWidth = this.Text.Length; 161751"];
1955 [label="FullWidth 161752"];
1956 [label="this.AdjustFlagsAndWidth(leading); 161753"];
1957 [label="return '\\''; 161754"];
1958 [label="FullWidth = this.Text.Length; 161755"];
1959 [label="FullWidth 161756"];
1960 [label="this.AdjustFlagsAndWidth(trailing); 161757"];
1961 [label="return '\\''; 161758"];
1962 [label="FullWidth = this.Text.Length; 161759"];
1963 [label="FullWidth 161760"];
1964 [label="this.AdjustFlagsAndWidth(trailing); 161761"];
1965 [label="return '''; 161762"];
1966 [label="FullWidth = this.Text.Length; 161763"];
1967 [label="FullWidth 161764"];
1968 [label="return '''; 161765"];
1969 [label="FullWidth = this.Text.Length; 161766"];
1970 [label="FullWidth 161767"];
1971 [label="this.AdjustFlagsAndWidth(leading); 161768"];
1972 [label="return '''; 161769"];
1973 [label="FullWidth = this.Text.Length; 161770"];
1974 [label="FullWidth 161771"];
1975 [label="this.AdjustFlagsAndWidth(trailing); 161772"];
1976 [label="return '''; 161773"];
1977 [label="FullWidth = this.Text.Length; 161774"];
1978 [label="FullWidth 161775"];
1979 [label="this.AdjustFlagsAndWidth(trailing); 161776"];
1980 [label="return '<'; 161777"];
1981 [label="FullWidth = this.Text.Length; 161778"];
1982 [label="FullWidth 161779"];
1983 [label="return '<'; 161780"];
1984 [label="FullWidth = this.Text.Length; 161781"];
1985 [label="FullWidth 161782"];
1986 [label="this.AdjustFlagsAndWidth(leading); 161783"];
1987 [label="return '<'; 161784"];
1988 [label="FullWidth = this.Text.Length; 161785"];
1989 [label="FullWidth 161786"];
1990 [label="this.AdjustFlagsAndWidth(trailing); 161787"];
1991 [label="return '<'; 161788"];
1992 [label="FullWidth = this.Text.Length; 161789"];
1993 [label="FullWidth 161790"];
1994 [label="this.AdjustFlagsAndWidth(trailing); 161791"];
1995 [label="return ','; 161792"];
1996 [label="FullWidth = this.Text.Length; 161793"];
1997 [label="FullWidth 161794"];
1998 [label="return ','; 161795"];
1999 [label="FullWidth = this.Text.Length; 161796"];
2000 [label="FullWidth 161797"];
2001 [label="this.AdjustFlagsAndWidth(leading); 161798"];
2002 [label="return ','; 161799"];
2003 [label="FullWidth = this.Text.Length; 161800"];
2004 [label="FullWidth 161801"];
2005 [label="this.AdjustFlagsAndWidth(trailing); 161802"];
2006 [label="return ','; 161803"];
2007 [label="FullWidth = this.Text.Length; 161804"];
2008 [label="FullWidth 161805"];
2009 [label="this.AdjustFlagsAndWidth(trailing); 161806"];
2010 [label="return '>'; 161807"];
2011 [label="FullWidth = this.Text.Length; 161808"];
2012 [label="FullWidth 161809"];
2013 [label="return '>'; 161810"];
2014 [label="FullWidth = this.Text.Length; 161811"];
2015 [label="FullWidth 161812"];
2016 [label="this.AdjustFlagsAndWidth(leading); 161813"];
2017 [label="return '>'; 161814"];
2018 [label="FullWidth = this.Text.Length; 161815"];
2019 [label="FullWidth 161816"];
2020 [label="this.AdjustFlagsAndWidth(trailing); 161817"];
2021 [label="return '>'; 161818"];
2022 [label="FullWidth = this.Text.Length; 161819"];
2023 [label="FullWidth 161820"];
2024 [label="this.AdjustFlagsAndWidth(trailing); 161821"];
2025 [label="return '.'; 161822"];
2026 [label="FullWidth = this.Text.Length; 161823"];
2027 [label="FullWidth 161824"];
2028 [label="return '.'; 161825"];
2029 [label="FullWidth = this.Text.Length; 161826"];
2030 [label="FullWidth 161827"];
2031 [label="this.AdjustFlagsAndWidth(leading); 161828"];
2032 [label="return '.'; 161829"];
2033 [label="FullWidth = this.Text.Length; 161830"];
2034 [label="FullWidth 161831"];
2035 [label="this.AdjustFlagsAndWidth(trailing); 161832"];
2036 [label="return '.'; 161833"];
2037 [label="FullWidth = this.Text.Length; 161834"];
2038 [label="FullWidth 161835"];
2039 [label="this.AdjustFlagsAndWidth(trailing); 161836"];
2040 [label="return '?'; 161837"];
2041 [label="FullWidth = this.Text.Length; 161838"];
2042 [label="FullWidth 161839"];
2043 [label="return '?'; 161840"];
2044 [label="FullWidth = this.Text.Length; 161841"];
2045 [label="FullWidth 161842"];
2046 [label="this.AdjustFlagsAndWidth(leading); 161843"];
2047 [label="return '?'; 161844"];
2048 [label="FullWidth = this.Text.Length; 161845"];
2049 [label="FullWidth 161846"];
2050 [label="this.AdjustFlagsAndWidth(trailing); 161847"];
2051 [label="return '?'; 161848"];
2052 [label="FullWidth = this.Text.Length; 161849"];
2053 [label="FullWidth 161850"];
2054 [label="this.AdjustFlagsAndWidth(trailing); 161851"];
2055 [label="return '#'; 161852"];
2056 [label="FullWidth = this.Text.Length; 161853"];
2057 [label="FullWidth 161854"];
2058 [label="return '#'; 161855"];
2059 [label="FullWidth = this.Text.Length; 161856"];
2060 [label="FullWidth 161857"];
2061 [label="this.AdjustFlagsAndWidth(leading); 161858"];
2062 [label="return '#'; 161859"];
2063 [label="FullWidth = this.Text.Length; 161860"];
2064 [label="FullWidth 161861"];
2065 [label="this.AdjustFlagsAndWidth(trailing); 161862"];
2066 [label="return '#'; 161863"];
2067 [label="FullWidth = this.Text.Length; 161864"];
2068 [label="FullWidth 161865"];
2069 [label="this.AdjustFlagsAndWidth(trailing); 161866"];
2070 [label="return '/'; 161867"];
2071 [label="FullWidth = this.Text.Length; 161868"];
2072 [label="FullWidth 161869"];
2073 [label="return '/'; 161870"];
2074 [label="FullWidth = this.Text.Length; 161871"];
2075 [label="FullWidth 161872"];
2076 [label="this.AdjustFlagsAndWidth(leading); 161873"];
2077 [label="return '/'; 161874"];
2078 [label="FullWidth = this.Text.Length; 161875"];
2079 [label="FullWidth 161876"];
2080 [label="this.AdjustFlagsAndWidth(trailing); 161877"];
2081 [label="return '/'; 161878"];
2082 [label="FullWidth = this.Text.Length; 161879"];
2083 [label="FullWidth 161880"];
2084 [label="this.AdjustFlagsAndWidth(trailing); 161881"];
2085 [label="return '..'; 161882"];
2086 [label="FullWidth = this.Text.Length; 161883"];
2087 [label="FullWidth 161884"];
2088 [label="return '..'; 161885"];
2089 [label="FullWidth = this.Text.Length; 161886"];
2090 [label="FullWidth 161887"];
2091 [label="this.AdjustFlagsAndWidth(leading); 161888"];
2092 [label="return '..'; 161889"];
2093 [label="FullWidth = this.Text.Length; 161890"];
2094 [label="FullWidth 161891"];
2095 [label="this.AdjustFlagsAndWidth(trailing); 161892"];
2096 [label="return '..'; 161893"];
2097 [label="FullWidth = this.Text.Length; 161894"];
2098 [label="FullWidth 161895"];
2099 [label="this.AdjustFlagsAndWidth(trailing); 161896"];
2100 [label="return string.Empty; 161897"];
2101 [label="FullWidth = this.Text.Length; 161898"];
2102 [label="FullWidth 161899"];
2103 [label="return string.Empty; 161900"];
2104 [label="FullWidth = this.Text.Length; 161901"];
2105 [label="FullWidth 161902"];
2106 [label="this.AdjustFlagsAndWidth(leading); 161903"];
2107 [label="return string.Empty; 161904"];
2108 [label="FullWidth = this.Text.Length; 161905"];
2109 [label="FullWidth 161906"];
2110 [label="this.AdjustFlagsAndWidth(trailing); 161907"];
2111 [label="return string.Empty; 161908"];
2112 [label="FullWidth = this.Text.Length; 161909"];
2113 [label="FullWidth 161910"];
2114 [label="this.AdjustFlagsAndWidth(trailing); 161911"];
2115 [label="return '/>'; 161912"];
2116 [label="FullWidth = this.Text.Length; 161913"];
2117 [label="FullWidth 161914"];
2118 [label="return '/>'; 161915"];
2119 [label="FullWidth = this.Text.Length; 161916"];
2120 [label="FullWidth 161917"];
2121 [label="this.AdjustFlagsAndWidth(leading); 161918"];
2122 [label="return '/>'; 161919"];
2123 [label="FullWidth = this.Text.Length; 161920"];
2124 [label="FullWidth 161921"];
2125 [label="this.AdjustFlagsAndWidth(trailing); 161922"];
2126 [label="return '/>'; 161923"];
2127 [label="FullWidth = this.Text.Length; 161924"];
2128 [label="FullWidth 161925"];
2129 [label="this.AdjustFlagsAndWidth(trailing); 161926"];
2130 [label="return '</'; 161927"];
2131 [label="FullWidth = this.Text.Length; 161928"];
2132 [label="FullWidth 161929"];
2133 [label="return '</'; 161930"];
2134 [label="FullWidth = this.Text.Length; 161931"];
2135 [label="FullWidth 161932"];
2136 [label="this.AdjustFlagsAndWidth(leading); 161933"];
2137 [label="return '</'; 161934"];
2138 [label="FullWidth = this.Text.Length; 161935"];
2139 [label="FullWidth 161936"];
2140 [label="this.AdjustFlagsAndWidth(trailing); 161937"];
2141 [label="return '</'; 161938"];
2142 [label="FullWidth = this.Text.Length; 161939"];
2143 [label="FullWidth 161940"];
2144 [label="this.AdjustFlagsAndWidth(trailing); 161941"];
2145 [label="return '<!--'; 161942"];
2146 [label="FullWidth = this.Text.Length; 161943"];
2147 [label="FullWidth 161944"];
2148 [label="return '<!--'; 161945"];
2149 [label="FullWidth = this.Text.Length; 161946"];
2150 [label="FullWidth 161947"];
2151 [label="this.AdjustFlagsAndWidth(leading); 161948"];
2152 [label="return '<!--'; 161949"];
2153 [label="FullWidth = this.Text.Length; 161950"];
2154 [label="FullWidth 161951"];
2155 [label="this.AdjustFlagsAndWidth(trailing); 161952"];
2156 [label="return '<!--'; 161953"];
2157 [label="FullWidth = this.Text.Length; 161954"];
2158 [label="FullWidth 161955"];
2159 [label="this.AdjustFlagsAndWidth(trailing); 161956"];
2160 [label="return '-->'; 161957"];
2161 [label="FullWidth = this.Text.Length; 161958"];
2162 [label="FullWidth 161959"];
2163 [label="return '-->'; 161960"];
2164 [label="FullWidth = this.Text.Length; 161961"];
2165 [label="FullWidth 161962"];
2166 [label="this.AdjustFlagsAndWidth(leading); 161963"];
2167 [label="return '-->'; 161964"];
2168 [label="FullWidth = this.Text.Length; 161965"];
2169 [label="FullWidth 161966"];
2170 [label="this.AdjustFlagsAndWidth(trailing); 161967"];
2171 [label="return '-->'; 161968"];
2172 [label="FullWidth = this.Text.Length; 161969"];
2173 [label="FullWidth 161970"];
2174 [label="this.AdjustFlagsAndWidth(trailing); 161971"];
2175 [label="return '<![CDATA['; 161972"];
2176 [label="FullWidth = this.Text.Length; 161973"];
2177 [label="FullWidth 161974"];
2178 [label="return '<![CDATA['; 161975"];
2179 [label="FullWidth = this.Text.Length; 161976"];
2180 [label="FullWidth 161977"];
2181 [label="this.AdjustFlagsAndWidth(leading); 161978"];
2182 [label="return '<![CDATA['; 161979"];
2183 [label="FullWidth = this.Text.Length; 161980"];
2184 [label="FullWidth 161981"];
2185 [label="this.AdjustFlagsAndWidth(trailing); 161982"];
2186 [label="return '<![CDATA['; 161983"];
2187 [label="FullWidth = this.Text.Length; 161984"];
2188 [label="FullWidth 161985"];
2189 [label="this.AdjustFlagsAndWidth(trailing); 161986"];
2190 [label="return ']]>'; 161987"];
2191 [label="FullWidth = this.Text.Length; 161988"];
2192 [label="FullWidth 161989"];
2193 [label="return ']]>'; 161990"];
2194 [label="FullWidth = this.Text.Length; 161991"];
2195 [label="FullWidth 161992"];
2196 [label="this.AdjustFlagsAndWidth(leading); 161993"];
2197 [label="return ']]>'; 161994"];
2198 [label="FullWidth = this.Text.Length; 161995"];
2199 [label="FullWidth 161996"];
2200 [label="this.AdjustFlagsAndWidth(trailing); 161997"];
2201 [label="return ']]>'; 161998"];
2202 [label="FullWidth = this.Text.Length; 161999"];
2203 [label="FullWidth 162000"];
2204 [label="this.AdjustFlagsAndWidth(trailing); 162001"];
2205 [label="return '<?'; 162002"];
2206 [label="FullWidth = this.Text.Length; 162003"];
2207 [label="FullWidth 162004"];
2208 [label="return '<?'; 162005"];
2209 [label="FullWidth = this.Text.Length; 162006"];
2210 [label="FullWidth 162007"];
2211 [label="this.AdjustFlagsAndWidth(leading); 162008"];
2212 [label="return '<?'; 162009"];
2213 [label="FullWidth = this.Text.Length; 162010"];
2214 [label="FullWidth 162011"];
2215 [label="this.AdjustFlagsAndWidth(trailing); 162012"];
2216 [label="return '<?'; 162013"];
2217 [label="FullWidth = this.Text.Length; 162014"];
2218 [label="FullWidth 162015"];
2219 [label="this.AdjustFlagsAndWidth(trailing); 162016"];
2220 [label="return '?>'; 162017"];
2221 [label="FullWidth = this.Text.Length; 162018"];
2222 [label="FullWidth 162019"];
2223 [label="return '?>'; 162020"];
2224 [label="FullWidth = this.Text.Length; 162021"];
2225 [label="FullWidth 162022"];
2226 [label="this.AdjustFlagsAndWidth(leading); 162023"];
2227 [label="return '?>'; 162024"];
2228 [label="FullWidth = this.Text.Length; 162025"];
2229 [label="FullWidth 162026"];
2230 [label="this.AdjustFlagsAndWidth(trailing); 162027"];
2231 [label="return '?>'; 162028"];
2232 [label="FullWidth = this.Text.Length; 162029"];
2233 [label="FullWidth 162030"];
2234 [label="this.AdjustFlagsAndWidth(trailing); 162031"];
2235 [label="return '||'; 162032"];
2236 [label="FullWidth = this.Text.Length; 162033"];
2237 [label="FullWidth 162034"];
2238 [label="return '||'; 162035"];
2239 [label="FullWidth = this.Text.Length; 162036"];
2240 [label="FullWidth 162037"];
2241 [label="this.AdjustFlagsAndWidth(leading); 162038"];
2242 [label="return '||'; 162039"];
2243 [label="FullWidth = this.Text.Length; 162040"];
2244 [label="FullWidth 162041"];
2245 [label="this.AdjustFlagsAndWidth(trailing); 162042"];
2246 [label="return '||'; 162043"];
2247 [label="FullWidth = this.Text.Length; 162044"];
2248 [label="FullWidth 162045"];
2249 [label="this.AdjustFlagsAndWidth(trailing); 162046"];
2250 [label="return '&&'; 162047"];
2251 [label="FullWidth = this.Text.Length; 162048"];
2252 [label="FullWidth 162049"];
2253 [label="return '&&'; 162050"];
2254 [label="FullWidth = this.Text.Length; 162051"];
2255 [label="FullWidth 162052"];
2256 [label="this.AdjustFlagsAndWidth(leading); 162053"];
2257 [label="return '&&'; 162054"];
2258 [label="FullWidth = this.Text.Length; 162055"];
2259 [label="FullWidth 162056"];
2260 [label="this.AdjustFlagsAndWidth(trailing); 162057"];
2261 [label="return '&&'; 162058"];
2262 [label="FullWidth = this.Text.Length; 162059"];
2263 [label="FullWidth 162060"];
2264 [label="this.AdjustFlagsAndWidth(trailing); 162061"];
2265 [label="return '--'; 162062"];
2266 [label="FullWidth = this.Text.Length; 162063"];
2267 [label="FullWidth 162064"];
2268 [label="return '--'; 162065"];
2269 [label="FullWidth = this.Text.Length; 162066"];
2270 [label="FullWidth 162067"];
2271 [label="this.AdjustFlagsAndWidth(leading); 162068"];
2272 [label="return '--'; 162069"];
2273 [label="FullWidth = this.Text.Length; 162070"];
2274 [label="FullWidth 162071"];
2275 [label="this.AdjustFlagsAndWidth(trailing); 162072"];
2276 [label="return '--'; 162073"];
2277 [label="FullWidth = this.Text.Length; 162074"];
2278 [label="FullWidth 162075"];
2279 [label="this.AdjustFlagsAndWidth(trailing); 162076"];
2280 [label="return '++'; 162077"];
2281 [label="FullWidth = this.Text.Length; 162078"];
2282 [label="FullWidth 162079"];
2283 [label="return '++'; 162080"];
2284 [label="FullWidth = this.Text.Length; 162081"];
2285 [label="FullWidth 162082"];
2286 [label="this.AdjustFlagsAndWidth(leading); 162083"];
2287 [label="return '++'; 162084"];
2288 [label="FullWidth = this.Text.Length; 162085"];
2289 [label="FullWidth 162086"];
2290 [label="this.AdjustFlagsAndWidth(trailing); 162087"];
2291 [label="return '++'; 162088"];
2292 [label="FullWidth = this.Text.Length; 162089"];
2293 [label="FullWidth 162090"];
2294 [label="this.AdjustFlagsAndWidth(trailing); 162091"];
2295 [label="return '::'; 162092"];
2296 [label="FullWidth = this.Text.Length; 162093"];
2297 [label="FullWidth 162094"];
2298 [label="return '::'; 162095"];
2299 [label="FullWidth = this.Text.Length; 162096"];
2300 [label="FullWidth 162097"];
2301 [label="this.AdjustFlagsAndWidth(leading); 162098"];
2302 [label="return '::'; 162099"];
2303 [label="FullWidth = this.Text.Length; 162100"];
2304 [label="FullWidth 162101"];
2305 [label="this.AdjustFlagsAndWidth(trailing); 162102"];
2306 [label="return '::'; 162103"];
2307 [label="FullWidth = this.Text.Length; 162104"];
2308 [label="FullWidth 162105"];
2309 [label="this.AdjustFlagsAndWidth(trailing); 162106"];
2310 [label="return '??'; 162107"];
2311 [label="FullWidth = this.Text.Length; 162108"];
2312 [label="FullWidth 162109"];
2313 [label="return '??'; 162110"];
2314 [label="FullWidth = this.Text.Length; 162111"];
2315 [label="FullWidth 162112"];
2316 [label="this.AdjustFlagsAndWidth(leading); 162113"];
2317 [label="return '??'; 162114"];
2318 [label="FullWidth = this.Text.Length; 162115"];
2319 [label="FullWidth 162116"];
2320 [label="this.AdjustFlagsAndWidth(trailing); 162117"];
2321 [label="return '??'; 162118"];
2322 [label="FullWidth = this.Text.Length; 162119"];
2323 [label="FullWidth 162120"];
2324 [label="this.AdjustFlagsAndWidth(trailing); 162121"];
2325 [label="return '->'; 162122"];
2326 [label="FullWidth = this.Text.Length; 162123"];
2327 [label="FullWidth 162124"];
2328 [label="return '->'; 162125"];
2329 [label="FullWidth = this.Text.Length; 162126"];
2330 [label="FullWidth 162127"];
2331 [label="this.AdjustFlagsAndWidth(leading); 162128"];
2332 [label="return '->'; 162129"];
2333 [label="FullWidth = this.Text.Length; 162130"];
2334 [label="FullWidth 162131"];
2335 [label="this.AdjustFlagsAndWidth(trailing); 162132"];
2336 [label="return '->'; 162133"];
2337 [label="FullWidth = this.Text.Length; 162134"];
2338 [label="FullWidth 162135"];
2339 [label="this.AdjustFlagsAndWidth(trailing); 162136"];
2340 [label="return '!='; 162137"];
2341 [label="FullWidth = this.Text.Length; 162138"];
2342 [label="FullWidth 162139"];
2343 [label="return '!='; 162140"];
2344 [label="FullWidth = this.Text.Length; 162141"];
2345 [label="FullWidth 162142"];
2346 [label="this.AdjustFlagsAndWidth(leading); 162143"];
2347 [label="return '!='; 162144"];
2348 [label="FullWidth = this.Text.Length; 162145"];
2349 [label="FullWidth 162146"];
2350 [label="this.AdjustFlagsAndWidth(trailing); 162147"];
2351 [label="return '!='; 162148"];
2352 [label="FullWidth = this.Text.Length; 162149"];
2353 [label="FullWidth 162150"];
2354 [label="this.AdjustFlagsAndWidth(trailing); 162151"];
2355 [label="return '=='; 162152"];
2356 [label="FullWidth = this.Text.Length; 162153"];
2357 [label="FullWidth 162154"];
2358 [label="return '=='; 162155"];
2359 [label="FullWidth = this.Text.Length; 162156"];
2360 [label="FullWidth 162157"];
2361 [label="this.AdjustFlagsAndWidth(leading); 162158"];
2362 [label="return '=='; 162159"];
2363 [label="FullWidth = this.Text.Length; 162160"];
2364 [label="FullWidth 162161"];
2365 [label="this.AdjustFlagsAndWidth(trailing); 162162"];
2366 [label="return '=='; 162163"];
2367 [label="FullWidth = this.Text.Length; 162164"];
2368 [label="FullWidth 162165"];
2369 [label="this.AdjustFlagsAndWidth(trailing); 162166"];
2370 [label="return '=>'; 162167"];
2371 [label="FullWidth = this.Text.Length; 162168"];
2372 [label="FullWidth 162169"];
2373 [label="return '=>'; 162170"];
2374 [label="FullWidth = this.Text.Length; 162171"];
2375 [label="FullWidth 162172"];
2376 [label="this.AdjustFlagsAndWidth(leading); 162173"];
2377 [label="return '=>'; 162174"];
2378 [label="FullWidth = this.Text.Length; 162175"];
2379 [label="FullWidth 162176"];
2380 [label="this.AdjustFlagsAndWidth(trailing); 162177"];
2381 [label="return '=>'; 162178"];
2382 [label="FullWidth = this.Text.Length; 162179"];
2383 [label="FullWidth 162180"];
2384 [label="this.AdjustFlagsAndWidth(trailing); 162181"];
2385 [label="return '<='; 162182"];
2386 [label="FullWidth = this.Text.Length; 162183"];
2387 [label="FullWidth 162184"];
2388 [label="return '<='; 162185"];
2389 [label="FullWidth = this.Text.Length; 162186"];
2390 [label="FullWidth 162187"];
2391 [label="this.AdjustFlagsAndWidth(leading); 162188"];
2392 [label="return '<='; 162189"];
2393 [label="FullWidth = this.Text.Length; 162190"];
2394 [label="FullWidth 162191"];
2395 [label="this.AdjustFlagsAndWidth(trailing); 162192"];
2396 [label="return '<='; 162193"];
2397 [label="FullWidth = this.Text.Length; 162194"];
2398 [label="FullWidth 162195"];
2399 [label="this.AdjustFlagsAndWidth(trailing); 162196"];
2400 [label="return '<<'; 162197"];
2401 [label="FullWidth = this.Text.Length; 162198"];
2402 [label="FullWidth 162199"];
2403 [label="return '<<'; 162200"];
2404 [label="FullWidth = this.Text.Length; 162201"];
2405 [label="FullWidth 162202"];
2406 [label="this.AdjustFlagsAndWidth(leading); 162203"];
2407 [label="return '<<'; 162204"];
2408 [label="FullWidth = this.Text.Length; 162205"];
2409 [label="FullWidth 162206"];
2410 [label="this.AdjustFlagsAndWidth(trailing); 162207"];
2411 [label="return '<<'; 162208"];
2412 [label="FullWidth = this.Text.Length; 162209"];
2413 [label="FullWidth 162210"];
2414 [label="this.AdjustFlagsAndWidth(trailing); 162211"];
2415 [label="return '<<='; 162212"];
2416 [label="FullWidth = this.Text.Length; 162213"];
2417 [label="FullWidth 162214"];
2418 [label="return '<<='; 162215"];
2419 [label="FullWidth = this.Text.Length; 162216"];
2420 [label="FullWidth 162217"];
2421 [label="this.AdjustFlagsAndWidth(leading); 162218"];
2422 [label="return '<<='; 162219"];
2423 [label="FullWidth = this.Text.Length; 162220"];
2424 [label="FullWidth 162221"];
2425 [label="this.AdjustFlagsAndWidth(trailing); 162222"];
2426 [label="return '<<='; 162223"];
2427 [label="FullWidth = this.Text.Length; 162224"];
2428 [label="FullWidth 162225"];
2429 [label="this.AdjustFlagsAndWidth(trailing); 162226"];
2430 [label="return '>='; 162227"];
2431 [label="FullWidth = this.Text.Length; 162228"];
2432 [label="FullWidth 162229"];
2433 [label="return '>='; 162230"];
2434 [label="FullWidth = this.Text.Length; 162231"];
2435 [label="FullWidth 162232"];
2436 [label="this.AdjustFlagsAndWidth(leading); 162233"];
2437 [label="return '>='; 162234"];
2438 [label="FullWidth = this.Text.Length; 162235"];
2439 [label="FullWidth 162236"];
2440 [label="this.AdjustFlagsAndWidth(trailing); 162237"];
2441 [label="return '>='; 162238"];
2442 [label="FullWidth = this.Text.Length; 162239"];
2443 [label="FullWidth 162240"];
2444 [label="this.AdjustFlagsAndWidth(trailing); 162241"];
2445 [label="return '>>'; 162242"];
2446 [label="FullWidth = this.Text.Length; 162243"];
2447 [label="FullWidth 162244"];
2448 [label="return '>>'; 162245"];
2449 [label="FullWidth = this.Text.Length; 162246"];
2450 [label="FullWidth 162247"];
2451 [label="this.AdjustFlagsAndWidth(leading); 162248"];
2452 [label="return '>>'; 162249"];
2453 [label="FullWidth = this.Text.Length; 162250"];
2454 [label="FullWidth 162251"];
2455 [label="this.AdjustFlagsAndWidth(trailing); 162252"];
2456 [label="return '>>'; 162253"];
2457 [label="FullWidth = this.Text.Length; 162254"];
2458 [label="FullWidth 162255"];
2459 [label="this.AdjustFlagsAndWidth(trailing); 162256"];
2460 [label="return '>>='; 162257"];
2461 [label="FullWidth = this.Text.Length; 162258"];
2462 [label="FullWidth 162259"];
2463 [label="return '>>='; 162260"];
2464 [label="FullWidth = this.Text.Length; 162261"];
2465 [label="FullWidth 162262"];
2466 [label="this.AdjustFlagsAndWidth(leading); 162263"];
2467 [label="return '>>='; 162264"];
2468 [label="FullWidth = this.Text.Length; 162265"];
2469 [label="FullWidth 162266"];
2470 [label="this.AdjustFlagsAndWidth(trailing); 162267"];
2471 [label="return '>>='; 162268"];
2472 [label="FullWidth = this.Text.Length; 162269"];
2473 [label="FullWidth 162270"];
2474 [label="this.AdjustFlagsAndWidth(trailing); 162271"];
2475 [label="return '/='; 162272"];
2476 [label="FullWidth = this.Text.Length; 162273"];
2477 [label="FullWidth 162274"];
2478 [label="return '/='; 162275"];
2479 [label="FullWidth = this.Text.Length; 162276"];
2480 [label="FullWidth 162277"];
2481 [label="this.AdjustFlagsAndWidth(leading); 162278"];
2482 [label="return '/='; 162279"];
2483 [label="FullWidth = this.Text.Length; 162280"];
2484 [label="FullWidth 162281"];
2485 [label="this.AdjustFlagsAndWidth(trailing); 162282"];
2486 [label="return '/='; 162283"];
2487 [label="FullWidth = this.Text.Length; 162284"];
2488 [label="FullWidth 162285"];
2489 [label="this.AdjustFlagsAndWidth(trailing); 162286"];
2490 [label="return '*='; 162287"];
2491 [label="FullWidth = this.Text.Length; 162288"];
2492 [label="FullWidth 162289"];
2493 [label="return '*='; 162290"];
2494 [label="FullWidth = this.Text.Length; 162291"];
2495 [label="FullWidth 162292"];
2496 [label="this.AdjustFlagsAndWidth(leading); 162293"];
2497 [label="return '*='; 162294"];
2498 [label="FullWidth = this.Text.Length; 162295"];
2499 [label="FullWidth 162296"];
2500 [label="this.AdjustFlagsAndWidth(trailing); 162297"];
2501 [label="return '*='; 162298"];
2502 [label="FullWidth = this.Text.Length; 162299"];
2503 [label="FullWidth 162300"];
2504 [label="this.AdjustFlagsAndWidth(trailing); 162301"];
2505 [label="return '|='; 162302"];
2506 [label="FullWidth = this.Text.Length; 162303"];
2507 [label="FullWidth 162304"];
2508 [label="return '|='; 162305"];
2509 [label="FullWidth = this.Text.Length; 162306"];
2510 [label="FullWidth 162307"];
2511 [label="this.AdjustFlagsAndWidth(leading); 162308"];
2512 [label="return '|='; 162309"];
2513 [label="FullWidth = this.Text.Length; 162310"];
2514 [label="FullWidth 162311"];
2515 [label="this.AdjustFlagsAndWidth(trailing); 162312"];
2516 [label="return '|='; 162313"];
2517 [label="FullWidth = this.Text.Length; 162314"];
2518 [label="FullWidth 162315"];
2519 [label="this.AdjustFlagsAndWidth(trailing); 162316"];
2520 [label="return '&='; 162317"];
2521 [label="FullWidth = this.Text.Length; 162318"];
2522 [label="FullWidth 162319"];
2523 [label="return '&='; 162320"];
2524 [label="FullWidth = this.Text.Length; 162321"];
2525 [label="FullWidth 162322"];
2526 [label="this.AdjustFlagsAndWidth(leading); 162323"];
2527 [label="return '&='; 162324"];
2528 [label="FullWidth = this.Text.Length; 162325"];
2529 [label="FullWidth 162326"];
2530 [label="this.AdjustFlagsAndWidth(trailing); 162327"];
2531 [label="return '&='; 162328"];
2532 [label="FullWidth = this.Text.Length; 162329"];
2533 [label="FullWidth 162330"];
2534 [label="this.AdjustFlagsAndWidth(trailing); 162331"];
2535 [label="return '+='; 162332"];
2536 [label="FullWidth = this.Text.Length; 162333"];
2537 [label="FullWidth 162334"];
2538 [label="return '+='; 162335"];
2539 [label="FullWidth = this.Text.Length; 162336"];
2540 [label="FullWidth 162337"];
2541 [label="this.AdjustFlagsAndWidth(leading); 162338"];
2542 [label="return '+='; 162339"];
2543 [label="FullWidth = this.Text.Length; 162340"];
2544 [label="FullWidth 162341"];
2545 [label="this.AdjustFlagsAndWidth(trailing); 162342"];
2546 [label="return '+='; 162343"];
2547 [label="FullWidth = this.Text.Length; 162344"];
2548 [label="FullWidth 162345"];
2549 [label="this.AdjustFlagsAndWidth(trailing); 162346"];
2550 [label="return '-='; 162347"];
2551 [label="FullWidth = this.Text.Length; 162348"];
2552 [label="FullWidth 162349"];
2553 [label="return '-='; 162350"];
2554 [label="FullWidth = this.Text.Length; 162351"];
2555 [label="FullWidth 162352"];
2556 [label="this.AdjustFlagsAndWidth(leading); 162353"];
2557 [label="return '-='; 162354"];
2558 [label="FullWidth = this.Text.Length; 162355"];
2559 [label="FullWidth 162356"];
2560 [label="this.AdjustFlagsAndWidth(trailing); 162357"];
2561 [label="return '-='; 162358"];
2562 [label="FullWidth = this.Text.Length; 162359"];
2563 [label="FullWidth 162360"];
2564 [label="this.AdjustFlagsAndWidth(trailing); 162361"];
2565 [label="return '^='; 162362"];
2566 [label="FullWidth = this.Text.Length; 162363"];
2567 [label="FullWidth 162364"];
2568 [label="return '^='; 162365"];
2569 [label="FullWidth = this.Text.Length; 162366"];
2570 [label="FullWidth 162367"];
2571 [label="this.AdjustFlagsAndWidth(leading); 162368"];
2572 [label="return '^='; 162369"];
2573 [label="FullWidth = this.Text.Length; 162370"];
2574 [label="FullWidth 162371"];
2575 [label="this.AdjustFlagsAndWidth(trailing); 162372"];
2576 [label="return '^='; 162373"];
2577 [label="FullWidth = this.Text.Length; 162374"];
2578 [label="FullWidth 162375"];
2579 [label="this.AdjustFlagsAndWidth(trailing); 162376"];
2580 [label="return '%='; 162377"];
2581 [label="FullWidth = this.Text.Length; 162378"];
2582 [label="FullWidth 162379"];
2583 [label="return '%='; 162380"];
2584 [label="FullWidth = this.Text.Length; 162381"];
2585 [label="FullWidth 162382"];
2586 [label="this.AdjustFlagsAndWidth(leading); 162383"];
2587 [label="return '%='; 162384"];
2588 [label="FullWidth = this.Text.Length; 162385"];
2589 [label="FullWidth 162386"];
2590 [label="this.AdjustFlagsAndWidth(trailing); 162387"];
2591 [label="return '%='; 162388"];
2592 [label="FullWidth = this.Text.Length; 162389"];
2593 [label="FullWidth 162390"];
2594 [label="this.AdjustFlagsAndWidth(trailing); 162391"];
2595 [label="return '??='; 162392"];
2596 [label="FullWidth = this.Text.Length; 162393"];
2597 [label="FullWidth 162394"];
2598 [label="return '??='; 162395"];
2599 [label="FullWidth = this.Text.Length; 162396"];
2600 [label="FullWidth 162397"];
2601 [label="this.AdjustFlagsAndWidth(leading); 162398"];
2602 [label="return '??='; 162399"];
2603 [label="FullWidth = this.Text.Length; 162400"];
2604 [label="FullWidth 162401"];
2605 [label="this.AdjustFlagsAndWidth(trailing); 162402"];
2606 [label="return '??='; 162403"];
2607 [label="FullWidth = this.Text.Length; 162404"];
2608 [label="FullWidth 162405"];
2609 [label="this.AdjustFlagsAndWidth(trailing); 162406"];
2610 [label="return 'bool'; 162407"];
2611 [label="FullWidth = this.Text.Length; 162408"];
2612 [label="FullWidth 162409"];
2613 [label="return 'bool'; 162410"];
2614 [label="FullWidth = this.Text.Length; 162411"];
2615 [label="FullWidth 162412"];
2616 [label="this.AdjustFlagsAndWidth(leading); 162413"];
2617 [label="return 'bool'; 162414"];
2618 [label="FullWidth = this.Text.Length; 162415"];
2619 [label="FullWidth 162416"];
2620 [label="this.AdjustFlagsAndWidth(trailing); 162417"];
2621 [label="return 'bool'; 162418"];
2622 [label="FullWidth = this.Text.Length; 162419"];
2623 [label="FullWidth 162420"];
2624 [label="this.AdjustFlagsAndWidth(trailing); 162421"];
2625 [label="return 'byte'; 162422"];
2626 [label="FullWidth = this.Text.Length; 162423"];
2627 [label="FullWidth 162424"];
2628 [label="return 'byte'; 162425"];
2629 [label="FullWidth = this.Text.Length; 162426"];
2630 [label="FullWidth 162427"];
2631 [label="this.AdjustFlagsAndWidth(leading); 162428"];
2632 [label="return 'byte'; 162429"];
2633 [label="FullWidth = this.Text.Length; 162430"];
2634 [label="FullWidth 162431"];
2635 [label="this.AdjustFlagsAndWidth(trailing); 162432"];
2636 [label="return 'byte'; 162433"];
2637 [label="FullWidth = this.Text.Length; 162434"];
2638 [label="FullWidth 162435"];
2639 [label="this.AdjustFlagsAndWidth(trailing); 162436"];
2640 [label="return 'sbyte'; 162437"];
2641 [label="FullWidth = this.Text.Length; 162438"];
2642 [label="FullWidth 162439"];
2643 [label="return 'sbyte'; 162440"];
2644 [label="FullWidth = this.Text.Length; 162441"];
2645 [label="FullWidth 162442"];
2646 [label="this.AdjustFlagsAndWidth(leading); 162443"];
2647 [label="return 'sbyte'; 162444"];
2648 [label="FullWidth = this.Text.Length; 162445"];
2649 [label="FullWidth 162446"];
2650 [label="this.AdjustFlagsAndWidth(trailing); 162447"];
2651 [label="return 'sbyte'; 162448"];
2652 [label="FullWidth = this.Text.Length; 162449"];
2653 [label="FullWidth 162450"];
2654 [label="this.AdjustFlagsAndWidth(trailing); 162451"];
2655 [label="return 'short'; 162452"];
2656 [label="FullWidth = this.Text.Length; 162453"];
2657 [label="FullWidth 162454"];
2658 [label="return 'short'; 162455"];
2659 [label="FullWidth = this.Text.Length; 162456"];
2660 [label="FullWidth 162457"];
2661 [label="this.AdjustFlagsAndWidth(leading); 162458"];
2662 [label="return 'short'; 162459"];
2663 [label="FullWidth = this.Text.Length; 162460"];
2664 [label="FullWidth 162461"];
2665 [label="this.AdjustFlagsAndWidth(trailing); 162462"];
2666 [label="return 'short'; 162463"];
2667 [label="FullWidth = this.Text.Length; 162464"];
2668 [label="FullWidth 162465"];
2669 [label="this.AdjustFlagsAndWidth(trailing); 162466"];
2670 [label="return 'ushort'; 162467"];
2671 [label="FullWidth = this.Text.Length; 162468"];
2672 [label="FullWidth 162469"];
2673 [label="return 'ushort'; 162470"];
2674 [label="FullWidth = this.Text.Length; 162471"];
2675 [label="FullWidth 162472"];
2676 [label="this.AdjustFlagsAndWidth(leading); 162473"];
2677 [label="return 'ushort'; 162474"];
2678 [label="FullWidth = this.Text.Length; 162475"];
2679 [label="FullWidth 162476"];
2680 [label="this.AdjustFlagsAndWidth(trailing); 162477"];
2681 [label="return 'ushort'; 162478"];
2682 [label="FullWidth = this.Text.Length; 162479"];
2683 [label="FullWidth 162480"];
2684 [label="this.AdjustFlagsAndWidth(trailing); 162481"];
2685 [label="return 'int'; 162482"];
2686 [label="FullWidth = this.Text.Length; 162483"];
2687 [label="FullWidth 162484"];
2688 [label="return 'int'; 162485"];
2689 [label="FullWidth = this.Text.Length; 162486"];
2690 [label="FullWidth 162487"];
2691 [label="this.AdjustFlagsAndWidth(leading); 162488"];
2692 [label="return 'int'; 162489"];
2693 [label="FullWidth = this.Text.Length; 162490"];
2694 [label="FullWidth 162491"];
2695 [label="this.AdjustFlagsAndWidth(trailing); 162492"];
2696 [label="return 'int'; 162493"];
2697 [label="FullWidth = this.Text.Length; 162494"];
2698 [label="FullWidth 162495"];
2699 [label="this.AdjustFlagsAndWidth(trailing); 162496"];
2700 [label="return 'uint'; 162497"];
2701 [label="FullWidth = this.Text.Length; 162498"];
2702 [label="FullWidth 162499"];
2703 [label="return 'uint'; 162500"];
2704 [label="FullWidth = this.Text.Length; 162501"];
2705 [label="FullWidth 162502"];
2706 [label="this.AdjustFlagsAndWidth(leading); 162503"];
2707 [label="return 'uint'; 162504"];
2708 [label="FullWidth = this.Text.Length; 162505"];
2709 [label="FullWidth 162506"];
2710 [label="this.AdjustFlagsAndWidth(trailing); 162507"];
2711 [label="return 'uint'; 162508"];
2712 [label="FullWidth = this.Text.Length; 162509"];
2713 [label="FullWidth 162510"];
2714 [label="this.AdjustFlagsAndWidth(trailing); 162511"];
2715 [label="return 'long'; 162512"];
2716 [label="FullWidth = this.Text.Length; 162513"];
2717 [label="FullWidth 162514"];
2718 [label="return 'long'; 162515"];
2719 [label="FullWidth = this.Text.Length; 162516"];
2720 [label="FullWidth 162517"];
2721 [label="this.AdjustFlagsAndWidth(leading); 162518"];
2722 [label="return 'long'; 162519"];
2723 [label="FullWidth = this.Text.Length; 162520"];
2724 [label="FullWidth 162521"];
2725 [label="this.AdjustFlagsAndWidth(trailing); 162522"];
2726 [label="return 'long'; 162523"];
2727 [label="FullWidth = this.Text.Length; 162524"];
2728 [label="FullWidth 162525"];
2729 [label="this.AdjustFlagsAndWidth(trailing); 162526"];
2730 [label="return 'ulong'; 162527"];
2731 [label="FullWidth = this.Text.Length; 162528"];
2732 [label="FullWidth 162529"];
2733 [label="return 'ulong'; 162530"];
2734 [label="FullWidth = this.Text.Length; 162531"];
2735 [label="FullWidth 162532"];
2736 [label="this.AdjustFlagsAndWidth(leading); 162533"];
2737 [label="return 'ulong'; 162534"];
2738 [label="FullWidth = this.Text.Length; 162535"];
2739 [label="FullWidth 162536"];
2740 [label="this.AdjustFlagsAndWidth(trailing); 162537"];
2741 [label="return 'ulong'; 162538"];
2742 [label="FullWidth = this.Text.Length; 162539"];
2743 [label="FullWidth 162540"];
2744 [label="this.AdjustFlagsAndWidth(trailing); 162541"];
2745 [label="return 'double'; 162542"];
2746 [label="FullWidth = this.Text.Length; 162543"];
2747 [label="FullWidth 162544"];
2748 [label="return 'double'; 162545"];
2749 [label="FullWidth = this.Text.Length; 162546"];
2750 [label="FullWidth 162547"];
2751 [label="this.AdjustFlagsAndWidth(leading); 162548"];
2752 [label="return 'double'; 162549"];
2753 [label="FullWidth = this.Text.Length; 162550"];
2754 [label="FullWidth 162551"];
2755 [label="this.AdjustFlagsAndWidth(trailing); 162552"];
2756 [label="return 'double'; 162553"];
2757 [label="FullWidth = this.Text.Length; 162554"];
2758 [label="FullWidth 162555"];
2759 [label="this.AdjustFlagsAndWidth(trailing); 162556"];
2760 [label="return 'float'; 162557"];
2761 [label="FullWidth = this.Text.Length; 162558"];
2762 [label="FullWidth 162559"];
2763 [label="return 'float'; 162560"];
2764 [label="FullWidth = this.Text.Length; 162561"];
2765 [label="FullWidth 162562"];
2766 [label="this.AdjustFlagsAndWidth(leading); 162563"];
2767 [label="return 'float'; 162564"];
2768 [label="FullWidth = this.Text.Length; 162565"];
2769 [label="FullWidth 162566"];
2770 [label="this.AdjustFlagsAndWidth(trailing); 162567"];
2771 [label="return 'float'; 162568"];
2772 [label="FullWidth = this.Text.Length; 162569"];
2773 [label="FullWidth 162570"];
2774 [label="this.AdjustFlagsAndWidth(trailing); 162571"];
2775 [label="return 'decimal'; 162572"];
2776 [label="FullWidth = this.Text.Length; 162573"];
2777 [label="FullWidth 162574"];
2778 [label="return 'decimal'; 162575"];
2779 [label="FullWidth = this.Text.Length; 162576"];
2780 [label="FullWidth 162577"];
2781 [label="this.AdjustFlagsAndWidth(leading); 162578"];
2782 [label="return 'decimal'; 162579"];
2783 [label="FullWidth = this.Text.Length; 162580"];
2784 [label="FullWidth 162581"];
2785 [label="this.AdjustFlagsAndWidth(trailing); 162582"];
2786 [label="return 'decimal'; 162583"];
2787 [label="FullWidth = this.Text.Length; 162584"];
2788 [label="FullWidth 162585"];
2789 [label="this.AdjustFlagsAndWidth(trailing); 162586"];
2790 [label="return 'string'; 162587"];
2791 [label="FullWidth = this.Text.Length; 162588"];
2792 [label="FullWidth 162589"];
2793 [label="return 'string'; 162590"];
2794 [label="FullWidth = this.Text.Length; 162591"];
2795 [label="FullWidth 162592"];
2796 [label="this.AdjustFlagsAndWidth(leading); 162593"];
2797 [label="return 'string'; 162594"];
2798 [label="FullWidth = this.Text.Length; 162595"];
2799 [label="FullWidth 162596"];
2800 [label="this.AdjustFlagsAndWidth(trailing); 162597"];
2801 [label="return 'string'; 162598"];
2802 [label="FullWidth = this.Text.Length; 162599"];
2803 [label="FullWidth 162600"];
2804 [label="this.AdjustFlagsAndWidth(trailing); 162601"];
2805 [label="return 'char'; 162602"];
2806 [label="FullWidth = this.Text.Length; 162603"];
2807 [label="FullWidth 162604"];
2808 [label="return 'char'; 162605"];
2809 [label="FullWidth = this.Text.Length; 162606"];
2810 [label="FullWidth 162607"];
2811 [label="this.AdjustFlagsAndWidth(leading); 162608"];
2812 [label="return 'char'; 162609"];
2813 [label="FullWidth = this.Text.Length; 162610"];
2814 [label="FullWidth 162611"];
2815 [label="this.AdjustFlagsAndWidth(trailing); 162612"];
2816 [label="return 'char'; 162613"];
2817 [label="FullWidth = this.Text.Length; 162614"];
2818 [label="FullWidth 162615"];
2819 [label="this.AdjustFlagsAndWidth(trailing); 162616"];
2820 [label="return 'void'; 162617"];
2821 [label="FullWidth = this.Text.Length; 162618"];
2822 [label="FullWidth 162619"];
2823 [label="return 'void'; 162620"];
2824 [label="FullWidth = this.Text.Length; 162621"];
2825 [label="FullWidth 162622"];
2826 [label="this.AdjustFlagsAndWidth(leading); 162623"];
2827 [label="return 'void'; 162624"];
2828 [label="FullWidth = this.Text.Length; 162625"];
2829 [label="FullWidth 162626"];
2830 [label="this.AdjustFlagsAndWidth(trailing); 162627"];
2831 [label="return 'void'; 162628"];
2832 [label="FullWidth = this.Text.Length; 162629"];
2833 [label="FullWidth 162630"];
2834 [label="this.AdjustFlagsAndWidth(trailing); 162631"];
2835 [label="return 'object'; 162632"];
2836 [label="FullWidth = this.Text.Length; 162633"];
2837 [label="FullWidth 162634"];
2838 [label="return 'object'; 162635"];
2839 [label="FullWidth = this.Text.Length; 162636"];
2840 [label="FullWidth 162637"];
2841 [label="this.AdjustFlagsAndWidth(leading); 162638"];
2842 [label="return 'object'; 162639"];
2843 [label="FullWidth = this.Text.Length; 162640"];
2844 [label="FullWidth 162641"];
2845 [label="this.AdjustFlagsAndWidth(trailing); 162642"];
2846 [label="return 'object'; 162643"];
2847 [label="FullWidth = this.Text.Length; 162644"];
2848 [label="FullWidth 162645"];
2849 [label="this.AdjustFlagsAndWidth(trailing); 162646"];
2850 [label="return 'typeof'; 162647"];
2851 [label="FullWidth = this.Text.Length; 162648"];
2852 [label="FullWidth 162649"];
2853 [label="return 'typeof'; 162650"];
2854 [label="FullWidth = this.Text.Length; 162651"];
2855 [label="FullWidth 162652"];
2856 [label="this.AdjustFlagsAndWidth(leading); 162653"];
2857 [label="return 'typeof'; 162654"];
2858 [label="FullWidth = this.Text.Length; 162655"];
2859 [label="FullWidth 162656"];
2860 [label="this.AdjustFlagsAndWidth(trailing); 162657"];
2861 [label="return 'typeof'; 162658"];
2862 [label="FullWidth = this.Text.Length; 162659"];
2863 [label="FullWidth 162660"];
2864 [label="this.AdjustFlagsAndWidth(trailing); 162661"];
2865 [label="return 'sizeof'; 162662"];
2866 [label="FullWidth = this.Text.Length; 162663"];
2867 [label="FullWidth 162664"];
2868 [label="return 'sizeof'; 162665"];
2869 [label="FullWidth = this.Text.Length; 162666"];
2870 [label="FullWidth 162667"];
2871 [label="this.AdjustFlagsAndWidth(leading); 162668"];
2872 [label="return 'sizeof'; 162669"];
2873 [label="FullWidth = this.Text.Length; 162670"];
2874 [label="FullWidth 162671"];
2875 [label="this.AdjustFlagsAndWidth(trailing); 162672"];
2876 [label="return 'sizeof'; 162673"];
2877 [label="FullWidth = this.Text.Length; 162674"];
2878 [label="FullWidth 162675"];
2879 [label="this.AdjustFlagsAndWidth(trailing); 162676"];
2880 [label="return 'null'; 162677"];
2881 [label="FullWidth = this.Text.Length; 162678"];
2882 [label="FullWidth 162679"];
2883 [label="return 'null'; 162680"];
2884 [label="FullWidth = this.Text.Length; 162681"];
2885 [label="FullWidth 162682"];
2886 [label="this.AdjustFlagsAndWidth(leading); 162683"];
2887 [label="return 'null'; 162684"];
2888 [label="FullWidth = this.Text.Length; 162685"];
2889 [label="FullWidth 162686"];
2890 [label="this.AdjustFlagsAndWidth(trailing); 162687"];
2891 [label="return 'null'; 162688"];
2892 [label="FullWidth = this.Text.Length; 162689"];
2893 [label="FullWidth 162690"];
2894 [label="this.AdjustFlagsAndWidth(trailing); 162691"];
2895 [label="return 'true'; 162692"];
2896 [label="FullWidth = this.Text.Length; 162693"];
2897 [label="FullWidth 162694"];
2898 [label="return 'true'; 162695"];
2899 [label="FullWidth = this.Text.Length; 162696"];
2900 [label="FullWidth 162697"];
2901 [label="this.AdjustFlagsAndWidth(leading); 162698"];
2902 [label="return 'true'; 162699"];
2903 [label="FullWidth = this.Text.Length; 162700"];
2904 [label="FullWidth 162701"];
2905 [label="this.AdjustFlagsAndWidth(trailing); 162702"];
2906 [label="return 'true'; 162703"];
2907 [label="FullWidth = this.Text.Length; 162704"];
2908 [label="FullWidth 162705"];
2909 [label="this.AdjustFlagsAndWidth(trailing); 162706"];
2910 [label="return 'false'; 162707"];
2911 [label="FullWidth = this.Text.Length; 162708"];
2912 [label="FullWidth 162709"];
2913 [label="return 'false'; 162710"];
2914 [label="FullWidth = this.Text.Length; 162711"];
2915 [label="FullWidth 162712"];
2916 [label="this.AdjustFlagsAndWidth(leading); 162713"];
2917 [label="return 'false'; 162714"];
2918 [label="FullWidth = this.Text.Length; 162715"];
2919 [label="FullWidth 162716"];
2920 [label="this.AdjustFlagsAndWidth(trailing); 162717"];
2921 [label="return 'false'; 162718"];
2922 [label="FullWidth = this.Text.Length; 162719"];
2923 [label="FullWidth 162720"];
2924 [label="this.AdjustFlagsAndWidth(trailing); 162721"];
2925 [label="return 'if'; 162722"];
2926 [label="FullWidth = this.Text.Length; 162723"];
2927 [label="FullWidth 162724"];
2928 [label="return 'if'; 162725"];
2929 [label="FullWidth = this.Text.Length; 162726"];
2930 [label="FullWidth 162727"];
2931 [label="this.AdjustFlagsAndWidth(leading); 162728"];
2932 [label="return 'if'; 162729"];
2933 [label="FullWidth = this.Text.Length; 162730"];
2934 [label="FullWidth 162731"];
2935 [label="this.AdjustFlagsAndWidth(trailing); 162732"];
2936 [label="return 'if'; 162733"];
2937 [label="FullWidth = this.Text.Length; 162734"];
2938 [label="FullWidth 162735"];
2939 [label="this.AdjustFlagsAndWidth(trailing); 162736"];
2940 [label="return 'else'; 162737"];
2941 [label="FullWidth = this.Text.Length; 162738"];
2942 [label="FullWidth 162739"];
2943 [label="return 'else'; 162740"];
2944 [label="FullWidth = this.Text.Length; 162741"];
2945 [label="FullWidth 162742"];
2946 [label="this.AdjustFlagsAndWidth(leading); 162743"];
2947 [label="return 'else'; 162744"];
2948 [label="FullWidth = this.Text.Length; 162745"];
2949 [label="FullWidth 162746"];
2950 [label="this.AdjustFlagsAndWidth(trailing); 162747"];
2951 [label="return 'else'; 162748"];
2952 [label="FullWidth = this.Text.Length; 162749"];
2953 [label="FullWidth 162750"];
2954 [label="this.AdjustFlagsAndWidth(trailing); 162751"];
2955 [label="return 'while'; 162752"];
2956 [label="FullWidth = this.Text.Length; 162753"];
2957 [label="FullWidth 162754"];
2958 [label="return 'while'; 162755"];
2959 [label="FullWidth = this.Text.Length; 162756"];
2960 [label="FullWidth 162757"];
2961 [label="this.AdjustFlagsAndWidth(leading); 162758"];
2962 [label="return 'while'; 162759"];
2963 [label="FullWidth = this.Text.Length; 162760"];
2964 [label="FullWidth 162761"];
2965 [label="this.AdjustFlagsAndWidth(trailing); 162762"];
2966 [label="return 'while'; 162763"];
2967 [label="FullWidth = this.Text.Length; 162764"];
2968 [label="FullWidth 162765"];
2969 [label="this.AdjustFlagsAndWidth(trailing); 162766"];
2970 [label="return 'for'; 162767"];
2971 [label="FullWidth = this.Text.Length; 162768"];
2972 [label="FullWidth 162769"];
2973 [label="return 'for'; 162770"];
2974 [label="FullWidth = this.Text.Length; 162771"];
2975 [label="FullWidth 162772"];
2976 [label="this.AdjustFlagsAndWidth(leading); 162773"];
2977 [label="return 'for'; 162774"];
2978 [label="FullWidth = this.Text.Length; 162775"];
2979 [label="FullWidth 162776"];
2980 [label="this.AdjustFlagsAndWidth(trailing); 162777"];
2981 [label="return 'for'; 162778"];
2982 [label="FullWidth = this.Text.Length; 162779"];
2983 [label="FullWidth 162780"];
2984 [label="this.AdjustFlagsAndWidth(trailing); 162781"];
2985 [label="return 'foreach'; 162782"];
2986 [label="FullWidth = this.Text.Length; 162783"];
2987 [label="FullWidth 162784"];
2988 [label="return 'foreach'; 162785"];
2989 [label="FullWidth = this.Text.Length; 162786"];
2990 [label="FullWidth 162787"];
2991 [label="this.AdjustFlagsAndWidth(leading); 162788"];
2992 [label="return 'foreach'; 162789"];
2993 [label="FullWidth = this.Text.Length; 162790"];
2994 [label="FullWidth 162791"];
2995 [label="this.AdjustFlagsAndWidth(trailing); 162792"];
2996 [label="return 'foreach'; 162793"];
2997 [label="FullWidth = this.Text.Length; 162794"];
2998 [label="FullWidth 162795"];
2999 [label="this.AdjustFlagsAndWidth(trailing); 162796"];
3000 [label="return 'do'; 162797"];
3001 [label="FullWidth = this.Text.Length; 162798"];
3002 [label="FullWidth 162799"];
3003 [label="return 'do'; 162800"];
3004 [label="FullWidth = this.Text.Length; 162801"];
3005 [label="FullWidth 162802"];
3006 [label="this.AdjustFlagsAndWidth(leading); 162803"];
3007 [label="return 'do'; 162804"];
3008 [label="FullWidth = this.Text.Length; 162805"];
3009 [label="FullWidth 162806"];
3010 [label="this.AdjustFlagsAndWidth(trailing); 162807"];
3011 [label="return 'do'; 162808"];
3012 [label="FullWidth = this.Text.Length; 162809"];
3013 [label="FullWidth 162810"];
3014 [label="this.AdjustFlagsAndWidth(trailing); 162811"];
3015 [label="return 'switch'; 162812"];
3016 [label="FullWidth = this.Text.Length; 162813"];
3017 [label="FullWidth 162814"];
3018 [label="return 'switch'; 162815"];
3019 [label="FullWidth = this.Text.Length; 162816"];
3020 [label="FullWidth 162817"];
3021 [label="this.AdjustFlagsAndWidth(leading); 162818"];
3022 [label="return 'switch'; 162819"];
3023 [label="FullWidth = this.Text.Length; 162820"];
3024 [label="FullWidth 162821"];
3025 [label="this.AdjustFlagsAndWidth(trailing); 162822"];
3026 [label="return 'switch'; 162823"];
3027 [label="FullWidth = this.Text.Length; 162824"];
3028 [label="FullWidth 162825"];
3029 [label="this.AdjustFlagsAndWidth(trailing); 162826"];
3030 [label="return 'case'; 162827"];
3031 [label="FullWidth = this.Text.Length; 162828"];
3032 [label="FullWidth 162829"];
3033 [label="return 'case'; 162830"];
3034 [label="FullWidth = this.Text.Length; 162831"];
3035 [label="FullWidth 162832"];
3036 [label="this.AdjustFlagsAndWidth(leading); 162833"];
3037 [label="return 'case'; 162834"];
3038 [label="FullWidth = this.Text.Length; 162835"];
3039 [label="FullWidth 162836"];
3040 [label="this.AdjustFlagsAndWidth(trailing); 162837"];
3041 [label="return 'case'; 162838"];
3042 [label="FullWidth = this.Text.Length; 162839"];
3043 [label="FullWidth 162840"];
3044 [label="this.AdjustFlagsAndWidth(trailing); 162841"];
3045 [label="return 'default'; 162842"];
3046 [label="FullWidth = this.Text.Length; 162843"];
3047 [label="FullWidth 162844"];
3048 [label="return 'default'; 162845"];
3049 [label="FullWidth = this.Text.Length; 162846"];
3050 [label="FullWidth 162847"];
3051 [label="this.AdjustFlagsAndWidth(leading); 162848"];
3052 [label="return 'default'; 162849"];
3053 [label="FullWidth = this.Text.Length; 162850"];
3054 [label="FullWidth 162851"];
3055 [label="this.AdjustFlagsAndWidth(trailing); 162852"];
3056 [label="return 'default'; 162853"];
3057 [label="FullWidth = this.Text.Length; 162854"];
3058 [label="FullWidth 162855"];
3059 [label="this.AdjustFlagsAndWidth(trailing); 162856"];
3060 [label="return 'try'; 162857"];
3061 [label="FullWidth = this.Text.Length; 162858"];
3062 [label="FullWidth 162859"];
3063 [label="return 'try'; 162860"];
3064 [label="FullWidth = this.Text.Length; 162861"];
3065 [label="FullWidth 162862"];
3066 [label="this.AdjustFlagsAndWidth(leading); 162863"];
3067 [label="return 'try'; 162864"];
3068 [label="FullWidth = this.Text.Length; 162865"];
3069 [label="FullWidth 162866"];
3070 [label="this.AdjustFlagsAndWidth(trailing); 162867"];
3071 [label="return 'try'; 162868"];
3072 [label="FullWidth = this.Text.Length; 162869"];
3073 [label="FullWidth 162870"];
3074 [label="this.AdjustFlagsAndWidth(trailing); 162871"];
3075 [label="return 'catch'; 162872"];
3076 [label="FullWidth = this.Text.Length; 162873"];
3077 [label="FullWidth 162874"];
3078 [label="return 'catch'; 162875"];
3079 [label="FullWidth = this.Text.Length; 162876"];
3080 [label="FullWidth 162877"];
3081 [label="this.AdjustFlagsAndWidth(leading); 162878"];
3082 [label="return 'catch'; 162879"];
3083 [label="FullWidth = this.Text.Length; 162880"];
3084 [label="FullWidth 162881"];
3085 [label="this.AdjustFlagsAndWidth(trailing); 162882"];
3086 [label="return 'catch'; 162883"];
3087 [label="FullWidth = this.Text.Length; 162884"];
3088 [label="FullWidth 162885"];
3089 [label="this.AdjustFlagsAndWidth(trailing); 162886"];
3090 [label="return 'finally'; 162887"];
3091 [label="FullWidth = this.Text.Length; 162888"];
3092 [label="FullWidth 162889"];
3093 [label="return 'finally'; 162890"];
3094 [label="FullWidth = this.Text.Length; 162891"];
3095 [label="FullWidth 162892"];
3096 [label="this.AdjustFlagsAndWidth(leading); 162893"];
3097 [label="return 'finally'; 162894"];
3098 [label="FullWidth = this.Text.Length; 162895"];
3099 [label="FullWidth 162896"];
3100 [label="this.AdjustFlagsAndWidth(trailing); 162897"];
3101 [label="return 'finally'; 162898"];
3102 [label="FullWidth = this.Text.Length; 162899"];
3103 [label="FullWidth 162900"];
3104 [label="this.AdjustFlagsAndWidth(trailing); 162901"];
3105 [label="return 'lock'; 162902"];
3106 [label="FullWidth = this.Text.Length; 162903"];
3107 [label="FullWidth 162904"];
3108 [label="return 'lock'; 162905"];
3109 [label="FullWidth = this.Text.Length; 162906"];
3110 [label="FullWidth 162907"];
3111 [label="this.AdjustFlagsAndWidth(leading); 162908"];
3112 [label="return 'lock'; 162909"];
3113 [label="FullWidth = this.Text.Length; 162910"];
3114 [label="FullWidth 162911"];
3115 [label="this.AdjustFlagsAndWidth(trailing); 162912"];
3116 [label="return 'lock'; 162913"];
3117 [label="FullWidth = this.Text.Length; 162914"];
3118 [label="FullWidth 162915"];
3119 [label="this.AdjustFlagsAndWidth(trailing); 162916"];
3120 [label="return 'goto'; 162917"];
3121 [label="FullWidth = this.Text.Length; 162918"];
3122 [label="FullWidth 162919"];
3123 [label="return 'goto'; 162920"];
3124 [label="FullWidth = this.Text.Length; 162921"];
3125 [label="FullWidth 162922"];
3126 [label="this.AdjustFlagsAndWidth(leading); 162923"];
3127 [label="return 'goto'; 162924"];
3128 [label="FullWidth = this.Text.Length; 162925"];
3129 [label="FullWidth 162926"];
3130 [label="this.AdjustFlagsAndWidth(trailing); 162927"];
3131 [label="return 'goto'; 162928"];
3132 [label="FullWidth = this.Text.Length; 162929"];
3133 [label="FullWidth 162930"];
3134 [label="this.AdjustFlagsAndWidth(trailing); 162931"];
3135 [label="return 'break'; 162932"];
3136 [label="FullWidth = this.Text.Length; 162933"];
3137 [label="FullWidth 162934"];
3138 [label="return 'break'; 162935"];
3139 [label="FullWidth = this.Text.Length; 162936"];
3140 [label="FullWidth 162937"];
3141 [label="this.AdjustFlagsAndWidth(leading); 162938"];
3142 [label="return 'break'; 162939"];
3143 [label="FullWidth = this.Text.Length; 162940"];
3144 [label="FullWidth 162941"];
3145 [label="this.AdjustFlagsAndWidth(trailing); 162942"];
3146 [label="return 'break'; 162943"];
3147 [label="FullWidth = this.Text.Length; 162944"];
3148 [label="FullWidth 162945"];
3149 [label="this.AdjustFlagsAndWidth(trailing); 162946"];
3150 [label="return 'continue'; 162947"];
3151 [label="FullWidth = this.Text.Length; 162948"];
3152 [label="FullWidth 162949"];
3153 [label="return 'continue'; 162950"];
3154 [label="FullWidth = this.Text.Length; 162951"];
3155 [label="FullWidth 162952"];
3156 [label="this.AdjustFlagsAndWidth(leading); 162953"];
3157 [label="return 'continue'; 162954"];
3158 [label="FullWidth = this.Text.Length; 162955"];
3159 [label="FullWidth 162956"];
3160 [label="this.AdjustFlagsAndWidth(trailing); 162957"];
3161 [label="return 'continue'; 162958"];
3162 [label="FullWidth = this.Text.Length; 162959"];
3163 [label="FullWidth 162960"];
3164 [label="this.AdjustFlagsAndWidth(trailing); 162961"];
3165 [label="return 'return'; 162962"];
3166 [label="FullWidth = this.Text.Length; 162963"];
3167 [label="FullWidth 162964"];
3168 [label="return 'return'; 162965"];
3169 [label="FullWidth = this.Text.Length; 162966"];
3170 [label="FullWidth 162967"];
3171 [label="this.AdjustFlagsAndWidth(leading); 162968"];
3172 [label="return 'return'; 162969"];
3173 [label="FullWidth = this.Text.Length; 162970"];
3174 [label="FullWidth 162971"];
3175 [label="this.AdjustFlagsAndWidth(trailing); 162972"];
3176 [label="return 'return'; 162973"];
3177 [label="FullWidth = this.Text.Length; 162974"];
3178 [label="FullWidth 162975"];
3179 [label="this.AdjustFlagsAndWidth(trailing); 162976"];
3180 [label="return 'throw'; 162977"];
3181 [label="FullWidth = this.Text.Length; 162978"];
3182 [label="FullWidth 162979"];
3183 [label="return 'throw'; 162980"];
3184 [label="FullWidth = this.Text.Length; 162981"];
3185 [label="FullWidth 162982"];
3186 [label="this.AdjustFlagsAndWidth(leading); 162983"];
3187 [label="return 'throw'; 162984"];
3188 [label="FullWidth = this.Text.Length; 162985"];
3189 [label="FullWidth 162986"];
3190 [label="this.AdjustFlagsAndWidth(trailing); 162987"];
3191 [label="return 'throw'; 162988"];
3192 [label="FullWidth = this.Text.Length; 162989"];
3193 [label="FullWidth 162990"];
3194 [label="this.AdjustFlagsAndWidth(trailing); 162991"];
3195 [label="return 'public'; 162992"];
3196 [label="FullWidth = this.Text.Length; 162993"];
3197 [label="FullWidth 162994"];
3198 [label="return 'public'; 162995"];
3199 [label="FullWidth = this.Text.Length; 162996"];
3200 [label="FullWidth 162997"];
3201 [label="this.AdjustFlagsAndWidth(leading); 162998"];
3202 [label="return 'public'; 162999"];
3203 [label="FullWidth = this.Text.Length; 163000"];
3204 [label="FullWidth 163001"];
3205 [label="this.AdjustFlagsAndWidth(trailing); 163002"];
3206 [label="return 'public'; 163003"];
3207 [label="FullWidth = this.Text.Length; 163004"];
3208 [label="FullWidth 163005"];
3209 [label="this.AdjustFlagsAndWidth(trailing); 163006"];
3210 [label="return 'private'; 163007"];
3211 [label="FullWidth = this.Text.Length; 163008"];
3212 [label="FullWidth 163009"];
3213 [label="return 'private'; 163010"];
3214 [label="FullWidth = this.Text.Length; 163011"];
3215 [label="FullWidth 163012"];
3216 [label="this.AdjustFlagsAndWidth(leading); 163013"];
3217 [label="return 'private'; 163014"];
3218 [label="FullWidth = this.Text.Length; 163015"];
3219 [label="FullWidth 163016"];
3220 [label="this.AdjustFlagsAndWidth(trailing); 163017"];
3221 [label="return 'private'; 163018"];
3222 [label="FullWidth = this.Text.Length; 163019"];
3223 [label="FullWidth 163020"];
3224 [label="this.AdjustFlagsAndWidth(trailing); 163021"];
3225 [label="return 'internal'; 163022"];
3226 [label="FullWidth = this.Text.Length; 163023"];
3227 [label="FullWidth 163024"];
3228 [label="return 'internal'; 163025"];
3229 [label="FullWidth = this.Text.Length; 163026"];
3230 [label="FullWidth 163027"];
3231 [label="this.AdjustFlagsAndWidth(leading); 163028"];
3232 [label="return 'internal'; 163029"];
3233 [label="FullWidth = this.Text.Length; 163030"];
3234 [label="FullWidth 163031"];
3235 [label="this.AdjustFlagsAndWidth(trailing); 163032"];
3236 [label="return 'internal'; 163033"];
3237 [label="FullWidth = this.Text.Length; 163034"];
3238 [label="FullWidth 163035"];
3239 [label="this.AdjustFlagsAndWidth(trailing); 163036"];
3240 [label="return 'protected'; 163037"];
3241 [label="FullWidth = this.Text.Length; 163038"];
3242 [label="FullWidth 163039"];
3243 [label="return 'protected'; 163040"];
3244 [label="FullWidth = this.Text.Length; 163041"];
3245 [label="FullWidth 163042"];
3246 [label="this.AdjustFlagsAndWidth(leading); 163043"];
3247 [label="return 'protected'; 163044"];
3248 [label="FullWidth = this.Text.Length; 163045"];
3249 [label="FullWidth 163046"];
3250 [label="this.AdjustFlagsAndWidth(trailing); 163047"];
3251 [label="return 'protected'; 163048"];
3252 [label="FullWidth = this.Text.Length; 163049"];
3253 [label="FullWidth 163050"];
3254 [label="this.AdjustFlagsAndWidth(trailing); 163051"];
3255 [label="return 'static'; 163052"];
3256 [label="FullWidth = this.Text.Length; 163053"];
3257 [label="FullWidth 163054"];
3258 [label="return 'static'; 163055"];
3259 [label="FullWidth = this.Text.Length; 163056"];
3260 [label="FullWidth 163057"];
3261 [label="this.AdjustFlagsAndWidth(leading); 163058"];
3262 [label="return 'static'; 163059"];
3263 [label="FullWidth = this.Text.Length; 163060"];
3264 [label="FullWidth 163061"];
3265 [label="this.AdjustFlagsAndWidth(trailing); 163062"];
3266 [label="return 'static'; 163063"];
3267 [label="FullWidth = this.Text.Length; 163064"];
3268 [label="FullWidth 163065"];
3269 [label="this.AdjustFlagsAndWidth(trailing); 163066"];
3270 [label="return 'readonly'; 163067"];
3271 [label="FullWidth = this.Text.Length; 163068"];
3272 [label="FullWidth 163069"];
3273 [label="return 'readonly'; 163070"];
3274 [label="FullWidth = this.Text.Length; 163071"];
3275 [label="FullWidth 163072"];
3276 [label="this.AdjustFlagsAndWidth(leading); 163073"];
3277 [label="return 'readonly'; 163074"];
3278 [label="FullWidth = this.Text.Length; 163075"];
3279 [label="FullWidth 163076"];
3280 [label="this.AdjustFlagsAndWidth(trailing); 163077"];
3281 [label="return 'readonly'; 163078"];
3282 [label="FullWidth = this.Text.Length; 163079"];
3283 [label="FullWidth 163080"];
3284 [label="this.AdjustFlagsAndWidth(trailing); 163081"];
3285 [label="return 'sealed'; 163082"];
3286 [label="FullWidth = this.Text.Length; 163083"];
3287 [label="FullWidth 163084"];
3288 [label="return 'sealed'; 163085"];
3289 [label="FullWidth = this.Text.Length; 163086"];
3290 [label="FullWidth 163087"];
3291 [label="this.AdjustFlagsAndWidth(leading); 163088"];
3292 [label="return 'sealed'; 163089"];
3293 [label="FullWidth = this.Text.Length; 163090"];
3294 [label="FullWidth 163091"];
3295 [label="this.AdjustFlagsAndWidth(trailing); 163092"];
3296 [label="return 'sealed'; 163093"];
3297 [label="FullWidth = this.Text.Length; 163094"];
3298 [label="FullWidth 163095"];
3299 [label="this.AdjustFlagsAndWidth(trailing); 163096"];
3300 [label="return 'const'; 163097"];
3301 [label="FullWidth = this.Text.Length; 163098"];
3302 [label="FullWidth 163099"];
3303 [label="return 'const'; 163100"];
3304 [label="FullWidth = this.Text.Length; 163101"];
3305 [label="FullWidth 163102"];
3306 [label="this.AdjustFlagsAndWidth(leading); 163103"];
3307 [label="return 'const'; 163104"];
3308 [label="FullWidth = this.Text.Length; 163105"];
3309 [label="FullWidth 163106"];
3310 [label="this.AdjustFlagsAndWidth(trailing); 163107"];
3311 [label="return 'const'; 163108"];
3312 [label="FullWidth = this.Text.Length; 163109"];
3313 [label="FullWidth 163110"];
3314 [label="this.AdjustFlagsAndWidth(trailing); 163111"];
3315 [label="return 'fixed'; 163112"];
3316 [label="FullWidth = this.Text.Length; 163113"];
3317 [label="FullWidth 163114"];
3318 [label="return 'fixed'; 163115"];
3319 [label="FullWidth = this.Text.Length; 163116"];
3320 [label="FullWidth 163117"];
3321 [label="this.AdjustFlagsAndWidth(leading); 163118"];
3322 [label="return 'fixed'; 163119"];
3323 [label="FullWidth = this.Text.Length; 163120"];
3324 [label="FullWidth 163121"];
3325 [label="this.AdjustFlagsAndWidth(trailing); 163122"];
3326 [label="return 'fixed'; 163123"];
3327 [label="FullWidth = this.Text.Length; 163124"];
3328 [label="FullWidth 163125"];
3329 [label="this.AdjustFlagsAndWidth(trailing); 163126"];
3330 [label="return 'stackalloc'; 163127"];
3331 [label="FullWidth = this.Text.Length; 163128"];
3332 [label="FullWidth 163129"];
3333 [label="return 'stackalloc'; 163130"];
3334 [label="FullWidth = this.Text.Length; 163131"];
3335 [label="FullWidth 163132"];
3336 [label="this.AdjustFlagsAndWidth(leading); 163133"];
3337 [label="return 'stackalloc'; 163134"];
3338 [label="FullWidth = this.Text.Length; 163135"];
3339 [label="FullWidth 163136"];
3340 [label="this.AdjustFlagsAndWidth(trailing); 163137"];
3341 [label="return 'stackalloc'; 163138"];
3342 [label="FullWidth = this.Text.Length; 163139"];
3343 [label="FullWidth 163140"];
3344 [label="this.AdjustFlagsAndWidth(trailing); 163141"];
3345 [label="return 'volatile'; 163142"];
3346 [label="FullWidth = this.Text.Length; 163143"];
3347 [label="FullWidth 163144"];
3348 [label="return 'volatile'; 163145"];
3349 [label="FullWidth = this.Text.Length; 163146"];
3350 [label="FullWidth 163147"];
3351 [label="this.AdjustFlagsAndWidth(leading); 163148"];
3352 [label="return 'volatile'; 163149"];
3353 [label="FullWidth = this.Text.Length; 163150"];
3354 [label="FullWidth 163151"];
3355 [label="this.AdjustFlagsAndWidth(trailing); 163152"];
3356 [label="return 'volatile'; 163153"];
3357 [label="FullWidth = this.Text.Length; 163154"];
3358 [label="FullWidth 163155"];
3359 [label="this.AdjustFlagsAndWidth(trailing); 163156"];
3360 [label="return 'new'; 163157"];
3361 [label="FullWidth = this.Text.Length; 163158"];
3362 [label="FullWidth 163159"];
3363 [label="return 'new'; 163160"];
3364 [label="FullWidth = this.Text.Length; 163161"];
3365 [label="FullWidth 163162"];
3366 [label="this.AdjustFlagsAndWidth(leading); 163163"];
3367 [label="return 'new'; 163164"];
3368 [label="FullWidth = this.Text.Length; 163165"];
3369 [label="FullWidth 163166"];
3370 [label="this.AdjustFlagsAndWidth(trailing); 163167"];
3371 [label="return 'new'; 163168"];
3372 [label="FullWidth = this.Text.Length; 163169"];
3373 [label="FullWidth 163170"];
3374 [label="this.AdjustFlagsAndWidth(trailing); 163171"];
3375 [label="return 'override'; 163172"];
3376 [label="FullWidth = this.Text.Length; 163173"];
3377 [label="FullWidth 163174"];
3378 [label="return 'override'; 163175"];
3379 [label="FullWidth = this.Text.Length; 163176"];
3380 [label="FullWidth 163177"];
3381 [label="this.AdjustFlagsAndWidth(leading); 163178"];
3382 [label="return 'override'; 163179"];
3383 [label="FullWidth = this.Text.Length; 163180"];
3384 [label="FullWidth 163181"];
3385 [label="this.AdjustFlagsAndWidth(trailing); 163182"];
3386 [label="return 'override'; 163183"];
3387 [label="FullWidth = this.Text.Length; 163184"];
3388 [label="FullWidth 163185"];
3389 [label="this.AdjustFlagsAndWidth(trailing); 163186"];
3390 [label="return 'abstract'; 163187"];
3391 [label="FullWidth = this.Text.Length; 163188"];
3392 [label="FullWidth 163189"];
3393 [label="return 'abstract'; 163190"];
3394 [label="FullWidth = this.Text.Length; 163191"];
3395 [label="FullWidth 163192"];
3396 [label="this.AdjustFlagsAndWidth(leading); 163193"];
3397 [label="return 'abstract'; 163194"];
3398 [label="FullWidth = this.Text.Length; 163195"];
3399 [label="FullWidth 163196"];
3400 [label="this.AdjustFlagsAndWidth(trailing); 163197"];
3401 [label="return 'abstract'; 163198"];
3402 [label="FullWidth = this.Text.Length; 163199"];
3403 [label="FullWidth 163200"];
3404 [label="this.AdjustFlagsAndWidth(trailing); 163201"];
3405 [label="return 'virtual'; 163202"];
3406 [label="FullWidth = this.Text.Length; 163203"];
3407 [label="FullWidth 163204"];
3408 [label="return 'virtual'; 163205"];
3409 [label="FullWidth = this.Text.Length; 163206"];
3410 [label="FullWidth 163207"];
3411 [label="this.AdjustFlagsAndWidth(leading); 163208"];
3412 [label="return 'virtual'; 163209"];
3413 [label="FullWidth = this.Text.Length; 163210"];
3414 [label="FullWidth 163211"];
3415 [label="this.AdjustFlagsAndWidth(trailing); 163212"];
3416 [label="return 'virtual'; 163213"];
3417 [label="FullWidth = this.Text.Length; 163214"];
3418 [label="FullWidth 163215"];
3419 [label="this.AdjustFlagsAndWidth(trailing); 163216"];
3420 [label="return 'event'; 163217"];
3421 [label="FullWidth = this.Text.Length; 163218"];
3422 [label="FullWidth 163219"];
3423 [label="return 'event'; 163220"];
3424 [label="FullWidth = this.Text.Length; 163221"];
3425 [label="FullWidth 163222"];
3426 [label="this.AdjustFlagsAndWidth(leading); 163223"];
3427 [label="return 'event'; 163224"];
3428 [label="FullWidth = this.Text.Length; 163225"];
3429 [label="FullWidth 163226"];
3430 [label="this.AdjustFlagsAndWidth(trailing); 163227"];
3431 [label="return 'event'; 163228"];
3432 [label="FullWidth = this.Text.Length; 163229"];
3433 [label="FullWidth 163230"];
3434 [label="this.AdjustFlagsAndWidth(trailing); 163231"];
3435 [label="return 'extern'; 163232"];
3436 [label="FullWidth = this.Text.Length; 163233"];
3437 [label="FullWidth 163234"];
3438 [label="return 'extern'; 163235"];
3439 [label="FullWidth = this.Text.Length; 163236"];
3440 [label="FullWidth 163237"];
3441 [label="this.AdjustFlagsAndWidth(leading); 163238"];
3442 [label="return 'extern'; 163239"];
3443 [label="FullWidth = this.Text.Length; 163240"];
3444 [label="FullWidth 163241"];
3445 [label="this.AdjustFlagsAndWidth(trailing); 163242"];
3446 [label="return 'extern'; 163243"];
3447 [label="FullWidth = this.Text.Length; 163244"];
3448 [label="FullWidth 163245"];
3449 [label="this.AdjustFlagsAndWidth(trailing); 163246"];
3450 [label="return 'ref'; 163247"];
3451 [label="FullWidth = this.Text.Length; 163248"];
3452 [label="FullWidth 163249"];
3453 [label="return 'ref'; 163250"];
3454 [label="FullWidth = this.Text.Length; 163251"];
3455 [label="FullWidth 163252"];
3456 [label="this.AdjustFlagsAndWidth(leading); 163253"];
3457 [label="return 'ref'; 163254"];
3458 [label="FullWidth = this.Text.Length; 163255"];
3459 [label="FullWidth 163256"];
3460 [label="this.AdjustFlagsAndWidth(trailing); 163257"];
3461 [label="return 'ref'; 163258"];
3462 [label="FullWidth = this.Text.Length; 163259"];
3463 [label="FullWidth 163260"];
3464 [label="this.AdjustFlagsAndWidth(trailing); 163261"];
3465 [label="return 'out'; 163262"];
3466 [label="FullWidth = this.Text.Length; 163263"];
3467 [label="FullWidth 163264"];
3468 [label="return 'out'; 163265"];
3469 [label="FullWidth = this.Text.Length; 163266"];
3470 [label="FullWidth 163267"];
3471 [label="this.AdjustFlagsAndWidth(leading); 163268"];
3472 [label="return 'out'; 163269"];
3473 [label="FullWidth = this.Text.Length; 163270"];
3474 [label="FullWidth 163271"];
3475 [label="this.AdjustFlagsAndWidth(trailing); 163272"];
3476 [label="return 'out'; 163273"];
3477 [label="FullWidth = this.Text.Length; 163274"];
3478 [label="FullWidth 163275"];
3479 [label="this.AdjustFlagsAndWidth(trailing); 163276"];
3480 [label="return 'in'; 163277"];
3481 [label="FullWidth = this.Text.Length; 163278"];
3482 [label="FullWidth 163279"];
3483 [label="return 'in'; 163280"];
3484 [label="FullWidth = this.Text.Length; 163281"];
3485 [label="FullWidth 163282"];
3486 [label="this.AdjustFlagsAndWidth(leading); 163283"];
3487 [label="return 'in'; 163284"];
3488 [label="FullWidth = this.Text.Length; 163285"];
3489 [label="FullWidth 163286"];
3490 [label="this.AdjustFlagsAndWidth(trailing); 163287"];
3491 [label="return 'in'; 163288"];
3492 [label="FullWidth = this.Text.Length; 163289"];
3493 [label="FullWidth 163290"];
3494 [label="this.AdjustFlagsAndWidth(trailing); 163291"];
3495 [label="return 'is'; 163292"];
3496 [label="FullWidth = this.Text.Length; 163293"];
3497 [label="FullWidth 163294"];
3498 [label="return 'is'; 163295"];
3499 [label="FullWidth = this.Text.Length; 163296"];
3500 [label="FullWidth 163297"];
3501 [label="this.AdjustFlagsAndWidth(leading); 163298"];
3502 [label="return 'is'; 163299"];
3503 [label="FullWidth = this.Text.Length; 163300"];
3504 [label="FullWidth 163301"];
3505 [label="this.AdjustFlagsAndWidth(trailing); 163302"];
3506 [label="return 'is'; 163303"];
3507 [label="FullWidth = this.Text.Length; 163304"];
3508 [label="FullWidth 163305"];
3509 [label="this.AdjustFlagsAndWidth(trailing); 163306"];
3510 [label="return 'as'; 163307"];
3511 [label="FullWidth = this.Text.Length; 163308"];
3512 [label="FullWidth 163309"];
3513 [label="return 'as'; 163310"];
3514 [label="FullWidth = this.Text.Length; 163311"];
3515 [label="FullWidth 163312"];
3516 [label="this.AdjustFlagsAndWidth(leading); 163313"];
3517 [label="return 'as'; 163314"];
3518 [label="FullWidth = this.Text.Length; 163315"];
3519 [label="FullWidth 163316"];
3520 [label="this.AdjustFlagsAndWidth(trailing); 163317"];
3521 [label="return 'as'; 163318"];
3522 [label="FullWidth = this.Text.Length; 163319"];
3523 [label="FullWidth 163320"];
3524 [label="this.AdjustFlagsAndWidth(trailing); 163321"];
3525 [label="return 'params'; 163322"];
3526 [label="FullWidth = this.Text.Length; 163323"];
3527 [label="FullWidth 163324"];
3528 [label="return 'params'; 163325"];
3529 [label="FullWidth = this.Text.Length; 163326"];
3530 [label="FullWidth 163327"];
3531 [label="this.AdjustFlagsAndWidth(leading); 163328"];
3532 [label="return 'params'; 163329"];
3533 [label="FullWidth = this.Text.Length; 163330"];
3534 [label="FullWidth 163331"];
3535 [label="this.AdjustFlagsAndWidth(trailing); 163332"];
3536 [label="return 'params'; 163333"];
3537 [label="FullWidth = this.Text.Length; 163334"];
3538 [label="FullWidth 163335"];
3539 [label="this.AdjustFlagsAndWidth(trailing); 163336"];
3540 [label="return '__arglist'; 163337"];
3541 [label="FullWidth = this.Text.Length; 163338"];
3542 [label="FullWidth 163339"];
3543 [label="return '__arglist'; 163340"];
3544 [label="FullWidth = this.Text.Length; 163341"];
3545 [label="FullWidth 163342"];
3546 [label="this.AdjustFlagsAndWidth(leading); 163343"];
3547 [label="return '__arglist'; 163344"];
3548 [label="FullWidth = this.Text.Length; 163345"];
3549 [label="FullWidth 163346"];
3550 [label="this.AdjustFlagsAndWidth(trailing); 163347"];
3551 [label="return '__arglist'; 163348"];
3552 [label="FullWidth = this.Text.Length; 163349"];
3553 [label="FullWidth 163350"];
3554 [label="this.AdjustFlagsAndWidth(trailing); 163351"];
3555 [label="return '__makeref'; 163352"];
3556 [label="FullWidth = this.Text.Length; 163353"];
3557 [label="FullWidth 163354"];
3558 [label="return '__makeref'; 163355"];
3559 [label="FullWidth = this.Text.Length; 163356"];
3560 [label="FullWidth 163357"];
3561 [label="this.AdjustFlagsAndWidth(leading); 163358"];
3562 [label="return '__makeref'; 163359"];
3563 [label="FullWidth = this.Text.Length; 163360"];
3564 [label="FullWidth 163361"];
3565 [label="this.AdjustFlagsAndWidth(trailing); 163362"];
3566 [label="return '__makeref'; 163363"];
3567 [label="FullWidth = this.Text.Length; 163364"];
3568 [label="FullWidth 163365"];
3569 [label="this.AdjustFlagsAndWidth(trailing); 163366"];
3570 [label="return '__reftype'; 163367"];
3571 [label="FullWidth = this.Text.Length; 163368"];
3572 [label="FullWidth 163369"];
3573 [label="return '__reftype'; 163370"];
3574 [label="FullWidth = this.Text.Length; 163371"];
3575 [label="FullWidth 163372"];
3576 [label="this.AdjustFlagsAndWidth(leading); 163373"];
3577 [label="return '__reftype'; 163374"];
3578 [label="FullWidth = this.Text.Length; 163375"];
3579 [label="FullWidth 163376"];
3580 [label="this.AdjustFlagsAndWidth(trailing); 163377"];
3581 [label="return '__reftype'; 163378"];
3582 [label="FullWidth = this.Text.Length; 163379"];
3583 [label="FullWidth 163380"];
3584 [label="this.AdjustFlagsAndWidth(trailing); 163381"];
3585 [label="return '__refvalue'; 163382"];
3586 [label="FullWidth = this.Text.Length; 163383"];
3587 [label="FullWidth 163384"];
3588 [label="return '__refvalue'; 163385"];
3589 [label="FullWidth = this.Text.Length; 163386"];
3590 [label="FullWidth 163387"];
3591 [label="this.AdjustFlagsAndWidth(leading); 163388"];
3592 [label="return '__refvalue'; 163389"];
3593 [label="FullWidth = this.Text.Length; 163390"];
3594 [label="FullWidth 163391"];
3595 [label="this.AdjustFlagsAndWidth(trailing); 163392"];
3596 [label="return '__refvalue'; 163393"];
3597 [label="FullWidth = this.Text.Length; 163394"];
3598 [label="FullWidth 163395"];
3599 [label="this.AdjustFlagsAndWidth(trailing); 163396"];
3600 [label="return 'this'; 163397"];
3601 [label="FullWidth = this.Text.Length; 163398"];
3602 [label="FullWidth 163399"];
3603 [label="return 'this'; 163400"];
3604 [label="FullWidth = this.Text.Length; 163401"];
3605 [label="FullWidth 163402"];
3606 [label="this.AdjustFlagsAndWidth(leading); 163403"];
3607 [label="return 'this'; 163404"];
3608 [label="FullWidth = this.Text.Length; 163405"];
3609 [label="FullWidth 163406"];
3610 [label="this.AdjustFlagsAndWidth(trailing); 163407"];
3611 [label="return 'this'; 163408"];
3612 [label="FullWidth = this.Text.Length; 163409"];
3613 [label="FullWidth 163410"];
3614 [label="this.AdjustFlagsAndWidth(trailing); 163411"];
3615 [label="return 'base'; 163412"];
3616 [label="FullWidth = this.Text.Length; 163413"];
3617 [label="FullWidth 163414"];
3618 [label="return 'base'; 163415"];
3619 [label="FullWidth = this.Text.Length; 163416"];
3620 [label="FullWidth 163417"];
3621 [label="this.AdjustFlagsAndWidth(leading); 163418"];
3622 [label="return 'base'; 163419"];
3623 [label="FullWidth = this.Text.Length; 163420"];
3624 [label="FullWidth 163421"];
3625 [label="this.AdjustFlagsAndWidth(trailing); 163422"];
3626 [label="return 'base'; 163423"];
3627 [label="FullWidth = this.Text.Length; 163424"];
3628 [label="FullWidth 163425"];
3629 [label="this.AdjustFlagsAndWidth(trailing); 163426"];
3630 [label="return 'namespace'; 163427"];
3631 [label="FullWidth = this.Text.Length; 163428"];
3632 [label="FullWidth 163429"];
3633 [label="return 'namespace'; 163430"];
3634 [label="FullWidth = this.Text.Length; 163431"];
3635 [label="FullWidth 163432"];
3636 [label="this.AdjustFlagsAndWidth(leading); 163433"];
3637 [label="return 'namespace'; 163434"];
3638 [label="FullWidth = this.Text.Length; 163435"];
3639 [label="FullWidth 163436"];
3640 [label="this.AdjustFlagsAndWidth(trailing); 163437"];
3641 [label="return 'namespace'; 163438"];
3642 [label="FullWidth = this.Text.Length; 163439"];
3643 [label="FullWidth 163440"];
3644 [label="this.AdjustFlagsAndWidth(trailing); 163441"];
3645 [label="return 'using'; 163442"];
3646 [label="FullWidth = this.Text.Length; 163443"];
3647 [label="FullWidth 163444"];
3648 [label="return 'using'; 163445"];
3649 [label="FullWidth = this.Text.Length; 163446"];
3650 [label="FullWidth 163447"];
3651 [label="this.AdjustFlagsAndWidth(leading); 163448"];
3652 [label="return 'using'; 163449"];
3653 [label="FullWidth = this.Text.Length; 163450"];
3654 [label="FullWidth 163451"];
3655 [label="this.AdjustFlagsAndWidth(trailing); 163452"];
3656 [label="return 'using'; 163453"];
3657 [label="FullWidth = this.Text.Length; 163454"];
3658 [label="FullWidth 163455"];
3659 [label="this.AdjustFlagsAndWidth(trailing); 163456"];
3660 [label="return 'class'; 163457"];
3661 [label="FullWidth = this.Text.Length; 163458"];
3662 [label="FullWidth 163459"];
3663 [label="return 'class'; 163460"];
3664 [label="FullWidth = this.Text.Length; 163461"];
3665 [label="FullWidth 163462"];
3666 [label="this.AdjustFlagsAndWidth(leading); 163463"];
3667 [label="return 'class'; 163464"];
3668 [label="FullWidth = this.Text.Length; 163465"];
3669 [label="FullWidth 163466"];
3670 [label="this.AdjustFlagsAndWidth(trailing); 163467"];
3671 [label="return 'class'; 163468"];
3672 [label="FullWidth = this.Text.Length; 163469"];
3673 [label="FullWidth 163470"];
3674 [label="this.AdjustFlagsAndWidth(trailing); 163471"];
3675 [label="return 'struct'; 163472"];
3676 [label="FullWidth = this.Text.Length; 163473"];
3677 [label="FullWidth 163474"];
3678 [label="return 'struct'; 163475"];
3679 [label="FullWidth = this.Text.Length; 163476"];
3680 [label="FullWidth 163477"];
3681 [label="this.AdjustFlagsAndWidth(leading); 163478"];
3682 [label="return 'struct'; 163479"];
3683 [label="FullWidth = this.Text.Length; 163480"];
3684 [label="FullWidth 163481"];
3685 [label="this.AdjustFlagsAndWidth(trailing); 163482"];
3686 [label="return 'struct'; 163483"];
3687 [label="FullWidth = this.Text.Length; 163484"];
3688 [label="FullWidth 163485"];
3689 [label="this.AdjustFlagsAndWidth(trailing); 163486"];
3690 [label="return 'interface'; 163487"];
3691 [label="FullWidth = this.Text.Length; 163488"];
3692 [label="FullWidth 163489"];
3693 [label="return 'interface'; 163490"];
3694 [label="FullWidth = this.Text.Length; 163491"];
3695 [label="FullWidth 163492"];
3696 [label="this.AdjustFlagsAndWidth(leading); 163493"];
3697 [label="return 'interface'; 163494"];
3698 [label="FullWidth = this.Text.Length; 163495"];
3699 [label="FullWidth 163496"];
3700 [label="this.AdjustFlagsAndWidth(trailing); 163497"];
3701 [label="return 'interface'; 163498"];
3702 [label="FullWidth = this.Text.Length; 163499"];
3703 [label="FullWidth 163500"];
3704 [label="this.AdjustFlagsAndWidth(trailing); 163501"];
3705 [label="return 'enum'; 163502"];
3706 [label="FullWidth = this.Text.Length; 163503"];
3707 [label="FullWidth 163504"];
3708 [label="return 'enum'; 163505"];
3709 [label="FullWidth = this.Text.Length; 163506"];
3710 [label="FullWidth 163507"];
3711 [label="this.AdjustFlagsAndWidth(leading); 163508"];
3712 [label="return 'enum'; 163509"];
3713 [label="FullWidth = this.Text.Length; 163510"];
3714 [label="FullWidth 163511"];
3715 [label="this.AdjustFlagsAndWidth(trailing); 163512"];
3716 [label="return 'enum'; 163513"];
3717 [label="FullWidth = this.Text.Length; 163514"];
3718 [label="FullWidth 163515"];
3719 [label="this.AdjustFlagsAndWidth(trailing); 163516"];
3720 [label="return 'delegate'; 163517"];
3721 [label="FullWidth = this.Text.Length; 163518"];
3722 [label="FullWidth 163519"];
3723 [label="return 'delegate'; 163520"];
3724 [label="FullWidth = this.Text.Length; 163521"];
3725 [label="FullWidth 163522"];
3726 [label="this.AdjustFlagsAndWidth(leading); 163523"];
3727 [label="return 'delegate'; 163524"];
3728 [label="FullWidth = this.Text.Length; 163525"];
3729 [label="FullWidth 163526"];
3730 [label="this.AdjustFlagsAndWidth(trailing); 163527"];
3731 [label="return 'delegate'; 163528"];
3732 [label="FullWidth = this.Text.Length; 163529"];
3733 [label="FullWidth 163530"];
3734 [label="this.AdjustFlagsAndWidth(trailing); 163531"];
3735 [label="return 'checked'; 163532"];
3736 [label="FullWidth = this.Text.Length; 163533"];
3737 [label="FullWidth 163534"];
3738 [label="return 'checked'; 163535"];
3739 [label="FullWidth = this.Text.Length; 163536"];
3740 [label="FullWidth 163537"];
3741 [label="this.AdjustFlagsAndWidth(leading); 163538"];
3742 [label="return 'checked'; 163539"];
3743 [label="FullWidth = this.Text.Length; 163540"];
3744 [label="FullWidth 163541"];
3745 [label="this.AdjustFlagsAndWidth(trailing); 163542"];
3746 [label="return 'checked'; 163543"];
3747 [label="FullWidth = this.Text.Length; 163544"];
3748 [label="FullWidth 163545"];
3749 [label="this.AdjustFlagsAndWidth(trailing); 163546"];
3750 [label="return 'unchecked'; 163547"];
3751 [label="FullWidth = this.Text.Length; 163548"];
3752 [label="FullWidth 163549"];
3753 [label="return 'unchecked'; 163550"];
3754 [label="FullWidth = this.Text.Length; 163551"];
3755 [label="FullWidth 163552"];
3756 [label="this.AdjustFlagsAndWidth(leading); 163553"];
3757 [label="return 'unchecked'; 163554"];
3758 [label="FullWidth = this.Text.Length; 163555"];
3759 [label="FullWidth 163556"];
3760 [label="this.AdjustFlagsAndWidth(trailing); 163557"];
3761 [label="return 'unchecked'; 163558"];
3762 [label="FullWidth = this.Text.Length; 163559"];
3763 [label="FullWidth 163560"];
3764 [label="this.AdjustFlagsAndWidth(trailing); 163561"];
3765 [label="return 'unsafe'; 163562"];
3766 [label="FullWidth = this.Text.Length; 163563"];
3767 [label="FullWidth 163564"];
3768 [label="return 'unsafe'; 163565"];
3769 [label="FullWidth = this.Text.Length; 163566"];
3770 [label="FullWidth 163567"];
3771 [label="this.AdjustFlagsAndWidth(leading); 163568"];
3772 [label="return 'unsafe'; 163569"];
3773 [label="FullWidth = this.Text.Length; 163570"];
3774 [label="FullWidth 163571"];
3775 [label="this.AdjustFlagsAndWidth(trailing); 163572"];
3776 [label="return 'unsafe'; 163573"];
3777 [label="FullWidth = this.Text.Length; 163574"];
3778 [label="FullWidth 163575"];
3779 [label="this.AdjustFlagsAndWidth(trailing); 163576"];
3780 [label="return 'operator'; 163577"];
3781 [label="FullWidth = this.Text.Length; 163578"];
3782 [label="FullWidth 163579"];
3783 [label="return 'operator'; 163580"];
3784 [label="FullWidth = this.Text.Length; 163581"];
3785 [label="FullWidth 163582"];
3786 [label="this.AdjustFlagsAndWidth(leading); 163583"];
3787 [label="return 'operator'; 163584"];
3788 [label="FullWidth = this.Text.Length; 163585"];
3789 [label="FullWidth 163586"];
3790 [label="this.AdjustFlagsAndWidth(trailing); 163587"];
3791 [label="return 'operator'; 163588"];
3792 [label="FullWidth = this.Text.Length; 163589"];
3793 [label="FullWidth 163590"];
3794 [label="this.AdjustFlagsAndWidth(trailing); 163591"];
3795 [label="return 'explicit'; 163592"];
3796 [label="FullWidth = this.Text.Length; 163593"];
3797 [label="FullWidth 163594"];
3798 [label="return 'explicit'; 163595"];
3799 [label="FullWidth = this.Text.Length; 163596"];
3800 [label="FullWidth 163597"];
3801 [label="this.AdjustFlagsAndWidth(leading); 163598"];
3802 [label="return 'explicit'; 163599"];
3803 [label="FullWidth = this.Text.Length; 163600"];
3804 [label="FullWidth 163601"];
3805 [label="this.AdjustFlagsAndWidth(trailing); 163602"];
3806 [label="return 'explicit'; 163603"];
3807 [label="FullWidth = this.Text.Length; 163604"];
3808 [label="FullWidth 163605"];
3809 [label="this.AdjustFlagsAndWidth(trailing); 163606"];
3810 [label="return 'implicit'; 163607"];
3811 [label="FullWidth = this.Text.Length; 163608"];
3812 [label="FullWidth 163609"];
3813 [label="return 'implicit'; 163610"];
3814 [label="FullWidth = this.Text.Length; 163611"];
3815 [label="FullWidth 163612"];
3816 [label="this.AdjustFlagsAndWidth(leading); 163613"];
3817 [label="return 'implicit'; 163614"];
3818 [label="FullWidth = this.Text.Length; 163615"];
3819 [label="FullWidth 163616"];
3820 [label="this.AdjustFlagsAndWidth(trailing); 163617"];
3821 [label="return 'implicit'; 163618"];
3822 [label="FullWidth = this.Text.Length; 163619"];
3823 [label="FullWidth 163620"];
3824 [label="this.AdjustFlagsAndWidth(trailing); 163621"];
3825 [label="return 'yield'; 163622"];
3826 [label="FullWidth = this.Text.Length; 163623"];
3827 [label="FullWidth 163624"];
3828 [label="return 'yield'; 163625"];
3829 [label="FullWidth = this.Text.Length; 163626"];
3830 [label="FullWidth 163627"];
3831 [label="this.AdjustFlagsAndWidth(leading); 163628"];
3832 [label="return 'yield'; 163629"];
3833 [label="FullWidth = this.Text.Length; 163630"];
3834 [label="FullWidth 163631"];
3835 [label="this.AdjustFlagsAndWidth(trailing); 163632"];
3836 [label="return 'yield'; 163633"];
3837 [label="FullWidth = this.Text.Length; 163634"];
3838 [label="FullWidth 163635"];
3839 [label="this.AdjustFlagsAndWidth(trailing); 163636"];
3840 [label="return 'partial'; 163637"];
3841 [label="FullWidth = this.Text.Length; 163638"];
3842 [label="FullWidth 163639"];
3843 [label="return 'partial'; 163640"];
3844 [label="FullWidth = this.Text.Length; 163641"];
3845 [label="FullWidth 163642"];
3846 [label="this.AdjustFlagsAndWidth(leading); 163643"];
3847 [label="return 'partial'; 163644"];
3848 [label="FullWidth = this.Text.Length; 163645"];
3849 [label="FullWidth 163646"];
3850 [label="this.AdjustFlagsAndWidth(trailing); 163647"];
3851 [label="return 'partial'; 163648"];
3852 [label="FullWidth = this.Text.Length; 163649"];
3853 [label="FullWidth 163650"];
3854 [label="this.AdjustFlagsAndWidth(trailing); 163651"];
3855 [label="return 'alias'; 163652"];
3856 [label="FullWidth = this.Text.Length; 163653"];
3857 [label="FullWidth 163654"];
3858 [label="return 'alias'; 163655"];
3859 [label="FullWidth = this.Text.Length; 163656"];
3860 [label="FullWidth 163657"];
3861 [label="this.AdjustFlagsAndWidth(leading); 163658"];
3862 [label="return 'alias'; 163659"];
3863 [label="FullWidth = this.Text.Length; 163660"];
3864 [label="FullWidth 163661"];
3865 [label="this.AdjustFlagsAndWidth(trailing); 163662"];
3866 [label="return 'alias'; 163663"];
3867 [label="FullWidth = this.Text.Length; 163664"];
3868 [label="FullWidth 163665"];
3869 [label="this.AdjustFlagsAndWidth(trailing); 163666"];
3870 [label="return 'global'; 163667"];
3871 [label="FullWidth = this.Text.Length; 163668"];
3872 [label="FullWidth 163669"];
3873 [label="return 'global'; 163670"];
3874 [label="FullWidth = this.Text.Length; 163671"];
3875 [label="FullWidth 163672"];
3876 [label="this.AdjustFlagsAndWidth(leading); 163673"];
3877 [label="return 'global'; 163674"];
3878 [label="FullWidth = this.Text.Length; 163675"];
3879 [label="FullWidth 163676"];
3880 [label="this.AdjustFlagsAndWidth(trailing); 163677"];
3881 [label="return 'global'; 163678"];
3882 [label="FullWidth = this.Text.Length; 163679"];
3883 [label="FullWidth 163680"];
3884 [label="this.AdjustFlagsAndWidth(trailing); 163681"];
3885 [label="return 'assembly'; 163682"];
3886 [label="FullWidth = this.Text.Length; 163683"];
3887 [label="FullWidth 163684"];
3888 [label="return 'assembly'; 163685"];
3889 [label="FullWidth = this.Text.Length; 163686"];
3890 [label="FullWidth 163687"];
3891 [label="this.AdjustFlagsAndWidth(leading); 163688"];
3892 [label="return 'assembly'; 163689"];
3893 [label="FullWidth = this.Text.Length; 163690"];
3894 [label="FullWidth 163691"];
3895 [label="this.AdjustFlagsAndWidth(trailing); 163692"];
3896 [label="return 'assembly'; 163693"];
3897 [label="FullWidth = this.Text.Length; 163694"];
3898 [label="FullWidth 163695"];
3899 [label="this.AdjustFlagsAndWidth(trailing); 163696"];
3900 [label="return 'module'; 163697"];
3901 [label="FullWidth = this.Text.Length; 163698"];
3902 [label="FullWidth 163699"];
3903 [label="return 'module'; 163700"];
3904 [label="FullWidth = this.Text.Length; 163701"];
3905 [label="FullWidth 163702"];
3906 [label="this.AdjustFlagsAndWidth(leading); 163703"];
3907 [label="return 'module'; 163704"];
3908 [label="FullWidth = this.Text.Length; 163705"];
3909 [label="FullWidth 163706"];
3910 [label="this.AdjustFlagsAndWidth(trailing); 163707"];
3911 [label="return 'module'; 163708"];
3912 [label="FullWidth = this.Text.Length; 163709"];
3913 [label="FullWidth 163710"];
3914 [label="this.AdjustFlagsAndWidth(trailing); 163711"];
3915 [label="return 'type'; 163712"];
3916 [label="FullWidth = this.Text.Length; 163713"];
3917 [label="FullWidth 163714"];
3918 [label="return 'type'; 163715"];
3919 [label="FullWidth = this.Text.Length; 163716"];
3920 [label="FullWidth 163717"];
3921 [label="this.AdjustFlagsAndWidth(leading); 163718"];
3922 [label="return 'type'; 163719"];
3923 [label="FullWidth = this.Text.Length; 163720"];
3924 [label="FullWidth 163721"];
3925 [label="this.AdjustFlagsAndWidth(trailing); 163722"];
3926 [label="return 'type'; 163723"];
3927 [label="FullWidth = this.Text.Length; 163724"];
3928 [label="FullWidth 163725"];
3929 [label="this.AdjustFlagsAndWidth(trailing); 163726"];
3930 [label="return 'field'; 163727"];
3931 [label="FullWidth = this.Text.Length; 163728"];
3932 [label="FullWidth 163729"];
3933 [label="return 'field'; 163730"];
3934 [label="FullWidth = this.Text.Length; 163731"];
3935 [label="FullWidth 163732"];
3936 [label="this.AdjustFlagsAndWidth(leading); 163733"];
3937 [label="return 'field'; 163734"];
3938 [label="FullWidth = this.Text.Length; 163735"];
3939 [label="FullWidth 163736"];
3940 [label="this.AdjustFlagsAndWidth(trailing); 163737"];
3941 [label="return 'field'; 163738"];
3942 [label="FullWidth = this.Text.Length; 163739"];
3943 [label="FullWidth 163740"];
3944 [label="this.AdjustFlagsAndWidth(trailing); 163741"];
3945 [label="return 'method'; 163742"];
3946 [label="FullWidth = this.Text.Length; 163743"];
3947 [label="FullWidth 163744"];
3948 [label="return 'method'; 163745"];
3949 [label="FullWidth = this.Text.Length; 163746"];
3950 [label="FullWidth 163747"];
3951 [label="this.AdjustFlagsAndWidth(leading); 163748"];
3952 [label="return 'method'; 163749"];
3953 [label="FullWidth = this.Text.Length; 163750"];
3954 [label="FullWidth 163751"];
3955 [label="this.AdjustFlagsAndWidth(trailing); 163752"];
3956 [label="return 'method'; 163753"];
3957 [label="FullWidth = this.Text.Length; 163754"];
3958 [label="FullWidth 163755"];
3959 [label="this.AdjustFlagsAndWidth(trailing); 163756"];
3960 [label="return 'param'; 163757"];
3961 [label="FullWidth = this.Text.Length; 163758"];
3962 [label="FullWidth 163759"];
3963 [label="return 'param'; 163760"];
3964 [label="FullWidth = this.Text.Length; 163761"];
3965 [label="FullWidth 163762"];
3966 [label="this.AdjustFlagsAndWidth(leading); 163763"];
3967 [label="return 'param'; 163764"];
3968 [label="FullWidth = this.Text.Length; 163765"];
3969 [label="FullWidth 163766"];
3970 [label="this.AdjustFlagsAndWidth(trailing); 163767"];
3971 [label="return 'param'; 163768"];
3972 [label="FullWidth = this.Text.Length; 163769"];
3973 [label="FullWidth 163770"];
3974 [label="this.AdjustFlagsAndWidth(trailing); 163771"];
3975 [label="return 'property'; 163772"];
3976 [label="FullWidth = this.Text.Length; 163773"];
3977 [label="FullWidth 163774"];
3978 [label="return 'property'; 163775"];
3979 [label="FullWidth = this.Text.Length; 163776"];
3980 [label="FullWidth 163777"];
3981 [label="this.AdjustFlagsAndWidth(leading); 163778"];
3982 [label="return 'property'; 163779"];
3983 [label="FullWidth = this.Text.Length; 163780"];
3984 [label="FullWidth 163781"];
3985 [label="this.AdjustFlagsAndWidth(trailing); 163782"];
3986 [label="return 'property'; 163783"];
3987 [label="FullWidth = this.Text.Length; 163784"];
3988 [label="FullWidth 163785"];
3989 [label="this.AdjustFlagsAndWidth(trailing); 163786"];
3990 [label="return 'typevar'; 163787"];
3991 [label="FullWidth = this.Text.Length; 163788"];
3992 [label="FullWidth 163789"];
3993 [label="return 'typevar'; 163790"];
3994 [label="FullWidth = this.Text.Length; 163791"];
3995 [label="FullWidth 163792"];
3996 [label="this.AdjustFlagsAndWidth(leading); 163793"];
3997 [label="return 'typevar'; 163794"];
3998 [label="FullWidth = this.Text.Length; 163795"];
3999 [label="FullWidth 163796"];
4000 [label="this.AdjustFlagsAndWidth(trailing); 163797"];
4001 [label="return 'typevar'; 163798"];
4002 [label="FullWidth = this.Text.Length; 163799"];
4003 [label="FullWidth 163800"];
4004 [label="this.AdjustFlagsAndWidth(trailing); 163801"];
4005 [label="return 'get'; 163802"];
4006 [label="FullWidth = this.Text.Length; 163803"];
4007 [label="FullWidth 163804"];
4008 [label="return 'get'; 163805"];
4009 [label="FullWidth = this.Text.Length; 163806"];
4010 [label="FullWidth 163807"];
4011 [label="this.AdjustFlagsAndWidth(leading); 163808"];
4012 [label="return 'get'; 163809"];
4013 [label="FullWidth = this.Text.Length; 163810"];
4014 [label="FullWidth 163811"];
4015 [label="this.AdjustFlagsAndWidth(trailing); 163812"];
4016 [label="return 'get'; 163813"];
4017 [label="FullWidth = this.Text.Length; 163814"];
4018 [label="FullWidth 163815"];
4019 [label="this.AdjustFlagsAndWidth(trailing); 163816"];
4020 [label="return 'set'; 163817"];
4021 [label="FullWidth = this.Text.Length; 163818"];
4022 [label="FullWidth 163819"];
4023 [label="return 'set'; 163820"];
4024 [label="FullWidth = this.Text.Length; 163821"];
4025 [label="FullWidth 163822"];
4026 [label="this.AdjustFlagsAndWidth(leading); 163823"];
4027 [label="return 'set'; 163824"];
4028 [label="FullWidth = this.Text.Length; 163825"];
4029 [label="FullWidth 163826"];
4030 [label="this.AdjustFlagsAndWidth(trailing); 163827"];
4031 [label="return 'set'; 163828"];
4032 [label="FullWidth = this.Text.Length; 163829"];
4033 [label="FullWidth 163830"];
4034 [label="this.AdjustFlagsAndWidth(trailing); 163831"];
4035 [label="return 'add'; 163832"];
4036 [label="FullWidth = this.Text.Length; 163833"];
4037 [label="FullWidth 163834"];
4038 [label="return 'add'; 163835"];
4039 [label="FullWidth = this.Text.Length; 163836"];
4040 [label="FullWidth 163837"];
4041 [label="this.AdjustFlagsAndWidth(leading); 163838"];
4042 [label="return 'add'; 163839"];
4043 [label="FullWidth = this.Text.Length; 163840"];
4044 [label="FullWidth 163841"];
4045 [label="this.AdjustFlagsAndWidth(trailing); 163842"];
4046 [label="return 'add'; 163843"];
4047 [label="FullWidth = this.Text.Length; 163844"];
4048 [label="FullWidth 163845"];
4049 [label="this.AdjustFlagsAndWidth(trailing); 163846"];
4050 [label="return 'remove'; 163847"];
4051 [label="FullWidth = this.Text.Length; 163848"];
4052 [label="FullWidth 163849"];
4053 [label="return 'remove'; 163850"];
4054 [label="FullWidth = this.Text.Length; 163851"];
4055 [label="FullWidth 163852"];
4056 [label="this.AdjustFlagsAndWidth(leading); 163853"];
4057 [label="return 'remove'; 163854"];
4058 [label="FullWidth = this.Text.Length; 163855"];
4059 [label="FullWidth 163856"];
4060 [label="this.AdjustFlagsAndWidth(trailing); 163857"];
4061 [label="return 'remove'; 163858"];
4062 [label="FullWidth = this.Text.Length; 163859"];
4063 [label="FullWidth 163860"];
4064 [label="this.AdjustFlagsAndWidth(trailing); 163861"];
4065 [label="return 'where'; 163862"];
4066 [label="FullWidth = this.Text.Length; 163863"];
4067 [label="FullWidth 163864"];
4068 [label="return 'where'; 163865"];
4069 [label="FullWidth = this.Text.Length; 163866"];
4070 [label="FullWidth 163867"];
4071 [label="this.AdjustFlagsAndWidth(leading); 163868"];
4072 [label="return 'where'; 163869"];
4073 [label="FullWidth = this.Text.Length; 163870"];
4074 [label="FullWidth 163871"];
4075 [label="this.AdjustFlagsAndWidth(trailing); 163872"];
4076 [label="return 'where'; 163873"];
4077 [label="FullWidth = this.Text.Length; 163874"];
4078 [label="FullWidth 163875"];
4079 [label="this.AdjustFlagsAndWidth(trailing); 163876"];
4080 [label="return 'from'; 163877"];
4081 [label="FullWidth = this.Text.Length; 163878"];
4082 [label="FullWidth 163879"];
4083 [label="return 'from'; 163880"];
4084 [label="FullWidth = this.Text.Length; 163881"];
4085 [label="FullWidth 163882"];
4086 [label="this.AdjustFlagsAndWidth(leading); 163883"];
4087 [label="return 'from'; 163884"];
4088 [label="FullWidth = this.Text.Length; 163885"];
4089 [label="FullWidth 163886"];
4090 [label="this.AdjustFlagsAndWidth(trailing); 163887"];
4091 [label="return 'from'; 163888"];
4092 [label="FullWidth = this.Text.Length; 163889"];
4093 [label="FullWidth 163890"];
4094 [label="this.AdjustFlagsAndWidth(trailing); 163891"];
4095 [label="return 'group'; 163892"];
4096 [label="FullWidth = this.Text.Length; 163893"];
4097 [label="FullWidth 163894"];
4098 [label="return 'group'; 163895"];
4099 [label="FullWidth = this.Text.Length; 163896"];
4100 [label="FullWidth 163897"];
4101 [label="this.AdjustFlagsAndWidth(leading); 163898"];
4102 [label="return 'group'; 163899"];
4103 [label="FullWidth = this.Text.Length; 163900"];
4104 [label="FullWidth 163901"];
4105 [label="this.AdjustFlagsAndWidth(trailing); 163902"];
4106 [label="return 'group'; 163903"];
4107 [label="FullWidth = this.Text.Length; 163904"];
4108 [label="FullWidth 163905"];
4109 [label="this.AdjustFlagsAndWidth(trailing); 163906"];
4110 [label="return 'join'; 163907"];
4111 [label="FullWidth = this.Text.Length; 163908"];
4112 [label="FullWidth 163909"];
4113 [label="return 'join'; 163910"];
4114 [label="FullWidth = this.Text.Length; 163911"];
4115 [label="FullWidth 163912"];
4116 [label="this.AdjustFlagsAndWidth(leading); 163913"];
4117 [label="return 'join'; 163914"];
4118 [label="FullWidth = this.Text.Length; 163915"];
4119 [label="FullWidth 163916"];
4120 [label="this.AdjustFlagsAndWidth(trailing); 163917"];
4121 [label="return 'join'; 163918"];
4122 [label="FullWidth = this.Text.Length; 163919"];
4123 [label="FullWidth 163920"];
4124 [label="this.AdjustFlagsAndWidth(trailing); 163921"];
4125 [label="return 'into'; 163922"];
4126 [label="FullWidth = this.Text.Length; 163923"];
4127 [label="FullWidth 163924"];
4128 [label="return 'into'; 163925"];
4129 [label="FullWidth = this.Text.Length; 163926"];
4130 [label="FullWidth 163927"];
4131 [label="this.AdjustFlagsAndWidth(leading); 163928"];
4132 [label="return 'into'; 163929"];
4133 [label="FullWidth = this.Text.Length; 163930"];
4134 [label="FullWidth 163931"];
4135 [label="this.AdjustFlagsAndWidth(trailing); 163932"];
4136 [label="return 'into'; 163933"];
4137 [label="FullWidth = this.Text.Length; 163934"];
4138 [label="FullWidth 163935"];
4139 [label="this.AdjustFlagsAndWidth(trailing); 163936"];
4140 [label="return 'let'; 163937"];
4141 [label="FullWidth = this.Text.Length; 163938"];
4142 [label="FullWidth 163939"];
4143 [label="return 'let'; 163940"];
4144 [label="FullWidth = this.Text.Length; 163941"];
4145 [label="FullWidth 163942"];
4146 [label="this.AdjustFlagsAndWidth(leading); 163943"];
4147 [label="return 'let'; 163944"];
4148 [label="FullWidth = this.Text.Length; 163945"];
4149 [label="FullWidth 163946"];
4150 [label="this.AdjustFlagsAndWidth(trailing); 163947"];
4151 [label="return 'let'; 163948"];
4152 [label="FullWidth = this.Text.Length; 163949"];
4153 [label="FullWidth 163950"];
4154 [label="this.AdjustFlagsAndWidth(trailing); 163951"];
4155 [label="return 'by'; 163952"];
4156 [label="FullWidth = this.Text.Length; 163953"];
4157 [label="FullWidth 163954"];
4158 [label="return 'by'; 163955"];
4159 [label="FullWidth = this.Text.Length; 163956"];
4160 [label="FullWidth 163957"];
4161 [label="this.AdjustFlagsAndWidth(leading); 163958"];
4162 [label="return 'by'; 163959"];
4163 [label="FullWidth = this.Text.Length; 163960"];
4164 [label="FullWidth 163961"];
4165 [label="this.AdjustFlagsAndWidth(trailing); 163962"];
4166 [label="return 'by'; 163963"];
4167 [label="FullWidth = this.Text.Length; 163964"];
4168 [label="FullWidth 163965"];
4169 [label="this.AdjustFlagsAndWidth(trailing); 163966"];
4170 [label="return 'select'; 163967"];
4171 [label="FullWidth = this.Text.Length; 163968"];
4172 [label="FullWidth 163969"];
4173 [label="return 'select'; 163970"];
4174 [label="FullWidth = this.Text.Length; 163971"];
4175 [label="FullWidth 163972"];
4176 [label="this.AdjustFlagsAndWidth(leading); 163973"];
4177 [label="return 'select'; 163974"];
4178 [label="FullWidth = this.Text.Length; 163975"];
4179 [label="FullWidth 163976"];
4180 [label="this.AdjustFlagsAndWidth(trailing); 163977"];
4181 [label="return 'select'; 163978"];
4182 [label="FullWidth = this.Text.Length; 163979"];
4183 [label="FullWidth 163980"];
4184 [label="this.AdjustFlagsAndWidth(trailing); 163981"];
4185 [label="return 'orderby'; 163982"];
4186 [label="FullWidth = this.Text.Length; 163983"];
4187 [label="FullWidth 163984"];
4188 [label="return 'orderby'; 163985"];
4189 [label="FullWidth = this.Text.Length; 163986"];
4190 [label="FullWidth 163987"];
4191 [label="this.AdjustFlagsAndWidth(leading); 163988"];
4192 [label="return 'orderby'; 163989"];
4193 [label="FullWidth = this.Text.Length; 163990"];
4194 [label="FullWidth 163991"];
4195 [label="this.AdjustFlagsAndWidth(trailing); 163992"];
4196 [label="return 'orderby'; 163993"];
4197 [label="FullWidth = this.Text.Length; 163994"];
4198 [label="FullWidth 163995"];
4199 [label="this.AdjustFlagsAndWidth(trailing); 163996"];
4200 [label="return 'on'; 163997"];
4201 [label="FullWidth = this.Text.Length; 163998"];
4202 [label="FullWidth 163999"];
4203 [label="return 'on'; 164000"];
4204 [label="FullWidth = this.Text.Length; 164001"];
4205 [label="FullWidth 164002"];
4206 [label="this.AdjustFlagsAndWidth(leading); 164003"];
4207 [label="return 'on'; 164004"];
4208 [label="FullWidth = this.Text.Length; 164005"];
4209 [label="FullWidth 164006"];
4210 [label="this.AdjustFlagsAndWidth(trailing); 164007"];
4211 [label="return 'on'; 164008"];
4212 [label="FullWidth = this.Text.Length; 164009"];
4213 [label="FullWidth 164010"];
4214 [label="this.AdjustFlagsAndWidth(trailing); 164011"];
4215 [label="return 'equals'; 164012"];
4216 [label="FullWidth = this.Text.Length; 164013"];
4217 [label="FullWidth 164014"];
4218 [label="return 'equals'; 164015"];
4219 [label="FullWidth = this.Text.Length; 164016"];
4220 [label="FullWidth 164017"];
4221 [label="this.AdjustFlagsAndWidth(leading); 164018"];
4222 [label="return 'equals'; 164019"];
4223 [label="FullWidth = this.Text.Length; 164020"];
4224 [label="FullWidth 164021"];
4225 [label="this.AdjustFlagsAndWidth(trailing); 164022"];
4226 [label="return 'equals'; 164023"];
4227 [label="FullWidth = this.Text.Length; 164024"];
4228 [label="FullWidth 164025"];
4229 [label="this.AdjustFlagsAndWidth(trailing); 164026"];
4230 [label="return 'ascending'; 164027"];
4231 [label="FullWidth = this.Text.Length; 164028"];
4232 [label="FullWidth 164029"];
4233 [label="return 'ascending'; 164030"];
4234 [label="FullWidth = this.Text.Length; 164031"];
4235 [label="FullWidth 164032"];
4236 [label="this.AdjustFlagsAndWidth(leading); 164033"];
4237 [label="return 'ascending'; 164034"];
4238 [label="FullWidth = this.Text.Length; 164035"];
4239 [label="FullWidth 164036"];
4240 [label="this.AdjustFlagsAndWidth(trailing); 164037"];
4241 [label="return 'ascending'; 164038"];
4242 [label="FullWidth = this.Text.Length; 164039"];
4243 [label="FullWidth 164040"];
4244 [label="this.AdjustFlagsAndWidth(trailing); 164041"];
4245 [label="return 'descending'; 164042"];
4246 [label="FullWidth = this.Text.Length; 164043"];
4247 [label="FullWidth 164044"];
4248 [label="return 'descending'; 164045"];
4249 [label="FullWidth = this.Text.Length; 164046"];
4250 [label="FullWidth 164047"];
4251 [label="this.AdjustFlagsAndWidth(leading); 164048"];
4252 [label="return 'descending'; 164049"];
4253 [label="FullWidth = this.Text.Length; 164050"];
4254 [label="FullWidth 164051"];
4255 [label="this.AdjustFlagsAndWidth(trailing); 164052"];
4256 [label="return 'descending'; 164053"];
4257 [label="FullWidth = this.Text.Length; 164054"];
4258 [label="FullWidth 164055"];
4259 [label="this.AdjustFlagsAndWidth(trailing); 164056"];
4260 [label="return 'nameof'; 164057"];
4261 [label="FullWidth = this.Text.Length; 164058"];
4262 [label="FullWidth 164059"];
4263 [label="return 'nameof'; 164060"];
4264 [label="FullWidth = this.Text.Length; 164061"];
4265 [label="FullWidth 164062"];
4266 [label="this.AdjustFlagsAndWidth(leading); 164063"];
4267 [label="return 'nameof'; 164064"];
4268 [label="FullWidth = this.Text.Length; 164065"];
4269 [label="FullWidth 164066"];
4270 [label="this.AdjustFlagsAndWidth(trailing); 164067"];
4271 [label="return 'nameof'; 164068"];
4272 [label="FullWidth = this.Text.Length; 164069"];
4273 [label="FullWidth 164070"];
4274 [label="this.AdjustFlagsAndWidth(trailing); 164071"];
4275 [label="return 'async'; 164072"];
4276 [label="FullWidth = this.Text.Length; 164073"];
4277 [label="FullWidth 164074"];
4278 [label="return 'async'; 164075"];
4279 [label="FullWidth = this.Text.Length; 164076"];
4280 [label="FullWidth 164077"];
4281 [label="this.AdjustFlagsAndWidth(leading); 164078"];
4282 [label="return 'async'; 164079"];
4283 [label="FullWidth = this.Text.Length; 164080"];
4284 [label="FullWidth 164081"];
4285 [label="this.AdjustFlagsAndWidth(trailing); 164082"];
4286 [label="return 'async'; 164083"];
4287 [label="FullWidth = this.Text.Length; 164084"];
4288 [label="FullWidth 164085"];
4289 [label="this.AdjustFlagsAndWidth(trailing); 164086"];
4290 [label="return 'await'; 164087"];
4291 [label="FullWidth = this.Text.Length; 164088"];
4292 [label="FullWidth 164089"];
4293 [label="return 'await'; 164090"];
4294 [label="FullWidth = this.Text.Length; 164091"];
4295 [label="FullWidth 164092"];
4296 [label="this.AdjustFlagsAndWidth(leading); 164093"];
4297 [label="return 'await'; 164094"];
4298 [label="FullWidth = this.Text.Length; 164095"];
4299 [label="FullWidth 164096"];
4300 [label="this.AdjustFlagsAndWidth(trailing); 164097"];
4301 [label="return 'await'; 164098"];
4302 [label="FullWidth = this.Text.Length; 164099"];
4303 [label="FullWidth 164100"];
4304 [label="this.AdjustFlagsAndWidth(trailing); 164101"];
4305 [label="return 'when'; 164102"];
4306 [label="FullWidth = this.Text.Length; 164103"];
4307 [label="FullWidth 164104"];
4308 [label="return 'when'; 164105"];
4309 [label="FullWidth = this.Text.Length; 164106"];
4310 [label="FullWidth 164107"];
4311 [label="this.AdjustFlagsAndWidth(leading); 164108"];
4312 [label="return 'when'; 164109"];
4313 [label="FullWidth = this.Text.Length; 164110"];
4314 [label="FullWidth 164111"];
4315 [label="this.AdjustFlagsAndWidth(trailing); 164112"];
4316 [label="return 'when'; 164113"];
4317 [label="FullWidth = this.Text.Length; 164114"];
4318 [label="FullWidth 164115"];
4319 [label="this.AdjustFlagsAndWidth(trailing); 164116"];
4320 [label="return 'or'; 164117"];
4321 [label="FullWidth = this.Text.Length; 164118"];
4322 [label="FullWidth 164119"];
4323 [label="return 'or'; 164120"];
4324 [label="FullWidth = this.Text.Length; 164121"];
4325 [label="FullWidth 164122"];
4326 [label="this.AdjustFlagsAndWidth(leading); 164123"];
4327 [label="return 'or'; 164124"];
4328 [label="FullWidth = this.Text.Length; 164125"];
4329 [label="FullWidth 164126"];
4330 [label="this.AdjustFlagsAndWidth(trailing); 164127"];
4331 [label="return 'or'; 164128"];
4332 [label="FullWidth = this.Text.Length; 164129"];
4333 [label="FullWidth 164130"];
4334 [label="this.AdjustFlagsAndWidth(trailing); 164131"];
4335 [label="return 'and'; 164132"];
4336 [label="FullWidth = this.Text.Length; 164133"];
4337 [label="FullWidth 164134"];
4338 [label="return 'and'; 164135"];
4339 [label="FullWidth = this.Text.Length; 164136"];
4340 [label="FullWidth 164137"];
4341 [label="this.AdjustFlagsAndWidth(leading); 164138"];
4342 [label="return 'and'; 164139"];
4343 [label="FullWidth = this.Text.Length; 164140"];
4344 [label="FullWidth 164141"];
4345 [label="this.AdjustFlagsAndWidth(trailing); 164142"];
4346 [label="return 'and'; 164143"];
4347 [label="FullWidth = this.Text.Length; 164144"];
4348 [label="FullWidth 164145"];
4349 [label="this.AdjustFlagsAndWidth(trailing); 164146"];
4350 [label="return 'not'; 164147"];
4351 [label="FullWidth = this.Text.Length; 164148"];
4352 [label="FullWidth 164149"];
4353 [label="return 'not'; 164150"];
4354 [label="FullWidth = this.Text.Length; 164151"];
4355 [label="FullWidth 164152"];
4356 [label="this.AdjustFlagsAndWidth(leading); 164153"];
4357 [label="return 'not'; 164154"];
4358 [label="FullWidth = this.Text.Length; 164155"];
4359 [label="FullWidth 164156"];
4360 [label="this.AdjustFlagsAndWidth(trailing); 164157"];
4361 [label="return 'not'; 164158"];
4362 [label="FullWidth = this.Text.Length; 164159"];
4363 [label="FullWidth 164160"];
4364 [label="this.AdjustFlagsAndWidth(trailing); 164161"];
4365 [label="return 'data'; 164162"];
4366 [label="FullWidth = this.Text.Length; 164163"];
4367 [label="FullWidth 164164"];
4368 [label="return 'data'; 164165"];
4369 [label="FullWidth = this.Text.Length; 164166"];
4370 [label="FullWidth 164167"];
4371 [label="this.AdjustFlagsAndWidth(leading); 164168"];
4372 [label="return 'data'; 164169"];
4373 [label="FullWidth = this.Text.Length; 164170"];
4374 [label="FullWidth 164171"];
4375 [label="this.AdjustFlagsAndWidth(trailing); 164172"];
4376 [label="return 'data'; 164173"];
4377 [label="FullWidth = this.Text.Length; 164174"];
4378 [label="FullWidth 164175"];
4379 [label="this.AdjustFlagsAndWidth(trailing); 164176"];
4380 [label="return 'with'; 164177"];
4381 [label="FullWidth = this.Text.Length; 164178"];
4382 [label="FullWidth 164179"];
4383 [label="return 'with'; 164180"];
4384 [label="FullWidth = this.Text.Length; 164181"];
4385 [label="FullWidth 164182"];
4386 [label="this.AdjustFlagsAndWidth(leading); 164183"];
4387 [label="return 'with'; 164184"];
4388 [label="FullWidth = this.Text.Length; 164185"];
4389 [label="FullWidth 164186"];
4390 [label="this.AdjustFlagsAndWidth(trailing); 164187"];
4391 [label="return 'with'; 164188"];
4392 [label="FullWidth = this.Text.Length; 164189"];
4393 [label="FullWidth 164190"];
4394 [label="this.AdjustFlagsAndWidth(trailing); 164191"];
4395 [label="return 'init'; 164192"];
4396 [label="FullWidth = this.Text.Length; 164193"];
4397 [label="FullWidth 164194"];
4398 [label="return 'init'; 164195"];
4399 [label="FullWidth = this.Text.Length; 164196"];
4400 [label="FullWidth 164197"];
4401 [label="this.AdjustFlagsAndWidth(leading); 164198"];
4402 [label="return 'init'; 164199"];
4403 [label="FullWidth = this.Text.Length; 164200"];
4404 [label="FullWidth 164201"];
4405 [label="this.AdjustFlagsAndWidth(trailing); 164202"];
4406 [label="return 'init'; 164203"];
4407 [label="FullWidth = this.Text.Length; 164204"];
4408 [label="FullWidth 164205"];
4409 [label="this.AdjustFlagsAndWidth(trailing); 164206"];
4410 [label="return 'record'; 164207"];
4411 [label="FullWidth = this.Text.Length; 164208"];
4412 [label="FullWidth 164209"];
4413 [label="return 'record'; 164210"];
4414 [label="FullWidth = this.Text.Length; 164211"];
4415 [label="FullWidth 164212"];
4416 [label="this.AdjustFlagsAndWidth(leading); 164213"];
4417 [label="return 'record'; 164214"];
4418 [label="FullWidth = this.Text.Length; 164215"];
4419 [label="FullWidth 164216"];
4420 [label="this.AdjustFlagsAndWidth(trailing); 164217"];
4421 [label="return 'record'; 164218"];
4422 [label="FullWidth = this.Text.Length; 164219"];
4423 [label="FullWidth 164220"];
4424 [label="this.AdjustFlagsAndWidth(trailing); 164221"];
4425 [label="return 'managed'; 164222"];
4426 [label="FullWidth = this.Text.Length; 164223"];
4427 [label="FullWidth 164224"];
4428 [label="return 'managed'; 164225"];
4429 [label="FullWidth = this.Text.Length; 164226"];
4430 [label="FullWidth 164227"];
4431 [label="this.AdjustFlagsAndWidth(leading); 164228"];
4432 [label="return 'managed'; 164229"];
4433 [label="FullWidth = this.Text.Length; 164230"];
4434 [label="FullWidth 164231"];
4435 [label="this.AdjustFlagsAndWidth(trailing); 164232"];
4436 [label="return 'managed'; 164233"];
4437 [label="FullWidth = this.Text.Length; 164234"];
4438 [label="FullWidth 164235"];
4439 [label="this.AdjustFlagsAndWidth(trailing); 164236"];
4440 [label="return 'unmanaged'; 164237"];
4441 [label="FullWidth = this.Text.Length; 164238"];
4442 [label="FullWidth 164239"];
4443 [label="return 'unmanaged'; 164240"];
4444 [label="FullWidth = this.Text.Length; 164241"];
4445 [label="FullWidth 164242"];
4446 [label="this.AdjustFlagsAndWidth(leading); 164243"];
4447 [label="return 'unmanaged'; 164244"];
4448 [label="FullWidth = this.Text.Length; 164245"];
4449 [label="FullWidth 164246"];
4450 [label="this.AdjustFlagsAndWidth(trailing); 164247"];
4451 [label="return 'unmanaged'; 164248"];
4452 [label="FullWidth = this.Text.Length; 164249"];
4453 [label="FullWidth 164250"];
4454 [label="this.AdjustFlagsAndWidth(trailing); 164251"];
4455 [label="return 'elif'; 164252"];
4456 [label="FullWidth = this.Text.Length; 164253"];
4457 [label="FullWidth 164254"];
4458 [label="return 'elif'; 164255"];
4459 [label="FullWidth = this.Text.Length; 164256"];
4460 [label="FullWidth 164257"];
4461 [label="this.AdjustFlagsAndWidth(leading); 164258"];
4462 [label="return 'elif'; 164259"];
4463 [label="FullWidth = this.Text.Length; 164260"];
4464 [label="FullWidth 164261"];
4465 [label="this.AdjustFlagsAndWidth(trailing); 164262"];
4466 [label="return 'elif'; 164263"];
4467 [label="FullWidth = this.Text.Length; 164264"];
4468 [label="FullWidth 164265"];
4469 [label="this.AdjustFlagsAndWidth(trailing); 164266"];
4470 [label="return 'endif'; 164267"];
4471 [label="FullWidth = this.Text.Length; 164268"];
4472 [label="FullWidth 164269"];
4473 [label="return 'endif'; 164270"];
4474 [label="FullWidth = this.Text.Length; 164271"];
4475 [label="FullWidth 164272"];
4476 [label="this.AdjustFlagsAndWidth(leading); 164273"];
4477 [label="return 'endif'; 164274"];
4478 [label="FullWidth = this.Text.Length; 164275"];
4479 [label="FullWidth 164276"];
4480 [label="this.AdjustFlagsAndWidth(trailing); 164277"];
4481 [label="return 'endif'; 164278"];
4482 [label="FullWidth = this.Text.Length; 164279"];
4483 [label="FullWidth 164280"];
4484 [label="this.AdjustFlagsAndWidth(trailing); 164281"];
4485 [label="return 'region'; 164282"];
4486 [label="FullWidth = this.Text.Length; 164283"];
4487 [label="FullWidth 164284"];
4488 [label="return 'region'; 164285"];
4489 [label="FullWidth = this.Text.Length; 164286"];
4490 [label="FullWidth 164287"];
4491 [label="this.AdjustFlagsAndWidth(leading); 164288"];
4492 [label="return 'region'; 164289"];
4493 [label="FullWidth = this.Text.Length; 164290"];
4494 [label="FullWidth 164291"];
4495 [label="this.AdjustFlagsAndWidth(trailing); 164292"];
4496 [label="return 'region'; 164293"];
4497 [label="FullWidth = this.Text.Length; 164294"];
4498 [label="FullWidth 164295"];
4499 [label="this.AdjustFlagsAndWidth(trailing); 164296"];
4500 [label="return 'endregion'; 164297"];
4501 [label="FullWidth = this.Text.Length; 164298"];
4502 [label="FullWidth 164299"];
4503 [label="return 'endregion'; 164300"];
4504 [label="FullWidth = this.Text.Length; 164301"];
4505 [label="FullWidth 164302"];
4506 [label="this.AdjustFlagsAndWidth(leading); 164303"];
4507 [label="return 'endregion'; 164304"];
4508 [label="FullWidth = this.Text.Length; 164305"];
4509 [label="FullWidth 164306"];
4510 [label="this.AdjustFlagsAndWidth(trailing); 164307"];
4511 [label="return 'endregion'; 164308"];
4512 [label="FullWidth = this.Text.Length; 164309"];
4513 [label="FullWidth 164310"];
4514 [label="this.AdjustFlagsAndWidth(trailing); 164311"];
4515 [label="return 'define'; 164312"];
4516 [label="FullWidth = this.Text.Length; 164313"];
4517 [label="FullWidth 164314"];
4518 [label="return 'define'; 164315"];
4519 [label="FullWidth = this.Text.Length; 164316"];
4520 [label="FullWidth 164317"];
4521 [label="this.AdjustFlagsAndWidth(leading); 164318"];
4522 [label="return 'define'; 164319"];
4523 [label="FullWidth = this.Text.Length; 164320"];
4524 [label="FullWidth 164321"];
4525 [label="this.AdjustFlagsAndWidth(trailing); 164322"];
4526 [label="return 'define'; 164323"];
4527 [label="FullWidth = this.Text.Length; 164324"];
4528 [label="FullWidth 164325"];
4529 [label="this.AdjustFlagsAndWidth(trailing); 164326"];
4530 [label="return 'undef'; 164327"];
4531 [label="FullWidth = this.Text.Length; 164328"];
4532 [label="FullWidth 164329"];
4533 [label="return 'undef'; 164330"];
4534 [label="FullWidth = this.Text.Length; 164331"];
4535 [label="FullWidth 164332"];
4536 [label="this.AdjustFlagsAndWidth(leading); 164333"];
4537 [label="return 'undef'; 164334"];
4538 [label="FullWidth = this.Text.Length; 164335"];
4539 [label="FullWidth 164336"];
4540 [label="this.AdjustFlagsAndWidth(trailing); 164337"];
4541 [label="return 'undef'; 164338"];
4542 [label="FullWidth = this.Text.Length; 164339"];
4543 [label="FullWidth 164340"];
4544 [label="this.AdjustFlagsAndWidth(trailing); 164341"];
4545 [label="return 'warning'; 164342"];
4546 [label="FullWidth = this.Text.Length; 164343"];
4547 [label="FullWidth 164344"];
4548 [label="return 'warning'; 164345"];
4549 [label="FullWidth = this.Text.Length; 164346"];
4550 [label="FullWidth 164347"];
4551 [label="this.AdjustFlagsAndWidth(leading); 164348"];
4552 [label="return 'warning'; 164349"];
4553 [label="FullWidth = this.Text.Length; 164350"];
4554 [label="FullWidth 164351"];
4555 [label="this.AdjustFlagsAndWidth(trailing); 164352"];
4556 [label="return 'warning'; 164353"];
4557 [label="FullWidth = this.Text.Length; 164354"];
4558 [label="FullWidth 164355"];
4559 [label="this.AdjustFlagsAndWidth(trailing); 164356"];
4560 [label="return 'error'; 164357"];
4561 [label="FullWidth = this.Text.Length; 164358"];
4562 [label="FullWidth 164359"];
4563 [label="return 'error'; 164360"];
4564 [label="FullWidth = this.Text.Length; 164361"];
4565 [label="FullWidth 164362"];
4566 [label="this.AdjustFlagsAndWidth(leading); 164363"];
4567 [label="return 'error'; 164364"];
4568 [label="FullWidth = this.Text.Length; 164365"];
4569 [label="FullWidth 164366"];
4570 [label="this.AdjustFlagsAndWidth(trailing); 164367"];
4571 [label="return 'error'; 164368"];
4572 [label="FullWidth = this.Text.Length; 164369"];
4573 [label="FullWidth 164370"];
4574 [label="this.AdjustFlagsAndWidth(trailing); 164371"];
4575 [label="return 'line'; 164372"];
4576 [label="FullWidth = this.Text.Length; 164373"];
4577 [label="FullWidth 164374"];
4578 [label="return 'line'; 164375"];
4579 [label="FullWidth = this.Text.Length; 164376"];
4580 [label="FullWidth 164377"];
4581 [label="this.AdjustFlagsAndWidth(leading); 164378"];
4582 [label="return 'line'; 164379"];
4583 [label="FullWidth = this.Text.Length; 164380"];
4584 [label="FullWidth 164381"];
4585 [label="this.AdjustFlagsAndWidth(trailing); 164382"];
4586 [label="return 'line'; 164383"];
4587 [label="FullWidth = this.Text.Length; 164384"];
4588 [label="FullWidth 164385"];
4589 [label="this.AdjustFlagsAndWidth(trailing); 164386"];
4590 [label="return 'pragma'; 164387"];
4591 [label="FullWidth = this.Text.Length; 164388"];
4592 [label="FullWidth 164389"];
4593 [label="return 'pragma'; 164390"];
4594 [label="FullWidth = this.Text.Length; 164391"];
4595 [label="FullWidth 164392"];
4596 [label="this.AdjustFlagsAndWidth(leading); 164393"];
4597 [label="return 'pragma'; 164394"];
4598 [label="FullWidth = this.Text.Length; 164395"];
4599 [label="FullWidth 164396"];
4600 [label="this.AdjustFlagsAndWidth(trailing); 164397"];
4601 [label="return 'pragma'; 164398"];
4602 [label="FullWidth = this.Text.Length; 164399"];
4603 [label="FullWidth 164400"];
4604 [label="this.AdjustFlagsAndWidth(trailing); 164401"];
4605 [label="return 'hidden'; 164402"];
4606 [label="FullWidth = this.Text.Length; 164403"];
4607 [label="FullWidth 164404"];
4608 [label="return 'hidden'; 164405"];
4609 [label="FullWidth = this.Text.Length; 164406"];
4610 [label="FullWidth 164407"];
4611 [label="this.AdjustFlagsAndWidth(leading); 164408"];
4612 [label="return 'hidden'; 164409"];
4613 [label="FullWidth = this.Text.Length; 164410"];
4614 [label="FullWidth 164411"];
4615 [label="this.AdjustFlagsAndWidth(trailing); 164412"];
4616 [label="return 'hidden'; 164413"];
4617 [label="FullWidth = this.Text.Length; 164414"];
4618 [label="FullWidth 164415"];
4619 [label="this.AdjustFlagsAndWidth(trailing); 164416"];
4620 [label="return 'checksum'; 164417"];
4621 [label="FullWidth = this.Text.Length; 164418"];
4622 [label="FullWidth 164419"];
4623 [label="return 'checksum'; 164420"];
4624 [label="FullWidth = this.Text.Length; 164421"];
4625 [label="FullWidth 164422"];
4626 [label="this.AdjustFlagsAndWidth(leading); 164423"];
4627 [label="return 'checksum'; 164424"];
4628 [label="FullWidth = this.Text.Length; 164425"];
4629 [label="FullWidth 164426"];
4630 [label="this.AdjustFlagsAndWidth(trailing); 164427"];
4631 [label="return 'checksum'; 164428"];
4632 [label="FullWidth = this.Text.Length; 164429"];
4633 [label="FullWidth 164430"];
4634 [label="this.AdjustFlagsAndWidth(trailing); 164431"];
4635 [label="return 'disable'; 164432"];
4636 [label="FullWidth = this.Text.Length; 164433"];
4637 [label="FullWidth 164434"];
4638 [label="return 'disable'; 164435"];
4639 [label="FullWidth = this.Text.Length; 164436"];
4640 [label="FullWidth 164437"];
4641 [label="this.AdjustFlagsAndWidth(leading); 164438"];
4642 [label="return 'disable'; 164439"];
4643 [label="FullWidth = this.Text.Length; 164440"];
4644 [label="FullWidth 164441"];
4645 [label="this.AdjustFlagsAndWidth(trailing); 164442"];
4646 [label="return 'disable'; 164443"];
4647 [label="FullWidth = this.Text.Length; 164444"];
4648 [label="FullWidth 164445"];
4649 [label="this.AdjustFlagsAndWidth(trailing); 164446"];
4650 [label="return 'restore'; 164447"];
4651 [label="FullWidth = this.Text.Length; 164448"];
4652 [label="FullWidth 164449"];
4653 [label="return 'restore'; 164450"];
4654 [label="FullWidth = this.Text.Length; 164451"];
4655 [label="FullWidth 164452"];
4656 [label="this.AdjustFlagsAndWidth(leading); 164453"];
4657 [label="return 'restore'; 164454"];
4658 [label="FullWidth = this.Text.Length; 164455"];
4659 [label="FullWidth 164456"];
4660 [label="this.AdjustFlagsAndWidth(trailing); 164457"];
4661 [label="return 'restore'; 164458"];
4662 [label="FullWidth = this.Text.Length; 164459"];
4663 [label="FullWidth 164460"];
4664 [label="this.AdjustFlagsAndWidth(trailing); 164461"];
4665 [label="return 'r'; 164462"];
4666 [label="FullWidth = this.Text.Length; 164463"];
4667 [label="FullWidth 164464"];
4668 [label="return 'r'; 164465"];
4669 [label="FullWidth = this.Text.Length; 164466"];
4670 [label="FullWidth 164467"];
4671 [label="this.AdjustFlagsAndWidth(leading); 164468"];
4672 [label="return 'r'; 164469"];
4673 [label="FullWidth = this.Text.Length; 164470"];
4674 [label="FullWidth 164471"];
4675 [label="this.AdjustFlagsAndWidth(trailing); 164472"];
4676 [label="return 'r'; 164473"];
4677 [label="FullWidth = this.Text.Length; 164474"];
4678 [label="FullWidth 164475"];
4679 [label="this.AdjustFlagsAndWidth(trailing); 164476"];
4680 [label="return '$\\''; 164477"];
4681 [label="FullWidth = this.Text.Length; 164478"];
4682 [label="FullWidth 164479"];
4683 [label="return '$\\''; 164480"];
4684 [label="FullWidth = this.Text.Length; 164481"];
4685 [label="FullWidth 164482"];
4686 [label="this.AdjustFlagsAndWidth(leading); 164483"];
4687 [label="return '$\\''; 164484"];
4688 [label="FullWidth = this.Text.Length; 164485"];
4689 [label="FullWidth 164486"];
4690 [label="this.AdjustFlagsAndWidth(trailing); 164487"];
4691 [label="return '$\\''; 164488"];
4692 [label="FullWidth = this.Text.Length; 164489"];
4693 [label="FullWidth 164490"];
4694 [label="this.AdjustFlagsAndWidth(trailing); 164491"];
4695 [label="return '\\''; 164492"];
4696 [label="FullWidth = this.Text.Length; 164493"];
4697 [label="FullWidth 164494"];
4698 [label="return '\\''; 164495"];
4699 [label="FullWidth = this.Text.Length; 164496"];
4700 [label="FullWidth 164497"];
4701 [label="this.AdjustFlagsAndWidth(leading); 164498"];
4702 [label="return '\\''; 164499"];
4703 [label="FullWidth = this.Text.Length; 164500"];
4704 [label="FullWidth 164501"];
4705 [label="this.AdjustFlagsAndWidth(trailing); 164502"];
4706 [label="return '\\''; 164503"];
4707 [label="FullWidth = this.Text.Length; 164504"];
4708 [label="FullWidth 164505"];
4709 [label="this.AdjustFlagsAndWidth(trailing); 164506"];
4710 [label="return '$@\\''; 164507"];
4711 [label="FullWidth = this.Text.Length; 164508"];
4712 [label="FullWidth 164509"];
4713 [label="return '$@\\''; 164510"];
4714 [label="FullWidth = this.Text.Length; 164511"];
4715 [label="FullWidth 164512"];
4716 [label="this.AdjustFlagsAndWidth(leading); 164513"];
4717 [label="return '$@\\''; 164514"];
4718 [label="FullWidth = this.Text.Length; 164515"];
4719 [label="FullWidth 164516"];
4720 [label="this.AdjustFlagsAndWidth(trailing); 164517"];
4721 [label="return '$@\\''; 164518"];
4722 [label="FullWidth = this.Text.Length; 164519"];
4723 [label="FullWidth 164520"];
4724 [label="this.AdjustFlagsAndWidth(trailing); 164521"];
4725 [label="return 'load'; 164522"];
4726 [label="FullWidth = this.Text.Length; 164523"];
4727 [label="FullWidth 164524"];
4728 [label="return 'load'; 164525"];
4729 [label="FullWidth = this.Text.Length; 164526"];
4730 [label="FullWidth 164527"];
4731 [label="this.AdjustFlagsAndWidth(leading); 164528"];
4732 [label="return 'load'; 164529"];
4733 [label="FullWidth = this.Text.Length; 164530"];
4734 [label="FullWidth 164531"];
4735 [label="this.AdjustFlagsAndWidth(trailing); 164532"];
4736 [label="return 'load'; 164533"];
4737 [label="FullWidth = this.Text.Length; 164534"];
4738 [label="FullWidth 164535"];
4739 [label="this.AdjustFlagsAndWidth(trailing); 164536"];
4740 [label="return 'nullable'; 164537"];
4741 [label="FullWidth = this.Text.Length; 164538"];
4742 [label="FullWidth 164539"];
4743 [label="return 'nullable'; 164540"];
4744 [label="FullWidth = this.Text.Length; 164541"];
4745 [label="FullWidth 164542"];
4746 [label="this.AdjustFlagsAndWidth(leading); 164543"];
4747 [label="return 'nullable'; 164544"];
4748 [label="FullWidth = this.Text.Length; 164545"];
4749 [label="FullWidth 164546"];
4750 [label="this.AdjustFlagsAndWidth(trailing); 164547"];
4751 [label="return 'nullable'; 164548"];
4752 [label="FullWidth = this.Text.Length; 164549"];
4753 [label="FullWidth 164550"];
4754 [label="this.AdjustFlagsAndWidth(trailing); 164551"];
4755 [label="return 'enable'; 164552"];
4756 [label="FullWidth = this.Text.Length; 164553"];
4757 [label="FullWidth 164554"];
4758 [label="return 'enable'; 164555"];
4759 [label="FullWidth = this.Text.Length; 164556"];
4760 [label="FullWidth 164557"];
4761 [label="this.AdjustFlagsAndWidth(leading); 164558"];
4762 [label="return 'enable'; 164559"];
4763 [label="FullWidth = this.Text.Length; 164560"];
4764 [label="FullWidth 164561"];
4765 [label="this.AdjustFlagsAndWidth(trailing); 164562"];
4766 [label="return 'enable'; 164563"];
4767 [label="FullWidth = this.Text.Length; 164564"];
4768 [label="FullWidth 164565"];
4769 [label="this.AdjustFlagsAndWidth(trailing); 164566"];
4770 [label="return 'warnings'; 164567"];
4771 [label="FullWidth = this.Text.Length; 164568"];
4772 [label="FullWidth 164569"];
4773 [label="return 'warnings'; 164570"];
4774 [label="FullWidth = this.Text.Length; 164571"];
4775 [label="FullWidth 164572"];
4776 [label="this.AdjustFlagsAndWidth(leading); 164573"];
4777 [label="return 'warnings'; 164574"];
4778 [label="FullWidth = this.Text.Length; 164575"];
4779 [label="FullWidth 164576"];
4780 [label="this.AdjustFlagsAndWidth(trailing); 164577"];
4781 [label="return 'warnings'; 164578"];
4782 [label="FullWidth = this.Text.Length; 164579"];
4783 [label="FullWidth 164580"];
4784 [label="this.AdjustFlagsAndWidth(trailing); 164581"];
4785 [label="return 'annotations'; 164582"];
4786 [label="FullWidth = this.Text.Length; 164583"];
4787 [label="FullWidth 164584"];
4788 [label="return 'annotations'; 164585"];
4789 [label="FullWidth = this.Text.Length; 164586"];
4790 [label="FullWidth 164587"];
4791 [label="this.AdjustFlagsAndWidth(leading); 164588"];
4792 [label="return 'annotations'; 164589"];
4793 [label="FullWidth = this.Text.Length; 164590"];
4794 [label="FullWidth 164591"];
4795 [label="this.AdjustFlagsAndWidth(trailing); 164592"];
4796 [label="return 'annotations'; 164593"];
4797 [label="FullWidth = this.Text.Length; 164594"];
4798 [label="FullWidth 164595"];
4799 [label="this.AdjustFlagsAndWidth(trailing); 164596"];
4800 [label="return 'var'; 164597"];
4801 [label="FullWidth = this.Text.Length; 164598"];
4802 [label="FullWidth 164599"];
4803 [label="return 'var'; 164600"];
4804 [label="FullWidth = this.Text.Length; 164601"];
4805 [label="FullWidth 164602"];
4806 [label="this.AdjustFlagsAndWidth(leading); 164603"];
4807 [label="return 'var'; 164604"];
4808 [label="FullWidth = this.Text.Length; 164605"];
4809 [label="FullWidth 164606"];
4810 [label="this.AdjustFlagsAndWidth(trailing); 164607"];
4811 [label="return 'var'; 164608"];
4812 [label="FullWidth = this.Text.Length; 164609"];
4813 [label="FullWidth 164610"];
4814 [label="this.AdjustFlagsAndWidth(trailing); 164611"];
4815 [label="return '_'; 164612"];
4816 [label="FullWidth = this.Text.Length; 164613"];
4817 [label="FullWidth 164614"];
4818 [label="return '_'; 164615"];
4819 [label="FullWidth = this.Text.Length; 164616"];
4820 [label="FullWidth 164617"];
4821 [label="this.AdjustFlagsAndWidth(leading); 164618"];
4822 [label="return '_'; 164619"];
4823 [label="FullWidth = this.Text.Length; 164620"];
4824 [label="FullWidth 164621"];
4825 [label="this.AdjustFlagsAndWidth(trailing); 164622"];
4826 [label="return '_'; 164623"];
4827 [label="FullWidth = this.Text.Length; 164624"];
4828 [label="FullWidth 164625"];
4829 [label="this.AdjustFlagsAndWidth(trailing); 164626"];
4830 [label="return SyntaxToken.Create(kind, leading, trailing); 164627"];
4831 [label="return SyntaxToken.Create(kind, leading, trailing); 164628"];
4832 [label="return SyntaxToken.Create(kind, leading, trailing); 164629"];
4833 [label="SyntaxToken.Create(kind, leading, trailing) 164630"];
4834 [label="param Create(SyntaxKind kind) 164631"];
4835 [label="param Create(GreenNode leading) 164632"];
4836 [label="param Create(GreenNode trailing) 164633"];
4837 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 164634"];
4838 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 164635"];
4839 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 164636"];
4840 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 164637"];
4841 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 164638"];
4842 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 164639"];
4843 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 164640"];
4844 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 164641"];
4845 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 164642"];
4846 [label="return token; 164643"];
4847 [label="this.AddLexedToken(token); 164644"];
4848 [label="this.AddLexedToken(token) 164645"];
4849 [label="param AddLexedToken(SyntaxToken token) 164646"];
4850 [label="param AddLexedToken(this) 164647"];
4851 [label="Debug.Assert(token != null); 164648"];
4852 [label="Debug.Assert(token != null); 164649"];
4853 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 164650"];
4854 [label="_lexedTokens[_tokenCount].Value = token; 164651"];
4855 [label="_lexedTokens[_tokenCount].Value 164652"];
4856 [label="_tokenCount 164653"];
4857 [label="this.AddLexedToken(token); 164654"];
4858 [label="token.Kind 164655"];
4859 [label="get { return (SyntaxKind)this.RawKind; } 164656"];
4860 [label="return (SyntaxKind)this.RawKind; 164657"];
4861 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 164658"];
4862 [label="TextWindow.Start(); 164659"];
4863 [label="get\n            {\n                return _lexemeStart;\n            } 164660"];
4864 [label="return _lexemeStart; 164661"];
4865 [label="param LookupToken(char[] textBuffer) 164662"];
4866 [label="param LookupToken(int keyStart) 164663"];
4867 [label="param LookupToken(int keyLength) 164664"];
4868 [label="param LookupToken(int hashCode) 164665"];
4869 [label="param LookupToken(Func<SyntaxToken> createTokenFunction) 164666"];
4870 [label="param LookupToken(this) 164667"];
4871 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 164668"];
4872 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 164669"];
4873 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 164670"];
4874 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 164671"];
4875 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 164672"];
4876 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 164673"];
4877 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 164674"];
4878 [label="value = createTokenFunction(); 164675"];
4879 [label="value = createTokenFunction(); 164676"];
4880 [label="param CreateQuickToken(this) 164677"];
4881 [label="TextWindow.Width 164678"];
4882 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 164679"];
4883 [label="var quickWidth = TextWindow.Width; 164680"];
4884 [label="TextWindow.LexemeStartPosition 164681"];
4885 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 164682"];
4886 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 164683"];
4887 [label="TextWindow.Reset(TextWindow.LexemeStartPosition) 164684"];
4888 [label="param Reset(int position) 164685"];
4889 [label="param Reset(this) 164686"];
4890 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 164687"];
4891 [label="this.LexSyntaxToken() 164688"];
4892 [label="param LexSyntaxToken(this) 164689"];
4893 [label="_leadingTriviaCache.Clear(); 164690"];
4894 [label="TextWindow.Position 164691"];
4895 [label="get\n            {\n                return _basis + _offset;\n            } 164692"];
4896 [label="param LexSyntaxTrivia(bool afterFirstToken) 164693"];
4897 [label="param LexSyntaxTrivia(bool isTrailing) 164694"];
4898 [label="bool onlyWhitespaceOnLine = !isTrailing; 164695"];
4899 [label="TextWindow.Start(); 164696"];
4900 [label="this.Start(); 164697"];
4901 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 164698"];
4902 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 164699"];
4903 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 164700"];
4904 [label="return; 164701"];
4905 [label="this.Start(); 164702"];
4906 [label="var errors = this.GetErrors(GetFullWidth(leading)); 164703"];
4907 [label="GetFullWidth(leading) 164704"];
4908 [label="param GetFullWidth(SyntaxListBuilder builder) 164705"];
4909 [label="int width = 0; 164706"];
4910 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 164707"];
4911 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 164708"];
4912 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 164709"];
4913 [label="return width; 164710"];
4914 [label="var errors = this.GetErrors(GetFullWidth(leading)); 164711"];
4915 [label="this.GetErrors(GetFullWidth(leading)) 164712"];
4916 [label="param GetErrors(int leadingTriviaWidth) 164713"];
4917 [label="param GetErrors(this) 164714"];
4918 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 164715"];
4919 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 164716"];
4920 [label="return null; 164717"];
4921 [label="var errors = this.GetErrors(GetFullWidth(leading)); 164718"];
4922 [label="param LexSyntaxTrivia(bool afterFirstToken) 164719"];
4923 [label="param Create(ref TokenInfo info) 164720"];
4924 [label="param Create(SyntaxDiagnosticInfo[] errors) 164721"];
4925 [label="param Create(this) 164722"];
4926 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 164723"];
4927 [label="SyntaxToken token; 164724"];
4928 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 164725"];
4929 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 164726"];
4930 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 164727"];
4931 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 164728"];
4932 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 164729"];
4933 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 164730"];
4934 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 164731"];
4935 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 164732"];
4936 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 164733"];
4937 [label="param Token(GreenNode leading) 164734"];
4938 [label="param Token(SyntaxKind kind) 164735"];
4939 [label="param Token(GreenNode trailing) 164736"];
4940 [label="return SyntaxToken.Create(kind, leading, trailing); 164737"];
4941 [label="return SyntaxToken.Create(kind, leading, trailing); 164738"];
4942 [label="return SyntaxToken.Create(kind, leading, trailing); 164739"];
4943 [label="SyntaxToken.Create(kind, leading, trailing) 164740"];
4944 [label="param Create(SyntaxKind kind) 164741"];
4945 [label="param Create(GreenNode leading) 164742"];
4946 [label="param Create(GreenNode trailing) 164743"];
4947 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 164744"];
4948 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 164745"];
4949 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 164746"];
4950 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 164747"];
4951 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 164748"];
4952 [label="return s_tokensWithNoTrivia[(int)kind].Value; 164749"];
4953 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 164750"];
4954 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 164751"];
4955 [label="return token; 164752"];
4956 [label="var token = this.LexSyntaxToken(); 164753"];
4957 [label="Debug.Assert(quickWidth == token.FullWidth); 164754"];
4958 [label="return token; 164755"];
4959 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 164756"];
4960 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 164757"];
4961 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 164758"];
4962 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 164759"];
4963 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 164760"];
4964 [label="return value; 164761"];
4965 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 164762"];
4966 [label="this.AddLexedToken(token); 164763"];
4967 [label="param AddLexedToken(SyntaxToken token) 164764"];
4968 [label="Debug.Assert(token != null); 164765"];
4969 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 164766"];
4970 [label="_lexedTokens[_tokenCount].Value = token; 164767"];
4971 [label="_lexedTokens[_tokenCount].Value 164768"];
4972 [label="get { return (SyntaxKind)this.RawKind; } 164769"];
4973 [label="return (SyntaxKind)this.RawKind; 164770"];
4974 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 164771"];
4975 [label="TextWindow.Start(); 164772"];
4976 [label="TextWindow.Width 164773"];
4977 [label="var quickWidth = TextWindow.Width; 164774"];
4978 [label="TextWindow.Position 164775"];
4979 [label="param LexSyntaxTrivia(bool afterFirstToken) 164776"];
4980 [label="param LexSyntaxTrivia(bool isTrailing) 164777"];
4981 [label="bool onlyWhitespaceOnLine = !isTrailing; 164778"];
4982 [label="this.Start(); 164779"];
4983 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 164780"];
4984 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 164781"];
4985 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 164782"];
4986 [label="return; 164783"];
4987 [label="this.Start(); 164784"];
4988 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 164785"];
4989 [label="param TryGetKeywordKind(out SyntaxKind kind) 164786"];
4990 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 164787"];
4991 [label="return SyntaxKind.None; 164788"];
4992 [label="param GetContextualKeywordKind(string text) 164789"];
4993 [label="switch (text)\n            {\n                case 'yield':\n                    return SyntaxKind.YieldKeyword;\n                case 'partial':\n                    return SyntaxKind.PartialKeyword;\n                case 'from':\n                    return SyntaxKind.FromKeyword;\n                case 'group':\n                    return SyntaxKind.GroupKeyword;\n                case 'join':\n                    return SyntaxKind.JoinKeyword;\n                case 'into':\n                    return SyntaxKind.IntoKeyword;\n                case 'let':\n                    return SyntaxKind.LetKeyword;\n                case 'by':\n                    return SyntaxKind.ByKeyword;\n                case 'where':\n                    return SyntaxKind.WhereKeyword;\n                case 'select':\n                    return SyntaxKind.SelectKeyword;\n                case 'get':\n                    return SyntaxKind.GetKeyword;\n                case 'set':\n                    return SyntaxKind.SetKeyword;\n                case 'add':\n                    return SyntaxKind.AddKeyword;\n                case 'remove':\n                    return SyntaxKind.RemoveKeyword;\n                case 'orderby':\n                    return SyntaxKind.OrderByKeyword;\n                case 'alias':\n                    return SyntaxKind.AliasKeyword;\n                case 'on':\n                    return SyntaxKind.OnKeyword;\n                case 'equals':\n                    return SyntaxKind.EqualsKeyword;\n                case 'ascending':\n                    return SyntaxKind.AscendingKeyword;\n                case 'descending':\n                    return SyntaxKind.DescendingKeyword;\n                case 'assembly':\n                    return SyntaxKind.AssemblyKeyword;\n                case 'module':\n                    return SyntaxKind.ModuleKeyword;\n                case 'type':\n                    return SyntaxKind.TypeKeyword;\n                case 'field':\n                    return SyntaxKind.FieldKeyword;\n                case 'method':\n                    return SyntaxKind.MethodKeyword;\n                case 'param':\n                    return SyntaxKind.ParamKeyword;\n                case 'property':\n                    return SyntaxKind.PropertyKeyword;\n                case 'typevar':\n                    return SyntaxKind.TypeVarKeyword;\n                case 'global':\n                    return SyntaxKind.GlobalKeyword;\n                case 'async':\n                    return SyntaxKind.AsyncKeyword;\n                case 'await':\n                    return SyntaxKind.AwaitKeyword;\n                case 'when':\n                    return SyntaxKind.WhenKeyword;\n                case 'nameof':\n                    return SyntaxKind.NameOfKeyword;\n                case '_':\n                    return SyntaxKind.UnderscoreToken;\n                case 'var':\n                    return SyntaxKind.VarKeyword;\n                case 'and':\n                    return SyntaxKind.AndKeyword;\n                case 'or':\n                    return SyntaxKind.OrKeyword;\n                case 'not':\n                    return SyntaxKind.NotKeyword;\n                case 'data':\n                    return SyntaxKind.DataKeyword;\n                case 'with':\n                    return SyntaxKind.WithKeyword;\n                case 'init':\n                    return SyntaxKind.InitKeyword;\n                case 'record':\n                    return SyntaxKind.RecordKeyword;\n                case 'managed':\n                    return SyntaxKind.ManagedKeyword;\n                case 'unmanaged':\n                    return SyntaxKind.UnmanagedKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 164790"];
4994 [label="return SyntaxKind.None; 164791"];
4995 [label="kind = _keywordKindMap.GetOrMakeValue(key); 164792"];
4996 [label="return kind != SyntaxKind.None; 164793"];
4997 [label="info.Kind 164794"];
4998 [label="info.ContextualKind 164795"];
4999 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 164796"];
5000 [label="this.ScanSyntaxToken(ref tokenInfo); 164797"];
5001 [label="var errors = this.GetErrors(GetFullWidth(leading)); 164798"];
5002 [label="GetFullWidth(leading) 164799"];
5003 [label="param GetFullWidth(SyntaxListBuilder builder) 164800"];
5004 [label="int width = 0; 164801"];
5005 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 164802"];
5006 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 164803"];
5007 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 164804"];
5008 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 164805"];
5009 [label="return width; 164806"];
5010 [label="var errors = this.GetErrors(GetFullWidth(leading)); 164807"];
5011 [label="this.GetErrors(GetFullWidth(leading)) 164808"];
5012 [label="param GetErrors(int leadingTriviaWidth) 164809"];
5013 [label="param GetErrors(this) 164810"];
5014 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 164811"];
5015 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 164812"];
5016 [label="return null; 164813"];
5017 [label="var errors = this.GetErrors(GetFullWidth(leading)); 164814"];
5018 [label="param LexSyntaxTrivia(bool afterFirstToken) 164815"];
5019 [label="param LexSyntaxTrivia(bool isTrailing) 164816"];
5020 [label="bool onlyWhitespaceOnLine = !isTrailing; 164817"];
5021 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 164818"];
5022 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 164819"];
5023 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 164820"];
5024 [label="return; 164821"];
5025 [label="param Create(SyntaxDiagnosticInfo[] errors) 164822"];
5026 [label="param Create(this) 164823"];
5027 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 164824"];
5028 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 164825"];
5029 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 164826"];
5030 [label="SyntaxToken token; 164827"];
5031 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 164828"];
5032 [label="SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode) 164829"];
5033 [label="param Identifier(SyntaxKind contextualKind) 164830"];
5034 [label="param Identifier(GreenNode leading) 164831"];
5035 [label="param Identifier(string text) 164832"];
5036 [label="param Identifier(string valueText) 164833"];
5037 [label="param Identifier(GreenNode trailing) 164834"];
5038 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 164835"];
5039 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 164836"];
5040 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 164837"];
5041 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 164838"];
5042 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 164839"];
5043 [label="SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing) 164840"];
5044 [label="param Identifier(SyntaxKind contextualKind) 164841"];
5045 [label="param Identifier(GreenNode leading) 164842"];
5046 [label="param Identifier(string text) 164843"];
5047 [label="param Identifier(string valueText) 164844"];
5048 [label="param Identifier(GreenNode trailing) 164845"];
5049 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 164846"];
5050 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 164847"];
5051 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 164848"];
5052 [label="return Identifier(leading, text, trailing); 164849"];
5053 [label="return Identifier(leading, text, trailing); 164850"];
5054 [label="return Identifier(leading, text, trailing); 164851"];
5055 [label="Identifier(leading, text, trailing) 164852"];
5056 [label="param Identifier(GreenNode leading) 164853"];
5057 [label="param Identifier(string text) 164854"];
5058 [label="param Identifier(GreenNode trailing) 164855"];
5059 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 164856"];
5060 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 164857"];
5061 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 164858"];
5062 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 164859"];
5063 [label="return Identifier(text); 164860"];
5064 [label="Identifier(text) 164861"];
5065 [label="param Identifier(string text) 164862"];
5066 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifier), r => new SyntaxIdentifier(r)); 164863"];
5067 [label="return new SyntaxIdentifier(text); 164864"];
5068 [label="return new SyntaxIdentifier(text); 164865"];
5069 [label="new SyntaxIdentifier(text) 164866"];
5070 [label="param SyntaxIdentifier(string text) 164867"];
5071 [label="param SyntaxIdentifier(this) 164868"];
5072 [label="SyntaxKind.IdentifierToken 164869"];
5073 [label="text 164870"];
5074 [label="param SyntaxIdentifier(this) 164871"];
5075 [label="param SyntaxToken(SyntaxKind kind) 164872"];
5076 [label="param SyntaxToken(int fullWidth) 164873"];
5077 [label="param SyntaxToken(this) 164874"];
5078 [label="kind 164875"];
5079 [label="fullWidth 164876"];
5080 [label="param SyntaxToken(this) 164877"];
5081 [label="param CSharpSyntaxNode(SyntaxKind kind) 164878"];
5082 [label="param CSharpSyntaxNode(int fullWidth) 164879"];
5083 [label="param CSharpSyntaxNode(this) 164880"];
5084 [label="kind 164881"];
5085 [label="fullWidth 164882"];
5086 [label="param CSharpSyntaxNode(this) 164883"];
5087 [label="param CSharpSyntaxNode(this) 164884"];
5088 [label="GreenStats.NoteGreen(this); 164885"];
5089 [label="GreenStats.NoteGreen(this); 164886"];
5090 [label="this.flags |= NodeFlags.IsNotMissing; 164887"];
5091 [label="this.flags 164888"];
5092 [label="TextField 164889"];
5093 [label="this.TextField 164890"];
5094 [label="return Identifier(text); 164891"];
5095 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 164892"];
5096 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 164893"];
5097 [label="Debug.Assert(quickWidth == token.FullWidth); 164894"];
5098 [label="value = createTokenFunction(); 164895"];
5099 [label="this.AddLexedToken(token); 164896"];
5100 [label="param AddLexedToken(SyntaxToken token) 164897"];
5101 [label="Debug.Assert(token != null); 164898"];
5102 [label="_lexedTokens[_tokenCount].Value 164899"];
5103 [label="get { return (SyntaxKind)this.RawKind; } 164900"];
5104 [label="return (SyntaxKind)this.RawKind; 164901"];
5105 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 164902"];
5106 [label="TextWindow.Start(); 164903"];
5107 [label="TextWindow.Width 164904"];
5108 [label="var quickWidth = TextWindow.Width; 164905"];
5109 [label="param LexSyntaxTrivia(bool afterFirstToken) 164906"];
5110 [label="param LexSyntaxTrivia(bool isTrailing) 164907"];
5111 [label="bool onlyWhitespaceOnLine = !isTrailing; 164908"];
5112 [label="this.Start(); 164909"];
5113 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 164910"];
5114 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 164911"];
5115 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 164912"];
5116 [label="return; 164913"];
5117 [label="this.Start(); 164914"];
5118 [label="var errors = this.GetErrors(GetFullWidth(leading)); 164915"];
5119 [label="GetFullWidth(leading) 164916"];
5120 [label="param GetFullWidth(SyntaxListBuilder builder) 164917"];
5121 [label="int width = 0; 164918"];
5122 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 164919"];
5123 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 164920"];
5124 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 164921"];
5125 [label="return width; 164922"];
5126 [label="var errors = this.GetErrors(GetFullWidth(leading)); 164923"];
5127 [label="this.GetErrors(GetFullWidth(leading)) 164924"];
5128 [label="param GetErrors(int leadingTriviaWidth) 164925"];
5129 [label="param GetErrors(this) 164926"];
5130 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 164927"];
5131 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 164928"];
5132 [label="return null; 164929"];
5133 [label="var errors = this.GetErrors(GetFullWidth(leading)); 164930"];
5134 [label="param AddTrivia(this) 164931"];
5135 [label="this.HasErrors 164932"];
5136 [label="get { return _errors != null; } 164933"];
5137 [label="return _errors != null; 164934"];
5138 [label="return _errors != null; 164935"];
5139 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 164936"];
5140 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 164937"];
5141 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 164938"];
5142 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 164939"];
5143 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 164940"];
5144 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 164941"];
5145 [label="return; 164942"];
5146 [label="param Create(SyntaxDiagnosticInfo[] errors) 164943"];
5147 [label="param Create(this) 164944"];
5148 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 164945"];
5149 [label="SyntaxToken token; 164946"];
5150 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 164947"];
5151 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 164948"];
5152 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 164949"];
5153 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 164950"];
5154 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 164951"];
5155 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 164952"];
5156 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 164953"];
5157 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 164954"];
5158 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 164955"];
5159 [label="Debug.Assert(quickWidth == token.FullWidth); 164956"];
5160 [label="this.AddLexedToken(token); 164957"];
5161 [label="param AddLexedToken(SyntaxToken token) 164958"];
5162 [label="Debug.Assert(token != null); 164959"];
5163 [label="_lexedTokens[_tokenCount].Value 164960"];
5164 [label="get { return (SyntaxKind)this.RawKind; } 164961"];
5165 [label="return (SyntaxKind)this.RawKind; 164962"];
5166 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 164963"];
5167 [label="TextWindow.Start(); 164964"];
5168 [label="var quickWidth = TextWindow.Width; 164965"];
5169 [label="param LexSyntaxTrivia(bool afterFirstToken) 164966"];
5170 [label="param LexSyntaxTrivia(bool isTrailing) 164967"];
5171 [label="bool onlyWhitespaceOnLine = !isTrailing; 164968"];
5172 [label="this.Start(); 164969"];
5173 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 164970"];
5174 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 164971"];
5175 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 164972"];
5176 [label="return; 164973"];
5177 [label="this.Start(); 164974"];
5178 [label="var errors = this.GetErrors(GetFullWidth(leading)); 164975"];
5179 [label="GetFullWidth(leading) 164976"];
5180 [label="param GetFullWidth(SyntaxListBuilder builder) 164977"];
5181 [label="int width = 0; 164978"];
5182 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 164979"];
5183 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 164980"];
5184 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 164981"];
5185 [label="return width; 164982"];
5186 [label="var errors = this.GetErrors(GetFullWidth(leading)); 164983"];
5187 [label="this.GetErrors(GetFullWidth(leading)) 164984"];
5188 [label="param GetErrors(int leadingTriviaWidth) 164985"];
5189 [label="param GetErrors(this) 164986"];
5190 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 164987"];
5191 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 164988"];
5192 [label="return null; 164989"];
5193 [label="var errors = this.GetErrors(GetFullWidth(leading)); 164990"];
5194 [label="param AddTrivia(this) 164991"];
5195 [label="this.HasErrors 164992"];
5196 [label="get { return _errors != null; } 164993"];
5197 [label="return _errors != null; 164994"];
5198 [label="return _errors != null; 164995"];
5199 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 164996"];
5200 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 164997"];
5201 [label="param Create(SyntaxDiagnosticInfo[] errors) 164998"];
5202 [label="param Create(this) 164999"];
5203 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 165000"];
5204 [label="SyntaxToken token; 165001"];
5205 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 165002"];
5206 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 165003"];
5207 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 165004"];
5208 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 165005"];
5209 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 165006"];
5210 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 165007"];
5211 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 165008"];
5212 [label="Debug.Assert(quickWidth == token.FullWidth); 165009"];
5213 [label="param TryGetKeywordKind(out SyntaxKind kind) 165010"];
5214 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 165011"];
5215 [label="return SyntaxKind.CaseKeyword; 165012"];
5216 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 165013"];
5217 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 165014"];
5218 [label="param IsContextualKeyword(SyntaxKind kind) 165015"];
5219 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 165016"];
5220 [label="return false; 165017"];
5221 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 165018"];
5222 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 165019"];
5223 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 165020"];
5224 [label="return null; 165021"];
5225 [label="var errors = this.GetErrors(GetFullWidth(leading)); 165022"];
5226 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 165023"];
5227 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 165024"];
5228 [label="param AddTrivia(this) 165025"];
5229 [label="this.HasErrors 165026"];
5230 [label="get { return _errors != null; } 165027"];
5231 [label="return _errors != null; 165028"];
5232 [label="return _errors != null; 165029"];
5233 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 165030"];
5234 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 165031"];
5235 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 165032"];
5236 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 165033"];
5237 [label="return; 165034"];
5238 [label="param Create(SyntaxDiagnosticInfo[] errors) 165035"];
5239 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 165036"];
5240 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 165037"];
5241 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 165038"];
5242 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 165039"];
5243 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 165040"];
5244 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 165041"];
5245 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 165042"];
5246 [label="Debug.Assert(quickWidth == token.FullWidth); 165043"];
5247 [label="this.AddLexedToken(token); 165044"];
5248 [label="param AddLexedToken(SyntaxToken token) 165045"];
5249 [label="Debug.Assert(token != null); 165046"];
5250 [label="_lexedTokens[_tokenCount].Value 165047"];
5251 [label="get { return (SyntaxKind)this.RawKind; } 165048"];
5252 [label="return (SyntaxKind)this.RawKind; 165049"];
5253 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 165050"];
5254 [label="TextWindow.Start(); 165051"];
5255 [label="var quickWidth = TextWindow.Width; 165052"];
5256 [label="param LexSyntaxTrivia(bool afterFirstToken) 165053"];
5257 [label="param LexSyntaxTrivia(bool isTrailing) 165054"];
5258 [label="bool onlyWhitespaceOnLine = !isTrailing; 165055"];
5259 [label="this.Start(); 165056"];
5260 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 165057"];
5261 [label="return; 165058"];
5262 [label="this.Start(); 165059"];
5263 [label="param TryGetKeywordKind(out SyntaxKind kind) 165060"];
5264 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 165061"];
5265 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 165062"];
5266 [label="var errors = this.GetErrors(GetFullWidth(leading)); 165063"];
5267 [label="GetFullWidth(leading) 165064"];
5268 [label="param GetFullWidth(SyntaxListBuilder builder) 165065"];
5269 [label="int width = 0; 165066"];
5270 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 165067"];
5271 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 165068"];
5272 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 165069"];
5273 [label="return width; 165070"];
5274 [label="var errors = this.GetErrors(GetFullWidth(leading)); 165071"];
5275 [label="this.GetErrors(GetFullWidth(leading)) 165072"];
5276 [label="param GetErrors(int leadingTriviaWidth) 165073"];
5277 [label="param GetErrors(this) 165074"];
5278 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 165075"];
5279 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 165076"];
5280 [label="return null; 165077"];
5281 [label="var errors = this.GetErrors(GetFullWidth(leading)); 165078"];
5282 [label="param Create(SyntaxDiagnosticInfo[] errors) 165079"];
5283 [label="param Create(this) 165080"];
5284 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 165081"];
5285 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 165082"];
5286 [label="SyntaxToken token; 165083"];
5287 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 165084"];
5288 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 165085"];
5289 [label="Debug.Assert(quickWidth == token.FullWidth); 165086"];
5290 [label="param AddTrivia(this) 165087"];
5291 [label="get { return _errors != null; } 165088"];
5292 [label="return _errors != null; 165089"];
5293 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 165090"];
5294 [label="return (SyntaxKind)this.RawKind; 165091"];
5295 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 165092"];
5296 [label="this.Position 165093"];
5297 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 165094"];
5298 [label="return false; 165095"];
5299 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 165096"];
5300 [label="return InvalidCharacter; 165097"];
5301 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 165098"];
5302 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 165099"];
5303 [label="SyntaxFacts.IsWhitespace(ch) 165100"];
5304 [label="param IsWhitespace(char ch) 165101"];
5305 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 165102"];
5306 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 165103"];
5307 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 165104"];
5308 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 165105"];
5309 [label="SyntaxFacts.IsNewLine(ch) 165106"];
5310 [label="param IsNewLine(char ch) 165107"];
5311 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 165108"];
5312 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 165109"];
5313 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 165110"];
5314 [label="return; 165111"];
5315 [label="param LexSyntaxTrivia(bool afterFirstToken) 165112"];
5316 [label="param LexSyntaxTrivia(bool isTrailing) 165113"];
5317 [label="bool onlyWhitespaceOnLine = !isTrailing; 165114"];
5318 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 165115"];
5319 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 165116"];
5320 [label="return false; 165117"];
5321 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 165118"];
5322 [label="return InvalidCharacter; 165119"];
5323 [label="param IsReallyAtEnd(this) 165120"];
5324 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 165121"];
5325 [label="Position 165122"];
5326 [label="get\n            {\n                return _basis + _offset;\n            } 165123"];
5327 [label="return _basis + _offset; 165124"];
5328 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 165125"];
5329 [label="ConsList<Directive>.Empty 165126"];
5330 [label="new DirectiveStack(ConsList<Directive>.Empty) 165127"];
5331 [label="param DirectiveStack(ConsList<Directive> directives) 165128"];
5332 [label="param DirectiveStack(this) 165129"];
5333 [label="_directives 165130"];
5334 [label="Empty = new DirectiveStack(ConsList<Directive>.Empty) 165131"];
5335 [label="null 165132"];
5336 [label="new DirectiveStack(null) 165133"];
5337 [label="param DirectiveStack(ConsList<Directive> directives) 165134"];
5338 [label="param DirectiveStack(this) 165135"];
5339 [label="_directives 165136"];
5340 [label="Null = new DirectiveStack(null) 165137"];
5341 [label="param HasUnfinishedIf(this) 165138"];
5342 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 165139"];
5343 [label="GetPreviousIfElifElseOrRegion(_directives) 165140"];
5344 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 165141"];
5345 [label="var current = directives; 165142"];
5346 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 165143"];
5347 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 165144"];
5348 [label="return current; 165145"];
5349 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 165146"];
5350 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 165147"];
5351 [label="param HasUnfinishedRegion(this) 165148"];
5352 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 165149"];
5353 [label="GetPreviousIfElifElseOrRegion(_directives) 165150"];
5354 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 165151"];
5355 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 165152"];
5356 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 165153"];
5357 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 165154"];
5358 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 165155"];
5359 [label="var errors = this.GetErrors(GetFullWidth(leading)); 165156"];
5360 [label="param GetFullWidth(SyntaxListBuilder builder) 165157"];
5361 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 165158"];
5362 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 165159"];
5363 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 165160"];
5364 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 165161"];
5365 [label="return null; 165162"];
5366 [label="var errors = this.GetErrors(GetFullWidth(leading)); 165163"];
5367 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 165164"];
5368 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 165165"];
5369 [label="SyntaxFacts.IsWhitespace(ch) 165166"];
5370 [label="param IsWhitespace(char ch) 165167"];
5371 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 165168"];
5372 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 165169"];
5373 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 165170"];
5374 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 165171"];
5375 [label="SyntaxFacts.IsNewLine(ch) 165172"];
5376 [label="param IsNewLine(char ch) 165173"];
5377 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 165174"];
5378 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 165175"];
5379 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 165176"];
5380 [label="return; 165177"];
5381 [label="param Create(SyntaxDiagnosticInfo[] errors) 165178"];
5382 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 165179"];
5383 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 165180"];
5384 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 165181"];
5385 [label="param Token(GreenNode leading) 165182"];
5386 [label="param Token(SyntaxKind kind) 165183"];
5387 [label="param Token(GreenNode trailing) 165184"];
5388 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 165185"];
5389 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 165186"];
5390 [label="this.AddLexedToken(token); 165187"];
5391 [label="param AddLexedToken(SyntaxToken token) 165188"];
5392 [label="Debug.Assert(token != null); 165189"];
5393 [label="_lexedTokens[_tokenCount].Value 165190"];
5394 [label="get { return (SyntaxKind)this.RawKind; } 165191"];
5395 [label="return (SyntaxKind)this.RawKind; 165192"];
5396 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 165193"];
5397 [label="this.PreLex(); 165194"];
5398 [label="new SyntaxListPool() 165195"];
5399 [label="_pool = new SyntaxListPool() 165196"];
5400 [label="_syntaxFactoryContext 165197"];
5401 [label="_syntaxFactory 165198"];
5402 [label="_recursionDepth 165199"];
5403 [label="_termState 165200"];
5404 [label="_isInTry 165201"];
5405 [label="_checkedTopLevelStatementsFeatureAvailability 165202"];
5406 [label="_syntaxFactoryContext = new SyntaxFactoryContext(); 165203"];
5407 [label="_syntaxFactoryContext 165204"];
5408 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 165205"];
5409 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 165206"];
5410 [label="_syntaxFactory 165207"];
5411 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 165208"];
5412 [label="parser.ParseStatement() 165209"];
5413 [label="param ParseStatement(this) 165210"];
5414 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 165211"];
5415 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 165212"];
5416 [label="ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))) 165213"];
5417 [label="param ParseWithStackGuard(Func<TNode> parseFunc) 165214"];
5418 [label="param ParseWithStackGuard(Func<TNode> createEmptyNodeFunc) 165215"];
5419 [label="param ParseWithStackGuard(this) 165216"];
5420 [label="Debug.Assert(_recursionDepth == 0); 165217"];
5421 [label="Debug.Assert(_recursionDepth == 0); 165218"];
5422 [label="return parseFunc(); 165219"];
5423 [label="return parseFunc(); 165220"];
5424 [label="=> ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 165221"];
5425 [label="ParseAttributeDeclarations() 165222"];
5426 [label="param ParseAttributeDeclarations(this) 165223"];
5427 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 165224"];
5428 [label="var saveTerm = _termState; 165225"];
5429 [label="_termState |= TerminatorState.IsAttributeDeclarationTerminator; 165226"];
5430 [label="_termState 165227"];
5431 [label="this.IsPossibleAttributeDeclaration() 165228"];
5432 [label="param IsPossibleAttributeDeclaration(this) 165229"];
5433 [label="this.CurrentToken 165230"];
5434 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165231"];
5435 [label="this.FetchCurrentToken() 165232"];
5436 [label="param FetchCurrentToken(this) 165233"];
5437 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165234"];
5438 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 165235"];
5439 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 165236"];
5440 [label="return _lexedTokens[_tokenOffset]; 165237"];
5441 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165238"];
5442 [label="_currentToken 165239"];
5443 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 165240"];
5444 [label="this.CurrentToken.Kind 165241"];
5445 [label="get { return (SyntaxKind)this.RawKind; } 165242"];
5446 [label="return (SyntaxKind)this.RawKind; 165243"];
5447 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 165244"];
5448 [label="_termState 165245"];
5449 [label="return attributes.ToList(); 165246"];
5450 [label="_pool.Free(attributes); 165247"];
5451 [label="_pool.Free(attributes); 165248"];
5452 [label="false 165249"];
5453 [label="isGlobal: false 165250"];
5454 [label="ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 165251"];
5455 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 165252"];
5456 [label="param ParseStatementCore(bool isGlobal) 165253"];
5457 [label="param ParseStatementCore(this) 165254"];
5458 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 165255"];
5459 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 165256"];
5460 [label="canReuseStatement(attributes, isGlobal) 165257"];
5461 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 165258"];
5462 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 165259"];
5463 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 165260"];
5464 [label="this.IsIncrementalAndFactoryContextMatches 165261"];
5465 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 165262"];
5466 [label="base.IsIncremental 165263"];
5467 [label="get\n            {\n                return _isIncremental;\n            } 165264"];
5468 [label="return _isIncremental; 165265"];
5469 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 165266"];
5470 [label="return false; 165267"];
5471 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 165268"];
5472 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 165269"];
5473 [label="this.GetResetPoint() 165270"];
5474 [label="param GetResetPoint(this) 165271"];
5475 [label="base.GetResetPoint() 165272"];
5476 [label="param GetResetPoint(this) 165273"];
5477 [label="CurrentTokenPosition 165274"];
5478 [label="=> _firstToken + _tokenOffset 165275"];
5479 [label="_firstToken + _tokenOffset 165276"];
5480 [label="var pos = CurrentTokenPosition; 165277"];
5481 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 165278"];
5482 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 165279"];
5483 [label="_resetStart 165280"];
5484 [label="_resetCount 165281"];
5485 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 165282"];
5486 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 165283"];
5487 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 165284"];
5488 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 165285"];
5489 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 165286"];
5490 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 165287"];
5491 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 165288"];
5492 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 165289"];
5493 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 165290"];
5494 [label="param ResetPoint(TerminatorState terminatorState) 165291"];
5495 [label="param ResetPoint(bool isInTry) 165292"];
5496 [label="param ResetPoint(bool isInAsync) 165293"];
5497 [label="param ResetPoint(int queryDepth) 165294"];
5498 [label="param ResetPoint(this) 165295"];
5499 [label="this.BaseResetPoint 165296"];
5500 [label="this.TerminatorState 165297"];
5501 [label="this.IsInTry 165298"];
5502 [label="this.IsInAsync 165299"];
5503 [label="this.QueryDepth 165300"];
5504 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 165301"];
5505 [label="_recursionDepth 165302"];
5506 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 165303"];
5507 [label="StatementSyntax result; 165304"];
5508 [label="this.CurrentToken 165305"];
5509 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165306"];
5510 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165307"];
5511 [label="switch (this.CurrentToken.Kind)\n                {\n                    case SyntaxKind.FixedKeyword:\n                        return this.ParseFixedStatement(attributes);\n                    case SyntaxKind.BreakKeyword:\n                        return this.ParseBreakStatement(attributes);\n                    case SyntaxKind.ContinueKeyword:\n                        return this.ParseContinueStatement(attributes);\n                    case SyntaxKind.TryKeyword:\n                    case SyntaxKind.CatchKeyword:\n                    case SyntaxKind.FinallyKeyword:\n                        return this.ParseTryStatement(attributes);\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                        return this.ParseCheckedStatement(attributes);\n                    case SyntaxKind.DoKeyword:\n                        return this.ParseDoStatement(attributes);\n                    case SyntaxKind.ForKeyword:\n                        return this.ParseForOrForEachStatement(attributes);\n                    case SyntaxKind.ForEachKeyword:\n                        return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                    case SyntaxKind.GotoKeyword:\n                        return this.ParseGotoStatement(attributes);\n                    case SyntaxKind.IfKeyword:\n                        return this.ParseIfStatement(attributes);\n                    case SyntaxKind.ElseKeyword:\n                        // Including 'else' keyword to handle 'else without if' error cases \n                        return this.ParseMisplacedElse(attributes);\n                    case SyntaxKind.LockKeyword:\n                        return this.ParseLockStatement(attributes);\n                    case SyntaxKind.ReturnKeyword:\n                        return this.ParseReturnStatement(attributes);\n                    case SyntaxKind.SwitchKeyword:\n                        return this.ParseSwitchStatement(attributes);\n                    case SyntaxKind.ThrowKeyword:\n                        return this.ParseThrowStatement(attributes);\n                    case SyntaxKind.UnsafeKeyword:\n                        result = TryParseStatementStartingWithUnsafe(attributes);\n                        if (result != null)\n                            return result;\n                        break;\n                    case SyntaxKind.UsingKeyword:\n                        return ParseStatementStartingWithUsing(attributes);\n                    case SyntaxKind.WhileKeyword:\n                        return this.ParseWhileStatement(attributes);\n                    case SyntaxKind.OpenBraceToken:\n                        return this.ParseBlock(attributes);\n                    case SyntaxKind.SemicolonToken:\n                        return _syntaxFactory.EmptyStatement(attributes, this.EatToken());\n                    case SyntaxKind.IdentifierToken:\n                        result = TryParseStatementStartingWithIdentifier(attributes, isGlobal);\n                        if (result != null)\n                            return result;\n                        break;\n                } 165308"];
5512 [label="this.CurrentToken.Kind 165309"];
5513 [label="get { return (SyntaxKind)this.RawKind; } 165310"];
5514 [label="return (SyntaxKind)this.RawKind; 165311"];
5515 [label="return this.ParseSwitchStatement(attributes); 165312"];
5516 [label="this.ParseSwitchStatement(attributes) 165313"];
5517 [label="param ParseSwitchStatement(SyntaxList<AttributeListSyntax> attributes) 165314"];
5518 [label="param ParseSwitchStatement(this) 165315"];
5519 [label="this.CurrentToken 165316"];
5520 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165317"];
5521 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.SwitchKeyword); 165318"];
5522 [label="this.CurrentToken.Kind 165319"];
5523 [label="get { return (SyntaxKind)this.RawKind; } 165320"];
5524 [label="var @switch = this.EatToken(SyntaxKind.SwitchKeyword); 165321"];
5525 [label="this.EatToken(SyntaxKind.SwitchKeyword) 165322"];
5526 [label="param EatToken(SyntaxKind kind) 165323"];
5527 [label="param EatToken(this) 165324"];
5528 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 165325"];
5529 [label="SyntaxFacts.IsAnyToken(kind) 165326"];
5530 [label="param IsAnyToken(SyntaxKind kind) 165327"];
5531 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 165328"];
5532 [label="return true; 165329"];
5533 [label="this.CurrentToken 165330"];
5534 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165331"];
5535 [label="var ct = this.CurrentToken; 165332"];
5536 [label="ct.Kind 165333"];
5537 [label="get { return (SyntaxKind)this.RawKind; } 165334"];
5538 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 165335"];
5539 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 165336"];
5540 [label="MoveToNextToken() 165337"];
5541 [label="param MoveToNextToken(this) 165338"];
5542 [label="_currentToken.GetTrailingTrivia() 165339"];
5543 [label="param GetTrailingTrivia(this) 165340"];
5544 [label="return this.TrailingField; 165341"];
5545 [label="_prevTokenTrailingTrivia = _currentToken.GetTrailingTrivia(); 165342"];
5546 [label="_prevTokenTrailingTrivia 165343"];
5547 [label="_currentToken = null; 165344"];
5548 [label="_currentToken 165345"];
5549 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 165346"];
5550 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 165347"];
5551 [label="_tokenOffset 165348"];
5552 [label="MoveToNextToken(); 165349"];
5553 [label="return ct; 165350"];
5554 [label="this.ParseExpressionCore() 165351"];
5555 [label="param ParseExpressionCore(this) 165352"];
5556 [label="return this.ParseSubExpression(Precedence.Expression); 165353"];
5557 [label="this.ParseSubExpression(Precedence.Expression) 165354"];
5558 [label="param ParseSubExpression(Precedence precedence) 165355"];
5559 [label="param ParseSubExpression(this) 165356"];
5560 [label="_recursionDepth 165357"];
5561 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 165358"];
5562 [label="var result = ParseSubExpressionCore(precedence); 165359"];
5563 [label="ParseSubExpressionCore(precedence) 165360"];
5564 [label="param ParseSubExpressionCore(Precedence precedence) 165361"];
5565 [label="param ParseSubExpressionCore(this) 165362"];
5566 [label="ExpressionSyntax leftOperand; 165363"];
5567 [label="Precedence newPrecedence = 0; 165364"];
5568 [label="this.CurrentToken 165365"];
5569 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165366"];
5570 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165367"];
5571 [label="return _lexedTokens[_tokenOffset]; 165368"];
5572 [label="var tk = this.CurrentToken.Kind; 165369"];
5573 [label="this.CurrentToken.Kind 165370"];
5574 [label="get { return (SyntaxKind)this.RawKind; } 165371"];
5575 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 165372"];
5576 [label="IsInvalidSubExpression(tk) 165373"];
5577 [label="param IsInvalidSubExpression(SyntaxKind kind) 165374"];
5578 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 165375"];
5579 [label="return false; 165376"];
5580 [label="if (IsExpectedPrefixUnaryOperator(tk))\n            {\n                var opKind = SyntaxFacts.GetPrefixUnaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n                var opToken = this.EatToken();\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.PrefixUnaryExpression(opKind, opToken, operand);\n            }\n            else if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 165377"];
5581 [label="IsExpectedPrefixUnaryOperator(tk) 165378"];
5582 [label="param IsExpectedPrefixUnaryOperator(SyntaxKind kind) 165379"];
5583 [label="return SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword; 165380"];
5584 [label="SyntaxFacts.IsPrefixUnaryExpression(kind) 165381"];
5585 [label="param IsPrefixUnaryExpression(SyntaxKind token) 165382"];
5586 [label="return GetPrefixUnaryExpression(token) != SyntaxKind.None; 165383"];
5587 [label="GetPrefixUnaryExpression(token) 165384"];
5588 [label="param GetPrefixUnaryExpression(SyntaxKind token) 165385"];
5589 [label="switch (token)\n            {\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.UnaryPlusExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.UnaryMinusExpression;\n                case SyntaxKind.TildeToken:\n                    return SyntaxKind.BitwiseNotExpression;\n                case SyntaxKind.ExclamationToken:\n                    return SyntaxKind.LogicalNotExpression;\n                case SyntaxKind.PlusPlusToken:\n                    return SyntaxKind.PreIncrementExpression;\n                case SyntaxKind.MinusMinusToken:\n                    return SyntaxKind.PreDecrementExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.AddressOfExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.PointerIndirectionExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.IndexExpression;\n                default:\n                    return SyntaxKind.None;\n            } 165386"];
5590 [label="return SyntaxKind.None; 165387"];
5591 [label="if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 165388"];
5592 [label="IsAwaitExpression() 165389"];
5593 [label="param IsAwaitExpression(this) 165390"];
5594 [label="this.CurrentToken 165391"];
5595 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165392"];
5596 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 165393"];
5597 [label="this.CurrentToken.ContextualKind 165394"];
5598 [label="get\n            {\n                return this.Kind;\n            } 165395"];
5599 [label="this.Kind 165396"];
5600 [label="get { return (SyntaxKind)this.RawKind; } 165397"];
5601 [label="return this.Kind; 165398"];
5602 [label="return false; 165399"];
5603 [label="if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 165400"];
5604 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 165401"];
5605 [label="this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false) 165402"];
5606 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 165403"];
5607 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 165404"];
5608 [label="param IsQueryExpression(this) 165405"];
5609 [label="this.CurrentToken 165406"];
5610 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165407"];
5611 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 165408"];
5612 [label="this.CurrentToken.ContextualKind 165409"];
5613 [label="get\n            {\n                return this.Kind;\n            } 165410"];
5614 [label="this.Kind 165411"];
5615 [label="get { return (SyntaxKind)this.RawKind; } 165412"];
5616 [label="return this.Kind; 165413"];
5617 [label="return false; 165414"];
5618 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 165415"];
5619 [label="this.CurrentToken 165416"];
5620 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 165417"];
5621 [label="this.CurrentToken.ContextualKind 165418"];
5622 [label="get\n            {\n                return this.Kind;\n            } 165419"];
5623 [label="this.Kind 165420"];
5624 [label="get { return (SyntaxKind)this.RawKind; } 165421"];
5625 [label="return this.Kind; 165422"];
5626 [label="if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 165423"];
5627 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 165424"];
5628 [label="this.IsPossibleDeconstructionLeft(precedence) 165425"];
5629 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 165426"];
5630 [label="param IsPossibleDeconstructionLeft(this) 165427"];
5631 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 165428"];
5632 [label="this.CurrentToken 165429"];
5633 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165430"];
5634 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 165431"];
5635 [label="this.CurrentToken.IsIdentifierVar() 165432"];
5636 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 165433"];
5637 [label="node.ContextualKind 165434"];
5638 [label="get\n            {\n                return this.Kind;\n            } 165435"];
5639 [label="return node.ContextualKind == SyntaxKind.VarKeyword; 165436"];
5640 [label="this.CurrentToken 165437"];
5641 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165438"];
5642 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 165439"];
5643 [label="this.CurrentToken.Kind 165440"];
5644 [label="get { return (SyntaxKind)this.RawKind; } 165441"];
5645 [label="IsPredefinedType(this.CurrentToken.Kind) 165442"];
5646 [label="param IsPredefinedType(SyntaxKind keyword) 165443"];
5647 [label="return SyntaxFacts.IsPredefinedType(keyword); 165444"];
5648 [label="SyntaxFacts.IsPredefinedType(keyword) 165445"];
5649 [label="param IsPredefinedType(SyntaxKind kind) 165446"];
5650 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 165447"];
5651 [label="return false; 165448"];
5652 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 165449"];
5653 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 165450"];
5654 [label="return false; 165451"];
5655 [label="leftOperand = this.ParseTerm(precedence); 165452"];
5656 [label="this.ParseTerm(precedence) 165453"];
5657 [label="param ParseTerm(Precedence precedence) 165454"];
5658 [label="=> this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 165455"];
5659 [label="precedence 165456"];
5660 [label="ParseTermWithoutPostfix(precedence) 165457"];
5661 [label="param ParseTermWithoutPostfix(Precedence precedence) 165458"];
5662 [label="param ParseTermWithoutPostfix(this) 165459"];
5663 [label="this.CurrentToken 165460"];
5664 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165461"];
5665 [label="var tk = this.CurrentToken.Kind; 165462"];
5666 [label="this.CurrentToken.Kind 165463"];
5667 [label="get { return (SyntaxKind)this.RawKind; } 165464"];
5668 [label="switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                    return this.ParseTypeOfExpression();\n                case SyntaxKind.DefaultKeyword:\n                    return this.ParseDefaultExpression();\n                case SyntaxKind.SizeOfKeyword:\n                    return this.ParseSizeOfExpression();\n                case SyntaxKind.MakeRefKeyword:\n                    return this.ParseMakeRefExpression();\n                case SyntaxKind.RefTypeKeyword:\n                    return this.ParseRefTypeExpression();\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    return this.ParseCheckedOrUncheckedExpression();\n                case SyntaxKind.RefValueKeyword:\n                    return this.ParseRefValueExpression();\n                case SyntaxKind.ColonColonToken:\n                    // misplaced ::\n                    // Calling ParseAliasQualifiedName will cause us to create a missing identifier node that then\n                    // properly consumes the :: and the reset of the alias name afterwards.\n                    return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return this.ParseLambdaExpression();\n                case SyntaxKind.StaticKeyword:\n                    if (this.IsPossibleAnonymousMethodExpression())\n                    {\n                        return this.ParseAnonymousMethodExpression();\n                    }\n                    else if (this.IsPossibleLambdaExpression(precedence))\n                    {\n                        return this.ParseLambdaExpression();\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.ThisKeyword:\n                    return _syntaxFactory.ThisExpression(this.EatToken());\n                case SyntaxKind.BaseKeyword:\n                    return ParseBaseExpression();\n\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                    return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken());\n                case SyntaxKind.InterpolatedStringStartToken:\n                    throw new NotImplementedException(); // this should not occur because these tokens are produced and parsed immediately\n                case SyntaxKind.InterpolatedStringToken:\n                    return this.ParseInterpolatedStringToken();\n                case SyntaxKind.OpenParenToken:\n                    return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence);\n                case SyntaxKind.NewKeyword:\n                    return this.ParseNewExpression();\n                case SyntaxKind.StackAllocKeyword:\n                    return this.ParseStackAllocExpression();\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseAnonymousMethodExpression();\n                case SyntaxKind.RefKeyword:\n                    // ref is not expected to appear in this position.\n                    return this.AddError(ParsePossibleRefExpression(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                default:\n                    // check for intrinsic type followed by '.'\n                    if (IsPredefinedType(tk))\n                    {\n                        var expr = _syntaxFactory.PredefinedType(this.EatToken());\n\n                        if (this.CurrentToken.Kind != SyntaxKind.DotToken || tk == SyntaxKind.VoidKeyword)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n                    else\n                    {\n                        var expr = this.CreateMissingIdentifierName();\n\n                        if (tk == SyntaxKind.EndOfFileToken)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_ExpressionExpected);\n                        }\n                        else\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n            } 165465"];
5669 [label="return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence); 165466"];
5670 [label="this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence) 165467"];
5671 [label="param ParseCastOrParenExpressionOrLambdaOrTuple(Precedence precedence) 165468"];
5672 [label="param ParseCastOrParenExpressionOrLambdaOrTuple(this) 165469"];
5673 [label="this.CurrentToken 165470"];
5674 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165471"];
5675 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.OpenParenToken); 165472"];
5676 [label="this.CurrentToken.Kind 165473"];
5677 [label="get { return (SyntaxKind)this.RawKind; } 165474"];
5678 [label="this.GetResetPoint() 165475"];
5679 [label="param GetResetPoint(this) 165476"];
5680 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 165477"];
5681 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 165478"];
5682 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 165479"];
5683 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 165480"];
5684 [label="param ResetPoint(TerminatorState terminatorState) 165481"];
5685 [label="param ResetPoint(bool isInTry) 165482"];
5686 [label="param ResetPoint(bool isInAsync) 165483"];
5687 [label="param ResetPoint(int queryDepth) 165484"];
5688 [label="param ResetPoint(this) 165485"];
5689 [label="this.BaseResetPoint 165486"];
5690 [label="this.TerminatorState 165487"];
5691 [label="this.IsInTry 165488"];
5692 [label="this.IsInAsync 165489"];
5693 [label="this.QueryDepth 165490"];
5694 [label="var resetPoint = this.GetResetPoint(); 165491"];
5695 [label="if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 165492"];
5696 [label="ScanParenthesizedImplicitlyTypedLambda(precedence) 165493"];
5697 [label="param ScanParenthesizedImplicitlyTypedLambda(Precedence precedence) 165494"];
5698 [label="param ScanParenthesizedImplicitlyTypedLambda(this) 165495"];
5699 [label="if (!(precedence <= Precedence.Lambda))\n            {\n                return false;\n            } 165496"];
5700 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 165497"];
5701 [label="this.PeekToken(1) 165498"];
5702 [label="param PeekToken(int n) 165499"];
5703 [label="param PeekToken(this) 165500"];
5704 [label="Debug.Assert(n >= 0); 165501"];
5705 [label="Debug.Assert(n >= 0); 165502"];
5706 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165503"];
5707 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165504"];
5708 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165505"];
5709 [label="return _lexedTokens[_tokenOffset + n]; 165506"];
5710 [label="this.PeekToken(1).Kind 165507"];
5711 [label="get { return (SyntaxKind)this.RawKind; } 165508"];
5712 [label="this.IsInQuery 165509"];
5713 [label="get { return _syntaxFactoryContext.IsInQuery; } 165510"];
5714 [label="return _syntaxFactoryContext.IsInQuery; 165511"];
5715 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 165512"];
5716 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 165513"];
5717 [label="this.PeekToken(2) 165514"];
5718 [label="param PeekToken(int n) 165515"];
5719 [label="param PeekToken(this) 165516"];
5720 [label="Debug.Assert(n >= 0); 165517"];
5721 [label="Debug.Assert(n >= 0); 165518"];
5722 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165519"];
5723 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165520"];
5724 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165521"];
5725 [label="return _lexedTokens[_tokenOffset + n]; 165522"];
5726 [label="this.PeekToken(2).Kind 165523"];
5727 [label="get { return (SyntaxKind)this.RawKind; } 165524"];
5728 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 165525"];
5729 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 165526"];
5730 [label="this.PeekToken(1) 165527"];
5731 [label="param PeekToken(int n) 165528"];
5732 [label="param PeekToken(this) 165529"];
5733 [label="Debug.Assert(n >= 0); 165530"];
5734 [label="Debug.Assert(n >= 0); 165531"];
5735 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165532"];
5736 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165533"];
5737 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165534"];
5738 [label="return _lexedTokens[_tokenOffset + n]; 165535"];
5739 [label="IsTrueIdentifier(this.PeekToken(1)) 165536"];
5740 [label="param IsTrueIdentifier(SyntaxToken token) 165537"];
5741 [label="param IsTrueIdentifier(this) 165538"];
5742 [label="token.Kind 165539"];
5743 [label="get { return (SyntaxKind)this.RawKind; } 165540"];
5744 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 165541"];
5745 [label="this.IsInQuery 165542"];
5746 [label="get { return _syntaxFactoryContext.IsInQuery; } 165543"];
5747 [label="return _syntaxFactoryContext.IsInQuery; 165544"];
5748 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 165545"];
5749 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 165546"];
5750 [label="this.PeekToken(2) 165547"];
5751 [label="param PeekToken(int n) 165548"];
5752 [label="param PeekToken(this) 165549"];
5753 [label="Debug.Assert(n >= 0); 165550"];
5754 [label="Debug.Assert(n >= 0); 165551"];
5755 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165552"];
5756 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165553"];
5757 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165554"];
5758 [label="return _lexedTokens[_tokenOffset + n]; 165555"];
5759 [label="this.PeekToken(2).Kind 165556"];
5760 [label="get { return (SyntaxKind)this.RawKind; } 165557"];
5761 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 165558"];
5762 [label="this.PeekToken(3) 165559"];
5763 [label="param PeekToken(int n) 165560"];
5764 [label="param PeekToken(this) 165561"];
5765 [label="Debug.Assert(n >= 0); 165562"];
5766 [label="Debug.Assert(n >= 0); 165563"];
5767 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165564"];
5768 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165565"];
5769 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165566"];
5770 [label="return _lexedTokens[_tokenOffset + n]; 165567"];
5771 [label="this.PeekToken(3).Kind 165568"];
5772 [label="get { return (SyntaxKind)this.RawKind; } 165569"];
5773 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 165570"];
5774 [label="if (this.PeekToken(1).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 165571"];
5775 [label="this.PeekToken(1) 165572"];
5776 [label="param PeekToken(int n) 165573"];
5777 [label="param PeekToken(this) 165574"];
5778 [label="Debug.Assert(n >= 0); 165575"];
5779 [label="Debug.Assert(n >= 0); 165576"];
5780 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165577"];
5781 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165578"];
5782 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165579"];
5783 [label="return _lexedTokens[_tokenOffset + n]; 165580"];
5784 [label="this.PeekToken(1).Kind 165581"];
5785 [label="get { return (SyntaxKind)this.RawKind; } 165582"];
5786 [label="if (this.PeekToken(1).Kind == SyntaxKind.ParamsKeyword)\n            {\n                return true;\n            } 165583"];
5787 [label="this.PeekToken(1) 165584"];
5788 [label="param PeekToken(int n) 165585"];
5789 [label="param PeekToken(this) 165586"];
5790 [label="Debug.Assert(n >= 0); 165587"];
5791 [label="Debug.Assert(n >= 0); 165588"];
5792 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165589"];
5793 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165590"];
5794 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165591"];
5795 [label="return _lexedTokens[_tokenOffset + n]; 165592"];
5796 [label="this.PeekToken(1).Kind 165593"];
5797 [label="get { return (SyntaxKind)this.RawKind; } 165594"];
5798 [label="return false; 165595"];
5799 [label="if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 165596"];
5800 [label="if (this.ScanCast())\n                {\n                    if (!IsCurrentTokenQueryKeywordInQuery())\n                    {\n                        // Looks like a cast, so parse it as one.\n                        this.Reset(ref resetPoint);\n                        var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                        var type = this.ParseType();\n                        var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                        var expr = this.ParseSubExpression(Precedence.Cast);\n                        return _syntaxFactory.CastExpression(openParen, type, closeParen, expr);\n                    }\n                } 165597"];
5801 [label="this.ScanCast() 165598"];
5802 [label="param ScanCast(bool forPattern = false) 165599"];
5803 [label="param ScanCast(this) 165600"];
5804 [label="this.CurrentToken 165601"];
5805 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165602"];
5806 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165603"];
5807 [label="if (this.CurrentToken.Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            } 165604"];
5808 [label="this.CurrentToken.Kind 165605"];
5809 [label="get { return (SyntaxKind)this.RawKind; } 165606"];
5810 [label="this.EatToken() 165607"];
5811 [label="param EatToken(this) 165608"];
5812 [label="this.CurrentToken 165609"];
5813 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165610"];
5814 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165611"];
5815 [label="var ct = this.CurrentToken; 165612"];
5816 [label="MoveToNextToken() 165613"];
5817 [label="param MoveToNextToken(this) 165614"];
5818 [label="param GetTrailingTrivia(this) 165615"];
5819 [label="return null; 165616"];
5820 [label="_prevTokenTrailingTrivia 165617"];
5821 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 165618"];
5822 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 165619"];
5823 [label="_tokenOffset 165620"];
5824 [label="MoveToNextToken(); 165621"];
5825 [label="return ct; 165622"];
5826 [label="this.EatToken(); 165623"];
5827 [label="var type = this.ScanType(forPattern: forPattern); 165624"];
5828 [label="this.ScanType(forPattern: forPattern) 165625"];
5829 [label="param ScanType(bool forPattern = false) 165626"];
5830 [label="param ScanType(this) 165627"];
5831 [label="return ScanType(out _, forPattern); 165628"];
5832 [label="return ScanType(out _, forPattern); 165629"];
5833 [label="ScanType(out _, forPattern) 165630"];
5834 [label="param ScanType(out SyntaxToken lastTokenOfType) 165631"];
5835 [label="param ScanType(bool forPattern = false) 165632"];
5836 [label="param ScanType(this) 165633"];
5837 [label="forPattern 165634"];
5838 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 165635"];
5839 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 165636"];
5840 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 165637"];
5841 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 165638"];
5842 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165639"];
5843 [label="param PeekToken(int n) 165640"];
5844 [label="param PeekToken(this) 165641"];
5845 [label="Debug.Assert(n >= 0); 165642"];
5846 [label="Debug.Assert(n >= 0); 165643"];
5847 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165644"];
5848 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165645"];
5849 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165646"];
5850 [label="return _lexedTokens[_tokenOffset + n]; 165647"];
5851 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 165648"];
5852 [label="param ScanNamedTypePart(this) 165649"];
5853 [label="this.CurrentToken 165650"];
5854 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165651"];
5855 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165652"];
5856 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 165653"];
5857 [label="this.CurrentToken.Kind 165654"];
5858 [label="get { return (SyntaxKind)this.RawKind; } 165655"];
5859 [label="this.IsTrueIdentifier() 165656"];
5860 [label="param IsTrueIdentifier(this) 165657"];
5861 [label="this.CurrentToken 165658"];
5862 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165659"];
5863 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165660"];
5864 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 165661"];
5865 [label="this.CurrentToken.Kind 165662"];
5866 [label="get { return (SyntaxKind)this.RawKind; } 165663"];
5867 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 165664"];
5868 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 165665"];
5869 [label="this.CurrentToken 165666"];
5870 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165667"];
5871 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 165668"];
5872 [label="this.CurrentToken.ContextualKind 165669"];
5873 [label="get\n            {\n                return this.Kind;\n            } 165670"];
5874 [label="return false; 165671"];
5875 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 165672"];
5876 [label="IsCurrentTokenQueryKeywordInQuery() 165673"];
5877 [label="param IsCurrentTokenQueryKeywordInQuery(this) 165674"];
5878 [label="this.IsInQuery 165675"];
5879 [label="get { return _syntaxFactoryContext.IsInQuery; } 165676"];
5880 [label="return _syntaxFactoryContext.IsInQuery; 165677"];
5881 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 165678"];
5882 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 165679"];
5883 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 165680"];
5884 [label="IsCurrentTokenWhereOfConstraintClause() 165681"];
5885 [label="param IsCurrentTokenWhereOfConstraintClause(this) 165682"];
5886 [label="this.CurrentToken 165683"];
5887 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165684"];
5888 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 165685"];
5889 [label="this.CurrentToken.ContextualKind 165686"];
5890 [label="get\n            {\n                return this.Kind;\n            } 165687"];
5891 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 165688"];
5892 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 165689"];
5893 [label="return true; 165690"];
5894 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 165691"];
5895 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 165692"];
5896 [label="this.EatToken() 165693"];
5897 [label="param EatToken(this) 165694"];
5898 [label="this.CurrentToken 165695"];
5899 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165696"];
5900 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165697"];
5901 [label="var ct = this.CurrentToken; 165698"];
5902 [label="MoveToNextToken() 165699"];
5903 [label="param GetTrailingTrivia(this) 165700"];
5904 [label="return null; 165701"];
5905 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 165702"];
5906 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 165703"];
5907 [label="_tokenOffset 165704"];
5908 [label="MoveToNextToken(); 165705"];
5909 [label="return ct; 165706"];
5910 [label="lastTokenOfType = this.EatToken(); 165707"];
5911 [label="this.CurrentToken 165708"];
5912 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165709"];
5913 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165710"];
5914 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 165711"];
5915 [label="return _lexedTokens[_tokenOffset]; 165712"];
5916 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                return this.ScanPossibleTypeArgumentList(ref lastTokenOfType, out _);\n            }\n            else\n            {\n                return ScanTypeFlags.NonGenericTypeOrExpression;\n            } 165713"];
5917 [label="this.CurrentToken.Kind 165714"];
5918 [label="get { return (SyntaxKind)this.RawKind; } 165715"];
5919 [label="return ScanTypeFlags.NonGenericTypeOrExpression; 165716"];
5920 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 165717"];
5921 [label="param IsDotOrColonColon(this) 165718"];
5922 [label="this.CurrentToken 165719"];
5923 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165720"];
5924 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165721"];
5925 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 165722"];
5926 [label="this.CurrentToken.Kind 165723"];
5927 [label="get { return (SyntaxKind)this.RawKind; } 165724"];
5928 [label="this.CurrentToken 165725"];
5929 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165726"];
5930 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165727"];
5931 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 165728"];
5932 [label="this.CurrentToken.Kind 165729"];
5933 [label="get { return (SyntaxKind)this.RawKind; } 165730"];
5934 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 165731"];
5935 [label="param IsMakingProgress(ref int lastTokenPosition) 165732"];
5936 [label="param IsMakingProgress(bool assertIfFalse = true) 165733"];
5937 [label="param IsMakingProgress(this) 165734"];
5938 [label="CurrentTokenPosition 165735"];
5939 [label="=> _firstToken + _tokenOffset 165736"];
5940 [label="_firstToken + _tokenOffset 165737"];
5941 [label="var pos = CurrentTokenPosition; 165738"];
5942 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 165739"];
5943 [label="lastTokenPosition = pos; 165740"];
5944 [label="return true; 165741"];
5945 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 165742"];
5946 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 165743"];
5947 [label="if (type == ScanTypeFlags.NotType)\n            {\n                return false;\n            } 165744"];
5948 [label="this.CurrentToken 165745"];
5949 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165746"];
5950 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165747"];
5951 [label="if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n            {\n                return false;\n            } 165748"];
5952 [label="this.CurrentToken.Kind 165749"];
5953 [label="get { return (SyntaxKind)this.RawKind; } 165750"];
5954 [label="this.EatToken() 165751"];
5955 [label="param EatToken(this) 165752"];
5956 [label="this.CurrentToken 165753"];
5957 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165754"];
5958 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165755"];
5959 [label="MoveToNextToken() 165756"];
5960 [label="param MoveToNextToken(this) 165757"];
5961 [label="param GetTrailingTrivia(this) 165758"];
5962 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 165759"];
5963 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 165760"];
5964 [label="_tokenOffset 165761"];
5965 [label="MoveToNextToken(); 165762"];
5966 [label="this.EatToken(); 165763"];
5967 [label="switch (type)\n            {\n                // If we have any of the following, we know it must be a cast:\n                // 1) (Goo*)bar;\n                // 2) (Goo?)bar;\n                // 3) '(int)bar' or '(int[])bar'\n                // 4) (G::Goo)bar\n                case ScanTypeFlags.PointerOrMultiplication:\n                case ScanTypeFlags.NullableType:\n                case ScanTypeFlags.MustBeType:\n                case ScanTypeFlags.AliasQualifiedName:\n                    // The thing between parens is unambiguously a type.\n                    // In a pattern, we need more lookahead to confirm it is a cast and not\n                    // a parenthesized type pattern.  In this case the tokens that\n                    // have both unary and binary operator forms may appear in their unary form\n                    // following a cast.\n                    return !forPattern || this.CurrentToken.Kind switch\n                    {\n                        SyntaxKind.PlusToken => true,\n                        SyntaxKind.MinusToken => true,\n                        SyntaxKind.AmpersandToken => true,\n                        SyntaxKind.AsteriskToken => true,\n                        SyntaxKind.DotDotToken => true,\n                        _ => CanFollowCast(this.CurrentToken.Kind)\n                    };\n\n                case ScanTypeFlags.GenericTypeOrMethod:\n                case ScanTypeFlags.GenericTypeOrExpression:\n                case ScanTypeFlags.NonGenericTypeOrExpression:\n                case ScanTypeFlags.TupleType:\n                    // check for ambiguous type or expression followed by disambiguating token.  i.e.\n                    //\n                    // '(A)b' is a cast.  But '(A)+b' is not a cast.  \n                    return CanFollowCast(this.CurrentToken.Kind);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(type);\n            } 165764"];
5968 [label="this.CurrentToken 165765"];
5969 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165766"];
5970 [label="return _lexedTokens[_tokenOffset]; 165767"];
5971 [label="return CanFollowCast(this.CurrentToken.Kind); 165768"];
5972 [label="this.CurrentToken.Kind 165769"];
5973 [label="get { return (SyntaxKind)this.RawKind; } 165770"];
5974 [label="CanFollowCast(this.CurrentToken.Kind) 165771"];
5975 [label="param CanFollowCast(SyntaxKind kind) 165772"];
5976 [label="switch (kind)\n            {\n                case SyntaxKind.AsKeyword:\n                case SyntaxKind.IsKeyword:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.EqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.QuestionToken:\n                case SyntaxKind.ColonToken:\n                case SyntaxKind.BarBarToken:\n                case SyntaxKind.AmpersandAmpersandToken:\n                case SyntaxKind.BarToken:\n                case SyntaxKind.CaretToken:\n                case SyntaxKind.AmpersandToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.LessThanLessThanToken:\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                case SyntaxKind.PlusToken:\n                case SyntaxKind.MinusToken:\n                case SyntaxKind.AsteriskToken:\n                case SyntaxKind.SlashToken:\n                case SyntaxKind.PercentToken:\n                case SyntaxKind.PlusPlusToken:\n                case SyntaxKind.MinusMinusToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                case SyntaxKind.QuestionQuestionToken:\n                case SyntaxKind.EndOfFileToken:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.EqualsGreaterThanToken:\n                case SyntaxKind.DotDotToken:\n                    return false;\n                default:\n                    return true;\n            } 165773"];
5977 [label="return false; 165774"];
5978 [label="this.Reset(ref resetPoint); 165775"];
5979 [label="this.Reset(ref resetPoint) 165776"];
5980 [label="param Reset(ref ResetPoint state) 165777"];
5981 [label="param Reset(this) 165778"];
5982 [label="_termState 165779"];
5983 [label="_isInTry 165780"];
5984 [label="_syntaxFactoryContext.IsInAsync 165781"];
5985 [label="_syntaxFactoryContext.QueryDepth 165782"];
5986 [label="base.Reset(ref state.BaseResetPoint); 165783"];
5987 [label="base.Reset(ref state.BaseResetPoint) 165784"];
5988 [label="param Reset(ref ResetPoint point) 165785"];
5989 [label="param Reset(this) 165786"];
5990 [label="var offset = point.Position - _firstToken; 165787"];
5991 [label="Debug.Assert(offset >= 0); 165788"];
5992 [label="Debug.Assert(offset >= 0); 165789"];
5993 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 165790"];
5994 [label="_mode 165791"];
5995 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 165792"];
5996 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 165793"];
5997 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 165794"];
5998 [label="_tokenOffset 165795"];
5999 [label="_currentToken = null; 165796"];
6000 [label="_currentToken 165797"];
6001 [label="_currentNode = default(BlendedNode); 165798"];
6002 [label="_currentNode 165799"];
6003 [label="_prevTokenTrailingTrivia 165800"];
6004 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 165801"];
6005 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 165802"];
6006 [label="base.Reset(ref state.BaseResetPoint); 165803"];
6007 [label="this.Reset(ref resetPoint); 165804"];
6008 [label="if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 165805"];
6009 [label="this.ScanExplicitlyTypedLambda(precedence) 165806"];
6010 [label="param ScanExplicitlyTypedLambda(Precedence precedence) 165807"];
6011 [label="param ScanExplicitlyTypedLambda(this) 165808"];
6012 [label="if (!(precedence <= Precedence.Lambda))\n            {\n                return false;\n            } 165809"];
6013 [label="this.GetResetPoint() 165810"];
6014 [label="param GetResetPoint(this) 165811"];
6015 [label="_firstToken + _tokenOffset 165812"];
6016 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 165813"];
6017 [label="_resetCount 165814"];
6018 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 165815"];
6019 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 165816"];
6020 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 165817"];
6021 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 165818"];
6022 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 165819"];
6023 [label="param ResetPoint(this) 165820"];
6024 [label="var resetPoint = this.GetResetPoint(); 165821"];
6025 [label="bool foundParameterModifier = false; 165822"];
6026 [label="while (true)\n                {\n                    // Advance past the open paren or comma.\n                    this.EatToken();\n\n                    // Eat 'out' or 'ref' for cases [3, 6]. Even though not allowed in a lambda,\n                    // we treat `params` similarly for better error recovery.\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.RefKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                            {\n                                this.EatToken();\n                            }\n                            break;\n                        case SyntaxKind.OutKeyword:\n                        case SyntaxKind.InKeyword:\n                        case SyntaxKind.ParamsKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            break;\n                    }\n\n                    if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        return foundParameterModifier;\n                    }\n\n                    // NOTE: advances CurrentToken\n                    if (this.ScanType() == ScanTypeFlags.NotType)\n                    {\n                        return false;\n                    }\n\n                    if (this.IsTrueIdentifier())\n                    {\n                        // eat the identifier\n                        this.EatToken();\n                    }\n\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.EndOfFileToken:\n                            return foundParameterModifier;\n\n                        case SyntaxKind.CommaToken:\n                            if (foundParameterModifier)\n                            {\n                                return true;\n                            }\n\n                            continue;\n\n                        case SyntaxKind.CloseParenToken:\n                            return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken;\n\n                        default:\n                            return false;\n                    }\n                } 165823"];
6027 [label="this.EatToken() 165824"];
6028 [label="param EatToken(this) 165825"];
6029 [label="this.CurrentToken 165826"];
6030 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165827"];
6031 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165828"];
6032 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 165829"];
6033 [label="MoveToNextToken() 165830"];
6034 [label="param MoveToNextToken(this) 165831"];
6035 [label="param GetTrailingTrivia(this) 165832"];
6036 [label="return null; 165833"];
6037 [label="_prevTokenTrailingTrivia 165834"];
6038 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 165835"];
6039 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 165836"];
6040 [label="_tokenOffset 165837"];
6041 [label="MoveToNextToken(); 165838"];
6042 [label="this.EatToken(); 165839"];
6043 [label="this.CurrentToken 165840"];
6044 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165841"];
6045 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165842"];
6046 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 165843"];
6047 [label="return _lexedTokens[_tokenOffset]; 165844"];
6048 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.RefKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                            {\n                                this.EatToken();\n                            }\n                            break;\n                        case SyntaxKind.OutKeyword:\n                        case SyntaxKind.InKeyword:\n                        case SyntaxKind.ParamsKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            break;\n                    } 165845"];
6049 [label="this.CurrentToken.Kind 165846"];
6050 [label="get { return (SyntaxKind)this.RawKind; } 165847"];
6051 [label="this.CurrentToken 165848"];
6052 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165849"];
6053 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165850"];
6054 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        return foundParameterModifier;\n                    } 165851"];
6055 [label="this.CurrentToken.Kind 165852"];
6056 [label="get { return (SyntaxKind)this.RawKind; } 165853"];
6057 [label="if (this.ScanType() == ScanTypeFlags.NotType)\n                    {\n                        return false;\n                    } 165854"];
6058 [label="this.ScanType() 165855"];
6059 [label="param ScanType(bool forPattern = false) 165856"];
6060 [label="param ScanType(this) 165857"];
6061 [label="return ScanType(out _, forPattern); 165858"];
6062 [label="return ScanType(out _, forPattern); 165859"];
6063 [label="ScanType(out _, forPattern) 165860"];
6064 [label="param ScanType(out SyntaxToken lastTokenOfType) 165861"];
6065 [label="param ScanType(bool forPattern = false) 165862"];
6066 [label="param ScanType(this) 165863"];
6067 [label="forPattern 165864"];
6068 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 165865"];
6069 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 165866"];
6070 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 165867"];
6071 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 165868"];
6072 [label="Debug.Assert(n >= 0); 165869"];
6073 [label="Debug.Assert(n >= 0); 165870"];
6074 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165871"];
6075 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 165872"];
6076 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 165873"];
6077 [label="this.CurrentToken 165874"];
6078 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165875"];
6079 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 165876"];
6080 [label="this.CurrentToken.Kind 165877"];
6081 [label="get { return (SyntaxKind)this.RawKind; } 165878"];
6082 [label="this.IsTrueIdentifier() 165879"];
6083 [label="param IsTrueIdentifier(this) 165880"];
6084 [label="this.CurrentToken 165881"];
6085 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165882"];
6086 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 165883"];
6087 [label="this.CurrentToken.Kind 165884"];
6088 [label="get { return (SyntaxKind)this.RawKind; } 165885"];
6089 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 165886"];
6090 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 165887"];
6091 [label="this.CurrentToken 165888"];
6092 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165889"];
6093 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 165890"];
6094 [label="this.CurrentToken.ContextualKind 165891"];
6095 [label="get\n            {\n                return this.Kind;\n            } 165892"];
6096 [label="return false; 165893"];
6097 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 165894"];
6098 [label="IsCurrentTokenQueryKeywordInQuery() 165895"];
6099 [label="param IsCurrentTokenQueryKeywordInQuery(this) 165896"];
6100 [label="this.IsInQuery 165897"];
6101 [label="get { return _syntaxFactoryContext.IsInQuery; } 165898"];
6102 [label="return _syntaxFactoryContext.IsInQuery; 165899"];
6103 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 165900"];
6104 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 165901"];
6105 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 165902"];
6106 [label="IsCurrentTokenWhereOfConstraintClause() 165903"];
6107 [label="param IsCurrentTokenWhereOfConstraintClause(this) 165904"];
6108 [label="this.CurrentToken 165905"];
6109 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165906"];
6110 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 165907"];
6111 [label="this.CurrentToken.ContextualKind 165908"];
6112 [label="get\n            {\n                return this.Kind;\n            } 165909"];
6113 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 165910"];
6114 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 165911"];
6115 [label="return true; 165912"];
6116 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 165913"];
6117 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 165914"];
6118 [label="this.EatToken() 165915"];
6119 [label="this.CurrentToken 165916"];
6120 [label="MoveToNextToken() 165917"];
6121 [label="param GetTrailingTrivia(this) 165918"];
6122 [label="return null; 165919"];
6123 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 165920"];
6124 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 165921"];
6125 [label="MoveToNextToken(); 165922"];
6126 [label="this.CurrentToken 165923"];
6127 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165924"];
6128 [label="this.CurrentToken.Kind 165925"];
6129 [label="this.CurrentToken 165926"];
6130 [label="this.CurrentToken.Kind 165927"];
6131 [label="this.CurrentToken 165928"];
6132 [label="this.CurrentToken.Kind 165929"];
6133 [label="param IsMakingProgress(bool assertIfFalse = true) 165930"];
6134 [label="CurrentTokenPosition 165931"];
6135 [label="this.IsTrueIdentifier() 165932"];
6136 [label="param IsTrueIdentifier(this) 165933"];
6137 [label="this.CurrentToken 165934"];
6138 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165935"];
6139 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165936"];
6140 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 165937"];
6141 [label="this.CurrentToken.Kind 165938"];
6142 [label="get { return (SyntaxKind)this.RawKind; } 165939"];
6143 [label="return false; 165940"];
6144 [label="if (this.IsTrueIdentifier())\n                    {\n                        // eat the identifier\n                        this.EatToken();\n                    } 165941"];
6145 [label="this.CurrentToken 165942"];
6146 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 165943"];
6147 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 165944"];
6148 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.EndOfFileToken:\n                            return foundParameterModifier;\n\n                        case SyntaxKind.CommaToken:\n                            if (foundParameterModifier)\n                            {\n                                return true;\n                            }\n\n                            continue;\n\n                        case SyntaxKind.CloseParenToken:\n                            return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken;\n\n                        default:\n                            return false;\n                    } 165945"];
6149 [label="this.CurrentToken.Kind 165946"];
6150 [label="get { return (SyntaxKind)this.RawKind; } 165947"];
6151 [label="return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken; 165948"];
6152 [label="this.PeekToken(1) 165949"];
6153 [label="param PeekToken(int n) 165950"];
6154 [label="Debug.Assert(n >= 0); 165951"];
6155 [label="Debug.Assert(n >= 0); 165952"];
6156 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 165953"];
6157 [label="this.PeekToken(1).Kind 165954"];
6158 [label="get { return (SyntaxKind)this.RawKind; } 165955"];
6159 [label="this.Reset(ref resetPoint); 165956"];
6160 [label="this.Reset(ref resetPoint) 165957"];
6161 [label="param Reset(ref ResetPoint state) 165958"];
6162 [label="Debug.Assert(offset >= 0); 165959"];
6163 [label="Debug.Assert(offset >= 0); 165960"];
6164 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 165961"];
6165 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 165962"];
6166 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 165963"];
6167 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 165964"];
6168 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 165965"];
6169 [label="this.Reset(ref resetPoint); 165966"];
6170 [label="this.Release(ref resetPoint); 165967"];
6171 [label="this.Release(ref resetPoint) 165968"];
6172 [label="param Release(ref ResetPoint state) 165969"];
6173 [label="param Release(this) 165970"];
6174 [label="base.Release(ref state.BaseResetPoint); 165971"];
6175 [label="base.Release(ref state.BaseResetPoint) 165972"];
6176 [label="param Release(ref ResetPoint point) 165973"];
6177 [label="param Release(this) 165974"];
6178 [label="Debug.Assert(_resetCount == point.ResetCount); 165975"];
6179 [label="_resetCount 165976"];
6180 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 165977"];
6181 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 165978"];
6182 [label="base.Release(ref state.BaseResetPoint); 165979"];
6183 [label="this.Release(ref resetPoint); 165980"];
6184 [label="if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 165981"];
6185 [label="this.Reset(ref resetPoint); 165982"];
6186 [label="this.Reset(ref resetPoint) 165983"];
6187 [label="param Reset(ref ResetPoint state) 165984"];
6188 [label="param Reset(this) 165985"];
6189 [label="_termState 165986"];
6190 [label="_isInTry 165987"];
6191 [label="_syntaxFactoryContext.IsInAsync 165988"];
6192 [label="_syntaxFactoryContext.QueryDepth 165989"];
6193 [label="base.Reset(ref state.BaseResetPoint); 165990"];
6194 [label="base.Reset(ref state.BaseResetPoint) 165991"];
6195 [label="param Reset(this) 165992"];
6196 [label="var offset = point.Position - _firstToken; 165993"];
6197 [label="Debug.Assert(offset >= 0); 165994"];
6198 [label="Debug.Assert(offset >= 0); 165995"];
6199 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 165996"];
6200 [label="_mode 165997"];
6201 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 165998"];
6202 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 165999"];
6203 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 166000"];
6204 [label="_currentToken = null; 166001"];
6205 [label="_currentToken 166002"];
6206 [label="_currentNode = default(BlendedNode); 166003"];
6207 [label="_currentNode 166004"];
6208 [label="_prevTokenTrailingTrivia 166005"];
6209 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 166006"];
6210 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 166007"];
6211 [label="base.Reset(ref state.BaseResetPoint); 166008"];
6212 [label="this.Reset(ref resetPoint); 166009"];
6213 [label="var openParen = this.EatToken(SyntaxKind.OpenParenToken); 166010"];
6214 [label="this.EatToken(SyntaxKind.OpenParenToken) 166011"];
6215 [label="param EatToken(SyntaxKind kind) 166012"];
6216 [label="param EatToken(this) 166013"];
6217 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 166014"];
6218 [label="SyntaxFacts.IsAnyToken(kind) 166015"];
6219 [label="param IsAnyToken(SyntaxKind kind) 166016"];
6220 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 166017"];
6221 [label="return true; 166018"];
6222 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166019"];
6223 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 166020"];
6224 [label="return _lexedTokens[_tokenOffset]; 166021"];
6225 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 166022"];
6226 [label="param GetTrailingTrivia(this) 166023"];
6227 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 166024"];
6228 [label="MoveToNextToken(); 166025"];
6229 [label="return ct; 166026"];
6230 [label="var expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true); 166027"];
6231 [label="var expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true); 166028"];
6232 [label="this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true) 166029"];
6233 [label="param ParseExpressionOrDeclaration(ParseTypeMode mode) 166030"];
6234 [label="param ParseExpressionOrDeclaration(MessageID feature) 166031"];
6235 [label="param ParseExpressionOrDeclaration(bool permitTupleDesignation) 166032"];
6236 [label="param ParseExpressionOrDeclaration(this) 166033"];
6237 [label="return IsPossibleDeclarationExpression(mode, permitTupleDesignation)\n                ? this.ParseDeclarationExpression(mode, feature)\n                : this.ParseSubExpression(Precedence.Expression); 166034"];
6238 [label="return IsPossibleDeclarationExpression(mode, permitTupleDesignation)\n                ? this.ParseDeclarationExpression(mode, feature)\n                : this.ParseSubExpression(Precedence.Expression); 166035"];
6239 [label="IsPossibleDeclarationExpression(mode, permitTupleDesignation) 166036"];
6240 [label="param IsPossibleDeclarationExpression(ParseTypeMode mode) 166037"];
6241 [label="param IsPossibleDeclarationExpression(bool permitTupleDesignation) 166038"];
6242 [label="param IsPossibleDeclarationExpression(this) 166039"];
6243 [label="this.IsInAsync 166040"];
6244 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 166041"];
6245 [label="return _syntaxFactoryContext.IsInAsync; 166042"];
6246 [label="if (this.IsInAsync && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                // can't be a declaration expression.\n                return false;\n            } 166043"];
6247 [label="this.GetResetPoint() 166044"];
6248 [label="param GetResetPoint(this) 166045"];
6249 [label="_firstToken + _tokenOffset 166046"];
6250 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 166047"];
6251 [label="_resetCount 166048"];
6252 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 166049"];
6253 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 166050"];
6254 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 166051"];
6255 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 166052"];
6256 [label="param ResetPoint(this) 166053"];
6257 [label="var resetPoint = this.GetResetPoint(); 166054"];
6258 [label="IsVarType() 166055"];
6259 [label="param IsVarType(this) 166056"];
6260 [label="this.CurrentToken 166057"];
6261 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166058"];
6262 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166059"];
6263 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 166060"];
6264 [label="if (!this.CurrentToken.IsIdentifierVar())\n            {\n                return false;\n            } 166061"];
6265 [label="this.CurrentToken.IsIdentifierVar() 166062"];
6266 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 166063"];
6267 [label="return false; 166064"];
6268 [label="bool typeIsVar = IsVarType(); 166065"];
6269 [label="SyntaxToken lastTokenOfType; 166066"];
6270 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 166067"];
6271 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 166068"];
6272 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 166069"];
6273 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 166070"];
6274 [label="Debug.Assert(n >= 0); 166071"];
6275 [label="Debug.Assert(n >= 0); 166072"];
6276 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166073"];
6277 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 166074"];
6278 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 166075"];
6279 [label="this.CurrentToken 166076"];
6280 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166077"];
6281 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 166078"];
6282 [label="this.CurrentToken.Kind 166079"];
6283 [label="get { return (SyntaxKind)this.RawKind; } 166080"];
6284 [label="this.IsTrueIdentifier() 166081"];
6285 [label="param IsTrueIdentifier(this) 166082"];
6286 [label="this.CurrentToken 166083"];
6287 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166084"];
6288 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 166085"];
6289 [label="this.CurrentToken.Kind 166086"];
6290 [label="get { return (SyntaxKind)this.RawKind; } 166087"];
6291 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 166088"];
6292 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 166089"];
6293 [label="this.CurrentToken 166090"];
6294 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166091"];
6295 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 166092"];
6296 [label="this.CurrentToken.ContextualKind 166093"];
6297 [label="get\n            {\n                return this.Kind;\n            } 166094"];
6298 [label="return false; 166095"];
6299 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 166096"];
6300 [label="IsCurrentTokenQueryKeywordInQuery() 166097"];
6301 [label="param IsCurrentTokenQueryKeywordInQuery(this) 166098"];
6302 [label="this.IsInQuery 166099"];
6303 [label="get { return _syntaxFactoryContext.IsInQuery; } 166100"];
6304 [label="return _syntaxFactoryContext.IsInQuery; 166101"];
6305 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 166102"];
6306 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 166103"];
6307 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 166104"];
6308 [label="IsCurrentTokenWhereOfConstraintClause() 166105"];
6309 [label="param IsCurrentTokenWhereOfConstraintClause(this) 166106"];
6310 [label="this.CurrentToken 166107"];
6311 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166108"];
6312 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 166109"];
6313 [label="this.CurrentToken.ContextualKind 166110"];
6314 [label="get\n            {\n                return this.Kind;\n            } 166111"];
6315 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 166112"];
6316 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 166113"];
6317 [label="return true; 166114"];
6318 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 166115"];
6319 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 166116"];
6320 [label="this.EatToken() 166117"];
6321 [label="this.CurrentToken 166118"];
6322 [label="MoveToNextToken() 166119"];
6323 [label="param GetTrailingTrivia(this) 166120"];
6324 [label="return null; 166121"];
6325 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 166122"];
6326 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 166123"];
6327 [label="MoveToNextToken(); 166124"];
6328 [label="this.CurrentToken 166125"];
6329 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166126"];
6330 [label="this.CurrentToken.Kind 166127"];
6331 [label="this.CurrentToken 166128"];
6332 [label="this.CurrentToken.Kind 166129"];
6333 [label="this.CurrentToken 166130"];
6334 [label="this.CurrentToken.Kind 166131"];
6335 [label="param IsMakingProgress(bool assertIfFalse = true) 166132"];
6336 [label="CurrentTokenPosition 166133"];
6337 [label="lastTokenOfType.Kind 166134"];
6338 [label="get { return (SyntaxKind)this.RawKind; } 166135"];
6339 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 166136"];
6340 [label="IsPredefinedType(lastTokenOfType.Kind) 166137"];
6341 [label="param IsPredefinedType(SyntaxKind keyword) 166138"];
6342 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 166139"];
6343 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 166140"];
6344 [label="ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))) 166141"];
6345 [label="param ScanDesignation(bool permitTuple) 166142"];
6346 [label="param ScanDesignation(this) 166143"];
6347 [label="this.CurrentToken 166144"];
6348 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166145"];
6349 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166146"];
6350 [label="switch (this.CurrentToken.Kind)\n            {\n                default:\n                    return false;\n                case SyntaxKind.IdentifierToken:\n                    bool result = this.IsTrueIdentifier();\n                    this.EatToken();\n                    return result;\n                case SyntaxKind.OpenParenToken:\n                    if (!permitTuple)\n                    {\n                        return false;\n                    }\n\n                    bool sawComma = false;\n                    while (true)\n                    {\n                        this.EatToken(); // consume the `(` or `,`\n                        if (!ScanDesignation(permitTuple: true))\n                        {\n                            return false;\n                        }\n                        switch (this.CurrentToken.Kind)\n                        {\n                            case SyntaxKind.CloseParenToken:\n                                this.EatToken();\n                                return sawComma;\n                            case SyntaxKind.CommaToken:\n                                sawComma = true;\n                                continue;\n                            default:\n                                return false;\n                        }\n                    }\n            } 166147"];
6351 [label="this.CurrentToken.Kind 166148"];
6352 [label="get { return (SyntaxKind)this.RawKind; } 166149"];
6353 [label="return false; 166150"];
6354 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 166151"];
6355 [label="return false; 166152"];
6356 [label="this.Reset(ref resetPoint); 166153"];
6357 [label="this.Reset(ref resetPoint) 166154"];
6358 [label="param Reset(ref ResetPoint state) 166155"];
6359 [label="Debug.Assert(offset >= 0); 166156"];
6360 [label="Debug.Assert(offset >= 0); 166157"];
6361 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 166158"];
6362 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 166159"];
6363 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 166160"];
6364 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 166161"];
6365 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 166162"];
6366 [label="this.Reset(ref resetPoint); 166163"];
6367 [label="this.Release(ref resetPoint); 166164"];
6368 [label="this.Release(ref resetPoint) 166165"];
6369 [label="param Release(ref ResetPoint state) 166166"];
6370 [label="base.Release(ref state.BaseResetPoint); 166167"];
6371 [label="param Release(ref ResetPoint point) 166168"];
6372 [label="Debug.Assert(_resetCount == point.ResetCount); 166169"];
6373 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 166170"];
6374 [label="base.Release(ref state.BaseResetPoint); 166171"];
6375 [label="this.Release(ref resetPoint); 166172"];
6376 [label="this.ParseSubExpression(Precedence.Expression) 166173"];
6377 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 166174"];
6378 [label="ExpressionSyntax leftOperand; 166175"];
6379 [label="Precedence newPrecedence = 0; 166176"];
6380 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166177"];
6381 [label="return _lexedTokens[_tokenOffset]; 166178"];
6382 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 166179"];
6383 [label="IsInvalidSubExpression(tk) 166180"];
6384 [label="param IsInvalidSubExpression(SyntaxKind kind) 166181"];
6385 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 166182"];
6386 [label="return false; 166183"];
6387 [label="param IsAwaitExpression(this) 166184"];
6388 [label="this.CurrentToken 166185"];
6389 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166186"];
6390 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 166187"];
6391 [label="this.CurrentToken.ContextualKind 166188"];
6392 [label="get\n            {\n                return this.Kind;\n            } 166189"];
6393 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 166190"];
6394 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 166191"];
6395 [label="param IsQueryExpression(this) 166192"];
6396 [label="this.CurrentToken 166193"];
6397 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166194"];
6398 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 166195"];
6399 [label="this.CurrentToken.ContextualKind 166196"];
6400 [label="get\n            {\n                return this.Kind;\n            } 166197"];
6401 [label="leftOperand = this.ParseTerm(precedence); 166198"];
6402 [label="param ParseTerm(Precedence precedence) 166199"];
6403 [label="precedence 166200"];
6404 [label="param ParseTermWithoutPostfix(Precedence precedence) 166201"];
6405 [label="this.IsTrueIdentifier() 166202"];
6406 [label="param IsTrueIdentifier(this) 166203"];
6407 [label="this.CurrentToken 166204"];
6408 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166205"];
6409 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 166206"];
6410 [label="this.CurrentToken.Kind 166207"];
6411 [label="get { return (SyntaxKind)this.RawKind; } 166208"];
6412 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 166209"];
6413 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 166210"];
6414 [label="this.CurrentToken 166211"];
6415 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166212"];
6416 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 166213"];
6417 [label="this.CurrentToken.ContextualKind 166214"];
6418 [label="get\n            {\n                return this.Kind;\n            } 166215"];
6419 [label="return false; 166216"];
6420 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 166217"];
6421 [label="IsCurrentTokenQueryKeywordInQuery() 166218"];
6422 [label="param IsCurrentTokenQueryKeywordInQuery(this) 166219"];
6423 [label="this.IsInQuery 166220"];
6424 [label="get { return _syntaxFactoryContext.IsInQuery; } 166221"];
6425 [label="return _syntaxFactoryContext.IsInQuery; 166222"];
6426 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 166223"];
6427 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 166224"];
6428 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 166225"];
6429 [label="IsCurrentTokenWhereOfConstraintClause() 166226"];
6430 [label="param IsCurrentTokenWhereOfConstraintClause(this) 166227"];
6431 [label="this.CurrentToken 166228"];
6432 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166229"];
6433 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 166230"];
6434 [label="this.CurrentToken.ContextualKind 166231"];
6435 [label="get\n            {\n                return this.Kind;\n            } 166232"];
6436 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 166233"];
6437 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 166234"];
6438 [label="return true; 166235"];
6439 [label="if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    } 166236"];
6440 [label="this.IsPossibleAnonymousMethodExpression() 166237"];
6441 [label="param IsPossibleAnonymousMethodExpression(this) 166238"];
6442 [label="var tokenIndex = 0; 166239"];
6443 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 166240"];
6444 [label="this.PeekToken(tokenIndex) 166241"];
6445 [label="param PeekToken(int n) 166242"];
6446 [label="param PeekToken(this) 166243"];
6447 [label="Debug.Assert(n >= 0); 166244"];
6448 [label="Debug.Assert(n >= 0); 166245"];
6449 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166246"];
6450 [label="return _lexedTokens[_tokenOffset + n]; 166247"];
6451 [label="this.PeekToken(tokenIndex).Kind 166248"];
6452 [label="get { return (SyntaxKind)this.RawKind; } 166249"];
6453 [label="this.PeekToken(tokenIndex) 166250"];
6454 [label="param PeekToken(int n) 166251"];
6455 [label="param PeekToken(this) 166252"];
6456 [label="Debug.Assert(n >= 0); 166253"];
6457 [label="Debug.Assert(n >= 0); 166254"];
6458 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166255"];
6459 [label="return _lexedTokens[_tokenOffset + n]; 166256"];
6460 [label="this.PeekToken(tokenIndex).ContextualKind 166257"];
6461 [label="get\n            {\n                return this.Kind;\n            } 166258"];
6462 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 166259"];
6463 [label="return this.PeekToken(tokenIndex).Kind == SyntaxKind.DelegateKeyword; 166260"];
6464 [label="this.PeekToken(tokenIndex) 166261"];
6465 [label="param PeekToken(int n) 166262"];
6466 [label="param PeekToken(this) 166263"];
6467 [label="Debug.Assert(n >= 0); 166264"];
6468 [label="Debug.Assert(n >= 0); 166265"];
6469 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166266"];
6470 [label="return _lexedTokens[_tokenOffset + n]; 166267"];
6471 [label="this.PeekToken(tokenIndex).Kind 166268"];
6472 [label="get { return (SyntaxKind)this.RawKind; } 166269"];
6473 [label="if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 166270"];
6474 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 166271"];
6475 [label="this.IsPossibleLambdaExpression(precedence) 166272"];
6476 [label="param IsPossibleLambdaExpression(Precedence precedence) 166273"];
6477 [label="param IsPossibleLambdaExpression(this) 166274"];
6478 [label="this.CurrentToken 166275"];
6479 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166276"];
6480 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 166277"];
6481 [label="this.CurrentToken.Kind 166278"];
6482 [label="get { return (SyntaxKind)this.RawKind; } 166279"];
6483 [label="this.CurrentToken 166280"];
6484 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166281"];
6485 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 166282"];
6486 [label="this.IsTrueIdentifier(this.CurrentToken) 166283"];
6487 [label="param IsTrueIdentifier(SyntaxToken token) 166284"];
6488 [label="param IsTrueIdentifier(this) 166285"];
6489 [label="token.Kind 166286"];
6490 [label="get { return (SyntaxKind)this.RawKind; } 166287"];
6491 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 166288"];
6492 [label="this.IsInQuery 166289"];
6493 [label="get { return _syntaxFactoryContext.IsInQuery; } 166290"];
6494 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 166291"];
6495 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 166292"];
6496 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 166293"];
6497 [label="if (precedence > Precedence.Lambda)\n            {\n                return false;\n            } 166294"];
6498 [label="int peekIndex; 166295"];
6499 [label="bool seenStatic; 166296"];
6500 [label="this.CurrentToken 166297"];
6501 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166298"];
6502 [label="if (this.CurrentToken.Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 1;\n                seenStatic = true;\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 166299"];
6503 [label="this.CurrentToken.Kind 166300"];
6504 [label="get { return (SyntaxKind)this.RawKind; } 166301"];
6505 [label="this.CurrentToken 166302"];
6506 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 166303"];
6507 [label="this.CurrentToken.ContextualKind 166304"];
6508 [label="get\n            {\n                return this.Kind;\n            } 166305"];
6509 [label="peekIndex = 0; 166306"];
6510 [label="seenStatic = false; 166307"];
6511 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on => then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static =>`\n                // 2. `async static =>`\n\n                // This is an error case, but we have enough code in front of us to be certain\n                // the user was trying to write a static lambda.\n                return true;\n            } 166308"];
6512 [label="this.PeekToken(peekIndex) 166309"];
6513 [label="param PeekToken(int n) 166310"];
6514 [label="param PeekToken(this) 166311"];
6515 [label="Debug.Assert(n >= 0); 166312"];
6516 [label="Debug.Assert(n >= 0); 166313"];
6517 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166314"];
6518 [label="this.PeekToken(peekIndex).Kind 166315"];
6519 [label="get { return (SyntaxKind)this.RawKind; } 166316"];
6520 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 166317"];
6521 [label="this.PeekToken(peekIndex) 166318"];
6522 [label="param PeekToken(int n) 166319"];
6523 [label="param PeekToken(this) 166320"];
6524 [label="Debug.Assert(n >= 0); 166321"];
6525 [label="Debug.Assert(n >= 0); 166322"];
6526 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166323"];
6527 [label="this.PeekToken(peekIndex).Kind 166324"];
6528 [label="get { return (SyntaxKind)this.RawKind; } 166325"];
6529 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 166326"];
6530 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 166327"];
6531 [label="this.PeekToken(peekIndex + 1) 166328"];
6532 [label="param PeekToken(int n) 166329"];
6533 [label="param PeekToken(this) 166330"];
6534 [label="Debug.Assert(n >= 0); 166331"];
6535 [label="Debug.Assert(n >= 0); 166332"];
6536 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166333"];
6537 [label="this.PeekToken(peekIndex + 1).Kind 166334"];
6538 [label="get { return (SyntaxKind)this.RawKind; } 166335"];
6539 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 166336"];
6540 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on ( then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static (...\n                // 2. `async static (...\n                return true;\n            } 166337"];
6541 [label="this.PeekToken(peekIndex) 166338"];
6542 [label="param PeekToken(int n) 166339"];
6543 [label="param PeekToken(this) 166340"];
6544 [label="Debug.Assert(n >= 0); 166341"];
6545 [label="Debug.Assert(n >= 0); 166342"];
6546 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166343"];
6547 [label="this.PeekToken(peekIndex).Kind 166344"];
6548 [label="get { return (SyntaxKind)this.RawKind; } 166345"];
6549 [label="if (this.PeekToken(peekIndex).ContextualKind != SyntaxKind.AsyncKeyword)\n            {\n                return false;\n            } 166346"];
6550 [label="this.PeekToken(peekIndex) 166347"];
6551 [label="param PeekToken(int n) 166348"];
6552 [label="param PeekToken(this) 166349"];
6553 [label="Debug.Assert(n >= 0); 166350"];
6554 [label="Debug.Assert(n >= 0); 166351"];
6555 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166352"];
6556 [label="this.PeekToken(peekIndex).ContextualKind 166353"];
6557 [label="get\n            {\n                return this.Kind;\n            } 166354"];
6558 [label="return false; 166355"];
6559 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 166356"];
6560 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 166357"];
6561 [label="this.IsPossibleDeconstructionLeft(precedence) 166358"];
6562 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 166359"];
6563 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 166360"];
6564 [label="this.ParseAliasQualifiedName(NameOptions.InExpression) 166361"];
6565 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 166362"];
6566 [label="param ParseAliasQualifiedName(this) 166363"];
6567 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 166364"];
6568 [label="this.ParseSimpleName(allowedParts) 166365"];
6569 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 166366"];
6570 [label="param ParseSimpleName(this) 166367"];
6571 [label="var id = this.ParseIdentifierName(); 166368"];
6572 [label="this.ParseIdentifierName() 166369"];
6573 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 166370"];
6574 [label="param ParseIdentifierName(this) 166371"];
6575 [label="this.IsIncrementalAndFactoryContextMatches 166372"];
6576 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 166373"];
6577 [label="base.IsIncremental 166374"];
6578 [label="get\n            {\n                return _isIncremental;\n            } 166375"];
6579 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 166376"];
6580 [label="return false; 166377"];
6581 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 166378"];
6582 [label="var tk = ParseIdentifierToken(code); 166379"];
6583 [label="ParseIdentifierToken(code) 166380"];
6584 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 166381"];
6585 [label="param ParseIdentifierToken(this) 166382"];
6586 [label="this.CurrentToken 166383"];
6587 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166384"];
6588 [label="var ctk = this.CurrentToken.Kind; 166385"];
6589 [label="this.CurrentToken.Kind 166386"];
6590 [label="get { return (SyntaxKind)this.RawKind; } 166387"];
6591 [label="if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Goo {\n                // } Because we're parsing an attribute argument we'll end up consuming the 'partial' identifier and\n                // we'll eventually end up in a pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see 'partial' we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, code);\n                return name;\n            } 166388"];
6592 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 166389"];
6593 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 166390"];
6594 [label="this.CurrentToken 166391"];
6595 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166392"];
6596 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 166393"];
6597 [label="this.CurrentToken.ContextualKind 166394"];
6598 [label="get\n            {\n                return this.Kind;\n            } 166395"];
6599 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 166396"];
6600 [label="IsCurrentTokenQueryKeywordInQuery() 166397"];
6601 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 166398"];
6602 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 166399"];
6603 [label="this.EatToken() 166400"];
6604 [label="param GetTrailingTrivia(this) 166401"];
6605 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 166402"];
6606 [label="MoveToNextToken(); 166403"];
6607 [label="SyntaxToken identifierToken = this.EatToken(); 166404"];
6608 [label="this.IsInAsync 166405"];
6609 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 166406"];
6610 [label="return _syntaxFactoryContext.IsInAsync; 166407"];
6611 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 166408"];
6612 [label="return identifierToken; 166409"];
6613 [label="var tk = ParseIdentifierToken(code); 166410"];
6614 [label="return SyntaxFactory.IdentifierName(tk); 166411"];
6615 [label="return SyntaxFactory.IdentifierName(tk); 166412"];
6616 [label="param CSharpSyntaxNode(SyntaxKind kind) 166413"];
6617 [label="param CSharpSyntaxNode(this) 166414"];
6618 [label="kind 166415"];
6619 [label="param CSharpSyntaxNode(this) 166416"];
6620 [label="param CSharpSyntaxNode(this) 166417"];
6621 [label="GreenStats.NoteGreen(this); 166418"];
6622 [label="GreenStats.NoteGreen(this); 166419"];
6623 [label="var id = this.ParseIdentifierName(); 166420"];
6624 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 166421"];
6625 [label="SimpleNameSyntax name = id; 166422"];
6626 [label="this.CurrentToken 166423"];
6627 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166424"];
6628 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166425"];
6629 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 166426"];
6630 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 166427"];
6631 [label="this.CurrentToken.Kind 166428"];
6632 [label="get { return (SyntaxKind)this.RawKind; } 166429"];
6633 [label="return name; 166430"];
6634 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 166431"];
6635 [label="this.CurrentToken 166432"];
6636 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166433"];
6637 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166434"];
6638 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 166435"];
6639 [label="this.CurrentToken.Kind 166436"];
6640 [label="get { return (SyntaxKind)this.RawKind; } 166437"];
6641 [label="return name; 166438"];
6642 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 166439"];
6643 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 166440"];
6644 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 166441"];
6645 [label="return ParseExpressionContinued(leftOperand, precedence); 166442"];
6646 [label="return ParseExpressionContinued(leftOperand, precedence); 166443"];
6647 [label="ParseExpressionContinued(leftOperand, precedence) 166444"];
6648 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 166445"];
6649 [label="param ParseExpressionContinued(Precedence precedence) 166446"];
6650 [label="param ParseExpressionContinued(this) 166447"];
6651 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 166448"];
6652 [label="this.CurrentToken 166449"];
6653 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166450"];
6654 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166451"];
6655 [label="var tk = this.CurrentToken.ContextualKind; 166452"];
6656 [label="this.CurrentToken.ContextualKind 166453"];
6657 [label="get\n            {\n                return this.Kind;\n            } 166454"];
6658 [label="bool isAssignmentOperator = false; 166455"];
6659 [label="SyntaxKind opKind; 166456"];
6660 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166457"];
6661 [label="IsExpectedBinaryOperator(tk) 166458"];
6662 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 166459"];
6663 [label="return SyntaxFacts.IsBinaryExpression(kind); 166460"];
6664 [label="SyntaxFacts.IsBinaryExpression(kind) 166461"];
6665 [label="param IsBinaryExpression(SyntaxKind token) 166462"];
6666 [label="return GetBinaryExpression(token) != SyntaxKind.None; 166463"];
6667 [label="GetBinaryExpression(token) 166464"];
6668 [label="param GetBinaryExpression(SyntaxKind token) 166465"];
6669 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 166466"];
6670 [label="return SyntaxKind.None; 166467"];
6671 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166468"];
6672 [label="IsExpectedAssignmentOperator(tk) 166469"];
6673 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 166470"];
6674 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 166471"];
6675 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 166472"];
6676 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 166473"];
6677 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 166474"];
6678 [label="return false; 166475"];
6679 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166476"];
6680 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166477"];
6681 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166478"];
6682 [label="CurrentToken 166479"];
6683 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166480"];
6684 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166481"];
6685 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 166482"];
6686 [label="CurrentToken.Kind 166483"];
6687 [label="get { return (SyntaxKind)this.RawKind; } 166484"];
6688 [label="return leftOperand; 166485"];
6689 [label="_ = GetPrecedence(result.Kind); 166486"];
6690 [label="result.Kind 166487"];
6691 [label="get { return (SyntaxKind)this.RawKind; } 166488"];
6692 [label="_ = GetPrecedence(result.Kind); 166489"];
6693 [label="GetPrecedence(result.Kind) 166490"];
6694 [label="param GetPrecedence(SyntaxKind op) 166491"];
6695 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 166492"];
6696 [label="return Precedence.Primary; 166493"];
6697 [label="_recursionDepth 166494"];
6698 [label="return result; 166495"];
6699 [label="this.CurrentToken 166496"];
6700 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166497"];
6701 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166498"];
6702 [label="if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        var firstArg = _syntaxFactory.Argument(nameColon: null, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 166499"];
6703 [label="this.CurrentToken.Kind 166500"];
6704 [label="get { return (SyntaxKind)this.RawKind; } 166501"];
6705 [label="expression.Kind 166502"];
6706 [label="get { return (SyntaxKind)this.RawKind; } 166503"];
6707 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 166504"];
6708 [label="this.CurrentToken 166505"];
6709 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166506"];
6710 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166507"];
6711 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 166508"];
6712 [label="this.CurrentToken.Kind 166509"];
6713 [label="get { return (SyntaxKind)this.RawKind; } 166510"];
6714 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 166511"];
6715 [label="var closeParen = this.EatToken(SyntaxKind.CloseParenToken); 166512"];
6716 [label="this.EatToken(SyntaxKind.CloseParenToken) 166513"];
6717 [label="param EatToken(SyntaxKind kind) 166514"];
6718 [label="param EatToken(this) 166515"];
6719 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 166516"];
6720 [label="SyntaxFacts.IsAnyToken(kind) 166517"];
6721 [label="param IsAnyToken(SyntaxKind kind) 166518"];
6722 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 166519"];
6723 [label="return true; 166520"];
6724 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166521"];
6725 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 166522"];
6726 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 166523"];
6727 [label="MoveToNextToken(); 166524"];
6728 [label="return ct; 166525"];
6729 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 166526"];
6730 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 166527"];
6731 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 166528"];
6732 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 166529"];
6733 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 166530"];
6734 [label="param TryGetNode(int kind) 166531"];
6735 [label="param TryGetNode(GreenNode child1) 166532"];
6736 [label="param TryGetNode(GreenNode child2) 166533"];
6737 [label="param TryGetNode(GreenNode child3) 166534"];
6738 [label="param TryGetNode(SyntaxFactoryContext context) 166535"];
6739 [label="param TryGetNode(out int hash) 166536"];
6740 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 166537"];
6741 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 166538"];
6742 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 166539"];
6743 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 166540"];
6744 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 166541"];
6745 [label="GetNodeFlags(context) 166542"];
6746 [label="param GetNodeFlags(SyntaxFactoryContext context) 166543"];
6747 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 166544"];
6748 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 166545"];
6749 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 166546"];
6750 [label="return flags; 166547"];
6751 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 166548"];
6752 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 166549"];
6753 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 166550"];
6754 [label="param CSharpSyntaxNode(this) 166551"];
6755 [label="GreenStats.NoteGreen(this); 166552"];
6756 [label="param SetFactoryContext(SyntaxFactoryContext context) 166553"];
6757 [label="param SetFactoryContext(this) 166554"];
6758 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 166555"];
6759 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 166556"];
6760 [label="this.Release(ref resetPoint); 166557"];
6761 [label="this.Release(ref resetPoint) 166558"];
6762 [label="param Release(ref ResetPoint state) 166559"];
6763 [label="param Release(this) 166560"];
6764 [label="base.Release(ref state.BaseResetPoint); 166561"];
6765 [label="base.Release(ref state.BaseResetPoint) 166562"];
6766 [label="param Release(ref ResetPoint point) 166563"];
6767 [label="param Release(this) 166564"];
6768 [label="Debug.Assert(_resetCount == point.ResetCount); 166565"];
6769 [label="_resetCount 166566"];
6770 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 166567"];
6771 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 166568"];
6772 [label="base.Release(ref state.BaseResetPoint); 166569"];
6773 [label="this.Release(ref resetPoint); 166570"];
6774 [label="return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence); 166571"];
6775 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 166572"];
6776 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 166573"];
6777 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166574"];
6778 [label="return ParseExpressionContinued(leftOperand, precedence); 166575"];
6779 [label="ParseExpressionContinued(leftOperand, precedence) 166576"];
6780 [label="param ParseExpressionContinued(Precedence precedence) 166577"];
6781 [label="param ParseExpressionContinued(this) 166578"];
6782 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 166579"];
6783 [label="this.CurrentToken 166580"];
6784 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166581"];
6785 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166582"];
6786 [label="var tk = this.CurrentToken.ContextualKind; 166583"];
6787 [label="this.CurrentToken.ContextualKind 166584"];
6788 [label="get\n            {\n                return this.Kind;\n            } 166585"];
6789 [label="this.Kind 166586"];
6790 [label="bool isAssignmentOperator = false; 166587"];
6791 [label="SyntaxKind opKind; 166588"];
6792 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166589"];
6793 [label="IsExpectedBinaryOperator(tk) 166590"];
6794 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 166591"];
6795 [label="return SyntaxFacts.IsBinaryExpression(kind); 166592"];
6796 [label="SyntaxFacts.IsBinaryExpression(kind) 166593"];
6797 [label="param IsBinaryExpression(SyntaxKind token) 166594"];
6798 [label="return GetBinaryExpression(token) != SyntaxKind.None; 166595"];
6799 [label="GetBinaryExpression(token) 166596"];
6800 [label="param GetBinaryExpression(SyntaxKind token) 166597"];
6801 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 166598"];
6802 [label="return SyntaxKind.None; 166599"];
6803 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166600"];
6804 [label="IsExpectedAssignmentOperator(tk) 166601"];
6805 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 166602"];
6806 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 166603"];
6807 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 166604"];
6808 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 166605"];
6809 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 166606"];
6810 [label="return false; 166607"];
6811 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166608"];
6812 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166609"];
6813 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166610"];
6814 [label="CurrentToken 166611"];
6815 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166612"];
6816 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166613"];
6817 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 166614"];
6818 [label="CurrentToken.Kind 166615"];
6819 [label="get { return (SyntaxKind)this.RawKind; } 166616"];
6820 [label="_ = GetPrecedence(result.Kind); 166617"];
6821 [label="result.Kind 166618"];
6822 [label="get { return (SyntaxKind)this.RawKind; } 166619"];
6823 [label="_ = GetPrecedence(result.Kind); 166620"];
6824 [label="GetPrecedence(result.Kind) 166621"];
6825 [label="param GetPrecedence(SyntaxKind op) 166622"];
6826 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 166623"];
6827 [label="return Precedence.Primary; 166624"];
6828 [label="var expression = this.ParseExpressionCore(); 166625"];
6829 [label="SyntaxToken openParen; 166626"];
6830 [label="SyntaxToken closeParen; 166627"];
6831 [label="expression.Kind 166628"];
6832 [label="get { return (SyntaxKind)this.RawKind; } 166629"];
6833 [label="if (expression.Kind == SyntaxKind.ParenthesizedExpression)\n            {\n                var parenExpression = (ParenthesizedExpressionSyntax)expression;\n                openParen = parenExpression.OpenParenToken;\n                expression = parenExpression.Expression;\n                closeParen = parenExpression.CloseParenToken;\n\n                Debug.Assert(parenExpression.GetDiagnostics().Length == 0);\n            }\n            else if (expression.Kind == SyntaxKind.TupleExpression)\n            {\n                // As a special case, when a tuple literal is the governing expression of\n                // a switch statement we permit the switch statement's own parentheses to be omitted.\n                // LDM 2018-04-04.\n                openParen = closeParen = null;\n            }\n            else\n            {\n                // Some other expression has appeared without parens. Give a syntax error.\n                openParen = SyntaxFactory.MissingToken(SyntaxKind.OpenParenToken);\n                expression = this.AddError(expression, ErrorCode.ERR_SwitchGoverningExpressionRequiresParens);\n                closeParen = SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken);\n            } 166630"];
6834 [label="var parenExpression = (ParenthesizedExpressionSyntax)expression; 166631"];
6835 [label="openParen = parenExpression.OpenParenToken; 166632"];
6836 [label="expression = parenExpression.Expression; 166633"];
6837 [label="closeParen = parenExpression.CloseParenToken; 166634"];
6838 [label="Debug.Assert(parenExpression.GetDiagnostics().Length == 0); 166635"];
6839 [label="Debug.Assert(parenExpression.GetDiagnostics().Length == 0); 166636"];
6840 [label="var openBrace = this.EatToken(SyntaxKind.OpenBraceToken); 166637"];
6841 [label="this.EatToken(SyntaxKind.OpenBraceToken) 166638"];
6842 [label="param EatToken(SyntaxKind kind) 166639"];
6843 [label="param EatToken(this) 166640"];
6844 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 166641"];
6845 [label="SyntaxFacts.IsAnyToken(kind) 166642"];
6846 [label="param IsAnyToken(SyntaxKind kind) 166643"];
6847 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 166644"];
6848 [label="return true; 166645"];
6849 [label="this.CurrentToken 166646"];
6850 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166647"];
6851 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166648"];
6852 [label="ct.Kind 166649"];
6853 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 166650"];
6854 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 166651"];
6855 [label="MoveToNextToken(); 166652"];
6856 [label="var sections = _pool.Allocate<SwitchSectionSyntax>(); 166653"];
6857 [label="this.IsPossibleSwitchSection() 166654"];
6858 [label="param IsPossibleSwitchSection(this) 166655"];
6859 [label="this.CurrentToken 166656"];
6860 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166657"];
6861 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166658"];
6862 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 166659"];
6863 [label="return (this.CurrentToken.Kind == SyntaxKind.CaseKeyword) ||\n                   (this.CurrentToken.Kind == SyntaxKind.DefaultKeyword && this.PeekToken(1).Kind != SyntaxKind.OpenParenToken); 166660"];
6864 [label="this.CurrentToken.Kind 166661"];
6865 [label="get { return (SyntaxKind)this.RawKind; } 166662"];
6866 [label="while (this.IsPossibleSwitchSection())\n                {\n                    var swcase = this.ParseSwitchSection();\n                    sections.Add(swcase);\n                } 166663"];
6867 [label="this.ParseSwitchSection() 166664"];
6868 [label="param ParseSwitchSection(this) 166665"];
6869 [label="this.IsPossibleSwitchSection() 166666"];
6870 [label="param IsPossibleSwitchSection(this) 166667"];
6871 [label="Debug.Assert(this.IsPossibleSwitchSection()); 166668"];
6872 [label="var labels = _pool.Allocate<SwitchLabelSyntax>(); 166669"];
6873 [label="var statements = _pool.Allocate<StatementSyntax>(); 166670"];
6874 [label="SyntaxToken specifier; 166671"];
6875 [label="SwitchLabelSyntax label; 166672"];
6876 [label="SyntaxToken colon; 166673"];
6877 [label="this.CurrentToken 166674"];
6878 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166675"];
6879 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166676"];
6880 [label="if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    } 166677"];
6881 [label="this.CurrentToken.Kind 166678"];
6882 [label="get { return (SyntaxKind)this.RawKind; } 166679"];
6883 [label="ExpressionSyntax expression; 166680"];
6884 [label="this.EatToken() 166681"];
6885 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 166682"];
6886 [label="MoveToNextToken(); 166683"];
6887 [label="specifier = this.EatToken(); 166684"];
6888 [label="this.CurrentToken 166685"];
6889 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166686"];
6890 [label="return _lexedTokens[_tokenOffset]; 166687"];
6891 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        } 166688"];
6892 [label="this.CurrentToken.Kind 166689"];
6893 [label="get { return (SyntaxKind)this.RawKind; } 166690"];
6894 [label="ParseExpressionOrPatternForSwitchStatement() 166691"];
6895 [label="param ParseExpressionOrPatternForSwitchStatement(this) 166692"];
6896 [label="ParseExpressionOrPatternForSwitchStatementCore() 166693"];
6897 [label="param ParseExpressionOrPatternForSwitchStatementCore(this) 166694"];
6898 [label="var pattern = ParsePattern(Precedence.Conditional, whenIsKeyword: true); 166695"];
6899 [label="var pattern = ParsePattern(Precedence.Conditional, whenIsKeyword: true); 166696"];
6900 [label="ParsePattern(Precedence.Conditional, whenIsKeyword: true) 166697"];
6901 [label="param ParsePattern(Precedence precedence) 166698"];
6902 [label="param ParsePattern(bool afterIs = false) 166699"];
6903 [label="param ParsePattern(bool whenIsKeyword = false) 166700"];
6904 [label="param ParsePattern(this) 166701"];
6905 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 166702"];
6906 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 166703"];
6907 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 166704"];
6908 [label="ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword) 166705"];
6909 [label="param ParseDisjunctivePattern(Precedence precedence) 166706"];
6910 [label="param ParseDisjunctivePattern(bool afterIs) 166707"];
6911 [label="param ParseDisjunctivePattern(bool whenIsKeyword) 166708"];
6912 [label="param ParseDisjunctivePattern(this) 166709"];
6913 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 166710"];
6914 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 166711"];
6915 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 166712"];
6916 [label="ParseConjunctivePattern(precedence, afterIs, whenIsKeyword) 166713"];
6917 [label="param ParseConjunctivePattern(Precedence precedence) 166714"];
6918 [label="param ParseConjunctivePattern(bool afterIs) 166715"];
6919 [label="param ParseConjunctivePattern(bool whenIsKeyword) 166716"];
6920 [label="param ParseConjunctivePattern(this) 166717"];
6921 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 166718"];
6922 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 166719"];
6923 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 166720"];
6924 [label="ParseNegatedPattern(precedence, afterIs, whenIsKeyword) 166721"];
6925 [label="param ParseNegatedPattern(Precedence precedence) 166722"];
6926 [label="param ParseNegatedPattern(bool afterIs) 166723"];
6927 [label="param ParseNegatedPattern(bool whenIsKeyword) 166724"];
6928 [label="param ParseNegatedPattern(this) 166725"];
6929 [label="this.CurrentToken 166726"];
6930 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166727"];
6931 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.NotKeyword)\n            {\n                var notToken = ConvertToKeyword(this.EatToken());\n                var pattern = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                var result = _syntaxFactory.UnaryPattern(notToken, pattern);\n                return CheckFeatureAvailability(result, MessageID.IDS_FeatureNotPattern);\n            }\n            else\n            {\n                return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword);\n            } 166728"];
6932 [label="this.CurrentToken.ContextualKind 166729"];
6933 [label="get\n            {\n                return this.Kind;\n            } 166730"];
6934 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 166731"];
6935 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 166732"];
6936 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 166733"];
6937 [label="ParsePrimaryPattern(precedence, afterIs, whenIsKeyword) 166734"];
6938 [label="param ParsePrimaryPattern(Precedence precedence) 166735"];
6939 [label="param ParsePrimaryPattern(bool afterIs) 166736"];
6940 [label="param ParsePrimaryPattern(bool whenIsKeyword) 166737"];
6941 [label="param ParsePrimaryPattern(this) 166738"];
6942 [label="this.CurrentToken 166739"];
6943 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166740"];
6944 [label="var tk = this.CurrentToken.Kind; 166741"];
6945 [label="this.CurrentToken.Kind 166742"];
6946 [label="get { return (SyntaxKind)this.RawKind; } 166743"];
6947 [label="switch (tk)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return _syntaxFactory.ConstantPattern(this.ParseIdentifierName(ErrorCode.ERR_MissingPattern));\n            } 166744"];
6948 [label="CurrentToken 166745"];
6949 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166746"];
6950 [label="if (CurrentToken.ContextualKind == SyntaxKind.UnderscoreToken)\n            {\n                return _syntaxFactory.DiscardPattern(this.EatContextualToken(SyntaxKind.UnderscoreToken));\n            } 166747"];
6951 [label="CurrentToken.ContextualKind 166748"];
6952 [label="get\n            {\n                return this.Kind;\n            } 166749"];
6953 [label="CurrentToken 166750"];
6954 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166751"];
6955 [label="switch (CurrentToken.Kind)\n            {\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                    // this is a relational pattern.\n                    var relationalToken = this.EatToken();\n                    Debug.Assert(precedence < Precedence.Shift);\n                    var expression = this.ParseSubExpression(Precedence.Relational);\n                    var result = _syntaxFactory.RelationalPattern(relationalToken, expression);\n                    return CheckFeatureAvailability(result, MessageID.IDS_FeatureRelationalPattern);\n            } 166752"];
6956 [label="CurrentToken.Kind 166753"];
6957 [label="get { return (SyntaxKind)this.RawKind; } 166754"];
6958 [label="this.GetResetPoint() 166755"];
6959 [label="param GetResetPoint(this) 166756"];
6960 [label="var resetPoint = this.GetResetPoint(); 166757"];
6961 [label="TypeSyntax type = null; 166758"];
6962 [label="LooksLikeTypeOfPattern() 166759"];
6963 [label="param LooksLikeTypeOfPattern(this) 166760"];
6964 [label="CurrentToken 166761"];
6965 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166762"];
6966 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166763"];
6967 [label="var tk = CurrentToken.Kind; 166764"];
6968 [label="CurrentToken.Kind 166765"];
6969 [label="get { return (SyntaxKind)this.RawKind; } 166766"];
6970 [label="if (SyntaxFacts.IsPredefinedType(tk))\n            {\n                return true;\n            } 166767"];
6971 [label="SyntaxFacts.IsPredefinedType(tk) 166768"];
6972 [label="param IsPredefinedType(SyntaxKind kind) 166769"];
6973 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 166770"];
6974 [label="this.CurrentToken 166771"];
6975 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166772"];
6976 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166773"];
6977 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 166774"];
6978 [label="this.CurrentToken.ContextualKind 166775"];
6979 [label="get\n            {\n                return this.Kind;\n            } 166776"];
6980 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 166777"];
6981 [label="this.CurrentToken 166778"];
6982 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166779"];
6983 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166780"];
6984 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 166781"];
6985 [label="this.CurrentToken.ContextualKind 166782"];
6986 [label="get\n            {\n                return this.Kind;\n            } 166783"];
6987 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 166784"];
6988 [label="return true; 166785"];
6989 [label="if (LooksLikeTypeOfPattern())\n                {\n                    type = this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern);\n                    if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    }\n                } 166786"];
6990 [label="afterIs 166787"];
6991 [label="type = this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern); 166788"];
6992 [label="this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern) 166789"];
6993 [label="param ParseType(ParseTypeMode mode = ParseTypeMode.Normal) 166790"];
6994 [label="param ParseType(this) 166791"];
6995 [label="this.CurrentToken 166792"];
6996 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166793"];
6997 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 166794"];
6998 [label="this.CurrentToken.Kind 166795"];
6999 [label="get { return (SyntaxKind)this.RawKind; } 166796"];
7000 [label="return ParseTypeCore(mode); 166797"];
7001 [label="return ParseTypeCore(mode); 166798"];
7002 [label="return ParseTypeCore(mode); 166799"];
7003 [label="param ParseUnderlyingType(ParseTypeMode mode) 166800"];
7004 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 166801"];
7005 [label="param ParseUnderlyingType(this) 166802"];
7006 [label="this.CurrentToken 166803"];
7007 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166804"];
7008 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 166805"];
7009 [label="this.CurrentToken.Kind 166806"];
7010 [label="get { return (SyntaxKind)this.RawKind; } 166807"];
7011 [label="IsPredefinedType(this.CurrentToken.Kind) 166808"];
7012 [label="param IsPredefinedType(SyntaxKind keyword) 166809"];
7013 [label="IsTrueIdentifier() 166810"];
7014 [label="param IsTrueIdentifier(this) 166811"];
7015 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 166812"];
7016 [label="this.CurrentToken 166813"];
7017 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166814"];
7018 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 166815"];
7019 [label="this.CurrentToken.ContextualKind 166816"];
7020 [label="get\n            {\n                return this.Kind;\n            } 166817"];
7021 [label="if (IsTrueIdentifier() || this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                return this.ParseQualifiedName(options);\n            } 166818"];
7022 [label="return this.ParseQualifiedName(options); 166819"];
7023 [label="this.ParseQualifiedName(options) 166820"];
7024 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 166821"];
7025 [label="param ParseQualifiedName(this) 166822"];
7026 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 166823"];
7027 [label="this.ParseAliasQualifiedName(options) 166824"];
7028 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 166825"];
7029 [label="param ParseAliasQualifiedName(this) 166826"];
7030 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 166827"];
7031 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 166828"];
7032 [label="this.IsIncrementalAndFactoryContextMatches 166829"];
7033 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 166830"];
7034 [label="base.IsIncremental 166831"];
7035 [label="get\n            {\n                return _isIncremental;\n            } 166832"];
7036 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 166833"];
7037 [label="return false; 166834"];
7038 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 166835"];
7039 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 166836"];
7040 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 166837"];
7041 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 166838"];
7042 [label="this.CurrentToken 166839"];
7043 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166840"];
7044 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 166841"];
7045 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 166842"];
7046 [label="IsCurrentTokenQueryKeywordInQuery() 166843"];
7047 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 166844"];
7048 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 166845"];
7049 [label="param GetTrailingTrivia(this) 166846"];
7050 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 166847"];
7051 [label="MoveToNextToken(); 166848"];
7052 [label="this.IsInAsync 166849"];
7053 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 166850"];
7054 [label="return _syntaxFactoryContext.IsInAsync; 166851"];
7055 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 166852"];
7056 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 166853"];
7057 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 166854"];
7058 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 166855"];
7059 [label="this.CurrentToken.Kind 166856"];
7060 [label="get { return (SyntaxKind)this.RawKind; } 166857"];
7061 [label="this.CurrentToken 166858"];
7062 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166859"];
7063 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 166860"];
7064 [label="this.CurrentToken.Kind 166861"];
7065 [label="get { return (SyntaxKind)this.RawKind; } 166862"];
7066 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 166863"];
7067 [label="this.IsDotOrColonColon() 166864"];
7068 [label="param IsDotOrColonColon(this) 166865"];
7069 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166866"];
7070 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 166867"];
7071 [label="this.CurrentToken 166868"];
7072 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166869"];
7073 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166870"];
7074 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 166871"];
7075 [label="this.CurrentToken.Kind 166872"];
7076 [label="get { return (SyntaxKind)this.RawKind; } 166873"];
7077 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 166874"];
7078 [label="return name; 166875"];
7079 [label="return this.ParseQualifiedName(options); 166876"];
7080 [label="param IsMakingProgress(bool assertIfFalse = true) 166877"];
7081 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 166878"];
7082 [label="CanTokenFollowTypeInPattern(precedence) 166879"];
7083 [label="param CanTokenFollowTypeInPattern(Precedence precedence) 166880"];
7084 [label="param CanTokenFollowTypeInPattern(this) 166881"];
7085 [label="this.CurrentToken 166882"];
7086 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166883"];
7087 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166884"];
7088 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.CloseBraceToken:   // for efficiency, test some tokens that can follow a type pattern\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                case SyntaxKind.DotToken:\n                    // int.MaxValue is an expression, not a type.\n                    return false;\n                case var kind:\n                    // If we find what looks like a continuation of an expression, it is not a type.\n                    return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence;\n            } 166885"];
7089 [label="this.CurrentToken.Kind 166886"];
7090 [label="get { return (SyntaxKind)this.RawKind; } 166887"];
7091 [label="return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence; 166888"];
7092 [label="SyntaxFacts.IsBinaryExpressionOperatorToken(kind) 166889"];
7093 [label="param IsBinaryExpressionOperatorToken(SyntaxKind token) 166890"];
7094 [label="return GetBinaryExpression(token) != SyntaxKind.None; 166891"];
7095 [label="GetBinaryExpression(token) 166892"];
7096 [label="param GetBinaryExpression(SyntaxKind token) 166893"];
7097 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 166894"];
7098 [label="return SyntaxKind.None; 166895"];
7099 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 166896"];
7100 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 166897"];
7101 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 166898"];
7102 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 166899"];
7103 [label="ParsePatternContinued(type, precedence, whenIsKeyword) 166900"];
7104 [label="param ParsePatternContinued(TypeSyntax type) 166901"];
7105 [label="param ParsePatternContinued(Precedence precedence) 166902"];
7106 [label="param ParsePatternContinued(bool whenIsKeyword) 166903"];
7107 [label="param ParsePatternContinued(this) 166904"];
7108 [label=".Kind 166905"];
7109 [label="get { return (SyntaxKind)this.RawKind; } 166906"];
7110 [label="if (type?.Kind == SyntaxKind.IdentifierName)\n            {\n                var typeIdentifier = (IdentifierNameSyntax)type;\n                var typeIdentifierToken = typeIdentifier.Identifier;\n                if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                }\n            } 166907"];
7111 [label="var typeIdentifier = (IdentifierNameSyntax)type; 166908"];
7112 [label="var typeIdentifierToken = typeIdentifier.Identifier; 166909"];
7113 [label="typeIdentifierToken.ContextualKind 166910"];
7114 [label="get\n            {\n                return this.Kind;\n            } 166911"];
7115 [label="if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                } 166912"];
7116 [label="this.CurrentToken 166913"];
7117 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166914"];
7118 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166915"];
7119 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken && (type != null || !looksLikeCast()))\n            {\n                // It is possible this is a parenthesized (constant) expression.\n                // We normalize later.\n                ParseSubpatternList(\n                    openToken: out SyntaxToken openParenToken,\n                    subPatterns: out SeparatedSyntaxList<SubpatternSyntax> subPatterns,\n                    closeToken: out SyntaxToken closeParenToken,\n                    openKind: SyntaxKind.OpenParenToken,\n                    closeKind: SyntaxKind.CloseParenToken);\n\n                parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause0);\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n\n                if (type == null &&\n                    propertyPatternClause0 == null &&\n                    designation0 == null &&\n                    subPatterns.Count == 1 &&\n                    subPatterns.SeparatorCount == 0 &&\n                    subPatterns[0].NameColon == null)\n                {\n                    var subpattern = subPatterns[0].Pattern;\n                    switch (subpattern)\n                    {\n                        case ConstantPatternSyntax cp:\n                            // There is an ambiguity between a positional pattern `(` pattern `)`\n                            // and a constant expression pattern that happens to be parenthesized.\n                            // Per 2017-11-20 LDM we treat such syntax as a parenthesized expression always.\n                            ExpressionSyntax expression = _syntaxFactory.ParenthesizedExpression(openParenToken, cp.Expression, closeParenToken);\n                            expression = ParseExpressionContinued(expression, precedence);\n                            return _syntaxFactory.ConstantPattern(expression);\n                        default:\n                            var parenthesizedPattern = _syntaxFactory.ParenthesizedPattern(openParenToken, subPatterns[0].Pattern, closeParenToken);\n                            return CheckFeatureAvailability(parenthesizedPattern, MessageID.IDS_FeatureParenthesizedPattern);\n                    }\n                }\n\n                var positionalPatternClause = _syntaxFactory.PositionalPatternClause(openParenToken, subPatterns, closeParenToken);\n                var result = _syntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause0, designation0);\n                return result;\n            } 166916"];
7120 [label="this.CurrentToken.Kind 166917"];
7121 [label="get { return (SyntaxKind)this.RawKind; } 166918"];
7122 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 166919"];
7123 [label="parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause) 166920"];
7124 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 166921"];
7125 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 166922"];
7126 [label="propertyPatternClauseResult = null; 166923"];
7127 [label="this.CurrentToken 166924"];
7128 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166925"];
7129 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 166926"];
7130 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                } 166927"];
7131 [label="this.CurrentToken.Kind 166928"];
7132 [label="get { return (SyntaxKind)this.RawKind; } 166929"];
7133 [label="return false; 166930"];
7134 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 166931"];
7135 [label="if (type != null)\n            {\n                if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                }\n            } 166932"];
7136 [label="if (type != null)\n            {\n                if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                }\n            } 166933"];
7137 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 166934"];
7138 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 166935"];
7139 [label="parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation) 166936"];
7140 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 166937"];
7141 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 166938"];
7142 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 166939"];
7143 [label="designationResult = null; 166940"];
7144 [label="this.IsTrueIdentifier() 166941"];
7145 [label="param IsTrueIdentifier(this) 166942"];
7146 [label="return false; 166943"];
7147 [label="if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                } 166944"];
7148 [label="return false; 166945"];
7149 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 166946"];
7150 [label="if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    } 166947"];
7151 [label="if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    } 166948"];
7152 [label="ConvertTypeToExpression(type, out var expression) 166949"];
7153 [label="param ConvertTypeToExpression(TypeSyntax type) 166950"];
7154 [label="param ConvertTypeToExpression(out ExpressionSyntax expr) 166951"];
7155 [label="param ConvertTypeToExpression(bool permitTypeArguments = false) 166952"];
7156 [label="param ConvertTypeToExpression(this) 166953"];
7157 [label="expr = null; 166954"];
7158 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 166955"];
7159 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 166956"];
7160 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 166957"];
7161 [label="expr = s; 166958"];
7162 [label="return true; 166959"];
7163 [label="expression = ParseExpressionContinued(expression, precedence); 166960"];
7164 [label="expression = ParseExpressionContinued(expression, precedence); 166961"];
7165 [label="ParseExpressionContinued(expression, precedence) 166962"];
7166 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 166963"];
7167 [label="param ParseExpressionContinued(Precedence precedence) 166964"];
7168 [label="param ParseExpressionContinued(this) 166965"];
7169 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 166966"];
7170 [label="this.CurrentToken 166967"];
7171 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166968"];
7172 [label="var tk = this.CurrentToken.ContextualKind; 166969"];
7173 [label="this.CurrentToken.ContextualKind 166970"];
7174 [label="get\n            {\n                return this.Kind;\n            } 166971"];
7175 [label="bool isAssignmentOperator = false; 166972"];
7176 [label="SyntaxKind opKind; 166973"];
7177 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166974"];
7178 [label="IsExpectedBinaryOperator(tk) 166975"];
7179 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 166976"];
7180 [label="return SyntaxFacts.IsBinaryExpression(kind); 166977"];
7181 [label="SyntaxFacts.IsBinaryExpression(kind) 166978"];
7182 [label="param IsBinaryExpression(SyntaxKind token) 166979"];
7183 [label="return GetBinaryExpression(token) != SyntaxKind.None; 166980"];
7184 [label="GetBinaryExpression(token) 166981"];
7185 [label="param GetBinaryExpression(SyntaxKind token) 166982"];
7186 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 166983"];
7187 [label="return SyntaxKind.None; 166984"];
7188 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166985"];
7189 [label="IsExpectedAssignmentOperator(tk) 166986"];
7190 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 166987"];
7191 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 166988"];
7192 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 166989"];
7193 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 166990"];
7194 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 166991"];
7195 [label="return false; 166992"];
7196 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166993"];
7197 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166994"];
7198 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 166995"];
7199 [label="CurrentToken 166996"];
7200 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 166997"];
7201 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 166998"];
7202 [label="CurrentToken.Kind 166999"];
7203 [label="get { return (SyntaxKind)this.RawKind; } 167000"];
7204 [label="return _syntaxFactory.ConstantPattern(expression); 167001"];
7205 [label="return _syntaxFactory.ConstantPattern(expression); 167002"];
7206 [label="return _syntaxFactory.ConstantPattern(expression); 167003"];
7207 [label="param TryGetNode(int kind) 167004"];
7208 [label="param TryGetNode(GreenNode child1) 167005"];
7209 [label="param TryGetNode(SyntaxFactoryContext context) 167006"];
7210 [label="param TryGetNode(out int hash) 167007"];
7211 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 167008"];
7212 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 167009"];
7213 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 167010"];
7214 [label="GetNodeFlags(context) 167011"];
7215 [label="param GetNodeFlags(SyntaxFactoryContext context) 167012"];
7216 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 167013"];
7217 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 167014"];
7218 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 167015"];
7219 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 167016"];
7220 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 167017"];
7221 [label="param SetFactoryContext(SyntaxFactoryContext context) 167018"];
7222 [label="param SetFactoryContext(this) 167019"];
7223 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 167020"];
7224 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 167021"];
7225 [label="if (p != null)\n                    return p; 167022"];
7226 [label="if (p != null)\n                    return p; 167023"];
7227 [label="return p; 167024"];
7228 [label="this.Release(ref resetPoint); 167025"];
7229 [label="this.Release(ref resetPoint) 167026"];
7230 [label="param Release(ref ResetPoint state) 167027"];
7231 [label="base.Release(ref state.BaseResetPoint); 167028"];
7232 [label="param Release(ref ResetPoint point) 167029"];
7233 [label="Debug.Assert(_resetCount == point.ResetCount); 167030"];
7234 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 167031"];
7235 [label="base.Release(ref state.BaseResetPoint); 167032"];
7236 [label="this.Release(ref resetPoint); 167033"];
7237 [label="this.CurrentToken 167034"];
7238 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167035"];
7239 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167036"];
7240 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.AndKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.AndPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureAndPattern);\n            } 167037"];
7241 [label="this.CurrentToken.ContextualKind 167038"];
7242 [label="get\n            {\n                return this.Kind;\n            } 167039"];
7243 [label="return result; 167040"];
7244 [label="this.CurrentToken 167041"];
7245 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167042"];
7246 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167043"];
7247 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.OrKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.OrPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureOrPattern);\n            } 167044"];
7248 [label="this.CurrentToken.ContextualKind 167045"];
7249 [label="get\n            {\n                return this.Kind;\n            } 167046"];
7250 [label="return result; 167047"];
7251 [label="pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            } 167048"];
7252 [label="return pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            }; 167049"];
7253 [label="return CheckRecursivePatternFeature(ParseExpressionOrPatternForSwitchStatementCore()); 167050"];
7254 [label="CheckRecursivePatternFeature(ParseExpressionOrPatternForSwitchStatementCore()) 167051"];
7255 [label="param CheckRecursivePatternFeature(CSharpSyntaxNode node) 167052"];
7256 [label="param CheckRecursivePatternFeature(this) 167053"];
7257 [label="node.Kind 167054"];
7258 [label="get { return (SyntaxKind)this.RawKind; } 167055"];
7259 [label="switch (node.Kind)\n            {\n                case SyntaxKind.RecursivePattern:\n                case SyntaxKind.DiscardPattern:\n                case SyntaxKind.VarPattern when ((VarPatternSyntax)node).Designation.Kind == SyntaxKind.ParenthesizedVariableDesignation:\n                    return this.CheckFeatureAvailability(node, MessageID.IDS_FeatureRecursivePatterns);\n                default:\n                    return node;\n            } 167056"];
7260 [label="return node; 167057"];
7261 [label="var node = ParseExpressionOrPatternForSwitchStatement(); 167058"];
7262 [label="this.CurrentToken 167059"];
7263 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167060"];
7264 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex); 167061"];
7265 [label="this.CurrentToken.ContextualKind 167062"];
7266 [label="get\n            {\n                return this.Kind;\n            } 167063"];
7267 [label="node.Kind 167064"];
7268 [label="get { return (SyntaxKind)this.RawKind; } 167065"];
7269 [label="if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement); 167066"];
7270 [label="if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            } 167067"];
7271 [label="colon = this.EatToken(SyntaxKind.ColonToken); 167068"];
7272 [label="this.EatToken(SyntaxKind.ColonToken) 167069"];
7273 [label="param EatToken(SyntaxKind kind) 167070"];
7274 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 167071"];
7275 [label="SyntaxFacts.IsAnyToken(kind) 167072"];
7276 [label="param IsAnyToken(SyntaxKind kind) 167073"];
7277 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 167074"];
7278 [label="return true; 167075"];
7279 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 167076"];
7280 [label="MoveToNextToken(); 167077"];
7281 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 167078"];
7282 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 167079"];
7283 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 167080"];
7284 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 167081"];
7285 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 167082"];
7286 [label="param TryGetNode(SyntaxFactoryContext context) 167083"];
7287 [label="param GetNodeFlags(SyntaxFactoryContext context) 167084"];
7288 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 167085"];
7289 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 167086"];
7290 [label="param SetFactoryContext(SyntaxFactoryContext context) 167087"];
7291 [label="param SetFactoryContext(this) 167088"];
7292 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 167089"];
7293 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 167090"];
7294 [label="labels.Add(label); 167091"];
7295 [label="IsPossibleSwitchSection() 167092"];
7296 [label="param IsPossibleSwitchSection(this) 167093"];
7297 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 167094"];
7298 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 167095"];
7299 [label="do\n                {\n                    SyntaxToken specifier;\n                    SwitchLabelSyntax label;\n                    SyntaxToken colon;\n                    if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    }\n\n                    labels.Add(label);\n                }\n                while (IsPossibleSwitchSection()); 167096"];
7300 [label="SyntaxToken specifier; 167097"];
7301 [label="SwitchLabelSyntax label; 167098"];
7302 [label="SyntaxToken colon; 167099"];
7303 [label="ExpressionSyntax expression; 167100"];
7304 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 167101"];
7305 [label="MoveToNextToken(); 167102"];
7306 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 167103"];
7307 [label="param ParsePattern(Precedence precedence) 167104"];
7308 [label="param ParsePattern(bool whenIsKeyword = false) 167105"];
7309 [label="param ParseDisjunctivePattern(Precedence precedence) 167106"];
7310 [label="param ParseDisjunctivePattern(bool whenIsKeyword) 167107"];
7311 [label="param ParseConjunctivePattern(Precedence precedence) 167108"];
7312 [label="param ParseConjunctivePattern(bool whenIsKeyword) 167109"];
7313 [label="param ParseNegatedPattern(Precedence precedence) 167110"];
7314 [label="param ParseNegatedPattern(bool whenIsKeyword) 167111"];
7315 [label="param ParsePrimaryPattern(Precedence precedence) 167112"];
7316 [label="param ParsePrimaryPattern(bool whenIsKeyword) 167113"];
7317 [label="this.CurrentToken 167114"];
7318 [label="var tk = this.CurrentToken.Kind; 167115"];
7319 [label="this.CurrentToken.Kind 167116"];
7320 [label="get { return (SyntaxKind)this.RawKind; } 167117"];
7321 [label="switch (tk)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return _syntaxFactory.ConstantPattern(this.ParseIdentifierName(ErrorCode.ERR_MissingPattern));\n            } 167118"];
7322 [label="CurrentToken 167119"];
7323 [label="if (CurrentToken.ContextualKind == SyntaxKind.UnderscoreToken)\n            {\n                return _syntaxFactory.DiscardPattern(this.EatContextualToken(SyntaxKind.UnderscoreToken));\n            } 167120"];
7324 [label="CurrentToken.ContextualKind 167121"];
7325 [label="get\n            {\n                return this.Kind;\n            } 167122"];
7326 [label="CurrentToken 167123"];
7327 [label="switch (CurrentToken.Kind)\n            {\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                    // this is a relational pattern.\n                    var relationalToken = this.EatToken();\n                    Debug.Assert(precedence < Precedence.Shift);\n                    var expression = this.ParseSubExpression(Precedence.Relational);\n                    var result = _syntaxFactory.RelationalPattern(relationalToken, expression);\n                    return CheckFeatureAvailability(result, MessageID.IDS_FeatureRelationalPattern);\n            } 167124"];
7328 [label="CurrentToken.Kind 167125"];
7329 [label="get { return (SyntaxKind)this.RawKind; } 167126"];
7330 [label="var resetPoint = this.GetResetPoint(); 167127"];
7331 [label="TypeSyntax type = null; 167128"];
7332 [label="if (SyntaxFacts.IsPredefinedType(tk))\n            {\n                return true;\n            } 167129"];
7333 [label="SyntaxFacts.IsPredefinedType(tk) 167130"];
7334 [label="param IsPredefinedType(SyntaxKind kind) 167131"];
7335 [label="get { return (SyntaxKind)this.RawKind; } 167132"];
7336 [label="afterIs 167133"];
7337 [label="this.CurrentToken 167134"];
7338 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 167135"];
7339 [label="this.CurrentToken.Kind 167136"];
7340 [label="get { return (SyntaxKind)this.RawKind; } 167137"];
7341 [label="param ParseUnderlyingType(ParseTypeMode mode) 167138"];
7342 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 167139"];
7343 [label="this.CurrentToken 167140"];
7344 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167141"];
7345 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 167142"];
7346 [label="this.CurrentToken.Kind 167143"];
7347 [label="get { return (SyntaxKind)this.RawKind; } 167144"];
7348 [label="IsPredefinedType(this.CurrentToken.Kind) 167145"];
7349 [label="param IsPredefinedType(SyntaxKind keyword) 167146"];
7350 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 167147"];
7351 [label="this.CurrentToken 167148"];
7352 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167149"];
7353 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 167150"];
7354 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 167151"];
7355 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 167152"];
7356 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 167153"];
7357 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 167154"];
7358 [label="this.IsIncrementalAndFactoryContextMatches 167155"];
7359 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 167156"];
7360 [label="base.IsIncremental 167157"];
7361 [label="get\n            {\n                return _isIncremental;\n            } 167158"];
7362 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 167159"];
7363 [label="return false; 167160"];
7364 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 167161"];
7365 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 167162"];
7366 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 167163"];
7367 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 167164"];
7368 [label="this.CurrentToken 167165"];
7369 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167166"];
7370 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 167167"];
7371 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 167168"];
7372 [label="IsCurrentTokenQueryKeywordInQuery() 167169"];
7373 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 167170"];
7374 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 167171"];
7375 [label="param GetTrailingTrivia(this) 167172"];
7376 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 167173"];
7377 [label="MoveToNextToken(); 167174"];
7378 [label="this.IsInAsync 167175"];
7379 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 167176"];
7380 [label="return _syntaxFactoryContext.IsInAsync; 167177"];
7381 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 167178"];
7382 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 167179"];
7383 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 167180"];
7384 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 167181"];
7385 [label="this.CurrentToken.Kind 167182"];
7386 [label="get { return (SyntaxKind)this.RawKind; } 167183"];
7387 [label="this.CurrentToken 167184"];
7388 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167185"];
7389 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 167186"];
7390 [label="this.CurrentToken.Kind 167187"];
7391 [label="get { return (SyntaxKind)this.RawKind; } 167188"];
7392 [label="this.IsDotOrColonColon() 167189"];
7393 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167190"];
7394 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 167191"];
7395 [label="this.CurrentToken 167192"];
7396 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167193"];
7397 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 167194"];
7398 [label="this.CurrentToken.Kind 167195"];
7399 [label="get { return (SyntaxKind)this.RawKind; } 167196"];
7400 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 167197"];
7401 [label="param IsMakingProgress(bool assertIfFalse = true) 167198"];
7402 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 167199"];
7403 [label="CanTokenFollowTypeInPattern(precedence) 167200"];
7404 [label="param CanTokenFollowTypeInPattern(Precedence precedence) 167201"];
7405 [label="param CanTokenFollowTypeInPattern(this) 167202"];
7406 [label="this.CurrentToken 167203"];
7407 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167204"];
7408 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167205"];
7409 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.CloseBraceToken:   // for efficiency, test some tokens that can follow a type pattern\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                case SyntaxKind.DotToken:\n                    // int.MaxValue is an expression, not a type.\n                    return false;\n                case var kind:\n                    // If we find what looks like a continuation of an expression, it is not a type.\n                    return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence;\n            } 167206"];
7410 [label="this.CurrentToken.Kind 167207"];
7411 [label="get { return (SyntaxKind)this.RawKind; } 167208"];
7412 [label="return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence; 167209"];
7413 [label="SyntaxFacts.IsBinaryExpressionOperatorToken(kind) 167210"];
7414 [label="param IsBinaryExpressionOperatorToken(SyntaxKind token) 167211"];
7415 [label="return GetBinaryExpression(token) != SyntaxKind.None; 167212"];
7416 [label="GetBinaryExpression(token) 167213"];
7417 [label="param GetBinaryExpression(SyntaxKind token) 167214"];
7418 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 167215"];
7419 [label="return SyntaxKind.None; 167216"];
7420 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 167217"];
7421 [label="param ParsePatternContinued(Precedence precedence) 167218"];
7422 [label="param ParsePatternContinued(bool whenIsKeyword) 167219"];
7423 [label=".Kind 167220"];
7424 [label="get { return (SyntaxKind)this.RawKind; } 167221"];
7425 [label="if (type?.Kind == SyntaxKind.IdentifierName)\n            {\n                var typeIdentifier = (IdentifierNameSyntax)type;\n                var typeIdentifierToken = typeIdentifier.Identifier;\n                if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                }\n            } 167222"];
7426 [label="var typeIdentifier = (IdentifierNameSyntax)type; 167223"];
7427 [label="var typeIdentifierToken = typeIdentifier.Identifier; 167224"];
7428 [label="typeIdentifierToken.ContextualKind 167225"];
7429 [label="get\n            {\n                return this.Kind;\n            } 167226"];
7430 [label="if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                } 167227"];
7431 [label="this.CurrentToken 167228"];
7432 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167229"];
7433 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken && (type != null || !looksLikeCast()))\n            {\n                // It is possible this is a parenthesized (constant) expression.\n                // We normalize later.\n                ParseSubpatternList(\n                    openToken: out SyntaxToken openParenToken,\n                    subPatterns: out SeparatedSyntaxList<SubpatternSyntax> subPatterns,\n                    closeToken: out SyntaxToken closeParenToken,\n                    openKind: SyntaxKind.OpenParenToken,\n                    closeKind: SyntaxKind.CloseParenToken);\n\n                parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause0);\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n\n                if (type == null &&\n                    propertyPatternClause0 == null &&\n                    designation0 == null &&\n                    subPatterns.Count == 1 &&\n                    subPatterns.SeparatorCount == 0 &&\n                    subPatterns[0].NameColon == null)\n                {\n                    var subpattern = subPatterns[0].Pattern;\n                    switch (subpattern)\n                    {\n                        case ConstantPatternSyntax cp:\n                            // There is an ambiguity between a positional pattern `(` pattern `)`\n                            // and a constant expression pattern that happens to be parenthesized.\n                            // Per 2017-11-20 LDM we treat such syntax as a parenthesized expression always.\n                            ExpressionSyntax expression = _syntaxFactory.ParenthesizedExpression(openParenToken, cp.Expression, closeParenToken);\n                            expression = ParseExpressionContinued(expression, precedence);\n                            return _syntaxFactory.ConstantPattern(expression);\n                        default:\n                            var parenthesizedPattern = _syntaxFactory.ParenthesizedPattern(openParenToken, subPatterns[0].Pattern, closeParenToken);\n                            return CheckFeatureAvailability(parenthesizedPattern, MessageID.IDS_FeatureParenthesizedPattern);\n                    }\n                }\n\n                var positionalPatternClause = _syntaxFactory.PositionalPatternClause(openParenToken, subPatterns, closeParenToken);\n                var result = _syntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause0, designation0);\n                return result;\n            } 167230"];
7434 [label="this.CurrentToken.Kind 167231"];
7435 [label="get { return (SyntaxKind)this.RawKind; } 167232"];
7436 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 167233"];
7437 [label="parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause) 167234"];
7438 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 167235"];
7439 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 167236"];
7440 [label="propertyPatternClauseResult = null; 167237"];
7441 [label="this.CurrentToken 167238"];
7442 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167239"];
7443 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167240"];
7444 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                } 167241"];
7445 [label="this.CurrentToken.Kind 167242"];
7446 [label="get { return (SyntaxKind)this.RawKind; } 167243"];
7447 [label="return false; 167244"];
7448 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 167245"];
7449 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 167246"];
7450 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 167247"];
7451 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 167248"];
7452 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 167249"];
7453 [label="designationResult = null; 167250"];
7454 [label="this.IsTrueIdentifier() 167251"];
7455 [label="param IsTrueIdentifier(this) 167252"];
7456 [label="return false; 167253"];
7457 [label="if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                } 167254"];
7458 [label="param ConvertTypeToExpression(out ExpressionSyntax expr) 167255"];
7459 [label="param ConvertTypeToExpression(bool permitTypeArguments = false) 167256"];
7460 [label="param ConvertTypeToExpression(this) 167257"];
7461 [label="expr = null; 167258"];
7462 [label="expression = ParseExpressionContinued(expression, precedence); 167259"];
7463 [label="param ParseExpressionContinued(Precedence precedence) 167260"];
7464 [label="param ParseExpressionContinued(this) 167261"];
7465 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 167262"];
7466 [label="this.CurrentToken 167263"];
7467 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167264"];
7468 [label="var tk = this.CurrentToken.ContextualKind; 167265"];
7469 [label="this.CurrentToken.ContextualKind 167266"];
7470 [label="get\n            {\n                return this.Kind;\n            } 167267"];
7471 [label="bool isAssignmentOperator = false; 167268"];
7472 [label="SyntaxKind opKind; 167269"];
7473 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 167270"];
7474 [label="IsExpectedBinaryOperator(tk) 167271"];
7475 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 167272"];
7476 [label="return SyntaxFacts.IsBinaryExpression(kind); 167273"];
7477 [label="SyntaxFacts.IsBinaryExpression(kind) 167274"];
7478 [label="param IsBinaryExpression(SyntaxKind token) 167275"];
7479 [label="return GetBinaryExpression(token) != SyntaxKind.None; 167276"];
7480 [label="GetBinaryExpression(token) 167277"];
7481 [label="param GetBinaryExpression(SyntaxKind token) 167278"];
7482 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 167279"];
7483 [label="return SyntaxKind.None; 167280"];
7484 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 167281"];
7485 [label="IsExpectedAssignmentOperator(tk) 167282"];
7486 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 167283"];
7487 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 167284"];
7488 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 167285"];
7489 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 167286"];
7490 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 167287"];
7491 [label="return false; 167288"];
7492 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 167289"];
7493 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 167290"];
7494 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 167291"];
7495 [label="CurrentToken 167292"];
7496 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167293"];
7497 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 167294"];
7498 [label="CurrentToken.Kind 167295"];
7499 [label="get { return (SyntaxKind)this.RawKind; } 167296"];
7500 [label="param TryGetNode(SyntaxFactoryContext context) 167297"];
7501 [label="param GetNodeFlags(SyntaxFactoryContext context) 167298"];
7502 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 167299"];
7503 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 167300"];
7504 [label="param SetFactoryContext(SyntaxFactoryContext context) 167301"];
7505 [label="param SetFactoryContext(this) 167302"];
7506 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 167303"];
7507 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 167304"];
7508 [label="this.Release(ref resetPoint); 167305"];
7509 [label="param Release(ref ResetPoint state) 167306"];
7510 [label="base.Release(ref state.BaseResetPoint); 167307"];
7511 [label="param Release(ref ResetPoint point) 167308"];
7512 [label="Debug.Assert(_resetCount == point.ResetCount); 167309"];
7513 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 167310"];
7514 [label="base.Release(ref state.BaseResetPoint); 167311"];
7515 [label="this.Release(ref resetPoint); 167312"];
7516 [label="this.CurrentToken 167313"];
7517 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167314"];
7518 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.AndKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.AndPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureAndPattern);\n            } 167315"];
7519 [label="this.CurrentToken.ContextualKind 167316"];
7520 [label="get\n            {\n                return this.Kind;\n            } 167317"];
7521 [label="this.CurrentToken 167318"];
7522 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167319"];
7523 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.OrKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.OrPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureOrPattern);\n            } 167320"];
7524 [label="this.CurrentToken.ContextualKind 167321"];
7525 [label="get\n            {\n                return this.Kind;\n            } 167322"];
7526 [label="pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            } 167323"];
7527 [label="param CheckRecursivePatternFeature(this) 167324"];
7528 [label="this.CurrentToken 167325"];
7529 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167326"];
7530 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex); 167327"];
7531 [label="this.CurrentToken.ContextualKind 167328"];
7532 [label="get\n            {\n                return this.Kind;\n            } 167329"];
7533 [label="node.Kind 167330"];
7534 [label="get { return (SyntaxKind)this.RawKind; } 167331"];
7535 [label="if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement); 167332"];
7536 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 167333"];
7537 [label="SyntaxFacts.IsAnyToken(kind) 167334"];
7538 [label="param IsAnyToken(SyntaxKind kind) 167335"];
7539 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 167336"];
7540 [label="return true; 167337"];
7541 [label="param GetTrailingTrivia(this) 167338"];
7542 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 167339"];
7543 [label="MoveToNextToken(); 167340"];
7544 [label="param GetNodeFlags(SyntaxFactoryContext context) 167341"];
7545 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 167342"];
7546 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 167343"];
7547 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 167344"];
7548 [label="this.CurrentToken 167345"];
7549 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167346"];
7550 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167347"];
7551 [label="this.CurrentToken.Kind 167348"];
7552 [label="get { return (SyntaxKind)this.RawKind; } 167349"];
7553 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 167350"];
7554 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 167351"];
7555 [label="this.ParseStatements(ref tmp, statements, true); 167352"];
7556 [label="this.ParseStatements(ref tmp, statements, true); 167353"];
7557 [label="this.ParseStatements(ref tmp, statements, true); 167354"];
7558 [label="this.ParseStatements(ref tmp, statements, true) 167355"];
7559 [label="param ParseStatements(ref CSharpSyntaxNode previousNode) 167356"];
7560 [label="param ParseStatements(SyntaxListBuilder<StatementSyntax> statements) 167357"];
7561 [label="param ParseStatements(bool stopOnSwitchSections) 167358"];
7562 [label="param ParseStatements(this) 167359"];
7563 [label="var saveTerm = _termState; 167360"];
7564 [label="_termState |= TerminatorState.IsPossibleStatementStartOrStop; 167361"];
7565 [label="_termState 167362"];
7566 [label="if (stopOnSwitchSections)\n            {\n                _termState |= TerminatorState.IsSwitchSectionStart;\n            } 167363"];
7567 [label="_termState |= TerminatorState.IsSwitchSectionStart; 167364"];
7568 [label="_termState 167365"];
7569 [label="int lastTokenPosition = -1; 167366"];
7570 [label="this.CurrentToken 167367"];
7571 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167368"];
7572 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167369"];
7573 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 167370"];
7574 [label="this.CurrentToken.Kind 167371"];
7575 [label="get { return (SyntaxKind)this.RawKind; } 167372"];
7576 [label="this.CurrentToken 167373"];
7577 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167374"];
7578 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167375"];
7579 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 167376"];
7580 [label="this.CurrentToken.Kind 167377"];
7581 [label="get { return (SyntaxKind)this.RawKind; } 167378"];
7582 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 167379"];
7583 [label="this.IsPossibleSwitchSection() 167380"];
7584 [label="param IsPossibleSwitchSection(this) 167381"];
7585 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167382"];
7586 [label="this.CurrentToken 167383"];
7587 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167384"];
7588 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167385"];
7589 [label="this.CurrentToken.Kind 167386"];
7590 [label="get { return (SyntaxKind)this.RawKind; } 167387"];
7591 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 167388"];
7592 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 167389"];
7593 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 167390"];
7594 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 167391"];
7595 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 167392"];
7596 [label="IsMakingProgress(ref lastTokenPosition) 167393"];
7597 [label="param IsMakingProgress(ref int lastTokenPosition) 167394"];
7598 [label="param IsMakingProgress(bool assertIfFalse = true) 167395"];
7599 [label="param IsMakingProgress(this) 167396"];
7600 [label="_firstToken + _tokenOffset 167397"];
7601 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 167398"];
7602 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 167399"];
7603 [label="if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                } 167400"];
7604 [label="this.IsPossibleStatement(acceptAccessibilityMods: true) 167401"];
7605 [label="param IsPossibleStatement(bool acceptAccessibilityMods) 167402"];
7606 [label="param IsPossibleStatement(this) 167403"];
7607 [label="this.CurrentToken 167404"];
7608 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167405"];
7609 [label="var tk = this.CurrentToken.Kind; 167406"];
7610 [label="this.CurrentToken.Kind 167407"];
7611 [label="get { return (SyntaxKind)this.RawKind; } 167408"];
7612 [label="switch (tk)\n            {\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.ThrowKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.OpenBracketToken:\n                    return true;\n\n                case SyntaxKind.IdentifierToken:\n                    return IsTrueIdentifier();\n\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.FinallyKeyword:\n                    return !_isInTry;\n\n                // Accessibility modifiers are not legal in a statement,\n                // but a common mistake for local functions. Parse to give a\n                // better error message.\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PrivateKeyword:\n                    return acceptAccessibilityMods;\n                default:\n                    return IsPredefinedType(tk)\n                        || IsPossibleExpression();\n            } 167409"];
7613 [label="return true; 167410"];
7614 [label="if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                } 167411"];
7615 [label="this.ParsePossiblyAttributedStatement() 167412"];
7616 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 167413"];
7617 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 167414"];
7618 [label="this.CurrentToken.Kind 167415"];
7619 [label="get { return (SyntaxKind)this.RawKind; } 167416"];
7620 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 167417"];
7621 [label="false 167418"];
7622 [label="isGlobal: false 167419"];
7623 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 167420"];
7624 [label="param ParseStatementCore(bool isGlobal) 167421"];
7625 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 167422"];
7626 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 167423"];
7627 [label="canReuseStatement(attributes, isGlobal) 167424"];
7628 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 167425"];
7629 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 167426"];
7630 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 167427"];
7631 [label="this.IsIncrementalAndFactoryContextMatches 167428"];
7632 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 167429"];
7633 [label="base.IsIncremental 167430"];
7634 [label="get\n            {\n                return _isIncremental;\n            } 167431"];
7635 [label="return _isIncremental; 167432"];
7636 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 167433"];
7637 [label="return false; 167434"];
7638 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 167435"];
7639 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 167436"];
7640 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 167437"];
7641 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 167438"];
7642 [label="StatementSyntax result; 167439"];
7643 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 167440"];
7644 [label="this.EatToken() 167441"];
7645 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 167442"];
7646 [label="MoveToNextToken(); 167443"];
7647 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 167444"];
7648 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 167445"];
7649 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 167446"];
7650 [label="param TryGetNode(int kind) 167447"];
7651 [label="param TryGetNode(GreenNode child1) 167448"];
7652 [label="param TryGetNode(GreenNode child2) 167449"];
7653 [label="param TryGetNode(SyntaxFactoryContext context) 167450"];
7654 [label="param TryGetNode(out int hash) 167451"];
7655 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 167452"];
7656 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 167453"];
7657 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 167454"];
7658 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 167455"];
7659 [label="GetNodeFlags(context) 167456"];
7660 [label="param GetNodeFlags(SyntaxFactoryContext context) 167457"];
7661 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 167458"];
7662 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 167459"];
7663 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 167460"];
7664 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 167461"];
7665 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 167462"];
7666 [label="param SetFactoryContext(SyntaxFactoryContext context) 167463"];
7667 [label="param SetFactoryContext(this) 167464"];
7668 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 167465"];
7669 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 167466"];
7670 [label="_recursionDepth 167467"];
7671 [label="this.Release(ref resetPointBeforeStatement); 167468"];
7672 [label="this.Release(ref resetPointBeforeStatement) 167469"];
7673 [label="param Release(ref ResetPoint state) 167470"];
7674 [label="base.Release(ref state.BaseResetPoint); 167471"];
7675 [label="param Release(ref ResetPoint point) 167472"];
7676 [label="Debug.Assert(_resetCount == point.ResetCount); 167473"];
7677 [label="_resetCount 167474"];
7678 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 167475"];
7679 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 167476"];
7680 [label="base.Release(ref state.BaseResetPoint); 167477"];
7681 [label="this.Release(ref resetPointBeforeStatement); 167478"];
7682 [label="var statement = this.ParsePossiblyAttributedStatement(); 167479"];
7683 [label="if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    } 167480"];
7684 [label="if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    } 167481"];
7685 [label="statements.Add(statement); 167482"];
7686 [label="statements.Add(statement); 167483"];
7687 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 167484"];
7688 [label="_termState 167485"];
7689 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 167486"];
7690 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 167487"];
7691 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 167488"];
7692 [label="return _syntaxFactory.SwitchSection(labels, statements); 167489"];
7693 [label="return _syntaxFactory.SwitchSection(labels, statements); 167490"];
7694 [label="return _syntaxFactory.SwitchSection(labels, statements); 167491"];
7695 [label="return _syntaxFactory.SwitchSection(labels, statements); 167492"];
7696 [label="param TryGetNode(SyntaxFactoryContext context) 167493"];
7697 [label="GetNodeFlags(context) 167494"];
7698 [label="param GetNodeFlags(SyntaxFactoryContext context) 167495"];
7699 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 167496"];
7700 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 167497"];
7701 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 167498"];
7702 [label="param SetFactoryContext(SyntaxFactoryContext context) 167499"];
7703 [label="param SetFactoryContext(this) 167500"];
7704 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 167501"];
7705 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 167502"];
7706 [label="_pool.Free(statements); 167503"];
7707 [label="_pool.Free(statements); 167504"];
7708 [label="_pool.Free(labels); 167505"];
7709 [label="_pool.Free(labels); 167506"];
7710 [label="var swcase = this.ParseSwitchSection(); 167507"];
7711 [label="sections.Add(swcase); 167508"];
7712 [label="sections.Add(swcase); 167509"];
7713 [label="this.CurrentToken 167510"];
7714 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167511"];
7715 [label="this.CurrentToken.Kind 167512"];
7716 [label="var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken); 167513"];
7717 [label="this.EatToken(SyntaxKind.CloseBraceToken) 167514"];
7718 [label="param EatToken(SyntaxKind kind) 167515"];
7719 [label="param EatToken(this) 167516"];
7720 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 167517"];
7721 [label="SyntaxFacts.IsAnyToken(kind) 167518"];
7722 [label="param IsAnyToken(SyntaxKind kind) 167519"];
7723 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 167520"];
7724 [label="return true; 167521"];
7725 [label="this.CurrentToken 167522"];
7726 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167523"];
7727 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 167524"];
7728 [label="ct.Kind 167525"];
7729 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 167526"];
7730 [label="param GetTrailingTrivia(this) 167527"];
7731 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 167528"];
7732 [label="MoveToNextToken(); 167529"];
7733 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 167530"];
7734 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 167531"];
7735 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 167532"];
7736 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 167533"];
7737 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 167534"];
7738 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 167535"];
7739 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 167536"];
7740 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 167537"];
7741 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 167538"];
7742 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 167539"];
7743 [label="param CSharpSyntaxNode(this) 167540"];
7744 [label="GreenStats.NoteGreen(this); 167541"];
7745 [label="param SetFactoryContext(SyntaxFactoryContext context) 167542"];
7746 [label="param SetFactoryContext(this) 167543"];
7747 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 167544"];
7748 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 167545"];
7749 [label="_pool.Free(sections); 167546"];
7750 [label="_pool.Free(sections); 167547"];
7751 [label="this.Release(ref resetPointBeforeStatement); 167548"];
7752 [label="this.Release(ref resetPointBeforeStatement) 167549"];
7753 [label="param Release(ref ResetPoint state) 167550"];
7754 [label="param Release(this) 167551"];
7755 [label="base.Release(ref state.BaseResetPoint); 167552"];
7756 [label="base.Release(ref state.BaseResetPoint) 167553"];
7757 [label="param Release(ref ResetPoint point) 167554"];
7758 [label="param Release(this) 167555"];
7759 [label="Debug.Assert(_resetCount == point.ResetCount); 167556"];
7760 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 167557"];
7761 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 167558"];
7762 [label="_resetStart = -1; 167559"];
7763 [label="_resetStart 167560"];
7764 [label="base.Release(ref state.BaseResetPoint); 167561"];
7765 [label="this.Release(ref resetPointBeforeStatement); 167562"];
7766 [label="var node = parser.ParseStatement(); 167563"];
7767 [label="if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node); 167564"];
7768 [label="node = parser.ConsumeUnexpectedTokens(node); 167565"];
7769 [label="parser.ConsumeUnexpectedTokens(node) 167566"];
7770 [label="param ConsumeUnexpectedTokens(TNode node) 167567"];
7771 [label="param ConsumeUnexpectedTokens(this) 167568"];
7772 [label="this.CurrentToken 167569"];
7773 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 167570"];
7774 [label="this.FetchCurrentToken() 167571"];
7775 [label="param FetchCurrentToken(this) 167572"];
7776 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 167573"];
7777 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 167574"];
7778 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 167575"];
7779 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken) return node; 167576"];
7780 [label="this.CurrentToken.Kind 167577"];
7781 [label="get { return (SyntaxKind)this.RawKind; } 167578"];
7782 [label="return node; 167579"];
7783 [label="return (StatementSyntax)node.CreateRed(); 167580"];
7784 [label="return (StatementSyntax)node.CreateRed(); 167581"];
7785 [label="return (StatementSyntax)node.CreateRed(); 167582"];
7786 [label="param CSharpSyntaxNode(GreenNode green) 167583"];
7787 [label="param CSharpSyntaxNode(SyntaxNode? parent) 167584"];
7788 [label="param CSharpSyntaxNode(int position) 167585"];
7789 [label="param CSharpSyntaxNode(this) 167586"];
7790 [label="green 167587"];
7791 [label="parent 167588"];
7792 [label="position 167589"];
7793 [label="param CSharpSyntaxNode(this) 167590"];
7794 [label="param CSharpSyntaxNode(this) 167591"];
7795 [label="CustomAssert.NotNull(statement); 167592"];
7796 [label="CustomAssert.Equal(SyntaxKind.SwitchStatement, statement.Kind()); 167593"];
7797 [label="statement.Kind() 167594"];
7798 [label="param Kind(this) 167595"];
7799 [label="return (SyntaxKind)this.Green.RawKind; 167596"];
7800 [label="CustomAssert.Equal(SyntaxKind.SwitchStatement, statement.Kind()); 167597"];
7801 [label="CustomAssert.Equal(text, statement.ToString()); 167598"];
7802 [label="CustomAssert.Equal(text, statement.ToString()); 167599"];
7803 [label="CustomAssert.Equal(text, statement.ToString()); 167600"];
7804 [label="=> true 167601"];
7805 [label="true 167602"];
7806 [label="CustomAssert.Equal(text, statement.ToString()); 167603"];
7807 [label="param WriteTokenTo(System.IO.TextWriter writer) 167604"];
7808 [label="param WriteTokenTo(bool leading) 167605"];
7809 [label="param WriteTokenTo(bool trailing) 167606"];
7810 [label="param WriteTokenTo(this) 167607"];
7811 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 167608"];
7812 [label="this.Text 167609"];
7813 [label="get { return SyntaxFacts.GetText(this.Kind); } 167610"];
7814 [label="this.Kind 167611"];
7815 [label="get { return (SyntaxKind)this.RawKind; } 167612"];
7816 [label="return (SyntaxKind)this.RawKind; 167613"];
7817 [label="return SyntaxFacts.GetText(this.Kind); 167614"];
7818 [label="SyntaxFacts.GetText(this.Kind) 167615"];
7819 [label="param GetText(SyntaxKind kind) 167616"];
7820 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 167617"];
7821 [label="return 'switch'; 167618"];
7822 [label="writer.Write(this.Text); 167619"];
7823 [label="writer.Write(this.Text); 167620"];
7824 [label="if (trailing)\n            {\n                var trivia = this.GetTrailingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 167621"];
7825 [label="this.GetTrailingTrivia() 167622"];
7826 [label="param GetTrailingTrivia(this) 167623"];
7827 [label="return this.TrailingField; 167624"];
7828 [label="var trivia = this.GetTrailingTrivia(); 167625"];
7829 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 167626"];
7830 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 167627"];
7831 [label="trivia.WriteTo(writer, true, true); 167628"];
7832 [label="trivia.WriteTo(writer, true, true); 167629"];
7833 [label="=> true 167630"];
7834 [label="true 167631"];
7835 [label="param WriteTriviaTo(System.IO.TextWriter writer) 167632"];
7836 [label="param WriteTriviaTo(this) 167633"];
7837 [label="writer.Write(Text); 167634"];
7838 [label="writer.Write(Text); 167635"];
7839 [label="this.GetLeadingTrivia() 167636"];
7840 [label="param GetLeadingTrivia(this) 167637"];
7841 [label="return null; 167638"];
7842 [label="var trivia = this.GetLeadingTrivia(); 167639"];
7843 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 167640"];
7844 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 167641"];
7845 [label="return '('; 167642"];
7846 [label="param GetTrailingTrivia(this) 167643"];
7847 [label="var trivia = this.GetTrailingTrivia(); 167644"];
7848 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 167645"];
7849 [label="get { return this.TextField; } 167646"];
7850 [label="return this.TextField; 167647"];
7851 [label="param GetLeadingTrivia(this) 167648"];
7852 [label="return this.LeadingField; 167649"];
7853 [label="var trivia = this.GetLeadingTrivia(); 167650"];
7854 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 167651"];
7855 [label="return ')'; 167652"];
7856 [label="=> true 167653"];
7857 [label="return this.LeadingField; 167654"];
7858 [label="var trivia = this.GetLeadingTrivia(); 167655"];
7859 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 167656"];
7860 [label="return '{'; 167657"];
7861 [label="=> true 167658"];
7862 [label="return this.LeadingField; 167659"];
7863 [label="var trivia = this.GetLeadingTrivia(); 167660"];
7864 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 167661"];
7865 [label="return 'case'; 167662"];
7866 [label="=> true 167663"];
7867 [label="return this.LeadingField; 167664"];
7868 [label="var trivia = this.GetLeadingTrivia(); 167665"];
7869 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 167666"];
7870 [label="return ':'; 167667"];
7871 [label="=> true 167668"];
7872 [label="return this.LeadingField; 167669"];
7873 [label="var trivia = this.GetLeadingTrivia(); 167670"];
7874 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 167671"];
7875 [label="return ';'; 167672"];
7876 [label="=> true 167673"];
7877 [label="return '}'; 167674"];
7878 [label="CustomAssert.Equal(0, statement.Errors().Length); 167675"];
7879 [label="CustomAssert.Equal(0, statement.Errors().Length); 167676"];
7880 [label="statement.Errors() 167677"];
7881 [label="param Errors(this SyntaxNode node) 167678"];
7882 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 167679"];
7883 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 167680"];
7884 [label="node.Green.ErrorsOrWarnings(errorsOnly: true) 167681"];
7885 [label="param ErrorsOrWarnings(this GreenNode node) 167682"];
7886 [label="param ErrorsOrWarnings(bool errorsOnly) 167683"];
7887 [label="ArrayBuilder<DiagnosticInfo> b = ArrayBuilder<DiagnosticInfo>.GetInstance(); 167684"];
7888 [label="var l = new SyntaxDiagnosticInfoList(node); 167685"];
7889 [label="foreach (var item in l)\n            {\n                if (item.Severity == (errorsOnly ? DiagnosticSeverity.Error : DiagnosticSeverity.Warning))\n                    b.Add(item);\n            } 167686"];
7890 [label="return b.ToImmutableAndFree(); 167687"];
7891 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 167688"];
7892 [label="CustomAssert.Equal(0, statement.Errors().Length); 167689"];
7893 [label="var ss = (SwitchStatementSyntax)statement; 167690"];
7894 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 167691"];
7895 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 167692"];
7896 [label="ss.SwitchKeyword 167693"];
7897 [label="=> true 167694"];
7898 [label="true 167695"];
7899 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 167696"];
7900 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 167697"];
7901 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 167698"];
7902 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 167699"];
7903 [label="ss.SwitchKeyword 167700"];
7904 [label="=> true 167701"];
7905 [label="true 167702"];
7906 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 167703"];
7907 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 167704"];
7908 [label="param Kind(this SyntaxToken token) 167705"];
7909 [label="var rawKind = token.RawKind; 167706"];
7910 [label="return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None; 167707"];
7911 [label="IsCSharpKind(rawKind) 167708"];
7912 [label="param IsCSharpKind(int rawKind) 167709"];
7913 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 167710"];
7914 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 167711"];
7915 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 167712"];
7916 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 167713"];
7917 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 167714"];
7918 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 167715"];
7919 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 167716"];
7920 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 167717"];
7921 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 167718"];
7922 [label="ss.OpenParenToken 167719"];
7923 [label="=> true 167720"];
7924 [label="true 167721"];
7925 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 167722"];
7926 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 167723"];
7927 [label="CustomAssert.NotNull(ss.Expression); 167724"];
7928 [label="ss.Expression 167725"];
7929 [label="param CSharpSyntaxNode(GreenNode green) 167726"];
7930 [label="param CSharpSyntaxNode(SyntaxNode? parent) 167727"];
7931 [label="param CSharpSyntaxNode(int position) 167728"];
7932 [label="param CSharpSyntaxNode(this) 167729"];
7933 [label="param CSharpSyntaxNode(this) 167730"];
7934 [label="CustomAssert.Equal('a', ss.Expression.ToString()); 167731"];
7935 [label="ss.Expression.ToString() 167732"];
7936 [label="param ToString(this) 167733"];
7937 [label="this.Identifier.Text 167734"];
7938 [label="get { return this.TextField; } 167735"];
7939 [label="return this.Identifier.Text; 167736"];
7940 [label="CustomAssert.Equal('a', ss.Expression.ToString()); 167737"];
7941 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 167738"];
7942 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 167739"];
7943 [label="ss.CloseParenToken 167740"];
7944 [label="=> true 167741"];
7945 [label="true 167742"];
7946 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 167743"];
7947 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 167744"];
7948 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 167745"];
7949 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 167746"];
7950 [label="ss.OpenBraceToken 167747"];
7951 [label="=> true 167748"];
7952 [label="true 167749"];
7953 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 167750"];
7954 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 167751"];
7955 [label="CustomAssert.Equal(1, ss.Sections.Count); 167752"];
7956 [label="CustomAssert.Equal(1, ss.Sections.Count); 167753"];
7957 [label="ss.Sections 167754"];
7958 [label="param CSharpSyntaxNode(GreenNode green) 167755"];
7959 [label="param CSharpSyntaxNode(SyntaxNode? parent) 167756"];
7960 [label="param CSharpSyntaxNode(int position) 167757"];
7961 [label="param CSharpSyntaxNode(this) 167758"];
7962 [label="param CSharpSyntaxNode(this) 167759"];
7963 [label="CustomAssert.Equal(2, ss.Sections[0].Labels.Count); 167760"];
7964 [label="CustomAssert.Equal(2, ss.Sections[0].Labels.Count); 167761"];
7965 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 167762"];
7966 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 167763"];
7967 [label="ss.Sections[0].Labels[0].Keyword 167764"];
7968 [label="param CSharpSyntaxNode(GreenNode green) 167765"];
7969 [label="param CSharpSyntaxNode(SyntaxNode? parent) 167766"];
7970 [label="param CSharpSyntaxNode(int position) 167767"];
7971 [label="param CSharpSyntaxNode(this) 167768"];
7972 [label="param CSharpSyntaxNode(this) 167769"];
7973 [label="=> true 167770"];
7974 [label="true 167771"];
7975 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 167772"];
7976 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 167773"];
7977 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 167774"];
7978 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 167775"];
7979 [label="ss.Sections[0].Labels[0].Keyword 167776"];
7980 [label="=> true 167777"];
7981 [label="true 167778"];
7982 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 167779"];
7983 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 167780"];
7984 [label="param Kind(this SyntaxToken token) 167781"];
7985 [label="IsCSharpKind(rawKind) 167782"];
7986 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 167783"];
7987 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 167784"];
7988 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 167785"];
7989 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 167786"];
7990 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 167787"];
7991 [label="var caseLabelSyntax = ss.Sections[0].Labels[0] as CaseSwitchLabelSyntax; 167788"];
7992 [label="var caseLabelSyntax = ss.Sections[0].Labels[0] as CaseSwitchLabelSyntax; 167789"];
7993 [label="CustomAssert.NotNull(caseLabelSyntax); 167790"];
7994 [label="CustomAssert.NotNull(caseLabelSyntax.Value); 167791"];
7995 [label="caseLabelSyntax.Value 167792"];
7996 [label="param CSharpSyntaxNode(GreenNode green) 167793"];
7997 [label="param CSharpSyntaxNode(SyntaxNode? parent) 167794"];
7998 [label="param CSharpSyntaxNode(int position) 167795"];
7999 [label="param CSharpSyntaxNode(this) 167796"];
8000 [label="param CSharpSyntaxNode(this) 167797"];
8001 [label="CustomAssert.Equal('b', caseLabelSyntax.Value.ToString()); 167798"];
8002 [label="caseLabelSyntax.Value.ToString() 167799"];
8003 [label="param ToString(this) 167800"];
8004 [label="this.Identifier.Text 167801"];
8005 [label="get { return this.TextField; } 167802"];
8006 [label="return this.Identifier.Text; 167803"];
8007 [label="CustomAssert.Equal('b', caseLabelSyntax.Value.ToString()); 167804"];
8008 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[1].Keyword); 167805"];
8009 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[1].Keyword); 167806"];
8010 [label="ss.Sections[0].Labels[1].Keyword 167807"];
8011 [label="param CSharpSyntaxNode(GreenNode green) 167808"];
8012 [label="param CSharpSyntaxNode(SyntaxNode? parent) 167809"];
8013 [label="param CSharpSyntaxNode(int position) 167810"];
8014 [label="param CSharpSyntaxNode(this) 167811"];
8015 [label="param CSharpSyntaxNode(this) 167812"];
8016 [label="=> true 167813"];
8017 [label="true 167814"];
8018 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[1].Keyword); 167815"];
8019 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[1].Keyword.Kind()); 167816"];
8020 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[1].Keyword.Kind()); 167817"];
8021 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[1].Keyword.Kind()); 167818"];
8022 [label="ss.Sections[0].Labels[1].Keyword 167819"];
8023 [label="=> true 167820"];
8024 [label="true 167821"];
8025 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[1].Keyword.Kind()); 167822"];
8026 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[1].Keyword.Kind()); 167823"];
8027 [label="param Kind(this SyntaxToken token) 167824"];
8028 [label="IsCSharpKind(rawKind) 167825"];
8029 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 167826"];
8030 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 167827"];
8031 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 167828"];
8032 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 167829"];
8033 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 167830"];
8034 [label="var caseLabelSyntax2 = ss.Sections[0].Labels[1] as CaseSwitchLabelSyntax; 167831"];
8035 [label="var caseLabelSyntax2 = ss.Sections[0].Labels[1] as CaseSwitchLabelSyntax; 167832"];
8036 [label="CustomAssert.NotNull(caseLabelSyntax2); 167833"];
8037 [label="CustomAssert.NotNull(caseLabelSyntax2.Value); 167834"];
8038 [label="caseLabelSyntax2.Value 167835"];
8039 [label="param CSharpSyntaxNode(GreenNode green) 167836"];
8040 [label="param CSharpSyntaxNode(SyntaxNode? parent) 167837"];
8041 [label="param CSharpSyntaxNode(int position) 167838"];
8042 [label="param CSharpSyntaxNode(this) 167839"];
8043 [label="param CSharpSyntaxNode(this) 167840"];
8044 [label="CustomAssert.Equal('c', caseLabelSyntax2.Value.ToString()); 167841"];
8045 [label="caseLabelSyntax2.Value.ToString() 167842"];
8046 [label="param ToString(this) 167843"];
8047 [label="this.Identifier.Text 167844"];
8048 [label="get { return this.TextField; } 167845"];
8049 [label="return this.Identifier.Text; 167846"];
8050 [label="CustomAssert.Equal('c', caseLabelSyntax2.Value.ToString()); 167847"];
8051 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].ColonToken); 167848"];
8052 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].ColonToken); 167849"];
8053 [label="ss.Sections[0].Labels[0].ColonToken 167850"];
8054 [label="=> true 167851"];
8055 [label="true 167852"];
8056 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].ColonToken); 167853"];
8057 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].ColonToken); 167854"];
8058 [label="CustomAssert.Equal(1, ss.Sections[0].Statements.Count); 167855"];
8059 [label="CustomAssert.Equal(1, ss.Sections[0].Statements.Count); 167856"];
8060 [label="ss.Sections[0].Statements 167857"];
8061 [label="param CSharpSyntaxNode(GreenNode green) 167858"];
8062 [label="param CSharpSyntaxNode(SyntaxNode? parent) 167859"];
8063 [label="param CSharpSyntaxNode(int position) 167860"];
8064 [label="param CSharpSyntaxNode(this) 167861"];
8065 [label="param CSharpSyntaxNode(this) 167862"];
8066 [label="CustomAssert.Equal(';', ss.Sections[0].Statements[0].ToString()); 167863"];
8067 [label="CustomAssert.Equal(';', ss.Sections[0].Statements[0].ToString()); 167864"];
8068 [label="=> true 167865"];
8069 [label="true 167866"];
8070 [label="param WriteTokenTo(bool leading) 167867"];
8071 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 167868"];
8072 [label="this.Text 167869"];
8073 [label="this.Kind 167870"];
8074 [label="SyntaxFacts.GetText(this.Kind) 167871"];
8075 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 167872"];
8076 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 167873"];
8077 [label="ss.CloseBraceToken 167874"];
8078 [label="=> true 167875"];
8079 [label="true 167876"];
8080 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 167877"];
8081 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 167878"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 1;
192 -> 1;
193 -> 191;
193 -> 1;
194 -> 193;
194 -> 192;
195 -> 192;
196 -> 195;
197 -> 196;
198 -> 197;
199 -> 198;
199 -> 197;
200 -> 195;
200 -> 192;
201 -> 195;
201 -> 192;
202 -> 195;
202 -> 192;
203 -> 194;
203 -> 195;
203 -> 192;
204 -> 1;
204 -> 2;
204 -> 199;
204 -> 200;
204 -> 201;
204 -> 203;
205 -> 1;
206 -> 1;
207 -> 206;
207 -> 1;
208 -> 1;
209 -> 1;
210 -> 207;
210 -> 209;
211 -> 208;
211 -> 209;
212 -> 208;
212 -> 209;
213 -> 205;
213 -> 209;
215 -> 214;
216 -> 215;
218 -> 216;
218 -> 217;
219 -> 217;
220 -> 217;
221 -> 218;
221 -> 217;
222 -> 219;
222 -> 221;
223 -> 0;
223 -> 222;
224 -> 217;
225 -> 223;
225 -> 224;
225 -> 217;
227 -> 0;
227 -> 217;
228 -> 218;
228 -> 217;
229 -> 217;
230 -> 227;
230 -> 229;
231 -> 228;
231 -> 229;
232 -> 230;
232 -> 229;
233 -> 231;
233 -> 229;
234 -> 229;
235 -> 229;
236 -> 232;
236 -> 235;
237 -> 233;
237 -> 235;
238 -> 234;
238 -> 235;
239 -> 234;
239 -> 235;
240 -> 234;
240 -> 235;
241 -> 236;
241 -> 235;
242 -> 238;
242 -> 235;
243 -> 239;
243 -> 235;
245 -> 244;
246 -> 237;
246 -> 235;
247 -> 235;
248 -> 241;
248 -> 247;
249 -> 242;
249 -> 247;
250 -> 243;
250 -> 247;
251 -> 246;
251 -> 247;
252 -> 240;
252 -> 247;
253 -> 248;
253 -> 247;
254 -> 249;
254 -> 247;
255 -> 250;
255 -> 247;
256 -> 251;
256 -> 247;
257 -> 247;
258 -> 257;
258 -> 253;
258 -> 254;
258 -> 255;
258 -> 256;
258 -> 247;
259 -> 257;
259 -> 247;
260 -> 259;
260 -> 258;
260 -> 247;
261 -> 240;
261 -> 235;
262 -> 237;
262 -> 240;
262 -> 235;
263 -> 236;
263 -> 0;
263 -> 235;
264 -> 234;
264 -> 217;
265 -> 219;
265 -> 217;
266 -> 264;
266 -> 265;
267 -> 266;
270 -> 268;
270 -> 269;
271 -> 269;
272 -> 269;
273 -> 270;
273 -> 269;
274 -> 271;
274 -> 273;
275 -> 0;
275 -> 274;
276 -> 269;
277 -> 275;
277 -> 276;
277 -> 269;
278 -> 0;
278 -> 269;
279 -> 270;
279 -> 269;
280 -> 269;
281 -> 278;
281 -> 280;
282 -> 279;
282 -> 280;
283 -> 281;
283 -> 280;
284 -> 282;
284 -> 280;
285 -> 280;
286 -> 280;
287 -> 283;
287 -> 286;
288 -> 284;
288 -> 286;
289 -> 285;
289 -> 286;
290 -> 285;
290 -> 286;
291 -> 285;
291 -> 286;
292 -> 287;
292 -> 286;
293 -> 289;
293 -> 286;
294 -> 290;
294 -> 286;
295 -> 288;
295 -> 286;
296 -> 286;
297 -> 292;
297 -> 296;
298 -> 293;
298 -> 296;
299 -> 294;
299 -> 296;
300 -> 295;
300 -> 296;
301 -> 291;
301 -> 296;
302 -> 297;
302 -> 296;
303 -> 298;
303 -> 296;
304 -> 299;
304 -> 296;
305 -> 300;
305 -> 296;
306 -> 296;
307 -> 306;
307 -> 302;
307 -> 303;
307 -> 304;
307 -> 305;
307 -> 296;
308 -> 306;
308 -> 296;
309 -> 308;
309 -> 307;
309 -> 296;
310 -> 291;
310 -> 286;
311 -> 288;
311 -> 291;
311 -> 286;
312 -> 287;
312 -> 0;
312 -> 286;
313 -> 285;
313 -> 269;
314 -> 271;
314 -> 269;
315 -> 313;
315 -> 314;
316 -> 315;
319 -> 317;
319 -> 318;
320 -> 318;
321 -> 318;
322 -> 319;
322 -> 318;
323 -> 320;
323 -> 322;
324 -> 0;
324 -> 323;
325 -> 318;
326 -> 324;
326 -> 325;
326 -> 318;
327 -> 0;
327 -> 318;
328 -> 319;
328 -> 318;
329 -> 318;
330 -> 327;
330 -> 329;
331 -> 328;
331 -> 329;
332 -> 330;
332 -> 329;
333 -> 331;
333 -> 329;
334 -> 329;
335 -> 329;
336 -> 332;
336 -> 335;
337 -> 333;
337 -> 335;
338 -> 334;
338 -> 335;
339 -> 334;
339 -> 335;
340 -> 334;
340 -> 335;
341 -> 336;
341 -> 335;
342 -> 338;
342 -> 335;
343 -> 339;
343 -> 335;
344 -> 337;
344 -> 335;
345 -> 335;
346 -> 341;
346 -> 345;
347 -> 342;
347 -> 345;
348 -> 343;
348 -> 345;
349 -> 344;
349 -> 345;
350 -> 340;
350 -> 345;
351 -> 346;
351 -> 345;
352 -> 347;
352 -> 345;
353 -> 348;
353 -> 345;
354 -> 349;
354 -> 345;
355 -> 345;
356 -> 355;
356 -> 351;
356 -> 352;
356 -> 353;
356 -> 354;
356 -> 345;
357 -> 355;
357 -> 345;
358 -> 357;
358 -> 356;
358 -> 345;
359 -> 340;
359 -> 335;
360 -> 337;
360 -> 340;
360 -> 335;
361 -> 336;
361 -> 0;
361 -> 335;
362 -> 334;
362 -> 318;
363 -> 320;
363 -> 318;
364 -> 362;
364 -> 363;
365 -> 364;
368 -> 366;
368 -> 367;
369 -> 367;
370 -> 0;
370 -> 367;
371 -> 368;
371 -> 367;
372 -> 367;
373 -> 370;
373 -> 372;
374 -> 371;
374 -> 372;
375 -> 373;
375 -> 372;
376 -> 374;
376 -> 372;
377 -> 372;
378 -> 372;
379 -> 375;
379 -> 378;
380 -> 376;
380 -> 378;
381 -> 377;
381 -> 378;
382 -> 377;
382 -> 378;
383 -> 377;
383 -> 378;
384 -> 379;
384 -> 378;
385 -> 381;
385 -> 378;
386 -> 382;
386 -> 378;
387 -> 380;
387 -> 378;
388 -> 378;
389 -> 384;
389 -> 388;
390 -> 385;
390 -> 388;
391 -> 386;
391 -> 388;
392 -> 387;
392 -> 388;
393 -> 383;
393 -> 388;
394 -> 389;
394 -> 388;
395 -> 390;
395 -> 388;
396 -> 391;
396 -> 388;
397 -> 392;
397 -> 388;
398 -> 388;
399 -> 398;
399 -> 394;
399 -> 395;
399 -> 396;
399 -> 397;
399 -> 388;
400 -> 398;
400 -> 388;
401 -> 400;
401 -> 399;
401 -> 388;
402 -> 383;
402 -> 378;
403 -> 380;
403 -> 383;
403 -> 378;
404 -> 379;
404 -> 0;
404 -> 378;
405 -> 377;
405 -> 367;
406 -> 369;
406 -> 367;
407 -> 405;
407 -> 406;
408 -> 407;
411 -> 409;
411 -> 410;
412 -> 410;
413 -> 0;
413 -> 410;
414 -> 411;
414 -> 410;
415 -> 410;
416 -> 413;
416 -> 415;
417 -> 414;
417 -> 415;
418 -> 416;
418 -> 415;
419 -> 417;
419 -> 415;
420 -> 415;
421 -> 415;
422 -> 418;
422 -> 421;
423 -> 419;
423 -> 421;
424 -> 420;
424 -> 421;
425 -> 420;
425 -> 421;
426 -> 420;
426 -> 421;
427 -> 422;
427 -> 421;
428 -> 424;
428 -> 421;
429 -> 425;
429 -> 421;
430 -> 423;
430 -> 421;
431 -> 421;
432 -> 427;
432 -> 431;
433 -> 428;
433 -> 431;
434 -> 429;
434 -> 431;
435 -> 430;
435 -> 431;
436 -> 426;
436 -> 431;
437 -> 432;
437 -> 431;
438 -> 433;
438 -> 431;
439 -> 434;
439 -> 431;
440 -> 435;
440 -> 431;
441 -> 431;
442 -> 441;
442 -> 437;
442 -> 438;
442 -> 439;
442 -> 440;
442 -> 431;
443 -> 441;
443 -> 431;
444 -> 443;
444 -> 442;
444 -> 431;
445 -> 426;
445 -> 421;
446 -> 423;
446 -> 426;
446 -> 421;
447 -> 422;
447 -> 0;
447 -> 421;
448 -> 420;
448 -> 410;
449 -> 412;
449 -> 410;
450 -> 448;
450 -> 449;
451 -> 450;
452 -> 215;
454 -> 453;
456 -> 452;
456 -> 455;
457 -> 454;
457 -> 455;
458 -> 455;
459 -> 456;
459 -> 455;
460 -> 457;
460 -> 459;
461 -> 0;
461 -> 460;
462 -> 455;
463 -> 461;
463 -> 462;
463 -> 455;
464 -> 0;
464 -> 455;
465 -> 456;
465 -> 455;
466 -> 455;
467 -> 464;
467 -> 466;
468 -> 465;
468 -> 466;
469 -> 467;
469 -> 466;
470 -> 468;
470 -> 466;
471 -> 466;
472 -> 466;
473 -> 469;
473 -> 472;
474 -> 470;
474 -> 472;
475 -> 471;
475 -> 472;
476 -> 471;
476 -> 472;
477 -> 471;
477 -> 472;
478 -> 473;
478 -> 472;
479 -> 475;
479 -> 472;
480 -> 476;
480 -> 472;
481 -> 474;
481 -> 472;
482 -> 472;
483 -> 478;
483 -> 482;
484 -> 479;
484 -> 482;
485 -> 480;
485 -> 482;
486 -> 481;
486 -> 482;
487 -> 477;
487 -> 482;
488 -> 483;
488 -> 482;
489 -> 484;
489 -> 482;
490 -> 485;
490 -> 482;
491 -> 486;
491 -> 482;
492 -> 482;
493 -> 492;
493 -> 488;
493 -> 489;
493 -> 490;
493 -> 491;
493 -> 482;
494 -> 492;
494 -> 482;
495 -> 494;
495 -> 493;
495 -> 482;
496 -> 477;
496 -> 472;
497 -> 474;
497 -> 477;
497 -> 472;
498 -> 473;
498 -> 0;
498 -> 472;
499 -> 471;
499 -> 455;
500 -> 457;
500 -> 455;
501 -> 499;
501 -> 455;
502 -> 455;
503 -> 0;
503 -> 502;
503 -> 455;
504 -> 501;
504 -> 502;
504 -> 495;
504 -> 496;
504 -> 497;
504 -> 503;
504 -> 0;
504 -> 455;
505 -> 504;
505 -> 502;
506 -> 504;
506 -> 502;
507 -> 502;
508 -> 506;
508 -> 507;
509 -> 508;
509 -> 504;
509 -> 507;
510 -> 509;
510 -> 502;
511 -> 506;
511 -> 504;
511 -> 502;
512 -> 505;
512 -> 502;
513 -> 502;
514 -> 502;
515 -> 510;
515 -> 514;
516 -> 511;
516 -> 514;
517 -> 511;
517 -> 514;
518 -> 512;
518 -> 514;
519 -> 513;
519 -> 514;
520 -> 514;
521 -> 519;
521 -> 520;
522 -> 520;
523 -> 522;
523 -> 515;
523 -> 517;
523 -> 518;
523 -> 516;
523 -> 511;
523 -> 520;
524 -> 522;
524 -> 520;
525 -> 519;
525 -> 514;
526 -> 515;
526 -> 0;
526 -> 514;
527 -> 523;
530 -> 529;
532 -> 528;
532 -> 531;
533 -> 530;
533 -> 531;
534 -> 531;
535 -> 532;
535 -> 531;
536 -> 533;
536 -> 535;
537 -> 0;
537 -> 536;
538 -> 531;
539 -> 537;
539 -> 538;
539 -> 531;
540 -> 0;
540 -> 531;
541 -> 532;
541 -> 531;
542 -> 531;
543 -> 540;
543 -> 542;
544 -> 541;
544 -> 542;
545 -> 543;
545 -> 542;
546 -> 544;
546 -> 542;
547 -> 542;
548 -> 542;
549 -> 545;
549 -> 548;
550 -> 546;
550 -> 548;
551 -> 547;
551 -> 548;
552 -> 547;
552 -> 548;
553 -> 547;
553 -> 548;
554 -> 549;
554 -> 548;
555 -> 551;
555 -> 548;
556 -> 552;
556 -> 548;
557 -> 550;
557 -> 548;
558 -> 548;
559 -> 554;
559 -> 558;
560 -> 555;
560 -> 558;
561 -> 556;
561 -> 558;
562 -> 557;
562 -> 558;
563 -> 553;
563 -> 558;
564 -> 559;
564 -> 558;
565 -> 560;
565 -> 558;
566 -> 561;
566 -> 558;
567 -> 562;
567 -> 558;
568 -> 558;
569 -> 568;
569 -> 564;
569 -> 565;
569 -> 566;
569 -> 567;
569 -> 558;
570 -> 568;
570 -> 558;
571 -> 570;
571 -> 569;
571 -> 558;
572 -> 553;
572 -> 548;
573 -> 550;
573 -> 553;
573 -> 548;
574 -> 549;
574 -> 0;
574 -> 548;
575 -> 547;
575 -> 531;
576 -> 533;
576 -> 531;
577 -> 575;
577 -> 531;
578 -> 531;
579 -> 0;
579 -> 578;
579 -> 531;
580 -> 577;
580 -> 578;
580 -> 571;
580 -> 572;
580 -> 573;
580 -> 579;
580 -> 523;
580 -> 531;
581 -> 578;
582 -> 578;
583 -> 578;
584 -> 582;
584 -> 583;
585 -> 583;
586 -> 584;
586 -> 585;
587 -> 585;
588 -> 587;
588 -> 585;
589 -> 584;
589 -> 583;
590 -> 580;
590 -> 0;
590 -> 583;
591 -> 580;
594 -> 593;
596 -> 592;
596 -> 595;
597 -> 594;
597 -> 595;
598 -> 595;
599 -> 596;
599 -> 595;
600 -> 597;
600 -> 599;
601 -> 0;
601 -> 600;
602 -> 595;
603 -> 601;
603 -> 602;
603 -> 595;
604 -> 0;
604 -> 595;
605 -> 596;
605 -> 595;
606 -> 595;
607 -> 604;
607 -> 606;
608 -> 605;
608 -> 606;
609 -> 607;
609 -> 606;
610 -> 608;
610 -> 606;
611 -> 606;
612 -> 606;
613 -> 609;
613 -> 612;
614 -> 610;
614 -> 612;
615 -> 611;
615 -> 612;
616 -> 611;
616 -> 612;
617 -> 611;
617 -> 612;
618 -> 613;
618 -> 612;
619 -> 615;
619 -> 612;
620 -> 616;
620 -> 612;
621 -> 614;
621 -> 612;
622 -> 612;
623 -> 618;
623 -> 622;
624 -> 619;
624 -> 622;
625 -> 620;
625 -> 622;
626 -> 621;
626 -> 622;
627 -> 617;
627 -> 622;
628 -> 623;
628 -> 622;
629 -> 624;
629 -> 622;
630 -> 625;
630 -> 622;
631 -> 626;
631 -> 622;
632 -> 622;
633 -> 632;
633 -> 628;
633 -> 629;
633 -> 630;
633 -> 631;
633 -> 622;
634 -> 632;
634 -> 622;
635 -> 634;
635 -> 633;
635 -> 622;
636 -> 617;
636 -> 612;
637 -> 614;
637 -> 617;
637 -> 612;
638 -> 613;
638 -> 0;
638 -> 612;
639 -> 611;
639 -> 595;
640 -> 597;
640 -> 595;
641 -> 639;
641 -> 595;
642 -> 595;
643 -> 0;
643 -> 642;
643 -> 595;
644 -> 641;
644 -> 642;
644 -> 635;
644 -> 636;
644 -> 637;
644 -> 643;
644 -> 580;
644 -> 595;
645 -> 642;
646 -> 642;
647 -> 642;
648 -> 646;
648 -> 647;
649 -> 647;
650 -> 648;
650 -> 649;
651 -> 649;
652 -> 651;
652 -> 649;
653 -> 648;
653 -> 647;
654 -> 644;
654 -> 0;
654 -> 647;
655 -> 644;
658 -> 657;
660 -> 656;
660 -> 659;
661 -> 658;
661 -> 659;
662 -> 0;
662 -> 659;
663 -> 660;
663 -> 659;
664 -> 659;
665 -> 662;
665 -> 664;
666 -> 663;
666 -> 664;
667 -> 665;
667 -> 664;
668 -> 666;
668 -> 664;
669 -> 664;
670 -> 664;
671 -> 667;
671 -> 670;
672 -> 668;
672 -> 670;
673 -> 669;
673 -> 670;
674 -> 669;
674 -> 670;
675 -> 669;
675 -> 670;
676 -> 671;
676 -> 670;
677 -> 673;
677 -> 670;
678 -> 674;
678 -> 670;
679 -> 672;
679 -> 670;
680 -> 670;
681 -> 676;
681 -> 680;
682 -> 677;
682 -> 680;
683 -> 678;
683 -> 680;
684 -> 679;
684 -> 680;
685 -> 675;
685 -> 680;
686 -> 681;
686 -> 680;
687 -> 682;
687 -> 680;
688 -> 683;
688 -> 680;
689 -> 684;
689 -> 680;
690 -> 680;
691 -> 690;
691 -> 686;
691 -> 687;
691 -> 688;
691 -> 689;
691 -> 680;
692 -> 690;
692 -> 680;
693 -> 692;
693 -> 691;
693 -> 680;
694 -> 675;
694 -> 670;
695 -> 672;
695 -> 675;
695 -> 670;
696 -> 671;
696 -> 0;
696 -> 670;
697 -> 669;
697 -> 659;
698 -> 661;
698 -> 659;
699 -> 697;
699 -> 659;
700 -> 659;
701 -> 0;
701 -> 700;
701 -> 659;
702 -> 699;
702 -> 700;
702 -> 693;
702 -> 694;
702 -> 695;
702 -> 701;
702 -> 644;
702 -> 659;
703 -> 700;
704 -> 700;
705 -> 700;
706 -> 704;
706 -> 705;
707 -> 705;
708 -> 706;
708 -> 707;
709 -> 707;
710 -> 709;
710 -> 707;
711 -> 706;
711 -> 705;
712 -> 702;
712 -> 0;
712 -> 705;
713 -> 702;
716 -> 715;
718 -> 714;
718 -> 717;
719 -> 716;
719 -> 717;
720 -> 0;
720 -> 717;
721 -> 718;
721 -> 717;
722 -> 717;
723 -> 720;
723 -> 722;
724 -> 721;
724 -> 722;
725 -> 723;
725 -> 722;
726 -> 724;
726 -> 722;
727 -> 722;
728 -> 722;
729 -> 725;
729 -> 728;
730 -> 726;
730 -> 728;
731 -> 727;
731 -> 728;
732 -> 727;
732 -> 728;
733 -> 727;
733 -> 728;
734 -> 729;
734 -> 728;
735 -> 731;
735 -> 728;
736 -> 732;
736 -> 728;
737 -> 730;
737 -> 728;
738 -> 728;
739 -> 734;
739 -> 738;
740 -> 735;
740 -> 738;
741 -> 736;
741 -> 738;
742 -> 737;
742 -> 738;
743 -> 733;
743 -> 738;
744 -> 739;
744 -> 738;
745 -> 740;
745 -> 738;
746 -> 741;
746 -> 738;
747 -> 742;
747 -> 738;
748 -> 738;
749 -> 748;
749 -> 744;
749 -> 745;
749 -> 746;
749 -> 747;
749 -> 738;
750 -> 748;
750 -> 738;
751 -> 750;
751 -> 749;
751 -> 738;
752 -> 733;
752 -> 728;
753 -> 730;
753 -> 733;
753 -> 728;
754 -> 729;
754 -> 0;
754 -> 728;
755 -> 727;
755 -> 717;
756 -> 719;
756 -> 717;
757 -> 755;
757 -> 717;
758 -> 717;
759 -> 0;
759 -> 758;
759 -> 717;
760 -> 757;
760 -> 758;
760 -> 751;
760 -> 752;
760 -> 753;
760 -> 759;
760 -> 702;
760 -> 717;
761 -> 758;
762 -> 758;
763 -> 758;
764 -> 762;
764 -> 763;
765 -> 763;
766 -> 764;
766 -> 765;
767 -> 765;
768 -> 767;
768 -> 765;
769 -> 764;
769 -> 763;
770 -> 760;
770 -> 0;
770 -> 763;
771 -> 760;
772 -> 0;
774 -> 773;
776 -> 772;
776 -> 775;
777 -> 774;
777 -> 775;
778 -> 0;
778 -> 775;
779 -> 776;
779 -> 775;
780 -> 775;
781 -> 778;
781 -> 780;
782 -> 779;
782 -> 780;
783 -> 781;
783 -> 780;
784 -> 782;
784 -> 780;
785 -> 780;
786 -> 780;
787 -> 783;
787 -> 786;
788 -> 784;
788 -> 786;
789 -> 785;
789 -> 786;
790 -> 785;
790 -> 786;
791 -> 785;
791 -> 786;
792 -> 787;
792 -> 786;
793 -> 789;
793 -> 786;
794 -> 790;
794 -> 786;
795 -> 788;
795 -> 786;
796 -> 786;
797 -> 792;
797 -> 796;
798 -> 793;
798 -> 796;
799 -> 794;
799 -> 796;
800 -> 795;
800 -> 796;
801 -> 791;
801 -> 796;
802 -> 797;
802 -> 796;
803 -> 798;
803 -> 796;
804 -> 799;
804 -> 796;
805 -> 800;
805 -> 796;
806 -> 796;
807 -> 806;
807 -> 802;
807 -> 803;
807 -> 804;
807 -> 805;
807 -> 796;
808 -> 806;
808 -> 796;
809 -> 808;
809 -> 807;
809 -> 796;
810 -> 791;
810 -> 786;
811 -> 788;
811 -> 791;
811 -> 786;
812 -> 787;
812 -> 0;
812 -> 786;
813 -> 785;
813 -> 775;
814 -> 777;
814 -> 775;
815 -> 813;
815 -> 775;
816 -> 775;
817 -> 0;
817 -> 816;
817 -> 775;
818 -> 815;
818 -> 816;
818 -> 809;
818 -> 810;
818 -> 811;
818 -> 817;
818 -> 760;
818 -> 775;
819 -> 816;
820 -> 816;
821 -> 816;
822 -> 820;
822 -> 821;
823 -> 821;
824 -> 822;
824 -> 823;
825 -> 823;
826 -> 825;
826 -> 823;
827 -> 822;
827 -> 821;
828 -> 818;
828 -> 0;
828 -> 821;
829 -> 818;
832 -> 267;
832 -> 831;
833 -> 831;
834 -> 832;
834 -> 831;
835 -> 833;
835 -> 834;
835 -> 260;
835 -> 261;
835 -> 262;
835 -> 831;
837 -> 316;
837 -> 836;
838 -> 836;
839 -> 837;
839 -> 836;
840 -> 838;
840 -> 839;
840 -> 309;
840 -> 310;
840 -> 311;
840 -> 836;
842 -> 365;
842 -> 841;
843 -> 841;
844 -> 842;
844 -> 841;
845 -> 843;
845 -> 844;
845 -> 358;
845 -> 359;
845 -> 360;
845 -> 841;
847 -> 408;
847 -> 846;
848 -> 846;
849 -> 847;
849 -> 846;
850 -> 848;
850 -> 849;
850 -> 401;
850 -> 402;
850 -> 403;
850 -> 846;
852 -> 451;
852 -> 851;
853 -> 851;
854 -> 852;
854 -> 851;
855 -> 853;
855 -> 854;
855 -> 444;
855 -> 445;
855 -> 446;
855 -> 851;
857 -> 527;
857 -> 856;
858 -> 856;
859 -> 857;
859 -> 856;
860 -> 858;
860 -> 859;
860 -> 818;
860 -> 856;
862 -> 591;
862 -> 861;
863 -> 861;
864 -> 862;
864 -> 861;
865 -> 863;
865 -> 864;
865 -> 860;
865 -> 861;
867 -> 655;
867 -> 866;
868 -> 866;
869 -> 867;
869 -> 866;
870 -> 868;
870 -> 869;
870 -> 865;
870 -> 866;
872 -> 713;
872 -> 871;
873 -> 871;
874 -> 872;
874 -> 871;
875 -> 873;
875 -> 874;
875 -> 870;
875 -> 871;
877 -> 771;
877 -> 876;
878 -> 876;
879 -> 877;
879 -> 876;
880 -> 878;
880 -> 879;
880 -> 875;
880 -> 876;
882 -> 829;
882 -> 881;
883 -> 881;
884 -> 882;
884 -> 881;
885 -> 883;
885 -> 884;
885 -> 880;
885 -> 881;
886 -> 210;
886 -> 209;
887 -> 211;
887 -> 209;
888 -> 212;
888 -> 209;
889 -> 209;
890 -> 209;
891 -> 886;
891 -> 890;
892 -> 887;
892 -> 890;
893 -> 888;
893 -> 890;
894 -> 889;
894 -> 890;
895 -> 891;
895 -> 890;
896 -> 892;
896 -> 890;
897 -> 893;
897 -> 890;
898 -> 890;
899 -> 895;
899 -> 898;
900 -> 896;
900 -> 898;
901 -> 897;
901 -> 898;
902 -> 899;
902 -> 898;
903 -> 900;
903 -> 898;
904 -> 898;
905 -> 902;
905 -> 904;
906 -> 903;
906 -> 904;
907 -> 905;
907 -> 904;
908 -> 0;
908 -> 904;
909 -> 904;
910 -> 906;
910 -> 904;
911 -> 907;
911 -> 910;
911 -> 904;
913 -> 912;
914 -> 912;
915 -> 912;
916 -> 912;
917 -> 912;
918 -> 913;
918 -> 912;
919 -> 914;
919 -> 912;
920 -> 915;
920 -> 912;
921 -> 916;
921 -> 912;
922 -> 921;
922 -> 912;
923 -> 0;
923 -> 912;
924 -> 918;
924 -> 917;
925 -> 919;
925 -> 917;
926 -> 920;
926 -> 917;
927 -> 922;
927 -> 917;
928 -> 923;
928 -> 917;
929 -> 917;
930 -> 926;
930 -> 917;
931 -> 925;
931 -> 917;
932 -> 929;
932 -> 930;
932 -> 931;
932 -> 917;
933 -> 929;
933 -> 917;
934 -> 929;
934 -> 917;
935 -> 929;
935 -> 917;
936 -> 924;
936 -> 929;
936 -> 917;
937 -> 924;
937 -> 917;
938 -> 917;
939 -> 937;
939 -> 938;
940 -> 939;
940 -> 938;
941 -> 0;
941 -> 940;
942 -> 941;
942 -> 929;
942 -> 917;
943 -> 927;
943 -> 917;
944 -> 943;
944 -> 929;
944 -> 917;
945 -> 928;
945 -> 917;
946 -> 0;
946 -> 917;
947 -> 945;
947 -> 929;
947 -> 917;
948 -> 912;
950 -> 949;
953 -> 952;
955 -> 954;
966 -> 957;
966 -> 956;
967 -> 958;
967 -> 956;
968 -> 959;
968 -> 956;
969 -> 960;
969 -> 956;
970 -> 961;
970 -> 956;
971 -> 962;
971 -> 956;
972 -> 963;
972 -> 956;
973 -> 964;
973 -> 956;
974 -> 965;
974 -> 956;
975 -> 956;
977 -> 976;
978 -> 948;
978 -> 898;
979 -> 978;
979 -> 901;
979 -> 898;
980 -> 898;
981 -> 898;
982 -> 911;
982 -> 981;
983 -> 979;
983 -> 981;
984 -> 980;
984 -> 981;
985 -> 980;
985 -> 981;
986 -> 980;
986 -> 981;
987 -> 982;
987 -> 981;
988 -> 981;
989 -> 987;
989 -> 988;
990 -> 986;
990 -> 988;
991 -> 990;
991 -> 988;
992 -> 990;
992 -> 988;
993 -> 0;
995 -> 994;
997 -> 996;
998 -> 997;
999 -> 989;
999 -> 988;
1000 -> 988;
1001 -> 988;
1002 -> 999;
1002 -> 1001;
1003 -> 1000;
1003 -> 1001;
1004 -> 1003;
1004 -> 1001;
1005 -> 1003;
1005 -> 1001;
1006 -> 1003;
1006 -> 1001;
1007 -> 1003;
1007 -> 1001;
1008 -> 1003;
1008 -> 1001;
1009 -> 1003;
1009 -> 1001;
1010 -> 1003;
1010 -> 1001;
1011 -> 1003;
1011 -> 1001;
1012 -> 1002;
1012 -> 1003;
1012 -> 1001;
1013 -> 1001;
1014 -> 1013;
1014 -> 1003;
1014 -> 1001;
1015 -> 1001;
1016 -> 1015;
1016 -> 1003;
1016 -> 1001;
1017 -> 1002;
1017 -> 911;
1017 -> 1003;
1017 -> 1001;
1018 -> 1001;
1019 -> 1018;
1019 -> 1003;
1019 -> 1001;
1020 -> 998;
1020 -> 997;
1020 -> 1001;
1021 -> 1020;
1021 -> 1003;
1021 -> 1001;
1022 -> 1001;
1023 -> 1022;
1023 -> 1003;
1023 -> 1001;
1024 -> 1000;
1024 -> 990;
1024 -> 988;
1025 -> 986;
1025 -> 981;
1026 -> 986;
1026 -> 981;
1027 -> 986;
1027 -> 981;
1028 -> 986;
1028 -> 981;
1029 -> 986;
1029 -> 981;
1030 -> 986;
1030 -> 981;
1031 -> 986;
1031 -> 981;
1032 -> 986;
1032 -> 981;
1033 -> 986;
1033 -> 981;
1034 -> 986;
1034 -> 981;
1035 -> 981;
1036 -> 1035;
1036 -> 981;
1037 -> 1036;
1037 -> 986;
1037 -> 981;
1038 -> 981;
1039 -> 1038;
1039 -> 981;
1040 -> 1039;
1040 -> 986;
1040 -> 981;
1041 -> 986;
1041 -> 981;
1042 -> 986;
1042 -> 981;
1043 -> 981;
1044 -> 983;
1044 -> 1043;
1044 -> 981;
1045 -> 983;
1045 -> 986;
1045 -> 981;
1046 -> 981;
1047 -> 1046;
1047 -> 986;
1047 -> 981;
1048 -> 981;
1049 -> 1048;
1049 -> 986;
1049 -> 981;
1052 -> 1050;
1052 -> 1051;
1053 -> 1052;
1055 -> 1054;
1056 -> 981;
1057 -> 981;
1058 -> 1056;
1058 -> 1057;
1059 -> 1058;
1059 -> 1057;
1060 -> 1058;
1060 -> 1057;
1061 -> 1058;
1061 -> 1057;
1062 -> 1057;
1063 -> 1062;
1063 -> 1058;
1063 -> 1057;
1064 -> 1057;
1065 -> 1064;
1065 -> 1058;
1065 -> 1057;
1066 -> 1053;
1066 -> 1052;
1066 -> 1057;
1067 -> 1066;
1067 -> 1058;
1067 -> 1057;
1068 -> 1056;
1068 -> 986;
1068 -> 981;
1069 -> 986;
1069 -> 981;
1070 -> 984;
1070 -> 986;
1070 -> 981;
1071 -> 985;
1071 -> 986;
1071 -> 981;
1072 -> 980;
1072 -> 890;
1073 -> 1072;
1073 -> 890;
1074 -> 890;
1075 -> 1073;
1075 -> 1074;
1076 -> 0;
1077 -> 1075;
1077 -> 1074;
1078 -> 1074;
1079 -> 1074;
1080 -> 1077;
1080 -> 1079;
1081 -> 1078;
1081 -> 1079;
1082 -> 1078;
1082 -> 1079;
1083 -> 1078;
1083 -> 1079;
1084 -> 1078;
1084 -> 1079;
1085 -> 1078;
1085 -> 1079;
1088 -> 1086;
1088 -> 1087;
1089 -> 1088;
1090 -> 1080;
1090 -> 1079;
1091 -> 1083;
1091 -> 1079;
1092 -> 1081;
1092 -> 1079;
1093 -> 1082;
1093 -> 1079;
1094 -> 1079;
1095 -> 1079;
1096 -> 1084;
1096 -> 1079;
1097 -> 1079;
1098 -> 1090;
1098 -> 1097;
1099 -> 1091;
1099 -> 1097;
1100 -> 1092;
1100 -> 1097;
1101 -> 1093;
1101 -> 1097;
1102 -> 1094;
1102 -> 1097;
1103 -> 1095;
1103 -> 1097;
1104 -> 1096;
1104 -> 1097;
1105 -> 1085;
1105 -> 1097;
1106 -> 1105;
1106 -> 1097;
1107 -> 1105;
1107 -> 1097;
1108 -> 1105;
1108 -> 1097;
1109 -> 1105;
1109 -> 1097;
1110 -> 1105;
1110 -> 1097;
1111 -> 1105;
1111 -> 1097;
1112 -> 1105;
1112 -> 1097;
1113 -> 1105;
1113 -> 1097;
1114 -> 1105;
1114 -> 1097;
1115 -> 1105;
1115 -> 1097;
1116 -> 1105;
1116 -> 1097;
1117 -> 1105;
1117 -> 1097;
1118 -> 1105;
1118 -> 1097;
1119 -> 1098;
1119 -> 1105;
1119 -> 1097;
1120 -> 1099;
1120 -> 1105;
1120 -> 1097;
1121 -> 1102;
1121 -> 1105;
1121 -> 1097;
1122 -> 1104;
1122 -> 1105;
1122 -> 1097;
1123 -> 1097;
1124 -> 1123;
1124 -> 1105;
1124 -> 1097;
1125 -> 1097;
1126 -> 1100;
1126 -> 1125;
1126 -> 1097;
1127 -> 1126;
1127 -> 1105;
1127 -> 1097;
1128 -> 1097;
1129 -> 1105;
1129 -> 1128;
1130 -> 1129;
1130 -> 1127;
1130 -> 1128;
1131 -> 1130;
1131 -> 1097;
1132 -> 1131;
1132 -> 1102;
1132 -> 1097;
1133 -> 1132;
1134 -> 1133;
1134 -> 1105;
1134 -> 1132;
1135 -> 1132;
1136 -> 1135;
1136 -> 1105;
1136 -> 1132;
1137 -> 1097;
1138 -> 1105;
1138 -> 1137;
1139 -> 1138;
1139 -> 1127;
1139 -> 1137;
1140 -> 1139;
1140 -> 1097;
1141 -> 1103;
1141 -> 1140;
1141 -> 1097;
1142 -> 1141;
1142 -> 1104;
1142 -> 1078;
1142 -> 1097;
1143 -> 1142;
1144 -> 1105;
1144 -> 1143;
1145 -> 1143;
1146 -> 1143;
1147 -> 1144;
1147 -> 1119;
1147 -> 1024;
1147 -> 1146;
1148 -> 1147;
1148 -> 1012;
1148 -> 1146;
1149 -> 1148;
1149 -> 1143;
1150 -> 1149;
1150 -> 1143;
1151 -> 1150;
1151 -> 1144;
1151 -> 1143;
1152 -> 1144;
1152 -> 1119;
1152 -> 1143;
1153 -> 1144;
1153 -> 1120;
1153 -> 1143;
1154 -> 1143;
1155 -> 1154;
1155 -> 1149;
1155 -> 1143;
1156 -> 1153;
1156 -> 1155;
1157 -> 1155;
1158 -> 1156;
1158 -> 1157;
1159 -> 1152;
1159 -> 1157;
1160 -> 951;
1160 -> 1157;
1161 -> 1158;
1161 -> 1159;
1161 -> 1157;
1162 -> 1159;
1162 -> 1161;
1162 -> 1157;
1163 -> 1159;
1163 -> 1024;
1163 -> 992;
1163 -> 1045;
1163 -> 1161;
1163 -> 1047;
1163 -> 1049;
1163 -> 1029;
1163 -> 1068;
1163 -> 1070;
1163 -> 1071;
1163 -> 1033;
1163 -> 1034;
1163 -> 1037;
1163 -> 1040;
1163 -> 1041;
1163 -> 1069;
1163 -> 1012;
1163 -> 1014;
1163 -> 1016;
1163 -> 1017;
1163 -> 1021;
1163 -> 1009;
1163 -> 1023;
1163 -> 1019;
1163 -> 911;
1163 -> 1036;
1163 -> 1039;
1163 -> 932;
1163 -> 933;
1163 -> 947;
1163 -> 934;
1163 -> 942;
1163 -> 935;
1163 -> 936;
1163 -> 944;
1163 -> 945;
1163 -> 943;
1163 -> 1046;
1163 -> 1048;
1163 -> 1063;
1163 -> 1065;
1163 -> 1067;
1163 -> 1066;
1163 -> 1064;
1163 -> 1062;
1163 -> 1018;
1163 -> 1020;
1163 -> 1162;
1164 -> 1162;
1165 -> 1163;
1165 -> 1164;
1166 -> 1164;
1167 -> 1165;
1167 -> 1163;
1167 -> 1166;
1168 -> 1167;
1168 -> 1163;
1168 -> 1166;
1169 -> 1164;
1170 -> 1164;
1171 -> 1170;
1171 -> 1165;
1171 -> 1164;
1172 -> 1163;
1172 -> 1164;
1173 -> 1172;
1173 -> 1163;
1173 -> 1164;
1174 -> 1163;
1174 -> 1173;
1174 -> 1168;
1174 -> 1171;
1174 -> 1162;
1175 -> 1163;
1175 -> 1164;
1176 -> 1175;
1176 -> 1174;
1176 -> 1164;
1177 -> 1163;
1177 -> 1164;
1178 -> 1177;
1178 -> 1176;
1178 -> 1164;
1179 -> 1163;
1179 -> 1164;
1180 -> 1163;
1180 -> 1164;
1181 -> 1180;
1181 -> 1178;
1181 -> 1179;
1181 -> 1164;
1182 -> 1181;
1182 -> 1180;
1182 -> 1164;
1183 -> 1163;
1183 -> 1164;
1184 -> 1183;
1184 -> 1178;
1184 -> 1164;
1185 -> 1163;
1185 -> 1184;
1185 -> 1178;
1185 -> 1182;
1185 -> 1162;
1186 -> 1163;
1186 -> 1164;
1187 -> 1163;
1187 -> 1164;
1188 -> 1186;
1188 -> 1187;
1188 -> 1185;
1188 -> 1164;
1189 -> 1164;
1190 -> 1188;
1190 -> 1189;
1190 -> 1164;
1191 -> 1188;
1191 -> 1187;
1191 -> 1185;
1191 -> 1164;
1192 -> 1188;
1192 -> 1187;
1192 -> 1190;
1193 -> 1162;
1194 -> 1159;
1194 -> 1193;
1195 -> 1194;
1195 -> 1192;
1195 -> 1193;
1196 -> 1193;
1197 -> 1194;
1197 -> 1195;
1197 -> 1196;
1198 -> 1197;
1198 -> 1195;
1198 -> 1196;
1199 -> 1198;
1199 -> 1193;
1200 -> 1193;
1201 -> 1194;
1201 -> 1195;
1201 -> 1193;
1202 -> 1193;
1203 -> 1199;
1203 -> 1202;
1204 -> 1200;
1204 -> 1202;
1205 -> 1201;
1205 -> 1202;
1206 -> 1194;
1206 -> 1202;
1207 -> 1204;
1207 -> 1202;
1208 -> 1202;
1209 -> 1208;
1210 -> 1206;
1210 -> 1209;
1211 -> 1209;
1212 -> 1210;
1212 -> 1195;
1212 -> 1211;
1213 -> 1209;
1214 -> 1209;
1215 -> 1214;
1215 -> 1210;
1215 -> 1209;
1216 -> 1208;
1217 -> 1208;
1218 -> 1206;
1218 -> 1195;
1218 -> 1217;
1219 -> 1218;
1219 -> 1195;
1219 -> 1217;
1220 -> 1217;
1221 -> 1218;
1221 -> 1220;
1222 -> 1221;
1222 -> 1195;
1222 -> 1220;
1223 -> 1222;
1224 -> 1221;
1224 -> 1223;
1225 -> 1224;
1225 -> 1195;
1225 -> 1223;
1226 -> 1225;
1226 -> 1222;
1227 -> 1222;
1228 -> 1221;
1228 -> 1195;
1228 -> 1212;
1228 -> 1227;
1228 -> 1222;
1229 -> 1221;
1229 -> 1195;
1229 -> 1212;
1229 -> 1215;
1229 -> 1222;
1230 -> 1221;
1230 -> 1195;
1230 -> 1222;
1231 -> 1221;
1231 -> 1195;
1231 -> 1212;
1231 -> 1215;
1231 -> 1222;
1232 -> 1221;
1232 -> 1195;
1232 -> 1222;
1233 -> 1231;
1233 -> 1222;
1234 -> 1221;
1234 -> 1233;
1234 -> 1231;
1234 -> 1222;
1235 -> 1234;
1235 -> 1221;
1235 -> 1222;
1236 -> 1222;
1237 -> 1231;
1237 -> 1236;
1237 -> 1222;
1238 -> 1237;
1238 -> 1217;
1239 -> 1218;
1239 -> 1233;
1239 -> 1235;
1239 -> 1217;
1240 -> 1239;
1240 -> 1208;
1241 -> 1208;
1242 -> 1240;
1242 -> 1241;
1242 -> 1208;
1243 -> 1242;
1244 -> 1240;
1244 -> 1208;
1245 -> 1244;
1246 -> 1194;
1246 -> 1233;
1246 -> 1205;
1246 -> 1193;
1247 -> 1193;
1248 -> 1193;
1249 -> 1194;
1249 -> 1248;
1250 -> 1248;
1251 -> 1249;
1251 -> 1233;
1251 -> 1250;
1252 -> 1248;
1253 -> 1248;
1254 -> 1253;
1254 -> 1249;
1254 -> 1248;
1255 -> 1193;
1256 -> 1247;
1256 -> 1193;
1257 -> 1256;
1257 -> 1194;
1257 -> 1233;
1257 -> 1235;
1257 -> 1205;
1257 -> 1251;
1257 -> 1254;
1257 -> 1247;
1257 -> 1193;
1258 -> 1193;
1259 -> 1257;
1259 -> 1258;
1260 -> 1259;
1260 -> 1257;
1260 -> 1258;
1261 -> 1257;
1261 -> 1260;
1261 -> 1258;
1262 -> 1257;
1262 -> 1260;
1262 -> 1258;
1263 -> 1257;
1263 -> 1258;
1264 -> 1257;
1264 -> 1258;
1265 -> 0;
1265 -> 1263;
1265 -> 1258;
1266 -> 1263;
1266 -> 1258;
1267 -> 1258;
1268 -> 1266;
1268 -> 1267;
1269 -> 1264;
1269 -> 1267;
1270 -> 1268;
1270 -> 1267;
1271 -> 1270;
1271 -> 1269;
1271 -> 1262;
1271 -> 1265;
1271 -> 1267;
1272 -> 1267;
1273 -> 1271;
1273 -> 1272;
1274 -> 1271;
1274 -> 1272;
1275 -> 1271;
1275 -> 1272;
1276 -> 1271;
1276 -> 1272;
1277 -> 1273;
1277 -> 1272;
1278 -> 1274;
1278 -> 1272;
1279 -> 1275;
1279 -> 1272;
1280 -> 1276;
1280 -> 1271;
1280 -> 1277;
1280 -> 1278;
1280 -> 1279;
1280 -> 1272;
1281 -> 1280;
1282 -> 0;
1282 -> 1281;
1283 -> 1281;
1284 -> 1282;
1284 -> 1283;
1285 -> 1264;
1285 -> 1283;
1286 -> 1285;
1286 -> 1280;
1286 -> 1283;
1287 -> 1283;
1288 -> 1286;
1288 -> 1287;
1289 -> 1288;
1289 -> 0;
1289 -> 1287;
1290 -> 1289;
1290 -> 1284;
1290 -> 1283;
1291 -> 1280;
1291 -> 1290;
1292 -> 1290;
1293 -> 1291;
1293 -> 1292;
1294 -> 1291;
1294 -> 1292;
1295 -> 1264;
1295 -> 1280;
1295 -> 1292;
1296 -> 1293;
1296 -> 1055;
1296 -> 1292;
1298 -> 1297;
1299 -> 1297;
1300 -> 1293;
1300 -> 1292;
1301 -> 1300;
1301 -> 1295;
1301 -> 1280;
1301 -> 1292;
1302 -> 1292;
1303 -> 1301;
1303 -> 1302;
1304 -> 1303;
1304 -> 1302;
1305 -> 0;
1305 -> 1304;
1306 -> 1305;
1306 -> 0;
1306 -> 1292;
1307 -> 1280;
1307 -> 1305;
1307 -> 1306;
1308 -> 1306;
1309 -> 1307;
1309 -> 1308;
1310 -> 1309;
1310 -> 1308;
1311 -> 1310;
1312 -> 1280;
1312 -> 1305;
1312 -> 0;
1312 -> 1281;
1313 -> 1280;
1314 -> 1280;
1314 -> 1313;
1314 -> 1305;
1314 -> 1193;
1315 -> 1246;
1315 -> 1193;
1316 -> 1193;
1317 -> 1315;
1317 -> 1316;
1318 -> 1316;
1319 -> 1316;
1320 -> 1317;
1320 -> 1319;
1320 -> 1316;
1321 -> 1320;
1322 -> 1321;
1322 -> 1317;
1322 -> 1314;
1322 -> 1320;
1323 -> 1318;
1323 -> 1316;
1324 -> 1323;
1324 -> 1193;
1325 -> 1193;
1326 -> 1324;
1326 -> 1325;
1327 -> 1194;
1327 -> 1325;
1328 -> 1325;
1329 -> 1327;
1329 -> 1314;
1329 -> 1328;
1329 -> 1325;
1330 -> 1329;
1331 -> 1330;
1331 -> 1193;
1332 -> 1194;
1332 -> 1314;
1332 -> 1193;
1333 -> 1193;
1334 -> 1194;
1334 -> 1332;
1334 -> 1193;
1335 -> 1193;
1336 -> 1333;
1336 -> 1335;
1337 -> 1333;
1337 -> 1335;
1338 -> 1334;
1338 -> 1335;
1339 -> 1194;
1339 -> 1335;
1340 -> 1337;
1340 -> 1335;
1341 -> 1335;
1342 -> 1341;
1343 -> 1339;
1343 -> 1342;
1344 -> 1342;
1345 -> 1343;
1345 -> 1332;
1345 -> 1344;
1346 -> 1342;
1347 -> 1342;
1348 -> 1347;
1348 -> 1343;
1348 -> 1342;
1349 -> 1341;
1350 -> 1341;
1351 -> 1339;
1351 -> 1332;
1351 -> 1350;
1352 -> 1351;
1352 -> 1332;
1352 -> 1350;
1353 -> 1351;
1353 -> 1341;
1354 -> 1341;
1355 -> 1353;
1355 -> 1354;
1355 -> 1341;
1356 -> 1339;
1356 -> 1332;
1356 -> 1345;
1356 -> 1348;
1356 -> 1355;
1357 -> 1355;
1358 -> 1356;
1358 -> 1357;
1359 -> 1356;
1359 -> 1357;
1360 -> 1359;
1360 -> 1356;
1360 -> 1357;
1361 -> 1356;
1361 -> 1360;
1361 -> 1357;
1362 -> 1356;
1362 -> 1357;
1363 -> 1362;
1363 -> 1360;
1363 -> 1357;
1364 -> 1338;
1364 -> 1355;
1365 -> 1355;
1366 -> 1363;
1366 -> 1365;
1367 -> 1364;
1367 -> 1365;
1368 -> 1339;
1368 -> 1365;
1369 -> 1365;
1370 -> 1368;
1370 -> 1369;
1371 -> 1369;
1372 -> 1370;
1372 -> 1363;
1372 -> 1371;
1372 -> 1369;
1373 -> 1372;
1373 -> 1365;
1374 -> 1365;
1375 -> 1367;
1375 -> 1374;
1375 -> 1365;
1376 -> 1366;
1376 -> 1365;
1377 -> 1367;
1377 -> 1376;
1377 -> 1363;
1377 -> 1365;
1378 -> 1377;
1378 -> 1350;
1379 -> 1377;
1380 -> 1377;
1380 -> 1341;
1381 -> 1380;
1382 -> 1194;
1382 -> 1377;
1382 -> 1367;
1382 -> 1193;
1383 -> 1314;
1383 -> 1193;
1384 -> 1246;
1384 -> 1193;
1385 -> 1382;
1385 -> 1193;
1386 -> 1331;
1386 -> 1193;
1387 -> 1193;
1388 -> 1383;
1388 -> 1387;
1389 -> 1384;
1389 -> 1387;
1390 -> 1385;
1390 -> 1387;
1391 -> 1386;
1391 -> 1387;
1392 -> 1194;
1392 -> 1387;
1393 -> 1388;
1393 -> 1314;
1393 -> 0;
1393 -> 1387;
1394 -> 1389;
1394 -> 1377;
1394 -> 1348;
1394 -> 1367;
1394 -> 1387;
1395 -> 1390;
1395 -> 1394;
1395 -> 1387;
1396 -> 1387;
1397 -> 1388;
1397 -> 1314;
1397 -> 1387;
1398 -> 1388;
1398 -> 1314;
1398 -> 1397;
1399 -> 1388;
1399 -> 1314;
1399 -> 1398;
1400 -> 1398;
1401 -> 1399;
1401 -> 1400;
1402 -> 1401;
1402 -> 0;
1402 -> 1400;
1403 -> 1394;
1403 -> 1398;
1404 -> 1388;
1404 -> 1314;
1404 -> 1398;
1405 -> 1395;
1405 -> 1398;
1406 -> 1398;
1407 -> 1403;
1407 -> 1406;
1408 -> 1404;
1408 -> 1406;
1409 -> 1405;
1409 -> 1406;
1410 -> 0;
1411 -> 0;
1413 -> 1411;
1413 -> 1412;
1414 -> 1413;
1415 -> 1414;
1417 -> 1411;
1417 -> 1416;
1418 -> 1417;
1419 -> 1418;
1421 -> 1411;
1421 -> 1420;
1422 -> 1421;
1423 -> 1422;
1425 -> 1411;
1425 -> 1424;
1426 -> 1425;
1427 -> 1426;
1429 -> 1410;
1430 -> 1429;
1430 -> 1411;
1431 -> 1415;
1431 -> 1414;
1431 -> 1429;
1431 -> 1430;
1432 -> 1429;
1432 -> 1430;
1433 -> 1430;
1434 -> 1430;
1435 -> 1432;
1435 -> 1434;
1436 -> 1433;
1436 -> 1434;
1437 -> 1435;
1437 -> 1434;
1438 -> 1434;
1439 -> 1437;
1439 -> 1438;
1440 -> 1436;
1440 -> 1438;
1441 -> 1439;
1441 -> 1438;
1442 -> 1438;
1443 -> 1442;
1443 -> 1441;
1443 -> 1438;
1444 -> 1442;
1444 -> 1438;
1445 -> 1444;
1445 -> 1443;
1445 -> 1438;
1446 -> 1434;
1447 -> 1436;
1447 -> 1446;
1448 -> 1446;
1449 -> 1447;
1449 -> 1448;
1450 -> 1449;
1450 -> 1445;
1450 -> 1448;
1451 -> 1450;
1451 -> 1446;
1452 -> 1446;
1453 -> 1451;
1453 -> 1452;
1454 -> 1453;
1454 -> 1452;
1455 -> 1454;
1456 -> 1455;
1456 -> 1434;
1457 -> 1456;
1457 -> 1436;
1457 -> 1434;
1458 -> 1436;
1458 -> 1445;
1458 -> 0;
1458 -> 1434;
1459 -> 1458;
1459 -> 1436;
1459 -> 1434;
1460 -> 1433;
1460 -> 1431;
1460 -> 1430;
1462 -> 1419;
1462 -> 1418;
1462 -> 1429;
1462 -> 1430;
1463 -> 1429;
1463 -> 1430;
1464 -> 829;
1464 -> 1430;
1465 -> 1430;
1466 -> 1430;
1467 -> 1463;
1467 -> 1466;
1468 -> 1464;
1468 -> 1466;
1469 -> 1464;
1469 -> 1466;
1470 -> 1465;
1470 -> 1466;
1471 -> 1467;
1471 -> 1466;
1472 -> 1466;
1473 -> 1471;
1473 -> 1472;
1474 -> 1470;
1474 -> 1472;
1475 -> 1473;
1475 -> 1472;
1476 -> 1472;
1477 -> 1475;
1477 -> 1476;
1478 -> 1474;
1478 -> 1476;
1479 -> 1477;
1479 -> 1476;
1480 -> 1476;
1481 -> 1480;
1481 -> 1479;
1481 -> 1476;
1482 -> 1480;
1482 -> 1476;
1483 -> 1482;
1483 -> 1481;
1483 -> 1476;
1484 -> 1472;
1485 -> 1474;
1485 -> 1484;
1486 -> 1484;
1487 -> 1485;
1487 -> 1486;
1488 -> 1487;
1488 -> 1483;
1488 -> 1486;
1489 -> 1488;
1489 -> 1484;
1490 -> 1484;
1491 -> 1489;
1491 -> 1490;
1492 -> 1491;
1492 -> 1490;
1493 -> 1492;
1494 -> 1493;
1494 -> 1472;
1495 -> 1494;
1495 -> 1474;
1495 -> 1472;
1496 -> 1474;
1496 -> 1483;
1496 -> 0;
1496 -> 1472;
1497 -> 1496;
1497 -> 1474;
1497 -> 1472;
1498 -> 1470;
1498 -> 1466;
1499 -> 1470;
1499 -> 1466;
1500 -> 1466;
1501 -> 1468;
1501 -> 1500;
1501 -> 1466;
1502 -> 1468;
1502 -> 1501;
1503 -> 1470;
1503 -> 1502;
1503 -> 1483;
1503 -> 1495;
1503 -> 1497;
1503 -> 1498;
1503 -> 1499;
1503 -> 885;
1503 -> 1501;
1504 -> 1468;
1504 -> 1470;
1504 -> 1501;
1505 -> 1466;
1506 -> 1469;
1506 -> 1505;
1506 -> 1466;
1507 -> 1469;
1507 -> 1506;
1508 -> 1470;
1508 -> 1507;
1508 -> 1503;
1508 -> 1504;
1508 -> 1506;
1509 -> 1469;
1509 -> 1470;
1509 -> 1506;
1510 -> 1465;
1510 -> 1462;
1510 -> 1430;
1511 -> 1423;
1511 -> 1422;
1511 -> 1429;
1511 -> 1430;
1512 -> 1429;
1512 -> 1430;
1513 -> 1430;
1514 -> 408;
1514 -> 1430;
1515 -> 1430;
1516 -> 1512;
1516 -> 1515;
1517 -> 1513;
1517 -> 1515;
1518 -> 1514;
1518 -> 1515;
1519 -> 1513;
1519 -> 1515;
1520 -> 1516;
1520 -> 1515;
1521 -> 1515;
1522 -> 1520;
1522 -> 1521;
1523 -> 1519;
1523 -> 1521;
1524 -> 1522;
1524 -> 1521;
1525 -> 1521;
1526 -> 1524;
1526 -> 1525;
1527 -> 1523;
1527 -> 1525;
1528 -> 1526;
1528 -> 1525;
1529 -> 1525;
1530 -> 1529;
1530 -> 1528;
1530 -> 1525;
1531 -> 1529;
1531 -> 1525;
1532 -> 1531;
1532 -> 1530;
1532 -> 1525;
1533 -> 1521;
1534 -> 1523;
1534 -> 1533;
1535 -> 1533;
1536 -> 1534;
1536 -> 1535;
1537 -> 1536;
1537 -> 1532;
1537 -> 1535;
1538 -> 1537;
1538 -> 1533;
1539 -> 1533;
1540 -> 1538;
1540 -> 1539;
1541 -> 1540;
1541 -> 1539;
1542 -> 1541;
1543 -> 1542;
1543 -> 1521;
1544 -> 1543;
1544 -> 1523;
1544 -> 1521;
1545 -> 1523;
1545 -> 1532;
1545 -> 0;
1545 -> 1521;
1546 -> 1545;
1546 -> 1523;
1546 -> 1521;
1547 -> 1519;
1547 -> 1515;
1548 -> 1519;
1548 -> 1515;
1549 -> 1515;
1550 -> 1517;
1550 -> 1549;
1550 -> 1515;
1551 -> 1515;
1552 -> 1518;
1552 -> 1551;
1552 -> 1515;
1553 -> 1518;
1553 -> 1552;
1554 -> 1519;
1554 -> 1553;
1554 -> 1532;
1554 -> 1544;
1554 -> 1546;
1554 -> 1547;
1554 -> 1548;
1554 -> 850;
1554 -> 1552;
1555 -> 1518;
1555 -> 1519;
1555 -> 1552;
1556 -> 1513;
1556 -> 1511;
1556 -> 1430;
1557 -> 1427;
1557 -> 1426;
1557 -> 1429;
1557 -> 1430;
1558 -> 1429;
1558 -> 1430;
1559 -> 1430;
1560 -> 267;
1560 -> 1430;
1561 -> 1430;
1562 -> 1558;
1562 -> 1561;
1563 -> 1559;
1563 -> 1561;
1564 -> 1560;
1564 -> 1561;
1565 -> 1559;
1565 -> 1561;
1566 -> 1562;
1566 -> 1561;
1567 -> 1561;
1568 -> 1566;
1568 -> 1567;
1569 -> 1565;
1569 -> 1567;
1570 -> 1568;
1570 -> 1567;
1571 -> 1567;
1572 -> 1570;
1572 -> 1571;
1573 -> 1569;
1573 -> 1571;
1574 -> 1572;
1574 -> 1571;
1575 -> 1571;
1576 -> 1575;
1576 -> 1574;
1576 -> 1571;
1577 -> 1575;
1577 -> 1571;
1578 -> 1577;
1578 -> 1576;
1578 -> 1571;
1579 -> 1567;
1580 -> 1569;
1580 -> 1579;
1581 -> 1579;
1582 -> 1580;
1582 -> 1581;
1583 -> 1582;
1583 -> 1578;
1583 -> 1581;
1584 -> 1583;
1584 -> 1579;
1585 -> 1579;
1586 -> 1584;
1586 -> 1585;
1587 -> 1586;
1587 -> 1585;
1588 -> 1587;
1589 -> 1588;
1589 -> 1567;
1590 -> 1589;
1590 -> 1569;
1590 -> 1567;
1591 -> 1569;
1591 -> 1578;
1591 -> 0;
1591 -> 1567;
1592 -> 1591;
1592 -> 1569;
1592 -> 1567;
1593 -> 1565;
1593 -> 1561;
1594 -> 1565;
1594 -> 1561;
1595 -> 1561;
1596 -> 1563;
1596 -> 1595;
1596 -> 1561;
1597 -> 1561;
1598 -> 1564;
1598 -> 1597;
1598 -> 1561;
1599 -> 1564;
1599 -> 1598;
1600 -> 1565;
1600 -> 1599;
1600 -> 1578;
1600 -> 1590;
1600 -> 1592;
1600 -> 1593;
1600 -> 1594;
1600 -> 835;
1600 -> 1598;
1601 -> 1564;
1601 -> 1565;
1601 -> 1598;
1602 -> 1559;
1602 -> 1557;
1602 -> 1430;
1603 -> 1415;
1603 -> 1414;
1603 -> 1430;
1604 -> 1433;
1604 -> 1434;
1605 -> 1604;
1605 -> 1434;
1606 -> 1605;
1606 -> 1438;
1607 -> 1606;
1607 -> 1438;
1608 -> 1442;
1608 -> 1607;
1608 -> 1438;
1609 -> 1444;
1609 -> 1608;
1609 -> 1438;
1610 -> 1449;
1610 -> 1609;
1610 -> 1448;
1611 -> 1610;
1611 -> 1446;
1612 -> 1611;
1612 -> 1452;
1613 -> 1612;
1613 -> 1452;
1614 -> 1613;
1615 -> 1614;
1615 -> 1434;
1616 -> 1615;
1616 -> 1436;
1616 -> 1434;
1617 -> 1436;
1617 -> 1609;
1617 -> 0;
1617 -> 1434;
1618 -> 1617;
1618 -> 1436;
1618 -> 1434;
1619 -> 1433;
1619 -> 1603;
1619 -> 1430;
1620 -> 1419;
1620 -> 1418;
1620 -> 1430;
1621 -> 1465;
1621 -> 1466;
1622 -> 1621;
1622 -> 1466;
1623 -> 1622;
1623 -> 1472;
1624 -> 1623;
1624 -> 1472;
1625 -> 1624;
1625 -> 1476;
1626 -> 1625;
1626 -> 1476;
1627 -> 1480;
1627 -> 1626;
1627 -> 1476;
1628 -> 1482;
1628 -> 1627;
1628 -> 1476;
1629 -> 1487;
1629 -> 1628;
1629 -> 1486;
1630 -> 1629;
1630 -> 1484;
1631 -> 1630;
1631 -> 1490;
1632 -> 1631;
1632 -> 1490;
1633 -> 1632;
1634 -> 1633;
1634 -> 1472;
1635 -> 1634;
1635 -> 1474;
1635 -> 1472;
1636 -> 1474;
1636 -> 1628;
1636 -> 0;
1636 -> 1472;
1637 -> 1636;
1637 -> 1474;
1637 -> 1472;
1638 -> 1470;
1638 -> 1502;
1638 -> 1628;
1638 -> 1635;
1638 -> 1637;
1638 -> 1498;
1638 -> 1499;
1638 -> 1508;
1638 -> 1509;
1638 -> 1501;
1639 -> 1465;
1639 -> 1620;
1639 -> 1430;
1640 -> 1423;
1640 -> 1422;
1640 -> 1430;
1641 -> 1513;
1641 -> 1515;
1642 -> 1641;
1642 -> 1515;
1643 -> 1642;
1643 -> 1521;
1644 -> 1643;
1644 -> 1521;
1645 -> 1644;
1645 -> 1525;
1646 -> 1645;
1646 -> 1525;
1647 -> 1529;
1647 -> 1646;
1647 -> 1525;
1648 -> 1531;
1648 -> 1647;
1648 -> 1525;
1649 -> 1536;
1649 -> 1648;
1649 -> 1535;
1650 -> 1649;
1650 -> 1533;
1651 -> 1650;
1651 -> 1539;
1652 -> 1651;
1652 -> 1539;
1653 -> 1652;
1654 -> 1653;
1654 -> 1521;
1655 -> 1654;
1655 -> 1523;
1655 -> 1521;
1656 -> 1523;
1656 -> 1648;
1656 -> 0;
1656 -> 1521;
1657 -> 1656;
1657 -> 1523;
1657 -> 1521;
1658 -> 1519;
1658 -> 1553;
1658 -> 1648;
1658 -> 1655;
1658 -> 1657;
1658 -> 1547;
1658 -> 1548;
1658 -> 1554;
1658 -> 1555;
1658 -> 1552;
1659 -> 1513;
1659 -> 1640;
1659 -> 1430;
1660 -> 1427;
1660 -> 1426;
1660 -> 1430;
1661 -> 1559;
1661 -> 1561;
1662 -> 1661;
1662 -> 1561;
1663 -> 1662;
1663 -> 1567;
1664 -> 1663;
1664 -> 1567;
1665 -> 1664;
1665 -> 1571;
1666 -> 1665;
1666 -> 1571;
1667 -> 1575;
1667 -> 1666;
1667 -> 1571;
1668 -> 1577;
1668 -> 1667;
1668 -> 1571;
1669 -> 1582;
1669 -> 1668;
1669 -> 1581;
1670 -> 1669;
1670 -> 1579;
1671 -> 1670;
1671 -> 1585;
1672 -> 1671;
1672 -> 1585;
1673 -> 1672;
1674 -> 1673;
1674 -> 1567;
1675 -> 1674;
1675 -> 1569;
1675 -> 1567;
1676 -> 1569;
1676 -> 1668;
1676 -> 0;
1676 -> 1567;
1677 -> 1676;
1677 -> 1569;
1677 -> 1567;
1678 -> 1565;
1678 -> 1599;
1678 -> 1668;
1678 -> 1675;
1678 -> 1677;
1678 -> 1593;
1678 -> 1594;
1678 -> 1600;
1678 -> 1601;
1678 -> 1598;
1679 -> 1559;
1679 -> 1660;
1679 -> 1430;
1680 -> 1613;
1681 -> 1680;
1681 -> 1434;
1682 -> 1681;
1682 -> 1436;
1682 -> 1434;
1683 -> 1632;
1684 -> 1683;
1684 -> 1472;
1685 -> 1684;
1685 -> 1474;
1685 -> 1472;
1686 -> 1470;
1686 -> 1502;
1686 -> 1628;
1686 -> 1685;
1686 -> 1637;
1686 -> 1498;
1686 -> 1499;
1686 -> 1638;
1686 -> 1509;
1686 -> 1501;
1687 -> 1652;
1688 -> 1687;
1688 -> 1521;
1689 -> 1688;
1689 -> 1523;
1689 -> 1521;
1690 -> 1519;
1690 -> 1553;
1690 -> 1648;
1690 -> 1689;
1690 -> 1657;
1690 -> 1547;
1690 -> 1548;
1690 -> 1658;
1690 -> 1555;
1690 -> 1552;
1691 -> 1672;
1692 -> 1691;
1692 -> 1567;
1693 -> 1692;
1693 -> 1569;
1693 -> 1567;
1694 -> 1565;
1694 -> 1599;
1694 -> 1668;
1694 -> 1693;
1694 -> 1677;
1694 -> 1593;
1694 -> 1594;
1694 -> 1678;
1694 -> 1601;
1694 -> 1598;
1695 -> 1613;
1696 -> 1695;
1696 -> 1434;
1697 -> 1696;
1697 -> 1436;
1697 -> 1434;
1698 -> 1632;
1699 -> 1698;
1699 -> 1472;
1700 -> 1699;
1700 -> 1474;
1700 -> 1472;
1701 -> 1470;
1701 -> 1502;
1701 -> 1628;
1701 -> 1700;
1701 -> 1637;
1701 -> 1498;
1701 -> 1499;
1701 -> 1686;
1701 -> 1509;
1701 -> 1501;
1702 -> 1652;
1703 -> 1702;
1703 -> 1521;
1704 -> 1703;
1704 -> 1523;
1704 -> 1521;
1705 -> 1519;
1705 -> 1553;
1705 -> 1648;
1705 -> 1704;
1705 -> 1657;
1705 -> 1547;
1705 -> 1548;
1705 -> 1690;
1705 -> 1555;
1705 -> 1552;
1706 -> 1672;
1707 -> 1706;
1707 -> 1567;
1708 -> 1707;
1708 -> 1569;
1708 -> 1567;
1709 -> 1565;
1709 -> 1599;
1709 -> 1668;
1709 -> 1708;
1709 -> 1677;
1709 -> 1593;
1709 -> 1594;
1709 -> 1694;
1709 -> 1601;
1709 -> 1598;
1710 -> 1613;
1711 -> 1710;
1711 -> 1434;
1712 -> 1711;
1712 -> 1436;
1712 -> 1434;
1713 -> 1632;
1714 -> 1713;
1714 -> 1472;
1715 -> 1714;
1715 -> 1474;
1715 -> 1472;
1716 -> 1470;
1716 -> 1502;
1716 -> 1628;
1716 -> 1715;
1716 -> 1637;
1716 -> 1498;
1716 -> 1499;
1716 -> 1701;
1716 -> 1509;
1716 -> 1501;
1717 -> 1652;
1718 -> 1717;
1718 -> 1521;
1719 -> 1718;
1719 -> 1523;
1719 -> 1521;
1720 -> 1519;
1720 -> 1553;
1720 -> 1648;
1720 -> 1719;
1720 -> 1657;
1720 -> 1547;
1720 -> 1548;
1720 -> 1705;
1720 -> 1555;
1720 -> 1552;
1721 -> 1672;
1722 -> 1721;
1722 -> 1567;
1723 -> 1722;
1723 -> 1569;
1723 -> 1567;
1724 -> 1565;
1724 -> 1599;
1724 -> 1668;
1724 -> 1723;
1724 -> 1677;
1724 -> 1593;
1724 -> 1594;
1724 -> 1709;
1724 -> 1601;
1724 -> 1598;
1725 -> 1613;
1726 -> 1725;
1726 -> 1434;
1727 -> 1726;
1727 -> 1436;
1727 -> 1434;
1728 -> 1632;
1729 -> 1728;
1729 -> 1472;
1730 -> 1729;
1730 -> 1474;
1730 -> 1472;
1731 -> 1470;
1731 -> 1502;
1731 -> 1628;
1731 -> 1730;
1731 -> 1637;
1731 -> 1498;
1731 -> 1499;
1731 -> 1716;
1731 -> 1509;
1731 -> 1501;
1732 -> 1652;
1733 -> 1732;
1733 -> 1521;
1734 -> 1733;
1734 -> 1523;
1734 -> 1521;
1735 -> 1519;
1735 -> 1553;
1735 -> 1648;
1735 -> 1734;
1735 -> 1657;
1735 -> 1547;
1735 -> 1548;
1735 -> 1720;
1735 -> 1555;
1735 -> 1552;
1736 -> 1672;
1737 -> 1736;
1737 -> 1567;
1738 -> 1737;
1738 -> 1569;
1738 -> 1567;
1739 -> 1565;
1739 -> 1599;
1739 -> 1668;
1739 -> 1738;
1739 -> 1677;
1739 -> 1593;
1739 -> 1594;
1739 -> 1724;
1739 -> 1601;
1739 -> 1598;
1740 -> 1613;
1741 -> 1740;
1741 -> 1434;
1742 -> 1741;
1742 -> 1436;
1742 -> 1434;
1743 -> 1632;
1744 -> 1743;
1744 -> 1472;
1745 -> 1744;
1745 -> 1474;
1745 -> 1472;
1746 -> 1470;
1746 -> 1502;
1746 -> 1628;
1746 -> 1745;
1746 -> 1637;
1746 -> 1498;
1746 -> 1499;
1746 -> 1731;
1746 -> 1509;
1746 -> 1501;
1747 -> 1652;
1748 -> 1747;
1748 -> 1521;
1749 -> 1748;
1749 -> 1523;
1749 -> 1521;
1750 -> 1519;
1750 -> 1553;
1750 -> 1648;
1750 -> 1749;
1750 -> 1657;
1750 -> 1547;
1750 -> 1548;
1750 -> 1735;
1750 -> 1555;
1750 -> 1552;
1751 -> 1672;
1752 -> 1751;
1752 -> 1567;
1753 -> 1752;
1753 -> 1569;
1753 -> 1567;
1754 -> 1565;
1754 -> 1599;
1754 -> 1668;
1754 -> 1753;
1754 -> 1677;
1754 -> 1593;
1754 -> 1594;
1754 -> 1739;
1754 -> 1601;
1754 -> 1598;
1755 -> 1613;
1756 -> 1755;
1756 -> 1434;
1757 -> 1756;
1757 -> 1436;
1757 -> 1434;
1758 -> 1632;
1759 -> 1758;
1759 -> 1472;
1760 -> 1759;
1760 -> 1474;
1760 -> 1472;
1761 -> 1470;
1761 -> 1502;
1761 -> 1628;
1761 -> 1760;
1761 -> 1637;
1761 -> 1498;
1761 -> 1499;
1761 -> 1746;
1761 -> 1509;
1761 -> 1501;
1762 -> 1652;
1763 -> 1762;
1763 -> 1521;
1764 -> 1763;
1764 -> 1523;
1764 -> 1521;
1765 -> 1519;
1765 -> 1553;
1765 -> 1648;
1765 -> 1764;
1765 -> 1657;
1765 -> 1547;
1765 -> 1548;
1765 -> 1750;
1765 -> 1555;
1765 -> 1552;
1766 -> 1672;
1767 -> 1766;
1767 -> 1567;
1768 -> 1767;
1768 -> 1569;
1768 -> 1567;
1769 -> 1565;
1769 -> 1599;
1769 -> 1668;
1769 -> 1768;
1769 -> 1677;
1769 -> 1593;
1769 -> 1594;
1769 -> 1754;
1769 -> 1601;
1769 -> 1598;
1770 -> 1613;
1771 -> 1770;
1771 -> 1434;
1772 -> 1771;
1772 -> 1436;
1772 -> 1434;
1773 -> 1632;
1774 -> 1773;
1774 -> 1472;
1775 -> 1774;
1775 -> 1474;
1775 -> 1472;
1776 -> 1470;
1776 -> 1502;
1776 -> 1628;
1776 -> 1775;
1776 -> 1637;
1776 -> 1498;
1776 -> 1499;
1776 -> 1761;
1776 -> 1509;
1776 -> 1501;
1777 -> 1652;
1778 -> 1777;
1778 -> 1521;
1779 -> 1778;
1779 -> 1523;
1779 -> 1521;
1780 -> 1519;
1780 -> 1553;
1780 -> 1648;
1780 -> 1779;
1780 -> 1657;
1780 -> 1547;
1780 -> 1548;
1780 -> 1765;
1780 -> 1555;
1780 -> 1552;
1781 -> 1672;
1782 -> 1781;
1782 -> 1567;
1783 -> 1782;
1783 -> 1569;
1783 -> 1567;
1784 -> 1565;
1784 -> 1599;
1784 -> 1668;
1784 -> 1783;
1784 -> 1677;
1784 -> 1593;
1784 -> 1594;
1784 -> 1769;
1784 -> 1601;
1784 -> 1598;
1785 -> 1613;
1786 -> 1785;
1786 -> 1434;
1787 -> 1786;
1787 -> 1436;
1787 -> 1434;
1788 -> 1632;
1789 -> 1788;
1789 -> 1472;
1790 -> 1789;
1790 -> 1474;
1790 -> 1472;
1791 -> 1470;
1791 -> 1502;
1791 -> 1628;
1791 -> 1790;
1791 -> 1637;
1791 -> 1498;
1791 -> 1499;
1791 -> 1776;
1791 -> 1509;
1791 -> 1501;
1792 -> 1652;
1793 -> 1792;
1793 -> 1521;
1794 -> 1793;
1794 -> 1523;
1794 -> 1521;
1795 -> 1519;
1795 -> 1553;
1795 -> 1648;
1795 -> 1794;
1795 -> 1657;
1795 -> 1547;
1795 -> 1548;
1795 -> 1780;
1795 -> 1555;
1795 -> 1552;
1796 -> 1672;
1797 -> 1796;
1797 -> 1567;
1798 -> 1797;
1798 -> 1569;
1798 -> 1567;
1799 -> 1565;
1799 -> 1599;
1799 -> 1668;
1799 -> 1798;
1799 -> 1677;
1799 -> 1593;
1799 -> 1594;
1799 -> 1784;
1799 -> 1601;
1799 -> 1598;
1800 -> 1613;
1801 -> 1800;
1801 -> 1434;
1802 -> 1801;
1802 -> 1436;
1802 -> 1434;
1803 -> 1632;
1804 -> 1803;
1804 -> 1472;
1805 -> 1804;
1805 -> 1474;
1805 -> 1472;
1806 -> 1470;
1806 -> 1502;
1806 -> 1628;
1806 -> 1805;
1806 -> 1637;
1806 -> 1498;
1806 -> 1499;
1806 -> 1791;
1806 -> 1509;
1806 -> 1501;
1807 -> 1652;
1808 -> 1807;
1808 -> 1521;
1809 -> 1808;
1809 -> 1523;
1809 -> 1521;
1810 -> 1519;
1810 -> 1553;
1810 -> 1648;
1810 -> 1809;
1810 -> 1657;
1810 -> 1547;
1810 -> 1548;
1810 -> 1795;
1810 -> 1555;
1810 -> 1552;
1811 -> 1672;
1812 -> 1811;
1812 -> 1567;
1813 -> 1812;
1813 -> 1569;
1813 -> 1567;
1814 -> 1565;
1814 -> 1599;
1814 -> 1668;
1814 -> 1813;
1814 -> 1677;
1814 -> 1593;
1814 -> 1594;
1814 -> 1799;
1814 -> 1601;
1814 -> 1598;
1815 -> 1613;
1816 -> 1815;
1816 -> 1434;
1817 -> 1816;
1817 -> 1436;
1817 -> 1434;
1818 -> 1632;
1819 -> 1818;
1819 -> 1472;
1820 -> 1819;
1820 -> 1474;
1820 -> 1472;
1821 -> 1470;
1821 -> 1502;
1821 -> 1628;
1821 -> 1820;
1821 -> 1637;
1821 -> 1498;
1821 -> 1499;
1821 -> 1806;
1821 -> 1509;
1821 -> 1501;
1822 -> 1652;
1823 -> 1822;
1823 -> 1521;
1824 -> 1823;
1824 -> 1523;
1824 -> 1521;
1825 -> 1519;
1825 -> 1553;
1825 -> 1648;
1825 -> 1824;
1825 -> 1657;
1825 -> 1547;
1825 -> 1548;
1825 -> 1810;
1825 -> 1555;
1825 -> 1552;
1826 -> 1672;
1827 -> 1826;
1827 -> 1567;
1828 -> 1827;
1828 -> 1569;
1828 -> 1567;
1829 -> 1565;
1829 -> 1599;
1829 -> 1668;
1829 -> 1828;
1829 -> 1677;
1829 -> 1593;
1829 -> 1594;
1829 -> 1814;
1829 -> 1601;
1829 -> 1598;
1830 -> 1613;
1831 -> 1830;
1831 -> 1434;
1832 -> 1831;
1832 -> 1436;
1832 -> 1434;
1833 -> 1632;
1834 -> 1833;
1834 -> 1472;
1835 -> 1834;
1835 -> 1474;
1835 -> 1472;
1836 -> 1470;
1836 -> 1502;
1836 -> 1628;
1836 -> 1835;
1836 -> 1637;
1836 -> 1498;
1836 -> 1499;
1836 -> 1821;
1836 -> 1509;
1836 -> 1501;
1837 -> 1652;
1838 -> 1837;
1838 -> 1521;
1839 -> 1838;
1839 -> 1523;
1839 -> 1521;
1840 -> 1519;
1840 -> 1553;
1840 -> 1648;
1840 -> 1839;
1840 -> 1657;
1840 -> 1547;
1840 -> 1548;
1840 -> 1825;
1840 -> 1555;
1840 -> 1552;
1841 -> 1672;
1842 -> 1841;
1842 -> 1567;
1843 -> 1842;
1843 -> 1569;
1843 -> 1567;
1844 -> 1565;
1844 -> 1599;
1844 -> 1668;
1844 -> 1843;
1844 -> 1677;
1844 -> 1593;
1844 -> 1594;
1844 -> 1829;
1844 -> 1601;
1844 -> 1598;
1845 -> 1613;
1846 -> 1845;
1846 -> 1434;
1847 -> 1846;
1847 -> 1436;
1847 -> 1434;
1848 -> 1632;
1849 -> 1848;
1849 -> 1472;
1850 -> 1849;
1850 -> 1474;
1850 -> 1472;
1851 -> 1470;
1851 -> 1502;
1851 -> 1628;
1851 -> 1850;
1851 -> 1637;
1851 -> 1498;
1851 -> 1499;
1851 -> 1836;
1851 -> 1509;
1851 -> 1501;
1852 -> 1652;
1853 -> 1852;
1853 -> 1521;
1854 -> 1853;
1854 -> 1523;
1854 -> 1521;
1855 -> 1519;
1855 -> 1553;
1855 -> 1648;
1855 -> 1854;
1855 -> 1657;
1855 -> 1547;
1855 -> 1548;
1855 -> 1840;
1855 -> 1555;
1855 -> 1552;
1856 -> 1672;
1857 -> 1856;
1857 -> 1567;
1858 -> 1857;
1858 -> 1569;
1858 -> 1567;
1859 -> 1565;
1859 -> 1599;
1859 -> 1668;
1859 -> 1858;
1859 -> 1677;
1859 -> 1593;
1859 -> 1594;
1859 -> 1844;
1859 -> 1601;
1859 -> 1598;
1860 -> 1613;
1861 -> 1860;
1861 -> 1434;
1862 -> 1861;
1862 -> 1436;
1862 -> 1434;
1863 -> 1632;
1864 -> 1863;
1864 -> 1472;
1865 -> 1864;
1865 -> 1474;
1865 -> 1472;
1866 -> 1470;
1866 -> 1502;
1866 -> 1628;
1866 -> 1865;
1866 -> 1637;
1866 -> 1498;
1866 -> 1499;
1866 -> 1851;
1866 -> 1509;
1866 -> 1501;
1867 -> 1652;
1868 -> 1867;
1868 -> 1521;
1869 -> 1868;
1869 -> 1523;
1869 -> 1521;
1870 -> 1519;
1870 -> 1553;
1870 -> 1648;
1870 -> 1869;
1870 -> 1657;
1870 -> 1547;
1870 -> 1548;
1870 -> 1855;
1870 -> 1555;
1870 -> 1552;
1871 -> 1672;
1872 -> 1871;
1872 -> 1567;
1873 -> 1872;
1873 -> 1569;
1873 -> 1567;
1874 -> 1565;
1874 -> 1599;
1874 -> 1668;
1874 -> 1873;
1874 -> 1677;
1874 -> 1593;
1874 -> 1594;
1874 -> 1859;
1874 -> 1601;
1874 -> 1598;
1875 -> 1613;
1876 -> 1875;
1876 -> 1434;
1877 -> 1876;
1877 -> 1436;
1877 -> 1434;
1878 -> 1632;
1879 -> 1878;
1879 -> 1472;
1880 -> 1879;
1880 -> 1474;
1880 -> 1472;
1881 -> 1470;
1881 -> 1502;
1881 -> 1628;
1881 -> 1880;
1881 -> 1637;
1881 -> 1498;
1881 -> 1499;
1881 -> 1866;
1881 -> 1509;
1881 -> 1501;
1882 -> 1652;
1883 -> 1882;
1883 -> 1521;
1884 -> 1883;
1884 -> 1523;
1884 -> 1521;
1885 -> 1519;
1885 -> 1553;
1885 -> 1648;
1885 -> 1884;
1885 -> 1657;
1885 -> 1547;
1885 -> 1548;
1885 -> 1870;
1885 -> 1555;
1885 -> 1552;
1886 -> 1672;
1887 -> 1886;
1887 -> 1567;
1888 -> 1887;
1888 -> 1569;
1888 -> 1567;
1889 -> 1565;
1889 -> 1599;
1889 -> 1668;
1889 -> 1888;
1889 -> 1677;
1889 -> 1593;
1889 -> 1594;
1889 -> 1874;
1889 -> 1601;
1889 -> 1598;
1890 -> 1613;
1891 -> 1890;
1891 -> 1434;
1892 -> 1891;
1892 -> 1436;
1892 -> 1434;
1893 -> 1632;
1894 -> 1893;
1894 -> 1472;
1895 -> 1894;
1895 -> 1474;
1895 -> 1472;
1896 -> 1470;
1896 -> 1502;
1896 -> 1628;
1896 -> 1895;
1896 -> 1637;
1896 -> 1498;
1896 -> 1499;
1896 -> 1881;
1896 -> 1509;
1896 -> 1501;
1897 -> 1652;
1898 -> 1897;
1898 -> 1521;
1899 -> 1898;
1899 -> 1523;
1899 -> 1521;
1900 -> 1519;
1900 -> 1553;
1900 -> 1648;
1900 -> 1899;
1900 -> 1657;
1900 -> 1547;
1900 -> 1548;
1900 -> 1885;
1900 -> 1555;
1900 -> 1552;
1901 -> 1672;
1902 -> 1901;
1902 -> 1567;
1903 -> 1902;
1903 -> 1569;
1903 -> 1567;
1904 -> 1565;
1904 -> 1599;
1904 -> 1668;
1904 -> 1903;
1904 -> 1677;
1904 -> 1593;
1904 -> 1594;
1904 -> 1889;
1904 -> 1601;
1904 -> 1598;
1905 -> 1613;
1906 -> 1905;
1906 -> 1434;
1907 -> 1906;
1907 -> 1436;
1907 -> 1434;
1908 -> 1632;
1909 -> 1908;
1909 -> 1472;
1910 -> 1909;
1910 -> 1474;
1910 -> 1472;
1911 -> 1470;
1911 -> 1502;
1911 -> 1628;
1911 -> 1910;
1911 -> 1637;
1911 -> 1498;
1911 -> 1499;
1911 -> 1896;
1911 -> 1509;
1911 -> 1501;
1912 -> 1652;
1913 -> 1912;
1913 -> 1521;
1914 -> 1913;
1914 -> 1523;
1914 -> 1521;
1915 -> 1519;
1915 -> 1553;
1915 -> 1648;
1915 -> 1914;
1915 -> 1657;
1915 -> 1547;
1915 -> 1548;
1915 -> 1900;
1915 -> 1555;
1915 -> 1552;
1916 -> 1672;
1917 -> 1916;
1917 -> 1567;
1918 -> 1917;
1918 -> 1569;
1918 -> 1567;
1919 -> 1565;
1919 -> 1599;
1919 -> 1668;
1919 -> 1918;
1919 -> 1677;
1919 -> 1593;
1919 -> 1594;
1919 -> 1904;
1919 -> 1601;
1919 -> 1598;
1920 -> 1613;
1921 -> 1920;
1921 -> 1434;
1922 -> 1921;
1922 -> 1436;
1922 -> 1434;
1923 -> 1632;
1924 -> 1923;
1924 -> 1472;
1925 -> 1924;
1925 -> 1474;
1925 -> 1472;
1926 -> 1470;
1926 -> 1502;
1926 -> 1628;
1926 -> 1925;
1926 -> 1637;
1926 -> 1498;
1926 -> 1499;
1926 -> 1911;
1926 -> 1509;
1926 -> 1501;
1927 -> 1652;
1928 -> 1927;
1928 -> 1521;
1929 -> 1928;
1929 -> 1523;
1929 -> 1521;
1930 -> 1519;
1930 -> 1553;
1930 -> 1648;
1930 -> 1929;
1930 -> 1657;
1930 -> 1547;
1930 -> 1548;
1930 -> 1915;
1930 -> 1555;
1930 -> 1552;
1931 -> 1672;
1932 -> 1931;
1932 -> 1567;
1933 -> 1932;
1933 -> 1569;
1933 -> 1567;
1934 -> 1565;
1934 -> 1599;
1934 -> 1668;
1934 -> 1933;
1934 -> 1677;
1934 -> 1593;
1934 -> 1594;
1934 -> 1919;
1934 -> 1601;
1934 -> 1598;
1935 -> 1613;
1936 -> 1935;
1936 -> 1434;
1937 -> 1936;
1937 -> 1436;
1937 -> 1434;
1938 -> 1632;
1939 -> 1938;
1939 -> 1472;
1940 -> 1939;
1940 -> 1474;
1940 -> 1472;
1941 -> 1470;
1941 -> 1502;
1941 -> 1628;
1941 -> 1940;
1941 -> 1637;
1941 -> 1498;
1941 -> 1499;
1941 -> 1926;
1941 -> 1509;
1941 -> 1501;
1942 -> 1652;
1943 -> 1942;
1943 -> 1521;
1944 -> 1943;
1944 -> 1523;
1944 -> 1521;
1945 -> 1519;
1945 -> 1553;
1945 -> 1648;
1945 -> 1944;
1945 -> 1657;
1945 -> 1547;
1945 -> 1548;
1945 -> 1930;
1945 -> 1555;
1945 -> 1552;
1946 -> 1672;
1947 -> 1946;
1947 -> 1567;
1948 -> 1947;
1948 -> 1569;
1948 -> 1567;
1949 -> 1565;
1949 -> 1599;
1949 -> 1668;
1949 -> 1948;
1949 -> 1677;
1949 -> 1593;
1949 -> 1594;
1949 -> 1934;
1949 -> 1601;
1949 -> 1598;
1950 -> 1613;
1951 -> 1950;
1951 -> 1434;
1952 -> 1951;
1952 -> 1436;
1952 -> 1434;
1953 -> 1632;
1954 -> 1953;
1954 -> 1472;
1955 -> 1954;
1955 -> 1474;
1955 -> 1472;
1956 -> 1470;
1956 -> 1502;
1956 -> 1628;
1956 -> 1955;
1956 -> 1637;
1956 -> 1498;
1956 -> 1499;
1956 -> 1941;
1956 -> 1509;
1956 -> 1501;
1957 -> 1652;
1958 -> 1957;
1958 -> 1521;
1959 -> 1958;
1959 -> 1523;
1959 -> 1521;
1960 -> 1519;
1960 -> 1553;
1960 -> 1648;
1960 -> 1959;
1960 -> 1657;
1960 -> 1547;
1960 -> 1548;
1960 -> 1945;
1960 -> 1555;
1960 -> 1552;
1961 -> 1672;
1962 -> 1961;
1962 -> 1567;
1963 -> 1962;
1963 -> 1569;
1963 -> 1567;
1964 -> 1565;
1964 -> 1599;
1964 -> 1668;
1964 -> 1963;
1964 -> 1677;
1964 -> 1593;
1964 -> 1594;
1964 -> 1949;
1964 -> 1601;
1964 -> 1598;
1965 -> 1613;
1966 -> 1965;
1966 -> 1434;
1967 -> 1966;
1967 -> 1436;
1967 -> 1434;
1968 -> 1632;
1969 -> 1968;
1969 -> 1472;
1970 -> 1969;
1970 -> 1474;
1970 -> 1472;
1971 -> 1470;
1971 -> 1502;
1971 -> 1628;
1971 -> 1970;
1971 -> 1637;
1971 -> 1498;
1971 -> 1499;
1971 -> 1956;
1971 -> 1509;
1971 -> 1501;
1972 -> 1652;
1973 -> 1972;
1973 -> 1521;
1974 -> 1973;
1974 -> 1523;
1974 -> 1521;
1975 -> 1519;
1975 -> 1553;
1975 -> 1648;
1975 -> 1974;
1975 -> 1657;
1975 -> 1547;
1975 -> 1548;
1975 -> 1960;
1975 -> 1555;
1975 -> 1552;
1976 -> 1672;
1977 -> 1976;
1977 -> 1567;
1978 -> 1977;
1978 -> 1569;
1978 -> 1567;
1979 -> 1565;
1979 -> 1599;
1979 -> 1668;
1979 -> 1978;
1979 -> 1677;
1979 -> 1593;
1979 -> 1594;
1979 -> 1964;
1979 -> 1601;
1979 -> 1598;
1980 -> 1613;
1981 -> 1980;
1981 -> 1434;
1982 -> 1981;
1982 -> 1436;
1982 -> 1434;
1983 -> 1632;
1984 -> 1983;
1984 -> 1472;
1985 -> 1984;
1985 -> 1474;
1985 -> 1472;
1986 -> 1470;
1986 -> 1502;
1986 -> 1628;
1986 -> 1985;
1986 -> 1637;
1986 -> 1498;
1986 -> 1499;
1986 -> 1971;
1986 -> 1509;
1986 -> 1501;
1987 -> 1652;
1988 -> 1987;
1988 -> 1521;
1989 -> 1988;
1989 -> 1523;
1989 -> 1521;
1990 -> 1519;
1990 -> 1553;
1990 -> 1648;
1990 -> 1989;
1990 -> 1657;
1990 -> 1547;
1990 -> 1548;
1990 -> 1975;
1990 -> 1555;
1990 -> 1552;
1991 -> 1672;
1992 -> 1991;
1992 -> 1567;
1993 -> 1992;
1993 -> 1569;
1993 -> 1567;
1994 -> 1565;
1994 -> 1599;
1994 -> 1668;
1994 -> 1993;
1994 -> 1677;
1994 -> 1593;
1994 -> 1594;
1994 -> 1979;
1994 -> 1601;
1994 -> 1598;
1995 -> 1613;
1996 -> 1995;
1996 -> 1434;
1997 -> 1996;
1997 -> 1436;
1997 -> 1434;
1998 -> 1632;
1999 -> 1998;
1999 -> 1472;
2000 -> 1999;
2000 -> 1474;
2000 -> 1472;
2001 -> 1470;
2001 -> 1502;
2001 -> 1628;
2001 -> 2000;
2001 -> 1637;
2001 -> 1498;
2001 -> 1499;
2001 -> 1986;
2001 -> 1509;
2001 -> 1501;
2002 -> 1652;
2003 -> 2002;
2003 -> 1521;
2004 -> 2003;
2004 -> 1523;
2004 -> 1521;
2005 -> 1519;
2005 -> 1553;
2005 -> 1648;
2005 -> 2004;
2005 -> 1657;
2005 -> 1547;
2005 -> 1548;
2005 -> 1990;
2005 -> 1555;
2005 -> 1552;
2006 -> 1672;
2007 -> 2006;
2007 -> 1567;
2008 -> 2007;
2008 -> 1569;
2008 -> 1567;
2009 -> 1565;
2009 -> 1599;
2009 -> 1668;
2009 -> 2008;
2009 -> 1677;
2009 -> 1593;
2009 -> 1594;
2009 -> 1994;
2009 -> 1601;
2009 -> 1598;
2010 -> 1613;
2011 -> 2010;
2011 -> 1434;
2012 -> 2011;
2012 -> 1436;
2012 -> 1434;
2013 -> 1632;
2014 -> 2013;
2014 -> 1472;
2015 -> 2014;
2015 -> 1474;
2015 -> 1472;
2016 -> 1470;
2016 -> 1502;
2016 -> 1628;
2016 -> 2015;
2016 -> 1637;
2016 -> 1498;
2016 -> 1499;
2016 -> 2001;
2016 -> 1509;
2016 -> 1501;
2017 -> 1652;
2018 -> 2017;
2018 -> 1521;
2019 -> 2018;
2019 -> 1523;
2019 -> 1521;
2020 -> 1519;
2020 -> 1553;
2020 -> 1648;
2020 -> 2019;
2020 -> 1657;
2020 -> 1547;
2020 -> 1548;
2020 -> 2005;
2020 -> 1555;
2020 -> 1552;
2021 -> 1672;
2022 -> 2021;
2022 -> 1567;
2023 -> 2022;
2023 -> 1569;
2023 -> 1567;
2024 -> 1565;
2024 -> 1599;
2024 -> 1668;
2024 -> 2023;
2024 -> 1677;
2024 -> 1593;
2024 -> 1594;
2024 -> 2009;
2024 -> 1601;
2024 -> 1598;
2025 -> 1613;
2026 -> 2025;
2026 -> 1434;
2027 -> 2026;
2027 -> 1436;
2027 -> 1434;
2028 -> 1632;
2029 -> 2028;
2029 -> 1472;
2030 -> 2029;
2030 -> 1474;
2030 -> 1472;
2031 -> 1470;
2031 -> 1502;
2031 -> 1628;
2031 -> 2030;
2031 -> 1637;
2031 -> 1498;
2031 -> 1499;
2031 -> 2016;
2031 -> 1509;
2031 -> 1501;
2032 -> 1652;
2033 -> 2032;
2033 -> 1521;
2034 -> 2033;
2034 -> 1523;
2034 -> 1521;
2035 -> 1519;
2035 -> 1553;
2035 -> 1648;
2035 -> 2034;
2035 -> 1657;
2035 -> 1547;
2035 -> 1548;
2035 -> 2020;
2035 -> 1555;
2035 -> 1552;
2036 -> 1672;
2037 -> 2036;
2037 -> 1567;
2038 -> 2037;
2038 -> 1569;
2038 -> 1567;
2039 -> 1565;
2039 -> 1599;
2039 -> 1668;
2039 -> 2038;
2039 -> 1677;
2039 -> 1593;
2039 -> 1594;
2039 -> 2024;
2039 -> 1601;
2039 -> 1598;
2040 -> 1613;
2041 -> 2040;
2041 -> 1434;
2042 -> 2041;
2042 -> 1436;
2042 -> 1434;
2043 -> 1632;
2044 -> 2043;
2044 -> 1472;
2045 -> 2044;
2045 -> 1474;
2045 -> 1472;
2046 -> 1470;
2046 -> 1502;
2046 -> 1628;
2046 -> 2045;
2046 -> 1637;
2046 -> 1498;
2046 -> 1499;
2046 -> 2031;
2046 -> 1509;
2046 -> 1501;
2047 -> 1652;
2048 -> 2047;
2048 -> 1521;
2049 -> 2048;
2049 -> 1523;
2049 -> 1521;
2050 -> 1519;
2050 -> 1553;
2050 -> 1648;
2050 -> 2049;
2050 -> 1657;
2050 -> 1547;
2050 -> 1548;
2050 -> 2035;
2050 -> 1555;
2050 -> 1552;
2051 -> 1672;
2052 -> 2051;
2052 -> 1567;
2053 -> 2052;
2053 -> 1569;
2053 -> 1567;
2054 -> 1565;
2054 -> 1599;
2054 -> 1668;
2054 -> 2053;
2054 -> 1677;
2054 -> 1593;
2054 -> 1594;
2054 -> 2039;
2054 -> 1601;
2054 -> 1598;
2055 -> 1613;
2056 -> 2055;
2056 -> 1434;
2057 -> 2056;
2057 -> 1436;
2057 -> 1434;
2058 -> 1632;
2059 -> 2058;
2059 -> 1472;
2060 -> 2059;
2060 -> 1474;
2060 -> 1472;
2061 -> 1470;
2061 -> 1502;
2061 -> 1628;
2061 -> 2060;
2061 -> 1637;
2061 -> 1498;
2061 -> 1499;
2061 -> 2046;
2061 -> 1509;
2061 -> 1501;
2062 -> 1652;
2063 -> 2062;
2063 -> 1521;
2064 -> 2063;
2064 -> 1523;
2064 -> 1521;
2065 -> 1519;
2065 -> 1553;
2065 -> 1648;
2065 -> 2064;
2065 -> 1657;
2065 -> 1547;
2065 -> 1548;
2065 -> 2050;
2065 -> 1555;
2065 -> 1552;
2066 -> 1672;
2067 -> 2066;
2067 -> 1567;
2068 -> 2067;
2068 -> 1569;
2068 -> 1567;
2069 -> 1565;
2069 -> 1599;
2069 -> 1668;
2069 -> 2068;
2069 -> 1677;
2069 -> 1593;
2069 -> 1594;
2069 -> 2054;
2069 -> 1601;
2069 -> 1598;
2070 -> 1613;
2071 -> 2070;
2071 -> 1434;
2072 -> 2071;
2072 -> 1436;
2072 -> 1434;
2073 -> 1632;
2074 -> 2073;
2074 -> 1472;
2075 -> 2074;
2075 -> 1474;
2075 -> 1472;
2076 -> 1470;
2076 -> 1502;
2076 -> 1628;
2076 -> 2075;
2076 -> 1637;
2076 -> 1498;
2076 -> 1499;
2076 -> 2061;
2076 -> 1509;
2076 -> 1501;
2077 -> 1652;
2078 -> 2077;
2078 -> 1521;
2079 -> 2078;
2079 -> 1523;
2079 -> 1521;
2080 -> 1519;
2080 -> 1553;
2080 -> 1648;
2080 -> 2079;
2080 -> 1657;
2080 -> 1547;
2080 -> 1548;
2080 -> 2065;
2080 -> 1555;
2080 -> 1552;
2081 -> 1672;
2082 -> 2081;
2082 -> 1567;
2083 -> 2082;
2083 -> 1569;
2083 -> 1567;
2084 -> 1565;
2084 -> 1599;
2084 -> 1668;
2084 -> 2083;
2084 -> 1677;
2084 -> 1593;
2084 -> 1594;
2084 -> 2069;
2084 -> 1601;
2084 -> 1598;
2085 -> 1613;
2086 -> 2085;
2086 -> 1434;
2087 -> 2086;
2087 -> 1436;
2087 -> 1434;
2088 -> 1632;
2089 -> 2088;
2089 -> 1472;
2090 -> 2089;
2090 -> 1474;
2090 -> 1472;
2091 -> 1470;
2091 -> 1502;
2091 -> 1628;
2091 -> 2090;
2091 -> 1637;
2091 -> 1498;
2091 -> 1499;
2091 -> 2076;
2091 -> 1509;
2091 -> 1501;
2092 -> 1652;
2093 -> 2092;
2093 -> 1521;
2094 -> 2093;
2094 -> 1523;
2094 -> 1521;
2095 -> 1519;
2095 -> 1553;
2095 -> 1648;
2095 -> 2094;
2095 -> 1657;
2095 -> 1547;
2095 -> 1548;
2095 -> 2080;
2095 -> 1555;
2095 -> 1552;
2096 -> 1672;
2097 -> 2096;
2097 -> 1567;
2098 -> 2097;
2098 -> 1569;
2098 -> 1567;
2099 -> 1565;
2099 -> 1599;
2099 -> 1668;
2099 -> 2098;
2099 -> 1677;
2099 -> 1593;
2099 -> 1594;
2099 -> 2084;
2099 -> 1601;
2099 -> 1598;
2100 -> 0;
2100 -> 1613;
2101 -> 2100;
2101 -> 1434;
2102 -> 2101;
2102 -> 1436;
2102 -> 1434;
2103 -> 0;
2103 -> 1632;
2104 -> 2103;
2104 -> 1472;
2105 -> 2104;
2105 -> 1474;
2105 -> 1472;
2106 -> 1470;
2106 -> 1502;
2106 -> 1628;
2106 -> 2105;
2106 -> 1637;
2106 -> 1498;
2106 -> 1499;
2106 -> 2091;
2106 -> 1509;
2106 -> 1501;
2107 -> 0;
2107 -> 1652;
2108 -> 2107;
2108 -> 1521;
2109 -> 2108;
2109 -> 1523;
2109 -> 1521;
2110 -> 1519;
2110 -> 1553;
2110 -> 1648;
2110 -> 2109;
2110 -> 1657;
2110 -> 1547;
2110 -> 1548;
2110 -> 2095;
2110 -> 1555;
2110 -> 1552;
2111 -> 0;
2111 -> 1672;
2112 -> 2111;
2112 -> 1567;
2113 -> 2112;
2113 -> 1569;
2113 -> 1567;
2114 -> 1565;
2114 -> 1599;
2114 -> 1668;
2114 -> 2113;
2114 -> 1677;
2114 -> 1593;
2114 -> 1594;
2114 -> 2099;
2114 -> 1601;
2114 -> 1598;
2115 -> 1613;
2116 -> 2115;
2116 -> 1434;
2117 -> 2116;
2117 -> 1436;
2117 -> 1434;
2118 -> 1632;
2119 -> 2118;
2119 -> 1472;
2120 -> 2119;
2120 -> 1474;
2120 -> 1472;
2121 -> 1470;
2121 -> 1502;
2121 -> 1628;
2121 -> 2120;
2121 -> 1637;
2121 -> 1498;
2121 -> 1499;
2121 -> 2106;
2121 -> 1509;
2121 -> 1501;
2122 -> 1652;
2123 -> 2122;
2123 -> 1521;
2124 -> 2123;
2124 -> 1523;
2124 -> 1521;
2125 -> 1519;
2125 -> 1553;
2125 -> 1648;
2125 -> 2124;
2125 -> 1657;
2125 -> 1547;
2125 -> 1548;
2125 -> 2110;
2125 -> 1555;
2125 -> 1552;
2126 -> 1672;
2127 -> 2126;
2127 -> 1567;
2128 -> 2127;
2128 -> 1569;
2128 -> 1567;
2129 -> 1565;
2129 -> 1599;
2129 -> 1668;
2129 -> 2128;
2129 -> 1677;
2129 -> 1593;
2129 -> 1594;
2129 -> 2114;
2129 -> 1601;
2129 -> 1598;
2130 -> 1613;
2131 -> 2130;
2131 -> 1434;
2132 -> 2131;
2132 -> 1436;
2132 -> 1434;
2133 -> 1632;
2134 -> 2133;
2134 -> 1472;
2135 -> 2134;
2135 -> 1474;
2135 -> 1472;
2136 -> 1470;
2136 -> 1502;
2136 -> 1628;
2136 -> 2135;
2136 -> 1637;
2136 -> 1498;
2136 -> 1499;
2136 -> 2121;
2136 -> 1509;
2136 -> 1501;
2137 -> 1652;
2138 -> 2137;
2138 -> 1521;
2139 -> 2138;
2139 -> 1523;
2139 -> 1521;
2140 -> 1519;
2140 -> 1553;
2140 -> 1648;
2140 -> 2139;
2140 -> 1657;
2140 -> 1547;
2140 -> 1548;
2140 -> 2125;
2140 -> 1555;
2140 -> 1552;
2141 -> 1672;
2142 -> 2141;
2142 -> 1567;
2143 -> 2142;
2143 -> 1569;
2143 -> 1567;
2144 -> 1565;
2144 -> 1599;
2144 -> 1668;
2144 -> 2143;
2144 -> 1677;
2144 -> 1593;
2144 -> 1594;
2144 -> 2129;
2144 -> 1601;
2144 -> 1598;
2145 -> 1613;
2146 -> 2145;
2146 -> 1434;
2147 -> 2146;
2147 -> 1436;
2147 -> 1434;
2148 -> 1632;
2149 -> 2148;
2149 -> 1472;
2150 -> 2149;
2150 -> 1474;
2150 -> 1472;
2151 -> 1470;
2151 -> 1502;
2151 -> 1628;
2151 -> 2150;
2151 -> 1637;
2151 -> 1498;
2151 -> 1499;
2151 -> 2136;
2151 -> 1509;
2151 -> 1501;
2152 -> 1652;
2153 -> 2152;
2153 -> 1521;
2154 -> 2153;
2154 -> 1523;
2154 -> 1521;
2155 -> 1519;
2155 -> 1553;
2155 -> 1648;
2155 -> 2154;
2155 -> 1657;
2155 -> 1547;
2155 -> 1548;
2155 -> 2140;
2155 -> 1555;
2155 -> 1552;
2156 -> 1672;
2157 -> 2156;
2157 -> 1567;
2158 -> 2157;
2158 -> 1569;
2158 -> 1567;
2159 -> 1565;
2159 -> 1599;
2159 -> 1668;
2159 -> 2158;
2159 -> 1677;
2159 -> 1593;
2159 -> 1594;
2159 -> 2144;
2159 -> 1601;
2159 -> 1598;
2160 -> 1613;
2161 -> 2160;
2161 -> 1434;
2162 -> 2161;
2162 -> 1436;
2162 -> 1434;
2163 -> 1632;
2164 -> 2163;
2164 -> 1472;
2165 -> 2164;
2165 -> 1474;
2165 -> 1472;
2166 -> 1470;
2166 -> 1502;
2166 -> 1628;
2166 -> 2165;
2166 -> 1637;
2166 -> 1498;
2166 -> 1499;
2166 -> 2151;
2166 -> 1509;
2166 -> 1501;
2167 -> 1652;
2168 -> 2167;
2168 -> 1521;
2169 -> 2168;
2169 -> 1523;
2169 -> 1521;
2170 -> 1519;
2170 -> 1553;
2170 -> 1648;
2170 -> 2169;
2170 -> 1657;
2170 -> 1547;
2170 -> 1548;
2170 -> 2155;
2170 -> 1555;
2170 -> 1552;
2171 -> 1672;
2172 -> 2171;
2172 -> 1567;
2173 -> 2172;
2173 -> 1569;
2173 -> 1567;
2174 -> 1565;
2174 -> 1599;
2174 -> 1668;
2174 -> 2173;
2174 -> 1677;
2174 -> 1593;
2174 -> 1594;
2174 -> 2159;
2174 -> 1601;
2174 -> 1598;
2175 -> 1613;
2176 -> 2175;
2176 -> 1434;
2177 -> 2176;
2177 -> 1436;
2177 -> 1434;
2178 -> 1632;
2179 -> 2178;
2179 -> 1472;
2180 -> 2179;
2180 -> 1474;
2180 -> 1472;
2181 -> 1470;
2181 -> 1502;
2181 -> 1628;
2181 -> 2180;
2181 -> 1637;
2181 -> 1498;
2181 -> 1499;
2181 -> 2166;
2181 -> 1509;
2181 -> 1501;
2182 -> 1652;
2183 -> 2182;
2183 -> 1521;
2184 -> 2183;
2184 -> 1523;
2184 -> 1521;
2185 -> 1519;
2185 -> 1553;
2185 -> 1648;
2185 -> 2184;
2185 -> 1657;
2185 -> 1547;
2185 -> 1548;
2185 -> 2170;
2185 -> 1555;
2185 -> 1552;
2186 -> 1672;
2187 -> 2186;
2187 -> 1567;
2188 -> 2187;
2188 -> 1569;
2188 -> 1567;
2189 -> 1565;
2189 -> 1599;
2189 -> 1668;
2189 -> 2188;
2189 -> 1677;
2189 -> 1593;
2189 -> 1594;
2189 -> 2174;
2189 -> 1601;
2189 -> 1598;
2190 -> 1613;
2191 -> 2190;
2191 -> 1434;
2192 -> 2191;
2192 -> 1436;
2192 -> 1434;
2193 -> 1632;
2194 -> 2193;
2194 -> 1472;
2195 -> 2194;
2195 -> 1474;
2195 -> 1472;
2196 -> 1470;
2196 -> 1502;
2196 -> 1628;
2196 -> 2195;
2196 -> 1637;
2196 -> 1498;
2196 -> 1499;
2196 -> 2181;
2196 -> 1509;
2196 -> 1501;
2197 -> 1652;
2198 -> 2197;
2198 -> 1521;
2199 -> 2198;
2199 -> 1523;
2199 -> 1521;
2200 -> 1519;
2200 -> 1553;
2200 -> 1648;
2200 -> 2199;
2200 -> 1657;
2200 -> 1547;
2200 -> 1548;
2200 -> 2185;
2200 -> 1555;
2200 -> 1552;
2201 -> 1672;
2202 -> 2201;
2202 -> 1567;
2203 -> 2202;
2203 -> 1569;
2203 -> 1567;
2204 -> 1565;
2204 -> 1599;
2204 -> 1668;
2204 -> 2203;
2204 -> 1677;
2204 -> 1593;
2204 -> 1594;
2204 -> 2189;
2204 -> 1601;
2204 -> 1598;
2205 -> 1613;
2206 -> 2205;
2206 -> 1434;
2207 -> 2206;
2207 -> 1436;
2207 -> 1434;
2208 -> 1632;
2209 -> 2208;
2209 -> 1472;
2210 -> 2209;
2210 -> 1474;
2210 -> 1472;
2211 -> 1470;
2211 -> 1502;
2211 -> 1628;
2211 -> 2210;
2211 -> 1637;
2211 -> 1498;
2211 -> 1499;
2211 -> 2196;
2211 -> 1509;
2211 -> 1501;
2212 -> 1652;
2213 -> 2212;
2213 -> 1521;
2214 -> 2213;
2214 -> 1523;
2214 -> 1521;
2215 -> 1519;
2215 -> 1553;
2215 -> 1648;
2215 -> 2214;
2215 -> 1657;
2215 -> 1547;
2215 -> 1548;
2215 -> 2200;
2215 -> 1555;
2215 -> 1552;
2216 -> 1672;
2217 -> 2216;
2217 -> 1567;
2218 -> 2217;
2218 -> 1569;
2218 -> 1567;
2219 -> 1565;
2219 -> 1599;
2219 -> 1668;
2219 -> 2218;
2219 -> 1677;
2219 -> 1593;
2219 -> 1594;
2219 -> 2204;
2219 -> 1601;
2219 -> 1598;
2220 -> 1613;
2221 -> 2220;
2221 -> 1434;
2222 -> 2221;
2222 -> 1436;
2222 -> 1434;
2223 -> 1632;
2224 -> 2223;
2224 -> 1472;
2225 -> 2224;
2225 -> 1474;
2225 -> 1472;
2226 -> 1470;
2226 -> 1502;
2226 -> 1628;
2226 -> 2225;
2226 -> 1637;
2226 -> 1498;
2226 -> 1499;
2226 -> 2211;
2226 -> 1509;
2226 -> 1501;
2227 -> 1652;
2228 -> 2227;
2228 -> 1521;
2229 -> 2228;
2229 -> 1523;
2229 -> 1521;
2230 -> 1519;
2230 -> 1553;
2230 -> 1648;
2230 -> 2229;
2230 -> 1657;
2230 -> 1547;
2230 -> 1548;
2230 -> 2215;
2230 -> 1555;
2230 -> 1552;
2231 -> 1672;
2232 -> 2231;
2232 -> 1567;
2233 -> 2232;
2233 -> 1569;
2233 -> 1567;
2234 -> 1565;
2234 -> 1599;
2234 -> 1668;
2234 -> 2233;
2234 -> 1677;
2234 -> 1593;
2234 -> 1594;
2234 -> 2219;
2234 -> 1601;
2234 -> 1598;
2235 -> 1613;
2236 -> 2235;
2236 -> 1434;
2237 -> 2236;
2237 -> 1436;
2237 -> 1434;
2238 -> 1632;
2239 -> 2238;
2239 -> 1472;
2240 -> 2239;
2240 -> 1474;
2240 -> 1472;
2241 -> 1470;
2241 -> 1502;
2241 -> 1628;
2241 -> 2240;
2241 -> 1637;
2241 -> 1498;
2241 -> 1499;
2241 -> 2226;
2241 -> 1509;
2241 -> 1501;
2242 -> 1652;
2243 -> 2242;
2243 -> 1521;
2244 -> 2243;
2244 -> 1523;
2244 -> 1521;
2245 -> 1519;
2245 -> 1553;
2245 -> 1648;
2245 -> 2244;
2245 -> 1657;
2245 -> 1547;
2245 -> 1548;
2245 -> 2230;
2245 -> 1555;
2245 -> 1552;
2246 -> 1672;
2247 -> 2246;
2247 -> 1567;
2248 -> 2247;
2248 -> 1569;
2248 -> 1567;
2249 -> 1565;
2249 -> 1599;
2249 -> 1668;
2249 -> 2248;
2249 -> 1677;
2249 -> 1593;
2249 -> 1594;
2249 -> 2234;
2249 -> 1601;
2249 -> 1598;
2250 -> 1613;
2251 -> 2250;
2251 -> 1434;
2252 -> 2251;
2252 -> 1436;
2252 -> 1434;
2253 -> 1632;
2254 -> 2253;
2254 -> 1472;
2255 -> 2254;
2255 -> 1474;
2255 -> 1472;
2256 -> 1470;
2256 -> 1502;
2256 -> 1628;
2256 -> 2255;
2256 -> 1637;
2256 -> 1498;
2256 -> 1499;
2256 -> 2241;
2256 -> 1509;
2256 -> 1501;
2257 -> 1652;
2258 -> 2257;
2258 -> 1521;
2259 -> 2258;
2259 -> 1523;
2259 -> 1521;
2260 -> 1519;
2260 -> 1553;
2260 -> 1648;
2260 -> 2259;
2260 -> 1657;
2260 -> 1547;
2260 -> 1548;
2260 -> 2245;
2260 -> 1555;
2260 -> 1552;
2261 -> 1672;
2262 -> 2261;
2262 -> 1567;
2263 -> 2262;
2263 -> 1569;
2263 -> 1567;
2264 -> 1565;
2264 -> 1599;
2264 -> 1668;
2264 -> 2263;
2264 -> 1677;
2264 -> 1593;
2264 -> 1594;
2264 -> 2249;
2264 -> 1601;
2264 -> 1598;
2265 -> 1613;
2266 -> 2265;
2266 -> 1434;
2267 -> 2266;
2267 -> 1436;
2267 -> 1434;
2268 -> 1632;
2269 -> 2268;
2269 -> 1472;
2270 -> 2269;
2270 -> 1474;
2270 -> 1472;
2271 -> 1470;
2271 -> 1502;
2271 -> 1628;
2271 -> 2270;
2271 -> 1637;
2271 -> 1498;
2271 -> 1499;
2271 -> 2256;
2271 -> 1509;
2271 -> 1501;
2272 -> 1652;
2273 -> 2272;
2273 -> 1521;
2274 -> 2273;
2274 -> 1523;
2274 -> 1521;
2275 -> 1519;
2275 -> 1553;
2275 -> 1648;
2275 -> 2274;
2275 -> 1657;
2275 -> 1547;
2275 -> 1548;
2275 -> 2260;
2275 -> 1555;
2275 -> 1552;
2276 -> 1672;
2277 -> 2276;
2277 -> 1567;
2278 -> 2277;
2278 -> 1569;
2278 -> 1567;
2279 -> 1565;
2279 -> 1599;
2279 -> 1668;
2279 -> 2278;
2279 -> 1677;
2279 -> 1593;
2279 -> 1594;
2279 -> 2264;
2279 -> 1601;
2279 -> 1598;
2280 -> 1613;
2281 -> 2280;
2281 -> 1434;
2282 -> 2281;
2282 -> 1436;
2282 -> 1434;
2283 -> 1632;
2284 -> 2283;
2284 -> 1472;
2285 -> 2284;
2285 -> 1474;
2285 -> 1472;
2286 -> 1470;
2286 -> 1502;
2286 -> 1628;
2286 -> 2285;
2286 -> 1637;
2286 -> 1498;
2286 -> 1499;
2286 -> 2271;
2286 -> 1509;
2286 -> 1501;
2287 -> 1652;
2288 -> 2287;
2288 -> 1521;
2289 -> 2288;
2289 -> 1523;
2289 -> 1521;
2290 -> 1519;
2290 -> 1553;
2290 -> 1648;
2290 -> 2289;
2290 -> 1657;
2290 -> 1547;
2290 -> 1548;
2290 -> 2275;
2290 -> 1555;
2290 -> 1552;
2291 -> 1672;
2292 -> 2291;
2292 -> 1567;
2293 -> 2292;
2293 -> 1569;
2293 -> 1567;
2294 -> 1565;
2294 -> 1599;
2294 -> 1668;
2294 -> 2293;
2294 -> 1677;
2294 -> 1593;
2294 -> 1594;
2294 -> 2279;
2294 -> 1601;
2294 -> 1598;
2295 -> 1613;
2296 -> 2295;
2296 -> 1434;
2297 -> 2296;
2297 -> 1436;
2297 -> 1434;
2298 -> 1632;
2299 -> 2298;
2299 -> 1472;
2300 -> 2299;
2300 -> 1474;
2300 -> 1472;
2301 -> 1470;
2301 -> 1502;
2301 -> 1628;
2301 -> 2300;
2301 -> 1637;
2301 -> 1498;
2301 -> 1499;
2301 -> 2286;
2301 -> 1509;
2301 -> 1501;
2302 -> 1652;
2303 -> 2302;
2303 -> 1521;
2304 -> 2303;
2304 -> 1523;
2304 -> 1521;
2305 -> 1519;
2305 -> 1553;
2305 -> 1648;
2305 -> 2304;
2305 -> 1657;
2305 -> 1547;
2305 -> 1548;
2305 -> 2290;
2305 -> 1555;
2305 -> 1552;
2306 -> 1672;
2307 -> 2306;
2307 -> 1567;
2308 -> 2307;
2308 -> 1569;
2308 -> 1567;
2309 -> 1565;
2309 -> 1599;
2309 -> 1668;
2309 -> 2308;
2309 -> 1677;
2309 -> 1593;
2309 -> 1594;
2309 -> 2294;
2309 -> 1601;
2309 -> 1598;
2310 -> 1613;
2311 -> 2310;
2311 -> 1434;
2312 -> 2311;
2312 -> 1436;
2312 -> 1434;
2313 -> 1632;
2314 -> 2313;
2314 -> 1472;
2315 -> 2314;
2315 -> 1474;
2315 -> 1472;
2316 -> 1470;
2316 -> 1502;
2316 -> 1628;
2316 -> 2315;
2316 -> 1637;
2316 -> 1498;
2316 -> 1499;
2316 -> 2301;
2316 -> 1509;
2316 -> 1501;
2317 -> 1652;
2318 -> 2317;
2318 -> 1521;
2319 -> 2318;
2319 -> 1523;
2319 -> 1521;
2320 -> 1519;
2320 -> 1553;
2320 -> 1648;
2320 -> 2319;
2320 -> 1657;
2320 -> 1547;
2320 -> 1548;
2320 -> 2305;
2320 -> 1555;
2320 -> 1552;
2321 -> 1672;
2322 -> 2321;
2322 -> 1567;
2323 -> 2322;
2323 -> 1569;
2323 -> 1567;
2324 -> 1565;
2324 -> 1599;
2324 -> 1668;
2324 -> 2323;
2324 -> 1677;
2324 -> 1593;
2324 -> 1594;
2324 -> 2309;
2324 -> 1601;
2324 -> 1598;
2325 -> 1613;
2326 -> 2325;
2326 -> 1434;
2327 -> 2326;
2327 -> 1436;
2327 -> 1434;
2328 -> 1632;
2329 -> 2328;
2329 -> 1472;
2330 -> 2329;
2330 -> 1474;
2330 -> 1472;
2331 -> 1470;
2331 -> 1502;
2331 -> 1628;
2331 -> 2330;
2331 -> 1637;
2331 -> 1498;
2331 -> 1499;
2331 -> 2316;
2331 -> 1509;
2331 -> 1501;
2332 -> 1652;
2333 -> 2332;
2333 -> 1521;
2334 -> 2333;
2334 -> 1523;
2334 -> 1521;
2335 -> 1519;
2335 -> 1553;
2335 -> 1648;
2335 -> 2334;
2335 -> 1657;
2335 -> 1547;
2335 -> 1548;
2335 -> 2320;
2335 -> 1555;
2335 -> 1552;
2336 -> 1672;
2337 -> 2336;
2337 -> 1567;
2338 -> 2337;
2338 -> 1569;
2338 -> 1567;
2339 -> 1565;
2339 -> 1599;
2339 -> 1668;
2339 -> 2338;
2339 -> 1677;
2339 -> 1593;
2339 -> 1594;
2339 -> 2324;
2339 -> 1601;
2339 -> 1598;
2340 -> 1613;
2341 -> 2340;
2341 -> 1434;
2342 -> 2341;
2342 -> 1436;
2342 -> 1434;
2343 -> 1632;
2344 -> 2343;
2344 -> 1472;
2345 -> 2344;
2345 -> 1474;
2345 -> 1472;
2346 -> 1470;
2346 -> 1502;
2346 -> 1628;
2346 -> 2345;
2346 -> 1637;
2346 -> 1498;
2346 -> 1499;
2346 -> 2331;
2346 -> 1509;
2346 -> 1501;
2347 -> 1652;
2348 -> 2347;
2348 -> 1521;
2349 -> 2348;
2349 -> 1523;
2349 -> 1521;
2350 -> 1519;
2350 -> 1553;
2350 -> 1648;
2350 -> 2349;
2350 -> 1657;
2350 -> 1547;
2350 -> 1548;
2350 -> 2335;
2350 -> 1555;
2350 -> 1552;
2351 -> 1672;
2352 -> 2351;
2352 -> 1567;
2353 -> 2352;
2353 -> 1569;
2353 -> 1567;
2354 -> 1565;
2354 -> 1599;
2354 -> 1668;
2354 -> 2353;
2354 -> 1677;
2354 -> 1593;
2354 -> 1594;
2354 -> 2339;
2354 -> 1601;
2354 -> 1598;
2355 -> 1613;
2356 -> 2355;
2356 -> 1434;
2357 -> 2356;
2357 -> 1436;
2357 -> 1434;
2358 -> 1632;
2359 -> 2358;
2359 -> 1472;
2360 -> 2359;
2360 -> 1474;
2360 -> 1472;
2361 -> 1470;
2361 -> 1502;
2361 -> 1628;
2361 -> 2360;
2361 -> 1637;
2361 -> 1498;
2361 -> 1499;
2361 -> 2346;
2361 -> 1509;
2361 -> 1501;
2362 -> 1652;
2363 -> 2362;
2363 -> 1521;
2364 -> 2363;
2364 -> 1523;
2364 -> 1521;
2365 -> 1519;
2365 -> 1553;
2365 -> 1648;
2365 -> 2364;
2365 -> 1657;
2365 -> 1547;
2365 -> 1548;
2365 -> 2350;
2365 -> 1555;
2365 -> 1552;
2366 -> 1672;
2367 -> 2366;
2367 -> 1567;
2368 -> 2367;
2368 -> 1569;
2368 -> 1567;
2369 -> 1565;
2369 -> 1599;
2369 -> 1668;
2369 -> 2368;
2369 -> 1677;
2369 -> 1593;
2369 -> 1594;
2369 -> 2354;
2369 -> 1601;
2369 -> 1598;
2370 -> 1613;
2371 -> 2370;
2371 -> 1434;
2372 -> 2371;
2372 -> 1436;
2372 -> 1434;
2373 -> 1632;
2374 -> 2373;
2374 -> 1472;
2375 -> 2374;
2375 -> 1474;
2375 -> 1472;
2376 -> 1470;
2376 -> 1502;
2376 -> 1628;
2376 -> 2375;
2376 -> 1637;
2376 -> 1498;
2376 -> 1499;
2376 -> 2361;
2376 -> 1509;
2376 -> 1501;
2377 -> 1652;
2378 -> 2377;
2378 -> 1521;
2379 -> 2378;
2379 -> 1523;
2379 -> 1521;
2380 -> 1519;
2380 -> 1553;
2380 -> 1648;
2380 -> 2379;
2380 -> 1657;
2380 -> 1547;
2380 -> 1548;
2380 -> 2365;
2380 -> 1555;
2380 -> 1552;
2381 -> 1672;
2382 -> 2381;
2382 -> 1567;
2383 -> 2382;
2383 -> 1569;
2383 -> 1567;
2384 -> 1565;
2384 -> 1599;
2384 -> 1668;
2384 -> 2383;
2384 -> 1677;
2384 -> 1593;
2384 -> 1594;
2384 -> 2369;
2384 -> 1601;
2384 -> 1598;
2385 -> 1613;
2386 -> 2385;
2386 -> 1434;
2387 -> 2386;
2387 -> 1436;
2387 -> 1434;
2388 -> 1632;
2389 -> 2388;
2389 -> 1472;
2390 -> 2389;
2390 -> 1474;
2390 -> 1472;
2391 -> 1470;
2391 -> 1502;
2391 -> 1628;
2391 -> 2390;
2391 -> 1637;
2391 -> 1498;
2391 -> 1499;
2391 -> 2376;
2391 -> 1509;
2391 -> 1501;
2392 -> 1652;
2393 -> 2392;
2393 -> 1521;
2394 -> 2393;
2394 -> 1523;
2394 -> 1521;
2395 -> 1519;
2395 -> 1553;
2395 -> 1648;
2395 -> 2394;
2395 -> 1657;
2395 -> 1547;
2395 -> 1548;
2395 -> 2380;
2395 -> 1555;
2395 -> 1552;
2396 -> 1672;
2397 -> 2396;
2397 -> 1567;
2398 -> 2397;
2398 -> 1569;
2398 -> 1567;
2399 -> 1565;
2399 -> 1599;
2399 -> 1668;
2399 -> 2398;
2399 -> 1677;
2399 -> 1593;
2399 -> 1594;
2399 -> 2384;
2399 -> 1601;
2399 -> 1598;
2400 -> 1613;
2401 -> 2400;
2401 -> 1434;
2402 -> 2401;
2402 -> 1436;
2402 -> 1434;
2403 -> 1632;
2404 -> 2403;
2404 -> 1472;
2405 -> 2404;
2405 -> 1474;
2405 -> 1472;
2406 -> 1470;
2406 -> 1502;
2406 -> 1628;
2406 -> 2405;
2406 -> 1637;
2406 -> 1498;
2406 -> 1499;
2406 -> 2391;
2406 -> 1509;
2406 -> 1501;
2407 -> 1652;
2408 -> 2407;
2408 -> 1521;
2409 -> 2408;
2409 -> 1523;
2409 -> 1521;
2410 -> 1519;
2410 -> 1553;
2410 -> 1648;
2410 -> 2409;
2410 -> 1657;
2410 -> 1547;
2410 -> 1548;
2410 -> 2395;
2410 -> 1555;
2410 -> 1552;
2411 -> 1672;
2412 -> 2411;
2412 -> 1567;
2413 -> 2412;
2413 -> 1569;
2413 -> 1567;
2414 -> 1565;
2414 -> 1599;
2414 -> 1668;
2414 -> 2413;
2414 -> 1677;
2414 -> 1593;
2414 -> 1594;
2414 -> 2399;
2414 -> 1601;
2414 -> 1598;
2415 -> 1613;
2416 -> 2415;
2416 -> 1434;
2417 -> 2416;
2417 -> 1436;
2417 -> 1434;
2418 -> 1632;
2419 -> 2418;
2419 -> 1472;
2420 -> 2419;
2420 -> 1474;
2420 -> 1472;
2421 -> 1470;
2421 -> 1502;
2421 -> 1628;
2421 -> 2420;
2421 -> 1637;
2421 -> 1498;
2421 -> 1499;
2421 -> 2406;
2421 -> 1509;
2421 -> 1501;
2422 -> 1652;
2423 -> 2422;
2423 -> 1521;
2424 -> 2423;
2424 -> 1523;
2424 -> 1521;
2425 -> 1519;
2425 -> 1553;
2425 -> 1648;
2425 -> 2424;
2425 -> 1657;
2425 -> 1547;
2425 -> 1548;
2425 -> 2410;
2425 -> 1555;
2425 -> 1552;
2426 -> 1672;
2427 -> 2426;
2427 -> 1567;
2428 -> 2427;
2428 -> 1569;
2428 -> 1567;
2429 -> 1565;
2429 -> 1599;
2429 -> 1668;
2429 -> 2428;
2429 -> 1677;
2429 -> 1593;
2429 -> 1594;
2429 -> 2414;
2429 -> 1601;
2429 -> 1598;
2430 -> 1613;
2431 -> 2430;
2431 -> 1434;
2432 -> 2431;
2432 -> 1436;
2432 -> 1434;
2433 -> 1632;
2434 -> 2433;
2434 -> 1472;
2435 -> 2434;
2435 -> 1474;
2435 -> 1472;
2436 -> 1470;
2436 -> 1502;
2436 -> 1628;
2436 -> 2435;
2436 -> 1637;
2436 -> 1498;
2436 -> 1499;
2436 -> 2421;
2436 -> 1509;
2436 -> 1501;
2437 -> 1652;
2438 -> 2437;
2438 -> 1521;
2439 -> 2438;
2439 -> 1523;
2439 -> 1521;
2440 -> 1519;
2440 -> 1553;
2440 -> 1648;
2440 -> 2439;
2440 -> 1657;
2440 -> 1547;
2440 -> 1548;
2440 -> 2425;
2440 -> 1555;
2440 -> 1552;
2441 -> 1672;
2442 -> 2441;
2442 -> 1567;
2443 -> 2442;
2443 -> 1569;
2443 -> 1567;
2444 -> 1565;
2444 -> 1599;
2444 -> 1668;
2444 -> 2443;
2444 -> 1677;
2444 -> 1593;
2444 -> 1594;
2444 -> 2429;
2444 -> 1601;
2444 -> 1598;
2445 -> 1613;
2446 -> 2445;
2446 -> 1434;
2447 -> 2446;
2447 -> 1436;
2447 -> 1434;
2448 -> 1632;
2449 -> 2448;
2449 -> 1472;
2450 -> 2449;
2450 -> 1474;
2450 -> 1472;
2451 -> 1470;
2451 -> 1502;
2451 -> 1628;
2451 -> 2450;
2451 -> 1637;
2451 -> 1498;
2451 -> 1499;
2451 -> 2436;
2451 -> 1509;
2451 -> 1501;
2452 -> 1652;
2453 -> 2452;
2453 -> 1521;
2454 -> 2453;
2454 -> 1523;
2454 -> 1521;
2455 -> 1519;
2455 -> 1553;
2455 -> 1648;
2455 -> 2454;
2455 -> 1657;
2455 -> 1547;
2455 -> 1548;
2455 -> 2440;
2455 -> 1555;
2455 -> 1552;
2456 -> 1672;
2457 -> 2456;
2457 -> 1567;
2458 -> 2457;
2458 -> 1569;
2458 -> 1567;
2459 -> 1565;
2459 -> 1599;
2459 -> 1668;
2459 -> 2458;
2459 -> 1677;
2459 -> 1593;
2459 -> 1594;
2459 -> 2444;
2459 -> 1601;
2459 -> 1598;
2460 -> 1613;
2461 -> 2460;
2461 -> 1434;
2462 -> 2461;
2462 -> 1436;
2462 -> 1434;
2463 -> 1632;
2464 -> 2463;
2464 -> 1472;
2465 -> 2464;
2465 -> 1474;
2465 -> 1472;
2466 -> 1470;
2466 -> 1502;
2466 -> 1628;
2466 -> 2465;
2466 -> 1637;
2466 -> 1498;
2466 -> 1499;
2466 -> 2451;
2466 -> 1509;
2466 -> 1501;
2467 -> 1652;
2468 -> 2467;
2468 -> 1521;
2469 -> 2468;
2469 -> 1523;
2469 -> 1521;
2470 -> 1519;
2470 -> 1553;
2470 -> 1648;
2470 -> 2469;
2470 -> 1657;
2470 -> 1547;
2470 -> 1548;
2470 -> 2455;
2470 -> 1555;
2470 -> 1552;
2471 -> 1672;
2472 -> 2471;
2472 -> 1567;
2473 -> 2472;
2473 -> 1569;
2473 -> 1567;
2474 -> 1565;
2474 -> 1599;
2474 -> 1668;
2474 -> 2473;
2474 -> 1677;
2474 -> 1593;
2474 -> 1594;
2474 -> 2459;
2474 -> 1601;
2474 -> 1598;
2475 -> 1613;
2476 -> 2475;
2476 -> 1434;
2477 -> 2476;
2477 -> 1436;
2477 -> 1434;
2478 -> 1632;
2479 -> 2478;
2479 -> 1472;
2480 -> 2479;
2480 -> 1474;
2480 -> 1472;
2481 -> 1470;
2481 -> 1502;
2481 -> 1628;
2481 -> 2480;
2481 -> 1637;
2481 -> 1498;
2481 -> 1499;
2481 -> 2466;
2481 -> 1509;
2481 -> 1501;
2482 -> 1652;
2483 -> 2482;
2483 -> 1521;
2484 -> 2483;
2484 -> 1523;
2484 -> 1521;
2485 -> 1519;
2485 -> 1553;
2485 -> 1648;
2485 -> 2484;
2485 -> 1657;
2485 -> 1547;
2485 -> 1548;
2485 -> 2470;
2485 -> 1555;
2485 -> 1552;
2486 -> 1672;
2487 -> 2486;
2487 -> 1567;
2488 -> 2487;
2488 -> 1569;
2488 -> 1567;
2489 -> 1565;
2489 -> 1599;
2489 -> 1668;
2489 -> 2488;
2489 -> 1677;
2489 -> 1593;
2489 -> 1594;
2489 -> 2474;
2489 -> 1601;
2489 -> 1598;
2490 -> 1613;
2491 -> 2490;
2491 -> 1434;
2492 -> 2491;
2492 -> 1436;
2492 -> 1434;
2493 -> 1632;
2494 -> 2493;
2494 -> 1472;
2495 -> 2494;
2495 -> 1474;
2495 -> 1472;
2496 -> 1470;
2496 -> 1502;
2496 -> 1628;
2496 -> 2495;
2496 -> 1637;
2496 -> 1498;
2496 -> 1499;
2496 -> 2481;
2496 -> 1509;
2496 -> 1501;
2497 -> 1652;
2498 -> 2497;
2498 -> 1521;
2499 -> 2498;
2499 -> 1523;
2499 -> 1521;
2500 -> 1519;
2500 -> 1553;
2500 -> 1648;
2500 -> 2499;
2500 -> 1657;
2500 -> 1547;
2500 -> 1548;
2500 -> 2485;
2500 -> 1555;
2500 -> 1552;
2501 -> 1672;
2502 -> 2501;
2502 -> 1567;
2503 -> 2502;
2503 -> 1569;
2503 -> 1567;
2504 -> 1565;
2504 -> 1599;
2504 -> 1668;
2504 -> 2503;
2504 -> 1677;
2504 -> 1593;
2504 -> 1594;
2504 -> 2489;
2504 -> 1601;
2504 -> 1598;
2505 -> 1613;
2506 -> 2505;
2506 -> 1434;
2507 -> 2506;
2507 -> 1436;
2507 -> 1434;
2508 -> 1632;
2509 -> 2508;
2509 -> 1472;
2510 -> 2509;
2510 -> 1474;
2510 -> 1472;
2511 -> 1470;
2511 -> 1502;
2511 -> 1628;
2511 -> 2510;
2511 -> 1637;
2511 -> 1498;
2511 -> 1499;
2511 -> 2496;
2511 -> 1509;
2511 -> 1501;
2512 -> 1652;
2513 -> 2512;
2513 -> 1521;
2514 -> 2513;
2514 -> 1523;
2514 -> 1521;
2515 -> 1519;
2515 -> 1553;
2515 -> 1648;
2515 -> 2514;
2515 -> 1657;
2515 -> 1547;
2515 -> 1548;
2515 -> 2500;
2515 -> 1555;
2515 -> 1552;
2516 -> 1672;
2517 -> 2516;
2517 -> 1567;
2518 -> 2517;
2518 -> 1569;
2518 -> 1567;
2519 -> 1565;
2519 -> 1599;
2519 -> 1668;
2519 -> 2518;
2519 -> 1677;
2519 -> 1593;
2519 -> 1594;
2519 -> 2504;
2519 -> 1601;
2519 -> 1598;
2520 -> 1613;
2521 -> 2520;
2521 -> 1434;
2522 -> 2521;
2522 -> 1436;
2522 -> 1434;
2523 -> 1632;
2524 -> 2523;
2524 -> 1472;
2525 -> 2524;
2525 -> 1474;
2525 -> 1472;
2526 -> 1470;
2526 -> 1502;
2526 -> 1628;
2526 -> 2525;
2526 -> 1637;
2526 -> 1498;
2526 -> 1499;
2526 -> 2511;
2526 -> 1509;
2526 -> 1501;
2527 -> 1652;
2528 -> 2527;
2528 -> 1521;
2529 -> 2528;
2529 -> 1523;
2529 -> 1521;
2530 -> 1519;
2530 -> 1553;
2530 -> 1648;
2530 -> 2529;
2530 -> 1657;
2530 -> 1547;
2530 -> 1548;
2530 -> 2515;
2530 -> 1555;
2530 -> 1552;
2531 -> 1672;
2532 -> 2531;
2532 -> 1567;
2533 -> 2532;
2533 -> 1569;
2533 -> 1567;
2534 -> 1565;
2534 -> 1599;
2534 -> 1668;
2534 -> 2533;
2534 -> 1677;
2534 -> 1593;
2534 -> 1594;
2534 -> 2519;
2534 -> 1601;
2534 -> 1598;
2535 -> 1613;
2536 -> 2535;
2536 -> 1434;
2537 -> 2536;
2537 -> 1436;
2537 -> 1434;
2538 -> 1632;
2539 -> 2538;
2539 -> 1472;
2540 -> 2539;
2540 -> 1474;
2540 -> 1472;
2541 -> 1470;
2541 -> 1502;
2541 -> 1628;
2541 -> 2540;
2541 -> 1637;
2541 -> 1498;
2541 -> 1499;
2541 -> 2526;
2541 -> 1509;
2541 -> 1501;
2542 -> 1652;
2543 -> 2542;
2543 -> 1521;
2544 -> 2543;
2544 -> 1523;
2544 -> 1521;
2545 -> 1519;
2545 -> 1553;
2545 -> 1648;
2545 -> 2544;
2545 -> 1657;
2545 -> 1547;
2545 -> 1548;
2545 -> 2530;
2545 -> 1555;
2545 -> 1552;
2546 -> 1672;
2547 -> 2546;
2547 -> 1567;
2548 -> 2547;
2548 -> 1569;
2548 -> 1567;
2549 -> 1565;
2549 -> 1599;
2549 -> 1668;
2549 -> 2548;
2549 -> 1677;
2549 -> 1593;
2549 -> 1594;
2549 -> 2534;
2549 -> 1601;
2549 -> 1598;
2550 -> 1613;
2551 -> 2550;
2551 -> 1434;
2552 -> 2551;
2552 -> 1436;
2552 -> 1434;
2553 -> 1632;
2554 -> 2553;
2554 -> 1472;
2555 -> 2554;
2555 -> 1474;
2555 -> 1472;
2556 -> 1470;
2556 -> 1502;
2556 -> 1628;
2556 -> 2555;
2556 -> 1637;
2556 -> 1498;
2556 -> 1499;
2556 -> 2541;
2556 -> 1509;
2556 -> 1501;
2557 -> 1652;
2558 -> 2557;
2558 -> 1521;
2559 -> 2558;
2559 -> 1523;
2559 -> 1521;
2560 -> 1519;
2560 -> 1553;
2560 -> 1648;
2560 -> 2559;
2560 -> 1657;
2560 -> 1547;
2560 -> 1548;
2560 -> 2545;
2560 -> 1555;
2560 -> 1552;
2561 -> 1672;
2562 -> 2561;
2562 -> 1567;
2563 -> 2562;
2563 -> 1569;
2563 -> 1567;
2564 -> 1565;
2564 -> 1599;
2564 -> 1668;
2564 -> 2563;
2564 -> 1677;
2564 -> 1593;
2564 -> 1594;
2564 -> 2549;
2564 -> 1601;
2564 -> 1598;
2565 -> 1613;
2566 -> 2565;
2566 -> 1434;
2567 -> 2566;
2567 -> 1436;
2567 -> 1434;
2568 -> 1632;
2569 -> 2568;
2569 -> 1472;
2570 -> 2569;
2570 -> 1474;
2570 -> 1472;
2571 -> 1470;
2571 -> 1502;
2571 -> 1628;
2571 -> 2570;
2571 -> 1637;
2571 -> 1498;
2571 -> 1499;
2571 -> 2556;
2571 -> 1509;
2571 -> 1501;
2572 -> 1652;
2573 -> 2572;
2573 -> 1521;
2574 -> 2573;
2574 -> 1523;
2574 -> 1521;
2575 -> 1519;
2575 -> 1553;
2575 -> 1648;
2575 -> 2574;
2575 -> 1657;
2575 -> 1547;
2575 -> 1548;
2575 -> 2560;
2575 -> 1555;
2575 -> 1552;
2576 -> 1672;
2577 -> 2576;
2577 -> 1567;
2578 -> 2577;
2578 -> 1569;
2578 -> 1567;
2579 -> 1565;
2579 -> 1599;
2579 -> 1668;
2579 -> 2578;
2579 -> 1677;
2579 -> 1593;
2579 -> 1594;
2579 -> 2564;
2579 -> 1601;
2579 -> 1598;
2580 -> 1613;
2581 -> 2580;
2581 -> 1434;
2582 -> 2581;
2582 -> 1436;
2582 -> 1434;
2583 -> 1632;
2584 -> 2583;
2584 -> 1472;
2585 -> 2584;
2585 -> 1474;
2585 -> 1472;
2586 -> 1470;
2586 -> 1502;
2586 -> 1628;
2586 -> 2585;
2586 -> 1637;
2586 -> 1498;
2586 -> 1499;
2586 -> 2571;
2586 -> 1509;
2586 -> 1501;
2587 -> 1652;
2588 -> 2587;
2588 -> 1521;
2589 -> 2588;
2589 -> 1523;
2589 -> 1521;
2590 -> 1519;
2590 -> 1553;
2590 -> 1648;
2590 -> 2589;
2590 -> 1657;
2590 -> 1547;
2590 -> 1548;
2590 -> 2575;
2590 -> 1555;
2590 -> 1552;
2591 -> 1672;
2592 -> 2591;
2592 -> 1567;
2593 -> 2592;
2593 -> 1569;
2593 -> 1567;
2594 -> 1565;
2594 -> 1599;
2594 -> 1668;
2594 -> 2593;
2594 -> 1677;
2594 -> 1593;
2594 -> 1594;
2594 -> 2579;
2594 -> 1601;
2594 -> 1598;
2595 -> 1613;
2596 -> 2595;
2596 -> 1434;
2597 -> 2596;
2597 -> 1436;
2597 -> 1434;
2598 -> 1632;
2599 -> 2598;
2599 -> 1472;
2600 -> 2599;
2600 -> 1474;
2600 -> 1472;
2601 -> 1470;
2601 -> 1502;
2601 -> 1628;
2601 -> 2600;
2601 -> 1637;
2601 -> 1498;
2601 -> 1499;
2601 -> 2586;
2601 -> 1509;
2601 -> 1501;
2602 -> 1652;
2603 -> 2602;
2603 -> 1521;
2604 -> 2603;
2604 -> 1523;
2604 -> 1521;
2605 -> 1519;
2605 -> 1553;
2605 -> 1648;
2605 -> 2604;
2605 -> 1657;
2605 -> 1547;
2605 -> 1548;
2605 -> 2590;
2605 -> 1555;
2605 -> 1552;
2606 -> 1672;
2607 -> 2606;
2607 -> 1567;
2608 -> 2607;
2608 -> 1569;
2608 -> 1567;
2609 -> 1565;
2609 -> 1599;
2609 -> 1668;
2609 -> 2608;
2609 -> 1677;
2609 -> 1593;
2609 -> 1594;
2609 -> 2594;
2609 -> 1601;
2609 -> 1598;
2610 -> 1613;
2611 -> 2610;
2611 -> 1434;
2612 -> 2611;
2612 -> 1436;
2612 -> 1434;
2613 -> 1632;
2614 -> 2613;
2614 -> 1472;
2615 -> 2614;
2615 -> 1474;
2615 -> 1472;
2616 -> 1470;
2616 -> 1502;
2616 -> 1628;
2616 -> 2615;
2616 -> 1637;
2616 -> 1498;
2616 -> 1499;
2616 -> 2601;
2616 -> 1509;
2616 -> 1501;
2617 -> 1652;
2618 -> 2617;
2618 -> 1521;
2619 -> 2618;
2619 -> 1523;
2619 -> 1521;
2620 -> 1519;
2620 -> 1553;
2620 -> 1648;
2620 -> 2619;
2620 -> 1657;
2620 -> 1547;
2620 -> 1548;
2620 -> 2605;
2620 -> 1555;
2620 -> 1552;
2621 -> 1672;
2622 -> 2621;
2622 -> 1567;
2623 -> 2622;
2623 -> 1569;
2623 -> 1567;
2624 -> 1565;
2624 -> 1599;
2624 -> 1668;
2624 -> 2623;
2624 -> 1677;
2624 -> 1593;
2624 -> 1594;
2624 -> 2609;
2624 -> 1601;
2624 -> 1598;
2625 -> 1613;
2626 -> 2625;
2626 -> 1434;
2627 -> 2626;
2627 -> 1436;
2627 -> 1434;
2628 -> 1632;
2629 -> 2628;
2629 -> 1472;
2630 -> 2629;
2630 -> 1474;
2630 -> 1472;
2631 -> 1470;
2631 -> 1502;
2631 -> 1628;
2631 -> 2630;
2631 -> 1637;
2631 -> 1498;
2631 -> 1499;
2631 -> 2616;
2631 -> 1509;
2631 -> 1501;
2632 -> 1652;
2633 -> 2632;
2633 -> 1521;
2634 -> 2633;
2634 -> 1523;
2634 -> 1521;
2635 -> 1519;
2635 -> 1553;
2635 -> 1648;
2635 -> 2634;
2635 -> 1657;
2635 -> 1547;
2635 -> 1548;
2635 -> 2620;
2635 -> 1555;
2635 -> 1552;
2636 -> 1672;
2637 -> 2636;
2637 -> 1567;
2638 -> 2637;
2638 -> 1569;
2638 -> 1567;
2639 -> 1565;
2639 -> 1599;
2639 -> 1668;
2639 -> 2638;
2639 -> 1677;
2639 -> 1593;
2639 -> 1594;
2639 -> 2624;
2639 -> 1601;
2639 -> 1598;
2640 -> 1613;
2641 -> 2640;
2641 -> 1434;
2642 -> 2641;
2642 -> 1436;
2642 -> 1434;
2643 -> 1632;
2644 -> 2643;
2644 -> 1472;
2645 -> 2644;
2645 -> 1474;
2645 -> 1472;
2646 -> 1470;
2646 -> 1502;
2646 -> 1628;
2646 -> 2645;
2646 -> 1637;
2646 -> 1498;
2646 -> 1499;
2646 -> 2631;
2646 -> 1509;
2646 -> 1501;
2647 -> 1652;
2648 -> 2647;
2648 -> 1521;
2649 -> 2648;
2649 -> 1523;
2649 -> 1521;
2650 -> 1519;
2650 -> 1553;
2650 -> 1648;
2650 -> 2649;
2650 -> 1657;
2650 -> 1547;
2650 -> 1548;
2650 -> 2635;
2650 -> 1555;
2650 -> 1552;
2651 -> 1672;
2652 -> 2651;
2652 -> 1567;
2653 -> 2652;
2653 -> 1569;
2653 -> 1567;
2654 -> 1565;
2654 -> 1599;
2654 -> 1668;
2654 -> 2653;
2654 -> 1677;
2654 -> 1593;
2654 -> 1594;
2654 -> 2639;
2654 -> 1601;
2654 -> 1598;
2655 -> 1613;
2656 -> 2655;
2656 -> 1434;
2657 -> 2656;
2657 -> 1436;
2657 -> 1434;
2658 -> 1632;
2659 -> 2658;
2659 -> 1472;
2660 -> 2659;
2660 -> 1474;
2660 -> 1472;
2661 -> 1470;
2661 -> 1502;
2661 -> 1628;
2661 -> 2660;
2661 -> 1637;
2661 -> 1498;
2661 -> 1499;
2661 -> 2646;
2661 -> 1509;
2661 -> 1501;
2662 -> 1652;
2663 -> 2662;
2663 -> 1521;
2664 -> 2663;
2664 -> 1523;
2664 -> 1521;
2665 -> 1519;
2665 -> 1553;
2665 -> 1648;
2665 -> 2664;
2665 -> 1657;
2665 -> 1547;
2665 -> 1548;
2665 -> 2650;
2665 -> 1555;
2665 -> 1552;
2666 -> 1672;
2667 -> 2666;
2667 -> 1567;
2668 -> 2667;
2668 -> 1569;
2668 -> 1567;
2669 -> 1565;
2669 -> 1599;
2669 -> 1668;
2669 -> 2668;
2669 -> 1677;
2669 -> 1593;
2669 -> 1594;
2669 -> 2654;
2669 -> 1601;
2669 -> 1598;
2670 -> 1613;
2671 -> 2670;
2671 -> 1434;
2672 -> 2671;
2672 -> 1436;
2672 -> 1434;
2673 -> 1632;
2674 -> 2673;
2674 -> 1472;
2675 -> 2674;
2675 -> 1474;
2675 -> 1472;
2676 -> 1470;
2676 -> 1502;
2676 -> 1628;
2676 -> 2675;
2676 -> 1637;
2676 -> 1498;
2676 -> 1499;
2676 -> 2661;
2676 -> 1509;
2676 -> 1501;
2677 -> 1652;
2678 -> 2677;
2678 -> 1521;
2679 -> 2678;
2679 -> 1523;
2679 -> 1521;
2680 -> 1519;
2680 -> 1553;
2680 -> 1648;
2680 -> 2679;
2680 -> 1657;
2680 -> 1547;
2680 -> 1548;
2680 -> 2665;
2680 -> 1555;
2680 -> 1552;
2681 -> 1672;
2682 -> 2681;
2682 -> 1567;
2683 -> 2682;
2683 -> 1569;
2683 -> 1567;
2684 -> 1565;
2684 -> 1599;
2684 -> 1668;
2684 -> 2683;
2684 -> 1677;
2684 -> 1593;
2684 -> 1594;
2684 -> 2669;
2684 -> 1601;
2684 -> 1598;
2685 -> 1613;
2686 -> 2685;
2686 -> 1434;
2687 -> 2686;
2687 -> 1436;
2687 -> 1434;
2688 -> 1632;
2689 -> 2688;
2689 -> 1472;
2690 -> 2689;
2690 -> 1474;
2690 -> 1472;
2691 -> 1470;
2691 -> 1502;
2691 -> 1628;
2691 -> 2690;
2691 -> 1637;
2691 -> 1498;
2691 -> 1499;
2691 -> 2676;
2691 -> 1509;
2691 -> 1501;
2692 -> 1652;
2693 -> 2692;
2693 -> 1521;
2694 -> 2693;
2694 -> 1523;
2694 -> 1521;
2695 -> 1519;
2695 -> 1553;
2695 -> 1648;
2695 -> 2694;
2695 -> 1657;
2695 -> 1547;
2695 -> 1548;
2695 -> 2680;
2695 -> 1555;
2695 -> 1552;
2696 -> 1672;
2697 -> 2696;
2697 -> 1567;
2698 -> 2697;
2698 -> 1569;
2698 -> 1567;
2699 -> 1565;
2699 -> 1599;
2699 -> 1668;
2699 -> 2698;
2699 -> 1677;
2699 -> 1593;
2699 -> 1594;
2699 -> 2684;
2699 -> 1601;
2699 -> 1598;
2700 -> 1613;
2701 -> 2700;
2701 -> 1434;
2702 -> 2701;
2702 -> 1436;
2702 -> 1434;
2703 -> 1632;
2704 -> 2703;
2704 -> 1472;
2705 -> 2704;
2705 -> 1474;
2705 -> 1472;
2706 -> 1470;
2706 -> 1502;
2706 -> 1628;
2706 -> 2705;
2706 -> 1637;
2706 -> 1498;
2706 -> 1499;
2706 -> 2691;
2706 -> 1509;
2706 -> 1501;
2707 -> 1652;
2708 -> 2707;
2708 -> 1521;
2709 -> 2708;
2709 -> 1523;
2709 -> 1521;
2710 -> 1519;
2710 -> 1553;
2710 -> 1648;
2710 -> 2709;
2710 -> 1657;
2710 -> 1547;
2710 -> 1548;
2710 -> 2695;
2710 -> 1555;
2710 -> 1552;
2711 -> 1672;
2712 -> 2711;
2712 -> 1567;
2713 -> 2712;
2713 -> 1569;
2713 -> 1567;
2714 -> 1565;
2714 -> 1599;
2714 -> 1668;
2714 -> 2713;
2714 -> 1677;
2714 -> 1593;
2714 -> 1594;
2714 -> 2699;
2714 -> 1601;
2714 -> 1598;
2715 -> 1613;
2716 -> 2715;
2716 -> 1434;
2717 -> 2716;
2717 -> 1436;
2717 -> 1434;
2718 -> 1632;
2719 -> 2718;
2719 -> 1472;
2720 -> 2719;
2720 -> 1474;
2720 -> 1472;
2721 -> 1470;
2721 -> 1502;
2721 -> 1628;
2721 -> 2720;
2721 -> 1637;
2721 -> 1498;
2721 -> 1499;
2721 -> 2706;
2721 -> 1509;
2721 -> 1501;
2722 -> 1652;
2723 -> 2722;
2723 -> 1521;
2724 -> 2723;
2724 -> 1523;
2724 -> 1521;
2725 -> 1519;
2725 -> 1553;
2725 -> 1648;
2725 -> 2724;
2725 -> 1657;
2725 -> 1547;
2725 -> 1548;
2725 -> 2710;
2725 -> 1555;
2725 -> 1552;
2726 -> 1672;
2727 -> 2726;
2727 -> 1567;
2728 -> 2727;
2728 -> 1569;
2728 -> 1567;
2729 -> 1565;
2729 -> 1599;
2729 -> 1668;
2729 -> 2728;
2729 -> 1677;
2729 -> 1593;
2729 -> 1594;
2729 -> 2714;
2729 -> 1601;
2729 -> 1598;
2730 -> 1613;
2731 -> 2730;
2731 -> 1434;
2732 -> 2731;
2732 -> 1436;
2732 -> 1434;
2733 -> 1632;
2734 -> 2733;
2734 -> 1472;
2735 -> 2734;
2735 -> 1474;
2735 -> 1472;
2736 -> 1470;
2736 -> 1502;
2736 -> 1628;
2736 -> 2735;
2736 -> 1637;
2736 -> 1498;
2736 -> 1499;
2736 -> 2721;
2736 -> 1509;
2736 -> 1501;
2737 -> 1652;
2738 -> 2737;
2738 -> 1521;
2739 -> 2738;
2739 -> 1523;
2739 -> 1521;
2740 -> 1519;
2740 -> 1553;
2740 -> 1648;
2740 -> 2739;
2740 -> 1657;
2740 -> 1547;
2740 -> 1548;
2740 -> 2725;
2740 -> 1555;
2740 -> 1552;
2741 -> 1672;
2742 -> 2741;
2742 -> 1567;
2743 -> 2742;
2743 -> 1569;
2743 -> 1567;
2744 -> 1565;
2744 -> 1599;
2744 -> 1668;
2744 -> 2743;
2744 -> 1677;
2744 -> 1593;
2744 -> 1594;
2744 -> 2729;
2744 -> 1601;
2744 -> 1598;
2745 -> 1613;
2746 -> 2745;
2746 -> 1434;
2747 -> 2746;
2747 -> 1436;
2747 -> 1434;
2748 -> 1632;
2749 -> 2748;
2749 -> 1472;
2750 -> 2749;
2750 -> 1474;
2750 -> 1472;
2751 -> 1470;
2751 -> 1502;
2751 -> 1628;
2751 -> 2750;
2751 -> 1637;
2751 -> 1498;
2751 -> 1499;
2751 -> 2736;
2751 -> 1509;
2751 -> 1501;
2752 -> 1652;
2753 -> 2752;
2753 -> 1521;
2754 -> 2753;
2754 -> 1523;
2754 -> 1521;
2755 -> 1519;
2755 -> 1553;
2755 -> 1648;
2755 -> 2754;
2755 -> 1657;
2755 -> 1547;
2755 -> 1548;
2755 -> 2740;
2755 -> 1555;
2755 -> 1552;
2756 -> 1672;
2757 -> 2756;
2757 -> 1567;
2758 -> 2757;
2758 -> 1569;
2758 -> 1567;
2759 -> 1565;
2759 -> 1599;
2759 -> 1668;
2759 -> 2758;
2759 -> 1677;
2759 -> 1593;
2759 -> 1594;
2759 -> 2744;
2759 -> 1601;
2759 -> 1598;
2760 -> 1613;
2761 -> 2760;
2761 -> 1434;
2762 -> 2761;
2762 -> 1436;
2762 -> 1434;
2763 -> 1632;
2764 -> 2763;
2764 -> 1472;
2765 -> 2764;
2765 -> 1474;
2765 -> 1472;
2766 -> 1470;
2766 -> 1502;
2766 -> 1628;
2766 -> 2765;
2766 -> 1637;
2766 -> 1498;
2766 -> 1499;
2766 -> 2751;
2766 -> 1509;
2766 -> 1501;
2767 -> 1652;
2768 -> 2767;
2768 -> 1521;
2769 -> 2768;
2769 -> 1523;
2769 -> 1521;
2770 -> 1519;
2770 -> 1553;
2770 -> 1648;
2770 -> 2769;
2770 -> 1657;
2770 -> 1547;
2770 -> 1548;
2770 -> 2755;
2770 -> 1555;
2770 -> 1552;
2771 -> 1672;
2772 -> 2771;
2772 -> 1567;
2773 -> 2772;
2773 -> 1569;
2773 -> 1567;
2774 -> 1565;
2774 -> 1599;
2774 -> 1668;
2774 -> 2773;
2774 -> 1677;
2774 -> 1593;
2774 -> 1594;
2774 -> 2759;
2774 -> 1601;
2774 -> 1598;
2775 -> 1613;
2776 -> 2775;
2776 -> 1434;
2777 -> 2776;
2777 -> 1436;
2777 -> 1434;
2778 -> 1632;
2779 -> 2778;
2779 -> 1472;
2780 -> 2779;
2780 -> 1474;
2780 -> 1472;
2781 -> 1470;
2781 -> 1502;
2781 -> 1628;
2781 -> 2780;
2781 -> 1637;
2781 -> 1498;
2781 -> 1499;
2781 -> 2766;
2781 -> 1509;
2781 -> 1501;
2782 -> 1652;
2783 -> 2782;
2783 -> 1521;
2784 -> 2783;
2784 -> 1523;
2784 -> 1521;
2785 -> 1519;
2785 -> 1553;
2785 -> 1648;
2785 -> 2784;
2785 -> 1657;
2785 -> 1547;
2785 -> 1548;
2785 -> 2770;
2785 -> 1555;
2785 -> 1552;
2786 -> 1672;
2787 -> 2786;
2787 -> 1567;
2788 -> 2787;
2788 -> 1569;
2788 -> 1567;
2789 -> 1565;
2789 -> 1599;
2789 -> 1668;
2789 -> 2788;
2789 -> 1677;
2789 -> 1593;
2789 -> 1594;
2789 -> 2774;
2789 -> 1601;
2789 -> 1598;
2790 -> 1613;
2791 -> 2790;
2791 -> 1434;
2792 -> 2791;
2792 -> 1436;
2792 -> 1434;
2793 -> 1632;
2794 -> 2793;
2794 -> 1472;
2795 -> 2794;
2795 -> 1474;
2795 -> 1472;
2796 -> 1470;
2796 -> 1502;
2796 -> 1628;
2796 -> 2795;
2796 -> 1637;
2796 -> 1498;
2796 -> 1499;
2796 -> 2781;
2796 -> 1509;
2796 -> 1501;
2797 -> 1652;
2798 -> 2797;
2798 -> 1521;
2799 -> 2798;
2799 -> 1523;
2799 -> 1521;
2800 -> 1519;
2800 -> 1553;
2800 -> 1648;
2800 -> 2799;
2800 -> 1657;
2800 -> 1547;
2800 -> 1548;
2800 -> 2785;
2800 -> 1555;
2800 -> 1552;
2801 -> 1672;
2802 -> 2801;
2802 -> 1567;
2803 -> 2802;
2803 -> 1569;
2803 -> 1567;
2804 -> 1565;
2804 -> 1599;
2804 -> 1668;
2804 -> 2803;
2804 -> 1677;
2804 -> 1593;
2804 -> 1594;
2804 -> 2789;
2804 -> 1601;
2804 -> 1598;
2805 -> 1613;
2806 -> 2805;
2806 -> 1434;
2807 -> 2806;
2807 -> 1436;
2807 -> 1434;
2808 -> 1632;
2809 -> 2808;
2809 -> 1472;
2810 -> 2809;
2810 -> 1474;
2810 -> 1472;
2811 -> 1470;
2811 -> 1502;
2811 -> 1628;
2811 -> 2810;
2811 -> 1637;
2811 -> 1498;
2811 -> 1499;
2811 -> 2796;
2811 -> 1509;
2811 -> 1501;
2812 -> 1652;
2813 -> 2812;
2813 -> 1521;
2814 -> 2813;
2814 -> 1523;
2814 -> 1521;
2815 -> 1519;
2815 -> 1553;
2815 -> 1648;
2815 -> 2814;
2815 -> 1657;
2815 -> 1547;
2815 -> 1548;
2815 -> 2800;
2815 -> 1555;
2815 -> 1552;
2816 -> 1672;
2817 -> 2816;
2817 -> 1567;
2818 -> 2817;
2818 -> 1569;
2818 -> 1567;
2819 -> 1565;
2819 -> 1599;
2819 -> 1668;
2819 -> 2818;
2819 -> 1677;
2819 -> 1593;
2819 -> 1594;
2819 -> 2804;
2819 -> 1601;
2819 -> 1598;
2820 -> 1613;
2821 -> 2820;
2821 -> 1434;
2822 -> 2821;
2822 -> 1436;
2822 -> 1434;
2823 -> 1632;
2824 -> 2823;
2824 -> 1472;
2825 -> 2824;
2825 -> 1474;
2825 -> 1472;
2826 -> 1470;
2826 -> 1502;
2826 -> 1628;
2826 -> 2825;
2826 -> 1637;
2826 -> 1498;
2826 -> 1499;
2826 -> 2811;
2826 -> 1509;
2826 -> 1501;
2827 -> 1652;
2828 -> 2827;
2828 -> 1521;
2829 -> 2828;
2829 -> 1523;
2829 -> 1521;
2830 -> 1519;
2830 -> 1553;
2830 -> 1648;
2830 -> 2829;
2830 -> 1657;
2830 -> 1547;
2830 -> 1548;
2830 -> 2815;
2830 -> 1555;
2830 -> 1552;
2831 -> 1672;
2832 -> 2831;
2832 -> 1567;
2833 -> 2832;
2833 -> 1569;
2833 -> 1567;
2834 -> 1565;
2834 -> 1599;
2834 -> 1668;
2834 -> 2833;
2834 -> 1677;
2834 -> 1593;
2834 -> 1594;
2834 -> 2819;
2834 -> 1601;
2834 -> 1598;
2835 -> 1613;
2836 -> 2835;
2836 -> 1434;
2837 -> 2836;
2837 -> 1436;
2837 -> 1434;
2838 -> 1632;
2839 -> 2838;
2839 -> 1472;
2840 -> 2839;
2840 -> 1474;
2840 -> 1472;
2841 -> 1470;
2841 -> 1502;
2841 -> 1628;
2841 -> 2840;
2841 -> 1637;
2841 -> 1498;
2841 -> 1499;
2841 -> 2826;
2841 -> 1509;
2841 -> 1501;
2842 -> 1652;
2843 -> 2842;
2843 -> 1521;
2844 -> 2843;
2844 -> 1523;
2844 -> 1521;
2845 -> 1519;
2845 -> 1553;
2845 -> 1648;
2845 -> 2844;
2845 -> 1657;
2845 -> 1547;
2845 -> 1548;
2845 -> 2830;
2845 -> 1555;
2845 -> 1552;
2846 -> 1672;
2847 -> 2846;
2847 -> 1567;
2848 -> 2847;
2848 -> 1569;
2848 -> 1567;
2849 -> 1565;
2849 -> 1599;
2849 -> 1668;
2849 -> 2848;
2849 -> 1677;
2849 -> 1593;
2849 -> 1594;
2849 -> 2834;
2849 -> 1601;
2849 -> 1598;
2850 -> 1613;
2851 -> 2850;
2851 -> 1434;
2852 -> 2851;
2852 -> 1436;
2852 -> 1434;
2853 -> 1632;
2854 -> 2853;
2854 -> 1472;
2855 -> 2854;
2855 -> 1474;
2855 -> 1472;
2856 -> 1470;
2856 -> 1502;
2856 -> 1628;
2856 -> 2855;
2856 -> 1637;
2856 -> 1498;
2856 -> 1499;
2856 -> 2841;
2856 -> 1509;
2856 -> 1501;
2857 -> 1652;
2858 -> 2857;
2858 -> 1521;
2859 -> 2858;
2859 -> 1523;
2859 -> 1521;
2860 -> 1519;
2860 -> 1553;
2860 -> 1648;
2860 -> 2859;
2860 -> 1657;
2860 -> 1547;
2860 -> 1548;
2860 -> 2845;
2860 -> 1555;
2860 -> 1552;
2861 -> 1672;
2862 -> 2861;
2862 -> 1567;
2863 -> 2862;
2863 -> 1569;
2863 -> 1567;
2864 -> 1565;
2864 -> 1599;
2864 -> 1668;
2864 -> 2863;
2864 -> 1677;
2864 -> 1593;
2864 -> 1594;
2864 -> 2849;
2864 -> 1601;
2864 -> 1598;
2865 -> 1613;
2866 -> 2865;
2866 -> 1434;
2867 -> 2866;
2867 -> 1436;
2867 -> 1434;
2868 -> 1632;
2869 -> 2868;
2869 -> 1472;
2870 -> 2869;
2870 -> 1474;
2870 -> 1472;
2871 -> 1470;
2871 -> 1502;
2871 -> 1628;
2871 -> 2870;
2871 -> 1637;
2871 -> 1498;
2871 -> 1499;
2871 -> 2856;
2871 -> 1509;
2871 -> 1501;
2872 -> 1652;
2873 -> 2872;
2873 -> 1521;
2874 -> 2873;
2874 -> 1523;
2874 -> 1521;
2875 -> 1519;
2875 -> 1553;
2875 -> 1648;
2875 -> 2874;
2875 -> 1657;
2875 -> 1547;
2875 -> 1548;
2875 -> 2860;
2875 -> 1555;
2875 -> 1552;
2876 -> 1672;
2877 -> 2876;
2877 -> 1567;
2878 -> 2877;
2878 -> 1569;
2878 -> 1567;
2879 -> 1565;
2879 -> 1599;
2879 -> 1668;
2879 -> 2878;
2879 -> 1677;
2879 -> 1593;
2879 -> 1594;
2879 -> 2864;
2879 -> 1601;
2879 -> 1598;
2880 -> 1613;
2881 -> 2880;
2881 -> 1434;
2882 -> 2881;
2882 -> 1436;
2882 -> 1434;
2883 -> 1632;
2884 -> 2883;
2884 -> 1472;
2885 -> 2884;
2885 -> 1474;
2885 -> 1472;
2886 -> 1470;
2886 -> 1502;
2886 -> 1628;
2886 -> 2885;
2886 -> 1637;
2886 -> 1498;
2886 -> 1499;
2886 -> 2871;
2886 -> 1509;
2886 -> 1501;
2887 -> 1652;
2888 -> 2887;
2888 -> 1521;
2889 -> 2888;
2889 -> 1523;
2889 -> 1521;
2890 -> 1519;
2890 -> 1553;
2890 -> 1648;
2890 -> 2889;
2890 -> 1657;
2890 -> 1547;
2890 -> 1548;
2890 -> 2875;
2890 -> 1555;
2890 -> 1552;
2891 -> 1672;
2892 -> 2891;
2892 -> 1567;
2893 -> 2892;
2893 -> 1569;
2893 -> 1567;
2894 -> 1565;
2894 -> 1599;
2894 -> 1668;
2894 -> 2893;
2894 -> 1677;
2894 -> 1593;
2894 -> 1594;
2894 -> 2879;
2894 -> 1601;
2894 -> 1598;
2895 -> 1613;
2896 -> 2895;
2896 -> 1434;
2897 -> 2896;
2897 -> 1436;
2897 -> 1434;
2898 -> 1632;
2899 -> 2898;
2899 -> 1472;
2900 -> 2899;
2900 -> 1474;
2900 -> 1472;
2901 -> 1470;
2901 -> 1502;
2901 -> 1628;
2901 -> 2900;
2901 -> 1637;
2901 -> 1498;
2901 -> 1499;
2901 -> 2886;
2901 -> 1509;
2901 -> 1501;
2902 -> 1652;
2903 -> 2902;
2903 -> 1521;
2904 -> 2903;
2904 -> 1523;
2904 -> 1521;
2905 -> 1519;
2905 -> 1553;
2905 -> 1648;
2905 -> 2904;
2905 -> 1657;
2905 -> 1547;
2905 -> 1548;
2905 -> 2890;
2905 -> 1555;
2905 -> 1552;
2906 -> 1672;
2907 -> 2906;
2907 -> 1567;
2908 -> 2907;
2908 -> 1569;
2908 -> 1567;
2909 -> 1565;
2909 -> 1599;
2909 -> 1668;
2909 -> 2908;
2909 -> 1677;
2909 -> 1593;
2909 -> 1594;
2909 -> 2894;
2909 -> 1601;
2909 -> 1598;
2910 -> 1613;
2911 -> 2910;
2911 -> 1434;
2912 -> 2911;
2912 -> 1436;
2912 -> 1434;
2913 -> 1632;
2914 -> 2913;
2914 -> 1472;
2915 -> 2914;
2915 -> 1474;
2915 -> 1472;
2916 -> 1470;
2916 -> 1502;
2916 -> 1628;
2916 -> 2915;
2916 -> 1637;
2916 -> 1498;
2916 -> 1499;
2916 -> 2901;
2916 -> 1509;
2916 -> 1501;
2917 -> 1652;
2918 -> 2917;
2918 -> 1521;
2919 -> 2918;
2919 -> 1523;
2919 -> 1521;
2920 -> 1519;
2920 -> 1553;
2920 -> 1648;
2920 -> 2919;
2920 -> 1657;
2920 -> 1547;
2920 -> 1548;
2920 -> 2905;
2920 -> 1555;
2920 -> 1552;
2921 -> 1672;
2922 -> 2921;
2922 -> 1567;
2923 -> 2922;
2923 -> 1569;
2923 -> 1567;
2924 -> 1565;
2924 -> 1599;
2924 -> 1668;
2924 -> 2923;
2924 -> 1677;
2924 -> 1593;
2924 -> 1594;
2924 -> 2909;
2924 -> 1601;
2924 -> 1598;
2925 -> 1613;
2926 -> 2925;
2926 -> 1434;
2927 -> 2926;
2927 -> 1436;
2927 -> 1434;
2928 -> 1632;
2929 -> 2928;
2929 -> 1472;
2930 -> 2929;
2930 -> 1474;
2930 -> 1472;
2931 -> 1470;
2931 -> 1502;
2931 -> 1628;
2931 -> 2930;
2931 -> 1637;
2931 -> 1498;
2931 -> 1499;
2931 -> 2916;
2931 -> 1509;
2931 -> 1501;
2932 -> 1652;
2933 -> 2932;
2933 -> 1521;
2934 -> 2933;
2934 -> 1523;
2934 -> 1521;
2935 -> 1519;
2935 -> 1553;
2935 -> 1648;
2935 -> 2934;
2935 -> 1657;
2935 -> 1547;
2935 -> 1548;
2935 -> 2920;
2935 -> 1555;
2935 -> 1552;
2936 -> 1672;
2937 -> 2936;
2937 -> 1567;
2938 -> 2937;
2938 -> 1569;
2938 -> 1567;
2939 -> 1565;
2939 -> 1599;
2939 -> 1668;
2939 -> 2938;
2939 -> 1677;
2939 -> 1593;
2939 -> 1594;
2939 -> 2924;
2939 -> 1601;
2939 -> 1598;
2940 -> 1613;
2941 -> 2940;
2941 -> 1434;
2942 -> 2941;
2942 -> 1436;
2942 -> 1434;
2943 -> 1632;
2944 -> 2943;
2944 -> 1472;
2945 -> 2944;
2945 -> 1474;
2945 -> 1472;
2946 -> 1470;
2946 -> 1502;
2946 -> 1628;
2946 -> 2945;
2946 -> 1637;
2946 -> 1498;
2946 -> 1499;
2946 -> 2931;
2946 -> 1509;
2946 -> 1501;
2947 -> 1652;
2948 -> 2947;
2948 -> 1521;
2949 -> 2948;
2949 -> 1523;
2949 -> 1521;
2950 -> 1519;
2950 -> 1553;
2950 -> 1648;
2950 -> 2949;
2950 -> 1657;
2950 -> 1547;
2950 -> 1548;
2950 -> 2935;
2950 -> 1555;
2950 -> 1552;
2951 -> 1672;
2952 -> 2951;
2952 -> 1567;
2953 -> 2952;
2953 -> 1569;
2953 -> 1567;
2954 -> 1565;
2954 -> 1599;
2954 -> 1668;
2954 -> 2953;
2954 -> 1677;
2954 -> 1593;
2954 -> 1594;
2954 -> 2939;
2954 -> 1601;
2954 -> 1598;
2955 -> 1613;
2956 -> 2955;
2956 -> 1434;
2957 -> 2956;
2957 -> 1436;
2957 -> 1434;
2958 -> 1632;
2959 -> 2958;
2959 -> 1472;
2960 -> 2959;
2960 -> 1474;
2960 -> 1472;
2961 -> 1470;
2961 -> 1502;
2961 -> 1628;
2961 -> 2960;
2961 -> 1637;
2961 -> 1498;
2961 -> 1499;
2961 -> 2946;
2961 -> 1509;
2961 -> 1501;
2962 -> 1652;
2963 -> 2962;
2963 -> 1521;
2964 -> 2963;
2964 -> 1523;
2964 -> 1521;
2965 -> 1519;
2965 -> 1553;
2965 -> 1648;
2965 -> 2964;
2965 -> 1657;
2965 -> 1547;
2965 -> 1548;
2965 -> 2950;
2965 -> 1555;
2965 -> 1552;
2966 -> 1672;
2967 -> 2966;
2967 -> 1567;
2968 -> 2967;
2968 -> 1569;
2968 -> 1567;
2969 -> 1565;
2969 -> 1599;
2969 -> 1668;
2969 -> 2968;
2969 -> 1677;
2969 -> 1593;
2969 -> 1594;
2969 -> 2954;
2969 -> 1601;
2969 -> 1598;
2970 -> 1613;
2971 -> 2970;
2971 -> 1434;
2972 -> 2971;
2972 -> 1436;
2972 -> 1434;
2973 -> 1632;
2974 -> 2973;
2974 -> 1472;
2975 -> 2974;
2975 -> 1474;
2975 -> 1472;
2976 -> 1470;
2976 -> 1502;
2976 -> 1628;
2976 -> 2975;
2976 -> 1637;
2976 -> 1498;
2976 -> 1499;
2976 -> 2961;
2976 -> 1509;
2976 -> 1501;
2977 -> 1652;
2978 -> 2977;
2978 -> 1521;
2979 -> 2978;
2979 -> 1523;
2979 -> 1521;
2980 -> 1519;
2980 -> 1553;
2980 -> 1648;
2980 -> 2979;
2980 -> 1657;
2980 -> 1547;
2980 -> 1548;
2980 -> 2965;
2980 -> 1555;
2980 -> 1552;
2981 -> 1672;
2982 -> 2981;
2982 -> 1567;
2983 -> 2982;
2983 -> 1569;
2983 -> 1567;
2984 -> 1565;
2984 -> 1599;
2984 -> 1668;
2984 -> 2983;
2984 -> 1677;
2984 -> 1593;
2984 -> 1594;
2984 -> 2969;
2984 -> 1601;
2984 -> 1598;
2985 -> 1613;
2986 -> 2985;
2986 -> 1434;
2987 -> 2986;
2987 -> 1436;
2987 -> 1434;
2988 -> 1632;
2989 -> 2988;
2989 -> 1472;
2990 -> 2989;
2990 -> 1474;
2990 -> 1472;
2991 -> 1470;
2991 -> 1502;
2991 -> 1628;
2991 -> 2990;
2991 -> 1637;
2991 -> 1498;
2991 -> 1499;
2991 -> 2976;
2991 -> 1509;
2991 -> 1501;
2992 -> 1652;
2993 -> 2992;
2993 -> 1521;
2994 -> 2993;
2994 -> 1523;
2994 -> 1521;
2995 -> 1519;
2995 -> 1553;
2995 -> 1648;
2995 -> 2994;
2995 -> 1657;
2995 -> 1547;
2995 -> 1548;
2995 -> 2980;
2995 -> 1555;
2995 -> 1552;
2996 -> 1672;
2997 -> 2996;
2997 -> 1567;
2998 -> 2997;
2998 -> 1569;
2998 -> 1567;
2999 -> 1565;
2999 -> 1599;
2999 -> 1668;
2999 -> 2998;
2999 -> 1677;
2999 -> 1593;
2999 -> 1594;
2999 -> 2984;
2999 -> 1601;
2999 -> 1598;
3000 -> 1613;
3001 -> 3000;
3001 -> 1434;
3002 -> 3001;
3002 -> 1436;
3002 -> 1434;
3003 -> 1632;
3004 -> 3003;
3004 -> 1472;
3005 -> 3004;
3005 -> 1474;
3005 -> 1472;
3006 -> 1470;
3006 -> 1502;
3006 -> 1628;
3006 -> 3005;
3006 -> 1637;
3006 -> 1498;
3006 -> 1499;
3006 -> 2991;
3006 -> 1509;
3006 -> 1501;
3007 -> 1652;
3008 -> 3007;
3008 -> 1521;
3009 -> 3008;
3009 -> 1523;
3009 -> 1521;
3010 -> 1519;
3010 -> 1553;
3010 -> 1648;
3010 -> 3009;
3010 -> 1657;
3010 -> 1547;
3010 -> 1548;
3010 -> 2995;
3010 -> 1555;
3010 -> 1552;
3011 -> 1672;
3012 -> 3011;
3012 -> 1567;
3013 -> 3012;
3013 -> 1569;
3013 -> 1567;
3014 -> 1565;
3014 -> 1599;
3014 -> 1668;
3014 -> 3013;
3014 -> 1677;
3014 -> 1593;
3014 -> 1594;
3014 -> 2999;
3014 -> 1601;
3014 -> 1598;
3015 -> 1613;
3016 -> 3015;
3016 -> 1434;
3017 -> 3016;
3017 -> 1436;
3017 -> 1434;
3018 -> 1632;
3019 -> 3018;
3019 -> 1472;
3020 -> 3019;
3020 -> 1474;
3020 -> 1472;
3021 -> 1470;
3021 -> 1502;
3021 -> 1628;
3021 -> 3020;
3021 -> 1637;
3021 -> 1498;
3021 -> 1499;
3021 -> 3006;
3021 -> 1509;
3021 -> 1501;
3022 -> 1652;
3023 -> 3022;
3023 -> 1521;
3024 -> 3023;
3024 -> 1523;
3024 -> 1521;
3025 -> 1519;
3025 -> 1553;
3025 -> 1648;
3025 -> 3024;
3025 -> 1657;
3025 -> 1547;
3025 -> 1548;
3025 -> 3010;
3025 -> 1555;
3025 -> 1552;
3026 -> 1672;
3027 -> 3026;
3027 -> 1567;
3028 -> 3027;
3028 -> 1569;
3028 -> 1567;
3029 -> 1565;
3029 -> 1599;
3029 -> 1668;
3029 -> 3028;
3029 -> 1677;
3029 -> 1593;
3029 -> 1594;
3029 -> 3014;
3029 -> 1601;
3029 -> 1598;
3030 -> 1613;
3031 -> 3030;
3031 -> 1434;
3032 -> 3031;
3032 -> 1436;
3032 -> 1434;
3033 -> 1632;
3034 -> 3033;
3034 -> 1472;
3035 -> 3034;
3035 -> 1474;
3035 -> 1472;
3036 -> 1470;
3036 -> 1502;
3036 -> 1628;
3036 -> 3035;
3036 -> 1637;
3036 -> 1498;
3036 -> 1499;
3036 -> 3021;
3036 -> 1509;
3036 -> 1501;
3037 -> 1652;
3038 -> 3037;
3038 -> 1521;
3039 -> 3038;
3039 -> 1523;
3039 -> 1521;
3040 -> 1519;
3040 -> 1553;
3040 -> 1648;
3040 -> 3039;
3040 -> 1657;
3040 -> 1547;
3040 -> 1548;
3040 -> 3025;
3040 -> 1555;
3040 -> 1552;
3041 -> 1672;
3042 -> 3041;
3042 -> 1567;
3043 -> 3042;
3043 -> 1569;
3043 -> 1567;
3044 -> 1565;
3044 -> 1599;
3044 -> 1668;
3044 -> 3043;
3044 -> 1677;
3044 -> 1593;
3044 -> 1594;
3044 -> 3029;
3044 -> 1601;
3044 -> 1598;
3045 -> 1613;
3046 -> 3045;
3046 -> 1434;
3047 -> 3046;
3047 -> 1436;
3047 -> 1434;
3048 -> 1632;
3049 -> 3048;
3049 -> 1472;
3050 -> 3049;
3050 -> 1474;
3050 -> 1472;
3051 -> 1470;
3051 -> 1502;
3051 -> 1628;
3051 -> 3050;
3051 -> 1637;
3051 -> 1498;
3051 -> 1499;
3051 -> 3036;
3051 -> 1509;
3051 -> 1501;
3052 -> 1652;
3053 -> 3052;
3053 -> 1521;
3054 -> 3053;
3054 -> 1523;
3054 -> 1521;
3055 -> 1519;
3055 -> 1553;
3055 -> 1648;
3055 -> 3054;
3055 -> 1657;
3055 -> 1547;
3055 -> 1548;
3055 -> 3040;
3055 -> 1555;
3055 -> 1552;
3056 -> 1672;
3057 -> 3056;
3057 -> 1567;
3058 -> 3057;
3058 -> 1569;
3058 -> 1567;
3059 -> 1565;
3059 -> 1599;
3059 -> 1668;
3059 -> 3058;
3059 -> 1677;
3059 -> 1593;
3059 -> 1594;
3059 -> 3044;
3059 -> 1601;
3059 -> 1598;
3060 -> 1613;
3061 -> 3060;
3061 -> 1434;
3062 -> 3061;
3062 -> 1436;
3062 -> 1434;
3063 -> 1632;
3064 -> 3063;
3064 -> 1472;
3065 -> 3064;
3065 -> 1474;
3065 -> 1472;
3066 -> 1470;
3066 -> 1502;
3066 -> 1628;
3066 -> 3065;
3066 -> 1637;
3066 -> 1498;
3066 -> 1499;
3066 -> 3051;
3066 -> 1509;
3066 -> 1501;
3067 -> 1652;
3068 -> 3067;
3068 -> 1521;
3069 -> 3068;
3069 -> 1523;
3069 -> 1521;
3070 -> 1519;
3070 -> 1553;
3070 -> 1648;
3070 -> 3069;
3070 -> 1657;
3070 -> 1547;
3070 -> 1548;
3070 -> 3055;
3070 -> 1555;
3070 -> 1552;
3071 -> 1672;
3072 -> 3071;
3072 -> 1567;
3073 -> 3072;
3073 -> 1569;
3073 -> 1567;
3074 -> 1565;
3074 -> 1599;
3074 -> 1668;
3074 -> 3073;
3074 -> 1677;
3074 -> 1593;
3074 -> 1594;
3074 -> 3059;
3074 -> 1601;
3074 -> 1598;
3075 -> 1613;
3076 -> 3075;
3076 -> 1434;
3077 -> 3076;
3077 -> 1436;
3077 -> 1434;
3078 -> 1632;
3079 -> 3078;
3079 -> 1472;
3080 -> 3079;
3080 -> 1474;
3080 -> 1472;
3081 -> 1470;
3081 -> 1502;
3081 -> 1628;
3081 -> 3080;
3081 -> 1637;
3081 -> 1498;
3081 -> 1499;
3081 -> 3066;
3081 -> 1509;
3081 -> 1501;
3082 -> 1652;
3083 -> 3082;
3083 -> 1521;
3084 -> 3083;
3084 -> 1523;
3084 -> 1521;
3085 -> 1519;
3085 -> 1553;
3085 -> 1648;
3085 -> 3084;
3085 -> 1657;
3085 -> 1547;
3085 -> 1548;
3085 -> 3070;
3085 -> 1555;
3085 -> 1552;
3086 -> 1672;
3087 -> 3086;
3087 -> 1567;
3088 -> 3087;
3088 -> 1569;
3088 -> 1567;
3089 -> 1565;
3089 -> 1599;
3089 -> 1668;
3089 -> 3088;
3089 -> 1677;
3089 -> 1593;
3089 -> 1594;
3089 -> 3074;
3089 -> 1601;
3089 -> 1598;
3090 -> 1613;
3091 -> 3090;
3091 -> 1434;
3092 -> 3091;
3092 -> 1436;
3092 -> 1434;
3093 -> 1632;
3094 -> 3093;
3094 -> 1472;
3095 -> 3094;
3095 -> 1474;
3095 -> 1472;
3096 -> 1470;
3096 -> 1502;
3096 -> 1628;
3096 -> 3095;
3096 -> 1637;
3096 -> 1498;
3096 -> 1499;
3096 -> 3081;
3096 -> 1509;
3096 -> 1501;
3097 -> 1652;
3098 -> 3097;
3098 -> 1521;
3099 -> 3098;
3099 -> 1523;
3099 -> 1521;
3100 -> 1519;
3100 -> 1553;
3100 -> 1648;
3100 -> 3099;
3100 -> 1657;
3100 -> 1547;
3100 -> 1548;
3100 -> 3085;
3100 -> 1555;
3100 -> 1552;
3101 -> 1672;
3102 -> 3101;
3102 -> 1567;
3103 -> 3102;
3103 -> 1569;
3103 -> 1567;
3104 -> 1565;
3104 -> 1599;
3104 -> 1668;
3104 -> 3103;
3104 -> 1677;
3104 -> 1593;
3104 -> 1594;
3104 -> 3089;
3104 -> 1601;
3104 -> 1598;
3105 -> 1613;
3106 -> 3105;
3106 -> 1434;
3107 -> 3106;
3107 -> 1436;
3107 -> 1434;
3108 -> 1632;
3109 -> 3108;
3109 -> 1472;
3110 -> 3109;
3110 -> 1474;
3110 -> 1472;
3111 -> 1470;
3111 -> 1502;
3111 -> 1628;
3111 -> 3110;
3111 -> 1637;
3111 -> 1498;
3111 -> 1499;
3111 -> 3096;
3111 -> 1509;
3111 -> 1501;
3112 -> 1652;
3113 -> 3112;
3113 -> 1521;
3114 -> 3113;
3114 -> 1523;
3114 -> 1521;
3115 -> 1519;
3115 -> 1553;
3115 -> 1648;
3115 -> 3114;
3115 -> 1657;
3115 -> 1547;
3115 -> 1548;
3115 -> 3100;
3115 -> 1555;
3115 -> 1552;
3116 -> 1672;
3117 -> 3116;
3117 -> 1567;
3118 -> 3117;
3118 -> 1569;
3118 -> 1567;
3119 -> 1565;
3119 -> 1599;
3119 -> 1668;
3119 -> 3118;
3119 -> 1677;
3119 -> 1593;
3119 -> 1594;
3119 -> 3104;
3119 -> 1601;
3119 -> 1598;
3120 -> 1613;
3121 -> 3120;
3121 -> 1434;
3122 -> 3121;
3122 -> 1436;
3122 -> 1434;
3123 -> 1632;
3124 -> 3123;
3124 -> 1472;
3125 -> 3124;
3125 -> 1474;
3125 -> 1472;
3126 -> 1470;
3126 -> 1502;
3126 -> 1628;
3126 -> 3125;
3126 -> 1637;
3126 -> 1498;
3126 -> 1499;
3126 -> 3111;
3126 -> 1509;
3126 -> 1501;
3127 -> 1652;
3128 -> 3127;
3128 -> 1521;
3129 -> 3128;
3129 -> 1523;
3129 -> 1521;
3130 -> 1519;
3130 -> 1553;
3130 -> 1648;
3130 -> 3129;
3130 -> 1657;
3130 -> 1547;
3130 -> 1548;
3130 -> 3115;
3130 -> 1555;
3130 -> 1552;
3131 -> 1672;
3132 -> 3131;
3132 -> 1567;
3133 -> 3132;
3133 -> 1569;
3133 -> 1567;
3134 -> 1565;
3134 -> 1599;
3134 -> 1668;
3134 -> 3133;
3134 -> 1677;
3134 -> 1593;
3134 -> 1594;
3134 -> 3119;
3134 -> 1601;
3134 -> 1598;
3135 -> 1613;
3136 -> 3135;
3136 -> 1434;
3137 -> 3136;
3137 -> 1436;
3137 -> 1434;
3138 -> 1632;
3139 -> 3138;
3139 -> 1472;
3140 -> 3139;
3140 -> 1474;
3140 -> 1472;
3141 -> 1470;
3141 -> 1502;
3141 -> 1628;
3141 -> 3140;
3141 -> 1637;
3141 -> 1498;
3141 -> 1499;
3141 -> 3126;
3141 -> 1509;
3141 -> 1501;
3142 -> 1652;
3143 -> 3142;
3143 -> 1521;
3144 -> 3143;
3144 -> 1523;
3144 -> 1521;
3145 -> 1519;
3145 -> 1553;
3145 -> 1648;
3145 -> 3144;
3145 -> 1657;
3145 -> 1547;
3145 -> 1548;
3145 -> 3130;
3145 -> 1555;
3145 -> 1552;
3146 -> 1672;
3147 -> 3146;
3147 -> 1567;
3148 -> 3147;
3148 -> 1569;
3148 -> 1567;
3149 -> 1565;
3149 -> 1599;
3149 -> 1668;
3149 -> 3148;
3149 -> 1677;
3149 -> 1593;
3149 -> 1594;
3149 -> 3134;
3149 -> 1601;
3149 -> 1598;
3150 -> 1613;
3151 -> 3150;
3151 -> 1434;
3152 -> 3151;
3152 -> 1436;
3152 -> 1434;
3153 -> 1632;
3154 -> 3153;
3154 -> 1472;
3155 -> 3154;
3155 -> 1474;
3155 -> 1472;
3156 -> 1470;
3156 -> 1502;
3156 -> 1628;
3156 -> 3155;
3156 -> 1637;
3156 -> 1498;
3156 -> 1499;
3156 -> 3141;
3156 -> 1509;
3156 -> 1501;
3157 -> 1652;
3158 -> 3157;
3158 -> 1521;
3159 -> 3158;
3159 -> 1523;
3159 -> 1521;
3160 -> 1519;
3160 -> 1553;
3160 -> 1648;
3160 -> 3159;
3160 -> 1657;
3160 -> 1547;
3160 -> 1548;
3160 -> 3145;
3160 -> 1555;
3160 -> 1552;
3161 -> 1672;
3162 -> 3161;
3162 -> 1567;
3163 -> 3162;
3163 -> 1569;
3163 -> 1567;
3164 -> 1565;
3164 -> 1599;
3164 -> 1668;
3164 -> 3163;
3164 -> 1677;
3164 -> 1593;
3164 -> 1594;
3164 -> 3149;
3164 -> 1601;
3164 -> 1598;
3165 -> 1613;
3166 -> 3165;
3166 -> 1434;
3167 -> 3166;
3167 -> 1436;
3167 -> 1434;
3168 -> 1632;
3169 -> 3168;
3169 -> 1472;
3170 -> 3169;
3170 -> 1474;
3170 -> 1472;
3171 -> 1470;
3171 -> 1502;
3171 -> 1628;
3171 -> 3170;
3171 -> 1637;
3171 -> 1498;
3171 -> 1499;
3171 -> 3156;
3171 -> 1509;
3171 -> 1501;
3172 -> 1652;
3173 -> 3172;
3173 -> 1521;
3174 -> 3173;
3174 -> 1523;
3174 -> 1521;
3175 -> 1519;
3175 -> 1553;
3175 -> 1648;
3175 -> 3174;
3175 -> 1657;
3175 -> 1547;
3175 -> 1548;
3175 -> 3160;
3175 -> 1555;
3175 -> 1552;
3176 -> 1672;
3177 -> 3176;
3177 -> 1567;
3178 -> 3177;
3178 -> 1569;
3178 -> 1567;
3179 -> 1565;
3179 -> 1599;
3179 -> 1668;
3179 -> 3178;
3179 -> 1677;
3179 -> 1593;
3179 -> 1594;
3179 -> 3164;
3179 -> 1601;
3179 -> 1598;
3180 -> 1613;
3181 -> 3180;
3181 -> 1434;
3182 -> 3181;
3182 -> 1436;
3182 -> 1434;
3183 -> 1632;
3184 -> 3183;
3184 -> 1472;
3185 -> 3184;
3185 -> 1474;
3185 -> 1472;
3186 -> 1470;
3186 -> 1502;
3186 -> 1628;
3186 -> 3185;
3186 -> 1637;
3186 -> 1498;
3186 -> 1499;
3186 -> 3171;
3186 -> 1509;
3186 -> 1501;
3187 -> 1652;
3188 -> 3187;
3188 -> 1521;
3189 -> 3188;
3189 -> 1523;
3189 -> 1521;
3190 -> 1519;
3190 -> 1553;
3190 -> 1648;
3190 -> 3189;
3190 -> 1657;
3190 -> 1547;
3190 -> 1548;
3190 -> 3175;
3190 -> 1555;
3190 -> 1552;
3191 -> 1672;
3192 -> 3191;
3192 -> 1567;
3193 -> 3192;
3193 -> 1569;
3193 -> 1567;
3194 -> 1565;
3194 -> 1599;
3194 -> 1668;
3194 -> 3193;
3194 -> 1677;
3194 -> 1593;
3194 -> 1594;
3194 -> 3179;
3194 -> 1601;
3194 -> 1598;
3195 -> 1613;
3196 -> 3195;
3196 -> 1434;
3197 -> 3196;
3197 -> 1436;
3197 -> 1434;
3198 -> 1632;
3199 -> 3198;
3199 -> 1472;
3200 -> 3199;
3200 -> 1474;
3200 -> 1472;
3201 -> 1470;
3201 -> 1502;
3201 -> 1628;
3201 -> 3200;
3201 -> 1637;
3201 -> 1498;
3201 -> 1499;
3201 -> 3186;
3201 -> 1509;
3201 -> 1501;
3202 -> 1652;
3203 -> 3202;
3203 -> 1521;
3204 -> 3203;
3204 -> 1523;
3204 -> 1521;
3205 -> 1519;
3205 -> 1553;
3205 -> 1648;
3205 -> 3204;
3205 -> 1657;
3205 -> 1547;
3205 -> 1548;
3205 -> 3190;
3205 -> 1555;
3205 -> 1552;
3206 -> 1672;
3207 -> 3206;
3207 -> 1567;
3208 -> 3207;
3208 -> 1569;
3208 -> 1567;
3209 -> 1565;
3209 -> 1599;
3209 -> 1668;
3209 -> 3208;
3209 -> 1677;
3209 -> 1593;
3209 -> 1594;
3209 -> 3194;
3209 -> 1601;
3209 -> 1598;
3210 -> 1613;
3211 -> 3210;
3211 -> 1434;
3212 -> 3211;
3212 -> 1436;
3212 -> 1434;
3213 -> 1632;
3214 -> 3213;
3214 -> 1472;
3215 -> 3214;
3215 -> 1474;
3215 -> 1472;
3216 -> 1470;
3216 -> 1502;
3216 -> 1628;
3216 -> 3215;
3216 -> 1637;
3216 -> 1498;
3216 -> 1499;
3216 -> 3201;
3216 -> 1509;
3216 -> 1501;
3217 -> 1652;
3218 -> 3217;
3218 -> 1521;
3219 -> 3218;
3219 -> 1523;
3219 -> 1521;
3220 -> 1519;
3220 -> 1553;
3220 -> 1648;
3220 -> 3219;
3220 -> 1657;
3220 -> 1547;
3220 -> 1548;
3220 -> 3205;
3220 -> 1555;
3220 -> 1552;
3221 -> 1672;
3222 -> 3221;
3222 -> 1567;
3223 -> 3222;
3223 -> 1569;
3223 -> 1567;
3224 -> 1565;
3224 -> 1599;
3224 -> 1668;
3224 -> 3223;
3224 -> 1677;
3224 -> 1593;
3224 -> 1594;
3224 -> 3209;
3224 -> 1601;
3224 -> 1598;
3225 -> 1613;
3226 -> 3225;
3226 -> 1434;
3227 -> 3226;
3227 -> 1436;
3227 -> 1434;
3228 -> 1632;
3229 -> 3228;
3229 -> 1472;
3230 -> 3229;
3230 -> 1474;
3230 -> 1472;
3231 -> 1470;
3231 -> 1502;
3231 -> 1628;
3231 -> 3230;
3231 -> 1637;
3231 -> 1498;
3231 -> 1499;
3231 -> 3216;
3231 -> 1509;
3231 -> 1501;
3232 -> 1652;
3233 -> 3232;
3233 -> 1521;
3234 -> 3233;
3234 -> 1523;
3234 -> 1521;
3235 -> 1519;
3235 -> 1553;
3235 -> 1648;
3235 -> 3234;
3235 -> 1657;
3235 -> 1547;
3235 -> 1548;
3235 -> 3220;
3235 -> 1555;
3235 -> 1552;
3236 -> 1672;
3237 -> 3236;
3237 -> 1567;
3238 -> 3237;
3238 -> 1569;
3238 -> 1567;
3239 -> 1565;
3239 -> 1599;
3239 -> 1668;
3239 -> 3238;
3239 -> 1677;
3239 -> 1593;
3239 -> 1594;
3239 -> 3224;
3239 -> 1601;
3239 -> 1598;
3240 -> 1613;
3241 -> 3240;
3241 -> 1434;
3242 -> 3241;
3242 -> 1436;
3242 -> 1434;
3243 -> 1632;
3244 -> 3243;
3244 -> 1472;
3245 -> 3244;
3245 -> 1474;
3245 -> 1472;
3246 -> 1470;
3246 -> 1502;
3246 -> 1628;
3246 -> 3245;
3246 -> 1637;
3246 -> 1498;
3246 -> 1499;
3246 -> 3231;
3246 -> 1509;
3246 -> 1501;
3247 -> 1652;
3248 -> 3247;
3248 -> 1521;
3249 -> 3248;
3249 -> 1523;
3249 -> 1521;
3250 -> 1519;
3250 -> 1553;
3250 -> 1648;
3250 -> 3249;
3250 -> 1657;
3250 -> 1547;
3250 -> 1548;
3250 -> 3235;
3250 -> 1555;
3250 -> 1552;
3251 -> 1672;
3252 -> 3251;
3252 -> 1567;
3253 -> 3252;
3253 -> 1569;
3253 -> 1567;
3254 -> 1565;
3254 -> 1599;
3254 -> 1668;
3254 -> 3253;
3254 -> 1677;
3254 -> 1593;
3254 -> 1594;
3254 -> 3239;
3254 -> 1601;
3254 -> 1598;
3255 -> 1613;
3256 -> 3255;
3256 -> 1434;
3257 -> 3256;
3257 -> 1436;
3257 -> 1434;
3258 -> 1632;
3259 -> 3258;
3259 -> 1472;
3260 -> 3259;
3260 -> 1474;
3260 -> 1472;
3261 -> 1470;
3261 -> 1502;
3261 -> 1628;
3261 -> 3260;
3261 -> 1637;
3261 -> 1498;
3261 -> 1499;
3261 -> 3246;
3261 -> 1509;
3261 -> 1501;
3262 -> 1652;
3263 -> 3262;
3263 -> 1521;
3264 -> 3263;
3264 -> 1523;
3264 -> 1521;
3265 -> 1519;
3265 -> 1553;
3265 -> 1648;
3265 -> 3264;
3265 -> 1657;
3265 -> 1547;
3265 -> 1548;
3265 -> 3250;
3265 -> 1555;
3265 -> 1552;
3266 -> 1672;
3267 -> 3266;
3267 -> 1567;
3268 -> 3267;
3268 -> 1569;
3268 -> 1567;
3269 -> 1565;
3269 -> 1599;
3269 -> 1668;
3269 -> 3268;
3269 -> 1677;
3269 -> 1593;
3269 -> 1594;
3269 -> 3254;
3269 -> 1601;
3269 -> 1598;
3270 -> 1613;
3271 -> 3270;
3271 -> 1434;
3272 -> 3271;
3272 -> 1436;
3272 -> 1434;
3273 -> 1632;
3274 -> 3273;
3274 -> 1472;
3275 -> 3274;
3275 -> 1474;
3275 -> 1472;
3276 -> 1470;
3276 -> 1502;
3276 -> 1628;
3276 -> 3275;
3276 -> 1637;
3276 -> 1498;
3276 -> 1499;
3276 -> 3261;
3276 -> 1509;
3276 -> 1501;
3277 -> 1652;
3278 -> 3277;
3278 -> 1521;
3279 -> 3278;
3279 -> 1523;
3279 -> 1521;
3280 -> 1519;
3280 -> 1553;
3280 -> 1648;
3280 -> 3279;
3280 -> 1657;
3280 -> 1547;
3280 -> 1548;
3280 -> 3265;
3280 -> 1555;
3280 -> 1552;
3281 -> 1672;
3282 -> 3281;
3282 -> 1567;
3283 -> 3282;
3283 -> 1569;
3283 -> 1567;
3284 -> 1565;
3284 -> 1599;
3284 -> 1668;
3284 -> 3283;
3284 -> 1677;
3284 -> 1593;
3284 -> 1594;
3284 -> 3269;
3284 -> 1601;
3284 -> 1598;
3285 -> 1613;
3286 -> 3285;
3286 -> 1434;
3287 -> 3286;
3287 -> 1436;
3287 -> 1434;
3288 -> 1632;
3289 -> 3288;
3289 -> 1472;
3290 -> 3289;
3290 -> 1474;
3290 -> 1472;
3291 -> 1470;
3291 -> 1502;
3291 -> 1628;
3291 -> 3290;
3291 -> 1637;
3291 -> 1498;
3291 -> 1499;
3291 -> 3276;
3291 -> 1509;
3291 -> 1501;
3292 -> 1652;
3293 -> 3292;
3293 -> 1521;
3294 -> 3293;
3294 -> 1523;
3294 -> 1521;
3295 -> 1519;
3295 -> 1553;
3295 -> 1648;
3295 -> 3294;
3295 -> 1657;
3295 -> 1547;
3295 -> 1548;
3295 -> 3280;
3295 -> 1555;
3295 -> 1552;
3296 -> 1672;
3297 -> 3296;
3297 -> 1567;
3298 -> 3297;
3298 -> 1569;
3298 -> 1567;
3299 -> 1565;
3299 -> 1599;
3299 -> 1668;
3299 -> 3298;
3299 -> 1677;
3299 -> 1593;
3299 -> 1594;
3299 -> 3284;
3299 -> 1601;
3299 -> 1598;
3300 -> 1613;
3301 -> 3300;
3301 -> 1434;
3302 -> 3301;
3302 -> 1436;
3302 -> 1434;
3303 -> 1632;
3304 -> 3303;
3304 -> 1472;
3305 -> 3304;
3305 -> 1474;
3305 -> 1472;
3306 -> 1470;
3306 -> 1502;
3306 -> 1628;
3306 -> 3305;
3306 -> 1637;
3306 -> 1498;
3306 -> 1499;
3306 -> 3291;
3306 -> 1509;
3306 -> 1501;
3307 -> 1652;
3308 -> 3307;
3308 -> 1521;
3309 -> 3308;
3309 -> 1523;
3309 -> 1521;
3310 -> 1519;
3310 -> 1553;
3310 -> 1648;
3310 -> 3309;
3310 -> 1657;
3310 -> 1547;
3310 -> 1548;
3310 -> 3295;
3310 -> 1555;
3310 -> 1552;
3311 -> 1672;
3312 -> 3311;
3312 -> 1567;
3313 -> 3312;
3313 -> 1569;
3313 -> 1567;
3314 -> 1565;
3314 -> 1599;
3314 -> 1668;
3314 -> 3313;
3314 -> 1677;
3314 -> 1593;
3314 -> 1594;
3314 -> 3299;
3314 -> 1601;
3314 -> 1598;
3315 -> 1613;
3316 -> 3315;
3316 -> 1434;
3317 -> 3316;
3317 -> 1436;
3317 -> 1434;
3318 -> 1632;
3319 -> 3318;
3319 -> 1472;
3320 -> 3319;
3320 -> 1474;
3320 -> 1472;
3321 -> 1470;
3321 -> 1502;
3321 -> 1628;
3321 -> 3320;
3321 -> 1637;
3321 -> 1498;
3321 -> 1499;
3321 -> 3306;
3321 -> 1509;
3321 -> 1501;
3322 -> 1652;
3323 -> 3322;
3323 -> 1521;
3324 -> 3323;
3324 -> 1523;
3324 -> 1521;
3325 -> 1519;
3325 -> 1553;
3325 -> 1648;
3325 -> 3324;
3325 -> 1657;
3325 -> 1547;
3325 -> 1548;
3325 -> 3310;
3325 -> 1555;
3325 -> 1552;
3326 -> 1672;
3327 -> 3326;
3327 -> 1567;
3328 -> 3327;
3328 -> 1569;
3328 -> 1567;
3329 -> 1565;
3329 -> 1599;
3329 -> 1668;
3329 -> 3328;
3329 -> 1677;
3329 -> 1593;
3329 -> 1594;
3329 -> 3314;
3329 -> 1601;
3329 -> 1598;
3330 -> 1613;
3331 -> 3330;
3331 -> 1434;
3332 -> 3331;
3332 -> 1436;
3332 -> 1434;
3333 -> 1632;
3334 -> 3333;
3334 -> 1472;
3335 -> 3334;
3335 -> 1474;
3335 -> 1472;
3336 -> 1470;
3336 -> 1502;
3336 -> 1628;
3336 -> 3335;
3336 -> 1637;
3336 -> 1498;
3336 -> 1499;
3336 -> 3321;
3336 -> 1509;
3336 -> 1501;
3337 -> 1652;
3338 -> 3337;
3338 -> 1521;
3339 -> 3338;
3339 -> 1523;
3339 -> 1521;
3340 -> 1519;
3340 -> 1553;
3340 -> 1648;
3340 -> 3339;
3340 -> 1657;
3340 -> 1547;
3340 -> 1548;
3340 -> 3325;
3340 -> 1555;
3340 -> 1552;
3341 -> 1672;
3342 -> 3341;
3342 -> 1567;
3343 -> 3342;
3343 -> 1569;
3343 -> 1567;
3344 -> 1565;
3344 -> 1599;
3344 -> 1668;
3344 -> 3343;
3344 -> 1677;
3344 -> 1593;
3344 -> 1594;
3344 -> 3329;
3344 -> 1601;
3344 -> 1598;
3345 -> 1613;
3346 -> 3345;
3346 -> 1434;
3347 -> 3346;
3347 -> 1436;
3347 -> 1434;
3348 -> 1632;
3349 -> 3348;
3349 -> 1472;
3350 -> 3349;
3350 -> 1474;
3350 -> 1472;
3351 -> 1470;
3351 -> 1502;
3351 -> 1628;
3351 -> 3350;
3351 -> 1637;
3351 -> 1498;
3351 -> 1499;
3351 -> 3336;
3351 -> 1509;
3351 -> 1501;
3352 -> 1652;
3353 -> 3352;
3353 -> 1521;
3354 -> 3353;
3354 -> 1523;
3354 -> 1521;
3355 -> 1519;
3355 -> 1553;
3355 -> 1648;
3355 -> 3354;
3355 -> 1657;
3355 -> 1547;
3355 -> 1548;
3355 -> 3340;
3355 -> 1555;
3355 -> 1552;
3356 -> 1672;
3357 -> 3356;
3357 -> 1567;
3358 -> 3357;
3358 -> 1569;
3358 -> 1567;
3359 -> 1565;
3359 -> 1599;
3359 -> 1668;
3359 -> 3358;
3359 -> 1677;
3359 -> 1593;
3359 -> 1594;
3359 -> 3344;
3359 -> 1601;
3359 -> 1598;
3360 -> 1613;
3361 -> 3360;
3361 -> 1434;
3362 -> 3361;
3362 -> 1436;
3362 -> 1434;
3363 -> 1632;
3364 -> 3363;
3364 -> 1472;
3365 -> 3364;
3365 -> 1474;
3365 -> 1472;
3366 -> 1470;
3366 -> 1502;
3366 -> 1628;
3366 -> 3365;
3366 -> 1637;
3366 -> 1498;
3366 -> 1499;
3366 -> 3351;
3366 -> 1509;
3366 -> 1501;
3367 -> 1652;
3368 -> 3367;
3368 -> 1521;
3369 -> 3368;
3369 -> 1523;
3369 -> 1521;
3370 -> 1519;
3370 -> 1553;
3370 -> 1648;
3370 -> 3369;
3370 -> 1657;
3370 -> 1547;
3370 -> 1548;
3370 -> 3355;
3370 -> 1555;
3370 -> 1552;
3371 -> 1672;
3372 -> 3371;
3372 -> 1567;
3373 -> 3372;
3373 -> 1569;
3373 -> 1567;
3374 -> 1565;
3374 -> 1599;
3374 -> 1668;
3374 -> 3373;
3374 -> 1677;
3374 -> 1593;
3374 -> 1594;
3374 -> 3359;
3374 -> 1601;
3374 -> 1598;
3375 -> 1613;
3376 -> 3375;
3376 -> 1434;
3377 -> 3376;
3377 -> 1436;
3377 -> 1434;
3378 -> 1632;
3379 -> 3378;
3379 -> 1472;
3380 -> 3379;
3380 -> 1474;
3380 -> 1472;
3381 -> 1470;
3381 -> 1502;
3381 -> 1628;
3381 -> 3380;
3381 -> 1637;
3381 -> 1498;
3381 -> 1499;
3381 -> 3366;
3381 -> 1509;
3381 -> 1501;
3382 -> 1652;
3383 -> 3382;
3383 -> 1521;
3384 -> 3383;
3384 -> 1523;
3384 -> 1521;
3385 -> 1519;
3385 -> 1553;
3385 -> 1648;
3385 -> 3384;
3385 -> 1657;
3385 -> 1547;
3385 -> 1548;
3385 -> 3370;
3385 -> 1555;
3385 -> 1552;
3386 -> 1672;
3387 -> 3386;
3387 -> 1567;
3388 -> 3387;
3388 -> 1569;
3388 -> 1567;
3389 -> 1565;
3389 -> 1599;
3389 -> 1668;
3389 -> 3388;
3389 -> 1677;
3389 -> 1593;
3389 -> 1594;
3389 -> 3374;
3389 -> 1601;
3389 -> 1598;
3390 -> 1613;
3391 -> 3390;
3391 -> 1434;
3392 -> 3391;
3392 -> 1436;
3392 -> 1434;
3393 -> 1632;
3394 -> 3393;
3394 -> 1472;
3395 -> 3394;
3395 -> 1474;
3395 -> 1472;
3396 -> 1470;
3396 -> 1502;
3396 -> 1628;
3396 -> 3395;
3396 -> 1637;
3396 -> 1498;
3396 -> 1499;
3396 -> 3381;
3396 -> 1509;
3396 -> 1501;
3397 -> 1652;
3398 -> 3397;
3398 -> 1521;
3399 -> 3398;
3399 -> 1523;
3399 -> 1521;
3400 -> 1519;
3400 -> 1553;
3400 -> 1648;
3400 -> 3399;
3400 -> 1657;
3400 -> 1547;
3400 -> 1548;
3400 -> 3385;
3400 -> 1555;
3400 -> 1552;
3401 -> 1672;
3402 -> 3401;
3402 -> 1567;
3403 -> 3402;
3403 -> 1569;
3403 -> 1567;
3404 -> 1565;
3404 -> 1599;
3404 -> 1668;
3404 -> 3403;
3404 -> 1677;
3404 -> 1593;
3404 -> 1594;
3404 -> 3389;
3404 -> 1601;
3404 -> 1598;
3405 -> 1613;
3406 -> 3405;
3406 -> 1434;
3407 -> 3406;
3407 -> 1436;
3407 -> 1434;
3408 -> 1632;
3409 -> 3408;
3409 -> 1472;
3410 -> 3409;
3410 -> 1474;
3410 -> 1472;
3411 -> 1470;
3411 -> 1502;
3411 -> 1628;
3411 -> 3410;
3411 -> 1637;
3411 -> 1498;
3411 -> 1499;
3411 -> 3396;
3411 -> 1509;
3411 -> 1501;
3412 -> 1652;
3413 -> 3412;
3413 -> 1521;
3414 -> 3413;
3414 -> 1523;
3414 -> 1521;
3415 -> 1519;
3415 -> 1553;
3415 -> 1648;
3415 -> 3414;
3415 -> 1657;
3415 -> 1547;
3415 -> 1548;
3415 -> 3400;
3415 -> 1555;
3415 -> 1552;
3416 -> 1672;
3417 -> 3416;
3417 -> 1567;
3418 -> 3417;
3418 -> 1569;
3418 -> 1567;
3419 -> 1565;
3419 -> 1599;
3419 -> 1668;
3419 -> 3418;
3419 -> 1677;
3419 -> 1593;
3419 -> 1594;
3419 -> 3404;
3419 -> 1601;
3419 -> 1598;
3420 -> 1613;
3421 -> 3420;
3421 -> 1434;
3422 -> 3421;
3422 -> 1436;
3422 -> 1434;
3423 -> 1632;
3424 -> 3423;
3424 -> 1472;
3425 -> 3424;
3425 -> 1474;
3425 -> 1472;
3426 -> 1470;
3426 -> 1502;
3426 -> 1628;
3426 -> 3425;
3426 -> 1637;
3426 -> 1498;
3426 -> 1499;
3426 -> 3411;
3426 -> 1509;
3426 -> 1501;
3427 -> 1652;
3428 -> 3427;
3428 -> 1521;
3429 -> 3428;
3429 -> 1523;
3429 -> 1521;
3430 -> 1519;
3430 -> 1553;
3430 -> 1648;
3430 -> 3429;
3430 -> 1657;
3430 -> 1547;
3430 -> 1548;
3430 -> 3415;
3430 -> 1555;
3430 -> 1552;
3431 -> 1672;
3432 -> 3431;
3432 -> 1567;
3433 -> 3432;
3433 -> 1569;
3433 -> 1567;
3434 -> 1565;
3434 -> 1599;
3434 -> 1668;
3434 -> 3433;
3434 -> 1677;
3434 -> 1593;
3434 -> 1594;
3434 -> 3419;
3434 -> 1601;
3434 -> 1598;
3435 -> 1613;
3436 -> 3435;
3436 -> 1434;
3437 -> 3436;
3437 -> 1436;
3437 -> 1434;
3438 -> 1632;
3439 -> 3438;
3439 -> 1472;
3440 -> 3439;
3440 -> 1474;
3440 -> 1472;
3441 -> 1470;
3441 -> 1502;
3441 -> 1628;
3441 -> 3440;
3441 -> 1637;
3441 -> 1498;
3441 -> 1499;
3441 -> 3426;
3441 -> 1509;
3441 -> 1501;
3442 -> 1652;
3443 -> 3442;
3443 -> 1521;
3444 -> 3443;
3444 -> 1523;
3444 -> 1521;
3445 -> 1519;
3445 -> 1553;
3445 -> 1648;
3445 -> 3444;
3445 -> 1657;
3445 -> 1547;
3445 -> 1548;
3445 -> 3430;
3445 -> 1555;
3445 -> 1552;
3446 -> 1672;
3447 -> 3446;
3447 -> 1567;
3448 -> 3447;
3448 -> 1569;
3448 -> 1567;
3449 -> 1565;
3449 -> 1599;
3449 -> 1668;
3449 -> 3448;
3449 -> 1677;
3449 -> 1593;
3449 -> 1594;
3449 -> 3434;
3449 -> 1601;
3449 -> 1598;
3450 -> 1613;
3451 -> 3450;
3451 -> 1434;
3452 -> 3451;
3452 -> 1436;
3452 -> 1434;
3453 -> 1632;
3454 -> 3453;
3454 -> 1472;
3455 -> 3454;
3455 -> 1474;
3455 -> 1472;
3456 -> 1470;
3456 -> 1502;
3456 -> 1628;
3456 -> 3455;
3456 -> 1637;
3456 -> 1498;
3456 -> 1499;
3456 -> 3441;
3456 -> 1509;
3456 -> 1501;
3457 -> 1652;
3458 -> 3457;
3458 -> 1521;
3459 -> 3458;
3459 -> 1523;
3459 -> 1521;
3460 -> 1519;
3460 -> 1553;
3460 -> 1648;
3460 -> 3459;
3460 -> 1657;
3460 -> 1547;
3460 -> 1548;
3460 -> 3445;
3460 -> 1555;
3460 -> 1552;
3461 -> 1672;
3462 -> 3461;
3462 -> 1567;
3463 -> 3462;
3463 -> 1569;
3463 -> 1567;
3464 -> 1565;
3464 -> 1599;
3464 -> 1668;
3464 -> 3463;
3464 -> 1677;
3464 -> 1593;
3464 -> 1594;
3464 -> 3449;
3464 -> 1601;
3464 -> 1598;
3465 -> 1613;
3466 -> 3465;
3466 -> 1434;
3467 -> 3466;
3467 -> 1436;
3467 -> 1434;
3468 -> 1632;
3469 -> 3468;
3469 -> 1472;
3470 -> 3469;
3470 -> 1474;
3470 -> 1472;
3471 -> 1470;
3471 -> 1502;
3471 -> 1628;
3471 -> 3470;
3471 -> 1637;
3471 -> 1498;
3471 -> 1499;
3471 -> 3456;
3471 -> 1509;
3471 -> 1501;
3472 -> 1652;
3473 -> 3472;
3473 -> 1521;
3474 -> 3473;
3474 -> 1523;
3474 -> 1521;
3475 -> 1519;
3475 -> 1553;
3475 -> 1648;
3475 -> 3474;
3475 -> 1657;
3475 -> 1547;
3475 -> 1548;
3475 -> 3460;
3475 -> 1555;
3475 -> 1552;
3476 -> 1672;
3477 -> 3476;
3477 -> 1567;
3478 -> 3477;
3478 -> 1569;
3478 -> 1567;
3479 -> 1565;
3479 -> 1599;
3479 -> 1668;
3479 -> 3478;
3479 -> 1677;
3479 -> 1593;
3479 -> 1594;
3479 -> 3464;
3479 -> 1601;
3479 -> 1598;
3480 -> 1613;
3481 -> 3480;
3481 -> 1434;
3482 -> 3481;
3482 -> 1436;
3482 -> 1434;
3483 -> 1632;
3484 -> 3483;
3484 -> 1472;
3485 -> 3484;
3485 -> 1474;
3485 -> 1472;
3486 -> 1470;
3486 -> 1502;
3486 -> 1628;
3486 -> 3485;
3486 -> 1637;
3486 -> 1498;
3486 -> 1499;
3486 -> 3471;
3486 -> 1509;
3486 -> 1501;
3487 -> 1652;
3488 -> 3487;
3488 -> 1521;
3489 -> 3488;
3489 -> 1523;
3489 -> 1521;
3490 -> 1519;
3490 -> 1553;
3490 -> 1648;
3490 -> 3489;
3490 -> 1657;
3490 -> 1547;
3490 -> 1548;
3490 -> 3475;
3490 -> 1555;
3490 -> 1552;
3491 -> 1672;
3492 -> 3491;
3492 -> 1567;
3493 -> 3492;
3493 -> 1569;
3493 -> 1567;
3494 -> 1565;
3494 -> 1599;
3494 -> 1668;
3494 -> 3493;
3494 -> 1677;
3494 -> 1593;
3494 -> 1594;
3494 -> 3479;
3494 -> 1601;
3494 -> 1598;
3495 -> 1613;
3496 -> 3495;
3496 -> 1434;
3497 -> 3496;
3497 -> 1436;
3497 -> 1434;
3498 -> 1632;
3499 -> 3498;
3499 -> 1472;
3500 -> 3499;
3500 -> 1474;
3500 -> 1472;
3501 -> 1470;
3501 -> 1502;
3501 -> 1628;
3501 -> 3500;
3501 -> 1637;
3501 -> 1498;
3501 -> 1499;
3501 -> 3486;
3501 -> 1509;
3501 -> 1501;
3502 -> 1652;
3503 -> 3502;
3503 -> 1521;
3504 -> 3503;
3504 -> 1523;
3504 -> 1521;
3505 -> 1519;
3505 -> 1553;
3505 -> 1648;
3505 -> 3504;
3505 -> 1657;
3505 -> 1547;
3505 -> 1548;
3505 -> 3490;
3505 -> 1555;
3505 -> 1552;
3506 -> 1672;
3507 -> 3506;
3507 -> 1567;
3508 -> 3507;
3508 -> 1569;
3508 -> 1567;
3509 -> 1565;
3509 -> 1599;
3509 -> 1668;
3509 -> 3508;
3509 -> 1677;
3509 -> 1593;
3509 -> 1594;
3509 -> 3494;
3509 -> 1601;
3509 -> 1598;
3510 -> 1613;
3511 -> 3510;
3511 -> 1434;
3512 -> 3511;
3512 -> 1436;
3512 -> 1434;
3513 -> 1632;
3514 -> 3513;
3514 -> 1472;
3515 -> 3514;
3515 -> 1474;
3515 -> 1472;
3516 -> 1470;
3516 -> 1502;
3516 -> 1628;
3516 -> 3515;
3516 -> 1637;
3516 -> 1498;
3516 -> 1499;
3516 -> 3501;
3516 -> 1509;
3516 -> 1501;
3517 -> 1652;
3518 -> 3517;
3518 -> 1521;
3519 -> 3518;
3519 -> 1523;
3519 -> 1521;
3520 -> 1519;
3520 -> 1553;
3520 -> 1648;
3520 -> 3519;
3520 -> 1657;
3520 -> 1547;
3520 -> 1548;
3520 -> 3505;
3520 -> 1555;
3520 -> 1552;
3521 -> 1672;
3522 -> 3521;
3522 -> 1567;
3523 -> 3522;
3523 -> 1569;
3523 -> 1567;
3524 -> 1565;
3524 -> 1599;
3524 -> 1668;
3524 -> 3523;
3524 -> 1677;
3524 -> 1593;
3524 -> 1594;
3524 -> 3509;
3524 -> 1601;
3524 -> 1598;
3525 -> 1613;
3526 -> 3525;
3526 -> 1434;
3527 -> 3526;
3527 -> 1436;
3527 -> 1434;
3528 -> 1632;
3529 -> 3528;
3529 -> 1472;
3530 -> 3529;
3530 -> 1474;
3530 -> 1472;
3531 -> 1470;
3531 -> 1502;
3531 -> 1628;
3531 -> 3530;
3531 -> 1637;
3531 -> 1498;
3531 -> 1499;
3531 -> 3516;
3531 -> 1509;
3531 -> 1501;
3532 -> 1652;
3533 -> 3532;
3533 -> 1521;
3534 -> 3533;
3534 -> 1523;
3534 -> 1521;
3535 -> 1519;
3535 -> 1553;
3535 -> 1648;
3535 -> 3534;
3535 -> 1657;
3535 -> 1547;
3535 -> 1548;
3535 -> 3520;
3535 -> 1555;
3535 -> 1552;
3536 -> 1672;
3537 -> 3536;
3537 -> 1567;
3538 -> 3537;
3538 -> 1569;
3538 -> 1567;
3539 -> 1565;
3539 -> 1599;
3539 -> 1668;
3539 -> 3538;
3539 -> 1677;
3539 -> 1593;
3539 -> 1594;
3539 -> 3524;
3539 -> 1601;
3539 -> 1598;
3540 -> 1613;
3541 -> 3540;
3541 -> 1434;
3542 -> 3541;
3542 -> 1436;
3542 -> 1434;
3543 -> 1632;
3544 -> 3543;
3544 -> 1472;
3545 -> 3544;
3545 -> 1474;
3545 -> 1472;
3546 -> 1470;
3546 -> 1502;
3546 -> 1628;
3546 -> 3545;
3546 -> 1637;
3546 -> 1498;
3546 -> 1499;
3546 -> 3531;
3546 -> 1509;
3546 -> 1501;
3547 -> 1652;
3548 -> 3547;
3548 -> 1521;
3549 -> 3548;
3549 -> 1523;
3549 -> 1521;
3550 -> 1519;
3550 -> 1553;
3550 -> 1648;
3550 -> 3549;
3550 -> 1657;
3550 -> 1547;
3550 -> 1548;
3550 -> 3535;
3550 -> 1555;
3550 -> 1552;
3551 -> 1672;
3552 -> 3551;
3552 -> 1567;
3553 -> 3552;
3553 -> 1569;
3553 -> 1567;
3554 -> 1565;
3554 -> 1599;
3554 -> 1668;
3554 -> 3553;
3554 -> 1677;
3554 -> 1593;
3554 -> 1594;
3554 -> 3539;
3554 -> 1601;
3554 -> 1598;
3555 -> 1613;
3556 -> 3555;
3556 -> 1434;
3557 -> 3556;
3557 -> 1436;
3557 -> 1434;
3558 -> 1632;
3559 -> 3558;
3559 -> 1472;
3560 -> 3559;
3560 -> 1474;
3560 -> 1472;
3561 -> 1470;
3561 -> 1502;
3561 -> 1628;
3561 -> 3560;
3561 -> 1637;
3561 -> 1498;
3561 -> 1499;
3561 -> 3546;
3561 -> 1509;
3561 -> 1501;
3562 -> 1652;
3563 -> 3562;
3563 -> 1521;
3564 -> 3563;
3564 -> 1523;
3564 -> 1521;
3565 -> 1519;
3565 -> 1553;
3565 -> 1648;
3565 -> 3564;
3565 -> 1657;
3565 -> 1547;
3565 -> 1548;
3565 -> 3550;
3565 -> 1555;
3565 -> 1552;
3566 -> 1672;
3567 -> 3566;
3567 -> 1567;
3568 -> 3567;
3568 -> 1569;
3568 -> 1567;
3569 -> 1565;
3569 -> 1599;
3569 -> 1668;
3569 -> 3568;
3569 -> 1677;
3569 -> 1593;
3569 -> 1594;
3569 -> 3554;
3569 -> 1601;
3569 -> 1598;
3570 -> 1613;
3571 -> 3570;
3571 -> 1434;
3572 -> 3571;
3572 -> 1436;
3572 -> 1434;
3573 -> 1632;
3574 -> 3573;
3574 -> 1472;
3575 -> 3574;
3575 -> 1474;
3575 -> 1472;
3576 -> 1470;
3576 -> 1502;
3576 -> 1628;
3576 -> 3575;
3576 -> 1637;
3576 -> 1498;
3576 -> 1499;
3576 -> 3561;
3576 -> 1509;
3576 -> 1501;
3577 -> 1652;
3578 -> 3577;
3578 -> 1521;
3579 -> 3578;
3579 -> 1523;
3579 -> 1521;
3580 -> 1519;
3580 -> 1553;
3580 -> 1648;
3580 -> 3579;
3580 -> 1657;
3580 -> 1547;
3580 -> 1548;
3580 -> 3565;
3580 -> 1555;
3580 -> 1552;
3581 -> 1672;
3582 -> 3581;
3582 -> 1567;
3583 -> 3582;
3583 -> 1569;
3583 -> 1567;
3584 -> 1565;
3584 -> 1599;
3584 -> 1668;
3584 -> 3583;
3584 -> 1677;
3584 -> 1593;
3584 -> 1594;
3584 -> 3569;
3584 -> 1601;
3584 -> 1598;
3585 -> 1613;
3586 -> 3585;
3586 -> 1434;
3587 -> 3586;
3587 -> 1436;
3587 -> 1434;
3588 -> 1632;
3589 -> 3588;
3589 -> 1472;
3590 -> 3589;
3590 -> 1474;
3590 -> 1472;
3591 -> 1470;
3591 -> 1502;
3591 -> 1628;
3591 -> 3590;
3591 -> 1637;
3591 -> 1498;
3591 -> 1499;
3591 -> 3576;
3591 -> 1509;
3591 -> 1501;
3592 -> 1652;
3593 -> 3592;
3593 -> 1521;
3594 -> 3593;
3594 -> 1523;
3594 -> 1521;
3595 -> 1519;
3595 -> 1553;
3595 -> 1648;
3595 -> 3594;
3595 -> 1657;
3595 -> 1547;
3595 -> 1548;
3595 -> 3580;
3595 -> 1555;
3595 -> 1552;
3596 -> 1672;
3597 -> 3596;
3597 -> 1567;
3598 -> 3597;
3598 -> 1569;
3598 -> 1567;
3599 -> 1565;
3599 -> 1599;
3599 -> 1668;
3599 -> 3598;
3599 -> 1677;
3599 -> 1593;
3599 -> 1594;
3599 -> 3584;
3599 -> 1601;
3599 -> 1598;
3600 -> 1613;
3601 -> 3600;
3601 -> 1434;
3602 -> 3601;
3602 -> 1436;
3602 -> 1434;
3603 -> 1632;
3604 -> 3603;
3604 -> 1472;
3605 -> 3604;
3605 -> 1474;
3605 -> 1472;
3606 -> 1470;
3606 -> 1502;
3606 -> 1628;
3606 -> 3605;
3606 -> 1637;
3606 -> 1498;
3606 -> 1499;
3606 -> 3591;
3606 -> 1509;
3606 -> 1501;
3607 -> 1652;
3608 -> 3607;
3608 -> 1521;
3609 -> 3608;
3609 -> 1523;
3609 -> 1521;
3610 -> 1519;
3610 -> 1553;
3610 -> 1648;
3610 -> 3609;
3610 -> 1657;
3610 -> 1547;
3610 -> 1548;
3610 -> 3595;
3610 -> 1555;
3610 -> 1552;
3611 -> 1672;
3612 -> 3611;
3612 -> 1567;
3613 -> 3612;
3613 -> 1569;
3613 -> 1567;
3614 -> 1565;
3614 -> 1599;
3614 -> 1668;
3614 -> 3613;
3614 -> 1677;
3614 -> 1593;
3614 -> 1594;
3614 -> 3599;
3614 -> 1601;
3614 -> 1598;
3615 -> 1613;
3616 -> 3615;
3616 -> 1434;
3617 -> 3616;
3617 -> 1436;
3617 -> 1434;
3618 -> 1632;
3619 -> 3618;
3619 -> 1472;
3620 -> 3619;
3620 -> 1474;
3620 -> 1472;
3621 -> 1470;
3621 -> 1502;
3621 -> 1628;
3621 -> 3620;
3621 -> 1637;
3621 -> 1498;
3621 -> 1499;
3621 -> 3606;
3621 -> 1509;
3621 -> 1501;
3622 -> 1652;
3623 -> 3622;
3623 -> 1521;
3624 -> 3623;
3624 -> 1523;
3624 -> 1521;
3625 -> 1519;
3625 -> 1553;
3625 -> 1648;
3625 -> 3624;
3625 -> 1657;
3625 -> 1547;
3625 -> 1548;
3625 -> 3610;
3625 -> 1555;
3625 -> 1552;
3626 -> 1672;
3627 -> 3626;
3627 -> 1567;
3628 -> 3627;
3628 -> 1569;
3628 -> 1567;
3629 -> 1565;
3629 -> 1599;
3629 -> 1668;
3629 -> 3628;
3629 -> 1677;
3629 -> 1593;
3629 -> 1594;
3629 -> 3614;
3629 -> 1601;
3629 -> 1598;
3630 -> 1613;
3631 -> 3630;
3631 -> 1434;
3632 -> 3631;
3632 -> 1436;
3632 -> 1434;
3633 -> 1632;
3634 -> 3633;
3634 -> 1472;
3635 -> 3634;
3635 -> 1474;
3635 -> 1472;
3636 -> 1470;
3636 -> 1502;
3636 -> 1628;
3636 -> 3635;
3636 -> 1637;
3636 -> 1498;
3636 -> 1499;
3636 -> 3621;
3636 -> 1509;
3636 -> 1501;
3637 -> 1652;
3638 -> 3637;
3638 -> 1521;
3639 -> 3638;
3639 -> 1523;
3639 -> 1521;
3640 -> 1519;
3640 -> 1553;
3640 -> 1648;
3640 -> 3639;
3640 -> 1657;
3640 -> 1547;
3640 -> 1548;
3640 -> 3625;
3640 -> 1555;
3640 -> 1552;
3641 -> 1672;
3642 -> 3641;
3642 -> 1567;
3643 -> 3642;
3643 -> 1569;
3643 -> 1567;
3644 -> 1565;
3644 -> 1599;
3644 -> 1668;
3644 -> 3643;
3644 -> 1677;
3644 -> 1593;
3644 -> 1594;
3644 -> 3629;
3644 -> 1601;
3644 -> 1598;
3645 -> 1613;
3646 -> 3645;
3646 -> 1434;
3647 -> 3646;
3647 -> 1436;
3647 -> 1434;
3648 -> 1632;
3649 -> 3648;
3649 -> 1472;
3650 -> 3649;
3650 -> 1474;
3650 -> 1472;
3651 -> 1470;
3651 -> 1502;
3651 -> 1628;
3651 -> 3650;
3651 -> 1637;
3651 -> 1498;
3651 -> 1499;
3651 -> 3636;
3651 -> 1509;
3651 -> 1501;
3652 -> 1652;
3653 -> 3652;
3653 -> 1521;
3654 -> 3653;
3654 -> 1523;
3654 -> 1521;
3655 -> 1519;
3655 -> 1553;
3655 -> 1648;
3655 -> 3654;
3655 -> 1657;
3655 -> 1547;
3655 -> 1548;
3655 -> 3640;
3655 -> 1555;
3655 -> 1552;
3656 -> 1672;
3657 -> 3656;
3657 -> 1567;
3658 -> 3657;
3658 -> 1569;
3658 -> 1567;
3659 -> 1565;
3659 -> 1599;
3659 -> 1668;
3659 -> 3658;
3659 -> 1677;
3659 -> 1593;
3659 -> 1594;
3659 -> 3644;
3659 -> 1601;
3659 -> 1598;
3660 -> 1613;
3661 -> 3660;
3661 -> 1434;
3662 -> 3661;
3662 -> 1436;
3662 -> 1434;
3663 -> 1632;
3664 -> 3663;
3664 -> 1472;
3665 -> 3664;
3665 -> 1474;
3665 -> 1472;
3666 -> 1470;
3666 -> 1502;
3666 -> 1628;
3666 -> 3665;
3666 -> 1637;
3666 -> 1498;
3666 -> 1499;
3666 -> 3651;
3666 -> 1509;
3666 -> 1501;
3667 -> 1652;
3668 -> 3667;
3668 -> 1521;
3669 -> 3668;
3669 -> 1523;
3669 -> 1521;
3670 -> 1519;
3670 -> 1553;
3670 -> 1648;
3670 -> 3669;
3670 -> 1657;
3670 -> 1547;
3670 -> 1548;
3670 -> 3655;
3670 -> 1555;
3670 -> 1552;
3671 -> 1672;
3672 -> 3671;
3672 -> 1567;
3673 -> 3672;
3673 -> 1569;
3673 -> 1567;
3674 -> 1565;
3674 -> 1599;
3674 -> 1668;
3674 -> 3673;
3674 -> 1677;
3674 -> 1593;
3674 -> 1594;
3674 -> 3659;
3674 -> 1601;
3674 -> 1598;
3675 -> 1613;
3676 -> 3675;
3676 -> 1434;
3677 -> 3676;
3677 -> 1436;
3677 -> 1434;
3678 -> 1632;
3679 -> 3678;
3679 -> 1472;
3680 -> 3679;
3680 -> 1474;
3680 -> 1472;
3681 -> 1470;
3681 -> 1502;
3681 -> 1628;
3681 -> 3680;
3681 -> 1637;
3681 -> 1498;
3681 -> 1499;
3681 -> 3666;
3681 -> 1509;
3681 -> 1501;
3682 -> 1652;
3683 -> 3682;
3683 -> 1521;
3684 -> 3683;
3684 -> 1523;
3684 -> 1521;
3685 -> 1519;
3685 -> 1553;
3685 -> 1648;
3685 -> 3684;
3685 -> 1657;
3685 -> 1547;
3685 -> 1548;
3685 -> 3670;
3685 -> 1555;
3685 -> 1552;
3686 -> 1672;
3687 -> 3686;
3687 -> 1567;
3688 -> 3687;
3688 -> 1569;
3688 -> 1567;
3689 -> 1565;
3689 -> 1599;
3689 -> 1668;
3689 -> 3688;
3689 -> 1677;
3689 -> 1593;
3689 -> 1594;
3689 -> 3674;
3689 -> 1601;
3689 -> 1598;
3690 -> 1613;
3691 -> 3690;
3691 -> 1434;
3692 -> 3691;
3692 -> 1436;
3692 -> 1434;
3693 -> 1632;
3694 -> 3693;
3694 -> 1472;
3695 -> 3694;
3695 -> 1474;
3695 -> 1472;
3696 -> 1470;
3696 -> 1502;
3696 -> 1628;
3696 -> 3695;
3696 -> 1637;
3696 -> 1498;
3696 -> 1499;
3696 -> 3681;
3696 -> 1509;
3696 -> 1501;
3697 -> 1652;
3698 -> 3697;
3698 -> 1521;
3699 -> 3698;
3699 -> 1523;
3699 -> 1521;
3700 -> 1519;
3700 -> 1553;
3700 -> 1648;
3700 -> 3699;
3700 -> 1657;
3700 -> 1547;
3700 -> 1548;
3700 -> 3685;
3700 -> 1555;
3700 -> 1552;
3701 -> 1672;
3702 -> 3701;
3702 -> 1567;
3703 -> 3702;
3703 -> 1569;
3703 -> 1567;
3704 -> 1565;
3704 -> 1599;
3704 -> 1668;
3704 -> 3703;
3704 -> 1677;
3704 -> 1593;
3704 -> 1594;
3704 -> 3689;
3704 -> 1601;
3704 -> 1598;
3705 -> 1613;
3706 -> 3705;
3706 -> 1434;
3707 -> 3706;
3707 -> 1436;
3707 -> 1434;
3708 -> 1632;
3709 -> 3708;
3709 -> 1472;
3710 -> 3709;
3710 -> 1474;
3710 -> 1472;
3711 -> 1470;
3711 -> 1502;
3711 -> 1628;
3711 -> 3710;
3711 -> 1637;
3711 -> 1498;
3711 -> 1499;
3711 -> 3696;
3711 -> 1509;
3711 -> 1501;
3712 -> 1652;
3713 -> 3712;
3713 -> 1521;
3714 -> 3713;
3714 -> 1523;
3714 -> 1521;
3715 -> 1519;
3715 -> 1553;
3715 -> 1648;
3715 -> 3714;
3715 -> 1657;
3715 -> 1547;
3715 -> 1548;
3715 -> 3700;
3715 -> 1555;
3715 -> 1552;
3716 -> 1672;
3717 -> 3716;
3717 -> 1567;
3718 -> 3717;
3718 -> 1569;
3718 -> 1567;
3719 -> 1565;
3719 -> 1599;
3719 -> 1668;
3719 -> 3718;
3719 -> 1677;
3719 -> 1593;
3719 -> 1594;
3719 -> 3704;
3719 -> 1601;
3719 -> 1598;
3720 -> 1613;
3721 -> 3720;
3721 -> 1434;
3722 -> 3721;
3722 -> 1436;
3722 -> 1434;
3723 -> 1632;
3724 -> 3723;
3724 -> 1472;
3725 -> 3724;
3725 -> 1474;
3725 -> 1472;
3726 -> 1470;
3726 -> 1502;
3726 -> 1628;
3726 -> 3725;
3726 -> 1637;
3726 -> 1498;
3726 -> 1499;
3726 -> 3711;
3726 -> 1509;
3726 -> 1501;
3727 -> 1652;
3728 -> 3727;
3728 -> 1521;
3729 -> 3728;
3729 -> 1523;
3729 -> 1521;
3730 -> 1519;
3730 -> 1553;
3730 -> 1648;
3730 -> 3729;
3730 -> 1657;
3730 -> 1547;
3730 -> 1548;
3730 -> 3715;
3730 -> 1555;
3730 -> 1552;
3731 -> 1672;
3732 -> 3731;
3732 -> 1567;
3733 -> 3732;
3733 -> 1569;
3733 -> 1567;
3734 -> 1565;
3734 -> 1599;
3734 -> 1668;
3734 -> 3733;
3734 -> 1677;
3734 -> 1593;
3734 -> 1594;
3734 -> 3719;
3734 -> 1601;
3734 -> 1598;
3735 -> 1613;
3736 -> 3735;
3736 -> 1434;
3737 -> 3736;
3737 -> 1436;
3737 -> 1434;
3738 -> 1632;
3739 -> 3738;
3739 -> 1472;
3740 -> 3739;
3740 -> 1474;
3740 -> 1472;
3741 -> 1470;
3741 -> 1502;
3741 -> 1628;
3741 -> 3740;
3741 -> 1637;
3741 -> 1498;
3741 -> 1499;
3741 -> 3726;
3741 -> 1509;
3741 -> 1501;
3742 -> 1652;
3743 -> 3742;
3743 -> 1521;
3744 -> 3743;
3744 -> 1523;
3744 -> 1521;
3745 -> 1519;
3745 -> 1553;
3745 -> 1648;
3745 -> 3744;
3745 -> 1657;
3745 -> 1547;
3745 -> 1548;
3745 -> 3730;
3745 -> 1555;
3745 -> 1552;
3746 -> 1672;
3747 -> 3746;
3747 -> 1567;
3748 -> 3747;
3748 -> 1569;
3748 -> 1567;
3749 -> 1565;
3749 -> 1599;
3749 -> 1668;
3749 -> 3748;
3749 -> 1677;
3749 -> 1593;
3749 -> 1594;
3749 -> 3734;
3749 -> 1601;
3749 -> 1598;
3750 -> 1613;
3751 -> 3750;
3751 -> 1434;
3752 -> 3751;
3752 -> 1436;
3752 -> 1434;
3753 -> 1632;
3754 -> 3753;
3754 -> 1472;
3755 -> 3754;
3755 -> 1474;
3755 -> 1472;
3756 -> 1470;
3756 -> 1502;
3756 -> 1628;
3756 -> 3755;
3756 -> 1637;
3756 -> 1498;
3756 -> 1499;
3756 -> 3741;
3756 -> 1509;
3756 -> 1501;
3757 -> 1652;
3758 -> 3757;
3758 -> 1521;
3759 -> 3758;
3759 -> 1523;
3759 -> 1521;
3760 -> 1519;
3760 -> 1553;
3760 -> 1648;
3760 -> 3759;
3760 -> 1657;
3760 -> 1547;
3760 -> 1548;
3760 -> 3745;
3760 -> 1555;
3760 -> 1552;
3761 -> 1672;
3762 -> 3761;
3762 -> 1567;
3763 -> 3762;
3763 -> 1569;
3763 -> 1567;
3764 -> 1565;
3764 -> 1599;
3764 -> 1668;
3764 -> 3763;
3764 -> 1677;
3764 -> 1593;
3764 -> 1594;
3764 -> 3749;
3764 -> 1601;
3764 -> 1598;
3765 -> 1613;
3766 -> 3765;
3766 -> 1434;
3767 -> 3766;
3767 -> 1436;
3767 -> 1434;
3768 -> 1632;
3769 -> 3768;
3769 -> 1472;
3770 -> 3769;
3770 -> 1474;
3770 -> 1472;
3771 -> 1470;
3771 -> 1502;
3771 -> 1628;
3771 -> 3770;
3771 -> 1637;
3771 -> 1498;
3771 -> 1499;
3771 -> 3756;
3771 -> 1509;
3771 -> 1501;
3772 -> 1652;
3773 -> 3772;
3773 -> 1521;
3774 -> 3773;
3774 -> 1523;
3774 -> 1521;
3775 -> 1519;
3775 -> 1553;
3775 -> 1648;
3775 -> 3774;
3775 -> 1657;
3775 -> 1547;
3775 -> 1548;
3775 -> 3760;
3775 -> 1555;
3775 -> 1552;
3776 -> 1672;
3777 -> 3776;
3777 -> 1567;
3778 -> 3777;
3778 -> 1569;
3778 -> 1567;
3779 -> 1565;
3779 -> 1599;
3779 -> 1668;
3779 -> 3778;
3779 -> 1677;
3779 -> 1593;
3779 -> 1594;
3779 -> 3764;
3779 -> 1601;
3779 -> 1598;
3780 -> 1613;
3781 -> 3780;
3781 -> 1434;
3782 -> 3781;
3782 -> 1436;
3782 -> 1434;
3783 -> 1632;
3784 -> 3783;
3784 -> 1472;
3785 -> 3784;
3785 -> 1474;
3785 -> 1472;
3786 -> 1470;
3786 -> 1502;
3786 -> 1628;
3786 -> 3785;
3786 -> 1637;
3786 -> 1498;
3786 -> 1499;
3786 -> 3771;
3786 -> 1509;
3786 -> 1501;
3787 -> 1652;
3788 -> 3787;
3788 -> 1521;
3789 -> 3788;
3789 -> 1523;
3789 -> 1521;
3790 -> 1519;
3790 -> 1553;
3790 -> 1648;
3790 -> 3789;
3790 -> 1657;
3790 -> 1547;
3790 -> 1548;
3790 -> 3775;
3790 -> 1555;
3790 -> 1552;
3791 -> 1672;
3792 -> 3791;
3792 -> 1567;
3793 -> 3792;
3793 -> 1569;
3793 -> 1567;
3794 -> 1565;
3794 -> 1599;
3794 -> 1668;
3794 -> 3793;
3794 -> 1677;
3794 -> 1593;
3794 -> 1594;
3794 -> 3779;
3794 -> 1601;
3794 -> 1598;
3795 -> 1613;
3796 -> 3795;
3796 -> 1434;
3797 -> 3796;
3797 -> 1436;
3797 -> 1434;
3798 -> 1632;
3799 -> 3798;
3799 -> 1472;
3800 -> 3799;
3800 -> 1474;
3800 -> 1472;
3801 -> 1470;
3801 -> 1502;
3801 -> 1628;
3801 -> 3800;
3801 -> 1637;
3801 -> 1498;
3801 -> 1499;
3801 -> 3786;
3801 -> 1509;
3801 -> 1501;
3802 -> 1652;
3803 -> 3802;
3803 -> 1521;
3804 -> 3803;
3804 -> 1523;
3804 -> 1521;
3805 -> 1519;
3805 -> 1553;
3805 -> 1648;
3805 -> 3804;
3805 -> 1657;
3805 -> 1547;
3805 -> 1548;
3805 -> 3790;
3805 -> 1555;
3805 -> 1552;
3806 -> 1672;
3807 -> 3806;
3807 -> 1567;
3808 -> 3807;
3808 -> 1569;
3808 -> 1567;
3809 -> 1565;
3809 -> 1599;
3809 -> 1668;
3809 -> 3808;
3809 -> 1677;
3809 -> 1593;
3809 -> 1594;
3809 -> 3794;
3809 -> 1601;
3809 -> 1598;
3810 -> 1613;
3811 -> 3810;
3811 -> 1434;
3812 -> 3811;
3812 -> 1436;
3812 -> 1434;
3813 -> 1632;
3814 -> 3813;
3814 -> 1472;
3815 -> 3814;
3815 -> 1474;
3815 -> 1472;
3816 -> 1470;
3816 -> 1502;
3816 -> 1628;
3816 -> 3815;
3816 -> 1637;
3816 -> 1498;
3816 -> 1499;
3816 -> 3801;
3816 -> 1509;
3816 -> 1501;
3817 -> 1652;
3818 -> 3817;
3818 -> 1521;
3819 -> 3818;
3819 -> 1523;
3819 -> 1521;
3820 -> 1519;
3820 -> 1553;
3820 -> 1648;
3820 -> 3819;
3820 -> 1657;
3820 -> 1547;
3820 -> 1548;
3820 -> 3805;
3820 -> 1555;
3820 -> 1552;
3821 -> 1672;
3822 -> 3821;
3822 -> 1567;
3823 -> 3822;
3823 -> 1569;
3823 -> 1567;
3824 -> 1565;
3824 -> 1599;
3824 -> 1668;
3824 -> 3823;
3824 -> 1677;
3824 -> 1593;
3824 -> 1594;
3824 -> 3809;
3824 -> 1601;
3824 -> 1598;
3825 -> 1613;
3826 -> 3825;
3826 -> 1434;
3827 -> 3826;
3827 -> 1436;
3827 -> 1434;
3828 -> 1632;
3829 -> 3828;
3829 -> 1472;
3830 -> 3829;
3830 -> 1474;
3830 -> 1472;
3831 -> 1470;
3831 -> 1502;
3831 -> 1628;
3831 -> 3830;
3831 -> 1637;
3831 -> 1498;
3831 -> 1499;
3831 -> 3816;
3831 -> 1509;
3831 -> 1501;
3832 -> 1652;
3833 -> 3832;
3833 -> 1521;
3834 -> 3833;
3834 -> 1523;
3834 -> 1521;
3835 -> 1519;
3835 -> 1553;
3835 -> 1648;
3835 -> 3834;
3835 -> 1657;
3835 -> 1547;
3835 -> 1548;
3835 -> 3820;
3835 -> 1555;
3835 -> 1552;
3836 -> 1672;
3837 -> 3836;
3837 -> 1567;
3838 -> 3837;
3838 -> 1569;
3838 -> 1567;
3839 -> 1565;
3839 -> 1599;
3839 -> 1668;
3839 -> 3838;
3839 -> 1677;
3839 -> 1593;
3839 -> 1594;
3839 -> 3824;
3839 -> 1601;
3839 -> 1598;
3840 -> 1613;
3841 -> 3840;
3841 -> 1434;
3842 -> 3841;
3842 -> 1436;
3842 -> 1434;
3843 -> 1632;
3844 -> 3843;
3844 -> 1472;
3845 -> 3844;
3845 -> 1474;
3845 -> 1472;
3846 -> 1470;
3846 -> 1502;
3846 -> 1628;
3846 -> 3845;
3846 -> 1637;
3846 -> 1498;
3846 -> 1499;
3846 -> 3831;
3846 -> 1509;
3846 -> 1501;
3847 -> 1652;
3848 -> 3847;
3848 -> 1521;
3849 -> 3848;
3849 -> 1523;
3849 -> 1521;
3850 -> 1519;
3850 -> 1553;
3850 -> 1648;
3850 -> 3849;
3850 -> 1657;
3850 -> 1547;
3850 -> 1548;
3850 -> 3835;
3850 -> 1555;
3850 -> 1552;
3851 -> 1672;
3852 -> 3851;
3852 -> 1567;
3853 -> 3852;
3853 -> 1569;
3853 -> 1567;
3854 -> 1565;
3854 -> 1599;
3854 -> 1668;
3854 -> 3853;
3854 -> 1677;
3854 -> 1593;
3854 -> 1594;
3854 -> 3839;
3854 -> 1601;
3854 -> 1598;
3855 -> 1613;
3856 -> 3855;
3856 -> 1434;
3857 -> 3856;
3857 -> 1436;
3857 -> 1434;
3858 -> 1632;
3859 -> 3858;
3859 -> 1472;
3860 -> 3859;
3860 -> 1474;
3860 -> 1472;
3861 -> 1470;
3861 -> 1502;
3861 -> 1628;
3861 -> 3860;
3861 -> 1637;
3861 -> 1498;
3861 -> 1499;
3861 -> 3846;
3861 -> 1509;
3861 -> 1501;
3862 -> 1652;
3863 -> 3862;
3863 -> 1521;
3864 -> 3863;
3864 -> 1523;
3864 -> 1521;
3865 -> 1519;
3865 -> 1553;
3865 -> 1648;
3865 -> 3864;
3865 -> 1657;
3865 -> 1547;
3865 -> 1548;
3865 -> 3850;
3865 -> 1555;
3865 -> 1552;
3866 -> 1672;
3867 -> 3866;
3867 -> 1567;
3868 -> 3867;
3868 -> 1569;
3868 -> 1567;
3869 -> 1565;
3869 -> 1599;
3869 -> 1668;
3869 -> 3868;
3869 -> 1677;
3869 -> 1593;
3869 -> 1594;
3869 -> 3854;
3869 -> 1601;
3869 -> 1598;
3870 -> 1613;
3871 -> 3870;
3871 -> 1434;
3872 -> 3871;
3872 -> 1436;
3872 -> 1434;
3873 -> 1632;
3874 -> 3873;
3874 -> 1472;
3875 -> 3874;
3875 -> 1474;
3875 -> 1472;
3876 -> 1470;
3876 -> 1502;
3876 -> 1628;
3876 -> 3875;
3876 -> 1637;
3876 -> 1498;
3876 -> 1499;
3876 -> 3861;
3876 -> 1509;
3876 -> 1501;
3877 -> 1652;
3878 -> 3877;
3878 -> 1521;
3879 -> 3878;
3879 -> 1523;
3879 -> 1521;
3880 -> 1519;
3880 -> 1553;
3880 -> 1648;
3880 -> 3879;
3880 -> 1657;
3880 -> 1547;
3880 -> 1548;
3880 -> 3865;
3880 -> 1555;
3880 -> 1552;
3881 -> 1672;
3882 -> 3881;
3882 -> 1567;
3883 -> 3882;
3883 -> 1569;
3883 -> 1567;
3884 -> 1565;
3884 -> 1599;
3884 -> 1668;
3884 -> 3883;
3884 -> 1677;
3884 -> 1593;
3884 -> 1594;
3884 -> 3869;
3884 -> 1601;
3884 -> 1598;
3885 -> 1613;
3886 -> 3885;
3886 -> 1434;
3887 -> 3886;
3887 -> 1436;
3887 -> 1434;
3888 -> 1632;
3889 -> 3888;
3889 -> 1472;
3890 -> 3889;
3890 -> 1474;
3890 -> 1472;
3891 -> 1470;
3891 -> 1502;
3891 -> 1628;
3891 -> 3890;
3891 -> 1637;
3891 -> 1498;
3891 -> 1499;
3891 -> 3876;
3891 -> 1509;
3891 -> 1501;
3892 -> 1652;
3893 -> 3892;
3893 -> 1521;
3894 -> 3893;
3894 -> 1523;
3894 -> 1521;
3895 -> 1519;
3895 -> 1553;
3895 -> 1648;
3895 -> 3894;
3895 -> 1657;
3895 -> 1547;
3895 -> 1548;
3895 -> 3880;
3895 -> 1555;
3895 -> 1552;
3896 -> 1672;
3897 -> 3896;
3897 -> 1567;
3898 -> 3897;
3898 -> 1569;
3898 -> 1567;
3899 -> 1565;
3899 -> 1599;
3899 -> 1668;
3899 -> 3898;
3899 -> 1677;
3899 -> 1593;
3899 -> 1594;
3899 -> 3884;
3899 -> 1601;
3899 -> 1598;
3900 -> 1613;
3901 -> 3900;
3901 -> 1434;
3902 -> 3901;
3902 -> 1436;
3902 -> 1434;
3903 -> 1632;
3904 -> 3903;
3904 -> 1472;
3905 -> 3904;
3905 -> 1474;
3905 -> 1472;
3906 -> 1470;
3906 -> 1502;
3906 -> 1628;
3906 -> 3905;
3906 -> 1637;
3906 -> 1498;
3906 -> 1499;
3906 -> 3891;
3906 -> 1509;
3906 -> 1501;
3907 -> 1652;
3908 -> 3907;
3908 -> 1521;
3909 -> 3908;
3909 -> 1523;
3909 -> 1521;
3910 -> 1519;
3910 -> 1553;
3910 -> 1648;
3910 -> 3909;
3910 -> 1657;
3910 -> 1547;
3910 -> 1548;
3910 -> 3895;
3910 -> 1555;
3910 -> 1552;
3911 -> 1672;
3912 -> 3911;
3912 -> 1567;
3913 -> 3912;
3913 -> 1569;
3913 -> 1567;
3914 -> 1565;
3914 -> 1599;
3914 -> 1668;
3914 -> 3913;
3914 -> 1677;
3914 -> 1593;
3914 -> 1594;
3914 -> 3899;
3914 -> 1601;
3914 -> 1598;
3915 -> 1613;
3916 -> 3915;
3916 -> 1434;
3917 -> 3916;
3917 -> 1436;
3917 -> 1434;
3918 -> 1632;
3919 -> 3918;
3919 -> 1472;
3920 -> 3919;
3920 -> 1474;
3920 -> 1472;
3921 -> 1470;
3921 -> 1502;
3921 -> 1628;
3921 -> 3920;
3921 -> 1637;
3921 -> 1498;
3921 -> 1499;
3921 -> 3906;
3921 -> 1509;
3921 -> 1501;
3922 -> 1652;
3923 -> 3922;
3923 -> 1521;
3924 -> 3923;
3924 -> 1523;
3924 -> 1521;
3925 -> 1519;
3925 -> 1553;
3925 -> 1648;
3925 -> 3924;
3925 -> 1657;
3925 -> 1547;
3925 -> 1548;
3925 -> 3910;
3925 -> 1555;
3925 -> 1552;
3926 -> 1672;
3927 -> 3926;
3927 -> 1567;
3928 -> 3927;
3928 -> 1569;
3928 -> 1567;
3929 -> 1565;
3929 -> 1599;
3929 -> 1668;
3929 -> 3928;
3929 -> 1677;
3929 -> 1593;
3929 -> 1594;
3929 -> 3914;
3929 -> 1601;
3929 -> 1598;
3930 -> 1613;
3931 -> 3930;
3931 -> 1434;
3932 -> 3931;
3932 -> 1436;
3932 -> 1434;
3933 -> 1632;
3934 -> 3933;
3934 -> 1472;
3935 -> 3934;
3935 -> 1474;
3935 -> 1472;
3936 -> 1470;
3936 -> 1502;
3936 -> 1628;
3936 -> 3935;
3936 -> 1637;
3936 -> 1498;
3936 -> 1499;
3936 -> 3921;
3936 -> 1509;
3936 -> 1501;
3937 -> 1652;
3938 -> 3937;
3938 -> 1521;
3939 -> 3938;
3939 -> 1523;
3939 -> 1521;
3940 -> 1519;
3940 -> 1553;
3940 -> 1648;
3940 -> 3939;
3940 -> 1657;
3940 -> 1547;
3940 -> 1548;
3940 -> 3925;
3940 -> 1555;
3940 -> 1552;
3941 -> 1672;
3942 -> 3941;
3942 -> 1567;
3943 -> 3942;
3943 -> 1569;
3943 -> 1567;
3944 -> 1565;
3944 -> 1599;
3944 -> 1668;
3944 -> 3943;
3944 -> 1677;
3944 -> 1593;
3944 -> 1594;
3944 -> 3929;
3944 -> 1601;
3944 -> 1598;
3945 -> 1613;
3946 -> 3945;
3946 -> 1434;
3947 -> 3946;
3947 -> 1436;
3947 -> 1434;
3948 -> 1632;
3949 -> 3948;
3949 -> 1472;
3950 -> 3949;
3950 -> 1474;
3950 -> 1472;
3951 -> 1470;
3951 -> 1502;
3951 -> 1628;
3951 -> 3950;
3951 -> 1637;
3951 -> 1498;
3951 -> 1499;
3951 -> 3936;
3951 -> 1509;
3951 -> 1501;
3952 -> 1652;
3953 -> 3952;
3953 -> 1521;
3954 -> 3953;
3954 -> 1523;
3954 -> 1521;
3955 -> 1519;
3955 -> 1553;
3955 -> 1648;
3955 -> 3954;
3955 -> 1657;
3955 -> 1547;
3955 -> 1548;
3955 -> 3940;
3955 -> 1555;
3955 -> 1552;
3956 -> 1672;
3957 -> 3956;
3957 -> 1567;
3958 -> 3957;
3958 -> 1569;
3958 -> 1567;
3959 -> 1565;
3959 -> 1599;
3959 -> 1668;
3959 -> 3958;
3959 -> 1677;
3959 -> 1593;
3959 -> 1594;
3959 -> 3944;
3959 -> 1601;
3959 -> 1598;
3960 -> 1613;
3961 -> 3960;
3961 -> 1434;
3962 -> 3961;
3962 -> 1436;
3962 -> 1434;
3963 -> 1632;
3964 -> 3963;
3964 -> 1472;
3965 -> 3964;
3965 -> 1474;
3965 -> 1472;
3966 -> 1470;
3966 -> 1502;
3966 -> 1628;
3966 -> 3965;
3966 -> 1637;
3966 -> 1498;
3966 -> 1499;
3966 -> 3951;
3966 -> 1509;
3966 -> 1501;
3967 -> 1652;
3968 -> 3967;
3968 -> 1521;
3969 -> 3968;
3969 -> 1523;
3969 -> 1521;
3970 -> 1519;
3970 -> 1553;
3970 -> 1648;
3970 -> 3969;
3970 -> 1657;
3970 -> 1547;
3970 -> 1548;
3970 -> 3955;
3970 -> 1555;
3970 -> 1552;
3971 -> 1672;
3972 -> 3971;
3972 -> 1567;
3973 -> 3972;
3973 -> 1569;
3973 -> 1567;
3974 -> 1565;
3974 -> 1599;
3974 -> 1668;
3974 -> 3973;
3974 -> 1677;
3974 -> 1593;
3974 -> 1594;
3974 -> 3959;
3974 -> 1601;
3974 -> 1598;
3975 -> 1613;
3976 -> 3975;
3976 -> 1434;
3977 -> 3976;
3977 -> 1436;
3977 -> 1434;
3978 -> 1632;
3979 -> 3978;
3979 -> 1472;
3980 -> 3979;
3980 -> 1474;
3980 -> 1472;
3981 -> 1470;
3981 -> 1502;
3981 -> 1628;
3981 -> 3980;
3981 -> 1637;
3981 -> 1498;
3981 -> 1499;
3981 -> 3966;
3981 -> 1509;
3981 -> 1501;
3982 -> 1652;
3983 -> 3982;
3983 -> 1521;
3984 -> 3983;
3984 -> 1523;
3984 -> 1521;
3985 -> 1519;
3985 -> 1553;
3985 -> 1648;
3985 -> 3984;
3985 -> 1657;
3985 -> 1547;
3985 -> 1548;
3985 -> 3970;
3985 -> 1555;
3985 -> 1552;
3986 -> 1672;
3987 -> 3986;
3987 -> 1567;
3988 -> 3987;
3988 -> 1569;
3988 -> 1567;
3989 -> 1565;
3989 -> 1599;
3989 -> 1668;
3989 -> 3988;
3989 -> 1677;
3989 -> 1593;
3989 -> 1594;
3989 -> 3974;
3989 -> 1601;
3989 -> 1598;
3990 -> 1613;
3991 -> 3990;
3991 -> 1434;
3992 -> 3991;
3992 -> 1436;
3992 -> 1434;
3993 -> 1632;
3994 -> 3993;
3994 -> 1472;
3995 -> 3994;
3995 -> 1474;
3995 -> 1472;
3996 -> 1470;
3996 -> 1502;
3996 -> 1628;
3996 -> 3995;
3996 -> 1637;
3996 -> 1498;
3996 -> 1499;
3996 -> 3981;
3996 -> 1509;
3996 -> 1501;
3997 -> 1652;
3998 -> 3997;
3998 -> 1521;
3999 -> 3998;
3999 -> 1523;
3999 -> 1521;
4000 -> 1519;
4000 -> 1553;
4000 -> 1648;
4000 -> 3999;
4000 -> 1657;
4000 -> 1547;
4000 -> 1548;
4000 -> 3985;
4000 -> 1555;
4000 -> 1552;
4001 -> 1672;
4002 -> 4001;
4002 -> 1567;
4003 -> 4002;
4003 -> 1569;
4003 -> 1567;
4004 -> 1565;
4004 -> 1599;
4004 -> 1668;
4004 -> 4003;
4004 -> 1677;
4004 -> 1593;
4004 -> 1594;
4004 -> 3989;
4004 -> 1601;
4004 -> 1598;
4005 -> 1613;
4006 -> 4005;
4006 -> 1434;
4007 -> 4006;
4007 -> 1436;
4007 -> 1434;
4008 -> 1632;
4009 -> 4008;
4009 -> 1472;
4010 -> 4009;
4010 -> 1474;
4010 -> 1472;
4011 -> 1470;
4011 -> 1502;
4011 -> 1628;
4011 -> 4010;
4011 -> 1637;
4011 -> 1498;
4011 -> 1499;
4011 -> 3996;
4011 -> 1509;
4011 -> 1501;
4012 -> 1652;
4013 -> 4012;
4013 -> 1521;
4014 -> 4013;
4014 -> 1523;
4014 -> 1521;
4015 -> 1519;
4015 -> 1553;
4015 -> 1648;
4015 -> 4014;
4015 -> 1657;
4015 -> 1547;
4015 -> 1548;
4015 -> 4000;
4015 -> 1555;
4015 -> 1552;
4016 -> 1672;
4017 -> 4016;
4017 -> 1567;
4018 -> 4017;
4018 -> 1569;
4018 -> 1567;
4019 -> 1565;
4019 -> 1599;
4019 -> 1668;
4019 -> 4018;
4019 -> 1677;
4019 -> 1593;
4019 -> 1594;
4019 -> 4004;
4019 -> 1601;
4019 -> 1598;
4020 -> 1613;
4021 -> 4020;
4021 -> 1434;
4022 -> 4021;
4022 -> 1436;
4022 -> 1434;
4023 -> 1632;
4024 -> 4023;
4024 -> 1472;
4025 -> 4024;
4025 -> 1474;
4025 -> 1472;
4026 -> 1470;
4026 -> 1502;
4026 -> 1628;
4026 -> 4025;
4026 -> 1637;
4026 -> 1498;
4026 -> 1499;
4026 -> 4011;
4026 -> 1509;
4026 -> 1501;
4027 -> 1652;
4028 -> 4027;
4028 -> 1521;
4029 -> 4028;
4029 -> 1523;
4029 -> 1521;
4030 -> 1519;
4030 -> 1553;
4030 -> 1648;
4030 -> 4029;
4030 -> 1657;
4030 -> 1547;
4030 -> 1548;
4030 -> 4015;
4030 -> 1555;
4030 -> 1552;
4031 -> 1672;
4032 -> 4031;
4032 -> 1567;
4033 -> 4032;
4033 -> 1569;
4033 -> 1567;
4034 -> 1565;
4034 -> 1599;
4034 -> 1668;
4034 -> 4033;
4034 -> 1677;
4034 -> 1593;
4034 -> 1594;
4034 -> 4019;
4034 -> 1601;
4034 -> 1598;
4035 -> 1613;
4036 -> 4035;
4036 -> 1434;
4037 -> 4036;
4037 -> 1436;
4037 -> 1434;
4038 -> 1632;
4039 -> 4038;
4039 -> 1472;
4040 -> 4039;
4040 -> 1474;
4040 -> 1472;
4041 -> 1470;
4041 -> 1502;
4041 -> 1628;
4041 -> 4040;
4041 -> 1637;
4041 -> 1498;
4041 -> 1499;
4041 -> 4026;
4041 -> 1509;
4041 -> 1501;
4042 -> 1652;
4043 -> 4042;
4043 -> 1521;
4044 -> 4043;
4044 -> 1523;
4044 -> 1521;
4045 -> 1519;
4045 -> 1553;
4045 -> 1648;
4045 -> 4044;
4045 -> 1657;
4045 -> 1547;
4045 -> 1548;
4045 -> 4030;
4045 -> 1555;
4045 -> 1552;
4046 -> 1672;
4047 -> 4046;
4047 -> 1567;
4048 -> 4047;
4048 -> 1569;
4048 -> 1567;
4049 -> 1565;
4049 -> 1599;
4049 -> 1668;
4049 -> 4048;
4049 -> 1677;
4049 -> 1593;
4049 -> 1594;
4049 -> 4034;
4049 -> 1601;
4049 -> 1598;
4050 -> 1613;
4051 -> 4050;
4051 -> 1434;
4052 -> 4051;
4052 -> 1436;
4052 -> 1434;
4053 -> 1632;
4054 -> 4053;
4054 -> 1472;
4055 -> 4054;
4055 -> 1474;
4055 -> 1472;
4056 -> 1470;
4056 -> 1502;
4056 -> 1628;
4056 -> 4055;
4056 -> 1637;
4056 -> 1498;
4056 -> 1499;
4056 -> 4041;
4056 -> 1509;
4056 -> 1501;
4057 -> 1652;
4058 -> 4057;
4058 -> 1521;
4059 -> 4058;
4059 -> 1523;
4059 -> 1521;
4060 -> 1519;
4060 -> 1553;
4060 -> 1648;
4060 -> 4059;
4060 -> 1657;
4060 -> 1547;
4060 -> 1548;
4060 -> 4045;
4060 -> 1555;
4060 -> 1552;
4061 -> 1672;
4062 -> 4061;
4062 -> 1567;
4063 -> 4062;
4063 -> 1569;
4063 -> 1567;
4064 -> 1565;
4064 -> 1599;
4064 -> 1668;
4064 -> 4063;
4064 -> 1677;
4064 -> 1593;
4064 -> 1594;
4064 -> 4049;
4064 -> 1601;
4064 -> 1598;
4065 -> 1613;
4066 -> 4065;
4066 -> 1434;
4067 -> 4066;
4067 -> 1436;
4067 -> 1434;
4068 -> 1632;
4069 -> 4068;
4069 -> 1472;
4070 -> 4069;
4070 -> 1474;
4070 -> 1472;
4071 -> 1470;
4071 -> 1502;
4071 -> 1628;
4071 -> 4070;
4071 -> 1637;
4071 -> 1498;
4071 -> 1499;
4071 -> 4056;
4071 -> 1509;
4071 -> 1501;
4072 -> 1652;
4073 -> 4072;
4073 -> 1521;
4074 -> 4073;
4074 -> 1523;
4074 -> 1521;
4075 -> 1519;
4075 -> 1553;
4075 -> 1648;
4075 -> 4074;
4075 -> 1657;
4075 -> 1547;
4075 -> 1548;
4075 -> 4060;
4075 -> 1555;
4075 -> 1552;
4076 -> 1672;
4077 -> 4076;
4077 -> 1567;
4078 -> 4077;
4078 -> 1569;
4078 -> 1567;
4079 -> 1565;
4079 -> 1599;
4079 -> 1668;
4079 -> 4078;
4079 -> 1677;
4079 -> 1593;
4079 -> 1594;
4079 -> 4064;
4079 -> 1601;
4079 -> 1598;
4080 -> 1613;
4081 -> 4080;
4081 -> 1434;
4082 -> 4081;
4082 -> 1436;
4082 -> 1434;
4083 -> 1632;
4084 -> 4083;
4084 -> 1472;
4085 -> 4084;
4085 -> 1474;
4085 -> 1472;
4086 -> 1470;
4086 -> 1502;
4086 -> 1628;
4086 -> 4085;
4086 -> 1637;
4086 -> 1498;
4086 -> 1499;
4086 -> 4071;
4086 -> 1509;
4086 -> 1501;
4087 -> 1652;
4088 -> 4087;
4088 -> 1521;
4089 -> 4088;
4089 -> 1523;
4089 -> 1521;
4090 -> 1519;
4090 -> 1553;
4090 -> 1648;
4090 -> 4089;
4090 -> 1657;
4090 -> 1547;
4090 -> 1548;
4090 -> 4075;
4090 -> 1555;
4090 -> 1552;
4091 -> 1672;
4092 -> 4091;
4092 -> 1567;
4093 -> 4092;
4093 -> 1569;
4093 -> 1567;
4094 -> 1565;
4094 -> 1599;
4094 -> 1668;
4094 -> 4093;
4094 -> 1677;
4094 -> 1593;
4094 -> 1594;
4094 -> 4079;
4094 -> 1601;
4094 -> 1598;
4095 -> 1613;
4096 -> 4095;
4096 -> 1434;
4097 -> 4096;
4097 -> 1436;
4097 -> 1434;
4098 -> 1632;
4099 -> 4098;
4099 -> 1472;
4100 -> 4099;
4100 -> 1474;
4100 -> 1472;
4101 -> 1470;
4101 -> 1502;
4101 -> 1628;
4101 -> 4100;
4101 -> 1637;
4101 -> 1498;
4101 -> 1499;
4101 -> 4086;
4101 -> 1509;
4101 -> 1501;
4102 -> 1652;
4103 -> 4102;
4103 -> 1521;
4104 -> 4103;
4104 -> 1523;
4104 -> 1521;
4105 -> 1519;
4105 -> 1553;
4105 -> 1648;
4105 -> 4104;
4105 -> 1657;
4105 -> 1547;
4105 -> 1548;
4105 -> 4090;
4105 -> 1555;
4105 -> 1552;
4106 -> 1672;
4107 -> 4106;
4107 -> 1567;
4108 -> 4107;
4108 -> 1569;
4108 -> 1567;
4109 -> 1565;
4109 -> 1599;
4109 -> 1668;
4109 -> 4108;
4109 -> 1677;
4109 -> 1593;
4109 -> 1594;
4109 -> 4094;
4109 -> 1601;
4109 -> 1598;
4110 -> 1613;
4111 -> 4110;
4111 -> 1434;
4112 -> 4111;
4112 -> 1436;
4112 -> 1434;
4113 -> 1632;
4114 -> 4113;
4114 -> 1472;
4115 -> 4114;
4115 -> 1474;
4115 -> 1472;
4116 -> 1470;
4116 -> 1502;
4116 -> 1628;
4116 -> 4115;
4116 -> 1637;
4116 -> 1498;
4116 -> 1499;
4116 -> 4101;
4116 -> 1509;
4116 -> 1501;
4117 -> 1652;
4118 -> 4117;
4118 -> 1521;
4119 -> 4118;
4119 -> 1523;
4119 -> 1521;
4120 -> 1519;
4120 -> 1553;
4120 -> 1648;
4120 -> 4119;
4120 -> 1657;
4120 -> 1547;
4120 -> 1548;
4120 -> 4105;
4120 -> 1555;
4120 -> 1552;
4121 -> 1672;
4122 -> 4121;
4122 -> 1567;
4123 -> 4122;
4123 -> 1569;
4123 -> 1567;
4124 -> 1565;
4124 -> 1599;
4124 -> 1668;
4124 -> 4123;
4124 -> 1677;
4124 -> 1593;
4124 -> 1594;
4124 -> 4109;
4124 -> 1601;
4124 -> 1598;
4125 -> 1613;
4126 -> 4125;
4126 -> 1434;
4127 -> 4126;
4127 -> 1436;
4127 -> 1434;
4128 -> 1632;
4129 -> 4128;
4129 -> 1472;
4130 -> 4129;
4130 -> 1474;
4130 -> 1472;
4131 -> 1470;
4131 -> 1502;
4131 -> 1628;
4131 -> 4130;
4131 -> 1637;
4131 -> 1498;
4131 -> 1499;
4131 -> 4116;
4131 -> 1509;
4131 -> 1501;
4132 -> 1652;
4133 -> 4132;
4133 -> 1521;
4134 -> 4133;
4134 -> 1523;
4134 -> 1521;
4135 -> 1519;
4135 -> 1553;
4135 -> 1648;
4135 -> 4134;
4135 -> 1657;
4135 -> 1547;
4135 -> 1548;
4135 -> 4120;
4135 -> 1555;
4135 -> 1552;
4136 -> 1672;
4137 -> 4136;
4137 -> 1567;
4138 -> 4137;
4138 -> 1569;
4138 -> 1567;
4139 -> 1565;
4139 -> 1599;
4139 -> 1668;
4139 -> 4138;
4139 -> 1677;
4139 -> 1593;
4139 -> 1594;
4139 -> 4124;
4139 -> 1601;
4139 -> 1598;
4140 -> 1613;
4141 -> 4140;
4141 -> 1434;
4142 -> 4141;
4142 -> 1436;
4142 -> 1434;
4143 -> 1632;
4144 -> 4143;
4144 -> 1472;
4145 -> 4144;
4145 -> 1474;
4145 -> 1472;
4146 -> 1470;
4146 -> 1502;
4146 -> 1628;
4146 -> 4145;
4146 -> 1637;
4146 -> 1498;
4146 -> 1499;
4146 -> 4131;
4146 -> 1509;
4146 -> 1501;
4147 -> 1652;
4148 -> 4147;
4148 -> 1521;
4149 -> 4148;
4149 -> 1523;
4149 -> 1521;
4150 -> 1519;
4150 -> 1553;
4150 -> 1648;
4150 -> 4149;
4150 -> 1657;
4150 -> 1547;
4150 -> 1548;
4150 -> 4135;
4150 -> 1555;
4150 -> 1552;
4151 -> 1672;
4152 -> 4151;
4152 -> 1567;
4153 -> 4152;
4153 -> 1569;
4153 -> 1567;
4154 -> 1565;
4154 -> 1599;
4154 -> 1668;
4154 -> 4153;
4154 -> 1677;
4154 -> 1593;
4154 -> 1594;
4154 -> 4139;
4154 -> 1601;
4154 -> 1598;
4155 -> 1613;
4156 -> 4155;
4156 -> 1434;
4157 -> 4156;
4157 -> 1436;
4157 -> 1434;
4158 -> 1632;
4159 -> 4158;
4159 -> 1472;
4160 -> 4159;
4160 -> 1474;
4160 -> 1472;
4161 -> 1470;
4161 -> 1502;
4161 -> 1628;
4161 -> 4160;
4161 -> 1637;
4161 -> 1498;
4161 -> 1499;
4161 -> 4146;
4161 -> 1509;
4161 -> 1501;
4162 -> 1652;
4163 -> 4162;
4163 -> 1521;
4164 -> 4163;
4164 -> 1523;
4164 -> 1521;
4165 -> 1519;
4165 -> 1553;
4165 -> 1648;
4165 -> 4164;
4165 -> 1657;
4165 -> 1547;
4165 -> 1548;
4165 -> 4150;
4165 -> 1555;
4165 -> 1552;
4166 -> 1672;
4167 -> 4166;
4167 -> 1567;
4168 -> 4167;
4168 -> 1569;
4168 -> 1567;
4169 -> 1565;
4169 -> 1599;
4169 -> 1668;
4169 -> 4168;
4169 -> 1677;
4169 -> 1593;
4169 -> 1594;
4169 -> 4154;
4169 -> 1601;
4169 -> 1598;
4170 -> 1613;
4171 -> 4170;
4171 -> 1434;
4172 -> 4171;
4172 -> 1436;
4172 -> 1434;
4173 -> 1632;
4174 -> 4173;
4174 -> 1472;
4175 -> 4174;
4175 -> 1474;
4175 -> 1472;
4176 -> 1470;
4176 -> 1502;
4176 -> 1628;
4176 -> 4175;
4176 -> 1637;
4176 -> 1498;
4176 -> 1499;
4176 -> 4161;
4176 -> 1509;
4176 -> 1501;
4177 -> 1652;
4178 -> 4177;
4178 -> 1521;
4179 -> 4178;
4179 -> 1523;
4179 -> 1521;
4180 -> 1519;
4180 -> 1553;
4180 -> 1648;
4180 -> 4179;
4180 -> 1657;
4180 -> 1547;
4180 -> 1548;
4180 -> 4165;
4180 -> 1555;
4180 -> 1552;
4181 -> 1672;
4182 -> 4181;
4182 -> 1567;
4183 -> 4182;
4183 -> 1569;
4183 -> 1567;
4184 -> 1565;
4184 -> 1599;
4184 -> 1668;
4184 -> 4183;
4184 -> 1677;
4184 -> 1593;
4184 -> 1594;
4184 -> 4169;
4184 -> 1601;
4184 -> 1598;
4185 -> 1613;
4186 -> 4185;
4186 -> 1434;
4187 -> 4186;
4187 -> 1436;
4187 -> 1434;
4188 -> 1632;
4189 -> 4188;
4189 -> 1472;
4190 -> 4189;
4190 -> 1474;
4190 -> 1472;
4191 -> 1470;
4191 -> 1502;
4191 -> 1628;
4191 -> 4190;
4191 -> 1637;
4191 -> 1498;
4191 -> 1499;
4191 -> 4176;
4191 -> 1509;
4191 -> 1501;
4192 -> 1652;
4193 -> 4192;
4193 -> 1521;
4194 -> 4193;
4194 -> 1523;
4194 -> 1521;
4195 -> 1519;
4195 -> 1553;
4195 -> 1648;
4195 -> 4194;
4195 -> 1657;
4195 -> 1547;
4195 -> 1548;
4195 -> 4180;
4195 -> 1555;
4195 -> 1552;
4196 -> 1672;
4197 -> 4196;
4197 -> 1567;
4198 -> 4197;
4198 -> 1569;
4198 -> 1567;
4199 -> 1565;
4199 -> 1599;
4199 -> 1668;
4199 -> 4198;
4199 -> 1677;
4199 -> 1593;
4199 -> 1594;
4199 -> 4184;
4199 -> 1601;
4199 -> 1598;
4200 -> 1613;
4201 -> 4200;
4201 -> 1434;
4202 -> 4201;
4202 -> 1436;
4202 -> 1434;
4203 -> 1632;
4204 -> 4203;
4204 -> 1472;
4205 -> 4204;
4205 -> 1474;
4205 -> 1472;
4206 -> 1470;
4206 -> 1502;
4206 -> 1628;
4206 -> 4205;
4206 -> 1637;
4206 -> 1498;
4206 -> 1499;
4206 -> 4191;
4206 -> 1509;
4206 -> 1501;
4207 -> 1652;
4208 -> 4207;
4208 -> 1521;
4209 -> 4208;
4209 -> 1523;
4209 -> 1521;
4210 -> 1519;
4210 -> 1553;
4210 -> 1648;
4210 -> 4209;
4210 -> 1657;
4210 -> 1547;
4210 -> 1548;
4210 -> 4195;
4210 -> 1555;
4210 -> 1552;
4211 -> 1672;
4212 -> 4211;
4212 -> 1567;
4213 -> 4212;
4213 -> 1569;
4213 -> 1567;
4214 -> 1565;
4214 -> 1599;
4214 -> 1668;
4214 -> 4213;
4214 -> 1677;
4214 -> 1593;
4214 -> 1594;
4214 -> 4199;
4214 -> 1601;
4214 -> 1598;
4215 -> 1613;
4216 -> 4215;
4216 -> 1434;
4217 -> 4216;
4217 -> 1436;
4217 -> 1434;
4218 -> 1632;
4219 -> 4218;
4219 -> 1472;
4220 -> 4219;
4220 -> 1474;
4220 -> 1472;
4221 -> 1470;
4221 -> 1502;
4221 -> 1628;
4221 -> 4220;
4221 -> 1637;
4221 -> 1498;
4221 -> 1499;
4221 -> 4206;
4221 -> 1509;
4221 -> 1501;
4222 -> 1652;
4223 -> 4222;
4223 -> 1521;
4224 -> 4223;
4224 -> 1523;
4224 -> 1521;
4225 -> 1519;
4225 -> 1553;
4225 -> 1648;
4225 -> 4224;
4225 -> 1657;
4225 -> 1547;
4225 -> 1548;
4225 -> 4210;
4225 -> 1555;
4225 -> 1552;
4226 -> 1672;
4227 -> 4226;
4227 -> 1567;
4228 -> 4227;
4228 -> 1569;
4228 -> 1567;
4229 -> 1565;
4229 -> 1599;
4229 -> 1668;
4229 -> 4228;
4229 -> 1677;
4229 -> 1593;
4229 -> 1594;
4229 -> 4214;
4229 -> 1601;
4229 -> 1598;
4230 -> 1613;
4231 -> 4230;
4231 -> 1434;
4232 -> 4231;
4232 -> 1436;
4232 -> 1434;
4233 -> 1632;
4234 -> 4233;
4234 -> 1472;
4235 -> 4234;
4235 -> 1474;
4235 -> 1472;
4236 -> 1470;
4236 -> 1502;
4236 -> 1628;
4236 -> 4235;
4236 -> 1637;
4236 -> 1498;
4236 -> 1499;
4236 -> 4221;
4236 -> 1509;
4236 -> 1501;
4237 -> 1652;
4238 -> 4237;
4238 -> 1521;
4239 -> 4238;
4239 -> 1523;
4239 -> 1521;
4240 -> 1519;
4240 -> 1553;
4240 -> 1648;
4240 -> 4239;
4240 -> 1657;
4240 -> 1547;
4240 -> 1548;
4240 -> 4225;
4240 -> 1555;
4240 -> 1552;
4241 -> 1672;
4242 -> 4241;
4242 -> 1567;
4243 -> 4242;
4243 -> 1569;
4243 -> 1567;
4244 -> 1565;
4244 -> 1599;
4244 -> 1668;
4244 -> 4243;
4244 -> 1677;
4244 -> 1593;
4244 -> 1594;
4244 -> 4229;
4244 -> 1601;
4244 -> 1598;
4245 -> 1613;
4246 -> 4245;
4246 -> 1434;
4247 -> 4246;
4247 -> 1436;
4247 -> 1434;
4248 -> 1632;
4249 -> 4248;
4249 -> 1472;
4250 -> 4249;
4250 -> 1474;
4250 -> 1472;
4251 -> 1470;
4251 -> 1502;
4251 -> 1628;
4251 -> 4250;
4251 -> 1637;
4251 -> 1498;
4251 -> 1499;
4251 -> 4236;
4251 -> 1509;
4251 -> 1501;
4252 -> 1652;
4253 -> 4252;
4253 -> 1521;
4254 -> 4253;
4254 -> 1523;
4254 -> 1521;
4255 -> 1519;
4255 -> 1553;
4255 -> 1648;
4255 -> 4254;
4255 -> 1657;
4255 -> 1547;
4255 -> 1548;
4255 -> 4240;
4255 -> 1555;
4255 -> 1552;
4256 -> 1672;
4257 -> 4256;
4257 -> 1567;
4258 -> 4257;
4258 -> 1569;
4258 -> 1567;
4259 -> 1565;
4259 -> 1599;
4259 -> 1668;
4259 -> 4258;
4259 -> 1677;
4259 -> 1593;
4259 -> 1594;
4259 -> 4244;
4259 -> 1601;
4259 -> 1598;
4260 -> 1613;
4261 -> 4260;
4261 -> 1434;
4262 -> 4261;
4262 -> 1436;
4262 -> 1434;
4263 -> 1632;
4264 -> 4263;
4264 -> 1472;
4265 -> 4264;
4265 -> 1474;
4265 -> 1472;
4266 -> 1470;
4266 -> 1502;
4266 -> 1628;
4266 -> 4265;
4266 -> 1637;
4266 -> 1498;
4266 -> 1499;
4266 -> 4251;
4266 -> 1509;
4266 -> 1501;
4267 -> 1652;
4268 -> 4267;
4268 -> 1521;
4269 -> 4268;
4269 -> 1523;
4269 -> 1521;
4270 -> 1519;
4270 -> 1553;
4270 -> 1648;
4270 -> 4269;
4270 -> 1657;
4270 -> 1547;
4270 -> 1548;
4270 -> 4255;
4270 -> 1555;
4270 -> 1552;
4271 -> 1672;
4272 -> 4271;
4272 -> 1567;
4273 -> 4272;
4273 -> 1569;
4273 -> 1567;
4274 -> 1565;
4274 -> 1599;
4274 -> 1668;
4274 -> 4273;
4274 -> 1677;
4274 -> 1593;
4274 -> 1594;
4274 -> 4259;
4274 -> 1601;
4274 -> 1598;
4275 -> 1613;
4276 -> 4275;
4276 -> 1434;
4277 -> 4276;
4277 -> 1436;
4277 -> 1434;
4278 -> 1632;
4279 -> 4278;
4279 -> 1472;
4280 -> 4279;
4280 -> 1474;
4280 -> 1472;
4281 -> 1470;
4281 -> 1502;
4281 -> 1628;
4281 -> 4280;
4281 -> 1637;
4281 -> 1498;
4281 -> 1499;
4281 -> 4266;
4281 -> 1509;
4281 -> 1501;
4282 -> 1652;
4283 -> 4282;
4283 -> 1521;
4284 -> 4283;
4284 -> 1523;
4284 -> 1521;
4285 -> 1519;
4285 -> 1553;
4285 -> 1648;
4285 -> 4284;
4285 -> 1657;
4285 -> 1547;
4285 -> 1548;
4285 -> 4270;
4285 -> 1555;
4285 -> 1552;
4286 -> 1672;
4287 -> 4286;
4287 -> 1567;
4288 -> 4287;
4288 -> 1569;
4288 -> 1567;
4289 -> 1565;
4289 -> 1599;
4289 -> 1668;
4289 -> 4288;
4289 -> 1677;
4289 -> 1593;
4289 -> 1594;
4289 -> 4274;
4289 -> 1601;
4289 -> 1598;
4290 -> 1613;
4291 -> 4290;
4291 -> 1434;
4292 -> 4291;
4292 -> 1436;
4292 -> 1434;
4293 -> 1632;
4294 -> 4293;
4294 -> 1472;
4295 -> 4294;
4295 -> 1474;
4295 -> 1472;
4296 -> 1470;
4296 -> 1502;
4296 -> 1628;
4296 -> 4295;
4296 -> 1637;
4296 -> 1498;
4296 -> 1499;
4296 -> 4281;
4296 -> 1509;
4296 -> 1501;
4297 -> 1652;
4298 -> 4297;
4298 -> 1521;
4299 -> 4298;
4299 -> 1523;
4299 -> 1521;
4300 -> 1519;
4300 -> 1553;
4300 -> 1648;
4300 -> 4299;
4300 -> 1657;
4300 -> 1547;
4300 -> 1548;
4300 -> 4285;
4300 -> 1555;
4300 -> 1552;
4301 -> 1672;
4302 -> 4301;
4302 -> 1567;
4303 -> 4302;
4303 -> 1569;
4303 -> 1567;
4304 -> 1565;
4304 -> 1599;
4304 -> 1668;
4304 -> 4303;
4304 -> 1677;
4304 -> 1593;
4304 -> 1594;
4304 -> 4289;
4304 -> 1601;
4304 -> 1598;
4305 -> 1613;
4306 -> 4305;
4306 -> 1434;
4307 -> 4306;
4307 -> 1436;
4307 -> 1434;
4308 -> 1632;
4309 -> 4308;
4309 -> 1472;
4310 -> 4309;
4310 -> 1474;
4310 -> 1472;
4311 -> 1470;
4311 -> 1502;
4311 -> 1628;
4311 -> 4310;
4311 -> 1637;
4311 -> 1498;
4311 -> 1499;
4311 -> 4296;
4311 -> 1509;
4311 -> 1501;
4312 -> 1652;
4313 -> 4312;
4313 -> 1521;
4314 -> 4313;
4314 -> 1523;
4314 -> 1521;
4315 -> 1519;
4315 -> 1553;
4315 -> 1648;
4315 -> 4314;
4315 -> 1657;
4315 -> 1547;
4315 -> 1548;
4315 -> 4300;
4315 -> 1555;
4315 -> 1552;
4316 -> 1672;
4317 -> 4316;
4317 -> 1567;
4318 -> 4317;
4318 -> 1569;
4318 -> 1567;
4319 -> 1565;
4319 -> 1599;
4319 -> 1668;
4319 -> 4318;
4319 -> 1677;
4319 -> 1593;
4319 -> 1594;
4319 -> 4304;
4319 -> 1601;
4319 -> 1598;
4320 -> 1613;
4321 -> 4320;
4321 -> 1434;
4322 -> 4321;
4322 -> 1436;
4322 -> 1434;
4323 -> 1632;
4324 -> 4323;
4324 -> 1472;
4325 -> 4324;
4325 -> 1474;
4325 -> 1472;
4326 -> 1470;
4326 -> 1502;
4326 -> 1628;
4326 -> 4325;
4326 -> 1637;
4326 -> 1498;
4326 -> 1499;
4326 -> 4311;
4326 -> 1509;
4326 -> 1501;
4327 -> 1652;
4328 -> 4327;
4328 -> 1521;
4329 -> 4328;
4329 -> 1523;
4329 -> 1521;
4330 -> 1519;
4330 -> 1553;
4330 -> 1648;
4330 -> 4329;
4330 -> 1657;
4330 -> 1547;
4330 -> 1548;
4330 -> 4315;
4330 -> 1555;
4330 -> 1552;
4331 -> 1672;
4332 -> 4331;
4332 -> 1567;
4333 -> 4332;
4333 -> 1569;
4333 -> 1567;
4334 -> 1565;
4334 -> 1599;
4334 -> 1668;
4334 -> 4333;
4334 -> 1677;
4334 -> 1593;
4334 -> 1594;
4334 -> 4319;
4334 -> 1601;
4334 -> 1598;
4335 -> 1613;
4336 -> 4335;
4336 -> 1434;
4337 -> 4336;
4337 -> 1436;
4337 -> 1434;
4338 -> 1632;
4339 -> 4338;
4339 -> 1472;
4340 -> 4339;
4340 -> 1474;
4340 -> 1472;
4341 -> 1470;
4341 -> 1502;
4341 -> 1628;
4341 -> 4340;
4341 -> 1637;
4341 -> 1498;
4341 -> 1499;
4341 -> 4326;
4341 -> 1509;
4341 -> 1501;
4342 -> 1652;
4343 -> 4342;
4343 -> 1521;
4344 -> 4343;
4344 -> 1523;
4344 -> 1521;
4345 -> 1519;
4345 -> 1553;
4345 -> 1648;
4345 -> 4344;
4345 -> 1657;
4345 -> 1547;
4345 -> 1548;
4345 -> 4330;
4345 -> 1555;
4345 -> 1552;
4346 -> 1672;
4347 -> 4346;
4347 -> 1567;
4348 -> 4347;
4348 -> 1569;
4348 -> 1567;
4349 -> 1565;
4349 -> 1599;
4349 -> 1668;
4349 -> 4348;
4349 -> 1677;
4349 -> 1593;
4349 -> 1594;
4349 -> 4334;
4349 -> 1601;
4349 -> 1598;
4350 -> 1613;
4351 -> 4350;
4351 -> 1434;
4352 -> 4351;
4352 -> 1436;
4352 -> 1434;
4353 -> 1632;
4354 -> 4353;
4354 -> 1472;
4355 -> 4354;
4355 -> 1474;
4355 -> 1472;
4356 -> 1470;
4356 -> 1502;
4356 -> 1628;
4356 -> 4355;
4356 -> 1637;
4356 -> 1498;
4356 -> 1499;
4356 -> 4341;
4356 -> 1509;
4356 -> 1501;
4357 -> 1652;
4358 -> 4357;
4358 -> 1521;
4359 -> 4358;
4359 -> 1523;
4359 -> 1521;
4360 -> 1519;
4360 -> 1553;
4360 -> 1648;
4360 -> 4359;
4360 -> 1657;
4360 -> 1547;
4360 -> 1548;
4360 -> 4345;
4360 -> 1555;
4360 -> 1552;
4361 -> 1672;
4362 -> 4361;
4362 -> 1567;
4363 -> 4362;
4363 -> 1569;
4363 -> 1567;
4364 -> 1565;
4364 -> 1599;
4364 -> 1668;
4364 -> 4363;
4364 -> 1677;
4364 -> 1593;
4364 -> 1594;
4364 -> 4349;
4364 -> 1601;
4364 -> 1598;
4365 -> 1613;
4366 -> 4365;
4366 -> 1434;
4367 -> 4366;
4367 -> 1436;
4367 -> 1434;
4368 -> 1632;
4369 -> 4368;
4369 -> 1472;
4370 -> 4369;
4370 -> 1474;
4370 -> 1472;
4371 -> 1470;
4371 -> 1502;
4371 -> 1628;
4371 -> 4370;
4371 -> 1637;
4371 -> 1498;
4371 -> 1499;
4371 -> 4356;
4371 -> 1509;
4371 -> 1501;
4372 -> 1652;
4373 -> 4372;
4373 -> 1521;
4374 -> 4373;
4374 -> 1523;
4374 -> 1521;
4375 -> 1519;
4375 -> 1553;
4375 -> 1648;
4375 -> 4374;
4375 -> 1657;
4375 -> 1547;
4375 -> 1548;
4375 -> 4360;
4375 -> 1555;
4375 -> 1552;
4376 -> 1672;
4377 -> 4376;
4377 -> 1567;
4378 -> 4377;
4378 -> 1569;
4378 -> 1567;
4379 -> 1565;
4379 -> 1599;
4379 -> 1668;
4379 -> 4378;
4379 -> 1677;
4379 -> 1593;
4379 -> 1594;
4379 -> 4364;
4379 -> 1601;
4379 -> 1598;
4380 -> 1613;
4381 -> 4380;
4381 -> 1434;
4382 -> 4381;
4382 -> 1436;
4382 -> 1434;
4383 -> 1632;
4384 -> 4383;
4384 -> 1472;
4385 -> 4384;
4385 -> 1474;
4385 -> 1472;
4386 -> 1470;
4386 -> 1502;
4386 -> 1628;
4386 -> 4385;
4386 -> 1637;
4386 -> 1498;
4386 -> 1499;
4386 -> 4371;
4386 -> 1509;
4386 -> 1501;
4387 -> 1652;
4388 -> 4387;
4388 -> 1521;
4389 -> 4388;
4389 -> 1523;
4389 -> 1521;
4390 -> 1519;
4390 -> 1553;
4390 -> 1648;
4390 -> 4389;
4390 -> 1657;
4390 -> 1547;
4390 -> 1548;
4390 -> 4375;
4390 -> 1555;
4390 -> 1552;
4391 -> 1672;
4392 -> 4391;
4392 -> 1567;
4393 -> 4392;
4393 -> 1569;
4393 -> 1567;
4394 -> 1565;
4394 -> 1599;
4394 -> 1668;
4394 -> 4393;
4394 -> 1677;
4394 -> 1593;
4394 -> 1594;
4394 -> 4379;
4394 -> 1601;
4394 -> 1598;
4395 -> 1613;
4396 -> 4395;
4396 -> 1434;
4397 -> 4396;
4397 -> 1436;
4397 -> 1434;
4398 -> 1632;
4399 -> 4398;
4399 -> 1472;
4400 -> 4399;
4400 -> 1474;
4400 -> 1472;
4401 -> 1470;
4401 -> 1502;
4401 -> 1628;
4401 -> 4400;
4401 -> 1637;
4401 -> 1498;
4401 -> 1499;
4401 -> 4386;
4401 -> 1509;
4401 -> 1501;
4402 -> 1652;
4403 -> 4402;
4403 -> 1521;
4404 -> 4403;
4404 -> 1523;
4404 -> 1521;
4405 -> 1519;
4405 -> 1553;
4405 -> 1648;
4405 -> 4404;
4405 -> 1657;
4405 -> 1547;
4405 -> 1548;
4405 -> 4390;
4405 -> 1555;
4405 -> 1552;
4406 -> 1672;
4407 -> 4406;
4407 -> 1567;
4408 -> 4407;
4408 -> 1569;
4408 -> 1567;
4409 -> 1565;
4409 -> 1599;
4409 -> 1668;
4409 -> 4408;
4409 -> 1677;
4409 -> 1593;
4409 -> 1594;
4409 -> 4394;
4409 -> 1601;
4409 -> 1598;
4410 -> 1613;
4411 -> 4410;
4411 -> 1434;
4412 -> 4411;
4412 -> 1436;
4412 -> 1434;
4413 -> 1632;
4414 -> 4413;
4414 -> 1472;
4415 -> 4414;
4415 -> 1474;
4415 -> 1472;
4416 -> 1470;
4416 -> 1502;
4416 -> 1628;
4416 -> 4415;
4416 -> 1637;
4416 -> 1498;
4416 -> 1499;
4416 -> 4401;
4416 -> 1509;
4416 -> 1501;
4417 -> 1652;
4418 -> 4417;
4418 -> 1521;
4419 -> 4418;
4419 -> 1523;
4419 -> 1521;
4420 -> 1519;
4420 -> 1553;
4420 -> 1648;
4420 -> 4419;
4420 -> 1657;
4420 -> 1547;
4420 -> 1548;
4420 -> 4405;
4420 -> 1555;
4420 -> 1552;
4421 -> 1672;
4422 -> 4421;
4422 -> 1567;
4423 -> 4422;
4423 -> 1569;
4423 -> 1567;
4424 -> 1565;
4424 -> 1599;
4424 -> 1668;
4424 -> 4423;
4424 -> 1677;
4424 -> 1593;
4424 -> 1594;
4424 -> 4409;
4424 -> 1601;
4424 -> 1598;
4425 -> 1613;
4426 -> 4425;
4426 -> 1434;
4427 -> 4426;
4427 -> 1436;
4427 -> 1434;
4428 -> 1632;
4429 -> 4428;
4429 -> 1472;
4430 -> 4429;
4430 -> 1474;
4430 -> 1472;
4431 -> 1470;
4431 -> 1502;
4431 -> 1628;
4431 -> 4430;
4431 -> 1637;
4431 -> 1498;
4431 -> 1499;
4431 -> 4416;
4431 -> 1509;
4431 -> 1501;
4432 -> 1652;
4433 -> 4432;
4433 -> 1521;
4434 -> 4433;
4434 -> 1523;
4434 -> 1521;
4435 -> 1519;
4435 -> 1553;
4435 -> 1648;
4435 -> 4434;
4435 -> 1657;
4435 -> 1547;
4435 -> 1548;
4435 -> 4420;
4435 -> 1555;
4435 -> 1552;
4436 -> 1672;
4437 -> 4436;
4437 -> 1567;
4438 -> 4437;
4438 -> 1569;
4438 -> 1567;
4439 -> 1565;
4439 -> 1599;
4439 -> 1668;
4439 -> 4438;
4439 -> 1677;
4439 -> 1593;
4439 -> 1594;
4439 -> 4424;
4439 -> 1601;
4439 -> 1598;
4440 -> 1613;
4441 -> 4440;
4441 -> 1434;
4442 -> 4441;
4442 -> 1436;
4442 -> 1434;
4443 -> 1632;
4444 -> 4443;
4444 -> 1472;
4445 -> 4444;
4445 -> 1474;
4445 -> 1472;
4446 -> 1470;
4446 -> 1502;
4446 -> 1628;
4446 -> 4445;
4446 -> 1637;
4446 -> 1498;
4446 -> 1499;
4446 -> 4431;
4446 -> 1509;
4446 -> 1501;
4447 -> 1652;
4448 -> 4447;
4448 -> 1521;
4449 -> 4448;
4449 -> 1523;
4449 -> 1521;
4450 -> 1519;
4450 -> 1553;
4450 -> 1648;
4450 -> 4449;
4450 -> 1657;
4450 -> 1547;
4450 -> 1548;
4450 -> 4435;
4450 -> 1555;
4450 -> 1552;
4451 -> 1672;
4452 -> 4451;
4452 -> 1567;
4453 -> 4452;
4453 -> 1569;
4453 -> 1567;
4454 -> 1565;
4454 -> 1599;
4454 -> 1668;
4454 -> 4453;
4454 -> 1677;
4454 -> 1593;
4454 -> 1594;
4454 -> 4439;
4454 -> 1601;
4454 -> 1598;
4455 -> 1613;
4456 -> 4455;
4456 -> 1434;
4457 -> 4456;
4457 -> 1436;
4457 -> 1434;
4458 -> 1632;
4459 -> 4458;
4459 -> 1472;
4460 -> 4459;
4460 -> 1474;
4460 -> 1472;
4461 -> 1470;
4461 -> 1502;
4461 -> 1628;
4461 -> 4460;
4461 -> 1637;
4461 -> 1498;
4461 -> 1499;
4461 -> 4446;
4461 -> 1509;
4461 -> 1501;
4462 -> 1652;
4463 -> 4462;
4463 -> 1521;
4464 -> 4463;
4464 -> 1523;
4464 -> 1521;
4465 -> 1519;
4465 -> 1553;
4465 -> 1648;
4465 -> 4464;
4465 -> 1657;
4465 -> 1547;
4465 -> 1548;
4465 -> 4450;
4465 -> 1555;
4465 -> 1552;
4466 -> 1672;
4467 -> 4466;
4467 -> 1567;
4468 -> 4467;
4468 -> 1569;
4468 -> 1567;
4469 -> 1565;
4469 -> 1599;
4469 -> 1668;
4469 -> 4468;
4469 -> 1677;
4469 -> 1593;
4469 -> 1594;
4469 -> 4454;
4469 -> 1601;
4469 -> 1598;
4470 -> 1613;
4471 -> 4470;
4471 -> 1434;
4472 -> 4471;
4472 -> 1436;
4472 -> 1434;
4473 -> 1632;
4474 -> 4473;
4474 -> 1472;
4475 -> 4474;
4475 -> 1474;
4475 -> 1472;
4476 -> 1470;
4476 -> 1502;
4476 -> 1628;
4476 -> 4475;
4476 -> 1637;
4476 -> 1498;
4476 -> 1499;
4476 -> 4461;
4476 -> 1509;
4476 -> 1501;
4477 -> 1652;
4478 -> 4477;
4478 -> 1521;
4479 -> 4478;
4479 -> 1523;
4479 -> 1521;
4480 -> 1519;
4480 -> 1553;
4480 -> 1648;
4480 -> 4479;
4480 -> 1657;
4480 -> 1547;
4480 -> 1548;
4480 -> 4465;
4480 -> 1555;
4480 -> 1552;
4481 -> 1672;
4482 -> 4481;
4482 -> 1567;
4483 -> 4482;
4483 -> 1569;
4483 -> 1567;
4484 -> 1565;
4484 -> 1599;
4484 -> 1668;
4484 -> 4483;
4484 -> 1677;
4484 -> 1593;
4484 -> 1594;
4484 -> 4469;
4484 -> 1601;
4484 -> 1598;
4485 -> 1613;
4486 -> 4485;
4486 -> 1434;
4487 -> 4486;
4487 -> 1436;
4487 -> 1434;
4488 -> 1632;
4489 -> 4488;
4489 -> 1472;
4490 -> 4489;
4490 -> 1474;
4490 -> 1472;
4491 -> 1470;
4491 -> 1502;
4491 -> 1628;
4491 -> 4490;
4491 -> 1637;
4491 -> 1498;
4491 -> 1499;
4491 -> 4476;
4491 -> 1509;
4491 -> 1501;
4492 -> 1652;
4493 -> 4492;
4493 -> 1521;
4494 -> 4493;
4494 -> 1523;
4494 -> 1521;
4495 -> 1519;
4495 -> 1553;
4495 -> 1648;
4495 -> 4494;
4495 -> 1657;
4495 -> 1547;
4495 -> 1548;
4495 -> 4480;
4495 -> 1555;
4495 -> 1552;
4496 -> 1672;
4497 -> 4496;
4497 -> 1567;
4498 -> 4497;
4498 -> 1569;
4498 -> 1567;
4499 -> 1565;
4499 -> 1599;
4499 -> 1668;
4499 -> 4498;
4499 -> 1677;
4499 -> 1593;
4499 -> 1594;
4499 -> 4484;
4499 -> 1601;
4499 -> 1598;
4500 -> 1613;
4501 -> 4500;
4501 -> 1434;
4502 -> 4501;
4502 -> 1436;
4502 -> 1434;
4503 -> 1632;
4504 -> 4503;
4504 -> 1472;
4505 -> 4504;
4505 -> 1474;
4505 -> 1472;
4506 -> 1470;
4506 -> 1502;
4506 -> 1628;
4506 -> 4505;
4506 -> 1637;
4506 -> 1498;
4506 -> 1499;
4506 -> 4491;
4506 -> 1509;
4506 -> 1501;
4507 -> 1652;
4508 -> 4507;
4508 -> 1521;
4509 -> 4508;
4509 -> 1523;
4509 -> 1521;
4510 -> 1519;
4510 -> 1553;
4510 -> 1648;
4510 -> 4509;
4510 -> 1657;
4510 -> 1547;
4510 -> 1548;
4510 -> 4495;
4510 -> 1555;
4510 -> 1552;
4511 -> 1672;
4512 -> 4511;
4512 -> 1567;
4513 -> 4512;
4513 -> 1569;
4513 -> 1567;
4514 -> 1565;
4514 -> 1599;
4514 -> 1668;
4514 -> 4513;
4514 -> 1677;
4514 -> 1593;
4514 -> 1594;
4514 -> 4499;
4514 -> 1601;
4514 -> 1598;
4515 -> 1613;
4516 -> 4515;
4516 -> 1434;
4517 -> 4516;
4517 -> 1436;
4517 -> 1434;
4518 -> 1632;
4519 -> 4518;
4519 -> 1472;
4520 -> 4519;
4520 -> 1474;
4520 -> 1472;
4521 -> 1470;
4521 -> 1502;
4521 -> 1628;
4521 -> 4520;
4521 -> 1637;
4521 -> 1498;
4521 -> 1499;
4521 -> 4506;
4521 -> 1509;
4521 -> 1501;
4522 -> 1652;
4523 -> 4522;
4523 -> 1521;
4524 -> 4523;
4524 -> 1523;
4524 -> 1521;
4525 -> 1519;
4525 -> 1553;
4525 -> 1648;
4525 -> 4524;
4525 -> 1657;
4525 -> 1547;
4525 -> 1548;
4525 -> 4510;
4525 -> 1555;
4525 -> 1552;
4526 -> 1672;
4527 -> 4526;
4527 -> 1567;
4528 -> 4527;
4528 -> 1569;
4528 -> 1567;
4529 -> 1565;
4529 -> 1599;
4529 -> 1668;
4529 -> 4528;
4529 -> 1677;
4529 -> 1593;
4529 -> 1594;
4529 -> 4514;
4529 -> 1601;
4529 -> 1598;
4530 -> 1613;
4531 -> 4530;
4531 -> 1434;
4532 -> 4531;
4532 -> 1436;
4532 -> 1434;
4533 -> 1632;
4534 -> 4533;
4534 -> 1472;
4535 -> 4534;
4535 -> 1474;
4535 -> 1472;
4536 -> 1470;
4536 -> 1502;
4536 -> 1628;
4536 -> 4535;
4536 -> 1637;
4536 -> 1498;
4536 -> 1499;
4536 -> 4521;
4536 -> 1509;
4536 -> 1501;
4537 -> 1652;
4538 -> 4537;
4538 -> 1521;
4539 -> 4538;
4539 -> 1523;
4539 -> 1521;
4540 -> 1519;
4540 -> 1553;
4540 -> 1648;
4540 -> 4539;
4540 -> 1657;
4540 -> 1547;
4540 -> 1548;
4540 -> 4525;
4540 -> 1555;
4540 -> 1552;
4541 -> 1672;
4542 -> 4541;
4542 -> 1567;
4543 -> 4542;
4543 -> 1569;
4543 -> 1567;
4544 -> 1565;
4544 -> 1599;
4544 -> 1668;
4544 -> 4543;
4544 -> 1677;
4544 -> 1593;
4544 -> 1594;
4544 -> 4529;
4544 -> 1601;
4544 -> 1598;
4545 -> 1613;
4546 -> 4545;
4546 -> 1434;
4547 -> 4546;
4547 -> 1436;
4547 -> 1434;
4548 -> 1632;
4549 -> 4548;
4549 -> 1472;
4550 -> 4549;
4550 -> 1474;
4550 -> 1472;
4551 -> 1470;
4551 -> 1502;
4551 -> 1628;
4551 -> 4550;
4551 -> 1637;
4551 -> 1498;
4551 -> 1499;
4551 -> 4536;
4551 -> 1509;
4551 -> 1501;
4552 -> 1652;
4553 -> 4552;
4553 -> 1521;
4554 -> 4553;
4554 -> 1523;
4554 -> 1521;
4555 -> 1519;
4555 -> 1553;
4555 -> 1648;
4555 -> 4554;
4555 -> 1657;
4555 -> 1547;
4555 -> 1548;
4555 -> 4540;
4555 -> 1555;
4555 -> 1552;
4556 -> 1672;
4557 -> 4556;
4557 -> 1567;
4558 -> 4557;
4558 -> 1569;
4558 -> 1567;
4559 -> 1565;
4559 -> 1599;
4559 -> 1668;
4559 -> 4558;
4559 -> 1677;
4559 -> 1593;
4559 -> 1594;
4559 -> 4544;
4559 -> 1601;
4559 -> 1598;
4560 -> 1613;
4561 -> 4560;
4561 -> 1434;
4562 -> 4561;
4562 -> 1436;
4562 -> 1434;
4563 -> 1632;
4564 -> 4563;
4564 -> 1472;
4565 -> 4564;
4565 -> 1474;
4565 -> 1472;
4566 -> 1470;
4566 -> 1502;
4566 -> 1628;
4566 -> 4565;
4566 -> 1637;
4566 -> 1498;
4566 -> 1499;
4566 -> 4551;
4566 -> 1509;
4566 -> 1501;
4567 -> 1652;
4568 -> 4567;
4568 -> 1521;
4569 -> 4568;
4569 -> 1523;
4569 -> 1521;
4570 -> 1519;
4570 -> 1553;
4570 -> 1648;
4570 -> 4569;
4570 -> 1657;
4570 -> 1547;
4570 -> 1548;
4570 -> 4555;
4570 -> 1555;
4570 -> 1552;
4571 -> 1672;
4572 -> 4571;
4572 -> 1567;
4573 -> 4572;
4573 -> 1569;
4573 -> 1567;
4574 -> 1565;
4574 -> 1599;
4574 -> 1668;
4574 -> 4573;
4574 -> 1677;
4574 -> 1593;
4574 -> 1594;
4574 -> 4559;
4574 -> 1601;
4574 -> 1598;
4575 -> 1613;
4576 -> 4575;
4576 -> 1434;
4577 -> 4576;
4577 -> 1436;
4577 -> 1434;
4578 -> 1632;
4579 -> 4578;
4579 -> 1472;
4580 -> 4579;
4580 -> 1474;
4580 -> 1472;
4581 -> 1470;
4581 -> 1502;
4581 -> 1628;
4581 -> 4580;
4581 -> 1637;
4581 -> 1498;
4581 -> 1499;
4581 -> 4566;
4581 -> 1509;
4581 -> 1501;
4582 -> 1652;
4583 -> 4582;
4583 -> 1521;
4584 -> 4583;
4584 -> 1523;
4584 -> 1521;
4585 -> 1519;
4585 -> 1553;
4585 -> 1648;
4585 -> 4584;
4585 -> 1657;
4585 -> 1547;
4585 -> 1548;
4585 -> 4570;
4585 -> 1555;
4585 -> 1552;
4586 -> 1672;
4587 -> 4586;
4587 -> 1567;
4588 -> 4587;
4588 -> 1569;
4588 -> 1567;
4589 -> 1565;
4589 -> 1599;
4589 -> 1668;
4589 -> 4588;
4589 -> 1677;
4589 -> 1593;
4589 -> 1594;
4589 -> 4574;
4589 -> 1601;
4589 -> 1598;
4590 -> 1613;
4591 -> 4590;
4591 -> 1434;
4592 -> 4591;
4592 -> 1436;
4592 -> 1434;
4593 -> 1632;
4594 -> 4593;
4594 -> 1472;
4595 -> 4594;
4595 -> 1474;
4595 -> 1472;
4596 -> 1470;
4596 -> 1502;
4596 -> 1628;
4596 -> 4595;
4596 -> 1637;
4596 -> 1498;
4596 -> 1499;
4596 -> 4581;
4596 -> 1509;
4596 -> 1501;
4597 -> 1652;
4598 -> 4597;
4598 -> 1521;
4599 -> 4598;
4599 -> 1523;
4599 -> 1521;
4600 -> 1519;
4600 -> 1553;
4600 -> 1648;
4600 -> 4599;
4600 -> 1657;
4600 -> 1547;
4600 -> 1548;
4600 -> 4585;
4600 -> 1555;
4600 -> 1552;
4601 -> 1672;
4602 -> 4601;
4602 -> 1567;
4603 -> 4602;
4603 -> 1569;
4603 -> 1567;
4604 -> 1565;
4604 -> 1599;
4604 -> 1668;
4604 -> 4603;
4604 -> 1677;
4604 -> 1593;
4604 -> 1594;
4604 -> 4589;
4604 -> 1601;
4604 -> 1598;
4605 -> 1613;
4606 -> 4605;
4606 -> 1434;
4607 -> 4606;
4607 -> 1436;
4607 -> 1434;
4608 -> 1632;
4609 -> 4608;
4609 -> 1472;
4610 -> 4609;
4610 -> 1474;
4610 -> 1472;
4611 -> 1470;
4611 -> 1502;
4611 -> 1628;
4611 -> 4610;
4611 -> 1637;
4611 -> 1498;
4611 -> 1499;
4611 -> 4596;
4611 -> 1509;
4611 -> 1501;
4612 -> 1652;
4613 -> 4612;
4613 -> 1521;
4614 -> 4613;
4614 -> 1523;
4614 -> 1521;
4615 -> 1519;
4615 -> 1553;
4615 -> 1648;
4615 -> 4614;
4615 -> 1657;
4615 -> 1547;
4615 -> 1548;
4615 -> 4600;
4615 -> 1555;
4615 -> 1552;
4616 -> 1672;
4617 -> 4616;
4617 -> 1567;
4618 -> 4617;
4618 -> 1569;
4618 -> 1567;
4619 -> 1565;
4619 -> 1599;
4619 -> 1668;
4619 -> 4618;
4619 -> 1677;
4619 -> 1593;
4619 -> 1594;
4619 -> 4604;
4619 -> 1601;
4619 -> 1598;
4620 -> 1613;
4621 -> 4620;
4621 -> 1434;
4622 -> 4621;
4622 -> 1436;
4622 -> 1434;
4623 -> 1632;
4624 -> 4623;
4624 -> 1472;
4625 -> 4624;
4625 -> 1474;
4625 -> 1472;
4626 -> 1470;
4626 -> 1502;
4626 -> 1628;
4626 -> 4625;
4626 -> 1637;
4626 -> 1498;
4626 -> 1499;
4626 -> 4611;
4626 -> 1509;
4626 -> 1501;
4627 -> 1652;
4628 -> 4627;
4628 -> 1521;
4629 -> 4628;
4629 -> 1523;
4629 -> 1521;
4630 -> 1519;
4630 -> 1553;
4630 -> 1648;
4630 -> 4629;
4630 -> 1657;
4630 -> 1547;
4630 -> 1548;
4630 -> 4615;
4630 -> 1555;
4630 -> 1552;
4631 -> 1672;
4632 -> 4631;
4632 -> 1567;
4633 -> 4632;
4633 -> 1569;
4633 -> 1567;
4634 -> 1565;
4634 -> 1599;
4634 -> 1668;
4634 -> 4633;
4634 -> 1677;
4634 -> 1593;
4634 -> 1594;
4634 -> 4619;
4634 -> 1601;
4634 -> 1598;
4635 -> 1613;
4636 -> 4635;
4636 -> 1434;
4637 -> 4636;
4637 -> 1436;
4637 -> 1434;
4638 -> 1632;
4639 -> 4638;
4639 -> 1472;
4640 -> 4639;
4640 -> 1474;
4640 -> 1472;
4641 -> 1470;
4641 -> 1502;
4641 -> 1628;
4641 -> 4640;
4641 -> 1637;
4641 -> 1498;
4641 -> 1499;
4641 -> 4626;
4641 -> 1509;
4641 -> 1501;
4642 -> 1652;
4643 -> 4642;
4643 -> 1521;
4644 -> 4643;
4644 -> 1523;
4644 -> 1521;
4645 -> 1519;
4645 -> 1553;
4645 -> 1648;
4645 -> 4644;
4645 -> 1657;
4645 -> 1547;
4645 -> 1548;
4645 -> 4630;
4645 -> 1555;
4645 -> 1552;
4646 -> 1672;
4647 -> 4646;
4647 -> 1567;
4648 -> 4647;
4648 -> 1569;
4648 -> 1567;
4649 -> 1565;
4649 -> 1599;
4649 -> 1668;
4649 -> 4648;
4649 -> 1677;
4649 -> 1593;
4649 -> 1594;
4649 -> 4634;
4649 -> 1601;
4649 -> 1598;
4650 -> 1613;
4651 -> 4650;
4651 -> 1434;
4652 -> 4651;
4652 -> 1436;
4652 -> 1434;
4653 -> 1632;
4654 -> 4653;
4654 -> 1472;
4655 -> 4654;
4655 -> 1474;
4655 -> 1472;
4656 -> 1470;
4656 -> 1502;
4656 -> 1628;
4656 -> 4655;
4656 -> 1637;
4656 -> 1498;
4656 -> 1499;
4656 -> 4641;
4656 -> 1509;
4656 -> 1501;
4657 -> 1652;
4658 -> 4657;
4658 -> 1521;
4659 -> 4658;
4659 -> 1523;
4659 -> 1521;
4660 -> 1519;
4660 -> 1553;
4660 -> 1648;
4660 -> 4659;
4660 -> 1657;
4660 -> 1547;
4660 -> 1548;
4660 -> 4645;
4660 -> 1555;
4660 -> 1552;
4661 -> 1672;
4662 -> 4661;
4662 -> 1567;
4663 -> 4662;
4663 -> 1569;
4663 -> 1567;
4664 -> 1565;
4664 -> 1599;
4664 -> 1668;
4664 -> 4663;
4664 -> 1677;
4664 -> 1593;
4664 -> 1594;
4664 -> 4649;
4664 -> 1601;
4664 -> 1598;
4665 -> 1613;
4666 -> 4665;
4666 -> 1434;
4667 -> 4666;
4667 -> 1436;
4667 -> 1434;
4668 -> 1632;
4669 -> 4668;
4669 -> 1472;
4670 -> 4669;
4670 -> 1474;
4670 -> 1472;
4671 -> 1470;
4671 -> 1502;
4671 -> 1628;
4671 -> 4670;
4671 -> 1637;
4671 -> 1498;
4671 -> 1499;
4671 -> 4656;
4671 -> 1509;
4671 -> 1501;
4672 -> 1652;
4673 -> 4672;
4673 -> 1521;
4674 -> 4673;
4674 -> 1523;
4674 -> 1521;
4675 -> 1519;
4675 -> 1553;
4675 -> 1648;
4675 -> 4674;
4675 -> 1657;
4675 -> 1547;
4675 -> 1548;
4675 -> 4660;
4675 -> 1555;
4675 -> 1552;
4676 -> 1672;
4677 -> 4676;
4677 -> 1567;
4678 -> 4677;
4678 -> 1569;
4678 -> 1567;
4679 -> 1565;
4679 -> 1599;
4679 -> 1668;
4679 -> 4678;
4679 -> 1677;
4679 -> 1593;
4679 -> 1594;
4679 -> 4664;
4679 -> 1601;
4679 -> 1598;
4680 -> 1613;
4681 -> 4680;
4681 -> 1434;
4682 -> 4681;
4682 -> 1436;
4682 -> 1434;
4683 -> 1632;
4684 -> 4683;
4684 -> 1472;
4685 -> 4684;
4685 -> 1474;
4685 -> 1472;
4686 -> 1470;
4686 -> 1502;
4686 -> 1628;
4686 -> 4685;
4686 -> 1637;
4686 -> 1498;
4686 -> 1499;
4686 -> 4671;
4686 -> 1509;
4686 -> 1501;
4687 -> 1652;
4688 -> 4687;
4688 -> 1521;
4689 -> 4688;
4689 -> 1523;
4689 -> 1521;
4690 -> 1519;
4690 -> 1553;
4690 -> 1648;
4690 -> 4689;
4690 -> 1657;
4690 -> 1547;
4690 -> 1548;
4690 -> 4675;
4690 -> 1555;
4690 -> 1552;
4691 -> 1672;
4692 -> 4691;
4692 -> 1567;
4693 -> 4692;
4693 -> 1569;
4693 -> 1567;
4694 -> 1565;
4694 -> 1599;
4694 -> 1668;
4694 -> 4693;
4694 -> 1677;
4694 -> 1593;
4694 -> 1594;
4694 -> 4679;
4694 -> 1601;
4694 -> 1598;
4695 -> 1613;
4696 -> 4695;
4696 -> 1434;
4697 -> 4696;
4697 -> 1436;
4697 -> 1434;
4698 -> 1632;
4699 -> 4698;
4699 -> 1472;
4700 -> 4699;
4700 -> 1474;
4700 -> 1472;
4701 -> 1470;
4701 -> 1502;
4701 -> 1628;
4701 -> 4700;
4701 -> 1637;
4701 -> 1498;
4701 -> 1499;
4701 -> 4686;
4701 -> 1509;
4701 -> 1501;
4702 -> 1652;
4703 -> 4702;
4703 -> 1521;
4704 -> 4703;
4704 -> 1523;
4704 -> 1521;
4705 -> 1519;
4705 -> 1553;
4705 -> 1648;
4705 -> 4704;
4705 -> 1657;
4705 -> 1547;
4705 -> 1548;
4705 -> 4690;
4705 -> 1555;
4705 -> 1552;
4706 -> 1672;
4707 -> 4706;
4707 -> 1567;
4708 -> 4707;
4708 -> 1569;
4708 -> 1567;
4709 -> 1565;
4709 -> 1599;
4709 -> 1668;
4709 -> 4708;
4709 -> 1677;
4709 -> 1593;
4709 -> 1594;
4709 -> 4694;
4709 -> 1601;
4709 -> 1598;
4710 -> 1613;
4711 -> 4710;
4711 -> 1434;
4712 -> 4711;
4712 -> 1436;
4712 -> 1434;
4713 -> 1632;
4714 -> 4713;
4714 -> 1472;
4715 -> 4714;
4715 -> 1474;
4715 -> 1472;
4716 -> 1470;
4716 -> 1502;
4716 -> 1628;
4716 -> 4715;
4716 -> 1637;
4716 -> 1498;
4716 -> 1499;
4716 -> 4701;
4716 -> 1509;
4716 -> 1501;
4717 -> 1652;
4718 -> 4717;
4718 -> 1521;
4719 -> 4718;
4719 -> 1523;
4719 -> 1521;
4720 -> 1519;
4720 -> 1553;
4720 -> 1648;
4720 -> 4719;
4720 -> 1657;
4720 -> 1547;
4720 -> 1548;
4720 -> 4705;
4720 -> 1555;
4720 -> 1552;
4721 -> 1672;
4722 -> 4721;
4722 -> 1567;
4723 -> 4722;
4723 -> 1569;
4723 -> 1567;
4724 -> 1565;
4724 -> 1599;
4724 -> 1668;
4724 -> 4723;
4724 -> 1677;
4724 -> 1593;
4724 -> 1594;
4724 -> 4709;
4724 -> 1601;
4724 -> 1598;
4725 -> 1613;
4726 -> 4725;
4726 -> 1434;
4727 -> 4726;
4727 -> 1436;
4727 -> 1434;
4728 -> 1632;
4729 -> 4728;
4729 -> 1472;
4730 -> 4729;
4730 -> 1474;
4730 -> 1472;
4731 -> 1470;
4731 -> 1502;
4731 -> 1628;
4731 -> 4730;
4731 -> 1637;
4731 -> 1498;
4731 -> 1499;
4731 -> 4716;
4731 -> 1509;
4731 -> 1501;
4732 -> 1652;
4733 -> 4732;
4733 -> 1521;
4734 -> 4733;
4734 -> 1523;
4734 -> 1521;
4735 -> 1519;
4735 -> 1553;
4735 -> 1648;
4735 -> 4734;
4735 -> 1657;
4735 -> 1547;
4735 -> 1548;
4735 -> 4720;
4735 -> 1555;
4735 -> 1552;
4736 -> 1672;
4737 -> 4736;
4737 -> 1567;
4738 -> 4737;
4738 -> 1569;
4738 -> 1567;
4739 -> 1565;
4739 -> 1599;
4739 -> 1668;
4739 -> 4738;
4739 -> 1677;
4739 -> 1593;
4739 -> 1594;
4739 -> 4724;
4739 -> 1601;
4739 -> 1598;
4740 -> 1613;
4741 -> 4740;
4741 -> 1434;
4742 -> 4741;
4742 -> 1436;
4742 -> 1434;
4743 -> 1632;
4744 -> 4743;
4744 -> 1472;
4745 -> 4744;
4745 -> 1474;
4745 -> 1472;
4746 -> 1470;
4746 -> 1502;
4746 -> 1628;
4746 -> 4745;
4746 -> 1637;
4746 -> 1498;
4746 -> 1499;
4746 -> 4731;
4746 -> 1509;
4746 -> 1501;
4747 -> 1652;
4748 -> 4747;
4748 -> 1521;
4749 -> 4748;
4749 -> 1523;
4749 -> 1521;
4750 -> 1519;
4750 -> 1553;
4750 -> 1648;
4750 -> 4749;
4750 -> 1657;
4750 -> 1547;
4750 -> 1548;
4750 -> 4735;
4750 -> 1555;
4750 -> 1552;
4751 -> 1672;
4752 -> 4751;
4752 -> 1567;
4753 -> 4752;
4753 -> 1569;
4753 -> 1567;
4754 -> 1565;
4754 -> 1599;
4754 -> 1668;
4754 -> 4753;
4754 -> 1677;
4754 -> 1593;
4754 -> 1594;
4754 -> 4739;
4754 -> 1601;
4754 -> 1598;
4755 -> 1613;
4756 -> 4755;
4756 -> 1434;
4757 -> 4756;
4757 -> 1436;
4757 -> 1434;
4758 -> 1632;
4759 -> 4758;
4759 -> 1472;
4760 -> 4759;
4760 -> 1474;
4760 -> 1472;
4761 -> 1470;
4761 -> 1502;
4761 -> 1628;
4761 -> 4760;
4761 -> 1637;
4761 -> 1498;
4761 -> 1499;
4761 -> 4746;
4761 -> 1509;
4761 -> 1501;
4762 -> 1652;
4763 -> 4762;
4763 -> 1521;
4764 -> 4763;
4764 -> 1523;
4764 -> 1521;
4765 -> 1519;
4765 -> 1553;
4765 -> 1648;
4765 -> 4764;
4765 -> 1657;
4765 -> 1547;
4765 -> 1548;
4765 -> 4750;
4765 -> 1555;
4765 -> 1552;
4766 -> 1672;
4767 -> 4766;
4767 -> 1567;
4768 -> 4767;
4768 -> 1569;
4768 -> 1567;
4769 -> 1565;
4769 -> 1599;
4769 -> 1668;
4769 -> 4768;
4769 -> 1677;
4769 -> 1593;
4769 -> 1594;
4769 -> 4754;
4769 -> 1601;
4769 -> 1598;
4770 -> 1613;
4771 -> 4770;
4771 -> 1434;
4772 -> 4771;
4772 -> 1436;
4772 -> 1434;
4773 -> 1632;
4774 -> 4773;
4774 -> 1472;
4775 -> 4774;
4775 -> 1474;
4775 -> 1472;
4776 -> 1470;
4776 -> 1502;
4776 -> 1628;
4776 -> 4775;
4776 -> 1637;
4776 -> 1498;
4776 -> 1499;
4776 -> 4761;
4776 -> 1509;
4776 -> 1501;
4777 -> 1652;
4778 -> 4777;
4778 -> 1521;
4779 -> 4778;
4779 -> 1523;
4779 -> 1521;
4780 -> 1519;
4780 -> 1553;
4780 -> 1648;
4780 -> 4779;
4780 -> 1657;
4780 -> 1547;
4780 -> 1548;
4780 -> 4765;
4780 -> 1555;
4780 -> 1552;
4781 -> 1672;
4782 -> 4781;
4782 -> 1567;
4783 -> 4782;
4783 -> 1569;
4783 -> 1567;
4784 -> 1565;
4784 -> 1599;
4784 -> 1668;
4784 -> 4783;
4784 -> 1677;
4784 -> 1593;
4784 -> 1594;
4784 -> 4769;
4784 -> 1601;
4784 -> 1598;
4785 -> 1613;
4786 -> 4785;
4786 -> 1434;
4787 -> 4786;
4787 -> 1436;
4787 -> 1434;
4788 -> 1632;
4789 -> 4788;
4789 -> 1472;
4790 -> 4789;
4790 -> 1474;
4790 -> 1472;
4791 -> 1470;
4791 -> 1502;
4791 -> 1628;
4791 -> 4790;
4791 -> 1637;
4791 -> 1498;
4791 -> 1499;
4791 -> 4776;
4791 -> 1509;
4791 -> 1501;
4792 -> 1652;
4793 -> 4792;
4793 -> 1521;
4794 -> 4793;
4794 -> 1523;
4794 -> 1521;
4795 -> 1519;
4795 -> 1553;
4795 -> 1648;
4795 -> 4794;
4795 -> 1657;
4795 -> 1547;
4795 -> 1548;
4795 -> 4780;
4795 -> 1555;
4795 -> 1552;
4796 -> 1672;
4797 -> 4796;
4797 -> 1567;
4798 -> 4797;
4798 -> 1569;
4798 -> 1567;
4799 -> 1565;
4799 -> 1599;
4799 -> 1668;
4799 -> 4798;
4799 -> 1677;
4799 -> 1593;
4799 -> 1594;
4799 -> 4784;
4799 -> 1601;
4799 -> 1598;
4800 -> 1613;
4801 -> 4800;
4801 -> 1434;
4802 -> 4801;
4802 -> 1436;
4802 -> 1434;
4803 -> 1632;
4804 -> 4803;
4804 -> 1472;
4805 -> 4804;
4805 -> 1474;
4805 -> 1472;
4806 -> 1470;
4806 -> 1502;
4806 -> 1628;
4806 -> 4805;
4806 -> 1637;
4806 -> 1498;
4806 -> 1499;
4806 -> 4791;
4806 -> 1509;
4806 -> 1501;
4807 -> 1652;
4808 -> 4807;
4808 -> 1521;
4809 -> 4808;
4809 -> 1523;
4809 -> 1521;
4810 -> 1519;
4810 -> 1553;
4810 -> 1648;
4810 -> 4809;
4810 -> 1657;
4810 -> 1547;
4810 -> 1548;
4810 -> 4795;
4810 -> 1555;
4810 -> 1552;
4811 -> 1672;
4812 -> 4811;
4812 -> 1567;
4813 -> 4812;
4813 -> 1569;
4813 -> 1567;
4814 -> 1565;
4814 -> 1599;
4814 -> 1668;
4814 -> 4813;
4814 -> 1677;
4814 -> 1593;
4814 -> 1594;
4814 -> 4799;
4814 -> 1601;
4814 -> 1598;
4815 -> 1613;
4816 -> 4815;
4816 -> 1434;
4817 -> 4816;
4817 -> 1436;
4817 -> 1434;
4818 -> 1632;
4819 -> 4818;
4819 -> 1472;
4820 -> 4819;
4820 -> 1474;
4820 -> 1472;
4821 -> 1470;
4821 -> 1502;
4821 -> 1628;
4821 -> 4820;
4821 -> 1637;
4821 -> 1498;
4821 -> 1499;
4821 -> 4806;
4821 -> 1509;
4821 -> 1501;
4822 -> 1652;
4823 -> 4822;
4823 -> 1521;
4824 -> 4823;
4824 -> 1523;
4824 -> 1521;
4825 -> 1519;
4825 -> 1553;
4825 -> 1648;
4825 -> 4824;
4825 -> 1657;
4825 -> 1547;
4825 -> 1548;
4825 -> 4810;
4825 -> 1555;
4825 -> 1552;
4826 -> 1672;
4827 -> 4826;
4827 -> 1567;
4828 -> 4827;
4828 -> 1569;
4828 -> 1567;
4829 -> 1565;
4829 -> 1599;
4829 -> 1668;
4829 -> 4828;
4829 -> 1677;
4829 -> 1593;
4829 -> 1594;
4829 -> 4814;
4829 -> 1601;
4829 -> 1598;
4830 -> 1408;
4830 -> 1406;
4831 -> 1407;
4831 -> 1406;
4832 -> 1409;
4832 -> 1406;
4833 -> 1406;
4834 -> 4830;
4834 -> 4833;
4835 -> 4831;
4835 -> 4833;
4836 -> 4832;
4836 -> 4833;
4837 -> 4834;
4837 -> 1411;
4837 -> 4833;
4838 -> 4833;
4839 -> 4835;
4839 -> 4838;
4839 -> 4833;
4840 -> 4839;
4841 -> 4836;
4841 -> 4840;
4841 -> 4839;
4842 -> 4836;
4842 -> 408;
4842 -> 4841;
4843 -> 1423;
4843 -> 1422;
4843 -> 4834;
4843 -> 4842;
4844 -> 1387;
4845 -> 1391;
4845 -> 4844;
4845 -> 1387;
4846 -> 4843;
4846 -> 1387;
4847 -> 4846;
4847 -> 1155;
4848 -> 1155;
4849 -> 4847;
4849 -> 4848;
4850 -> 1144;
4850 -> 4848;
4851 -> 4848;
4852 -> 4849;
4852 -> 4851;
4852 -> 4848;
4853 -> 4850;
4853 -> 1115;
4853 -> 1151;
4853 -> 1150;
4853 -> 4848;
4854 -> 4850;
4854 -> 1151;
4854 -> 1150;
4854 -> 1115;
4854 -> 4848;
4855 -> 4849;
4855 -> 4854;
4855 -> 4848;
4856 -> 4850;
4856 -> 1115;
4856 -> 4848;
4857 -> 1155;
4858 -> 1155;
4859 -> 4846;
4859 -> 4858;
4860 -> 4859;
4860 -> 4858;
4861 -> 4860;
4861 -> 1155;
4862 -> 1395;
4863 -> 1395;
4864 -> 4863;
4864 -> 1395;
4865 -> 1395;
4866 -> 1395;
4867 -> 1395;
4868 -> 1395;
4869 -> 1395;
4870 -> 1395;
4871 -> 4865;
4871 -> 1395;
4872 -> 4866;
4872 -> 1395;
4873 -> 4867;
4873 -> 1395;
4874 -> 4868;
4874 -> 1395;
4875 -> 4870;
4875 -> 4864;
4875 -> 4871;
4875 -> 4872;
4875 -> 4873;
4875 -> 4874;
4875 -> 1395;
4876 -> 1395;
4877 -> 4875;
4877 -> 4876;
4877 -> 1395;
4878 -> 4869;
4878 -> 4875;
4878 -> 4877;
4879 -> 4877;
4880 -> 4878;
4880 -> 4879;
4881 -> 4879;
4882 -> 4880;
4882 -> 4878;
4882 -> 4881;
4883 -> 4882;
4883 -> 4879;
4884 -> 4879;
4885 -> 4880;
4885 -> 4878;
4885 -> 4884;
4886 -> 4885;
4886 -> 4879;
4887 -> 4879;
4888 -> 4886;
4888 -> 4887;
4889 -> 4880;
4889 -> 4878;
4889 -> 4887;
4890 -> 4879;
4891 -> 4879;
4892 -> 4880;
4892 -> 4891;
4893 -> 4892;
4893 -> 4878;
4893 -> 4888;
4893 -> 4891;
4894 -> 4891;
4895 -> 4892;
4895 -> 4893;
4895 -> 4894;
4896 -> 4895;
4896 -> 4891;
4897 -> 4891;
4898 -> 4897;
4898 -> 4891;
4899 -> 4891;
4900 -> 4891;
4901 -> 4893;
4901 -> 4891;
4902 -> 4893;
4903 -> 4893;
4903 -> 4891;
4904 -> 4903;
4905 -> 4891;
4906 -> 4893;
4906 -> 4891;
4907 -> 4891;
4908 -> 4906;
4908 -> 4907;
4909 -> 4907;
4910 -> 4907;
4911 -> 4908;
4911 -> 4910;
4911 -> 4907;
4912 -> 4911;
4913 -> 4909;
4913 -> 4907;
4914 -> 4913;
4914 -> 4891;
4915 -> 4891;
4916 -> 4914;
4916 -> 4915;
4917 -> 4892;
4917 -> 4915;
4918 -> 4915;
4919 -> 4917;
4919 -> 4893;
4919 -> 4918;
4919 -> 4915;
4920 -> 4919;
4921 -> 4920;
4921 -> 4891;
4922 -> 4891;
4923 -> 4893;
4923 -> 4891;
4924 -> 4921;
4924 -> 4891;
4925 -> 4892;
4925 -> 4891;
4926 -> 4923;
4926 -> 4893;
4926 -> 0;
4926 -> 4891;
4927 -> 4891;
4928 -> 4923;
4928 -> 4893;
4928 -> 4891;
4929 -> 4923;
4929 -> 4893;
4929 -> 4928;
4930 -> 4923;
4930 -> 4893;
4930 -> 4929;
4931 -> 4929;
4932 -> 4930;
4932 -> 4931;
4933 -> 4932;
4933 -> 0;
4933 -> 4931;
4934 -> 4893;
4934 -> 4929;
4935 -> 4923;
4935 -> 4893;
4935 -> 4929;
4936 -> 4929;
4937 -> 4934;
4937 -> 4936;
4938 -> 4935;
4938 -> 4936;
4939 -> 4934;
4939 -> 4936;
4940 -> 4938;
4940 -> 4936;
4941 -> 4937;
4941 -> 4936;
4942 -> 4939;
4942 -> 4936;
4943 -> 4936;
4944 -> 4940;
4944 -> 4943;
4945 -> 4941;
4945 -> 4943;
4946 -> 4942;
4946 -> 4943;
4947 -> 4944;
4947 -> 1411;
4947 -> 4943;
4948 -> 4943;
4949 -> 4945;
4949 -> 4948;
4949 -> 4943;
4950 -> 4949;
4951 -> 4946;
4951 -> 4950;
4951 -> 4949;
4952 -> 1415;
4952 -> 1414;
4952 -> 4944;
4952 -> 4951;
4953 -> 4891;
4954 -> 4924;
4954 -> 4953;
4954 -> 4891;
4955 -> 4952;
4955 -> 4891;
4956 -> 4955;
4956 -> 4879;
4957 -> 4883;
4957 -> 4956;
4957 -> 4879;
4958 -> 4956;
4958 -> 4879;
4959 -> 4865;
4959 -> 4877;
4960 -> 4866;
4960 -> 4877;
4961 -> 4867;
4961 -> 4877;
4962 -> 4868;
4962 -> 4877;
4963 -> 4958;
4963 -> 4877;
4964 -> 4958;
4964 -> 1395;
4965 -> 1395;
4965 -> 4964;
4965 -> 4963;
4966 -> 4965;
4966 -> 1155;
4967 -> 4966;
4967 -> 4848;
4968 -> 4967;
4968 -> 4851;
4968 -> 4848;
4969 -> 4850;
4969 -> 4856;
4969 -> 1151;
4969 -> 1150;
4969 -> 4848;
4970 -> 4850;
4970 -> 1151;
4970 -> 1150;
4970 -> 4856;
4970 -> 4848;
4971 -> 4967;
4971 -> 4970;
4971 -> 4848;
4972 -> 4965;
4972 -> 4858;
4973 -> 4972;
4973 -> 4965;
4973 -> 4858;
4974 -> 4973;
4974 -> 1155;
4975 -> 4965;
4976 -> 4965;
4977 -> 4976;
4977 -> 4965;
4978 -> 4965;
4979 -> 4978;
4979 -> 4965;
4980 -> 4978;
4980 -> 4965;
4981 -> 4980;
4981 -> 4965;
4982 -> 4965;
4983 -> 4965;
4984 -> 4965;
4985 -> 4965;
4986 -> 4985;
4987 -> 4965;
4988 -> 4978;
4989 -> 4978;
4990 -> 4978;
4990 -> 1055;
4991 -> 0;
4991 -> 4978;
4992 -> 4978;
4993 -> 4992;
4993 -> 4978;
4994 -> 0;
4994 -> 4993;
4995 -> 4978;
4995 -> 4994;
4995 -> 4991;
4996 -> 4995;
4996 -> 0;
4996 -> 4978;
4997 -> 0;
4997 -> 4978;
4997 -> 4996;
4998 -> 0;
4998 -> 4978;
4998 -> 4996;
4999 -> 4978;
4999 -> 4995;
4999 -> 4997;
4999 -> 0;
5000 -> 4978;
5000 -> 4995;
5000 -> 4997;
5000 -> 4998;
5000 -> 4965;
5001 -> 4978;
5001 -> 4965;
5002 -> 4965;
5003 -> 5001;
5003 -> 5002;
5004 -> 5002;
5005 -> 5002;
5006 -> 5003;
5006 -> 5005;
5006 -> 5002;
5007 -> 5006;
5008 -> 5007;
5008 -> 5003;
5008 -> 5000;
5008 -> 5006;
5009 -> 5004;
5009 -> 5002;
5010 -> 5009;
5010 -> 4965;
5011 -> 4965;
5012 -> 5010;
5012 -> 5011;
5013 -> 4965;
5013 -> 5011;
5014 -> 5011;
5015 -> 5013;
5015 -> 5000;
5015 -> 5014;
5015 -> 5011;
5016 -> 5015;
5017 -> 5016;
5017 -> 4965;
5018 -> 4965;
5019 -> 4965;
5020 -> 5019;
5020 -> 4965;
5021 -> 5000;
5021 -> 4965;
5022 -> 5000;
5023 -> 5000;
5023 -> 4965;
5024 -> 5023;
5025 -> 5017;
5025 -> 4965;
5026 -> 4965;
5027 -> 5000;
5027 -> 0;
5027 -> 4965;
5028 -> 4965;
5029 -> 5000;
5029 -> 5028;
5029 -> 4965;
5030 -> 4965;
5031 -> 5000;
5032 -> 5000;
5033 -> 5031;
5033 -> 5032;
5034 -> 5031;
5034 -> 5032;
5035 -> 5031;
5035 -> 5032;
5036 -> 5031;
5036 -> 5032;
5037 -> 5031;
5037 -> 5032;
5038 -> 5033;
5038 -> 5032;
5039 -> 5034;
5039 -> 5032;
5040 -> 5035;
5040 -> 5032;
5041 -> 5036;
5041 -> 5032;
5042 -> 5037;
5042 -> 5032;
5043 -> 5032;
5044 -> 5038;
5044 -> 5043;
5045 -> 5039;
5045 -> 5043;
5046 -> 5040;
5046 -> 5043;
5047 -> 5041;
5047 -> 5043;
5048 -> 5042;
5048 -> 5043;
5049 -> 5044;
5049 -> 0;
5049 -> 5043;
5050 -> 5047;
5050 -> 5046;
5050 -> 5043;
5051 -> 5049;
5051 -> 5050;
5051 -> 5043;
5052 -> 5045;
5052 -> 5051;
5053 -> 5046;
5053 -> 5051;
5054 -> 5048;
5054 -> 5051;
5055 -> 5051;
5056 -> 5052;
5056 -> 5055;
5057 -> 5053;
5057 -> 5055;
5058 -> 5054;
5058 -> 5055;
5059 -> 5055;
5060 -> 5056;
5060 -> 5059;
5060 -> 5055;
5061 -> 5060;
5062 -> 5058;
5062 -> 5061;
5062 -> 5060;
5063 -> 5057;
5063 -> 5062;
5064 -> 5062;
5065 -> 5063;
5065 -> 5064;
5067 -> 5065;
5067 -> 5064;
5068 -> 5064;
5069 -> 5064;
5070 -> 5067;
5070 -> 5069;
5071 -> 5068;
5071 -> 5069;
5072 -> 0;
5072 -> 5069;
5073 -> 5070;
5073 -> 5069;
5074 -> 5069;
5075 -> 5072;
5075 -> 5074;
5076 -> 5073;
5076 -> 5074;
5077 -> 5071;
5077 -> 5074;
5078 -> 5075;
5078 -> 5074;
5079 -> 5076;
5079 -> 5074;
5080 -> 5074;
5081 -> 5078;
5081 -> 5080;
5082 -> 5079;
5082 -> 5080;
5083 -> 5077;
5083 -> 5080;
5084 -> 5081;
5084 -> 5080;
5085 -> 5082;
5085 -> 5080;
5086 -> 5080;
5087 -> 5086;
5087 -> 5084;
5087 -> 5085;
5087 -> 5080;
5088 -> 5086;
5088 -> 5080;
5089 -> 5088;
5089 -> 5087;
5089 -> 5080;
5090 -> 5077;
5090 -> 5089;
5090 -> 0;
5090 -> 5074;
5091 -> 5090;
5091 -> 5077;
5091 -> 5074;
5092 -> 5071;
5092 -> 5069;
5093 -> 5070;
5093 -> 5071;
5093 -> 5069;
5094 -> 5068;
5094 -> 5062;
5095 -> 4965;
5096 -> 5025;
5096 -> 5095;
5096 -> 4965;
5097 -> 4977;
5097 -> 5094;
5097 -> 5089;
5097 -> 4965;
5098 -> 4965;
5098 -> 5094;
5098 -> 5000;
5098 -> 5089;
5098 -> 5091;
5098 -> 5092;
5098 -> 5093;
5099 -> 5098;
5099 -> 1155;
5100 -> 5099;
5100 -> 4848;
5101 -> 5100;
5101 -> 4851;
5101 -> 4848;
5102 -> 5100;
5102 -> 4970;
5102 -> 4848;
5103 -> 5098;
5103 -> 4858;
5104 -> 5103;
5104 -> 5098;
5104 -> 4858;
5105 -> 5104;
5105 -> 1155;
5106 -> 5098;
5107 -> 5098;
5108 -> 5107;
5108 -> 5098;
5109 -> 5098;
5110 -> 5098;
5111 -> 5110;
5111 -> 5098;
5112 -> 5098;
5113 -> 5098;
5114 -> 5098;
5115 -> 5098;
5116 -> 5115;
5117 -> 5098;
5118 -> 5098;
5119 -> 5098;
5120 -> 5118;
5120 -> 5119;
5121 -> 5119;
5122 -> 5119;
5123 -> 5120;
5123 -> 5122;
5123 -> 5119;
5124 -> 5123;
5125 -> 5121;
5125 -> 5119;
5126 -> 5125;
5126 -> 5098;
5127 -> 5098;
5128 -> 5126;
5128 -> 5127;
5129 -> 5098;
5129 -> 5127;
5130 -> 5127;
5131 -> 5129;
5131 -> 5098;
5131 -> 5130;
5131 -> 5127;
5132 -> 5131;
5133 -> 5132;
5133 -> 5098;
5134 -> 5098;
5135 -> 5098;
5136 -> 5134;
5136 -> 5135;
5137 -> 5135;
5138 -> 5136;
5138 -> 5107;
5138 -> 5137;
5138 -> 5135;
5139 -> 5138;
5139 -> 5098;
5140 -> 5098;
5141 -> 5107;
5141 -> 5140;
5141 -> 5098;
5142 -> 5107;
5142 -> 5098;
5143 -> 5107;
5144 -> 5107;
5144 -> 5098;
5145 -> 5144;
5146 -> 5133;
5146 -> 5098;
5147 -> 5098;
5148 -> 5098;
5148 -> 0;
5149 -> 5098;
5150 -> 5098;
5151 -> 5098;
5152 -> 5150;
5152 -> 5151;
5153 -> 5152;
5153 -> 0;
5153 -> 5151;
5154 -> 5107;
5154 -> 1411;
5154 -> 5098;
5155 -> 5107;
5155 -> 408;
5156 -> 1423;
5156 -> 1422;
5156 -> 5107;
5156 -> 5155;
5157 -> 5098;
5158 -> 5146;
5158 -> 5157;
5158 -> 5098;
5159 -> 5108;
5159 -> 5156;
5159 -> 5098;
5160 -> 5156;
5160 -> 1155;
5161 -> 5160;
5161 -> 4848;
5162 -> 5161;
5162 -> 4851;
5162 -> 4848;
5163 -> 5161;
5163 -> 4970;
5163 -> 4848;
5164 -> 5156;
5164 -> 4858;
5165 -> 5164;
5165 -> 5156;
5165 -> 4858;
5166 -> 5165;
5166 -> 1155;
5167 -> 5156;
5168 -> 5156;
5169 -> 5156;
5170 -> 5156;
5171 -> 5170;
5171 -> 5156;
5172 -> 5156;
5173 -> 5156;
5174 -> 5156;
5175 -> 5156;
5176 -> 5175;
5177 -> 5156;
5178 -> 5156;
5179 -> 5156;
5180 -> 5178;
5180 -> 5179;
5181 -> 5179;
5182 -> 5179;
5183 -> 5180;
5183 -> 5182;
5183 -> 5179;
5184 -> 5183;
5185 -> 5181;
5185 -> 5179;
5186 -> 5185;
5186 -> 5156;
5187 -> 5156;
5188 -> 5186;
5188 -> 5187;
5189 -> 5156;
5189 -> 5187;
5190 -> 5187;
5191 -> 5189;
5191 -> 5156;
5191 -> 5190;
5191 -> 5187;
5192 -> 5191;
5193 -> 5192;
5193 -> 5156;
5194 -> 5156;
5195 -> 5156;
5196 -> 5194;
5196 -> 5195;
5197 -> 5195;
5198 -> 5196;
5198 -> 5156;
5198 -> 5197;
5198 -> 5195;
5199 -> 5198;
5199 -> 5156;
5200 -> 5156;
5201 -> 5193;
5201 -> 5156;
5202 -> 5156;
5203 -> 5156;
5203 -> 0;
5204 -> 5156;
5205 -> 5156;
5206 -> 5156;
5207 -> 5205;
5207 -> 5206;
5208 -> 5207;
5208 -> 0;
5208 -> 5206;
5209 -> 5156;
5209 -> 1411;
5210 -> 5156;
5211 -> 5201;
5211 -> 5210;
5211 -> 5156;
5212 -> 5168;
5212 -> 5156;
5213 -> 5156;
5214 -> 5156;
5214 -> 1055;
5215 -> 0;
5215 -> 5156;
5216 -> 5156;
5216 -> 5215;
5217 -> 5215;
5218 -> 5216;
5218 -> 5217;
5219 -> 5218;
5219 -> 5217;
5220 -> 5219;
5221 -> 5156;
5221 -> 5215;
5221 -> 0;
5222 -> 5184;
5222 -> 5180;
5222 -> 5215;
5222 -> 5183;
5223 -> 5189;
5223 -> 5215;
5223 -> 5190;
5223 -> 5187;
5224 -> 5223;
5225 -> 5224;
5225 -> 5156;
5226 -> 5215;
5226 -> 5156;
5227 -> 5215;
5228 -> 5156;
5228 -> 5215;
5229 -> 5215;
5230 -> 5228;
5230 -> 5229;
5231 -> 5229;
5232 -> 5230;
5232 -> 5215;
5232 -> 5231;
5232 -> 5229;
5233 -> 5232;
5233 -> 5215;
5234 -> 5215;
5235 -> 5215;
5236 -> 5215;
5236 -> 5156;
5237 -> 5236;
5238 -> 5225;
5238 -> 5156;
5239 -> 5215;
5239 -> 0;
5239 -> 5156;
5240 -> 5215;
5241 -> 5215;
5242 -> 5240;
5242 -> 5241;
5243 -> 5242;
5243 -> 0;
5243 -> 5241;
5244 -> 5215;
5244 -> 1411;
5245 -> 5238;
5245 -> 5210;
5245 -> 5156;
5246 -> 5168;
5246 -> 5215;
5246 -> 5156;
5247 -> 5215;
5247 -> 1155;
5248 -> 5247;
5248 -> 4848;
5249 -> 5248;
5249 -> 4851;
5249 -> 4848;
5250 -> 5248;
5250 -> 4970;
5250 -> 4848;
5251 -> 5215;
5251 -> 4858;
5252 -> 5251;
5252 -> 5215;
5252 -> 4858;
5253 -> 5252;
5253 -> 1155;
5254 -> 5215;
5255 -> 5215;
5256 -> 5215;
5257 -> 5215;
5258 -> 5257;
5258 -> 5215;
5259 -> 5215;
5260 -> 5215;
5261 -> 5260;
5262 -> 5215;
5263 -> 5215;
5264 -> 5215;
5264 -> 1055;
5265 -> 5215;
5265 -> 0;
5266 -> 5215;
5267 -> 5215;
5268 -> 5266;
5268 -> 5267;
5269 -> 5267;
5270 -> 5267;
5271 -> 5268;
5271 -> 5270;
5271 -> 5267;
5272 -> 5271;
5273 -> 5269;
5273 -> 5267;
5274 -> 5273;
5274 -> 5215;
5275 -> 5215;
5276 -> 5274;
5276 -> 5275;
5277 -> 5215;
5277 -> 5275;
5278 -> 5275;
5279 -> 5277;
5279 -> 5215;
5279 -> 5278;
5279 -> 5275;
5280 -> 5279;
5281 -> 5280;
5281 -> 5215;
5282 -> 5281;
5282 -> 5215;
5283 -> 5215;
5284 -> 5215;
5284 -> 0;
5285 -> 5215;
5286 -> 5215;
5287 -> 5215;
5288 -> 5282;
5288 -> 5287;
5288 -> 5215;
5289 -> 5255;
5289 -> 5215;
5290 -> 5215;
5291 -> 5290;
5291 -> 5229;
5292 -> 5291;
5292 -> 5215;
5292 -> 5231;
5292 -> 5229;
5293 -> 5292;
5293 -> 5215;
5294 -> 5251;
5294 -> 4858;
5295 -> 5294;
5295 -> 1155;
5296 -> 5215;
5297 -> 5296;
5297 -> 5215;
5298 -> 5297;
5299 -> 5298;
5299 -> 5215;
5300 -> 993;
5300 -> 5299;
5301 -> 5300;
5302 -> 5300;
5302 -> 5301;
5303 -> 5301;
5304 -> 5302;
5304 -> 5303;
5305 -> 5303;
5306 -> 5304;
5306 -> 5305;
5306 -> 5303;
5307 -> 5304;
5307 -> 5303;
5308 -> 5300;
5308 -> 5306;
5309 -> 5306;
5310 -> 5308;
5310 -> 5309;
5311 -> 5309;
5312 -> 5310;
5312 -> 5311;
5312 -> 5309;
5313 -> 5300;
5313 -> 5215;
5314 -> 5313;
5315 -> 5296;
5315 -> 5215;
5316 -> 5296;
5316 -> 5215;
5317 -> 5316;
5317 -> 5215;
5318 -> 5296;
5319 -> 5296;
5320 -> 5319;
5321 -> 5320;
5321 -> 5296;
5322 -> 993;
5322 -> 5321;
5323 -> 5296;
5324 -> 5323;
5324 -> 5322;
5324 -> 5296;
5325 -> 5296;
5326 -> 5323;
5326 -> 5325;
5327 -> 5326;
5327 -> 5322;
5327 -> 5325;
5328 -> 5327;
5328 -> 5296;
5329 -> 0;
5331 -> 5329;
5331 -> 5330;
5332 -> 5330;
5333 -> 5331;
5333 -> 5332;
5333 -> 5330;
5334 -> 5330;
5337 -> 5335;
5337 -> 5336;
5338 -> 5336;
5339 -> 5337;
5339 -> 5338;
5339 -> 5336;
5340 -> 5336;
5341 -> 5296;
5342 -> 5341;
5342 -> 5328;
5342 -> 5296;
5343 -> 5296;
5344 -> 5342;
5344 -> 5343;
5345 -> 5344;
5345 -> 5343;
5346 -> 5343;
5347 -> 5345;
5347 -> 5346;
5347 -> 5343;
5348 -> 5345;
5348 -> 5343;
5349 -> 5296;
5350 -> 5348;
5350 -> 5349;
5350 -> 5296;
5351 -> 5296;
5352 -> 5351;
5352 -> 5350;
5352 -> 5296;
5353 -> 5296;
5354 -> 5352;
5354 -> 5353;
5355 -> 5353;
5356 -> 5354;
5356 -> 5355;
5356 -> 5353;
5357 -> 5296;
5358 -> 5354;
5358 -> 5357;
5358 -> 5296;
5359 -> 5296;
5359 -> 5215;
5360 -> 5359;
5360 -> 5267;
5361 -> 5360;
5361 -> 5270;
5361 -> 5267;
5362 -> 5361;
5363 -> 5362;
5363 -> 5360;
5363 -> 5358;
5363 -> 5361;
5364 -> 5277;
5364 -> 5358;
5364 -> 5278;
5364 -> 5275;
5365 -> 5364;
5366 -> 5365;
5366 -> 5215;
5367 -> 5358;
5368 -> 5358;
5368 -> 5367;
5369 -> 5367;
5370 -> 5368;
5370 -> 5369;
5371 -> 5369;
5372 -> 5370;
5372 -> 5371;
5372 -> 5369;
5373 -> 5370;
5373 -> 5369;
5374 -> 5358;
5374 -> 5372;
5375 -> 5372;
5376 -> 5374;
5376 -> 5375;
5377 -> 5375;
5378 -> 5376;
5378 -> 5377;
5378 -> 5375;
5379 -> 5358;
5379 -> 5215;
5380 -> 5379;
5381 -> 5366;
5381 -> 5215;
5382 -> 5358;
5382 -> 0;
5382 -> 5215;
5383 -> 5358;
5384 -> 5358;
5385 -> 5383;
5385 -> 5384;
5386 -> 5383;
5386 -> 5384;
5387 -> 5383;
5387 -> 5384;
5388 -> 5386;
5388 -> 1411;
5388 -> 5384;
5389 -> 5381;
5389 -> 5287;
5389 -> 5215;
5390 -> 5386;
5390 -> 1155;
5391 -> 5390;
5391 -> 4848;
5392 -> 5391;
5392 -> 4851;
5392 -> 4848;
5393 -> 5391;
5393 -> 4970;
5393 -> 4848;
5394 -> 5386;
5394 -> 4858;
5395 -> 5394;
5395 -> 4858;
5396 -> 5395;
5396 -> 1155;
5397 -> 1142;
5398 -> 1079;
5399 -> 5398;
5399 -> 1085;
5399 -> 1079;
5400 -> 1085;
5400 -> 1079;
5401 -> 1085;
5401 -> 1079;
5402 -> 1085;
5402 -> 1079;
5403 -> 1085;
5403 -> 1079;
5404 -> 1085;
5404 -> 1079;
5405 -> 1085;
5405 -> 1079;
5406 -> 1079;
5407 -> 5406;
5407 -> 1085;
5407 -> 1079;
5408 -> 1085;
5408 -> 5407;
5408 -> 1079;
5409 -> 1079;
5410 -> 5409;
5410 -> 1085;
5410 -> 1079;
5411 -> 1078;
5411 -> 890;
5412 -> 890;
5413 -> 5411;
5413 -> 5412;
5414 -> 5413;
5414 -> 5412;
5415 -> 0;
5415 -> 5412;
5416 -> 5412;
5417 -> 5414;
5417 -> 5416;
5418 -> 5415;
5418 -> 5416;
5419 -> 5413;
5419 -> 5416;
5420 -> 5416;
5421 -> 5419;
5421 -> 5402;
5421 -> 5420;
5421 -> 5416;
5422 -> 5417;
5422 -> 5414;
5422 -> 1119;
5422 -> 1127;
5422 -> 1121;
5422 -> 1120;
5422 -> 1110;
5422 -> 1151;
5422 -> 1112;
5422 -> 1113;
5422 -> 1114;
5422 -> 4856;
5422 -> 1116;
5422 -> 1117;
5422 -> 1118;
5422 -> 1122;
5422 -> 1124;
5422 -> 1134;
5422 -> 5399;
5422 -> 5407;
5422 -> 5410;
5422 -> 5402;
5422 -> 5403;
5422 -> 5404;
5422 -> 5405;
5422 -> 5358;
5422 -> 1078;
5422 -> 1123;
5422 -> 1133;
5422 -> 1150;
5422 -> 5398;
5422 -> 5408;
5422 -> 5416;
5423 -> 5416;
5424 -> 5422;
5424 -> 5423;
5425 -> 5423;
5426 -> 5424;
5426 -> 5425;
5427 -> 5426;
5427 -> 5422;
5427 -> 5425;
5428 -> 5426;
5428 -> 5427;
5428 -> 5425;
5429 -> 5426;
5429 -> 5427;
5429 -> 0;
5429 -> 5425;
5430 -> 5429;
5430 -> 5426;
5430 -> 5425;
5431 -> 5425;
5432 -> 5426;
5432 -> 5431;
5433 -> 5431;
5434 -> 5432;
5434 -> 5433;
5435 -> 5433;
5436 -> 5434;
5436 -> 5435;
5437 -> 5436;
5437 -> 5427;
5437 -> 5435;
5438 -> 5435;
5439 -> 5436;
5439 -> 5427;
5439 -> 5438;
5439 -> 5435;
5440 -> 5436;
5440 -> 5427;
5440 -> 5430;
5440 -> 5439;
5441 -> 5440;
5441 -> 5433;
5442 -> 5441;
5442 -> 5434;
5442 -> 5433;
5443 -> 5442;
5443 -> 5431;
5444 -> 5431;
5445 -> 5443;
5445 -> 5444;
5446 -> 5445;
5446 -> 5427;
5446 -> 5444;
5447 -> 5446;
5447 -> 5425;
5448 -> 5428;
5448 -> 5426;
5448 -> 5425;
5449 -> 5427;
5449 -> 5430;
5449 -> 5448;
5449 -> 5442;
5449 -> 5425;
5450 -> 5427;
5450 -> 5425;
5451 -> 5426;
5451 -> 5449;
5451 -> 5450;
5451 -> 5425;
5452 -> 5423;
5453 -> 5452;
5453 -> 5423;
5454 -> 5423;
5455 -> 5449;
5455 -> 5454;
5456 -> 5453;
5456 -> 5454;
5457 -> 5424;
5457 -> 5454;
5458 -> 5455;
5458 -> 5454;
5459 -> 5456;
5459 -> 5454;
5460 -> 5454;
5461 -> 5458;
5461 -> 5460;
5462 -> 5459;
5462 -> 5460;
5463 -> 5457;
5463 -> 5460;
5464 -> 5460;
5465 -> 5463;
5465 -> 5464;
5466 -> 5464;
5467 -> 5465;
5467 -> 5466;
5468 -> 5467;
5468 -> 5451;
5468 -> 5466;
5469 -> 5468;
5469 -> 5464;
5470 -> 5469;
5471 -> 5470;
5471 -> 5460;
5472 -> 5471;
5472 -> 5454;
5473 -> 5454;
5474 -> 5457;
5474 -> 5473;
5475 -> 5473;
5476 -> 5474;
5476 -> 5475;
5477 -> 5475;
5478 -> 5476;
5478 -> 5477;
5479 -> 5478;
5479 -> 5451;
5479 -> 5477;
5480 -> 5479;
5480 -> 5475;
5481 -> 5475;
5482 -> 5476;
5482 -> 5451;
5482 -> 5481;
5482 -> 5475;
5483 -> 5480;
5483 -> 5476;
5483 -> 5482;
5484 -> 5476;
5484 -> 5451;
5484 -> 5475;
5485 -> 5476;
5485 -> 5451;
5485 -> 5484;
5485 -> 5475;
5486 -> 5476;
5486 -> 5451;
5486 -> 5475;
5487 -> 5480;
5487 -> 5475;
5488 -> 5485;
5488 -> 5486;
5488 -> 5487;
5488 -> 5451;
5488 -> 5483;
5488 -> 5484;
5488 -> 5475;
5489 -> 5488;
5489 -> 5473;
5490 -> 5474;
5490 -> 5488;
5490 -> 5473;
5491 -> 5473;
5492 -> 5473;
5493 -> 5489;
5493 -> 5492;
5494 -> 5490;
5494 -> 5492;
5495 -> 5490;
5495 -> 5492;
5496 -> 5490;
5496 -> 5492;
5497 -> 5490;
5497 -> 5492;
5498 -> 5491;
5498 -> 5492;
5499 -> 5493;
5499 -> 5498;
5499 -> 5492;
5500 -> 5494;
5500 -> 5498;
5500 -> 5492;
5501 -> 5495;
5501 -> 5498;
5501 -> 5492;
5502 -> 5496;
5502 -> 5498;
5502 -> 5492;
5503 -> 5497;
5503 -> 5498;
5503 -> 5492;
5504 -> 5491;
5504 -> 5454;
5505 -> 5457;
5505 -> 5488;
5505 -> 5454;
5506 -> 5457;
5506 -> 5488;
5506 -> 5505;
5506 -> 5454;
5507 -> 5454;
5508 -> 5454;
5509 -> 5457;
5509 -> 5508;
5510 -> 5509;
5510 -> 5488;
5510 -> 5508;
5511 -> 5510;
5511 -> 5454;
5512 -> 5454;
5513 -> 5511;
5513 -> 5512;
5514 -> 5513;
5514 -> 5488;
5514 -> 5512;
5515 -> 5455;
5515 -> 5514;
5516 -> 5514;
5517 -> 5515;
5517 -> 5516;
5518 -> 5457;
5518 -> 5516;
5519 -> 5516;
5520 -> 5518;
5520 -> 5519;
5521 -> 5520;
5521 -> 5516;
5522 -> 5516;
5523 -> 5521;
5523 -> 5522;
5524 -> 0;
5524 -> 5516;
5525 -> 5516;
5526 -> 5524;
5526 -> 5525;
5527 -> 5518;
5527 -> 5525;
5528 -> 5526;
5528 -> 5525;
5529 -> 5525;
5530 -> 5528;
5530 -> 5529;
5531 -> 5530;
5531 -> 0;
5531 -> 5529;
5532 -> 5531;
5533 -> 5525;
5534 -> 5527;
5534 -> 5533;
5535 -> 5534;
5535 -> 5525;
5536 -> 5525;
5537 -> 5535;
5537 -> 5536;
5538 -> 5537;
5538 -> 5525;
5539 -> 5538;
5539 -> 5526;
5539 -> 5525;
5540 -> 5539;
5541 -> 5527;
5541 -> 5540;
5542 -> 5540;
5543 -> 5541;
5543 -> 5488;
5543 -> 5542;
5544 -> 5543;
5544 -> 5488;
5544 -> 5542;
5545 -> 5544;
5545 -> 5540;
5546 -> 5545;
5546 -> 5541;
5546 -> 5540;
5547 -> 5540;
5548 -> 5547;
5548 -> 5541;
5548 -> 5540;
5549 -> 5540;
5550 -> 5541;
5550 -> 5488;
5550 -> 5549;
5550 -> 5540;
5551 -> 5541;
5551 -> 5488;
5551 -> 5540;
5552 -> 5539;
5553 -> 5535;
5553 -> 5539;
5554 -> 5516;
5555 -> 5518;
5555 -> 5554;
5556 -> 0;
5556 -> 5554;
5557 -> 5554;
5558 -> 5556;
5558 -> 5557;
5559 -> 5555;
5559 -> 5557;
5560 -> 5559;
5560 -> 5488;
5560 -> 5505;
5560 -> 5557;
5561 -> 5559;
5561 -> 5488;
5561 -> 5505;
5561 -> 5560;
5561 -> 5557;
5562 -> 5558;
5562 -> 5557;
5563 -> 5557;
5564 -> 5562;
5564 -> 5563;
5565 -> 5559;
5565 -> 5563;
5566 -> 5563;
5567 -> 5563;
5568 -> 5563;
5569 -> 5565;
5569 -> 5568;
5570 -> 5569;
5570 -> 5488;
5570 -> 5551;
5570 -> 5568;
5571 -> 5569;
5571 -> 5488;
5571 -> 5505;
5571 -> 5560;
5571 -> 5546;
5571 -> 5548;
5571 -> 5551;
5572 -> 5571;
5572 -> 5563;
5573 -> 5563;
5574 -> 5572;
5574 -> 5573;
5575 -> 5574;
5575 -> 5563;
5576 -> 5563;
5577 -> 5575;
5577 -> 5576;
5578 -> 5577;
5578 -> 5576;
5579 -> 5578;
5580 -> 5574;
5580 -> 5563;
5581 -> 5563;
5582 -> 5580;
5582 -> 5581;
5583 -> 5582;
5583 -> 5581;
5584 -> 5581;
5585 -> 5583;
5585 -> 5584;
5586 -> 5585;
5586 -> 5584;
5587 -> 5584;
5588 -> 5586;
5588 -> 5587;
5589 -> 5588;
5589 -> 5587;
5590 -> 0;
5590 -> 5589;
5591 -> 5574;
5591 -> 0;
5591 -> 5590;
5592 -> 5591;
5593 -> 5565;
5593 -> 5592;
5594 -> 5592;
5595 -> 5593;
5595 -> 5594;
5596 -> 5595;
5596 -> 5592;
5597 -> 5592;
5598 -> 5596;
5598 -> 5597;
5599 -> 5597;
5600 -> 5598;
5600 -> 5599;
5601 -> 5600;
5601 -> 5597;
5602 -> 5592;
5603 -> 5602;
5603 -> 5591;
5604 -> 5603;
5605 -> 5603;
5606 -> 5604;
5606 -> 5605;
5607 -> 5604;
5607 -> 5605;
5608 -> 5565;
5608 -> 5605;
5609 -> 5605;
5610 -> 5608;
5610 -> 5609;
5611 -> 5610;
5611 -> 5605;
5612 -> 5605;
5613 -> 5611;
5613 -> 5612;
5614 -> 5612;
5615 -> 5613;
5615 -> 5614;
5616 -> 5615;
5616 -> 5612;
5617 -> 5605;
5618 -> 5617;
5618 -> 5603;
5619 -> 5618;
5620 -> 5619;
5620 -> 5618;
5621 -> 5618;
5622 -> 5620;
5622 -> 5621;
5623 -> 5621;
5624 -> 5622;
5624 -> 5623;
5625 -> 5624;
5625 -> 5621;
5626 -> 5574;
5626 -> 0;
5626 -> 5625;
5627 -> 5564;
5627 -> 5626;
5628 -> 5626;
5629 -> 5627;
5629 -> 5628;
5630 -> 5565;
5630 -> 5628;
5631 -> 5629;
5631 -> 0;
5631 -> 5628;
5632 -> 5628;
5633 -> 5630;
5633 -> 5632;
5634 -> 5633;
5634 -> 5628;
5635 -> 5628;
5636 -> 5634;
5636 -> 5635;
5637 -> 5635;
5638 -> 5636;
5638 -> 5637;
5639 -> 5638;
5639 -> 5635;
5640 -> 5628;
5641 -> 5630;
5641 -> 5640;
5642 -> 5641;
5642 -> 5628;
5643 -> 5628;
5644 -> 5642;
5644 -> 5643;
5645 -> 5628;
5646 -> 5644;
5646 -> 5645;
5647 -> 5646;
5647 -> 5645;
5648 -> 5645;
5649 -> 5647;
5649 -> 5648;
5650 -> 5649;
5650 -> 5648;
5651 -> 5650;
5652 -> 5639;
5652 -> 5651;
5652 -> 5628;
5653 -> 5631;
5653 -> 5652;
5653 -> 5628;
5654 -> 5653;
5655 -> 5564;
5655 -> 5654;
5656 -> 5654;
5657 -> 5655;
5657 -> 5656;
5658 -> 5565;
5658 -> 5656;
5659 -> 5657;
5659 -> 5656;
5660 -> 5656;
5661 -> 5659;
5661 -> 5660;
5662 -> 5658;
5662 -> 5660;
5663 -> 5660;
5664 -> 5662;
5664 -> 5663;
5665 -> 5664;
5665 -> 5660;
5666 -> 5660;
5667 -> 5665;
5667 -> 5666;
5668 -> 5667;
5668 -> 5660;
5669 -> 5661;
5669 -> 5668;
5670 -> 5668;
5671 -> 5669;
5671 -> 5670;
5672 -> 5662;
5672 -> 5670;
5673 -> 5670;
5674 -> 5672;
5674 -> 5673;
5675 -> 5674;
5675 -> 5670;
5676 -> 5670;
5677 -> 5675;
5677 -> 5676;
5678 -> 5670;
5679 -> 5672;
5679 -> 5678;
5680 -> 5679;
5680 -> 5678;
5681 -> 5678;
5682 -> 5678;
5683 -> 5680;
5683 -> 5682;
5684 -> 5680;
5684 -> 5682;
5685 -> 5680;
5685 -> 5682;
5686 -> 5680;
5686 -> 5682;
5687 -> 5680;
5687 -> 5682;
5688 -> 5681;
5688 -> 5682;
5689 -> 5683;
5689 -> 5688;
5689 -> 5682;
5690 -> 5684;
5690 -> 5688;
5690 -> 5682;
5691 -> 5685;
5691 -> 5688;
5691 -> 5682;
5692 -> 5686;
5692 -> 5688;
5692 -> 5682;
5693 -> 5687;
5693 -> 5688;
5693 -> 5682;
5694 -> 5681;
5694 -> 5670;
5695 -> 5671;
5695 -> 5670;
5696 -> 5670;
5697 -> 5695;
5697 -> 5696;
5698 -> 5672;
5698 -> 5696;
5699 -> 5697;
5699 -> 0;
5699 -> 5696;
5700 -> 5696;
5701 -> 5696;
5702 -> 5700;
5702 -> 5701;
5703 -> 5698;
5703 -> 5701;
5704 -> 5701;
5705 -> 5702;
5705 -> 5704;
5705 -> 5701;
5706 -> 5703;
5706 -> 5679;
5706 -> 5702;
5706 -> 5701;
5707 -> 5701;
5708 -> 5703;
5708 -> 5679;
5708 -> 5707;
5708 -> 5701;
5709 -> 5703;
5709 -> 5679;
5709 -> 5702;
5709 -> 5708;
5710 -> 5696;
5711 -> 5709;
5711 -> 5710;
5712 -> 5696;
5713 -> 5698;
5713 -> 5712;
5714 -> 5713;
5714 -> 5679;
5714 -> 5712;
5715 -> 5714;
5715 -> 5696;
5716 -> 5711;
5716 -> 5715;
5716 -> 5696;
5717 -> 5696;
5718 -> 5700;
5718 -> 5717;
5719 -> 5698;
5719 -> 5717;
5720 -> 5717;
5721 -> 5718;
5721 -> 5720;
5721 -> 5717;
5722 -> 5719;
5722 -> 5679;
5722 -> 5718;
5722 -> 5717;
5723 -> 5717;
5724 -> 5719;
5724 -> 5679;
5724 -> 5723;
5724 -> 5717;
5725 -> 5719;
5725 -> 5679;
5725 -> 5718;
5725 -> 5724;
5726 -> 5696;
5727 -> 5725;
5727 -> 5726;
5728 -> 5716;
5728 -> 5727;
5728 -> 5696;
5729 -> 5696;
5730 -> 5696;
5731 -> 5729;
5731 -> 5730;
5732 -> 5698;
5732 -> 5730;
5733 -> 5730;
5734 -> 5731;
5734 -> 5733;
5734 -> 5730;
5735 -> 5732;
5735 -> 5679;
5735 -> 5731;
5735 -> 5730;
5736 -> 5730;
5737 -> 5732;
5737 -> 5679;
5737 -> 5736;
5737 -> 5730;
5738 -> 5732;
5738 -> 5679;
5738 -> 5731;
5738 -> 5737;
5739 -> 5696;
5740 -> 5738;
5740 -> 5739;
5741 -> 5698;
5741 -> 5739;
5742 -> 5739;
5743 -> 5740;
5743 -> 5742;
5744 -> 5743;
5744 -> 5739;
5745 -> 5739;
5746 -> 5741;
5746 -> 5745;
5747 -> 5746;
5747 -> 5679;
5747 -> 5745;
5748 -> 5747;
5748 -> 5739;
5749 -> 5744;
5749 -> 5748;
5749 -> 5739;
5750 -> 5696;
5751 -> 5729;
5751 -> 5750;
5752 -> 5698;
5752 -> 5750;
5753 -> 5750;
5754 -> 5751;
5754 -> 5753;
5754 -> 5750;
5755 -> 5752;
5755 -> 5679;
5755 -> 5751;
5755 -> 5750;
5756 -> 5750;
5757 -> 5752;
5757 -> 5679;
5757 -> 5756;
5757 -> 5750;
5758 -> 5752;
5758 -> 5679;
5758 -> 5751;
5758 -> 5757;
5759 -> 5696;
5760 -> 5758;
5760 -> 5759;
5761 -> 5749;
5761 -> 5760;
5761 -> 5696;
5762 -> 5696;
5763 -> 5729;
5763 -> 5762;
5764 -> 5698;
5764 -> 5762;
5765 -> 5762;
5766 -> 5763;
5766 -> 5765;
5766 -> 5762;
5767 -> 5764;
5767 -> 5679;
5767 -> 5763;
5767 -> 5762;
5768 -> 5762;
5769 -> 5764;
5769 -> 5679;
5769 -> 5768;
5769 -> 5762;
5770 -> 5764;
5770 -> 5679;
5770 -> 5763;
5770 -> 5769;
5771 -> 5696;
5772 -> 5770;
5772 -> 5771;
5773 -> 5761;
5773 -> 5772;
5773 -> 5696;
5774 -> 5696;
5775 -> 5696;
5776 -> 5774;
5776 -> 5775;
5777 -> 5698;
5777 -> 5775;
5778 -> 5775;
5779 -> 5776;
5779 -> 5778;
5779 -> 5775;
5780 -> 5777;
5780 -> 5679;
5780 -> 5776;
5780 -> 5775;
5781 -> 5775;
5782 -> 5777;
5782 -> 5679;
5782 -> 5781;
5782 -> 5775;
5783 -> 5777;
5783 -> 5679;
5783 -> 5776;
5783 -> 5782;
5784 -> 5696;
5785 -> 5783;
5785 -> 5784;
5786 -> 5696;
5787 -> 5696;
5788 -> 5786;
5788 -> 5787;
5789 -> 5698;
5789 -> 5787;
5790 -> 5787;
5791 -> 5788;
5791 -> 5790;
5791 -> 5787;
5792 -> 5789;
5792 -> 5679;
5792 -> 5788;
5792 -> 5787;
5793 -> 5787;
5794 -> 5789;
5794 -> 5679;
5794 -> 5793;
5794 -> 5787;
5795 -> 5789;
5795 -> 5679;
5795 -> 5788;
5795 -> 5794;
5796 -> 5696;
5797 -> 5795;
5797 -> 5796;
5798 -> 5696;
5799 -> 5798;
5799 -> 5670;
5800 -> 5670;
5801 -> 5670;
5802 -> 5800;
5802 -> 5801;
5803 -> 5672;
5803 -> 5801;
5804 -> 5801;
5805 -> 5803;
5805 -> 5804;
5806 -> 5805;
5806 -> 5679;
5806 -> 5804;
5807 -> 5806;
5807 -> 5801;
5808 -> 5801;
5809 -> 5807;
5809 -> 5808;
5810 -> 5801;
5811 -> 5803;
5811 -> 5810;
5812 -> 5810;
5813 -> 5811;
5813 -> 5812;
5814 -> 5813;
5814 -> 5679;
5814 -> 5812;
5815 -> 5814;
5815 -> 5810;
5816 -> 5810;
5817 -> 5811;
5817 -> 5816;
5818 -> 5817;
5818 -> 5679;
5818 -> 5816;
5819 -> 5816;
5820 -> 5819;
5820 -> 5817;
5820 -> 5816;
5821 -> 5816;
5822 -> 5817;
5822 -> 5679;
5822 -> 5821;
5822 -> 5816;
5823 -> 5817;
5823 -> 5679;
5823 -> 5816;
5824 -> 5810;
5825 -> 5815;
5825 -> 5810;
5826 -> 5825;
5826 -> 5801;
5827 -> 5802;
5827 -> 5801;
5828 -> 5801;
5829 -> 5827;
5829 -> 5828;
5830 -> 5803;
5830 -> 5828;
5831 -> 5828;
5832 -> 5829;
5832 -> 5828;
5833 -> 5828;
5834 -> 5831;
5834 -> 5833;
5835 -> 5832;
5835 -> 5833;
5836 -> 5830;
5836 -> 5833;
5837 -> 5835;
5837 -> 5833;
5838 -> 0;
5838 -> 5837;
5839 -> 5834;
5839 -> 5833;
5840 -> 5838;
5840 -> 5839;
5840 -> 5836;
5840 -> 5679;
5840 -> 5820;
5840 -> 5817;
5840 -> 5823;
5840 -> 5833;
5841 -> 5833;
5842 -> 5840;
5842 -> 5841;
5843 -> 5840;
5843 -> 5841;
5844 -> 5840;
5844 -> 5841;
5845 -> 5841;
5846 -> 5843;
5846 -> 5845;
5846 -> 5841;
5847 -> 5844;
5847 -> 5840;
5847 -> 5843;
5847 -> 5841;
5848 -> 5841;
5849 -> 5844;
5849 -> 5840;
5849 -> 5848;
5849 -> 5841;
5850 -> 5844;
5850 -> 5840;
5850 -> 5843;
5850 -> 5849;
5851 -> 5840;
5851 -> 5841;
5852 -> 5840;
5852 -> 5841;
5853 -> 5841;
5854 -> 5852;
5854 -> 5853;
5855 -> 5854;
5855 -> 5850;
5855 -> 5853;
5856 -> 5855;
5856 -> 5841;
5857 -> 5841;
5858 -> 5856;
5858 -> 5857;
5859 -> 5841;
5860 -> 5852;
5860 -> 5859;
5861 -> 5859;
5862 -> 5860;
5862 -> 5861;
5863 -> 5862;
5863 -> 5850;
5863 -> 5861;
5864 -> 5863;
5864 -> 5859;
5865 -> 5859;
5866 -> 5864;
5866 -> 5865;
5867 -> 5866;
5868 -> 5860;
5868 -> 5867;
5869 -> 5867;
5870 -> 5868;
5870 -> 5869;
5871 -> 5870;
5871 -> 5867;
5872 -> 5867;
5873 -> 5871;
5873 -> 5872;
5874 -> 5867;
5875 -> 5874;
5875 -> 5866;
5876 -> 5866;
5877 -> 5860;
5877 -> 5876;
5878 -> 5876;
5879 -> 5877;
5879 -> 5878;
5880 -> 5879;
5880 -> 5850;
5880 -> 5878;
5881 -> 5880;
5881 -> 5876;
5882 -> 5881;
5882 -> 5866;
5883 -> 5875;
5883 -> 5882;
5883 -> 5866;
5884 -> 5866;
5885 -> 5860;
5885 -> 5884;
5886 -> 5884;
5887 -> 5885;
5887 -> 5886;
5888 -> 5887;
5888 -> 5884;
5889 -> 5884;
5890 -> 5888;
5890 -> 5889;
5891 -> 5890;
5891 -> 5866;
5892 -> 5883;
5892 -> 5891;
5892 -> 5866;
5893 -> 5892;
5894 -> 5893;
5894 -> 5841;
5895 -> 5858;
5895 -> 5894;
5895 -> 5841;
5896 -> 5841;
5897 -> 5852;
5897 -> 5896;
5898 -> 5896;
5899 -> 5897;
5899 -> 5898;
5900 -> 5899;
5900 -> 5850;
5900 -> 5898;
5901 -> 5900;
5901 -> 5896;
5902 -> 5896;
5903 -> 5897;
5903 -> 5850;
5903 -> 5902;
5904 -> 5902;
5905 -> 5902;
5906 -> 5897;
5906 -> 5850;
5906 -> 5905;
5906 -> 5902;
5907 -> 5897;
5907 -> 5850;
5907 -> 5902;
5908 -> 5896;
5909 -> 5901;
5909 -> 5896;
5910 -> 5909;
5910 -> 5841;
5911 -> 5841;
5912 -> 5852;
5912 -> 5911;
5913 -> 5912;
5913 -> 5850;
5913 -> 5907;
5913 -> 5911;
5914 -> 5912;
5914 -> 5850;
5914 -> 5911;
5915 -> 5912;
5915 -> 5850;
5915 -> 5897;
5915 -> 5907;
5915 -> 5914;
5916 -> 5915;
5916 -> 5841;
5917 -> 5841;
5918 -> 5916;
5918 -> 5917;
5919 -> 0;
5919 -> 5918;
5920 -> 5910;
5920 -> 5919;
5920 -> 5850;
5920 -> 5897;
5920 -> 5915;
5920 -> 5907;
5920 -> 5833;
5921 -> 5910;
5921 -> 5841;
5922 -> 5841;
5923 -> 5921;
5923 -> 5922;
5924 -> 5923;
5924 -> 5920;
5924 -> 5922;
5925 -> 5924;
5925 -> 5841;
5926 -> 5841;
5927 -> 5925;
5927 -> 5926;
5928 -> 5841;
5929 -> 5921;
5929 -> 5928;
5930 -> 5929;
5930 -> 5920;
5930 -> 5928;
5931 -> 5930;
5931 -> 5841;
5932 -> 5841;
5933 -> 5931;
5933 -> 5932;
5934 -> 5927;
5934 -> 5933;
5934 -> 5841;
5935 -> 5910;
5935 -> 5841;
5936 -> 5910;
5936 -> 5841;
5937 -> 5910;
5937 -> 5841;
5938 -> 5841;
5939 -> 5937;
5939 -> 5938;
5940 -> 5939;
5940 -> 5934;
5940 -> 5938;
5941 -> 5940;
5941 -> 5841;
5942 -> 5941;
5942 -> 5935;
5942 -> 5841;
5943 -> 5941;
5943 -> 5942;
5944 -> 5942;
5945 -> 5943;
5945 -> 5944;
5945 -> 5833;
5946 -> 5836;
5946 -> 5838;
5946 -> 5839;
5946 -> 5840;
5946 -> 5850;
5946 -> 5919;
5946 -> 5934;
5946 -> 5944;
5946 -> 5943;
5946 -> 5833;
5947 -> 5946;
5947 -> 0;
5947 -> 5801;
5948 -> 5801;
5949 -> 5803;
5949 -> 5948;
5950 -> 5949;
5950 -> 5946;
5950 -> 5948;
5951 -> 5950;
5951 -> 5801;
5952 -> 5801;
5953 -> 5951;
5953 -> 5952;
5954 -> 5801;
5955 -> 5803;
5955 -> 5954;
5956 -> 5954;
5957 -> 5955;
5957 -> 5956;
5958 -> 5957;
5958 -> 5946;
5958 -> 5956;
5959 -> 5954;
5960 -> 5955;
5960 -> 5959;
5961 -> 5960;
5961 -> 5946;
5961 -> 5959;
5962 -> 5959;
5963 -> 5960;
5963 -> 5946;
5963 -> 5962;
5963 -> 5959;
5964 -> 5960;
5964 -> 5946;
5964 -> 5959;
5965 -> 5954;
5966 -> 5958;
5966 -> 5801;
5967 -> 5946;
5967 -> 5801;
5968 -> 5967;
5969 -> 5968;
5969 -> 5946;
5969 -> 5964;
5970 -> 5968;
5970 -> 5946;
5970 -> 5961;
5970 -> 5960;
5970 -> 5964;
5971 -> 5970;
5971 -> 5967;
5972 -> 5967;
5973 -> 5971;
5973 -> 5972;
5974 -> 5967;
5975 -> 5973;
5975 -> 5974;
5976 -> 5975;
5976 -> 5974;
5977 -> 5976;
5978 -> 5694;
5978 -> 5670;
5979 -> 5670;
5980 -> 5978;
5980 -> 5979;
5981 -> 5672;
5981 -> 5979;
5982 -> 5980;
5982 -> 5690;
5982 -> 5981;
5982 -> 5979;
5983 -> 5980;
5983 -> 5691;
5983 -> 5981;
5983 -> 5979;
5984 -> 5980;
5984 -> 5692;
5984 -> 5981;
5984 -> 5946;
5984 -> 5979;
5985 -> 5980;
5985 -> 5693;
5985 -> 5981;
5985 -> 5946;
5985 -> 5979;
5986 -> 5980;
5986 -> 5689;
5986 -> 5979;
5987 -> 5979;
5988 -> 5986;
5988 -> 5987;
5989 -> 5981;
5989 -> 5987;
5990 -> 5988;
5990 -> 5679;
5990 -> 5989;
5990 -> 5946;
5990 -> 5987;
5991 -> 5987;
5992 -> 5990;
5992 -> 5991;
5992 -> 5987;
5993 -> 5990;
5993 -> 5989;
5993 -> 5946;
5993 -> 5987;
5994 -> 5988;
5994 -> 5679;
5994 -> 5989;
5994 -> 5987;
5995 -> 5987;
5996 -> 5990;
5996 -> 5995;
5996 -> 5987;
5997 -> 5990;
5997 -> 5989;
5997 -> 5946;
5997 -> 5987;
5998 -> 5990;
5998 -> 5989;
5998 -> 5987;
5999 -> 5987;
6000 -> 5999;
6000 -> 5989;
6000 -> 5987;
6001 -> 5987;
6002 -> 6001;
6002 -> 5989;
6002 -> 5987;
6003 -> 5988;
6003 -> 5679;
6003 -> 5989;
6003 -> 5987;
6004 -> 5987;
6005 -> 5989;
6005 -> 5946;
6005 -> 6004;
6005 -> 5987;
6006 -> 5979;
6007 -> 5670;
6008 -> 5671;
6008 -> 5670;
6009 -> 5670;
6010 -> 6008;
6010 -> 6009;
6011 -> 5672;
6011 -> 6009;
6012 -> 6010;
6012 -> 0;
6012 -> 6009;
6013 -> 6009;
6014 -> 6011;
6014 -> 6013;
6015 -> 6014;
6015 -> 5946;
6015 -> 5964;
6015 -> 5998;
6015 -> 6013;
6016 -> 6014;
6016 -> 5946;
6016 -> 6013;
6017 -> 6014;
6017 -> 5946;
6017 -> 6013;
6018 -> 6014;
6018 -> 5946;
6018 -> 5994;
6018 -> 6013;
6019 -> 6014;
6019 -> 5946;
6019 -> 5961;
6019 -> 6003;
6019 -> 6013;
6020 -> 6017;
6020 -> 6018;
6020 -> 6015;
6020 -> 6019;
6020 -> 5946;
6020 -> 5961;
6020 -> 6003;
6020 -> 5960;
6020 -> 5970;
6020 -> 6000;
6020 -> 5964;
6020 -> 5998;
6020 -> 5982;
6020 -> 5983;
6020 -> 5984;
6020 -> 5985;
6020 -> 5994;
6020 -> 6002;
6020 -> 6001;
6020 -> 6013;
6021 -> 6013;
6022 -> 6013;
6023 -> 6021;
6023 -> 6022;
6024 -> 6021;
6024 -> 6009;
6025 -> 6009;
6026 -> 6009;
6027 -> 6026;
6028 -> 6011;
6028 -> 6027;
6029 -> 6027;
6030 -> 6028;
6030 -> 6029;
6031 -> 6030;
6031 -> 6020;
6031 -> 6029;
6032 -> 6030;
6032 -> 6020;
6032 -> 6029;
6033 -> 6027;
6034 -> 6028;
6034 -> 6033;
6035 -> 6034;
6035 -> 6020;
6035 -> 6032;
6035 -> 6033;
6036 -> 6033;
6037 -> 6036;
6037 -> 6034;
6037 -> 6033;
6038 -> 6033;
6039 -> 6034;
6039 -> 6020;
6039 -> 6038;
6039 -> 6033;
6040 -> 6034;
6040 -> 6020;
6040 -> 6033;
6041 -> 6027;
6042 -> 6032;
6042 -> 6026;
6043 -> 6026;
6044 -> 6011;
6044 -> 6043;
6045 -> 6044;
6045 -> 6020;
6045 -> 6040;
6045 -> 6043;
6046 -> 6044;
6046 -> 6020;
6046 -> 6043;
6047 -> 6044;
6047 -> 6020;
6047 -> 6032;
6047 -> 6034;
6047 -> 6037;
6047 -> 6040;
6047 -> 6046;
6048 -> 6047;
6048 -> 6026;
6049 -> 6026;
6050 -> 6048;
6050 -> 6049;
6051 -> 6026;
6052 -> 6011;
6052 -> 6051;
6053 -> 6052;
6053 -> 6020;
6053 -> 6032;
6053 -> 6034;
6053 -> 6047;
6053 -> 6051;
6054 -> 6053;
6054 -> 6026;
6055 -> 6026;
6056 -> 6054;
6056 -> 6055;
6057 -> 6026;
6058 -> 6026;
6059 -> 6057;
6059 -> 6058;
6060 -> 6011;
6060 -> 6058;
6061 -> 6058;
6062 -> 6059;
6062 -> 6058;
6063 -> 6058;
6064 -> 6061;
6064 -> 6063;
6065 -> 6062;
6065 -> 6063;
6066 -> 6060;
6066 -> 6063;
6067 -> 6065;
6067 -> 6063;
6068 -> 5838;
6068 -> 6067;
6069 -> 6064;
6069 -> 6063;
6070 -> 6068;
6070 -> 6069;
6070 -> 6066;
6070 -> 6020;
6070 -> 6032;
6070 -> 6034;
6070 -> 6047;
6070 -> 6037;
6070 -> 6040;
6070 -> 6063;
6071 -> 6063;
6072 -> 6071;
6073 -> 6070;
6073 -> 6072;
6073 -> 6071;
6074 -> 6070;
6074 -> 6071;
6075 -> 6071;
6076 -> 6070;
6076 -> 6071;
6077 -> 6071;
6078 -> 6070;
6078 -> 6077;
6079 -> 6078;
6079 -> 6071;
6080 -> 6071;
6081 -> 6079;
6081 -> 6080;
6082 -> 6071;
6083 -> 6070;
6083 -> 6082;
6084 -> 6082;
6085 -> 6083;
6085 -> 6084;
6086 -> 6085;
6086 -> 6082;
6087 -> 6082;
6088 -> 6086;
6088 -> 6087;
6089 -> 6088;
6090 -> 6083;
6090 -> 6089;
6091 -> 6089;
6092 -> 6090;
6092 -> 6091;
6093 -> 6092;
6093 -> 6089;
6094 -> 6089;
6095 -> 6093;
6095 -> 6094;
6096 -> 6089;
6097 -> 6096;
6097 -> 6088;
6098 -> 6088;
6099 -> 6083;
6099 -> 6098;
6100 -> 6098;
6101 -> 6099;
6101 -> 6100;
6102 -> 6101;
6102 -> 6070;
6102 -> 6100;
6103 -> 6102;
6103 -> 6098;
6104 -> 6103;
6104 -> 6088;
6105 -> 6097;
6105 -> 6104;
6105 -> 6088;
6106 -> 6088;
6107 -> 6083;
6107 -> 6106;
6108 -> 6106;
6109 -> 6107;
6109 -> 6108;
6110 -> 6109;
6110 -> 6106;
6111 -> 6106;
6112 -> 6110;
6112 -> 6111;
6113 -> 6112;
6113 -> 6088;
6114 -> 6105;
6114 -> 6113;
6114 -> 6088;
6115 -> 6114;
6116 -> 6115;
6116 -> 6071;
6117 -> 6081;
6117 -> 6116;
6117 -> 6071;
6118 -> 6071;
6119 -> 6118;
6120 -> 6118;
6121 -> 6070;
6121 -> 6120;
6122 -> 6120;
6123 -> 6120;
6124 -> 6070;
6124 -> 6123;
6124 -> 6120;
6125 -> 6118;
6126 -> 6071;
6127 -> 6070;
6127 -> 6126;
6128 -> 6071;
6129 -> 6071;
6130 -> 6071;
6131 -> 6071;
6132 -> 6071;
6133 -> 6070;
6133 -> 6071;
6134 -> 6071;
6135 -> 6026;
6136 -> 6011;
6136 -> 6135;
6137 -> 6135;
6138 -> 6136;
6138 -> 6137;
6139 -> 6138;
6139 -> 6070;
6139 -> 6137;
6140 -> 6139;
6140 -> 6135;
6141 -> 6135;
6142 -> 6140;
6142 -> 6141;
6143 -> 6135;
6144 -> 6143;
6144 -> 6026;
6145 -> 6026;
6146 -> 6011;
6146 -> 6145;
6147 -> 6146;
6147 -> 6070;
6147 -> 6145;
6148 -> 6147;
6148 -> 6026;
6149 -> 6026;
6150 -> 6148;
6150 -> 6149;
6151 -> 6150;
6152 -> 6150;
6153 -> 6151;
6153 -> 6152;
6154 -> 6152;
6155 -> 6153;
6155 -> 6154;
6155 -> 6152;
6156 -> 6152;
6156 -> 6070;
6156 -> 6153;
6157 -> 6150;
6158 -> 6153;
6158 -> 6157;
6159 -> 6024;
6159 -> 6150;
6160 -> 6150;
6161 -> 6159;
6161 -> 6160;
6162 -> 6160;
6163 -> 6161;
6163 -> 6162;
6163 -> 6160;
6164 -> 6161;
6164 -> 6160;
6164 -> 6070;
6165 -> 6160;
6166 -> 6161;
6166 -> 6165;
6166 -> 6160;
6167 -> 6161;
6167 -> 6160;
6167 -> 6070;
6168 -> 6160;
6169 -> 6150;
6170 -> 6161;
6170 -> 6150;
6171 -> 6150;
6172 -> 6170;
6172 -> 6171;
6173 -> 6011;
6173 -> 6171;
6174 -> 6172;
6174 -> 6161;
6174 -> 6171;
6175 -> 6171;
6176 -> 6174;
6176 -> 6175;
6177 -> 6173;
6177 -> 6175;
6178 -> 6177;
6178 -> 6070;
6178 -> 6176;
6178 -> 6020;
6178 -> 6175;
6179 -> 6177;
6179 -> 6070;
6179 -> 6175;
6180 -> 6175;
6181 -> 6177;
6181 -> 6070;
6181 -> 6179;
6181 -> 6180;
6181 -> 6175;
6182 -> 6171;
6183 -> 6150;
6184 -> 6158;
6184 -> 5670;
6185 -> 5980;
6185 -> 5670;
6186 -> 5670;
6187 -> 6185;
6187 -> 6186;
6188 -> 5672;
6188 -> 6186;
6189 -> 6187;
6189 -> 5690;
6189 -> 6188;
6189 -> 6186;
6190 -> 6187;
6190 -> 5691;
6190 -> 6188;
6190 -> 6186;
6191 -> 6187;
6191 -> 5692;
6191 -> 6188;
6191 -> 6070;
6191 -> 6186;
6192 -> 6187;
6192 -> 5693;
6192 -> 6188;
6192 -> 6070;
6192 -> 6186;
6193 -> 6187;
6193 -> 5988;
6193 -> 6186;
6194 -> 6186;
6195 -> 6188;
6195 -> 6194;
6196 -> 6193;
6196 -> 5679;
6196 -> 6195;
6196 -> 6070;
6196 -> 6194;
6197 -> 6194;
6198 -> 6196;
6198 -> 6197;
6198 -> 6194;
6199 -> 6196;
6199 -> 6195;
6199 -> 6070;
6199 -> 6194;
6200 -> 6193;
6200 -> 5679;
6200 -> 6195;
6200 -> 6194;
6201 -> 6194;
6202 -> 6196;
6202 -> 6201;
6202 -> 6194;
6203 -> 6196;
6203 -> 6195;
6203 -> 6070;
6203 -> 6194;
6204 -> 6194;
6205 -> 6204;
6205 -> 6195;
6205 -> 6194;
6206 -> 6194;
6207 -> 6206;
6207 -> 6195;
6207 -> 6194;
6208 -> 6193;
6208 -> 5679;
6208 -> 6195;
6208 -> 6194;
6209 -> 6194;
6210 -> 6195;
6210 -> 6070;
6210 -> 6209;
6210 -> 6194;
6211 -> 6186;
6212 -> 5670;
6213 -> 0;
6213 -> 5670;
6214 -> 5670;
6215 -> 6213;
6215 -> 6214;
6216 -> 5672;
6216 -> 6214;
6217 -> 6215;
6217 -> 6214;
6218 -> 6214;
6219 -> 6217;
6219 -> 6218;
6220 -> 6219;
6220 -> 0;
6220 -> 6218;
6221 -> 6220;
6222 -> 6216;
6222 -> 6070;
6222 -> 6161;
6222 -> 6196;
6222 -> 6214;
6223 -> 6216;
6223 -> 6070;
6223 -> 6214;
6224 -> 6216;
6224 -> 6070;
6224 -> 6161;
6224 -> 6189;
6224 -> 6190;
6224 -> 6191;
6224 -> 6192;
6224 -> 6200;
6224 -> 6196;
6224 -> 6160;
6224 -> 6205;
6224 -> 6207;
6224 -> 6208;
6224 -> 6179;
6224 -> 6223;
6225 -> 6224;
6225 -> 6215;
6225 -> 6214;
6226 -> 6225;
6226 -> 6070;
6226 -> 6160;
6226 -> 6205;
6226 -> 6224;
6227 -> 6225;
6228 -> 6225;
6229 -> 6224;
6229 -> 6225;
6230 -> 0;
6230 -> 5670;
6231 -> 5670;
6232 -> 5670;
6233 -> 6230;
6233 -> 6232;
6234 -> 6231;
6234 -> 6232;
6235 -> 6231;
6235 -> 6232;
6236 -> 5672;
6236 -> 6232;
6237 -> 6233;
6237 -> 6232;
6238 -> 6235;
6238 -> 6232;
6239 -> 6232;
6240 -> 6237;
6240 -> 6239;
6241 -> 6238;
6241 -> 6239;
6242 -> 6236;
6242 -> 6239;
6243 -> 6239;
6244 -> 6242;
6244 -> 6243;
6245 -> 6244;
6245 -> 6070;
6245 -> 6161;
6245 -> 6189;
6245 -> 6190;
6245 -> 6191;
6245 -> 6192;
6245 -> 6200;
6245 -> 6196;
6245 -> 6225;
6245 -> 6160;
6245 -> 6205;
6245 -> 6224;
6245 -> 6207;
6245 -> 6208;
6245 -> 6179;
6245 -> 6243;
6246 -> 6245;
6246 -> 6239;
6247 -> 6239;
6248 -> 6242;
6248 -> 6247;
6249 -> 6248;
6249 -> 6070;
6249 -> 6161;
6249 -> 6196;
6249 -> 6225;
6249 -> 6247;
6250 -> 6248;
6250 -> 6070;
6250 -> 6179;
6250 -> 6247;
6251 -> 6248;
6251 -> 6070;
6251 -> 6179;
6251 -> 6247;
6252 -> 6248;
6252 -> 6070;
6252 -> 6161;
6252 -> 6200;
6252 -> 6247;
6253 -> 6248;
6253 -> 6070;
6253 -> 6161;
6253 -> 6208;
6253 -> 6225;
6253 -> 6247;
6254 -> 6247;
6255 -> 6247;
6256 -> 6254;
6256 -> 6255;
6257 -> 6254;
6257 -> 6239;
6258 -> 6239;
6259 -> 6242;
6259 -> 6258;
6260 -> 6258;
6261 -> 6259;
6261 -> 6260;
6262 -> 6261;
6262 -> 6249;
6262 -> 6260;
6263 -> 6261;
6263 -> 6249;
6263 -> 6260;
6264 -> 6263;
6264 -> 6258;
6265 -> 6258;
6266 -> 6264;
6266 -> 6265;
6267 -> 6266;
6268 -> 6267;
6268 -> 6239;
6269 -> 6239;
6270 -> 6240;
6270 -> 6239;
6271 -> 6269;
6271 -> 6239;
6272 -> 6270;
6272 -> 6271;
6272 -> 6242;
6272 -> 6249;
6272 -> 6263;
6272 -> 6239;
6273 -> 6239;
6274 -> 6273;
6275 -> 6272;
6275 -> 6274;
6275 -> 6273;
6276 -> 6272;
6276 -> 6273;
6277 -> 6273;
6278 -> 6272;
6278 -> 6273;
6279 -> 6273;
6280 -> 6272;
6280 -> 6279;
6281 -> 6280;
6281 -> 6273;
6282 -> 6273;
6283 -> 6281;
6283 -> 6282;
6284 -> 6273;
6285 -> 6272;
6285 -> 6284;
6286 -> 6284;
6287 -> 6285;
6287 -> 6286;
6288 -> 6287;
6288 -> 6284;
6289 -> 6284;
6290 -> 6288;
6290 -> 6289;
6291 -> 6290;
6292 -> 6285;
6292 -> 6291;
6293 -> 6291;
6294 -> 6292;
6294 -> 6293;
6295 -> 6294;
6295 -> 6291;
6296 -> 6291;
6297 -> 6295;
6297 -> 6296;
6298 -> 6291;
6299 -> 6298;
6299 -> 6290;
6300 -> 6290;
6301 -> 6285;
6301 -> 6300;
6302 -> 6300;
6303 -> 6301;
6303 -> 6302;
6304 -> 6303;
6304 -> 6272;
6304 -> 6302;
6305 -> 6304;
6305 -> 6300;
6306 -> 6305;
6306 -> 6290;
6307 -> 6299;
6307 -> 6306;
6307 -> 6290;
6308 -> 6290;
6309 -> 6285;
6309 -> 6308;
6310 -> 6308;
6311 -> 6309;
6311 -> 6310;
6312 -> 6311;
6312 -> 6308;
6313 -> 6308;
6314 -> 6312;
6314 -> 6313;
6315 -> 6314;
6315 -> 6290;
6316 -> 6307;
6316 -> 6315;
6316 -> 6290;
6317 -> 6316;
6318 -> 6317;
6318 -> 6273;
6319 -> 6283;
6319 -> 6318;
6319 -> 6273;
6320 -> 6273;
6321 -> 6320;
6322 -> 6320;
6323 -> 6272;
6323 -> 6322;
6324 -> 6322;
6325 -> 6322;
6326 -> 6272;
6326 -> 6325;
6326 -> 6322;
6327 -> 6320;
6328 -> 6273;
6329 -> 6272;
6329 -> 6328;
6330 -> 6273;
6331 -> 6273;
6332 -> 6273;
6333 -> 6273;
6334 -> 6273;
6335 -> 6272;
6335 -> 6273;
6336 -> 6273;
6337 -> 6239;
6338 -> 6272;
6338 -> 6337;
6339 -> 6338;
6339 -> 6239;
6340 -> 6239;
6341 -> 6339;
6341 -> 6340;
6342 -> 6268;
6342 -> 6341;
6342 -> 6239;
6343 -> 6241;
6343 -> 6342;
6343 -> 6239;
6344 -> 6239;
6345 -> 6343;
6345 -> 6344;
6346 -> 6242;
6346 -> 6344;
6347 -> 6344;
6348 -> 6346;
6348 -> 6347;
6349 -> 6348;
6349 -> 6272;
6349 -> 6347;
6350 -> 6349;
6350 -> 6344;
6351 -> 6344;
6352 -> 6350;
6352 -> 6351;
6353 -> 6352;
6354 -> 6353;
6354 -> 6239;
6355 -> 6354;
6356 -> 6257;
6356 -> 6354;
6357 -> 6354;
6358 -> 6356;
6358 -> 6357;
6359 -> 6357;
6360 -> 6358;
6360 -> 6359;
6360 -> 6357;
6361 -> 6358;
6361 -> 6357;
6361 -> 6272;
6362 -> 6357;
6363 -> 6358;
6363 -> 6362;
6363 -> 6357;
6364 -> 6358;
6364 -> 6357;
6364 -> 6272;
6365 -> 6357;
6366 -> 6354;
6367 -> 6358;
6367 -> 6354;
6368 -> 6354;
6369 -> 6367;
6369 -> 6368;
6370 -> 6369;
6370 -> 6358;
6370 -> 6368;
6371 -> 6370;
6371 -> 6368;
6372 -> 6368;
6372 -> 6272;
6372 -> 6371;
6372 -> 6249;
6373 -> 6368;
6374 -> 6368;
6375 -> 6354;
6376 -> 6355;
6377 -> 6376;
6377 -> 6272;
6378 -> 6376;
6379 -> 6376;
6380 -> 6376;
6380 -> 6272;
6380 -> 6358;
6381 -> 6376;
6381 -> 6272;
6381 -> 6358;
6381 -> 6357;
6381 -> 6368;
6382 -> 6381;
6382 -> 6376;
6383 -> 6376;
6384 -> 6382;
6384 -> 6383;
6385 -> 6384;
6385 -> 6383;
6386 -> 6385;
6387 -> 6376;
6387 -> 6381;
6388 -> 6381;
6389 -> 6387;
6389 -> 6388;
6390 -> 6389;
6390 -> 6381;
6391 -> 6381;
6392 -> 6390;
6392 -> 6391;
6393 -> 6381;
6394 -> 6381;
6395 -> 6376;
6395 -> 6381;
6396 -> 6381;
6397 -> 6395;
6397 -> 6396;
6398 -> 6397;
6398 -> 6381;
6399 -> 6381;
6400 -> 6398;
6400 -> 6399;
6401 -> 6376;
6401 -> 6391;
6402 -> 6401;
6402 -> 6391;
6403 -> 6402;
6403 -> 6391;
6404 -> 6403;
6404 -> 6391;
6405 -> 6391;
6406 -> 6391;
6406 -> 6405;
6407 -> 6405;
6408 -> 6406;
6408 -> 6407;
6409 -> 6408;
6409 -> 6405;
6410 -> 6405;
6411 -> 6409;
6411 -> 6410;
6412 -> 6411;
6413 -> 6406;
6413 -> 6412;
6414 -> 6412;
6415 -> 6413;
6415 -> 6414;
6416 -> 6415;
6416 -> 6412;
6417 -> 6412;
6418 -> 6416;
6418 -> 6417;
6419 -> 6412;
6420 -> 6419;
6420 -> 6411;
6421 -> 6411;
6422 -> 6406;
6422 -> 6421;
6423 -> 6421;
6424 -> 6422;
6424 -> 6423;
6425 -> 6424;
6425 -> 6272;
6425 -> 6358;
6425 -> 6357;
6425 -> 6381;
6425 -> 6368;
6425 -> 6376;
6425 -> 6423;
6426 -> 6425;
6426 -> 6421;
6427 -> 6426;
6427 -> 6411;
6428 -> 6420;
6428 -> 6427;
6428 -> 6411;
6429 -> 6411;
6430 -> 6406;
6430 -> 6429;
6431 -> 6429;
6432 -> 6430;
6432 -> 6431;
6433 -> 6432;
6433 -> 6429;
6434 -> 6429;
6435 -> 6433;
6435 -> 6434;
6436 -> 6435;
6436 -> 6411;
6437 -> 6428;
6437 -> 6436;
6437 -> 6411;
6438 -> 6437;
6439 -> 6438;
6439 -> 6391;
6440 -> 6439;
6441 -> 6391;
6441 -> 6440;
6442 -> 6440;
6443 -> 6442;
6443 -> 6440;
6444 -> 6440;
6445 -> 6443;
6445 -> 6444;
6446 -> 6441;
6446 -> 6444;
6447 -> 6444;
6448 -> 6445;
6448 -> 6447;
6448 -> 6444;
6449 -> 6446;
6449 -> 6272;
6449 -> 6358;
6449 -> 6445;
6449 -> 6444;
6450 -> 6446;
6450 -> 6272;
6450 -> 6358;
6450 -> 6445;
6451 -> 6440;
6452 -> 6450;
6452 -> 6451;
6453 -> 6440;
6454 -> 6443;
6454 -> 6453;
6455 -> 6441;
6455 -> 6453;
6456 -> 6453;
6457 -> 6454;
6457 -> 6456;
6457 -> 6453;
6458 -> 6455;
6458 -> 6272;
6458 -> 6358;
6458 -> 6454;
6458 -> 6453;
6459 -> 6455;
6459 -> 6272;
6459 -> 6358;
6459 -> 6454;
6460 -> 6440;
6461 -> 6459;
6461 -> 6460;
6462 -> 6452;
6462 -> 6461;
6462 -> 6440;
6463 -> 6442;
6463 -> 6440;
6464 -> 6440;
6465 -> 6463;
6465 -> 6464;
6466 -> 6441;
6466 -> 6464;
6467 -> 6464;
6468 -> 6465;
6468 -> 6467;
6468 -> 6464;
6469 -> 6466;
6469 -> 6272;
6469 -> 6358;
6469 -> 6465;
6469 -> 6464;
6470 -> 6466;
6470 -> 6272;
6470 -> 6358;
6470 -> 6465;
6471 -> 6440;
6472 -> 6470;
6472 -> 6471;
6473 -> 6472;
6473 -> 6439;
6474 -> 6404;
6474 -> 6473;
6475 -> 6473;
6476 -> 6474;
6476 -> 6475;
6477 -> 6391;
6477 -> 6475;
6478 -> 6475;
6479 -> 6477;
6479 -> 6478;
6480 -> 6479;
6480 -> 6475;
6481 -> 6475;
6482 -> 6480;
6482 -> 6481;
6483 -> 6475;
6484 -> 6477;
6484 -> 6483;
6485 -> 6484;
6485 -> 6475;
6486 -> 6475;
6487 -> 6485;
6487 -> 6486;
6488 -> 6477;
6488 -> 6486;
6489 -> 6486;
6490 -> 6487;
6490 -> 6489;
6491 -> 6490;
6491 -> 6486;
6492 -> 6486;
6493 -> 6488;
6493 -> 6492;
6494 -> 6493;
6494 -> 6486;
6495 -> 6491;
6495 -> 6494;
6495 -> 6486;
6496 -> 6482;
6496 -> 6495;
6496 -> 6475;
6497 -> 6476;
6497 -> 0;
6497 -> 6475;
6498 -> 6475;
6499 -> 6475;
6500 -> 6475;
6501 -> 6477;
6501 -> 6500;
6502 -> 6501;
6502 -> 6475;
6503 -> 6475;
6504 -> 6502;
6504 -> 6503;
6505 -> 6504;
6506 -> 6505;
6506 -> 6504;
6507 -> 6504;
6508 -> 6506;
6508 -> 6507;
6509 -> 6508;
6510 -> 6508;
6511 -> 6509;
6511 -> 6475;
6512 -> 6475;
6513 -> 6511;
6513 -> 6512;
6514 -> 6477;
6514 -> 6512;
6515 -> 6512;
6516 -> 6513;
6516 -> 6515;
6516 -> 6512;
6517 -> 6514;
6517 -> 6272;
6517 -> 6358;
6517 -> 6513;
6517 -> 6512;
6518 -> 6475;
6519 -> 6513;
6519 -> 6518;
6520 -> 6509;
6520 -> 6475;
6521 -> 6475;
6522 -> 6520;
6522 -> 6521;
6523 -> 6477;
6523 -> 6521;
6524 -> 6521;
6525 -> 6522;
6525 -> 6524;
6525 -> 6521;
6526 -> 6523;
6526 -> 6272;
6526 -> 6358;
6526 -> 6522;
6526 -> 6521;
6527 -> 6475;
6528 -> 6522;
6528 -> 6527;
6529 -> 6475;
6530 -> 6509;
6530 -> 6529;
6530 -> 6475;
6531 -> 6475;
6532 -> 6530;
6532 -> 6531;
6533 -> 6477;
6533 -> 6531;
6534 -> 6531;
6535 -> 6532;
6535 -> 6534;
6535 -> 6531;
6536 -> 6533;
6536 -> 6272;
6536 -> 6358;
6536 -> 6532;
6536 -> 6531;
6537 -> 6475;
6538 -> 6532;
6538 -> 6537;
6539 -> 6528;
6539 -> 6538;
6539 -> 6475;
6540 -> 6509;
6540 -> 6475;
6541 -> 6475;
6542 -> 6540;
6542 -> 6541;
6543 -> 6477;
6543 -> 6541;
6544 -> 6541;
6545 -> 6542;
6545 -> 6544;
6545 -> 6541;
6546 -> 6543;
6546 -> 6272;
6546 -> 6358;
6546 -> 6542;
6546 -> 6541;
6547 -> 6475;
6548 -> 6542;
6548 -> 6547;
6549 -> 6509;
6549 -> 6475;
6550 -> 6475;
6551 -> 6549;
6551 -> 6550;
6552 -> 6477;
6552 -> 6550;
6553 -> 6550;
6554 -> 6551;
6554 -> 6553;
6554 -> 6550;
6555 -> 6552;
6555 -> 6272;
6555 -> 6358;
6555 -> 6551;
6555 -> 6550;
6556 -> 6475;
6557 -> 6551;
6557 -> 6556;
6558 -> 6557;
6559 -> 6558;
6559 -> 6473;
6560 -> 6404;
6560 -> 6559;
6561 -> 6559;
6562 -> 6560;
6562 -> 6561;
6563 -> 0;
6563 -> 6562;
6564 -> 6562;
6565 -> 6563;
6565 -> 6564;
6566 -> 6391;
6566 -> 6564;
6567 -> 6565;
6567 -> 6564;
6568 -> 6564;
6569 -> 6567;
6569 -> 6568;
6570 -> 6566;
6570 -> 6568;
6571 -> 6568;
6572 -> 6568;
6573 -> 6571;
6573 -> 6572;
6574 -> 6570;
6574 -> 6572;
6575 -> 6572;
6576 -> 6574;
6576 -> 6575;
6577 -> 6575;
6578 -> 6576;
6578 -> 6577;
6579 -> 6578;
6579 -> 6575;
6580 -> 6579;
6581 -> 6580;
6581 -> 6572;
6582 -> 6573;
6582 -> 6572;
6583 -> 6572;
6584 -> 6582;
6584 -> 6583;
6585 -> 6574;
6585 -> 6583;
6586 -> 6583;
6587 -> 6585;
6587 -> 6586;
6588 -> 6587;
6588 -> 6583;
6589 -> 6583;
6590 -> 6588;
6590 -> 6589;
6591 -> 6590;
6591 -> 0;
6591 -> 6583;
6592 -> 6591;
6593 -> 6585;
6593 -> 6592;
6594 -> 6592;
6595 -> 6593;
6595 -> 6594;
6596 -> 6595;
6596 -> 6592;
6597 -> 6592;
6598 -> 6596;
6598 -> 6597;
6599 -> 6592;
6599 -> 6591;
6600 -> 6591;
6601 -> 6600;
6601 -> 6591;
6602 -> 6599;
6602 -> 6601;
6602 -> 6591;
6603 -> 6591;
6604 -> 6603;
6604 -> 6272;
6604 -> 6357;
6604 -> 6381;
6605 -> 6603;
6606 -> 6603;
6607 -> 6603;
6607 -> 6591;
6608 -> 6591;
6609 -> 6585;
6609 -> 6608;
6610 -> 6609;
6610 -> 6272;
6610 -> 6358;
6610 -> 6603;
6610 -> 6357;
6610 -> 6381;
6610 -> 6368;
6610 -> 6376;
6610 -> 6608;
6611 -> 6610;
6611 -> 6591;
6612 -> 6607;
6612 -> 6591;
6613 -> 6612;
6613 -> 6572;
6614 -> 6613;
6614 -> 6572;
6615 -> 6572;
6616 -> 6614;
6616 -> 6615;
6617 -> 6614;
6617 -> 6615;
6618 -> 6616;
6618 -> 6615;
6619 -> 6615;
6620 -> 6619;
6620 -> 6618;
6620 -> 6615;
6621 -> 6619;
6621 -> 6615;
6622 -> 6621;
6622 -> 6620;
6622 -> 6615;
6623 -> 6622;
6623 -> 6568;
6624 -> 6623;
6624 -> 6622;
6624 -> 6568;
6625 -> 6623;
6625 -> 6568;
6626 -> 6568;
6627 -> 6570;
6627 -> 6626;
6628 -> 6627;
6628 -> 6622;
6628 -> 6626;
6629 -> 6627;
6629 -> 6622;
6629 -> 6626;
6630 -> 6629;
6630 -> 6568;
6631 -> 6568;
6632 -> 6630;
6632 -> 6631;
6633 -> 6625;
6633 -> 6568;
6634 -> 6633;
6634 -> 6564;
6635 -> 6564;
6636 -> 6566;
6636 -> 6635;
6637 -> 6636;
6637 -> 6622;
6637 -> 6629;
6637 -> 6635;
6638 -> 6637;
6638 -> 6564;
6639 -> 6564;
6640 -> 6638;
6640 -> 6639;
6641 -> 6634;
6641 -> 6564;
6642 -> 6641;
6642 -> 6562;
6643 -> 6642;
6643 -> 6391;
6643 -> 6622;
6643 -> 6629;
6644 -> 6391;
6645 -> 6643;
6645 -> 6376;
6646 -> 6376;
6647 -> 6376;
6648 -> 6645;
6648 -> 6647;
6649 -> 6646;
6649 -> 6647;
6650 -> 6376;
6650 -> 6647;
6651 -> 6647;
6652 -> 6651;
6653 -> 6650;
6653 -> 6652;
6654 -> 6653;
6654 -> 6643;
6654 -> 6652;
6655 -> 6654;
6655 -> 6651;
6656 -> 6651;
6657 -> 6655;
6657 -> 6656;
6658 -> 6651;
6659 -> 6651;
6660 -> 6657;
6660 -> 6651;
6661 -> 6651;
6662 -> 6660;
6662 -> 6661;
6663 -> 6662;
6663 -> 6661;
6664 -> 6661;
6665 -> 6663;
6665 -> 6664;
6666 -> 6665;
6666 -> 6664;
6667 -> 6664;
6668 -> 6666;
6668 -> 6667;
6669 -> 6668;
6669 -> 6667;
6670 -> 0;
6670 -> 6669;
6671 -> 6657;
6671 -> 6670;
6672 -> 6670;
6673 -> 6671;
6673 -> 6672;
6674 -> 6673;
6674 -> 6672;
6675 -> 6672;
6676 -> 6674;
6676 -> 6675;
6677 -> 6676;
6677 -> 6675;
6678 -> 6677;
6679 -> 6657;
6679 -> 0;
6679 -> 6678;
6680 -> 6657;
6680 -> 0;
6680 -> 6679;
6681 -> 6657;
6681 -> 0;
6681 -> 6680;
6682 -> 6647;
6683 -> 6650;
6683 -> 6682;
6684 -> 6683;
6684 -> 6643;
6684 -> 6682;
6685 -> 6684;
6685 -> 6647;
6686 -> 6647;
6687 -> 6685;
6687 -> 6686;
6688 -> 6648;
6688 -> 6647;
6689 -> 6376;
6690 -> 6376;
6691 -> 6688;
6691 -> 6690;
6692 -> 6691;
6692 -> 6376;
6693 -> 6376;
6694 -> 6692;
6694 -> 6693;
6695 -> 6694;
6695 -> 6693;
6696 -> 0;
6696 -> 6695;
6697 -> 6376;
6697 -> 6643;
6698 -> 6688;
6698 -> 6376;
6699 -> 5670;
6700 -> 5672;
6700 -> 6699;
6701 -> 6700;
6701 -> 6643;
6701 -> 6699;
6702 -> 6701;
6702 -> 5670;
6703 -> 5670;
6704 -> 6702;
6704 -> 6703;
6705 -> 5670;
6706 -> 6698;
6706 -> 6705;
6707 -> 6706;
6707 -> 5670;
6708 -> 5670;
6709 -> 5672;
6709 -> 6708;
6710 -> 6709;
6710 -> 6643;
6710 -> 6708;
6711 -> 6710;
6711 -> 5670;
6712 -> 5670;
6713 -> 6711;
6713 -> 6712;
6714 -> 6707;
6714 -> 6713;
6714 -> 5670;
6715 -> 0;
6715 -> 5670;
6716 -> 5670;
6717 -> 6715;
6717 -> 6716;
6718 -> 5672;
6718 -> 6716;
6719 -> 6717;
6719 -> 6716;
6720 -> 6716;
6721 -> 6719;
6721 -> 6720;
6722 -> 6721;
6722 -> 0;
6722 -> 6720;
6723 -> 6722;
6724 -> 6718;
6724 -> 6643;
6724 -> 6716;
6725 -> 6724;
6725 -> 6717;
6725 -> 6716;
6726 -> 6725;
6727 -> 6725;
6728 -> 6724;
6728 -> 6725;
6729 -> 6229;
6729 -> 5670;
6730 -> 6698;
6730 -> 5670;
6731 -> 6728;
6731 -> 5670;
6732 -> 6729;
6732 -> 6730;
6732 -> 6731;
6732 -> 5672;
6732 -> 6643;
6732 -> 6697;
6732 -> 6725;
6732 -> 5670;
6733 -> 5670;
6734 -> 6732;
6734 -> 6733;
6735 -> 6732;
6735 -> 6733;
6736 -> 6732;
6736 -> 6733;
6737 -> 6732;
6737 -> 6733;
6738 -> 6732;
6738 -> 6733;
6739 -> 6732;
6739 -> 6733;
6740 -> 6734;
6740 -> 6733;
6741 -> 6735;
6741 -> 6733;
6742 -> 6736;
6742 -> 6733;
6743 -> 6737;
6743 -> 6733;
6744 -> 6738;
6744 -> 6733;
6745 -> 6733;
6746 -> 6744;
6746 -> 6745;
6747 -> 6745;
6748 -> 6746;
6748 -> 6732;
6748 -> 6745;
6749 -> 6746;
6749 -> 6732;
6749 -> 6745;
6750 -> 6747;
6750 -> 6745;
6751 -> 6750;
6751 -> 6733;
6752 -> 6739;
6752 -> 6733;
6753 -> 6740;
6753 -> 6741;
6753 -> 6742;
6753 -> 6743;
6753 -> 6751;
6753 -> 6752;
6753 -> 6732;
6753 -> 6733;
6754 -> 6733;
6755 -> 6754;
6755 -> 6733;
6756 -> 6753;
6756 -> 6733;
6757 -> 6753;
6757 -> 6733;
6758 -> 6756;
6758 -> 6733;
6759 -> 6756;
6759 -> 6733;
6760 -> 6187;
6760 -> 5670;
6761 -> 5670;
6762 -> 6760;
6762 -> 6761;
6763 -> 5672;
6763 -> 6761;
6764 -> 6762;
6764 -> 6193;
6764 -> 6761;
6765 -> 6761;
6766 -> 6764;
6766 -> 6765;
6767 -> 6763;
6767 -> 6765;
6768 -> 6767;
6768 -> 6753;
6768 -> 6766;
6768 -> 5679;
6768 -> 6765;
6769 -> 6767;
6769 -> 6753;
6769 -> 6765;
6770 -> 6765;
6771 -> 6767;
6771 -> 6753;
6771 -> 6769;
6771 -> 6770;
6771 -> 6765;
6772 -> 6761;
6773 -> 5670;
6774 -> 6753;
6774 -> 5668;
6775 -> 6774;
6775 -> 5658;
6775 -> 6753;
6775 -> 6769;
6775 -> 5656;
6776 -> 5656;
6777 -> 6775;
6777 -> 6776;
6778 -> 5564;
6778 -> 5563;
6779 -> 5563;
6780 -> 6778;
6780 -> 6779;
6781 -> 5565;
6781 -> 6779;
6782 -> 6779;
6783 -> 6782;
6784 -> 6781;
6784 -> 6783;
6785 -> 6784;
6785 -> 6775;
6785 -> 6783;
6786 -> 6785;
6786 -> 6782;
6787 -> 6782;
6788 -> 6786;
6788 -> 6787;
6789 -> 6787;
6790 -> 6782;
6791 -> 6782;
6792 -> 6788;
6792 -> 6782;
6793 -> 6782;
6794 -> 6792;
6794 -> 6793;
6795 -> 6794;
6795 -> 6793;
6796 -> 6793;
6797 -> 6795;
6797 -> 6796;
6798 -> 6797;
6798 -> 6796;
6799 -> 6796;
6800 -> 6798;
6800 -> 6799;
6801 -> 6800;
6801 -> 6799;
6802 -> 0;
6802 -> 6801;
6803 -> 6788;
6803 -> 6802;
6804 -> 6802;
6805 -> 6803;
6805 -> 6804;
6806 -> 6805;
6806 -> 6804;
6807 -> 6804;
6808 -> 6806;
6808 -> 6807;
6809 -> 6808;
6809 -> 6807;
6810 -> 6809;
6811 -> 6788;
6811 -> 0;
6811 -> 6810;
6812 -> 6788;
6812 -> 0;
6812 -> 6811;
6813 -> 6788;
6813 -> 0;
6813 -> 6812;
6814 -> 6779;
6815 -> 6781;
6815 -> 6814;
6816 -> 6815;
6816 -> 6775;
6816 -> 6814;
6817 -> 6816;
6817 -> 6779;
6818 -> 6779;
6819 -> 6817;
6819 -> 6818;
6820 -> 5557;
6821 -> 5557;
6822 -> 6775;
6822 -> 6821;
6823 -> 6822;
6823 -> 5557;
6824 -> 5557;
6825 -> 6823;
6825 -> 6824;
6826 -> 6825;
6826 -> 6824;
6827 -> 0;
6827 -> 6826;
6828 -> 6775;
6828 -> 5516;
6829 -> 5516;
6830 -> 5516;
6831 -> 5516;
6832 -> 6828;
6832 -> 6831;
6833 -> 6832;
6833 -> 5516;
6834 -> 6828;
6834 -> 6833;
6835 -> 6834;
6835 -> 6775;
6835 -> 6833;
6836 -> 6834;
6836 -> 6775;
6836 -> 6833;
6837 -> 6834;
6837 -> 6775;
6837 -> 6833;
6838 -> 6834;
6838 -> 6775;
6838 -> 6833;
6839 -> 6833;
6840 -> 0;
6840 -> 5516;
6841 -> 5516;
6842 -> 6840;
6842 -> 6841;
6843 -> 5518;
6843 -> 6841;
6844 -> 6842;
6844 -> 6841;
6845 -> 6841;
6846 -> 6844;
6846 -> 6845;
6847 -> 6846;
6847 -> 0;
6847 -> 6845;
6848 -> 6847;
6849 -> 6841;
6850 -> 6843;
6850 -> 6849;
6851 -> 6850;
6851 -> 6838;
6851 -> 6849;
6852 -> 6841;
6853 -> 6851;
6853 -> 6842;
6853 -> 6841;
6854 -> 6853;
6855 -> 6853;
6856 -> 5518;
6856 -> 6838;
6856 -> 6853;
6856 -> 5516;
6857 -> 5516;
6858 -> 5518;
6858 -> 6857;
6859 -> 6857;
6860 -> 6858;
6860 -> 6859;
6861 -> 6860;
6861 -> 6856;
6861 -> 6859;
6862 -> 6860;
6862 -> 6856;
6862 -> 6859;
6863 -> 6862;
6863 -> 6857;
6864 -> 6857;
6865 -> 6863;
6865 -> 6864;
6866 -> 6865;
6866 -> 5516;
6867 -> 6866;
6868 -> 5518;
6868 -> 6867;
6869 -> 6867;
6870 -> 6868;
6870 -> 6869;
6871 -> 6870;
6871 -> 6867;
6872 -> 6868;
6872 -> 6856;
6872 -> 6862;
6872 -> 6867;
6873 -> 6868;
6873 -> 6872;
6873 -> 6867;
6874 -> 6867;
6875 -> 6867;
6876 -> 6867;
6877 -> 6867;
6878 -> 6868;
6878 -> 6877;
6879 -> 6878;
6879 -> 6873;
6879 -> 6877;
6880 -> 6879;
6880 -> 6867;
6881 -> 6867;
6882 -> 6880;
6882 -> 6881;
6883 -> 6882;
6884 -> 6882;
6885 -> 6884;
6886 -> 6884;
6887 -> 6884;
6887 -> 6882;
6888 -> 6882;
6889 -> 6888;
6889 -> 6873;
6889 -> 6884;
6890 -> 6888;
6890 -> 6873;
6890 -> 6884;
6891 -> 6890;
6891 -> 6882;
6892 -> 6882;
6893 -> 6891;
6893 -> 6892;
6894 -> 6893;
6895 -> 6868;
6895 -> 6894;
6896 -> 6894;
6897 -> 6895;
6897 -> 6896;
6898 -> 0;
6898 -> 6896;
6899 -> 6896;
6900 -> 6896;
6901 -> 6898;
6901 -> 6900;
6902 -> 6899;
6902 -> 6900;
6903 -> 6899;
6903 -> 6900;
6904 -> 6897;
6904 -> 6900;
6905 -> 6901;
6905 -> 6900;
6906 -> 6902;
6906 -> 6900;
6907 -> 6903;
6907 -> 6900;
6908 -> 6900;
6909 -> 6905;
6909 -> 6908;
6910 -> 6906;
6910 -> 6908;
6911 -> 6907;
6911 -> 6908;
6912 -> 6904;
6912 -> 6908;
6913 -> 6909;
6913 -> 6908;
6914 -> 6910;
6914 -> 6908;
6915 -> 6911;
6915 -> 6908;
6916 -> 6908;
6917 -> 6913;
6917 -> 6916;
6918 -> 6914;
6918 -> 6916;
6919 -> 6915;
6919 -> 6916;
6920 -> 6912;
6920 -> 6916;
6921 -> 6917;
6921 -> 6916;
6922 -> 6918;
6922 -> 6916;
6923 -> 6919;
6923 -> 6916;
6924 -> 6916;
6925 -> 6921;
6925 -> 6924;
6926 -> 6922;
6926 -> 6924;
6927 -> 6923;
6927 -> 6924;
6928 -> 6920;
6928 -> 6924;
6929 -> 6924;
6930 -> 6928;
6930 -> 6929;
6931 -> 6930;
6931 -> 6924;
6932 -> 6924;
6933 -> 6931;
6933 -> 6932;
6934 -> 6925;
6934 -> 6933;
6935 -> 6926;
6935 -> 6933;
6936 -> 6927;
6936 -> 6933;
6937 -> 6933;
6938 -> 6934;
6938 -> 6937;
6939 -> 6935;
6939 -> 6937;
6940 -> 6936;
6940 -> 6937;
6941 -> 6928;
6941 -> 6937;
6942 -> 6937;
6943 -> 6941;
6943 -> 6942;
6944 -> 6943;
6944 -> 6937;
6945 -> 6937;
6946 -> 6944;
6946 -> 6945;
6947 -> 6946;
6947 -> 6937;
6948 -> 6937;
6949 -> 6941;
6949 -> 6948;
6950 -> 6949;
6950 -> 6937;
6951 -> 6937;
6952 -> 6950;
6952 -> 6951;
6953 -> 6937;
6954 -> 6941;
6954 -> 6953;
6955 -> 6954;
6955 -> 6937;
6956 -> 6937;
6957 -> 6955;
6957 -> 6956;
6958 -> 6937;
6959 -> 6941;
6959 -> 6958;
6960 -> 6958;
6960 -> 6937;
6961 -> 6937;
6962 -> 6937;
6963 -> 6941;
6963 -> 6962;
6964 -> 6962;
6965 -> 6963;
6965 -> 6964;
6966 -> 6965;
6966 -> 6959;
6966 -> 6964;
6967 -> 6966;
6967 -> 6962;
6968 -> 6962;
6969 -> 6967;
6969 -> 6968;
6970 -> 6969;
6970 -> 6962;
6971 -> 6962;
6972 -> 6970;
6972 -> 6971;
6973 -> 6969;
6973 -> 0;
6973 -> 6962;
6974 -> 6962;
6975 -> 6963;
6975 -> 6974;
6976 -> 6975;
6976 -> 6959;
6976 -> 6974;
6977 -> 6976;
6977 -> 6962;
6978 -> 6962;
6979 -> 6977;
6979 -> 6978;
6980 -> 6973;
6980 -> 6979;
6980 -> 6962;
6981 -> 6962;
6982 -> 6963;
6982 -> 6981;
6983 -> 6982;
6983 -> 6959;
6983 -> 6981;
6984 -> 6983;
6984 -> 6962;
6985 -> 6962;
6986 -> 6984;
6986 -> 6985;
6987 -> 6980;
6987 -> 6986;
6987 -> 6962;
6988 -> 6987;
6989 -> 6988;
6989 -> 6937;
6990 -> 6939;
6990 -> 6989;
6991 -> 0;
6991 -> 6990;
6992 -> 6989;
6993 -> 6991;
6993 -> 6992;
6994 -> 6941;
6994 -> 6992;
6995 -> 6992;
6996 -> 6994;
6996 -> 6995;
6997 -> 6996;
6997 -> 6992;
6998 -> 6992;
6999 -> 6997;
6999 -> 6998;
7000 -> 6993;
7000 -> 6992;
7001 -> 7000;
7001 -> 6994;
7001 -> 6959;
7001 -> 6992;
7002 -> 6992;
7003 -> 7001;
7003 -> 7002;
7004 -> 7001;
7004 -> 7002;
7005 -> 7001;
7005 -> 7002;
7006 -> 7002;
7007 -> 7005;
7007 -> 7006;
7008 -> 7007;
7008 -> 7002;
7009 -> 7002;
7010 -> 7008;
7010 -> 7009;
7011 -> 7002;
7012 -> 7010;
7012 -> 7011;
7013 -> 7002;
7014 -> 7005;
7014 -> 7013;
7015 -> 7014;
7016 -> 7014;
7017 -> 7015;
7017 -> 7016;
7018 -> 7017;
7018 -> 7014;
7019 -> 7014;
7020 -> 7018;
7020 -> 7019;
7021 -> 7019;
7021 -> 7002;
7022 -> 7004;
7022 -> 7021;
7023 -> 7021;
7024 -> 7022;
7024 -> 7023;
7025 -> 7005;
7025 -> 7023;
7026 -> 7024;
7026 -> 7023;
7027 -> 7023;
7028 -> 7026;
7028 -> 7027;
7029 -> 7025;
7029 -> 7027;
7030 -> 7028;
7030 -> 7027;
7031 -> 7027;
7032 -> 7027;
7033 -> 7029;
7033 -> 7032;
7034 -> 7032;
7035 -> 7033;
7035 -> 7034;
7036 -> 7035;
7036 -> 7032;
7037 -> 7036;
7038 -> 7037;
7038 -> 7027;
7039 -> 7031;
7039 -> 7027;
7040 -> 7029;
7041 -> 7029;
7041 -> 7040;
7042 -> 7040;
7043 -> 7041;
7043 -> 7042;
7044 -> 7043;
7044 -> 7040;
7045 -> 7040;
7045 -> 7029;
7046 -> 7029;
7047 -> 7046;
7047 -> 7029;
7048 -> 7045;
7048 -> 7047;
7048 -> 7029;
7049 -> 7029;
7049 -> 7001;
7050 -> 7029;
7051 -> 7029;
7052 -> 7029;
7053 -> 7029;
7053 -> 7052;
7054 -> 7053;
7054 -> 7001;
7054 -> 7029;
7054 -> 7052;
7055 -> 7054;
7055 -> 7029;
7056 -> 7029;
7056 -> 7027;
7057 -> 7029;
7057 -> 7027;
7058 -> 7029;
7058 -> 7027;
7059 -> 7027;
7060 -> 7058;
7060 -> 7059;
7061 -> 7027;
7062 -> 7029;
7062 -> 7061;
7063 -> 7062;
7063 -> 7027;
7064 -> 7027;
7065 -> 7063;
7065 -> 7064;
7066 -> 7029;
7066 -> 7023;
7067 -> 7023;
7068 -> 7025;
7068 -> 7067;
7069 -> 7068;
7069 -> 7029;
7069 -> 7067;
7070 -> 7069;
7070 -> 7023;
7071 -> 7023;
7072 -> 7025;
7072 -> 7071;
7073 -> 7072;
7073 -> 7029;
7073 -> 7071;
7074 -> 7073;
7074 -> 7023;
7075 -> 7023;
7076 -> 7074;
7076 -> 7075;
7077 -> 7070;
7077 -> 7076;
7077 -> 7023;
7078 -> 7066;
7078 -> 7023;
7079 -> 7078;
7079 -> 7021;
7080 -> 7001;
7080 -> 7002;
7081 -> 6938;
7081 -> 6989;
7082 -> 6989;
7083 -> 7081;
7083 -> 7082;
7084 -> 6941;
7084 -> 7082;
7085 -> 7082;
7086 -> 7084;
7086 -> 7085;
7087 -> 7086;
7087 -> 7079;
7087 -> 7085;
7088 -> 7087;
7088 -> 7082;
7089 -> 7082;
7090 -> 7088;
7090 -> 7089;
7091 -> 7090;
7092 -> 7090;
7093 -> 7091;
7093 -> 7092;
7094 -> 7093;
7094 -> 7092;
7095 -> 7092;
7096 -> 7094;
7096 -> 7095;
7097 -> 7096;
7097 -> 7095;
7098 -> 0;
7098 -> 7097;
7099 -> 7098;
7099 -> 6989;
7100 -> 7079;
7100 -> 6937;
7101 -> 6938;
7101 -> 6937;
7102 -> 6940;
7102 -> 6937;
7103 -> 6937;
7104 -> 7100;
7104 -> 7103;
7105 -> 7101;
7105 -> 7103;
7106 -> 7102;
7106 -> 7103;
7107 -> 6941;
7107 -> 7103;
7108 -> 7103;
7109 -> 7104;
7109 -> 7108;
7110 -> 7109;
7110 -> 7103;
7111 -> 7104;
7111 -> 7110;
7112 -> 7111;
7112 -> 7079;
7112 -> 7110;
7113 -> 7110;
7114 -> 7112;
7114 -> 7113;
7115 -> 7114;
7115 -> 7110;
7116 -> 7103;
7117 -> 7107;
7117 -> 7116;
7118 -> 7117;
7118 -> 7079;
7118 -> 7116;
7119 -> 7118;
7119 -> 7103;
7120 -> 7103;
7121 -> 7119;
7121 -> 7120;
7122 -> 7103;
7123 -> 7103;
7124 -> 7122;
7124 -> 7123;
7125 -> 7107;
7125 -> 7123;
7126 -> 7123;
7127 -> 7123;
7128 -> 7125;
7128 -> 7127;
7129 -> 7128;
7129 -> 7079;
7129 -> 7127;
7130 -> 7129;
7130 -> 7123;
7131 -> 7123;
7132 -> 7130;
7132 -> 7131;
7133 -> 7123;
7134 -> 7133;
7134 -> 7103;
7135 -> 7103;
7136 -> 7104;
7136 -> 7135;
7136 -> 7103;
7137 -> 7106;
7137 -> 7136;
7138 -> 7136;
7139 -> 7136;
7140 -> 7137;
7140 -> 7139;
7141 -> 7138;
7141 -> 7139;
7142 -> 7107;
7142 -> 7139;
7143 -> 7139;
7144 -> 7139;
7145 -> 7142;
7145 -> 7144;
7146 -> 7144;
7147 -> 7146;
7147 -> 7139;
7148 -> 7139;
7149 -> 7148;
7149 -> 7136;
7150 -> 7104;
7150 -> 7149;
7151 -> 7149;
7152 -> 7149;
7153 -> 7150;
7153 -> 7152;
7154 -> 7151;
7154 -> 7152;
7155 -> 7151;
7155 -> 7152;
7156 -> 7107;
7156 -> 7152;
7157 -> 7152;
7158 -> 7153;
7158 -> 7152;
7159 -> 7153;
7159 -> 7079;
7159 -> 7152;
7160 -> 7156;
7160 -> 7079;
7160 -> 7152;
7161 -> 7158;
7161 -> 7159;
7162 -> 7159;
7163 -> 7161;
7163 -> 7162;
7164 -> 7105;
7164 -> 7162;
7165 -> 7162;
7166 -> 7163;
7166 -> 7165;
7167 -> 7164;
7167 -> 7165;
7168 -> 7107;
7168 -> 7165;
7169 -> 7165;
7170 -> 7169;
7171 -> 7168;
7171 -> 7170;
7172 -> 7171;
7172 -> 7169;
7173 -> 7169;
7174 -> 7172;
7174 -> 7173;
7175 -> 7169;
7176 -> 7169;
7177 -> 7174;
7177 -> 7169;
7178 -> 7169;
7179 -> 7177;
7179 -> 7178;
7180 -> 7179;
7180 -> 7178;
7181 -> 7178;
7182 -> 7180;
7182 -> 7181;
7183 -> 7182;
7183 -> 7181;
7184 -> 7181;
7185 -> 7183;
7185 -> 7184;
7186 -> 7185;
7186 -> 7184;
7187 -> 0;
7187 -> 7186;
7188 -> 7174;
7188 -> 7187;
7189 -> 7187;
7190 -> 7188;
7190 -> 7189;
7191 -> 7190;
7191 -> 7189;
7192 -> 7189;
7193 -> 7191;
7193 -> 7192;
7194 -> 7193;
7194 -> 7192;
7195 -> 7194;
7196 -> 7174;
7196 -> 0;
7196 -> 7195;
7197 -> 7174;
7197 -> 0;
7197 -> 7196;
7198 -> 7174;
7198 -> 0;
7198 -> 7197;
7199 -> 7165;
7200 -> 7168;
7200 -> 7199;
7201 -> 7200;
7201 -> 7165;
7202 -> 7165;
7203 -> 7201;
7203 -> 7202;
7204 -> 7166;
7204 -> 7162;
7205 -> 7204;
7205 -> 7107;
7205 -> 7079;
7205 -> 7162;
7206 -> 7162;
7207 -> 7205;
7207 -> 7206;
7208 -> 7205;
7208 -> 7206;
7209 -> 7205;
7209 -> 7206;
7210 -> 7205;
7210 -> 7206;
7211 -> 7207;
7211 -> 7206;
7212 -> 7208;
7212 -> 7206;
7213 -> 7209;
7213 -> 7206;
7214 -> 7206;
7215 -> 7213;
7215 -> 7214;
7216 -> 7215;
7216 -> 7205;
7216 -> 7214;
7217 -> 7215;
7217 -> 7205;
7217 -> 7214;
7218 -> 7214;
7218 -> 7206;
7219 -> 7210;
7219 -> 7206;
7220 -> 7211;
7220 -> 7212;
7220 -> 7218;
7220 -> 7219;
7220 -> 7205;
7220 -> 7206;
7221 -> 7220;
7221 -> 7206;
7222 -> 7220;
7222 -> 7206;
7223 -> 7221;
7223 -> 7206;
7224 -> 7221;
7224 -> 7206;
7225 -> 6937;
7226 -> 7220;
7226 -> 7225;
7226 -> 6937;
7227 -> 7220;
7227 -> 7226;
7228 -> 6960;
7228 -> 7226;
7229 -> 7226;
7230 -> 7228;
7230 -> 7229;
7231 -> 7230;
7231 -> 6959;
7231 -> 7229;
7232 -> 7231;
7232 -> 7229;
7233 -> 7229;
7233 -> 7220;
7233 -> 7232;
7233 -> 6959;
7234 -> 7229;
7235 -> 7229;
7236 -> 7226;
7237 -> 6916;
7238 -> 6920;
7238 -> 7237;
7239 -> 7238;
7239 -> 7220;
7239 -> 7237;
7240 -> 7239;
7240 -> 6916;
7241 -> 6916;
7242 -> 7240;
7242 -> 7241;
7243 -> 7227;
7243 -> 6916;
7244 -> 6908;
7245 -> 6912;
7245 -> 7244;
7246 -> 7245;
7246 -> 7220;
7246 -> 7244;
7247 -> 7246;
7247 -> 6908;
7248 -> 6908;
7249 -> 7247;
7249 -> 7248;
7250 -> 7243;
7250 -> 6908;
7251 -> 7250;
7251 -> 6896;
7252 -> 7250;
7252 -> 6896;
7253 -> 7252;
7253 -> 6894;
7254 -> 6894;
7255 -> 7253;
7255 -> 7254;
7256 -> 6895;
7256 -> 7254;
7257 -> 7254;
7258 -> 7255;
7258 -> 7257;
7259 -> 7258;
7259 -> 7254;
7260 -> 7255;
7260 -> 7259;
7261 -> 7260;
7261 -> 6893;
7262 -> 6893;
7263 -> 7262;
7263 -> 7220;
7264 -> 7263;
7264 -> 6893;
7265 -> 6893;
7266 -> 7264;
7266 -> 7265;
7267 -> 6893;
7268 -> 7261;
7268 -> 7267;
7269 -> 7268;
7269 -> 6893;
7270 -> 7261;
7270 -> 6893;
7271 -> 0;
7271 -> 7270;
7272 -> 7270;
7273 -> 7271;
7273 -> 7272;
7274 -> 7273;
7274 -> 7272;
7275 -> 7272;
7276 -> 7274;
7276 -> 7275;
7277 -> 7276;
7277 -> 0;
7277 -> 7275;
7278 -> 7277;
7279 -> 7273;
7280 -> 7273;
7281 -> 6887;
7281 -> 7270;
7282 -> 7261;
7282 -> 7270;
7283 -> 7273;
7283 -> 7270;
7284 -> 7281;
7284 -> 7282;
7284 -> 7283;
7284 -> 6868;
7284 -> 7220;
7284 -> 7229;
7284 -> 7273;
7284 -> 7270;
7285 -> 7270;
7286 -> 7284;
7286 -> 7285;
7287 -> 7286;
7287 -> 7285;
7288 -> 7287;
7288 -> 7284;
7288 -> 7285;
7289 -> 7287;
7289 -> 7284;
7289 -> 7285;
7290 -> 7286;
7290 -> 7285;
7291 -> 7286;
7291 -> 7285;
7292 -> 7290;
7292 -> 7285;
7293 -> 7290;
7293 -> 7285;
7294 -> 7286;
7294 -> 6867;
7295 -> 6867;
7296 -> 6868;
7296 -> 7295;
7297 -> 7296;
7297 -> 7294;
7297 -> 7295;
7298 -> 7296;
7298 -> 7294;
7298 -> 7295;
7299 -> 7298;
7299 -> 6867;
7300 -> 7299;
7301 -> 7299;
7302 -> 7299;
7303 -> 7299;
7304 -> 7299;
7305 -> 7299;
7306 -> 7299;
7306 -> 7294;
7307 -> 7299;
7308 -> 7299;
7309 -> 7307;
7309 -> 7299;
7310 -> 7308;
7310 -> 7299;
7311 -> 7309;
7311 -> 7299;
7312 -> 7310;
7312 -> 7299;
7313 -> 7311;
7313 -> 7299;
7314 -> 7312;
7314 -> 7299;
7315 -> 7313;
7315 -> 7299;
7316 -> 7314;
7316 -> 7299;
7317 -> 7299;
7318 -> 7317;
7318 -> 7299;
7319 -> 7299;
7320 -> 7318;
7320 -> 7319;
7321 -> 7320;
7321 -> 7299;
7322 -> 7299;
7323 -> 7322;
7323 -> 7299;
7324 -> 7299;
7325 -> 7323;
7325 -> 7324;
7326 -> 7299;
7327 -> 7326;
7327 -> 7299;
7328 -> 7299;
7329 -> 7327;
7329 -> 7328;
7330 -> 7299;
7331 -> 7299;
7332 -> 7317;
7332 -> 7299;
7333 -> 7299;
7334 -> 7332;
7334 -> 7333;
7335 -> 7317;
7335 -> 7324;
7336 -> 7313;
7336 -> 7335;
7337 -> 7335;
7338 -> 7337;
7338 -> 7335;
7339 -> 7335;
7340 -> 7338;
7340 -> 7339;
7341 -> 7336;
7341 -> 7335;
7342 -> 7336;
7342 -> 7335;
7343 -> 7335;
7344 -> 7336;
7344 -> 7343;
7345 -> 7344;
7345 -> 7335;
7346 -> 7335;
7347 -> 7345;
7347 -> 7346;
7348 -> 7335;
7349 -> 7347;
7349 -> 7348;
7350 -> 7336;
7351 -> 7336;
7352 -> 7350;
7352 -> 7351;
7353 -> 7352;
7353 -> 7336;
7354 -> 7342;
7354 -> 7336;
7355 -> 7354;
7355 -> 7336;
7356 -> 7355;
7356 -> 7336;
7357 -> 7336;
7358 -> 7336;
7359 -> 7336;
7359 -> 7358;
7360 -> 7358;
7361 -> 7359;
7361 -> 7360;
7362 -> 7361;
7362 -> 7358;
7363 -> 7362;
7364 -> 7363;
7364 -> 7336;
7365 -> 7357;
7365 -> 7336;
7366 -> 7336;
7367 -> 7336;
7367 -> 7366;
7368 -> 7366;
7369 -> 7367;
7369 -> 7368;
7370 -> 7369;
7370 -> 7366;
7371 -> 7366;
7371 -> 7336;
7372 -> 7336;
7373 -> 7372;
7373 -> 7336;
7374 -> 7371;
7374 -> 7373;
7374 -> 7336;
7375 -> 7336;
7376 -> 7336;
7377 -> 7336;
7378 -> 7336;
7379 -> 7336;
7379 -> 7378;
7380 -> 7379;
7380 -> 7336;
7380 -> 7378;
7381 -> 7380;
7381 -> 7336;
7382 -> 7357;
7382 -> 7336;
7383 -> 7336;
7383 -> 7357;
7384 -> 7357;
7384 -> 7336;
7385 -> 7336;
7386 -> 7384;
7386 -> 7385;
7387 -> 7336;
7388 -> 7387;
7388 -> 7357;
7389 -> 7388;
7389 -> 7336;
7390 -> 7336;
7391 -> 7389;
7391 -> 7390;
7392 -> 7336;
7393 -> 7392;
7393 -> 7357;
7394 -> 7393;
7394 -> 7336;
7395 -> 7336;
7396 -> 7395;
7396 -> 7357;
7397 -> 7396;
7397 -> 7336;
7398 -> 7336;
7399 -> 7397;
7399 -> 7398;
7400 -> 7394;
7400 -> 7399;
7400 -> 7336;
7401 -> 7336;
7401 -> 7335;
7402 -> 7315;
7402 -> 7335;
7403 -> 7335;
7404 -> 7402;
7404 -> 7403;
7405 -> 7299;
7405 -> 7403;
7406 -> 7403;
7407 -> 7405;
7407 -> 7406;
7408 -> 7407;
7408 -> 7357;
7408 -> 7406;
7409 -> 7408;
7409 -> 7403;
7410 -> 7403;
7411 -> 7409;
7411 -> 7410;
7412 -> 7411;
7413 -> 7411;
7414 -> 7412;
7414 -> 7413;
7415 -> 7414;
7415 -> 7413;
7416 -> 7413;
7417 -> 7415;
7417 -> 7416;
7418 -> 7417;
7418 -> 7416;
7419 -> 0;
7419 -> 7418;
7420 -> 7419;
7420 -> 7335;
7421 -> 7315;
7421 -> 7299;
7422 -> 7316;
7422 -> 7299;
7423 -> 7299;
7424 -> 7357;
7424 -> 7423;
7425 -> 7424;
7425 -> 7299;
7426 -> 7357;
7426 -> 7425;
7427 -> 7426;
7427 -> 7357;
7427 -> 7425;
7428 -> 7425;
7429 -> 7427;
7429 -> 7428;
7430 -> 7429;
7430 -> 7425;
7431 -> 7299;
7432 -> 7431;
7432 -> 7357;
7433 -> 7432;
7433 -> 7299;
7434 -> 7299;
7435 -> 7433;
7435 -> 7434;
7436 -> 7299;
7437 -> 7299;
7438 -> 7436;
7438 -> 7437;
7439 -> 7299;
7439 -> 7437;
7440 -> 7437;
7441 -> 7437;
7442 -> 7439;
7442 -> 7441;
7443 -> 7442;
7443 -> 7357;
7443 -> 7441;
7444 -> 7443;
7444 -> 7437;
7445 -> 7437;
7446 -> 7444;
7446 -> 7445;
7447 -> 7437;
7448 -> 7447;
7448 -> 7299;
7449 -> 7422;
7449 -> 7357;
7450 -> 7449;
7450 -> 7357;
7451 -> 7357;
7452 -> 7299;
7452 -> 7357;
7453 -> 7357;
7454 -> 7357;
7455 -> 7452;
7455 -> 7454;
7456 -> 7454;
7457 -> 7456;
7457 -> 7357;
7458 -> 7357;
7459 -> 7357;
7460 -> 7299;
7460 -> 7357;
7461 -> 7357;
7462 -> 7421;
7462 -> 7357;
7463 -> 7462;
7463 -> 7357;
7464 -> 7299;
7464 -> 7357;
7465 -> 7357;
7466 -> 7465;
7467 -> 7464;
7467 -> 7466;
7468 -> 7467;
7468 -> 7465;
7469 -> 7465;
7470 -> 7468;
7470 -> 7469;
7471 -> 7465;
7472 -> 7465;
7473 -> 7470;
7473 -> 7465;
7474 -> 7465;
7475 -> 7473;
7475 -> 7474;
7476 -> 7475;
7476 -> 7474;
7477 -> 7474;
7478 -> 7476;
7478 -> 7477;
7479 -> 7478;
7479 -> 7477;
7480 -> 7477;
7481 -> 7479;
7481 -> 7480;
7482 -> 7481;
7482 -> 7480;
7483 -> 0;
7483 -> 7482;
7484 -> 7470;
7484 -> 7483;
7485 -> 7483;
7486 -> 7484;
7486 -> 7485;
7487 -> 7486;
7487 -> 7485;
7488 -> 7485;
7489 -> 7487;
7489 -> 7488;
7490 -> 7489;
7490 -> 7488;
7491 -> 7490;
7492 -> 7470;
7492 -> 0;
7492 -> 7491;
7493 -> 7470;
7493 -> 0;
7493 -> 7492;
7494 -> 7470;
7494 -> 0;
7494 -> 7493;
7495 -> 7357;
7496 -> 7464;
7496 -> 7495;
7497 -> 7496;
7497 -> 7357;
7498 -> 7357;
7499 -> 7497;
7499 -> 7498;
7500 -> 7357;
7501 -> 7500;
7501 -> 7357;
7502 -> 7501;
7502 -> 7357;
7503 -> 7501;
7503 -> 7357;
7504 -> 7500;
7505 -> 7500;
7506 -> 7504;
7506 -> 7500;
7507 -> 7504;
7507 -> 7500;
7508 -> 7330;
7508 -> 7500;
7509 -> 7508;
7509 -> 7500;
7510 -> 7509;
7510 -> 7299;
7510 -> 7500;
7511 -> 7510;
7511 -> 7500;
7512 -> 7500;
7512 -> 7511;
7512 -> 7299;
7513 -> 7500;
7514 -> 7500;
7515 -> 7500;
7516 -> 7299;
7517 -> 7516;
7517 -> 7500;
7518 -> 7517;
7518 -> 7299;
7519 -> 7299;
7520 -> 7518;
7520 -> 7519;
7521 -> 7299;
7522 -> 7521;
7522 -> 7500;
7523 -> 7522;
7523 -> 7299;
7524 -> 7299;
7525 -> 7523;
7525 -> 7524;
7526 -> 7500;
7526 -> 7299;
7527 -> 7299;
7528 -> 7299;
7529 -> 7528;
7529 -> 7500;
7530 -> 7529;
7530 -> 7299;
7531 -> 7299;
7532 -> 7530;
7532 -> 7531;
7533 -> 7299;
7534 -> 7500;
7534 -> 7533;
7535 -> 7534;
7535 -> 7299;
7536 -> 7500;
7537 -> 7500;
7538 -> 7536;
7538 -> 7537;
7539 -> 7538;
7539 -> 0;
7539 -> 7537;
7540 -> 7539;
7541 -> 7500;
7542 -> 7500;
7543 -> 7500;
7544 -> 7500;
7545 -> 7544;
7545 -> 7500;
7546 -> 7544;
7546 -> 7500;
7547 -> 7296;
7547 -> 7500;
7547 -> 7295;
7548 -> 7295;
7549 -> 7296;
7549 -> 7548;
7550 -> 7549;
7550 -> 7500;
7550 -> 7548;
7551 -> 7295;
7552 -> 7550;
7552 -> 7551;
7553 -> 6867;
7554 -> 6872;
7554 -> 7500;
7554 -> 7553;
7554 -> 6867;
7555 -> 7554;
7555 -> 6867;
7556 -> 6873;
7556 -> 6867;
7557 -> 6867;
7558 -> 6867;
7559 -> 7555;
7559 -> 7558;
7560 -> 7556;
7560 -> 7558;
7561 -> 7557;
7561 -> 7558;
7562 -> 6868;
7562 -> 7558;
7563 -> 7562;
7563 -> 7554;
7563 -> 7558;
7564 -> 7562;
7564 -> 7554;
7564 -> 0;
7564 -> 7558;
7565 -> 7564;
7565 -> 7562;
7565 -> 7558;
7566 -> 7561;
7566 -> 7558;
7567 -> 7562;
7567 -> 7554;
7567 -> 7565;
7567 -> 0;
7567 -> 7566;
7568 -> 7567;
7568 -> 7562;
7568 -> 7566;
7569 -> 7558;
7570 -> 7558;
7571 -> 7562;
7571 -> 7570;
7572 -> 7571;
7572 -> 7554;
7572 -> 7570;
7573 -> 7572;
7573 -> 7558;
7574 -> 7558;
7575 -> 7573;
7575 -> 7574;
7576 -> 7558;
7577 -> 7562;
7577 -> 7576;
7578 -> 7577;
7578 -> 7554;
7578 -> 7576;
7579 -> 7578;
7579 -> 7558;
7580 -> 7558;
7581 -> 7579;
7581 -> 7580;
7582 -> 7575;
7582 -> 7581;
7582 -> 7558;
7583 -> 7558;
7584 -> 7562;
7584 -> 7583;
7585 -> 7584;
7585 -> 7554;
7585 -> 7583;
7586 -> 7583;
7587 -> 7584;
7587 -> 7586;
7588 -> 7587;
7588 -> 7554;
7588 -> 7586;
7589 -> 7583;
7590 -> 7588;
7590 -> 7589;
7591 -> 7590;
7591 -> 7558;
7592 -> 7561;
7592 -> 7591;
7592 -> 7558;
7593 -> 7582;
7593 -> 7592;
7593 -> 7558;
7594 -> 7569;
7594 -> 7558;
7595 -> 7558;
7596 -> 7558;
7597 -> 7594;
7597 -> 7596;
7598 -> 7595;
7598 -> 7596;
7599 -> 7562;
7599 -> 7596;
7600 -> 7599;
7600 -> 7554;
7600 -> 7596;
7601 -> 7600;
7601 -> 7597;
7601 -> 7596;
7602 -> 7593;
7602 -> 7601;
7602 -> 7558;
7603 -> 7602;
7604 -> 7602;
7605 -> 7603;
7605 -> 7604;
7606 -> 7562;
7606 -> 7604;
7607 -> 7604;
7608 -> 7606;
7608 -> 7607;
7609 -> 7608;
7609 -> 7604;
7610 -> 7604;
7611 -> 7609;
7611 -> 7610;
7612 -> 7611;
7612 -> 7604;
7613 -> 7612;
7614 -> 7613;
7614 -> 7602;
7615 -> 7614;
7616 -> 7615;
7616 -> 7554;
7616 -> 7565;
7616 -> 7568;
7617 -> 7616;
7617 -> 7615;
7618 -> 7615;
7619 -> 7617;
7619 -> 7618;
7620 -> 7619;
7620 -> 7615;
7621 -> 7615;
7622 -> 7621;
7622 -> 7615;
7623 -> 7616;
7623 -> 7615;
7624 -> 7622;
7624 -> 7615;
7625 -> 7623;
7625 -> 7615;
7626 -> 7624;
7626 -> 7615;
7627 -> 7615;
7628 -> 7625;
7628 -> 7627;
7629 -> 7626;
7629 -> 7627;
7630 -> 7615;
7630 -> 7627;
7631 -> 7627;
7632 -> 7630;
7632 -> 7631;
7633 -> 7631;
7634 -> 7632;
7634 -> 7633;
7635 -> 7634;
7635 -> 7616;
7635 -> 7633;
7636 -> 7635;
7636 -> 7631;
7637 -> 7636;
7638 -> 7637;
7638 -> 7627;
7639 -> 7638;
7639 -> 7615;
7640 -> 7615;
7641 -> 7615;
7641 -> 7616;
7642 -> 7615;
7643 -> 7623;
7643 -> 7616;
7644 -> 7616;
7645 -> 7644;
7646 -> 7644;
7647 -> 7644;
7647 -> 7616;
7648 -> 7643;
7648 -> 7647;
7648 -> 7615;
7648 -> 7616;
7648 -> 7644;
7649 -> 7616;
7650 -> 7648;
7650 -> 7649;
7651 -> 7648;
7651 -> 7649;
7652 -> 7648;
7652 -> 7649;
7653 -> 7648;
7653 -> 7649;
7654 -> 7648;
7654 -> 7649;
7655 -> 7650;
7655 -> 7649;
7656 -> 7651;
7656 -> 7649;
7657 -> 7652;
7657 -> 7649;
7658 -> 7653;
7658 -> 7649;
7659 -> 7649;
7660 -> 7658;
7660 -> 7659;
7661 -> 7660;
7661 -> 7648;
7661 -> 7659;
7662 -> 7660;
7662 -> 7648;
7662 -> 7659;
7663 -> 7659;
7663 -> 7649;
7664 -> 7654;
7664 -> 7649;
7665 -> 7655;
7665 -> 7656;
7665 -> 7657;
7665 -> 7663;
7665 -> 7664;
7665 -> 7648;
7665 -> 7649;
7666 -> 7665;
7666 -> 7649;
7667 -> 7665;
7667 -> 7649;
7668 -> 7666;
7668 -> 7649;
7669 -> 7666;
7669 -> 7649;
7670 -> 7615;
7670 -> 7665;
7670 -> 7616;
7671 -> 7640;
7671 -> 7616;
7672 -> 7616;
7673 -> 7671;
7673 -> 7672;
7674 -> 7673;
7674 -> 7616;
7674 -> 7672;
7675 -> 7674;
7675 -> 7672;
7676 -> 7672;
7676 -> 7665;
7676 -> 7675;
7676 -> 7616;
7677 -> 7672;
7677 -> 7665;
7678 -> 7672;
7679 -> 7672;
7679 -> 7665;
7679 -> 7677;
7679 -> 7678;
7680 -> 7672;
7681 -> 7616;
7682 -> 7665;
7682 -> 7614;
7683 -> 7614;
7684 -> 7682;
7684 -> 7683;
7684 -> 7614;
7685 -> 7682;
7685 -> 7684;
7686 -> 7560;
7686 -> 7685;
7686 -> 6873;
7686 -> 7665;
7686 -> 7670;
7686 -> 7677;
7686 -> 7684;
7687 -> 7602;
7687 -> 7686;
7688 -> 7563;
7688 -> 7562;
7688 -> 7686;
7689 -> 6867;
7690 -> 6872;
7690 -> 7686;
7690 -> 7689;
7690 -> 6867;
7691 -> 7559;
7691 -> 7690;
7691 -> 6867;
7692 -> 7691;
7692 -> 6867;
7693 -> 6873;
7693 -> 6867;
7694 -> 7692;
7694 -> 7693;
7694 -> 6868;
7694 -> 7686;
7694 -> 6873;
7694 -> 7688;
7694 -> 6867;
7695 -> 6867;
7696 -> 7694;
7696 -> 7695;
7697 -> 7695;
7698 -> 7696;
7698 -> 7697;
7699 -> 7698;
7699 -> 7694;
7699 -> 7697;
7700 -> 7698;
7700 -> 7694;
7700 -> 7697;
7701 -> 7697;
7701 -> 7695;
7702 -> 7696;
7702 -> 7695;
7703 -> 7696;
7703 -> 7695;
7704 -> 7702;
7704 -> 7695;
7705 -> 7702;
7705 -> 7695;
7706 -> 6873;
7706 -> 6867;
7707 -> 6868;
7707 -> 7696;
7707 -> 7706;
7707 -> 6873;
7707 -> 6867;
7708 -> 7691;
7708 -> 6867;
7709 -> 6868;
7709 -> 7707;
7709 -> 7708;
7709 -> 6867;
7710 -> 7696;
7710 -> 6866;
7711 -> 7710;
7711 -> 6866;
7712 -> 6856;
7712 -> 7711;
7712 -> 7709;
7712 -> 6866;
7713 -> 6857;
7714 -> 6858;
7714 -> 7713;
7715 -> 6857;
7716 -> 0;
7716 -> 5516;
7717 -> 5516;
7718 -> 7716;
7718 -> 7717;
7719 -> 5518;
7719 -> 7717;
7720 -> 7718;
7720 -> 7717;
7721 -> 7717;
7722 -> 7720;
7722 -> 7721;
7723 -> 7722;
7723 -> 0;
7723 -> 7721;
7724 -> 7723;
7725 -> 7717;
7726 -> 7719;
7726 -> 7725;
7727 -> 7726;
7727 -> 7712;
7727 -> 7725;
7728 -> 7717;
7729 -> 7727;
7729 -> 7718;
7729 -> 7717;
7730 -> 7729;
7730 -> 7712;
7731 -> 7729;
7732 -> 7729;
7733 -> 5517;
7733 -> 5516;
7734 -> 5553;
7734 -> 5516;
7735 -> 6835;
7735 -> 5516;
7736 -> 6836;
7736 -> 5516;
7737 -> 6837;
7737 -> 5516;
7738 -> 6853;
7738 -> 5516;
7739 -> 6856;
7739 -> 5516;
7740 -> 7729;
7740 -> 5516;
7741 -> 7733;
7741 -> 7734;
7741 -> 7735;
7741 -> 7736;
7741 -> 7737;
7741 -> 7738;
7741 -> 7739;
7741 -> 7740;
7741 -> 5518;
7741 -> 7712;
7741 -> 5449;
7741 -> 7729;
7741 -> 5516;
7742 -> 5516;
7743 -> 7742;
7744 -> 7743;
7744 -> 7742;
7745 -> 7741;
7745 -> 7742;
7746 -> 7741;
7746 -> 7742;
7747 -> 7745;
7747 -> 7741;
7747 -> 7742;
7748 -> 7745;
7748 -> 7741;
7748 -> 7742;
7749 -> 6856;
7749 -> 5516;
7750 -> 5518;
7750 -> 7741;
7750 -> 7749;
7750 -> 5516;
7751 -> 5504;
7751 -> 5514;
7752 -> 5514;
7753 -> 7751;
7753 -> 7752;
7754 -> 5457;
7754 -> 7752;
7755 -> 7753;
7755 -> 5499;
7755 -> 7752;
7756 -> 7752;
7757 -> 7755;
7757 -> 7756;
7758 -> 7754;
7758 -> 7756;
7759 -> 7758;
7759 -> 7750;
7759 -> 7757;
7759 -> 5488;
7759 -> 7756;
7760 -> 7756;
7761 -> 7758;
7761 -> 7750;
7761 -> 7760;
7761 -> 7756;
7762 -> 7761;
7763 -> 7762;
7763 -> 7758;
7763 -> 7761;
7764 -> 7752;
7765 -> 5514;
7766 -> 7763;
7766 -> 890;
7767 -> 894;
7767 -> 890;
7768 -> 7766;
7768 -> 7767;
7769 -> 7767;
7770 -> 7768;
7770 -> 7769;
7771 -> 5411;
7771 -> 7769;
7772 -> 7769;
7773 -> 7771;
7773 -> 7772;
7774 -> 7772;
7775 -> 7773;
7775 -> 7774;
7776 -> 7775;
7776 -> 7763;
7776 -> 7774;
7777 -> 7774;
7778 -> 7775;
7778 -> 7763;
7778 -> 7777;
7778 -> 7774;
7779 -> 7778;
7779 -> 7769;
7780 -> 7769;
7781 -> 7779;
7781 -> 7780;
7782 -> 7770;
7782 -> 7781;
7783 -> 7782;
7783 -> 890;
7784 -> 7782;
7784 -> 7763;
7784 -> 7778;
7784 -> 890;
7785 -> 890;
7786 -> 7784;
7786 -> 7785;
7787 -> 7784;
7787 -> 7785;
7788 -> 7784;
7788 -> 7785;
7789 -> 7783;
7789 -> 7785;
7790 -> 7786;
7790 -> 7785;
7791 -> 7787;
7791 -> 7785;
7792 -> 7788;
7792 -> 7785;
7793 -> 7785;
7794 -> 7793;
7794 -> 7790;
7794 -> 7791;
7794 -> 7792;
7794 -> 7784;
7794 -> 7785;
7795 -> 7794;
7795 -> 1;
7796 -> 0;
7796 -> 1;
7797 -> 1;
7798 -> 7794;
7798 -> 7797;
7799 -> 7798;
7799 -> 7794;
7799 -> 7797;
7800 -> 7799;
7800 -> 1;
7801 -> 206;
7801 -> 1;
7802 -> 7794;
7802 -> 1;
7803 -> 1;
7804 -> 7802;
7804 -> 7803;
7805 -> 7803;
7806 -> 7802;
7806 -> 7805;
7806 -> 1;
7807 -> 7802;
7807 -> 7803;
7808 -> 7802;
7808 -> 7803;
7809 -> 7802;
7809 -> 7803;
7810 -> 7802;
7810 -> 7803;
7811 -> 7808;
7811 -> 7803;
7812 -> 7803;
7813 -> 7810;
7813 -> 7812;
7814 -> 7812;
7815 -> 7813;
7815 -> 7814;
7816 -> 7815;
7816 -> 7806;
7816 -> 7814;
7817 -> 7816;
7817 -> 7812;
7818 -> 7812;
7819 -> 7817;
7819 -> 7818;
7820 -> 7819;
7820 -> 7818;
7821 -> 7820;
7822 -> 7821;
7822 -> 7803;
7823 -> 7807;
7823 -> 7822;
7823 -> 7806;
7823 -> 7803;
7824 -> 7809;
7824 -> 7803;
7825 -> 7824;
7826 -> 7810;
7826 -> 7825;
7827 -> 7826;
7827 -> 7823;
7827 -> 7825;
7828 -> 7827;
7828 -> 7824;
7829 -> 7824;
7830 -> 7828;
7830 -> 7829;
7830 -> 7824;
7831 -> 7807;
7831 -> 7830;
7832 -> 7830;
7833 -> 7831;
7833 -> 7832;
7834 -> 7832;
7835 -> 7831;
7835 -> 7832;
7836 -> 7831;
7836 -> 7832;
7837 -> 7836;
7837 -> 7834;
7837 -> 7832;
7838 -> 7835;
7838 -> 7837;
7838 -> 7834;
7838 -> 7832;
7839 -> 7811;
7840 -> 7810;
7840 -> 7839;
7841 -> 7839;
7842 -> 7841;
7842 -> 7811;
7843 -> 7811;
7844 -> 7842;
7844 -> 7843;
7844 -> 7811;
7845 -> 7838;
7846 -> 7810;
7846 -> 7825;
7847 -> 7825;
7847 -> 7824;
7848 -> 7847;
7848 -> 7829;
7848 -> 7824;
7849 -> 7810;
7849 -> 7812;
7850 -> 7849;
7850 -> 7845;
7850 -> 7812;
7851 -> 7810;
7851 -> 7839;
7852 -> 7851;
7852 -> 7850;
7852 -> 7839;
7853 -> 7852;
7853 -> 7811;
7854 -> 7853;
7854 -> 7843;
7854 -> 7811;
7855 -> 7850;
7856 -> 7855;
7857 -> 7851;
7857 -> 7855;
7857 -> 7839;
7858 -> 7857;
7858 -> 7811;
7859 -> 7858;
7859 -> 7843;
7859 -> 7811;
7860 -> 7855;
7861 -> 7860;
7862 -> 7851;
7862 -> 7860;
7862 -> 7839;
7863 -> 7862;
7863 -> 7811;
7864 -> 7863;
7864 -> 7843;
7864 -> 7811;
7865 -> 7860;
7866 -> 7865;
7867 -> 7851;
7867 -> 7865;
7867 -> 7839;
7868 -> 7867;
7868 -> 7811;
7869 -> 7868;
7869 -> 7843;
7869 -> 7811;
7870 -> 7865;
7871 -> 7870;
7872 -> 7851;
7872 -> 7870;
7872 -> 7839;
7873 -> 7872;
7873 -> 7811;
7874 -> 7873;
7874 -> 7843;
7874 -> 7811;
7875 -> 7870;
7876 -> 7875;
7877 -> 7875;
7878 -> 1;
7879 -> 7794;
7879 -> 1;
7880 -> 1;
7881 -> 7879;
7881 -> 7880;
7882 -> 7881;
7882 -> 7877;
7882 -> 7880;
7883 -> 7880;
7884 -> 7880;
7885 -> 7882;
7885 -> 7884;
7886 -> 7883;
7886 -> 7884;
7887 -> 7884;
7888 -> 7885;
7888 -> 7884;
7889 -> 7888;
7889 -> 7884;
7890 -> 7887;
7890 -> 7884;
7891 -> 7890;
7891 -> 7880;
7892 -> 7891;
7892 -> 1;
7893 -> 7794;
7893 -> 1;
7894 -> 1;
7895 -> 7893;
7895 -> 7888;
7895 -> 1;
7896 -> 1;
7897 -> 7895;
7897 -> 7896;
7898 -> 7896;
7899 -> 7898;
7899 -> 1;
7900 -> 7895;
7900 -> 7899;
7900 -> 1;
7901 -> 0;
7901 -> 1;
7902 -> 7893;
7902 -> 7900;
7902 -> 1;
7903 -> 1;
7904 -> 7902;
7904 -> 7903;
7905 -> 7903;
7906 -> 7905;
7906 -> 1;
7907 -> 7902;
7907 -> 7906;
7907 -> 1;
7908 -> 7902;
7908 -> 7903;
7909 -> 7908;
7909 -> 7907;
7909 -> 7903;
7910 -> 7909;
7910 -> 7903;
7911 -> 7903;
7912 -> 7910;
7912 -> 7911;
7913 -> 7911;
7914 -> 0;
7914 -> 7911;
7915 -> 7912;
7915 -> 7913;
7915 -> 7911;
7916 -> 7911;
7917 -> 7914;
7917 -> 7916;
7917 -> 7911;
7918 -> 7917;
7918 -> 7913;
7918 -> 7911;
7919 -> 7915;
7919 -> 7918;
7919 -> 7911;
7920 -> 1;
7921 -> 7893;
7921 -> 7919;
7921 -> 1;
7922 -> 1;
7923 -> 7921;
7923 -> 7922;
7924 -> 7922;
7925 -> 7924;
7925 -> 1;
7926 -> 7921;
7926 -> 7925;
7926 -> 1;
7927 -> 7893;
7927 -> 7926;
7927 -> 1;
7928 -> 1;
7929 -> 7927;
7929 -> 7928;
7930 -> 7927;
7930 -> 7928;
7931 -> 7927;
7931 -> 7928;
7932 -> 7927;
7932 -> 7928;
7933 -> 7928;
7934 -> 1;
7935 -> 1;
7936 -> 7893;
7936 -> 7929;
7936 -> 7935;
7937 -> 7935;
7938 -> 7936;
7938 -> 7929;
7938 -> 7937;
7939 -> 7938;
7939 -> 7935;
7940 -> 7939;
7940 -> 1;
7941 -> 1;
7942 -> 7893;
7942 -> 7929;
7942 -> 1;
7943 -> 1;
7944 -> 7942;
7944 -> 7943;
7945 -> 7943;
7946 -> 7945;
7946 -> 1;
7947 -> 7942;
7947 -> 7946;
7947 -> 1;
7948 -> 1;
7949 -> 7893;
7949 -> 7947;
7949 -> 1;
7950 -> 1;
7951 -> 7949;
7951 -> 7950;
7952 -> 7950;
7953 -> 7952;
7953 -> 1;
7954 -> 7949;
7954 -> 7953;
7954 -> 1;
7955 -> 1;
7956 -> 7893;
7956 -> 7954;
7956 -> 1;
7957 -> 1;
7958 -> 7956;
7958 -> 7957;
7959 -> 7956;
7959 -> 7957;
7960 -> 7956;
7960 -> 7957;
7961 -> 7956;
7961 -> 7957;
7962 -> 7957;
7963 -> 1;
7964 -> 7893;
7964 -> 7958;
7964 -> 7963;
7964 -> 1;
7965 -> 1;
7966 -> 7893;
7966 -> 7964;
7966 -> 7965;
7966 -> 1;
7967 -> 1;
7968 -> 7966;
7968 -> 7967;
7969 -> 7966;
7969 -> 7967;
7970 -> 7966;
7970 -> 7967;
7971 -> 7966;
7971 -> 7967;
7972 -> 7967;
7973 -> 7966;
7973 -> 7967;
7974 -> 7967;
7975 -> 7974;
7975 -> 1;
7976 -> 0;
7976 -> 1;
7977 -> 1;
7978 -> 7893;
7978 -> 7968;
7978 -> 7977;
7978 -> 1;
7979 -> 1;
7980 -> 7978;
7980 -> 7979;
7981 -> 7979;
7982 -> 7981;
7982 -> 1;
7983 -> 7978;
7983 -> 7982;
7983 -> 1;
7984 -> 7978;
7984 -> 7979;
7985 -> 7979;
7986 -> 7985;
7987 -> 0;
7987 -> 7985;
7988 -> 7985;
7989 -> 7987;
7989 -> 7988;
7989 -> 7985;
7990 -> 7989;
7990 -> 7986;
7990 -> 7985;
7991 -> 1;
7992 -> 7893;
7992 -> 7984;
7992 -> 7991;
7992 -> 1;
7993 -> 7992;
7993 -> 1;
7994 -> 7992;
7994 -> 1;
7995 -> 1;
7996 -> 7994;
7996 -> 7995;
7997 -> 7994;
7997 -> 7995;
7998 -> 7994;
7998 -> 7995;
7999 -> 7994;
7999 -> 7995;
8000 -> 7995;
8001 -> 1;
8002 -> 1;
8003 -> 7992;
8003 -> 7996;
8003 -> 8002;
8004 -> 8002;
8005 -> 8003;
8005 -> 7996;
8005 -> 8004;
8006 -> 8005;
8006 -> 8002;
8007 -> 8006;
8007 -> 1;
8008 -> 1;
8009 -> 7893;
8009 -> 7996;
8009 -> 8008;
8009 -> 1;
8010 -> 1;
8011 -> 8009;
8011 -> 8010;
8012 -> 8009;
8012 -> 8010;
8013 -> 8009;
8013 -> 8010;
8014 -> 8009;
8014 -> 8010;
8015 -> 8010;
8016 -> 8009;
8016 -> 8010;
8017 -> 8010;
8018 -> 8017;
8018 -> 1;
8019 -> 0;
8019 -> 1;
8020 -> 1;
8021 -> 7893;
8021 -> 8011;
8021 -> 8020;
8021 -> 1;
8022 -> 1;
8023 -> 8021;
8023 -> 8022;
8024 -> 8022;
8025 -> 8024;
8025 -> 1;
8026 -> 8021;
8026 -> 8025;
8026 -> 1;
8027 -> 8021;
8027 -> 8022;
8028 -> 8022;
8029 -> 8028;
8030 -> 0;
8030 -> 8028;
8031 -> 8028;
8032 -> 8030;
8032 -> 8031;
8032 -> 8028;
8033 -> 8032;
8033 -> 8029;
8033 -> 8028;
8034 -> 1;
8035 -> 7893;
8035 -> 8027;
8035 -> 8034;
8035 -> 1;
8036 -> 8035;
8036 -> 1;
8037 -> 8035;
8037 -> 1;
8038 -> 1;
8039 -> 8037;
8039 -> 8038;
8040 -> 8037;
8040 -> 8038;
8041 -> 8037;
8041 -> 8038;
8042 -> 8037;
8042 -> 8038;
8043 -> 8038;
8044 -> 1;
8045 -> 1;
8046 -> 8035;
8046 -> 8039;
8046 -> 8045;
8047 -> 8045;
8048 -> 8046;
8048 -> 8039;
8048 -> 8047;
8049 -> 8048;
8049 -> 8045;
8050 -> 8049;
8050 -> 1;
8051 -> 1;
8052 -> 7893;
8052 -> 8039;
8052 -> 8051;
8052 -> 1;
8053 -> 1;
8054 -> 8052;
8054 -> 8053;
8055 -> 8053;
8056 -> 8055;
8056 -> 1;
8057 -> 8052;
8057 -> 8056;
8057 -> 1;
8058 -> 1;
8059 -> 7893;
8059 -> 8057;
8059 -> 8058;
8059 -> 1;
8060 -> 1;
8061 -> 8059;
8061 -> 8060;
8062 -> 8059;
8062 -> 8060;
8063 -> 8059;
8063 -> 8060;
8064 -> 8059;
8064 -> 8060;
8065 -> 8060;
8066 -> 1;
8067 -> 7893;
8067 -> 8061;
8067 -> 8066;
8067 -> 1;
8068 -> 8067;
8068 -> 8066;
8069 -> 8066;
8070 -> 8067;
8070 -> 8066;
8071 -> 8070;
8071 -> 8066;
8072 -> 8066;
8073 -> 8072;
8074 -> 8072;
8075 -> 1;
8076 -> 7893;
8076 -> 8067;
8076 -> 1;
8077 -> 1;
8078 -> 8076;
8078 -> 8077;
8079 -> 8077;
8080 -> 8079;
8080 -> 1;
8081 -> 8076;
8081 -> 8080;
8081 -> 1;
}