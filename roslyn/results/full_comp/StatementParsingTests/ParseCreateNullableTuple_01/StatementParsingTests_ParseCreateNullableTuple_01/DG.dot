digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 2"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 3"];
3 [label="RuntimeHelpers.RunModuleConstructor(typeof(TestBase).Module.ModuleHandle); 4"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 5"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 6"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 7"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 8"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 9"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 10"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 11"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 12"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 13"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 14"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 15"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 16"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 17"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 18"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 19"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 20"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 21"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 22"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 23"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 24"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 25"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 26"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 27"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 28"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 29"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 30"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 31"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 32"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 33"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 34"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 35"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 36"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 37"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 38"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 39"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 40"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 41"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 42"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 43"];
43 [label="LazyThreadSafetyMode.PublicationOnly 44"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 45"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 46"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 47"];
47 [label="LazyThreadSafetyMode.PublicationOnly 48"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 49"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 50"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 51"];
51 [label="'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' 52"];
52 [label="new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51') 53"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 54"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 55"];
55 [label="LazyThreadSafetyMode.PublicationOnly 56"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 57"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 58"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 59"];
59 [label="LazyThreadSafetyMode.PublicationOnly 60"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 61"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 62"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 63"];
63 [label="LazyThreadSafetyMode.PublicationOnly 64"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 65"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 66"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 67"];
67 [label="LazyThreadSafetyMode.PublicationOnly 68"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 69"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 70"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 71"];
71 [label="LazyThreadSafetyMode.PublicationOnly 72"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 73"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 74"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 75"];
75 [label="LazyThreadSafetyMode.PublicationOnly 76"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 77"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 78"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 79"];
79 [label="LazyThreadSafetyMode.PublicationOnly 80"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 81"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 82"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 83"];
83 [label="LazyThreadSafetyMode.PublicationOnly 84"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 85"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 86"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 87"];
87 [label="LazyThreadSafetyMode.PublicationOnly 88"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 89"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 90"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 91"];
91 [label="LazyThreadSafetyMode.PublicationOnly 92"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 93"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 94"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 95"];
95 [label="LazyThreadSafetyMode.PublicationOnly 96"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 97"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 98"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 99"];
99 [label="LazyThreadSafetyMode.PublicationOnly 100"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 101"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 102"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 103"];
103 [label="LazyThreadSafetyMode.PublicationOnly 104"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 105"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 106"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 107"];
107 [label="LazyThreadSafetyMode.PublicationOnly 108"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 109"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 110"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 111"];
111 [label="LazyThreadSafetyMode.PublicationOnly 112"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 113"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 114"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 115"];
115 [label="LazyThreadSafetyMode.PublicationOnly 116"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 117"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 118"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 119"];
119 [label="LazyThreadSafetyMode.PublicationOnly 120"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 121"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 122"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 123"];
123 [label="LazyThreadSafetyMode.PublicationOnly 124"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 125"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 126"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 127"];
127 [label="LazyThreadSafetyMode.PublicationOnly 128"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 129"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 130"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 131"];
131 [label="LazyThreadSafetyMode.PublicationOnly 132"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 133"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 134"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 135"];
135 [label="LazyThreadSafetyMode.PublicationOnly 136"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 137"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 138"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 139"];
139 [label="LazyThreadSafetyMode.PublicationOnly 140"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 141"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 142"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 143"];
143 [label="LazyThreadSafetyMode.PublicationOnly 144"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 145"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 146"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 147"];
147 [label="LazyThreadSafetyMode.PublicationOnly 148"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 149"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 150"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 151"];
151 [label="LazyThreadSafetyMode.PublicationOnly 152"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 153"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 154"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 155"];
155 [label="LazyThreadSafetyMode.PublicationOnly 156"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 157"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 158"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 159"];
159 [label="LazyThreadSafetyMode.PublicationOnly 160"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 161"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 162"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 163"];
163 [label="LazyThreadSafetyMode.PublicationOnly 164"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 165"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 166"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 167"];
167 [label="LazyThreadSafetyMode.PublicationOnly 168"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 169"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 170"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 171"];
171 [label="LazyThreadSafetyMode.PublicationOnly 172"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 173"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 174"];
174 [label="@'R:\\Invalid.dll' 175"];
175 [label="fullPath: @'R:\\Invalid.dll' 176"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 177"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 178"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 179"];
179 [label="MscorlibRef_v4_0_30316_17626 180"];
180 [label="Net451.mscorlib 181"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 182"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 183"];
183 [label="'/*<bind>*/' 184"];
184 [label="StartString = '/*<bind>*/' 185"];
185 [label="'/*</bind>*/' 186"];
186 [label="EndString = '/*</bind>*/' 187"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 188"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 189"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 190"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 191"];
191 [label="param StatementParsingTests(ITestOutputHelper output) 192"];
192 [label="param StatementParsingTests(this) 193"];
193 [label="output 194"];
194 [label="param ParsingTests(ITestOutputHelper output) 195"];
195 [label="param ParsingTests(this) 196"];
196 [label="param CSharpTestBase(this) 197"];
197 [label="param CommonTestBase(this) 198"];
198 [label="param TestBase(this) 199"];
199 [label="_temp 200"];
200 [label="_node 201"];
201 [label="_treeEnumerator 202"];
202 [label="_output 203"];
203 [label="this._output 204"];
204 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 205"];
205 [label="param ParseCreateNullableTuple_01(this) 206"];
206 [label="UsingStatement('_ = new (int, int)? {};'); 207"];
207 [label="UsingStatement('_ = new (int, int)? {};') 208"];
208 [label="param UsingStatement(string text) 209"];
209 [label="param UsingStatement(params DiagnosticDescription[] expectedErrors) 210"];
210 [label="param UsingStatement(this) 211"];
211 [label="UsingStatement(text, options: null, expectedErrors); 212"];
212 [label="UsingStatement(text, options: null, expectedErrors); 213"];
213 [label="UsingStatement(text, options: null, expectedErrors); 214"];
214 [label="UsingStatement(text, options: null, expectedErrors) 215"];
215 [label="param UsingStatement(string text) 216"];
216 [label="param UsingStatement(ParseOptions? options) 217"];
217 [label="param UsingStatement(params DiagnosticDescription[] expectedErrors) 218"];
218 [label="param UsingStatement(this) 219"];
219 [label="'\\r\\n' 220"];
220 [label="CrLf = '\\r\\n' 221"];
221 [label="CrLf 222"];
222 [label="EndOfLine(CrLf) 223"];
223 [label="param EndOfLine(string text) 224"];
224 [label="param EndOfLine(bool elastic = false) 225"];
225 [label="SyntaxTrivia trivia = null; 226"];
226 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 227"];
227 [label="elastic 228"];
228 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 229"];
229 [label="if (trivia != null)\n            {\n                return trivia;\n            } 230"];
230 [label="if (trivia != null)\n            {\n                return trivia;\n            } 231"];
231 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTrivia), r => new SyntaxTrivia(r)); 232"];
232 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 233"];
233 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 234"];
234 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 235"];
235 [label="param Create(SyntaxKind kind) 236"];
236 [label="param Create(string text) 237"];
237 [label="return new SyntaxTrivia(kind, text); 238"];
238 [label="return new SyntaxTrivia(kind, text); 239"];
239 [label="return new SyntaxTrivia(kind, text); 240"];
240 [label="new SyntaxTrivia(kind, text) 241"];
241 [label="param SyntaxTrivia(SyntaxKind kind) 242"];
242 [label="param SyntaxTrivia(string text) 243"];
243 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 244"];
244 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 245"];
245 [label="param SyntaxTrivia(this) 246"];
246 [label="kind 247"];
247 [label="diagnostics 248"];
248 [label="annotations 249"];
249 [label="new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 250"];
250 [label="s_structuresTable\n            = new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 251"];
251 [label="text 252"];
252 [label="param SyntaxTrivia(this) 253"];
253 [label="param CSharpSyntaxNode(SyntaxKind kind) 254"];
254 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 255"];
255 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 256"];
256 [label="param CSharpSyntaxNode(int fullWidth) 257"];
257 [label="param CSharpSyntaxNode(this) 258"];
258 [label="kind 259"];
259 [label="diagnostics 260"];
260 [label="annotations 261"];
261 [label="fullWidth 262"];
262 [label="param CSharpSyntaxNode(this) 263"];
263 [label="param CSharpSyntaxNode(this) 264"];
264 [label="GreenStats.NoteGreen(this); 265"];
265 [label="GreenStats.NoteGreen(this); 266"];
266 [label="Text 267"];
267 [label="this.Text 268"];
268 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 269"];
269 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 270"];
270 [label="if (!elastic)\n            {\n                return trivia;\n            } 271"];
271 [label="return trivia; 272"];
272 [label="CarriageReturnLineFeed = EndOfLine(CrLf) 273"];
273 [label="'\\n' 274"];
274 [label="EndOfLine('\\n') 275"];
275 [label="param EndOfLine(string text) 276"];
276 [label="param EndOfLine(bool elastic = false) 277"];
277 [label="SyntaxTrivia trivia = null; 278"];
278 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 279"];
279 [label="elastic 280"];
280 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 281"];
281 [label="if (trivia != null)\n            {\n                return trivia;\n            } 282"];
282 [label="if (trivia != null)\n            {\n                return trivia;\n            } 283"];
283 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 284"];
284 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 285"];
285 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 286"];
286 [label="param Create(SyntaxKind kind) 287"];
287 [label="param Create(string text) 288"];
288 [label="return new SyntaxTrivia(kind, text); 289"];
289 [label="return new SyntaxTrivia(kind, text); 290"];
290 [label="return new SyntaxTrivia(kind, text); 291"];
291 [label="new SyntaxTrivia(kind, text) 292"];
292 [label="param SyntaxTrivia(SyntaxKind kind) 293"];
293 [label="param SyntaxTrivia(string text) 294"];
294 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 295"];
295 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 296"];
296 [label="param SyntaxTrivia(this) 297"];
297 [label="kind 298"];
298 [label="diagnostics 299"];
299 [label="annotations 300"];
300 [label="text 301"];
301 [label="param SyntaxTrivia(this) 302"];
302 [label="param CSharpSyntaxNode(SyntaxKind kind) 303"];
303 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 304"];
304 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 305"];
305 [label="param CSharpSyntaxNode(int fullWidth) 306"];
306 [label="param CSharpSyntaxNode(this) 307"];
307 [label="kind 308"];
308 [label="diagnostics 309"];
309 [label="annotations 310"];
310 [label="fullWidth 311"];
311 [label="param CSharpSyntaxNode(this) 312"];
312 [label="param CSharpSyntaxNode(this) 313"];
313 [label="GreenStats.NoteGreen(this); 314"];
314 [label="GreenStats.NoteGreen(this); 315"];
315 [label="Text 316"];
316 [label="this.Text 317"];
317 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 318"];
318 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 319"];
319 [label="if (!elastic)\n            {\n                return trivia;\n            } 320"];
320 [label="return trivia; 321"];
321 [label="LineFeed = EndOfLine('\\n') 322"];
322 [label="'\\r' 323"];
323 [label="EndOfLine('\\r') 324"];
324 [label="param EndOfLine(string text) 325"];
325 [label="param EndOfLine(bool elastic = false) 326"];
326 [label="SyntaxTrivia trivia = null; 327"];
327 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 328"];
328 [label="elastic 329"];
329 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 330"];
330 [label="if (trivia != null)\n            {\n                return trivia;\n            } 331"];
331 [label="if (trivia != null)\n            {\n                return trivia;\n            } 332"];
332 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 333"];
333 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 334"];
334 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 335"];
335 [label="param Create(SyntaxKind kind) 336"];
336 [label="param Create(string text) 337"];
337 [label="return new SyntaxTrivia(kind, text); 338"];
338 [label="return new SyntaxTrivia(kind, text); 339"];
339 [label="return new SyntaxTrivia(kind, text); 340"];
340 [label="new SyntaxTrivia(kind, text) 341"];
341 [label="param SyntaxTrivia(SyntaxKind kind) 342"];
342 [label="param SyntaxTrivia(string text) 343"];
343 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 344"];
344 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 345"];
345 [label="param SyntaxTrivia(this) 346"];
346 [label="kind 347"];
347 [label="diagnostics 348"];
348 [label="annotations 349"];
349 [label="text 350"];
350 [label="param SyntaxTrivia(this) 351"];
351 [label="param CSharpSyntaxNode(SyntaxKind kind) 352"];
352 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 353"];
353 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 354"];
354 [label="param CSharpSyntaxNode(int fullWidth) 355"];
355 [label="param CSharpSyntaxNode(this) 356"];
356 [label="kind 357"];
357 [label="diagnostics 358"];
358 [label="annotations 359"];
359 [label="fullWidth 360"];
360 [label="param CSharpSyntaxNode(this) 361"];
361 [label="param CSharpSyntaxNode(this) 362"];
362 [label="GreenStats.NoteGreen(this); 363"];
363 [label="GreenStats.NoteGreen(this); 364"];
364 [label="Text 365"];
365 [label="this.Text 366"];
366 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 367"];
367 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 368"];
368 [label="if (!elastic)\n            {\n                return trivia;\n            } 369"];
369 [label="return trivia; 370"];
370 [label="CarriageReturn = EndOfLine('\\r') 371"];
371 [label="' ' 372"];
372 [label="Whitespace(' ') 373"];
373 [label="param Whitespace(string text) 374"];
374 [label="param Whitespace(bool elastic = false) 375"];
375 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 376"];
376 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 377"];
377 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 378"];
378 [label="param Create(SyntaxKind kind) 379"];
379 [label="param Create(string text) 380"];
380 [label="return new SyntaxTrivia(kind, text); 381"];
381 [label="return new SyntaxTrivia(kind, text); 382"];
382 [label="return new SyntaxTrivia(kind, text); 383"];
383 [label="new SyntaxTrivia(kind, text) 384"];
384 [label="param SyntaxTrivia(SyntaxKind kind) 385"];
385 [label="param SyntaxTrivia(string text) 386"];
386 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 387"];
387 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 388"];
388 [label="param SyntaxTrivia(this) 389"];
389 [label="kind 390"];
390 [label="diagnostics 391"];
391 [label="annotations 392"];
392 [label="text 393"];
393 [label="param SyntaxTrivia(this) 394"];
394 [label="param CSharpSyntaxNode(SyntaxKind kind) 395"];
395 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 396"];
396 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 397"];
397 [label="param CSharpSyntaxNode(int fullWidth) 398"];
398 [label="param CSharpSyntaxNode(this) 399"];
399 [label="kind 400"];
400 [label="diagnostics 401"];
401 [label="annotations 402"];
402 [label="fullWidth 403"];
403 [label="param CSharpSyntaxNode(this) 404"];
404 [label="param CSharpSyntaxNode(this) 405"];
405 [label="GreenStats.NoteGreen(this); 406"];
406 [label="GreenStats.NoteGreen(this); 407"];
407 [label="Text 408"];
408 [label="this.Text 409"];
409 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 410"];
410 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 411"];
411 [label="if (!elastic)\n            {\n                return trivia;\n            } 412"];
412 [label="return trivia; 413"];
413 [label="Space = Whitespace(' ') 414"];
414 [label="'\\t' 415"];
415 [label="Whitespace('\\t') 416"];
416 [label="param Whitespace(string text) 417"];
417 [label="param Whitespace(bool elastic = false) 418"];
418 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 419"];
419 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 420"];
420 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 421"];
421 [label="param Create(SyntaxKind kind) 422"];
422 [label="param Create(string text) 423"];
423 [label="return new SyntaxTrivia(kind, text); 424"];
424 [label="return new SyntaxTrivia(kind, text); 425"];
425 [label="return new SyntaxTrivia(kind, text); 426"];
426 [label="new SyntaxTrivia(kind, text) 427"];
427 [label="param SyntaxTrivia(SyntaxKind kind) 428"];
428 [label="param SyntaxTrivia(string text) 429"];
429 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 430"];
430 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 431"];
431 [label="param SyntaxTrivia(this) 432"];
432 [label="kind 433"];
433 [label="diagnostics 434"];
434 [label="annotations 435"];
435 [label="text 436"];
436 [label="param SyntaxTrivia(this) 437"];
437 [label="param CSharpSyntaxNode(SyntaxKind kind) 438"];
438 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 439"];
439 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 440"];
440 [label="param CSharpSyntaxNode(int fullWidth) 441"];
441 [label="param CSharpSyntaxNode(this) 442"];
442 [label="kind 443"];
443 [label="diagnostics 444"];
444 [label="annotations 445"];
445 [label="fullWidth 446"];
446 [label="param CSharpSyntaxNode(this) 447"];
447 [label="param CSharpSyntaxNode(this) 448"];
448 [label="GreenStats.NoteGreen(this); 449"];
449 [label="GreenStats.NoteGreen(this); 450"];
450 [label="Text 451"];
451 [label="this.Text 452"];
452 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 453"];
453 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 454"];
454 [label="if (!elastic)\n            {\n                return trivia;\n            } 455"];
455 [label="return trivia; 456"];
456 [label="Tab = Whitespace('\\t') 457"];
457 [label="CrLf 458"];
458 [label="true 459"];
459 [label="elastic: true 460"];
460 [label="EndOfLine(CrLf, elastic: true) 461"];
461 [label="param EndOfLine(string text) 462"];
462 [label="param EndOfLine(bool elastic = false) 463"];
463 [label="SyntaxTrivia trivia = null; 464"];
464 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 465"];
465 [label="elastic 466"];
466 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 467"];
467 [label="if (trivia != null)\n            {\n                return trivia;\n            } 468"];
468 [label="if (trivia != null)\n            {\n                return trivia;\n            } 469"];
469 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 470"];
470 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 471"];
471 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 472"];
472 [label="param Create(SyntaxKind kind) 473"];
473 [label="param Create(string text) 474"];
474 [label="return new SyntaxTrivia(kind, text); 475"];
475 [label="return new SyntaxTrivia(kind, text); 476"];
476 [label="return new SyntaxTrivia(kind, text); 477"];
477 [label="new SyntaxTrivia(kind, text) 478"];
478 [label="param SyntaxTrivia(SyntaxKind kind) 479"];
479 [label="param SyntaxTrivia(string text) 480"];
480 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 481"];
481 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 482"];
482 [label="param SyntaxTrivia(this) 483"];
483 [label="kind 484"];
484 [label="diagnostics 485"];
485 [label="annotations 486"];
486 [label="text 487"];
487 [label="param SyntaxTrivia(this) 488"];
488 [label="param CSharpSyntaxNode(SyntaxKind kind) 489"];
489 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 490"];
490 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 491"];
491 [label="param CSharpSyntaxNode(int fullWidth) 492"];
492 [label="param CSharpSyntaxNode(this) 493"];
493 [label="kind 494"];
494 [label="diagnostics 495"];
495 [label="annotations 496"];
496 [label="fullWidth 497"];
497 [label="param CSharpSyntaxNode(this) 498"];
498 [label="param CSharpSyntaxNode(this) 499"];
499 [label="GreenStats.NoteGreen(this); 500"];
500 [label="GreenStats.NoteGreen(this); 501"];
501 [label="Text 502"];
502 [label="this.Text 503"];
503 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 504"];
504 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 505"];
505 [label="if (!elastic)\n            {\n                return trivia;\n            } 506"];
506 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 507"];
507 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 508"];
508 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 509"];
509 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 510"];
510 [label="param SetAnnotations(SyntaxAnnotation[]? annotations) 511"];
511 [label="param SetAnnotations(this) 512"];
512 [label="this.Kind 513"];
513 [label="get { return (SyntaxKind)this.RawKind; } 514"];
514 [label="return (SyntaxKind)this.RawKind; 515"];
515 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 516"];
516 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 517"];
517 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 518"];
518 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 519"];
519 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 520"];
520 [label="param SyntaxTrivia(SyntaxKind kind) 521"];
521 [label="param SyntaxTrivia(string text) 522"];
522 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 523"];
523 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 524"];
524 [label="param SyntaxTrivia(this) 525"];
525 [label="param SyntaxTrivia(this) 526"];
526 [label="param CSharpSyntaxNode(this) 527"];
527 [label="param CSharpSyntaxNode(this) 528"];
528 [label="param CSharpSyntaxNode(this) 529"];
529 [label="GreenStats.NoteGreen(this); 530"];
530 [label="Text 531"];
531 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 532"];
532 [label="ElasticCarriageReturnLineFeed = EndOfLine(CrLf, elastic: true) 533"];
533 [label="'\\n' 534"];
534 [label="true 535"];
535 [label="elastic: true 536"];
536 [label="EndOfLine('\\n', elastic: true) 537"];
537 [label="param EndOfLine(string text) 538"];
538 [label="param EndOfLine(bool elastic = false) 539"];
539 [label="SyntaxTrivia trivia = null; 540"];
540 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 541"];
541 [label="elastic 542"];
542 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 543"];
543 [label="if (trivia != null)\n            {\n                return trivia;\n            } 544"];
544 [label="if (trivia != null)\n            {\n                return trivia;\n            } 545"];
545 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 546"];
546 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 547"];
547 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 548"];
548 [label="param Create(SyntaxKind kind) 549"];
549 [label="param Create(string text) 550"];
550 [label="return new SyntaxTrivia(kind, text); 551"];
551 [label="return new SyntaxTrivia(kind, text); 552"];
552 [label="return new SyntaxTrivia(kind, text); 553"];
553 [label="new SyntaxTrivia(kind, text) 554"];
554 [label="param SyntaxTrivia(SyntaxKind kind) 555"];
555 [label="param SyntaxTrivia(string text) 556"];
556 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 557"];
557 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 558"];
558 [label="param SyntaxTrivia(this) 559"];
559 [label="kind 560"];
560 [label="diagnostics 561"];
561 [label="annotations 562"];
562 [label="text 563"];
563 [label="param SyntaxTrivia(this) 564"];
564 [label="param CSharpSyntaxNode(SyntaxKind kind) 565"];
565 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 566"];
566 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 567"];
567 [label="param CSharpSyntaxNode(int fullWidth) 568"];
568 [label="param CSharpSyntaxNode(this) 569"];
569 [label="kind 570"];
570 [label="diagnostics 571"];
571 [label="annotations 572"];
572 [label="fullWidth 573"];
573 [label="param CSharpSyntaxNode(this) 574"];
574 [label="param CSharpSyntaxNode(this) 575"];
575 [label="GreenStats.NoteGreen(this); 576"];
576 [label="GreenStats.NoteGreen(this); 577"];
577 [label="Text 578"];
578 [label="this.Text 579"];
579 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 580"];
580 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 581"];
581 [label="if (!elastic)\n            {\n                return trivia;\n            } 582"];
582 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 583"];
583 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 584"];
584 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 585"];
585 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 586"];
586 [label="this.Kind 587"];
587 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 588"];
588 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 589"];
589 [label="param SyntaxTrivia(this) 590"];
590 [label="param SyntaxTrivia(this) 591"];
591 [label="param CSharpSyntaxNode(this) 592"];
592 [label="param CSharpSyntaxNode(this) 593"];
593 [label="GreenStats.NoteGreen(this); 594"];
594 [label="Text 595"];
595 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 596"];
596 [label="ElasticLineFeed = EndOfLine('\\n', elastic: true) 597"];
597 [label="'\\r' 598"];
598 [label="true 599"];
599 [label="elastic: true 600"];
600 [label="EndOfLine('\\r', elastic: true) 601"];
601 [label="param EndOfLine(string text) 602"];
602 [label="param EndOfLine(bool elastic = false) 603"];
603 [label="SyntaxTrivia trivia = null; 604"];
604 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 605"];
605 [label="elastic 606"];
606 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 607"];
607 [label="if (trivia != null)\n            {\n                return trivia;\n            } 608"];
608 [label="if (trivia != null)\n            {\n                return trivia;\n            } 609"];
609 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 610"];
610 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 611"];
611 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 612"];
612 [label="param Create(SyntaxKind kind) 613"];
613 [label="param Create(string text) 614"];
614 [label="return new SyntaxTrivia(kind, text); 615"];
615 [label="return new SyntaxTrivia(kind, text); 616"];
616 [label="return new SyntaxTrivia(kind, text); 617"];
617 [label="new SyntaxTrivia(kind, text) 618"];
618 [label="param SyntaxTrivia(SyntaxKind kind) 619"];
619 [label="param SyntaxTrivia(string text) 620"];
620 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 621"];
621 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 622"];
622 [label="param SyntaxTrivia(this) 623"];
623 [label="kind 624"];
624 [label="diagnostics 625"];
625 [label="annotations 626"];
626 [label="text 627"];
627 [label="param SyntaxTrivia(this) 628"];
628 [label="param CSharpSyntaxNode(SyntaxKind kind) 629"];
629 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 630"];
630 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 631"];
631 [label="param CSharpSyntaxNode(int fullWidth) 632"];
632 [label="param CSharpSyntaxNode(this) 633"];
633 [label="kind 634"];
634 [label="diagnostics 635"];
635 [label="annotations 636"];
636 [label="fullWidth 637"];
637 [label="param CSharpSyntaxNode(this) 638"];
638 [label="param CSharpSyntaxNode(this) 639"];
639 [label="GreenStats.NoteGreen(this); 640"];
640 [label="GreenStats.NoteGreen(this); 641"];
641 [label="Text 642"];
642 [label="this.Text 643"];
643 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 644"];
644 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 645"];
645 [label="if (!elastic)\n            {\n                return trivia;\n            } 646"];
646 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 647"];
647 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 648"];
648 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 649"];
649 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 650"];
650 [label="this.Kind 651"];
651 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 652"];
652 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 653"];
653 [label="param SyntaxTrivia(this) 654"];
654 [label="param SyntaxTrivia(this) 655"];
655 [label="param CSharpSyntaxNode(this) 656"];
656 [label="param CSharpSyntaxNode(this) 657"];
657 [label="GreenStats.NoteGreen(this); 658"];
658 [label="Text 659"];
659 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 660"];
660 [label="ElasticCarriageReturn = EndOfLine('\\r', elastic: true) 661"];
661 [label="' ' 662"];
662 [label="true 663"];
663 [label="elastic: true 664"];
664 [label="Whitespace(' ', elastic: true) 665"];
665 [label="param Whitespace(string text) 666"];
666 [label="param Whitespace(bool elastic = false) 667"];
667 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 668"];
668 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 669"];
669 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 670"];
670 [label="param Create(SyntaxKind kind) 671"];
671 [label="param Create(string text) 672"];
672 [label="return new SyntaxTrivia(kind, text); 673"];
673 [label="return new SyntaxTrivia(kind, text); 674"];
674 [label="return new SyntaxTrivia(kind, text); 675"];
675 [label="new SyntaxTrivia(kind, text) 676"];
676 [label="param SyntaxTrivia(SyntaxKind kind) 677"];
677 [label="param SyntaxTrivia(string text) 678"];
678 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 679"];
679 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 680"];
680 [label="param SyntaxTrivia(this) 681"];
681 [label="kind 682"];
682 [label="diagnostics 683"];
683 [label="annotations 684"];
684 [label="text 685"];
685 [label="param SyntaxTrivia(this) 686"];
686 [label="param CSharpSyntaxNode(SyntaxKind kind) 687"];
687 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 688"];
688 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 689"];
689 [label="param CSharpSyntaxNode(int fullWidth) 690"];
690 [label="param CSharpSyntaxNode(this) 691"];
691 [label="kind 692"];
692 [label="diagnostics 693"];
693 [label="annotations 694"];
694 [label="fullWidth 695"];
695 [label="param CSharpSyntaxNode(this) 696"];
696 [label="param CSharpSyntaxNode(this) 697"];
697 [label="GreenStats.NoteGreen(this); 698"];
698 [label="GreenStats.NoteGreen(this); 699"];
699 [label="Text 700"];
700 [label="this.Text 701"];
701 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 702"];
702 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 703"];
703 [label="if (!elastic)\n            {\n                return trivia;\n            } 704"];
704 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 705"];
705 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 706"];
706 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 707"];
707 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 708"];
708 [label="this.Kind 709"];
709 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 710"];
710 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 711"];
711 [label="param SyntaxTrivia(this) 712"];
712 [label="param SyntaxTrivia(this) 713"];
713 [label="param CSharpSyntaxNode(this) 714"];
714 [label="param CSharpSyntaxNode(this) 715"];
715 [label="GreenStats.NoteGreen(this); 716"];
716 [label="Text 717"];
717 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 718"];
718 [label="ElasticSpace = Whitespace(' ', elastic: true) 719"];
719 [label="'\\t' 720"];
720 [label="true 721"];
721 [label="elastic: true 722"];
722 [label="Whitespace('\\t', elastic: true) 723"];
723 [label="param Whitespace(string text) 724"];
724 [label="param Whitespace(bool elastic = false) 725"];
725 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 726"];
726 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 727"];
727 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 728"];
728 [label="param Create(SyntaxKind kind) 729"];
729 [label="param Create(string text) 730"];
730 [label="return new SyntaxTrivia(kind, text); 731"];
731 [label="return new SyntaxTrivia(kind, text); 732"];
732 [label="return new SyntaxTrivia(kind, text); 733"];
733 [label="new SyntaxTrivia(kind, text) 734"];
734 [label="param SyntaxTrivia(SyntaxKind kind) 735"];
735 [label="param SyntaxTrivia(string text) 736"];
736 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 737"];
737 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 738"];
738 [label="param SyntaxTrivia(this) 739"];
739 [label="kind 740"];
740 [label="diagnostics 741"];
741 [label="annotations 742"];
742 [label="text 743"];
743 [label="param SyntaxTrivia(this) 744"];
744 [label="param CSharpSyntaxNode(SyntaxKind kind) 745"];
745 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 746"];
746 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 747"];
747 [label="param CSharpSyntaxNode(int fullWidth) 748"];
748 [label="param CSharpSyntaxNode(this) 749"];
749 [label="kind 750"];
750 [label="diagnostics 751"];
751 [label="annotations 752"];
752 [label="fullWidth 753"];
753 [label="param CSharpSyntaxNode(this) 754"];
754 [label="param CSharpSyntaxNode(this) 755"];
755 [label="GreenStats.NoteGreen(this); 756"];
756 [label="GreenStats.NoteGreen(this); 757"];
757 [label="Text 758"];
758 [label="this.Text 759"];
759 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 760"];
760 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 761"];
761 [label="if (!elastic)\n            {\n                return trivia;\n            } 762"];
762 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 763"];
763 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 764"];
764 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 765"];
765 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 766"];
766 [label="this.Kind 767"];
767 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 768"];
768 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 769"];
769 [label="param SyntaxTrivia(this) 770"];
770 [label="param SyntaxTrivia(this) 771"];
771 [label="param CSharpSyntaxNode(this) 772"];
772 [label="param CSharpSyntaxNode(this) 773"];
773 [label="GreenStats.NoteGreen(this); 774"];
774 [label="Text 775"];
775 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 776"];
776 [label="ElasticTab = Whitespace('\\t', elastic: true) 777"];
777 [label="string.Empty 778"];
778 [label="true 779"];
779 [label="elastic: true 780"];
780 [label="Whitespace(string.Empty, elastic: true) 781"];
781 [label="param Whitespace(string text) 782"];
782 [label="param Whitespace(bool elastic = false) 783"];
783 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 784"];
784 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 785"];
785 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 786"];
786 [label="param Create(SyntaxKind kind) 787"];
787 [label="param Create(string text) 788"];
788 [label="return new SyntaxTrivia(kind, text); 789"];
789 [label="return new SyntaxTrivia(kind, text); 790"];
790 [label="return new SyntaxTrivia(kind, text); 791"];
791 [label="new SyntaxTrivia(kind, text) 792"];
792 [label="param SyntaxTrivia(SyntaxKind kind) 793"];
793 [label="param SyntaxTrivia(string text) 794"];
794 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 795"];
795 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 796"];
796 [label="param SyntaxTrivia(this) 797"];
797 [label="kind 798"];
798 [label="diagnostics 799"];
799 [label="annotations 800"];
800 [label="text 801"];
801 [label="param SyntaxTrivia(this) 802"];
802 [label="param CSharpSyntaxNode(SyntaxKind kind) 803"];
803 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 804"];
804 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 805"];
805 [label="param CSharpSyntaxNode(int fullWidth) 806"];
806 [label="param CSharpSyntaxNode(this) 807"];
807 [label="kind 808"];
808 [label="diagnostics 809"];
809 [label="annotations 810"];
810 [label="fullWidth 811"];
811 [label="param CSharpSyntaxNode(this) 812"];
812 [label="param CSharpSyntaxNode(this) 813"];
813 [label="GreenStats.NoteGreen(this); 814"];
814 [label="GreenStats.NoteGreen(this); 815"];
815 [label="Text 816"];
816 [label="this.Text 817"];
817 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 818"];
818 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 819"];
819 [label="if (!elastic)\n            {\n                return trivia;\n            } 820"];
820 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 821"];
821 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 822"];
822 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 823"];
823 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 824"];
824 [label="this.Kind 825"];
825 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 826"];
826 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 827"];
827 [label="param SyntaxTrivia(this) 828"];
828 [label="param SyntaxTrivia(this) 829"];
829 [label="param CSharpSyntaxNode(this) 830"];
830 [label="param CSharpSyntaxNode(this) 831"];
831 [label="GreenStats.NoteGreen(this); 832"];
832 [label="Text 833"];
833 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 834"];
834 [label="ElasticZeroSpace = Whitespace(string.Empty, elastic: true) 835"];
835 [label="s_xmlCarriageReturnLineFeed 836"];
836 [label="public static SyntaxTrivia CarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed; 837"];
837 [label="param operator(SyntaxTrivia trivia) 838"];
838 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 839"];
839 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 840"];
840 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 841"];
841 [label="public static SyntaxTrivia LineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.LineFeed; 842"];
842 [label="param operator(SyntaxTrivia trivia) 843"];
843 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 844"];
844 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 845"];
845 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 846"];
846 [label="public static SyntaxTrivia CarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn; 847"];
847 [label="param operator(SyntaxTrivia trivia) 848"];
848 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 849"];
849 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 850"];
850 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 851"];
851 [label="public static SyntaxTrivia Space { get; } = Syntax.InternalSyntax.SyntaxFactory.Space; 852"];
852 [label="param operator(SyntaxTrivia trivia) 853"];
853 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 854"];
854 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 855"];
855 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 856"];
856 [label="public static SyntaxTrivia Tab { get; } = Syntax.InternalSyntax.SyntaxFactory.Tab; 857"];
857 [label="param operator(SyntaxTrivia trivia) 858"];
858 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 859"];
859 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 860"];
860 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 861"];
861 [label="public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed; 862"];
862 [label="param operator(SyntaxTrivia trivia) 863"];
863 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 864"];
864 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 865"];
865 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 866"];
866 [label="public static SyntaxTrivia ElasticLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed; 867"];
867 [label="param operator(SyntaxTrivia trivia) 868"];
868 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 869"];
869 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 870"];
870 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 871"];
871 [label="public static SyntaxTrivia ElasticCarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn; 872"];
872 [label="param operator(SyntaxTrivia trivia) 873"];
873 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 874"];
874 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 875"];
875 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 876"];
876 [label="public static SyntaxTrivia ElasticSpace { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace; 877"];
877 [label="param operator(SyntaxTrivia trivia) 878"];
878 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 879"];
879 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 880"];
880 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 881"];
881 [label="public static SyntaxTrivia ElasticTab { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticTab; 882"];
882 [label="param operator(SyntaxTrivia trivia) 883"];
883 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 884"];
884 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 885"];
885 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 886"];
886 [label="public static SyntaxTrivia ElasticMarker { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace; 887"];
887 [label="param operator(SyntaxTrivia trivia) 888"];
888 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 889"];
889 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 890"];
890 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 891"];
891 [label="var node = SyntaxFactory.ParseStatement(text, options: options); 892"];
892 [label="var node = SyntaxFactory.ParseStatement(text, options: options); 893"];
893 [label="var node = SyntaxFactory.ParseStatement(text, options: options); 894"];
894 [label="SyntaxFactory.ParseStatement(text, options: options) 895"];
895 [label="param ParseStatement(string text) 896"];
896 [label="param ParseStatement(int offset = 0) 897"];
897 [label="param ParseStatement(ParseOptions? options = null) 898"];
898 [label="param ParseStatement(bool consumeFullText = true) 899"];
899 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 900"];
900 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 901"];
901 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 902"];
902 [label="MakeLexer(text, offset, (CSharpParseOptions?)options) 903"];
903 [label="param MakeLexer(string text) 904"];
904 [label="param MakeLexer(int offset) 905"];
905 [label="param MakeLexer(CSharpParseOptions? options = null) 906"];
906 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 907"];
907 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 908"];
908 [label="MakeSourceText(text, offset) 909"];
909 [label="param MakeSourceText(string text) 910"];
910 [label="param MakeSourceText(int offset) 911"];
911 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 912"];
912 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 913"];
913 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 914"];
914 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 915"];
915 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 916"];
916 [label="new CSharpParseOptions() 917"];
917 [label="param CSharpParseOptions(LanguageVersion languageVersion = LanguageVersion.Default) 918"];
918 [label="param CSharpParseOptions(DocumentationMode documentationMode = DocumentationMode.Parse) 919"];
919 [label="param CSharpParseOptions(SourceCodeKind kind = SourceCodeKind.Regular) 920"];
920 [label="param CSharpParseOptions(IEnumerable<string>? preprocessorSymbols = null) 921"];
921 [label="param CSharpParseOptions(this) 922"];
922 [label="languageVersion 923"];
923 [label="documentationMode 924"];
924 [label="kind 925"];
925 [label="preprocessorSymbols 926"];
926 [label="preprocessorSymbols.ToImmutableArrayOrEmpty() 927"];
927 [label="ImmutableDictionary<string, string>.Empty 928"];
928 [label="param CSharpParseOptions(LanguageVersion languageVersion) 929"];
929 [label="param CSharpParseOptions(DocumentationMode documentationMode) 930"];
930 [label="param CSharpParseOptions(SourceCodeKind kind) 931"];
931 [label="param CSharpParseOptions(ImmutableArray<string> preprocessorSymbols) 932"];
932 [label="param CSharpParseOptions(IReadOnlyDictionary<string, string>? features) 933"];
933 [label="param CSharpParseOptions(this) 934"];
934 [label="kind 935"];
935 [label="documentationMode 936"];
936 [label="param CSharpParseOptions(this) 937"];
937 [label="_features 938"];
938 [label="public LanguageVersion LanguageVersion { get; private set; } 939"];
939 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 940"];
940 [label="this.SpecifiedLanguageVersion 941"];
941 [label="this.LanguageVersion = languageVersion.MapSpecifiedToEffectiveVersion(); 942"];
942 [label="languageVersion.MapSpecifiedToEffectiveVersion() 943"];
943 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 944"];
944 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 945"];
945 [label="return LanguageVersion.CSharp9; 946"];
946 [label="this.LanguageVersion 947"];
947 [label="this.PreprocessorSymbols = preprocessorSymbols.ToImmutableArrayOrEmpty(); 948"];
948 [label="this.PreprocessorSymbols 949"];
949 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 950"];
950 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 951"];
951 [label="_features 952"];
952 [label="public static CSharpParseOptions Default { get; } = new CSharpParseOptions(); 953"];
953 [label="8 954"];
954 [label="TriviaListInitialCapacity = 8 955"];
955 [label="TokensLexed 956"];
956 [label="'<<<<<<<' 957"];
957 [label="s_conflictMarkerLength = '<<<<<<<'.Length 958"];
958 [label="42 959"];
959 [label="MaxCachedTokenSize = 42 960"];
960 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 961"];
961 [label="{\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            } 962"];
962 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 963"];
963 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 964"];
964 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 965"];
965 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 966"];
966 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 967"];
967 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 968"];
968 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 969"];
969 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 970"];
970 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 971"];
971 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 972"];
972 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 973"];
973 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 974"];
974 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 975"];
975 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 976"];
976 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 977"];
977 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 978"];
978 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 979"];
979 [label="s_stateTransitions = new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 980"];
980 [label="new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 981"];
981 [label="s_charProperties = new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 982"];
982 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 983"];
983 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 984"];
984 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 985"];
985 [label="new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default) 986"];
986 [label="param Lexer(SourceText text) 987"];
987 [label="param Lexer(CSharpParseOptions options) 988"];
988 [label="param Lexer(bool allowPreprocessorDirectives = true) 989"];
989 [label="param Lexer(bool interpolationFollowedByColon = false) 990"];
990 [label="param Lexer(this) 991"];
991 [label="text 992"];
992 [label="param Lexer(this) 993"];
993 [label="param AbstractLexer(SourceText text) 994"];
994 [label="param AbstractLexer(this) 995"];
995 [label="TextWindow 996"];
996 [label="_errors 997"];
997 [label="InvalidCharacter = char.MaxValue 998"];
998 [label="2048 999"];
999 [label="DefaultWindowLength = 2048 1000"];
1000 [label="() => new char[DefaultWindowLength] 1001"];
1001 [label="new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 1002"];
1002 [label="s_windowPool = new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 1003"];
1003 [label="this.TextWindow = new SlidingTextWindow(text); 1004"];
1004 [label="this.TextWindow = new SlidingTextWindow(text); 1005"];
1005 [label="new SlidingTextWindow(text) 1006"];
1006 [label="param SlidingTextWindow(SourceText text) 1007"];
1007 [label="param SlidingTextWindow(this) 1008"];
1008 [label="_text 1009"];
1009 [label="_basis 1010"];
1010 [label="_offset 1011"];
1011 [label="_textEnd 1012"];
1012 [label="_characterWindow 1013"];
1013 [label="_characterWindowCount 1014"];
1014 [label="_lexemeStart 1015"];
1015 [label="_strings 1016"];
1016 [label="_text 1017"];
1017 [label="_basis = 0; 1018"];
1018 [label="_basis 1019"];
1019 [label="_offset = 0; 1020"];
1020 [label="_offset 1021"];
1021 [label="_textEnd 1022"];
1022 [label="_strings = StringTable.GetInstance(); 1023"];
1023 [label="_strings 1024"];
1024 [label="_characterWindow = s_windowPool.Allocate(); 1025"];
1025 [label="_characterWindow 1026"];
1026 [label="_lexemeStart = 0; 1027"];
1027 [label="_lexemeStart 1028"];
1028 [label="this.TextWindow 1029"];
1029 [label="_options 1030"];
1030 [label="_mode 1031"];
1031 [label="_builder 1032"];
1032 [label="_identBuffer 1033"];
1033 [label="_identLen 1034"];
1034 [label="_cache 1035"];
1035 [label="_allowPreprocessorDirectives 1036"];
1036 [label="_interpolationFollowedByColon 1037"];
1037 [label="_xmlParser 1038"];
1038 [label="_badTokenCount 1039"];
1039 [label="10 1040"];
1040 [label="new SyntaxListBuilder(10) 1041"];
1041 [label="_leadingTriviaCache = new SyntaxListBuilder(10) 1042"];
1042 [label="10 1043"];
1043 [label="new SyntaxListBuilder(10) 1044"];
1044 [label="_trailingTriviaCache = new SyntaxListBuilder(10) 1045"];
1045 [label="_createWhitespaceTriviaFunction 1046"];
1046 [label="_createQuickTokenFunction 1047"];
1047 [label="Debug.Assert(options != null); 1048"];
1048 [label="Debug.Assert(options != null); 1049"];
1049 [label="_options 1050"];
1050 [label="_builder = new StringBuilder(); 1051"];
1051 [label="_builder 1052"];
1052 [label="_identBuffer = new char[32]; 1053"];
1053 [label="_identBuffer 1054"];
1054 [label="512 1055"];
1055 [label="(key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            } 1056"];
1056 [label="CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 1057"];
1057 [label="s_keywordKindPool =\n            CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 1058"];
1058 [label="10 1059"];
1059 [label="MaxKeywordLength = 10 1060"];
1060 [label="_cache = new LexerCache(); 1061"];
1061 [label="new LexerCache() 1062"];
1062 [label="param LexerCache(this) 1063"];
1063 [label="_triviaMap 1064"];
1064 [label="_tokenMap 1065"];
1065 [label="_keywordKindMap 1066"];
1066 [label="_triviaMap = TextKeyedCache<SyntaxTrivia>.GetInstance(); 1067"];
1067 [label="_triviaMap 1068"];
1068 [label="_tokenMap = TextKeyedCache<SyntaxToken>.GetInstance(); 1069"];
1069 [label="_tokenMap 1070"];
1070 [label="_keywordKindMap = s_keywordKindPool.Allocate(); 1071"];
1071 [label="_keywordKindMap 1072"];
1072 [label="_cache 1073"];
1073 [label="_createQuickTokenFunction 1074"];
1074 [label="_allowPreprocessorDirectives 1075"];
1075 [label="_interpolationFollowedByColon 1076"];
1076 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 1077"];
1077 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 1078"];
1078 [label="MakeParser(lexer) 1079"];
1079 [label="param MakeParser(InternalSyntax.Lexer lexer) 1080"];
1080 [label="LastTerminatorState = (int)TerminatorState.IsEndOfRecordSignature 1081"];
1081 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 1082"];
1082 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 1083"];
1083 [label="new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null) 1084"];
1084 [label="param LanguageParser(Lexer lexer) 1085"];
1085 [label="param LanguageParser(CSharp.CSharpSyntaxNode oldTree) 1086"];
1086 [label="param LanguageParser(IEnumerable<TextChangeRange> changes) 1087"];
1087 [label="param LanguageParser(LexerMode lexerMode = LexerMode.Syntax) 1088"];
1088 [label="param LanguageParser(CancellationToken cancellationToken = default(CancellationToken)) 1089"];
1089 [label="param LanguageParser(this) 1090"];
1090 [label="() => new BlendedNode[32] 1091"];
1091 [label="2 1092"];
1092 [label="new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 1093"];
1093 [label="s_blendedNodesPool = new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 1094"];
1094 [label="lexer 1095"];
1095 [label="lexerMode 1096"];
1096 [label="oldTree 1097"];
1097 [label="changes 1098"];
1098 [label="false 1099"];
1099 [label="true 1100"];
1100 [label="cancellationToken 1101"];
1101 [label="param LanguageParser(this) 1102"];
1102 [label="param SyntaxParser(Lexer lexer) 1103"];
1103 [label="param SyntaxParser(LexerMode mode) 1104"];
1104 [label="param SyntaxParser(CSharp.CSharpSyntaxNode oldTree) 1105"];
1105 [label="param SyntaxParser(IEnumerable<TextChangeRange> changes) 1106"];
1106 [label="param SyntaxParser(bool allowModeReset) 1107"];
1107 [label="param SyntaxParser(bool preLexIfNotIncremental = false) 1108"];
1108 [label="param SyntaxParser(CancellationToken cancellationToken = default(CancellationToken)) 1109"];
1109 [label="param SyntaxParser(this) 1110"];
1110 [label="lexer 1111"];
1111 [label="_isIncremental 1112"];
1112 [label="_allowModeReset 1113"];
1113 [label="_mode 1114"];
1114 [label="_currentToken 1115"];
1115 [label="_lexedTokens 1116"];
1116 [label="_prevTokenTrailingTrivia 1117"];
1117 [label="_firstToken 1118"];
1118 [label="_tokenOffset 1119"];
1119 [label="_tokenCount 1120"];
1120 [label="_resetCount 1121"];
1121 [label="_resetStart 1122"];
1122 [label="_blendedTokens 1123"];
1123 [label="this.lexer 1124"];
1124 [label="_mode 1125"];
1125 [label="_allowModeReset 1126"];
1126 [label="this.cancellationToken 1127"];
1127 [label="_currentNode = default(BlendedNode); 1128"];
1128 [label="_currentNode 1129"];
1129 [label="_isIncremental = oldTree != null; 1130"];
1130 [label="_isIncremental = oldTree != null; 1131"];
1131 [label="_isIncremental 1132"];
1132 [label="this.IsIncremental 1133"];
1133 [label="get\n            {\n                return _isIncremental;\n            } 1134"];
1134 [label="return _isIncremental; 1135"];
1135 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 1136"];
1136 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 1137"];
1137 [label="_firstBlender = default(Blender); 1138"];
1138 [label="_firstBlender 1139"];
1139 [label="_lexedTokens = new ArrayElement<SyntaxToken>[32]; 1140"];
1140 [label="_lexedTokens 1141"];
1141 [label="this.IsIncremental 1142"];
1142 [label="get\n            {\n                return _isIncremental;\n            } 1143"];
1143 [label="return _isIncremental; 1144"];
1144 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 1145"];
1145 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 1146"];
1146 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 1147"];
1147 [label="this.PreLex() 1148"];
1148 [label="param PreLex(this) 1149"];
1149 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 1150"];
1150 [label="this.lexer.TextWindow.Text 1151"];
1151 [label="=> _text 1152"];
1152 [label="_text 1153"];
1153 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 1154"];
1154 [label="_lexedTokens = new ArrayElement<SyntaxToken>[size]; 1155"];
1155 [label="_lexedTokens 1156"];
1156 [label="var lexer = this.lexer; 1157"];
1157 [label="var mode = _mode; 1158"];
1158 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 1159"];
1159 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 1160"];
1160 [label="var token = lexer.Lex(mode); 1161"];
1161 [label="lexer.Lex(mode) 1162"];
1162 [label="param Lex(LexerMode mode) 1163"];
1163 [label="param Lex(this) 1164"];
1164 [label="TokensLexed++; 1165"];
1165 [label="_mode 1166"];
1166 [label="switch (_mode)\n            {\n                case LexerMode.Syntax:\n                case LexerMode.DebuggerSyntax:\n                    return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();\n                case LexerMode.Directive:\n                    return this.LexDirectiveToken();\n            } 1167"];
1167 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 1168"];
1168 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 1169"];
1169 [label="param Start(this) 1170"];
1170 [label="TextWindow.Start() 1171"];
1171 [label="param Start(this) 1172"];
1172 [label="_lexemeStart 1173"];
1173 [label="TextWindow.Start(); 1174"];
1174 [label="_errors = null; 1175"];
1175 [label="_errors 1176"];
1176 [label="get\n            {\n                return _offset;\n            } 1177"];
1177 [label="return _offset; 1178"];
1178 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 1179"];
1179 [label="get\n            {\n                return _characterWindowCount;\n            } 1180"];
1180 [label="return _characterWindowCount; 1181"];
1181 [label="get\n            {\n                return _characterWindow;\n            } 1182"];
1182 [label="return _characterWindow; 1183"];
1183 [label="param AdvanceChar(int n) 1184"];
1184 [label="param AdvanceChar(this) 1185"];
1185 [label="_offset += n; 1186"];
1186 [label="_offset 1187"];
1187 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 1188"];
1188 [label="return _basis + _lexemeStart; 1189"];
1189 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 1190"];
1190 [label="param Reset(int position) 1191"];
1191 [label="param Reset(this) 1192"];
1192 [label="int relative = position - _basis; 1193"];
1193 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 1194"];
1194 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 1195"];
1195 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 1196"];
1196 [label="_offset 1197"];
1197 [label="this.LexSyntaxToken() 1198"];
1198 [label="param LexSyntaxToken(this) 1199"];
1199 [label="_leadingTriviaCache.Clear(); 1200"];
1200 [label="TextWindow.Position 1201"];
1201 [label="get\n            {\n                return _basis + _offset;\n            } 1202"];
1202 [label="return _basis + _offset; 1203"];
1203 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 1204"];
1204 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 1205"];
1205 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 1206"];
1206 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache) 1207"];
1207 [label="param LexSyntaxTrivia(bool afterFirstToken) 1208"];
1208 [label="param LexSyntaxTrivia(bool isTrailing) 1209"];
1209 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 1210"];
1210 [label="param LexSyntaxTrivia(this) 1211"];
1211 [label="bool onlyWhitespaceOnLine = !isTrailing; 1212"];
1212 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 1213"];
1213 [label="this.Start() 1214"];
1214 [label="param Start(this) 1215"];
1215 [label="TextWindow.Start() 1216"];
1216 [label="param Start(this) 1217"];
1217 [label="TextWindow.Start(); 1218"];
1218 [label="_errors = null; 1219"];
1219 [label="_errors 1220"];
1220 [label="this.Start(); 1221"];
1221 [label="TextWindow.PeekChar() 1222"];
1222 [label="param PeekChar(this) 1223"];
1223 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 1224"];
1224 [label="MoreChars() 1225"];
1225 [label="param MoreChars(this) 1226"];
1226 [label="if (_offset >= _characterWindowCount)\n            {\n                if (this.Position >= _textEnd)\n                {\n                    return false;\n                }\n\n                // if lexeme scanning is sufficiently into the char buffer, \n                // then refocus the window onto the lexeme\n                if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                }\n\n                if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                }\n\n                int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount);\n                _text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead);\n                _characterWindowCount += amountToRead;\n                return amountToRead > 0;\n            } 1227"];
1227 [label="this.Position 1228"];
1228 [label="get\n            {\n                return _basis + _offset;\n            } 1229"];
1229 [label="return _basis + _offset; 1230"];
1230 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 1231"];
1231 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 1232"];
1232 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 1233"];
1233 [label="if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                } 1234"];
1234 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 1235"];
1235 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 1236"];
1236 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 1237"];
1237 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 1238"];
1238 [label="_characterWindowCount += amountToRead; 1239"];
1239 [label="_characterWindowCount 1240"];
1240 [label="return amountToRead > 0; 1241"];
1241 [label="return amountToRead > 0; 1242"];
1242 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 1243"];
1243 [label="return _characterWindow[_offset]; 1244"];
1244 [label="char ch = TextWindow.PeekChar(); 1245"];
1245 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 1246"];
1246 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 1247"];
1247 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 1248"];
1248 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 1249"];
1249 [label="return; 1250"];
1250 [label="var leading = _leadingTriviaCache; 1251"];
1251 [label="var tokenInfo = default(TokenInfo); 1252"];
1252 [label="this.Start() 1253"];
1253 [label="param Start(this) 1254"];
1254 [label="TextWindow.Start() 1255"];
1255 [label="param Start(this) 1256"];
1256 [label="TextWindow.Start(); 1257"];
1257 [label="_errors = null; 1258"];
1258 [label="_errors 1259"];
1259 [label="this.Start(); 1260"];
1260 [label="this.ScanSyntaxToken(ref tokenInfo); 1261"];
1261 [label="this.ScanSyntaxToken(ref tokenInfo); 1262"];
1262 [label="this.ScanSyntaxToken(ref tokenInfo); 1263"];
1263 [label="get\n            {\n                return _basis + _offset;\n            } 1264"];
1264 [label="return _basis + _offset; 1265"];
1265 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 1266"];
1266 [label="return _characterWindow[_offset]; 1267"];
1267 [label="param ScanIdentifierOrKeyword(ref TokenInfo info) 1268"];
1268 [label="param ScanIdentifierOrKeyword(this) 1269"];
1269 [label="info.ContextualKind 1270"];
1270 [label="if (this.ScanIdentifier(ref info))\n            {\n                // check to see if it is an actual keyword\n                if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                }\n\n                return true;\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                return false;\n            } 1271"];
1271 [label="this.ScanIdentifier(ref info) 1272"];
1272 [label="param ScanIdentifier(ref TokenInfo info) 1273"];
1273 [label="param ScanIdentifier(this) 1274"];
1274 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 1275"];
1275 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 1276"];
1276 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 1277"];
1277 [label="param Intern(char[] array) 1278"];
1278 [label="param Intern(int start) 1279"];
1279 [label="param Intern(int length) 1280"];
1280 [label="param Intern(this) 1281"];
1281 [label="return _strings.Add(array, start, length); 1282"];
1282 [label="return _strings.Add(array, start, length); 1283"];
1283 [label="return _strings.Add(array, start, length); 1284"];
1284 [label="return _strings.Add(array, start, length); 1285"];
1285 [label="if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                } 1286"];
1286 [label="if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    } 1287"];
1287 [label="this.ModeIs(LexerMode.Directive) 1288"];
1288 [label="param ModeIs(LexerMode mode) 1289"];
1289 [label="param ModeIs(this) 1290"];
1290 [label="return ModeOf(_mode) == mode; 1291"];
1291 [label="ModeOf(_mode) 1292"];
1292 [label="param ModeOf(LexerMode mode) 1293"];
1293 [label="return mode & LexerMode.MaskLexMode; 1294"];
1294 [label="return ModeOf(_mode) == mode; 1295"];
1295 [label="if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 1296"];
1296 [label="_cache.TryGetKeywordKind(info.Text, out info.Kind) 1297"];
1297 [label="param TryGetKeywordKind(string key) 1298"];
1298 [label="param TryGetKeywordKind(out SyntaxKind kind) 1299"];
1299 [label="param TryGetKeywordKind(this) 1300"];
1300 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 1301"];
1301 [label="new SyntaxKindEqualityComparer() 1302"];
1302 [label="param SyntaxKindEqualityComparer(this) 1303"];
1303 [label="public static IEqualityComparer<SyntaxKind> EqualityComparer { get; } = new SyntaxKindEqualityComparer(); 1304"];
1304 [label="kind = _keywordKindMap.GetOrMakeValue(key); 1305"];
1305 [label="kind = _keywordKindMap.GetOrMakeValue(key); 1306"];
1306 [label="kind = _keywordKindMap.GetOrMakeValue(key); 1307"];
1307 [label="param GetKeywordKind(string text) 1308"];
1308 [label="switch (text)\n            {\n                case 'bool':\n                    return SyntaxKind.BoolKeyword;\n                case 'byte':\n                    return SyntaxKind.ByteKeyword;\n                case 'sbyte':\n                    return SyntaxKind.SByteKeyword;\n                case 'short':\n                    return SyntaxKind.ShortKeyword;\n                case 'ushort':\n                    return SyntaxKind.UShortKeyword;\n                case 'int':\n                    return SyntaxKind.IntKeyword;\n                case 'uint':\n                    return SyntaxKind.UIntKeyword;\n                case 'long':\n                    return SyntaxKind.LongKeyword;\n                case 'ulong':\n                    return SyntaxKind.ULongKeyword;\n                case 'double':\n                    return SyntaxKind.DoubleKeyword;\n                case 'float':\n                    return SyntaxKind.FloatKeyword;\n                case 'decimal':\n                    return SyntaxKind.DecimalKeyword;\n                case 'string':\n                    return SyntaxKind.StringKeyword;\n                case 'char':\n                    return SyntaxKind.CharKeyword;\n                case 'void':\n                    return SyntaxKind.VoidKeyword;\n                case 'object':\n                    return SyntaxKind.ObjectKeyword;\n                case 'typeof':\n                    return SyntaxKind.TypeOfKeyword;\n                case 'sizeof':\n                    return SyntaxKind.SizeOfKeyword;\n                case 'null':\n                    return SyntaxKind.NullKeyword;\n                case 'true':\n                    return SyntaxKind.TrueKeyword;\n                case 'false':\n                    return SyntaxKind.FalseKeyword;\n                case 'if':\n                    return SyntaxKind.IfKeyword;\n                case 'else':\n                    return SyntaxKind.ElseKeyword;\n                case 'while':\n                    return SyntaxKind.WhileKeyword;\n                case 'for':\n                    return SyntaxKind.ForKeyword;\n                case 'foreach':\n                    return SyntaxKind.ForEachKeyword;\n                case 'do':\n                    return SyntaxKind.DoKeyword;\n                case 'switch':\n                    return SyntaxKind.SwitchKeyword;\n                case 'case':\n                    return SyntaxKind.CaseKeyword;\n                case 'default':\n                    return SyntaxKind.DefaultKeyword;\n                case 'lock':\n                    return SyntaxKind.LockKeyword;\n                case 'try':\n                    return SyntaxKind.TryKeyword;\n                case 'throw':\n                    return SyntaxKind.ThrowKeyword;\n                case 'catch':\n                    return SyntaxKind.CatchKeyword;\n                case 'finally':\n                    return SyntaxKind.FinallyKeyword;\n                case 'goto':\n                    return SyntaxKind.GotoKeyword;\n                case 'break':\n                    return SyntaxKind.BreakKeyword;\n                case 'continue':\n                    return SyntaxKind.ContinueKeyword;\n                case 'return':\n                    return SyntaxKind.ReturnKeyword;\n                case 'public':\n                    return SyntaxKind.PublicKeyword;\n                case 'private':\n                    return SyntaxKind.PrivateKeyword;\n                case 'internal':\n                    return SyntaxKind.InternalKeyword;\n                case 'protected':\n                    return SyntaxKind.ProtectedKeyword;\n                case 'static':\n                    return SyntaxKind.StaticKeyword;\n                case 'readonly':\n                    return SyntaxKind.ReadOnlyKeyword;\n                case 'sealed':\n                    return SyntaxKind.SealedKeyword;\n                case 'const':\n                    return SyntaxKind.ConstKeyword;\n                case 'fixed':\n                    return SyntaxKind.FixedKeyword;\n                case 'stackalloc':\n                    return SyntaxKind.StackAllocKeyword;\n                case 'volatile':\n                    return SyntaxKind.VolatileKeyword;\n                case 'new':\n                    return SyntaxKind.NewKeyword;\n                case 'override':\n                    return SyntaxKind.OverrideKeyword;\n                case 'abstract':\n                    return SyntaxKind.AbstractKeyword;\n                case 'virtual':\n                    return SyntaxKind.VirtualKeyword;\n                case 'event':\n                    return SyntaxKind.EventKeyword;\n                case 'extern':\n                    return SyntaxKind.ExternKeyword;\n                case 'ref':\n                    return SyntaxKind.RefKeyword;\n                case 'out':\n                    return SyntaxKind.OutKeyword;\n                case 'in':\n                    return SyntaxKind.InKeyword;\n                case 'is':\n                    return SyntaxKind.IsKeyword;\n                case 'as':\n                    return SyntaxKind.AsKeyword;\n                case 'params':\n                    return SyntaxKind.ParamsKeyword;\n                case '__arglist':\n                    return SyntaxKind.ArgListKeyword;\n                case '__makeref':\n                    return SyntaxKind.MakeRefKeyword;\n                case '__reftype':\n                    return SyntaxKind.RefTypeKeyword;\n                case '__refvalue':\n                    return SyntaxKind.RefValueKeyword;\n                case 'this':\n                    return SyntaxKind.ThisKeyword;\n                case 'base':\n                    return SyntaxKind.BaseKeyword;\n                case 'namespace':\n                    return SyntaxKind.NamespaceKeyword;\n                case 'using':\n                    return SyntaxKind.UsingKeyword;\n                case 'class':\n                    return SyntaxKind.ClassKeyword;\n                case 'struct':\n                    return SyntaxKind.StructKeyword;\n                case 'interface':\n                    return SyntaxKind.InterfaceKeyword;\n                case 'enum':\n                    return SyntaxKind.EnumKeyword;\n                case 'delegate':\n                    return SyntaxKind.DelegateKeyword;\n                case 'checked':\n                    return SyntaxKind.CheckedKeyword;\n                case 'unchecked':\n                    return SyntaxKind.UncheckedKeyword;\n                case 'unsafe':\n                    return SyntaxKind.UnsafeKeyword;\n                case 'operator':\n                    return SyntaxKind.OperatorKeyword;\n                case 'implicit':\n                    return SyntaxKind.ImplicitKeyword;\n                case 'explicit':\n                    return SyntaxKind.ExplicitKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 1309"];
1309 [label="return SyntaxKind.None; 1310"];
1310 [label="param GetContextualKeywordKind(string text) 1311"];
1311 [label="switch (text)\n            {\n                case 'yield':\n                    return SyntaxKind.YieldKeyword;\n                case 'partial':\n                    return SyntaxKind.PartialKeyword;\n                case 'from':\n                    return SyntaxKind.FromKeyword;\n                case 'group':\n                    return SyntaxKind.GroupKeyword;\n                case 'join':\n                    return SyntaxKind.JoinKeyword;\n                case 'into':\n                    return SyntaxKind.IntoKeyword;\n                case 'let':\n                    return SyntaxKind.LetKeyword;\n                case 'by':\n                    return SyntaxKind.ByKeyword;\n                case 'where':\n                    return SyntaxKind.WhereKeyword;\n                case 'select':\n                    return SyntaxKind.SelectKeyword;\n                case 'get':\n                    return SyntaxKind.GetKeyword;\n                case 'set':\n                    return SyntaxKind.SetKeyword;\n                case 'add':\n                    return SyntaxKind.AddKeyword;\n                case 'remove':\n                    return SyntaxKind.RemoveKeyword;\n                case 'orderby':\n                    return SyntaxKind.OrderByKeyword;\n                case 'alias':\n                    return SyntaxKind.AliasKeyword;\n                case 'on':\n                    return SyntaxKind.OnKeyword;\n                case 'equals':\n                    return SyntaxKind.EqualsKeyword;\n                case 'ascending':\n                    return SyntaxKind.AscendingKeyword;\n                case 'descending':\n                    return SyntaxKind.DescendingKeyword;\n                case 'assembly':\n                    return SyntaxKind.AssemblyKeyword;\n                case 'module':\n                    return SyntaxKind.ModuleKeyword;\n                case 'type':\n                    return SyntaxKind.TypeKeyword;\n                case 'field':\n                    return SyntaxKind.FieldKeyword;\n                case 'method':\n                    return SyntaxKind.MethodKeyword;\n                case 'param':\n                    return SyntaxKind.ParamKeyword;\n                case 'property':\n                    return SyntaxKind.PropertyKeyword;\n                case 'typevar':\n                    return SyntaxKind.TypeVarKeyword;\n                case 'global':\n                    return SyntaxKind.GlobalKeyword;\n                case 'async':\n                    return SyntaxKind.AsyncKeyword;\n                case 'await':\n                    return SyntaxKind.AwaitKeyword;\n                case 'when':\n                    return SyntaxKind.WhenKeyword;\n                case 'nameof':\n                    return SyntaxKind.NameOfKeyword;\n                case '_':\n                    return SyntaxKind.UnderscoreToken;\n                case 'var':\n                    return SyntaxKind.VarKeyword;\n                case 'and':\n                    return SyntaxKind.AndKeyword;\n                case 'or':\n                    return SyntaxKind.OrKeyword;\n                case 'not':\n                    return SyntaxKind.NotKeyword;\n                case 'data':\n                    return SyntaxKind.DataKeyword;\n                case 'with':\n                    return SyntaxKind.WithKeyword;\n                case 'init':\n                    return SyntaxKind.InitKeyword;\n                case 'record':\n                    return SyntaxKind.RecordKeyword;\n                case 'managed':\n                    return SyntaxKind.ManagedKeyword;\n                case 'unmanaged':\n                    return SyntaxKind.UnmanagedKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 1312"];
1312 [label="return SyntaxKind.UnderscoreToken; 1313"];
1313 [label="kind = _keywordKindMap.GetOrMakeValue(key); 1314"];
1314 [label="return kind != SyntaxKind.None; 1315"];
1315 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 1316"];
1316 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 1317"];
1317 [label="param IsContextualKeyword(SyntaxKind kind) 1318"];
1318 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 1319"];
1319 [label="return true; 1320"];
1320 [label="info.ContextualKind 1321"];
1321 [label="info.Kind 1322"];
1322 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 1323"];
1323 [label="return true; 1324"];
1324 [label="this.ScanSyntaxToken(ref tokenInfo); 1325"];
1325 [label="var errors = this.GetErrors(GetFullWidth(leading)); 1326"];
1326 [label="GetFullWidth(leading) 1327"];
1327 [label="param GetFullWidth(SyntaxListBuilder builder) 1328"];
1328 [label="int width = 0; 1329"];
1329 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 1330"];
1330 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 1331"];
1331 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 1332"];
1332 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 1333"];
1333 [label="return width; 1334"];
1334 [label="var errors = this.GetErrors(GetFullWidth(leading)); 1335"];
1335 [label="this.GetErrors(GetFullWidth(leading)) 1336"];
1336 [label="param GetErrors(int leadingTriviaWidth) 1337"];
1337 [label="param GetErrors(this) 1338"];
1338 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 1339"];
1339 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 1340"];
1340 [label="return null; 1341"];
1341 [label="var errors = this.GetErrors(GetFullWidth(leading)); 1342"];
1342 [label="_trailingTriviaCache.Clear(); 1343"];
1343 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 1344"];
1344 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 1345"];
1345 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache) 1346"];
1346 [label="param LexSyntaxTrivia(bool afterFirstToken) 1347"];
1347 [label="param LexSyntaxTrivia(bool isTrailing) 1348"];
1348 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 1349"];
1349 [label="param LexSyntaxTrivia(this) 1350"];
1350 [label="bool onlyWhitespaceOnLine = !isTrailing; 1351"];
1351 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 1352"];
1352 [label="this.Start() 1353"];
1353 [label="param Start(this) 1354"];
1354 [label="TextWindow.Start() 1355"];
1355 [label="param Start(this) 1356"];
1356 [label="TextWindow.Start(); 1357"];
1357 [label="_errors = null; 1358"];
1358 [label="_errors 1359"];
1359 [label="this.Start(); 1360"];
1360 [label="TextWindow.PeekChar() 1361"];
1361 [label="param PeekChar(this) 1362"];
1362 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 1363"];
1363 [label="char ch = TextWindow.PeekChar(); 1364"];
1364 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 1365"];
1365 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 1366"];
1366 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 1367"];
1367 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 1368"];
1368 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 1369"];
1369 [label="param AdvanceChar(this) 1370"];
1370 [label="_offset 1371"];
1371 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 1372"];
1372 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 1373"];
1373 [label="return _offset - _lexemeStart; 1374"];
1374 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 1375"];
1375 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList) 1376"];
1376 [label="param AddTrivia(CSharpSyntaxNode trivia) 1377"];
1377 [label="param AddTrivia(ref SyntaxListBuilder list) 1378"];
1378 [label="param AddTrivia(this) 1379"];
1379 [label="this.HasErrors 1380"];
1380 [label="get { return _errors != null; } 1381"];
1381 [label="return _errors != null; 1382"];
1382 [label="return _errors != null; 1383"];
1383 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 1384"];
1384 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 1385"];
1385 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 1386"];
1386 [label="list.Add(trivia); 1387"];
1387 [label="list.Add(trivia); 1388"];
1388 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 1389"];
1389 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 1390"];
1390 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 1391"];
1391 [label="if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        } 1392"];
1392 [label="return; 1393"];
1393 [label="var trailing = _trailingTriviaCache; 1394"];
1394 [label="return Create(ref tokenInfo, leading, trailing, errors); 1395"];
1395 [label="return Create(ref tokenInfo, leading, trailing, errors); 1396"];
1396 [label="return Create(ref tokenInfo, leading, trailing, errors); 1397"];
1397 [label="return Create(ref tokenInfo, leading, trailing, errors); 1398"];
1398 [label="Create(ref tokenInfo, leading, trailing, errors) 1399"];
1399 [label="param Create(ref TokenInfo info) 1400"];
1400 [label="param Create(SyntaxListBuilder leading) 1401"];
1401 [label="param Create(SyntaxListBuilder trailing) 1402"];
1402 [label="param Create(SyntaxDiagnosticInfo[] errors) 1403"];
1403 [label="param Create(this) 1404"];
1404 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 1405"];
1405 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 1406"];
1406 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 1407"];
1407 [label="var leadingNode = leading?.ToListNode(); 1408"];
1408 [label="var trailingNode = trailing?.ToListNode(); 1409"];
1409 [label="SyntaxToken token; 1410"];
1410 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 1411"];
1411 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 1412"];
1412 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 1413"];
1413 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 1414"];
1414 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 1415"];
1415 [label="SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode) 1416"];
1416 [label="param Identifier(SyntaxKind contextualKind) 1417"];
1417 [label="param Identifier(GreenNode leading) 1418"];
1418 [label="param Identifier(string text) 1419"];
1419 [label="param Identifier(string valueText) 1420"];
1420 [label="param Identifier(GreenNode trailing) 1421"];
1421 [label="FirstTokenWithWellKnownText = SyntaxKind.TildeToken 1422"];
1422 [label="LastTokenWithWellKnownText = SyntaxKind.EndOfFileToken 1423"];
1423 [label="1 1424"];
1424 [label="(int)LastTokenWithWellKnownText + 1 1425"];
1425 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1426"];
1426 [label="s_tokensWithNoTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1427"];
1427 [label="1 1428"];
1428 [label="(int)LastTokenWithWellKnownText + 1 1429"];
1429 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1430"];
1430 [label="s_tokensWithElasticTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1431"];
1431 [label="1 1432"];
1432 [label="(int)LastTokenWithWellKnownText + 1 1433"];
1433 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1434"];
1434 [label="s_tokensWithSingleTrailingSpace = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1435"];
1435 [label="1 1436"];
1436 [label="(int)LastTokenWithWellKnownText + 1 1437"];
1437 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1438"];
1438 [label="s_tokensWithSingleTrailingCRLF = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1439"];
1439 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxToken), r => new SyntaxToken(r)); 1440"];
1440 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 1441"];
1441 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 1442"];
1442 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 1443"];
1443 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 1444"];
1444 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 1445"];
1445 [label="new SyntaxToken(kind) 1446"];
1446 [label="param SyntaxToken(SyntaxKind kind) 1447"];
1447 [label="param SyntaxToken(this) 1448"];
1448 [label="kind 1449"];
1449 [label="param SyntaxToken(this) 1450"];
1450 [label="param CSharpSyntaxNode(SyntaxKind kind) 1451"];
1451 [label="param CSharpSyntaxNode(this) 1452"];
1452 [label="kind 1453"];
1453 [label="param CSharpSyntaxNode(this) 1454"];
1454 [label="param CSharpSyntaxNode(this) 1455"];
1455 [label="GreenStats.NoteGreen(this); 1456"];
1456 [label="GreenStats.NoteGreen(this); 1457"];
1457 [label="this.Text 1458"];
1458 [label="get { return SyntaxFacts.GetText(this.Kind); } 1459"];
1459 [label="this.Kind 1460"];
1460 [label="get { return (SyntaxKind)this.RawKind; } 1461"];
1461 [label="return (SyntaxKind)this.RawKind; 1462"];
1462 [label="return SyntaxFacts.GetText(this.Kind); 1463"];
1463 [label="SyntaxFacts.GetText(this.Kind) 1464"];
1464 [label="param GetText(SyntaxKind kind) 1465"];
1465 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1466"];
1466 [label="return '~'; 1467"];
1467 [label="FullWidth = this.Text.Length; 1468"];
1468 [label="FullWidth 1469"];
1469 [label="this.flags |= NodeFlags.IsNotMissing; 1470"];
1470 [label="this.flags 1471"];
1471 [label="s_tokensWithNoTrivia[(int)kind].Value 1472"];
1472 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithTrivia), r => new SyntaxTokenWithTrivia(r)); 1473"];
1473 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 1474"];
1474 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 1475"];
1475 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 1476"];
1476 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 1477"];
1477 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 1478"];
1478 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 1479"];
1479 [label="param SyntaxTokenWithTrivia(GreenNode leading) 1480"];
1480 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 1481"];
1481 [label="param SyntaxTokenWithTrivia(this) 1482"];
1482 [label="kind 1483"];
1483 [label="param SyntaxTokenWithTrivia(this) 1484"];
1484 [label="param SyntaxToken(SyntaxKind kind) 1485"];
1485 [label="param SyntaxToken(this) 1486"];
1486 [label="kind 1487"];
1487 [label="param SyntaxToken(this) 1488"];
1488 [label="param CSharpSyntaxNode(SyntaxKind kind) 1489"];
1489 [label="param CSharpSyntaxNode(this) 1490"];
1490 [label="kind 1491"];
1491 [label="param CSharpSyntaxNode(this) 1492"];
1492 [label="param CSharpSyntaxNode(this) 1493"];
1493 [label="GreenStats.NoteGreen(this); 1494"];
1494 [label="GreenStats.NoteGreen(this); 1495"];
1495 [label="this.Text 1496"];
1496 [label="get { return SyntaxFacts.GetText(this.Kind); } 1497"];
1497 [label="this.Kind 1498"];
1498 [label="get { return (SyntaxKind)this.RawKind; } 1499"];
1499 [label="return (SyntaxKind)this.RawKind; 1500"];
1500 [label="return SyntaxFacts.GetText(this.Kind); 1501"];
1501 [label="SyntaxFacts.GetText(this.Kind) 1502"];
1502 [label="param GetText(SyntaxKind kind) 1503"];
1503 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1504"];
1504 [label="return '~'; 1505"];
1505 [label="FullWidth = this.Text.Length; 1506"];
1506 [label="FullWidth 1507"];
1507 [label="this.flags |= NodeFlags.IsNotMissing; 1508"];
1508 [label="this.flags 1509"];
1509 [label="LeadingField 1510"];
1510 [label="TrailingField 1511"];
1511 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 1512"];
1512 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 1513"];
1513 [label="this.AdjustFlagsAndWidth(leading); 1514"];
1514 [label="this.AdjustFlagsAndWidth(leading); 1515"];
1515 [label="this.LeadingField 1516"];
1516 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 1517"];
1517 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 1518"];
1518 [label="this.AdjustFlagsAndWidth(trailing); 1519"];
1519 [label="this.AdjustFlagsAndWidth(trailing); 1520"];
1520 [label="this.TrailingField 1521"];
1521 [label="s_tokensWithElasticTrivia[(int)kind].Value 1522"];
1522 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 1523"];
1523 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 1524"];
1524 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 1525"];
1525 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 1526"];
1526 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 1527"];
1527 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 1528"];
1528 [label="param SyntaxTokenWithTrivia(GreenNode leading) 1529"];
1529 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 1530"];
1530 [label="param SyntaxTokenWithTrivia(this) 1531"];
1531 [label="kind 1532"];
1532 [label="param SyntaxTokenWithTrivia(this) 1533"];
1533 [label="param SyntaxToken(SyntaxKind kind) 1534"];
1534 [label="param SyntaxToken(this) 1535"];
1535 [label="kind 1536"];
1536 [label="param SyntaxToken(this) 1537"];
1537 [label="param CSharpSyntaxNode(SyntaxKind kind) 1538"];
1538 [label="param CSharpSyntaxNode(this) 1539"];
1539 [label="kind 1540"];
1540 [label="param CSharpSyntaxNode(this) 1541"];
1541 [label="param CSharpSyntaxNode(this) 1542"];
1542 [label="GreenStats.NoteGreen(this); 1543"];
1543 [label="GreenStats.NoteGreen(this); 1544"];
1544 [label="this.Text 1545"];
1545 [label="get { return SyntaxFacts.GetText(this.Kind); } 1546"];
1546 [label="this.Kind 1547"];
1547 [label="get { return (SyntaxKind)this.RawKind; } 1548"];
1548 [label="return (SyntaxKind)this.RawKind; 1549"];
1549 [label="return SyntaxFacts.GetText(this.Kind); 1550"];
1550 [label="SyntaxFacts.GetText(this.Kind) 1551"];
1551 [label="param GetText(SyntaxKind kind) 1552"];
1552 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1553"];
1553 [label="return '~'; 1554"];
1554 [label="FullWidth = this.Text.Length; 1555"];
1555 [label="FullWidth 1556"];
1556 [label="this.flags |= NodeFlags.IsNotMissing; 1557"];
1557 [label="this.flags 1558"];
1558 [label="LeadingField 1559"];
1559 [label="TrailingField 1560"];
1560 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 1561"];
1561 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 1562"];
1562 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 1563"];
1563 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 1564"];
1564 [label="this.AdjustFlagsAndWidth(trailing); 1565"];
1565 [label="this.AdjustFlagsAndWidth(trailing); 1566"];
1566 [label="this.TrailingField 1567"];
1567 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1568"];
1568 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 1569"];
1569 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 1570"];
1570 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 1571"];
1571 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 1572"];
1572 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 1573"];
1573 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 1574"];
1574 [label="param SyntaxTokenWithTrivia(GreenNode leading) 1575"];
1575 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 1576"];
1576 [label="param SyntaxTokenWithTrivia(this) 1577"];
1577 [label="kind 1578"];
1578 [label="param SyntaxTokenWithTrivia(this) 1579"];
1579 [label="param SyntaxToken(SyntaxKind kind) 1580"];
1580 [label="param SyntaxToken(this) 1581"];
1581 [label="kind 1582"];
1582 [label="param SyntaxToken(this) 1583"];
1583 [label="param CSharpSyntaxNode(SyntaxKind kind) 1584"];
1584 [label="param CSharpSyntaxNode(this) 1585"];
1585 [label="kind 1586"];
1586 [label="param CSharpSyntaxNode(this) 1587"];
1587 [label="param CSharpSyntaxNode(this) 1588"];
1588 [label="GreenStats.NoteGreen(this); 1589"];
1589 [label="GreenStats.NoteGreen(this); 1590"];
1590 [label="this.Text 1591"];
1591 [label="get { return SyntaxFacts.GetText(this.Kind); } 1592"];
1592 [label="this.Kind 1593"];
1593 [label="get { return (SyntaxKind)this.RawKind; } 1594"];
1594 [label="return (SyntaxKind)this.RawKind; 1595"];
1595 [label="return SyntaxFacts.GetText(this.Kind); 1596"];
1596 [label="SyntaxFacts.GetText(this.Kind) 1597"];
1597 [label="param GetText(SyntaxKind kind) 1598"];
1598 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1599"];
1599 [label="return '~'; 1600"];
1600 [label="FullWidth = this.Text.Length; 1601"];
1601 [label="FullWidth 1602"];
1602 [label="this.flags |= NodeFlags.IsNotMissing; 1603"];
1603 [label="this.flags 1604"];
1604 [label="LeadingField 1605"];
1605 [label="TrailingField 1606"];
1606 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 1607"];
1607 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 1608"];
1608 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 1609"];
1609 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 1610"];
1610 [label="this.AdjustFlagsAndWidth(trailing); 1611"];
1611 [label="this.AdjustFlagsAndWidth(trailing); 1612"];
1612 [label="this.TrailingField 1613"];
1613 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1614"];
1614 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 1615"];
1615 [label="param SyntaxToken(SyntaxKind kind) 1616"];
1616 [label="kind 1617"];
1617 [label="param CSharpSyntaxNode(SyntaxKind kind) 1618"];
1618 [label="kind 1619"];
1619 [label="param CSharpSyntaxNode(this) 1620"];
1620 [label="GreenStats.NoteGreen(this); 1621"];
1621 [label="return (SyntaxKind)this.RawKind; 1622"];
1622 [label="return SyntaxFacts.GetText(this.Kind); 1623"];
1623 [label="param GetText(SyntaxKind kind) 1624"];
1624 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1625"];
1625 [label="return '!'; 1626"];
1626 [label="FullWidth = this.Text.Length; 1627"];
1627 [label="FullWidth 1628"];
1628 [label="this.flags |= NodeFlags.IsNotMissing; 1629"];
1629 [label="this.flags 1630"];
1630 [label="s_tokensWithNoTrivia[(int)kind].Value 1631"];
1631 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 1632"];
1632 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 1633"];
1633 [label="kind 1634"];
1634 [label="param SyntaxToken(SyntaxKind kind) 1635"];
1635 [label="kind 1636"];
1636 [label="param CSharpSyntaxNode(SyntaxKind kind) 1637"];
1637 [label="kind 1638"];
1638 [label="param CSharpSyntaxNode(this) 1639"];
1639 [label="GreenStats.NoteGreen(this); 1640"];
1640 [label="return (SyntaxKind)this.RawKind; 1641"];
1641 [label="return SyntaxFacts.GetText(this.Kind); 1642"];
1642 [label="param GetText(SyntaxKind kind) 1643"];
1643 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1644"];
1644 [label="return '!'; 1645"];
1645 [label="FullWidth = this.Text.Length; 1646"];
1646 [label="FullWidth 1647"];
1647 [label="this.flags |= NodeFlags.IsNotMissing; 1648"];
1648 [label="this.flags 1649"];
1649 [label="this.AdjustFlagsAndWidth(leading); 1650"];
1650 [label="s_tokensWithElasticTrivia[(int)kind].Value 1651"];
1651 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 1652"];
1652 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 1653"];
1653 [label="kind 1654"];
1654 [label="param SyntaxToken(SyntaxKind kind) 1655"];
1655 [label="kind 1656"];
1656 [label="param CSharpSyntaxNode(SyntaxKind kind) 1657"];
1657 [label="kind 1658"];
1658 [label="param CSharpSyntaxNode(this) 1659"];
1659 [label="GreenStats.NoteGreen(this); 1660"];
1660 [label="return (SyntaxKind)this.RawKind; 1661"];
1661 [label="return SyntaxFacts.GetText(this.Kind); 1662"];
1662 [label="param GetText(SyntaxKind kind) 1663"];
1663 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1664"];
1664 [label="return '!'; 1665"];
1665 [label="FullWidth = this.Text.Length; 1666"];
1666 [label="FullWidth 1667"];
1667 [label="this.flags |= NodeFlags.IsNotMissing; 1668"];
1668 [label="this.flags 1669"];
1669 [label="this.AdjustFlagsAndWidth(trailing); 1670"];
1670 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1671"];
1671 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 1672"];
1672 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 1673"];
1673 [label="kind 1674"];
1674 [label="param SyntaxToken(SyntaxKind kind) 1675"];
1675 [label="kind 1676"];
1676 [label="param CSharpSyntaxNode(SyntaxKind kind) 1677"];
1677 [label="kind 1678"];
1678 [label="param CSharpSyntaxNode(this) 1679"];
1679 [label="GreenStats.NoteGreen(this); 1680"];
1680 [label="return (SyntaxKind)this.RawKind; 1681"];
1681 [label="return SyntaxFacts.GetText(this.Kind); 1682"];
1682 [label="param GetText(SyntaxKind kind) 1683"];
1683 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1684"];
1684 [label="return '!'; 1685"];
1685 [label="FullWidth = this.Text.Length; 1686"];
1686 [label="FullWidth 1687"];
1687 [label="this.flags |= NodeFlags.IsNotMissing; 1688"];
1688 [label="this.flags 1689"];
1689 [label="this.AdjustFlagsAndWidth(trailing); 1690"];
1690 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1691"];
1691 [label="return '$'; 1692"];
1692 [label="FullWidth = this.Text.Length; 1693"];
1693 [label="FullWidth 1694"];
1694 [label="return '$'; 1695"];
1695 [label="FullWidth = this.Text.Length; 1696"];
1696 [label="FullWidth 1697"];
1697 [label="this.AdjustFlagsAndWidth(leading); 1698"];
1698 [label="return '$'; 1699"];
1699 [label="FullWidth = this.Text.Length; 1700"];
1700 [label="FullWidth 1701"];
1701 [label="this.AdjustFlagsAndWidth(trailing); 1702"];
1702 [label="return '$'; 1703"];
1703 [label="FullWidth = this.Text.Length; 1704"];
1704 [label="FullWidth 1705"];
1705 [label="this.AdjustFlagsAndWidth(trailing); 1706"];
1706 [label="return '%'; 1707"];
1707 [label="FullWidth = this.Text.Length; 1708"];
1708 [label="FullWidth 1709"];
1709 [label="return '%'; 1710"];
1710 [label="FullWidth = this.Text.Length; 1711"];
1711 [label="FullWidth 1712"];
1712 [label="this.AdjustFlagsAndWidth(leading); 1713"];
1713 [label="return '%'; 1714"];
1714 [label="FullWidth = this.Text.Length; 1715"];
1715 [label="FullWidth 1716"];
1716 [label="this.AdjustFlagsAndWidth(trailing); 1717"];
1717 [label="return '%'; 1718"];
1718 [label="FullWidth = this.Text.Length; 1719"];
1719 [label="FullWidth 1720"];
1720 [label="this.AdjustFlagsAndWidth(trailing); 1721"];
1721 [label="return '^'; 1722"];
1722 [label="FullWidth = this.Text.Length; 1723"];
1723 [label="FullWidth 1724"];
1724 [label="return '^'; 1725"];
1725 [label="FullWidth = this.Text.Length; 1726"];
1726 [label="FullWidth 1727"];
1727 [label="this.AdjustFlagsAndWidth(leading); 1728"];
1728 [label="return '^'; 1729"];
1729 [label="FullWidth = this.Text.Length; 1730"];
1730 [label="FullWidth 1731"];
1731 [label="this.AdjustFlagsAndWidth(trailing); 1732"];
1732 [label="return '^'; 1733"];
1733 [label="FullWidth = this.Text.Length; 1734"];
1734 [label="FullWidth 1735"];
1735 [label="this.AdjustFlagsAndWidth(trailing); 1736"];
1736 [label="return '&'; 1737"];
1737 [label="FullWidth = this.Text.Length; 1738"];
1738 [label="FullWidth 1739"];
1739 [label="return '&'; 1740"];
1740 [label="FullWidth = this.Text.Length; 1741"];
1741 [label="FullWidth 1742"];
1742 [label="this.AdjustFlagsAndWidth(leading); 1743"];
1743 [label="return '&'; 1744"];
1744 [label="FullWidth = this.Text.Length; 1745"];
1745 [label="FullWidth 1746"];
1746 [label="this.AdjustFlagsAndWidth(trailing); 1747"];
1747 [label="return '&'; 1748"];
1748 [label="FullWidth = this.Text.Length; 1749"];
1749 [label="FullWidth 1750"];
1750 [label="this.AdjustFlagsAndWidth(trailing); 1751"];
1751 [label="return '*'; 1752"];
1752 [label="FullWidth = this.Text.Length; 1753"];
1753 [label="FullWidth 1754"];
1754 [label="return '*'; 1755"];
1755 [label="FullWidth = this.Text.Length; 1756"];
1756 [label="FullWidth 1757"];
1757 [label="this.AdjustFlagsAndWidth(leading); 1758"];
1758 [label="return '*'; 1759"];
1759 [label="FullWidth = this.Text.Length; 1760"];
1760 [label="FullWidth 1761"];
1761 [label="this.AdjustFlagsAndWidth(trailing); 1762"];
1762 [label="return '*'; 1763"];
1763 [label="FullWidth = this.Text.Length; 1764"];
1764 [label="FullWidth 1765"];
1765 [label="this.AdjustFlagsAndWidth(trailing); 1766"];
1766 [label="return '('; 1767"];
1767 [label="FullWidth = this.Text.Length; 1768"];
1768 [label="FullWidth 1769"];
1769 [label="return '('; 1770"];
1770 [label="FullWidth = this.Text.Length; 1771"];
1771 [label="FullWidth 1772"];
1772 [label="this.AdjustFlagsAndWidth(leading); 1773"];
1773 [label="return '('; 1774"];
1774 [label="FullWidth = this.Text.Length; 1775"];
1775 [label="FullWidth 1776"];
1776 [label="this.AdjustFlagsAndWidth(trailing); 1777"];
1777 [label="return '('; 1778"];
1778 [label="FullWidth = this.Text.Length; 1779"];
1779 [label="FullWidth 1780"];
1780 [label="this.AdjustFlagsAndWidth(trailing); 1781"];
1781 [label="return ')'; 1782"];
1782 [label="FullWidth = this.Text.Length; 1783"];
1783 [label="FullWidth 1784"];
1784 [label="return ')'; 1785"];
1785 [label="FullWidth = this.Text.Length; 1786"];
1786 [label="FullWidth 1787"];
1787 [label="this.AdjustFlagsAndWidth(leading); 1788"];
1788 [label="return ')'; 1789"];
1789 [label="FullWidth = this.Text.Length; 1790"];
1790 [label="FullWidth 1791"];
1791 [label="this.AdjustFlagsAndWidth(trailing); 1792"];
1792 [label="return ')'; 1793"];
1793 [label="FullWidth = this.Text.Length; 1794"];
1794 [label="FullWidth 1795"];
1795 [label="this.AdjustFlagsAndWidth(trailing); 1796"];
1796 [label="return '-'; 1797"];
1797 [label="FullWidth = this.Text.Length; 1798"];
1798 [label="FullWidth 1799"];
1799 [label="return '-'; 1800"];
1800 [label="FullWidth = this.Text.Length; 1801"];
1801 [label="FullWidth 1802"];
1802 [label="this.AdjustFlagsAndWidth(leading); 1803"];
1803 [label="return '-'; 1804"];
1804 [label="FullWidth = this.Text.Length; 1805"];
1805 [label="FullWidth 1806"];
1806 [label="this.AdjustFlagsAndWidth(trailing); 1807"];
1807 [label="return '-'; 1808"];
1808 [label="FullWidth = this.Text.Length; 1809"];
1809 [label="FullWidth 1810"];
1810 [label="this.AdjustFlagsAndWidth(trailing); 1811"];
1811 [label="return '+'; 1812"];
1812 [label="FullWidth = this.Text.Length; 1813"];
1813 [label="FullWidth 1814"];
1814 [label="return '+'; 1815"];
1815 [label="FullWidth = this.Text.Length; 1816"];
1816 [label="FullWidth 1817"];
1817 [label="this.AdjustFlagsAndWidth(leading); 1818"];
1818 [label="return '+'; 1819"];
1819 [label="FullWidth = this.Text.Length; 1820"];
1820 [label="FullWidth 1821"];
1821 [label="this.AdjustFlagsAndWidth(trailing); 1822"];
1822 [label="return '+'; 1823"];
1823 [label="FullWidth = this.Text.Length; 1824"];
1824 [label="FullWidth 1825"];
1825 [label="this.AdjustFlagsAndWidth(trailing); 1826"];
1826 [label="return '='; 1827"];
1827 [label="FullWidth = this.Text.Length; 1828"];
1828 [label="FullWidth 1829"];
1829 [label="return '='; 1830"];
1830 [label="FullWidth = this.Text.Length; 1831"];
1831 [label="FullWidth 1832"];
1832 [label="this.AdjustFlagsAndWidth(leading); 1833"];
1833 [label="return '='; 1834"];
1834 [label="FullWidth = this.Text.Length; 1835"];
1835 [label="FullWidth 1836"];
1836 [label="this.AdjustFlagsAndWidth(trailing); 1837"];
1837 [label="return '='; 1838"];
1838 [label="FullWidth = this.Text.Length; 1839"];
1839 [label="FullWidth 1840"];
1840 [label="this.AdjustFlagsAndWidth(trailing); 1841"];
1841 [label="return '{'; 1842"];
1842 [label="FullWidth = this.Text.Length; 1843"];
1843 [label="FullWidth 1844"];
1844 [label="return '{'; 1845"];
1845 [label="FullWidth = this.Text.Length; 1846"];
1846 [label="FullWidth 1847"];
1847 [label="this.AdjustFlagsAndWidth(leading); 1848"];
1848 [label="return '{'; 1849"];
1849 [label="FullWidth = this.Text.Length; 1850"];
1850 [label="FullWidth 1851"];
1851 [label="this.AdjustFlagsAndWidth(trailing); 1852"];
1852 [label="return '{'; 1853"];
1853 [label="FullWidth = this.Text.Length; 1854"];
1854 [label="FullWidth 1855"];
1855 [label="this.AdjustFlagsAndWidth(trailing); 1856"];
1856 [label="return '}'; 1857"];
1857 [label="FullWidth = this.Text.Length; 1858"];
1858 [label="FullWidth 1859"];
1859 [label="return '}'; 1860"];
1860 [label="FullWidth = this.Text.Length; 1861"];
1861 [label="FullWidth 1862"];
1862 [label="this.AdjustFlagsAndWidth(leading); 1863"];
1863 [label="return '}'; 1864"];
1864 [label="FullWidth = this.Text.Length; 1865"];
1865 [label="FullWidth 1866"];
1866 [label="this.AdjustFlagsAndWidth(trailing); 1867"];
1867 [label="return '}'; 1868"];
1868 [label="FullWidth = this.Text.Length; 1869"];
1869 [label="FullWidth 1870"];
1870 [label="this.AdjustFlagsAndWidth(trailing); 1871"];
1871 [label="return '['; 1872"];
1872 [label="FullWidth = this.Text.Length; 1873"];
1873 [label="FullWidth 1874"];
1874 [label="return '['; 1875"];
1875 [label="FullWidth = this.Text.Length; 1876"];
1876 [label="FullWidth 1877"];
1877 [label="this.AdjustFlagsAndWidth(leading); 1878"];
1878 [label="return '['; 1879"];
1879 [label="FullWidth = this.Text.Length; 1880"];
1880 [label="FullWidth 1881"];
1881 [label="this.AdjustFlagsAndWidth(trailing); 1882"];
1882 [label="return '['; 1883"];
1883 [label="FullWidth = this.Text.Length; 1884"];
1884 [label="FullWidth 1885"];
1885 [label="this.AdjustFlagsAndWidth(trailing); 1886"];
1886 [label="return ']'; 1887"];
1887 [label="FullWidth = this.Text.Length; 1888"];
1888 [label="FullWidth 1889"];
1889 [label="return ']'; 1890"];
1890 [label="FullWidth = this.Text.Length; 1891"];
1891 [label="FullWidth 1892"];
1892 [label="this.AdjustFlagsAndWidth(leading); 1893"];
1893 [label="return ']'; 1894"];
1894 [label="FullWidth = this.Text.Length; 1895"];
1895 [label="FullWidth 1896"];
1896 [label="this.AdjustFlagsAndWidth(trailing); 1897"];
1897 [label="return ']'; 1898"];
1898 [label="FullWidth = this.Text.Length; 1899"];
1899 [label="FullWidth 1900"];
1900 [label="this.AdjustFlagsAndWidth(trailing); 1901"];
1901 [label="return '|'; 1902"];
1902 [label="FullWidth = this.Text.Length; 1903"];
1903 [label="FullWidth 1904"];
1904 [label="return '|'; 1905"];
1905 [label="FullWidth = this.Text.Length; 1906"];
1906 [label="FullWidth 1907"];
1907 [label="this.AdjustFlagsAndWidth(leading); 1908"];
1908 [label="return '|'; 1909"];
1909 [label="FullWidth = this.Text.Length; 1910"];
1910 [label="FullWidth 1911"];
1911 [label="this.AdjustFlagsAndWidth(trailing); 1912"];
1912 [label="return '|'; 1913"];
1913 [label="FullWidth = this.Text.Length; 1914"];
1914 [label="FullWidth 1915"];
1915 [label="this.AdjustFlagsAndWidth(trailing); 1916"];
1916 [label="return '\\\\'; 1917"];
1917 [label="FullWidth = this.Text.Length; 1918"];
1918 [label="FullWidth 1919"];
1919 [label="return '\\\\'; 1920"];
1920 [label="FullWidth = this.Text.Length; 1921"];
1921 [label="FullWidth 1922"];
1922 [label="this.AdjustFlagsAndWidth(leading); 1923"];
1923 [label="return '\\\\'; 1924"];
1924 [label="FullWidth = this.Text.Length; 1925"];
1925 [label="FullWidth 1926"];
1926 [label="this.AdjustFlagsAndWidth(trailing); 1927"];
1927 [label="return '\\\\'; 1928"];
1928 [label="FullWidth = this.Text.Length; 1929"];
1929 [label="FullWidth 1930"];
1930 [label="this.AdjustFlagsAndWidth(trailing); 1931"];
1931 [label="return ':'; 1932"];
1932 [label="FullWidth = this.Text.Length; 1933"];
1933 [label="FullWidth 1934"];
1934 [label="return ':'; 1935"];
1935 [label="FullWidth = this.Text.Length; 1936"];
1936 [label="FullWidth 1937"];
1937 [label="this.AdjustFlagsAndWidth(leading); 1938"];
1938 [label="return ':'; 1939"];
1939 [label="FullWidth = this.Text.Length; 1940"];
1940 [label="FullWidth 1941"];
1941 [label="this.AdjustFlagsAndWidth(trailing); 1942"];
1942 [label="return ':'; 1943"];
1943 [label="FullWidth = this.Text.Length; 1944"];
1944 [label="FullWidth 1945"];
1945 [label="this.AdjustFlagsAndWidth(trailing); 1946"];
1946 [label="return ';'; 1947"];
1947 [label="FullWidth = this.Text.Length; 1948"];
1948 [label="FullWidth 1949"];
1949 [label="return ';'; 1950"];
1950 [label="FullWidth = this.Text.Length; 1951"];
1951 [label="FullWidth 1952"];
1952 [label="this.AdjustFlagsAndWidth(leading); 1953"];
1953 [label="return ';'; 1954"];
1954 [label="FullWidth = this.Text.Length; 1955"];
1955 [label="FullWidth 1956"];
1956 [label="this.AdjustFlagsAndWidth(trailing); 1957"];
1957 [label="return ';'; 1958"];
1958 [label="FullWidth = this.Text.Length; 1959"];
1959 [label="FullWidth 1960"];
1960 [label="this.AdjustFlagsAndWidth(trailing); 1961"];
1961 [label="return '\\''; 1962"];
1962 [label="FullWidth = this.Text.Length; 1963"];
1963 [label="FullWidth 1964"];
1964 [label="return '\\''; 1965"];
1965 [label="FullWidth = this.Text.Length; 1966"];
1966 [label="FullWidth 1967"];
1967 [label="this.AdjustFlagsAndWidth(leading); 1968"];
1968 [label="return '\\''; 1969"];
1969 [label="FullWidth = this.Text.Length; 1970"];
1970 [label="FullWidth 1971"];
1971 [label="this.AdjustFlagsAndWidth(trailing); 1972"];
1972 [label="return '\\''; 1973"];
1973 [label="FullWidth = this.Text.Length; 1974"];
1974 [label="FullWidth 1975"];
1975 [label="this.AdjustFlagsAndWidth(trailing); 1976"];
1976 [label="return '''; 1977"];
1977 [label="FullWidth = this.Text.Length; 1978"];
1978 [label="FullWidth 1979"];
1979 [label="return '''; 1980"];
1980 [label="FullWidth = this.Text.Length; 1981"];
1981 [label="FullWidth 1982"];
1982 [label="this.AdjustFlagsAndWidth(leading); 1983"];
1983 [label="return '''; 1984"];
1984 [label="FullWidth = this.Text.Length; 1985"];
1985 [label="FullWidth 1986"];
1986 [label="this.AdjustFlagsAndWidth(trailing); 1987"];
1987 [label="return '''; 1988"];
1988 [label="FullWidth = this.Text.Length; 1989"];
1989 [label="FullWidth 1990"];
1990 [label="this.AdjustFlagsAndWidth(trailing); 1991"];
1991 [label="return '<'; 1992"];
1992 [label="FullWidth = this.Text.Length; 1993"];
1993 [label="FullWidth 1994"];
1994 [label="return '<'; 1995"];
1995 [label="FullWidth = this.Text.Length; 1996"];
1996 [label="FullWidth 1997"];
1997 [label="this.AdjustFlagsAndWidth(leading); 1998"];
1998 [label="return '<'; 1999"];
1999 [label="FullWidth = this.Text.Length; 2000"];
2000 [label="FullWidth 2001"];
2001 [label="this.AdjustFlagsAndWidth(trailing); 2002"];
2002 [label="return '<'; 2003"];
2003 [label="FullWidth = this.Text.Length; 2004"];
2004 [label="FullWidth 2005"];
2005 [label="this.AdjustFlagsAndWidth(trailing); 2006"];
2006 [label="return ','; 2007"];
2007 [label="FullWidth = this.Text.Length; 2008"];
2008 [label="FullWidth 2009"];
2009 [label="return ','; 2010"];
2010 [label="FullWidth = this.Text.Length; 2011"];
2011 [label="FullWidth 2012"];
2012 [label="this.AdjustFlagsAndWidth(leading); 2013"];
2013 [label="return ','; 2014"];
2014 [label="FullWidth = this.Text.Length; 2015"];
2015 [label="FullWidth 2016"];
2016 [label="this.AdjustFlagsAndWidth(trailing); 2017"];
2017 [label="return ','; 2018"];
2018 [label="FullWidth = this.Text.Length; 2019"];
2019 [label="FullWidth 2020"];
2020 [label="this.AdjustFlagsAndWidth(trailing); 2021"];
2021 [label="return '>'; 2022"];
2022 [label="FullWidth = this.Text.Length; 2023"];
2023 [label="FullWidth 2024"];
2024 [label="return '>'; 2025"];
2025 [label="FullWidth = this.Text.Length; 2026"];
2026 [label="FullWidth 2027"];
2027 [label="this.AdjustFlagsAndWidth(leading); 2028"];
2028 [label="return '>'; 2029"];
2029 [label="FullWidth = this.Text.Length; 2030"];
2030 [label="FullWidth 2031"];
2031 [label="this.AdjustFlagsAndWidth(trailing); 2032"];
2032 [label="return '>'; 2033"];
2033 [label="FullWidth = this.Text.Length; 2034"];
2034 [label="FullWidth 2035"];
2035 [label="this.AdjustFlagsAndWidth(trailing); 2036"];
2036 [label="return '.'; 2037"];
2037 [label="FullWidth = this.Text.Length; 2038"];
2038 [label="FullWidth 2039"];
2039 [label="return '.'; 2040"];
2040 [label="FullWidth = this.Text.Length; 2041"];
2041 [label="FullWidth 2042"];
2042 [label="this.AdjustFlagsAndWidth(leading); 2043"];
2043 [label="return '.'; 2044"];
2044 [label="FullWidth = this.Text.Length; 2045"];
2045 [label="FullWidth 2046"];
2046 [label="this.AdjustFlagsAndWidth(trailing); 2047"];
2047 [label="return '.'; 2048"];
2048 [label="FullWidth = this.Text.Length; 2049"];
2049 [label="FullWidth 2050"];
2050 [label="this.AdjustFlagsAndWidth(trailing); 2051"];
2051 [label="return '?'; 2052"];
2052 [label="FullWidth = this.Text.Length; 2053"];
2053 [label="FullWidth 2054"];
2054 [label="return '?'; 2055"];
2055 [label="FullWidth = this.Text.Length; 2056"];
2056 [label="FullWidth 2057"];
2057 [label="this.AdjustFlagsAndWidth(leading); 2058"];
2058 [label="return '?'; 2059"];
2059 [label="FullWidth = this.Text.Length; 2060"];
2060 [label="FullWidth 2061"];
2061 [label="this.AdjustFlagsAndWidth(trailing); 2062"];
2062 [label="return '?'; 2063"];
2063 [label="FullWidth = this.Text.Length; 2064"];
2064 [label="FullWidth 2065"];
2065 [label="this.AdjustFlagsAndWidth(trailing); 2066"];
2066 [label="return '#'; 2067"];
2067 [label="FullWidth = this.Text.Length; 2068"];
2068 [label="FullWidth 2069"];
2069 [label="return '#'; 2070"];
2070 [label="FullWidth = this.Text.Length; 2071"];
2071 [label="FullWidth 2072"];
2072 [label="this.AdjustFlagsAndWidth(leading); 2073"];
2073 [label="return '#'; 2074"];
2074 [label="FullWidth = this.Text.Length; 2075"];
2075 [label="FullWidth 2076"];
2076 [label="this.AdjustFlagsAndWidth(trailing); 2077"];
2077 [label="return '#'; 2078"];
2078 [label="FullWidth = this.Text.Length; 2079"];
2079 [label="FullWidth 2080"];
2080 [label="this.AdjustFlagsAndWidth(trailing); 2081"];
2081 [label="return '/'; 2082"];
2082 [label="FullWidth = this.Text.Length; 2083"];
2083 [label="FullWidth 2084"];
2084 [label="return '/'; 2085"];
2085 [label="FullWidth = this.Text.Length; 2086"];
2086 [label="FullWidth 2087"];
2087 [label="this.AdjustFlagsAndWidth(leading); 2088"];
2088 [label="return '/'; 2089"];
2089 [label="FullWidth = this.Text.Length; 2090"];
2090 [label="FullWidth 2091"];
2091 [label="this.AdjustFlagsAndWidth(trailing); 2092"];
2092 [label="return '/'; 2093"];
2093 [label="FullWidth = this.Text.Length; 2094"];
2094 [label="FullWidth 2095"];
2095 [label="this.AdjustFlagsAndWidth(trailing); 2096"];
2096 [label="return '..'; 2097"];
2097 [label="FullWidth = this.Text.Length; 2098"];
2098 [label="FullWidth 2099"];
2099 [label="return '..'; 2100"];
2100 [label="FullWidth = this.Text.Length; 2101"];
2101 [label="FullWidth 2102"];
2102 [label="this.AdjustFlagsAndWidth(leading); 2103"];
2103 [label="return '..'; 2104"];
2104 [label="FullWidth = this.Text.Length; 2105"];
2105 [label="FullWidth 2106"];
2106 [label="this.AdjustFlagsAndWidth(trailing); 2107"];
2107 [label="return '..'; 2108"];
2108 [label="FullWidth = this.Text.Length; 2109"];
2109 [label="FullWidth 2110"];
2110 [label="this.AdjustFlagsAndWidth(trailing); 2111"];
2111 [label="return string.Empty; 2112"];
2112 [label="FullWidth = this.Text.Length; 2113"];
2113 [label="FullWidth 2114"];
2114 [label="return string.Empty; 2115"];
2115 [label="FullWidth = this.Text.Length; 2116"];
2116 [label="FullWidth 2117"];
2117 [label="this.AdjustFlagsAndWidth(leading); 2118"];
2118 [label="return string.Empty; 2119"];
2119 [label="FullWidth = this.Text.Length; 2120"];
2120 [label="FullWidth 2121"];
2121 [label="this.AdjustFlagsAndWidth(trailing); 2122"];
2122 [label="return string.Empty; 2123"];
2123 [label="FullWidth = this.Text.Length; 2124"];
2124 [label="FullWidth 2125"];
2125 [label="this.AdjustFlagsAndWidth(trailing); 2126"];
2126 [label="return '/>'; 2127"];
2127 [label="FullWidth = this.Text.Length; 2128"];
2128 [label="FullWidth 2129"];
2129 [label="return '/>'; 2130"];
2130 [label="FullWidth = this.Text.Length; 2131"];
2131 [label="FullWidth 2132"];
2132 [label="this.AdjustFlagsAndWidth(leading); 2133"];
2133 [label="return '/>'; 2134"];
2134 [label="FullWidth = this.Text.Length; 2135"];
2135 [label="FullWidth 2136"];
2136 [label="this.AdjustFlagsAndWidth(trailing); 2137"];
2137 [label="return '/>'; 2138"];
2138 [label="FullWidth = this.Text.Length; 2139"];
2139 [label="FullWidth 2140"];
2140 [label="this.AdjustFlagsAndWidth(trailing); 2141"];
2141 [label="return '</'; 2142"];
2142 [label="FullWidth = this.Text.Length; 2143"];
2143 [label="FullWidth 2144"];
2144 [label="return '</'; 2145"];
2145 [label="FullWidth = this.Text.Length; 2146"];
2146 [label="FullWidth 2147"];
2147 [label="this.AdjustFlagsAndWidth(leading); 2148"];
2148 [label="return '</'; 2149"];
2149 [label="FullWidth = this.Text.Length; 2150"];
2150 [label="FullWidth 2151"];
2151 [label="this.AdjustFlagsAndWidth(trailing); 2152"];
2152 [label="return '</'; 2153"];
2153 [label="FullWidth = this.Text.Length; 2154"];
2154 [label="FullWidth 2155"];
2155 [label="this.AdjustFlagsAndWidth(trailing); 2156"];
2156 [label="return '<!--'; 2157"];
2157 [label="FullWidth = this.Text.Length; 2158"];
2158 [label="FullWidth 2159"];
2159 [label="return '<!--'; 2160"];
2160 [label="FullWidth = this.Text.Length; 2161"];
2161 [label="FullWidth 2162"];
2162 [label="this.AdjustFlagsAndWidth(leading); 2163"];
2163 [label="return '<!--'; 2164"];
2164 [label="FullWidth = this.Text.Length; 2165"];
2165 [label="FullWidth 2166"];
2166 [label="this.AdjustFlagsAndWidth(trailing); 2167"];
2167 [label="return '<!--'; 2168"];
2168 [label="FullWidth = this.Text.Length; 2169"];
2169 [label="FullWidth 2170"];
2170 [label="this.AdjustFlagsAndWidth(trailing); 2171"];
2171 [label="return '-->'; 2172"];
2172 [label="FullWidth = this.Text.Length; 2173"];
2173 [label="FullWidth 2174"];
2174 [label="return '-->'; 2175"];
2175 [label="FullWidth = this.Text.Length; 2176"];
2176 [label="FullWidth 2177"];
2177 [label="this.AdjustFlagsAndWidth(leading); 2178"];
2178 [label="return '-->'; 2179"];
2179 [label="FullWidth = this.Text.Length; 2180"];
2180 [label="FullWidth 2181"];
2181 [label="this.AdjustFlagsAndWidth(trailing); 2182"];
2182 [label="return '-->'; 2183"];
2183 [label="FullWidth = this.Text.Length; 2184"];
2184 [label="FullWidth 2185"];
2185 [label="this.AdjustFlagsAndWidth(trailing); 2186"];
2186 [label="return '<![CDATA['; 2187"];
2187 [label="FullWidth = this.Text.Length; 2188"];
2188 [label="FullWidth 2189"];
2189 [label="return '<![CDATA['; 2190"];
2190 [label="FullWidth = this.Text.Length; 2191"];
2191 [label="FullWidth 2192"];
2192 [label="this.AdjustFlagsAndWidth(leading); 2193"];
2193 [label="return '<![CDATA['; 2194"];
2194 [label="FullWidth = this.Text.Length; 2195"];
2195 [label="FullWidth 2196"];
2196 [label="this.AdjustFlagsAndWidth(trailing); 2197"];
2197 [label="return '<![CDATA['; 2198"];
2198 [label="FullWidth = this.Text.Length; 2199"];
2199 [label="FullWidth 2200"];
2200 [label="this.AdjustFlagsAndWidth(trailing); 2201"];
2201 [label="return ']]>'; 2202"];
2202 [label="FullWidth = this.Text.Length; 2203"];
2203 [label="FullWidth 2204"];
2204 [label="return ']]>'; 2205"];
2205 [label="FullWidth = this.Text.Length; 2206"];
2206 [label="FullWidth 2207"];
2207 [label="this.AdjustFlagsAndWidth(leading); 2208"];
2208 [label="return ']]>'; 2209"];
2209 [label="FullWidth = this.Text.Length; 2210"];
2210 [label="FullWidth 2211"];
2211 [label="this.AdjustFlagsAndWidth(trailing); 2212"];
2212 [label="return ']]>'; 2213"];
2213 [label="FullWidth = this.Text.Length; 2214"];
2214 [label="FullWidth 2215"];
2215 [label="this.AdjustFlagsAndWidth(trailing); 2216"];
2216 [label="return '<?'; 2217"];
2217 [label="FullWidth = this.Text.Length; 2218"];
2218 [label="FullWidth 2219"];
2219 [label="return '<?'; 2220"];
2220 [label="FullWidth = this.Text.Length; 2221"];
2221 [label="FullWidth 2222"];
2222 [label="this.AdjustFlagsAndWidth(leading); 2223"];
2223 [label="return '<?'; 2224"];
2224 [label="FullWidth = this.Text.Length; 2225"];
2225 [label="FullWidth 2226"];
2226 [label="this.AdjustFlagsAndWidth(trailing); 2227"];
2227 [label="return '<?'; 2228"];
2228 [label="FullWidth = this.Text.Length; 2229"];
2229 [label="FullWidth 2230"];
2230 [label="this.AdjustFlagsAndWidth(trailing); 2231"];
2231 [label="return '?>'; 2232"];
2232 [label="FullWidth = this.Text.Length; 2233"];
2233 [label="FullWidth 2234"];
2234 [label="return '?>'; 2235"];
2235 [label="FullWidth = this.Text.Length; 2236"];
2236 [label="FullWidth 2237"];
2237 [label="this.AdjustFlagsAndWidth(leading); 2238"];
2238 [label="return '?>'; 2239"];
2239 [label="FullWidth = this.Text.Length; 2240"];
2240 [label="FullWidth 2241"];
2241 [label="this.AdjustFlagsAndWidth(trailing); 2242"];
2242 [label="return '?>'; 2243"];
2243 [label="FullWidth = this.Text.Length; 2244"];
2244 [label="FullWidth 2245"];
2245 [label="this.AdjustFlagsAndWidth(trailing); 2246"];
2246 [label="return '||'; 2247"];
2247 [label="FullWidth = this.Text.Length; 2248"];
2248 [label="FullWidth 2249"];
2249 [label="return '||'; 2250"];
2250 [label="FullWidth = this.Text.Length; 2251"];
2251 [label="FullWidth 2252"];
2252 [label="this.AdjustFlagsAndWidth(leading); 2253"];
2253 [label="return '||'; 2254"];
2254 [label="FullWidth = this.Text.Length; 2255"];
2255 [label="FullWidth 2256"];
2256 [label="this.AdjustFlagsAndWidth(trailing); 2257"];
2257 [label="return '||'; 2258"];
2258 [label="FullWidth = this.Text.Length; 2259"];
2259 [label="FullWidth 2260"];
2260 [label="this.AdjustFlagsAndWidth(trailing); 2261"];
2261 [label="return '&&'; 2262"];
2262 [label="FullWidth = this.Text.Length; 2263"];
2263 [label="FullWidth 2264"];
2264 [label="return '&&'; 2265"];
2265 [label="FullWidth = this.Text.Length; 2266"];
2266 [label="FullWidth 2267"];
2267 [label="this.AdjustFlagsAndWidth(leading); 2268"];
2268 [label="return '&&'; 2269"];
2269 [label="FullWidth = this.Text.Length; 2270"];
2270 [label="FullWidth 2271"];
2271 [label="this.AdjustFlagsAndWidth(trailing); 2272"];
2272 [label="return '&&'; 2273"];
2273 [label="FullWidth = this.Text.Length; 2274"];
2274 [label="FullWidth 2275"];
2275 [label="this.AdjustFlagsAndWidth(trailing); 2276"];
2276 [label="return '--'; 2277"];
2277 [label="FullWidth = this.Text.Length; 2278"];
2278 [label="FullWidth 2279"];
2279 [label="return '--'; 2280"];
2280 [label="FullWidth = this.Text.Length; 2281"];
2281 [label="FullWidth 2282"];
2282 [label="this.AdjustFlagsAndWidth(leading); 2283"];
2283 [label="return '--'; 2284"];
2284 [label="FullWidth = this.Text.Length; 2285"];
2285 [label="FullWidth 2286"];
2286 [label="this.AdjustFlagsAndWidth(trailing); 2287"];
2287 [label="return '--'; 2288"];
2288 [label="FullWidth = this.Text.Length; 2289"];
2289 [label="FullWidth 2290"];
2290 [label="this.AdjustFlagsAndWidth(trailing); 2291"];
2291 [label="return '++'; 2292"];
2292 [label="FullWidth = this.Text.Length; 2293"];
2293 [label="FullWidth 2294"];
2294 [label="return '++'; 2295"];
2295 [label="FullWidth = this.Text.Length; 2296"];
2296 [label="FullWidth 2297"];
2297 [label="this.AdjustFlagsAndWidth(leading); 2298"];
2298 [label="return '++'; 2299"];
2299 [label="FullWidth = this.Text.Length; 2300"];
2300 [label="FullWidth 2301"];
2301 [label="this.AdjustFlagsAndWidth(trailing); 2302"];
2302 [label="return '++'; 2303"];
2303 [label="FullWidth = this.Text.Length; 2304"];
2304 [label="FullWidth 2305"];
2305 [label="this.AdjustFlagsAndWidth(trailing); 2306"];
2306 [label="return '::'; 2307"];
2307 [label="FullWidth = this.Text.Length; 2308"];
2308 [label="FullWidth 2309"];
2309 [label="return '::'; 2310"];
2310 [label="FullWidth = this.Text.Length; 2311"];
2311 [label="FullWidth 2312"];
2312 [label="this.AdjustFlagsAndWidth(leading); 2313"];
2313 [label="return '::'; 2314"];
2314 [label="FullWidth = this.Text.Length; 2315"];
2315 [label="FullWidth 2316"];
2316 [label="this.AdjustFlagsAndWidth(trailing); 2317"];
2317 [label="return '::'; 2318"];
2318 [label="FullWidth = this.Text.Length; 2319"];
2319 [label="FullWidth 2320"];
2320 [label="this.AdjustFlagsAndWidth(trailing); 2321"];
2321 [label="return '??'; 2322"];
2322 [label="FullWidth = this.Text.Length; 2323"];
2323 [label="FullWidth 2324"];
2324 [label="return '??'; 2325"];
2325 [label="FullWidth = this.Text.Length; 2326"];
2326 [label="FullWidth 2327"];
2327 [label="this.AdjustFlagsAndWidth(leading); 2328"];
2328 [label="return '??'; 2329"];
2329 [label="FullWidth = this.Text.Length; 2330"];
2330 [label="FullWidth 2331"];
2331 [label="this.AdjustFlagsAndWidth(trailing); 2332"];
2332 [label="return '??'; 2333"];
2333 [label="FullWidth = this.Text.Length; 2334"];
2334 [label="FullWidth 2335"];
2335 [label="this.AdjustFlagsAndWidth(trailing); 2336"];
2336 [label="return '->'; 2337"];
2337 [label="FullWidth = this.Text.Length; 2338"];
2338 [label="FullWidth 2339"];
2339 [label="return '->'; 2340"];
2340 [label="FullWidth = this.Text.Length; 2341"];
2341 [label="FullWidth 2342"];
2342 [label="this.AdjustFlagsAndWidth(leading); 2343"];
2343 [label="return '->'; 2344"];
2344 [label="FullWidth = this.Text.Length; 2345"];
2345 [label="FullWidth 2346"];
2346 [label="this.AdjustFlagsAndWidth(trailing); 2347"];
2347 [label="return '->'; 2348"];
2348 [label="FullWidth = this.Text.Length; 2349"];
2349 [label="FullWidth 2350"];
2350 [label="this.AdjustFlagsAndWidth(trailing); 2351"];
2351 [label="return '!='; 2352"];
2352 [label="FullWidth = this.Text.Length; 2353"];
2353 [label="FullWidth 2354"];
2354 [label="return '!='; 2355"];
2355 [label="FullWidth = this.Text.Length; 2356"];
2356 [label="FullWidth 2357"];
2357 [label="this.AdjustFlagsAndWidth(leading); 2358"];
2358 [label="return '!='; 2359"];
2359 [label="FullWidth = this.Text.Length; 2360"];
2360 [label="FullWidth 2361"];
2361 [label="this.AdjustFlagsAndWidth(trailing); 2362"];
2362 [label="return '!='; 2363"];
2363 [label="FullWidth = this.Text.Length; 2364"];
2364 [label="FullWidth 2365"];
2365 [label="this.AdjustFlagsAndWidth(trailing); 2366"];
2366 [label="return '=='; 2367"];
2367 [label="FullWidth = this.Text.Length; 2368"];
2368 [label="FullWidth 2369"];
2369 [label="return '=='; 2370"];
2370 [label="FullWidth = this.Text.Length; 2371"];
2371 [label="FullWidth 2372"];
2372 [label="this.AdjustFlagsAndWidth(leading); 2373"];
2373 [label="return '=='; 2374"];
2374 [label="FullWidth = this.Text.Length; 2375"];
2375 [label="FullWidth 2376"];
2376 [label="this.AdjustFlagsAndWidth(trailing); 2377"];
2377 [label="return '=='; 2378"];
2378 [label="FullWidth = this.Text.Length; 2379"];
2379 [label="FullWidth 2380"];
2380 [label="this.AdjustFlagsAndWidth(trailing); 2381"];
2381 [label="return '=>'; 2382"];
2382 [label="FullWidth = this.Text.Length; 2383"];
2383 [label="FullWidth 2384"];
2384 [label="return '=>'; 2385"];
2385 [label="FullWidth = this.Text.Length; 2386"];
2386 [label="FullWidth 2387"];
2387 [label="this.AdjustFlagsAndWidth(leading); 2388"];
2388 [label="return '=>'; 2389"];
2389 [label="FullWidth = this.Text.Length; 2390"];
2390 [label="FullWidth 2391"];
2391 [label="this.AdjustFlagsAndWidth(trailing); 2392"];
2392 [label="return '=>'; 2393"];
2393 [label="FullWidth = this.Text.Length; 2394"];
2394 [label="FullWidth 2395"];
2395 [label="this.AdjustFlagsAndWidth(trailing); 2396"];
2396 [label="return '<='; 2397"];
2397 [label="FullWidth = this.Text.Length; 2398"];
2398 [label="FullWidth 2399"];
2399 [label="return '<='; 2400"];
2400 [label="FullWidth = this.Text.Length; 2401"];
2401 [label="FullWidth 2402"];
2402 [label="this.AdjustFlagsAndWidth(leading); 2403"];
2403 [label="return '<='; 2404"];
2404 [label="FullWidth = this.Text.Length; 2405"];
2405 [label="FullWidth 2406"];
2406 [label="this.AdjustFlagsAndWidth(trailing); 2407"];
2407 [label="return '<='; 2408"];
2408 [label="FullWidth = this.Text.Length; 2409"];
2409 [label="FullWidth 2410"];
2410 [label="this.AdjustFlagsAndWidth(trailing); 2411"];
2411 [label="return '<<'; 2412"];
2412 [label="FullWidth = this.Text.Length; 2413"];
2413 [label="FullWidth 2414"];
2414 [label="return '<<'; 2415"];
2415 [label="FullWidth = this.Text.Length; 2416"];
2416 [label="FullWidth 2417"];
2417 [label="this.AdjustFlagsAndWidth(leading); 2418"];
2418 [label="return '<<'; 2419"];
2419 [label="FullWidth = this.Text.Length; 2420"];
2420 [label="FullWidth 2421"];
2421 [label="this.AdjustFlagsAndWidth(trailing); 2422"];
2422 [label="return '<<'; 2423"];
2423 [label="FullWidth = this.Text.Length; 2424"];
2424 [label="FullWidth 2425"];
2425 [label="this.AdjustFlagsAndWidth(trailing); 2426"];
2426 [label="return '<<='; 2427"];
2427 [label="FullWidth = this.Text.Length; 2428"];
2428 [label="FullWidth 2429"];
2429 [label="return '<<='; 2430"];
2430 [label="FullWidth = this.Text.Length; 2431"];
2431 [label="FullWidth 2432"];
2432 [label="this.AdjustFlagsAndWidth(leading); 2433"];
2433 [label="return '<<='; 2434"];
2434 [label="FullWidth = this.Text.Length; 2435"];
2435 [label="FullWidth 2436"];
2436 [label="this.AdjustFlagsAndWidth(trailing); 2437"];
2437 [label="return '<<='; 2438"];
2438 [label="FullWidth = this.Text.Length; 2439"];
2439 [label="FullWidth 2440"];
2440 [label="this.AdjustFlagsAndWidth(trailing); 2441"];
2441 [label="return '>='; 2442"];
2442 [label="FullWidth = this.Text.Length; 2443"];
2443 [label="FullWidth 2444"];
2444 [label="return '>='; 2445"];
2445 [label="FullWidth = this.Text.Length; 2446"];
2446 [label="FullWidth 2447"];
2447 [label="this.AdjustFlagsAndWidth(leading); 2448"];
2448 [label="return '>='; 2449"];
2449 [label="FullWidth = this.Text.Length; 2450"];
2450 [label="FullWidth 2451"];
2451 [label="this.AdjustFlagsAndWidth(trailing); 2452"];
2452 [label="return '>='; 2453"];
2453 [label="FullWidth = this.Text.Length; 2454"];
2454 [label="FullWidth 2455"];
2455 [label="this.AdjustFlagsAndWidth(trailing); 2456"];
2456 [label="return '>>'; 2457"];
2457 [label="FullWidth = this.Text.Length; 2458"];
2458 [label="FullWidth 2459"];
2459 [label="return '>>'; 2460"];
2460 [label="FullWidth = this.Text.Length; 2461"];
2461 [label="FullWidth 2462"];
2462 [label="this.AdjustFlagsAndWidth(leading); 2463"];
2463 [label="return '>>'; 2464"];
2464 [label="FullWidth = this.Text.Length; 2465"];
2465 [label="FullWidth 2466"];
2466 [label="this.AdjustFlagsAndWidth(trailing); 2467"];
2467 [label="return '>>'; 2468"];
2468 [label="FullWidth = this.Text.Length; 2469"];
2469 [label="FullWidth 2470"];
2470 [label="this.AdjustFlagsAndWidth(trailing); 2471"];
2471 [label="return '>>='; 2472"];
2472 [label="FullWidth = this.Text.Length; 2473"];
2473 [label="FullWidth 2474"];
2474 [label="return '>>='; 2475"];
2475 [label="FullWidth = this.Text.Length; 2476"];
2476 [label="FullWidth 2477"];
2477 [label="this.AdjustFlagsAndWidth(leading); 2478"];
2478 [label="return '>>='; 2479"];
2479 [label="FullWidth = this.Text.Length; 2480"];
2480 [label="FullWidth 2481"];
2481 [label="this.AdjustFlagsAndWidth(trailing); 2482"];
2482 [label="return '>>='; 2483"];
2483 [label="FullWidth = this.Text.Length; 2484"];
2484 [label="FullWidth 2485"];
2485 [label="this.AdjustFlagsAndWidth(trailing); 2486"];
2486 [label="return '/='; 2487"];
2487 [label="FullWidth = this.Text.Length; 2488"];
2488 [label="FullWidth 2489"];
2489 [label="return '/='; 2490"];
2490 [label="FullWidth = this.Text.Length; 2491"];
2491 [label="FullWidth 2492"];
2492 [label="this.AdjustFlagsAndWidth(leading); 2493"];
2493 [label="return '/='; 2494"];
2494 [label="FullWidth = this.Text.Length; 2495"];
2495 [label="FullWidth 2496"];
2496 [label="this.AdjustFlagsAndWidth(trailing); 2497"];
2497 [label="return '/='; 2498"];
2498 [label="FullWidth = this.Text.Length; 2499"];
2499 [label="FullWidth 2500"];
2500 [label="this.AdjustFlagsAndWidth(trailing); 2501"];
2501 [label="return '*='; 2502"];
2502 [label="FullWidth = this.Text.Length; 2503"];
2503 [label="FullWidth 2504"];
2504 [label="return '*='; 2505"];
2505 [label="FullWidth = this.Text.Length; 2506"];
2506 [label="FullWidth 2507"];
2507 [label="this.AdjustFlagsAndWidth(leading); 2508"];
2508 [label="return '*='; 2509"];
2509 [label="FullWidth = this.Text.Length; 2510"];
2510 [label="FullWidth 2511"];
2511 [label="this.AdjustFlagsAndWidth(trailing); 2512"];
2512 [label="return '*='; 2513"];
2513 [label="FullWidth = this.Text.Length; 2514"];
2514 [label="FullWidth 2515"];
2515 [label="this.AdjustFlagsAndWidth(trailing); 2516"];
2516 [label="return '|='; 2517"];
2517 [label="FullWidth = this.Text.Length; 2518"];
2518 [label="FullWidth 2519"];
2519 [label="return '|='; 2520"];
2520 [label="FullWidth = this.Text.Length; 2521"];
2521 [label="FullWidth 2522"];
2522 [label="this.AdjustFlagsAndWidth(leading); 2523"];
2523 [label="return '|='; 2524"];
2524 [label="FullWidth = this.Text.Length; 2525"];
2525 [label="FullWidth 2526"];
2526 [label="this.AdjustFlagsAndWidth(trailing); 2527"];
2527 [label="return '|='; 2528"];
2528 [label="FullWidth = this.Text.Length; 2529"];
2529 [label="FullWidth 2530"];
2530 [label="this.AdjustFlagsAndWidth(trailing); 2531"];
2531 [label="return '&='; 2532"];
2532 [label="FullWidth = this.Text.Length; 2533"];
2533 [label="FullWidth 2534"];
2534 [label="return '&='; 2535"];
2535 [label="FullWidth = this.Text.Length; 2536"];
2536 [label="FullWidth 2537"];
2537 [label="this.AdjustFlagsAndWidth(leading); 2538"];
2538 [label="return '&='; 2539"];
2539 [label="FullWidth = this.Text.Length; 2540"];
2540 [label="FullWidth 2541"];
2541 [label="this.AdjustFlagsAndWidth(trailing); 2542"];
2542 [label="return '&='; 2543"];
2543 [label="FullWidth = this.Text.Length; 2544"];
2544 [label="FullWidth 2545"];
2545 [label="this.AdjustFlagsAndWidth(trailing); 2546"];
2546 [label="return '+='; 2547"];
2547 [label="FullWidth = this.Text.Length; 2548"];
2548 [label="FullWidth 2549"];
2549 [label="return '+='; 2550"];
2550 [label="FullWidth = this.Text.Length; 2551"];
2551 [label="FullWidth 2552"];
2552 [label="this.AdjustFlagsAndWidth(leading); 2553"];
2553 [label="return '+='; 2554"];
2554 [label="FullWidth = this.Text.Length; 2555"];
2555 [label="FullWidth 2556"];
2556 [label="this.AdjustFlagsAndWidth(trailing); 2557"];
2557 [label="return '+='; 2558"];
2558 [label="FullWidth = this.Text.Length; 2559"];
2559 [label="FullWidth 2560"];
2560 [label="this.AdjustFlagsAndWidth(trailing); 2561"];
2561 [label="return '-='; 2562"];
2562 [label="FullWidth = this.Text.Length; 2563"];
2563 [label="FullWidth 2564"];
2564 [label="return '-='; 2565"];
2565 [label="FullWidth = this.Text.Length; 2566"];
2566 [label="FullWidth 2567"];
2567 [label="this.AdjustFlagsAndWidth(leading); 2568"];
2568 [label="return '-='; 2569"];
2569 [label="FullWidth = this.Text.Length; 2570"];
2570 [label="FullWidth 2571"];
2571 [label="this.AdjustFlagsAndWidth(trailing); 2572"];
2572 [label="return '-='; 2573"];
2573 [label="FullWidth = this.Text.Length; 2574"];
2574 [label="FullWidth 2575"];
2575 [label="this.AdjustFlagsAndWidth(trailing); 2576"];
2576 [label="return '^='; 2577"];
2577 [label="FullWidth = this.Text.Length; 2578"];
2578 [label="FullWidth 2579"];
2579 [label="return '^='; 2580"];
2580 [label="FullWidth = this.Text.Length; 2581"];
2581 [label="FullWidth 2582"];
2582 [label="this.AdjustFlagsAndWidth(leading); 2583"];
2583 [label="return '^='; 2584"];
2584 [label="FullWidth = this.Text.Length; 2585"];
2585 [label="FullWidth 2586"];
2586 [label="this.AdjustFlagsAndWidth(trailing); 2587"];
2587 [label="return '^='; 2588"];
2588 [label="FullWidth = this.Text.Length; 2589"];
2589 [label="FullWidth 2590"];
2590 [label="this.AdjustFlagsAndWidth(trailing); 2591"];
2591 [label="return '%='; 2592"];
2592 [label="FullWidth = this.Text.Length; 2593"];
2593 [label="FullWidth 2594"];
2594 [label="return '%='; 2595"];
2595 [label="FullWidth = this.Text.Length; 2596"];
2596 [label="FullWidth 2597"];
2597 [label="this.AdjustFlagsAndWidth(leading); 2598"];
2598 [label="return '%='; 2599"];
2599 [label="FullWidth = this.Text.Length; 2600"];
2600 [label="FullWidth 2601"];
2601 [label="this.AdjustFlagsAndWidth(trailing); 2602"];
2602 [label="return '%='; 2603"];
2603 [label="FullWidth = this.Text.Length; 2604"];
2604 [label="FullWidth 2605"];
2605 [label="this.AdjustFlagsAndWidth(trailing); 2606"];
2606 [label="return '??='; 2607"];
2607 [label="FullWidth = this.Text.Length; 2608"];
2608 [label="FullWidth 2609"];
2609 [label="return '??='; 2610"];
2610 [label="FullWidth = this.Text.Length; 2611"];
2611 [label="FullWidth 2612"];
2612 [label="this.AdjustFlagsAndWidth(leading); 2613"];
2613 [label="return '??='; 2614"];
2614 [label="FullWidth = this.Text.Length; 2615"];
2615 [label="FullWidth 2616"];
2616 [label="this.AdjustFlagsAndWidth(trailing); 2617"];
2617 [label="return '??='; 2618"];
2618 [label="FullWidth = this.Text.Length; 2619"];
2619 [label="FullWidth 2620"];
2620 [label="this.AdjustFlagsAndWidth(trailing); 2621"];
2621 [label="return 'bool'; 2622"];
2622 [label="FullWidth = this.Text.Length; 2623"];
2623 [label="FullWidth 2624"];
2624 [label="return 'bool'; 2625"];
2625 [label="FullWidth = this.Text.Length; 2626"];
2626 [label="FullWidth 2627"];
2627 [label="this.AdjustFlagsAndWidth(leading); 2628"];
2628 [label="return 'bool'; 2629"];
2629 [label="FullWidth = this.Text.Length; 2630"];
2630 [label="FullWidth 2631"];
2631 [label="this.AdjustFlagsAndWidth(trailing); 2632"];
2632 [label="return 'bool'; 2633"];
2633 [label="FullWidth = this.Text.Length; 2634"];
2634 [label="FullWidth 2635"];
2635 [label="this.AdjustFlagsAndWidth(trailing); 2636"];
2636 [label="return 'byte'; 2637"];
2637 [label="FullWidth = this.Text.Length; 2638"];
2638 [label="FullWidth 2639"];
2639 [label="return 'byte'; 2640"];
2640 [label="FullWidth = this.Text.Length; 2641"];
2641 [label="FullWidth 2642"];
2642 [label="this.AdjustFlagsAndWidth(leading); 2643"];
2643 [label="return 'byte'; 2644"];
2644 [label="FullWidth = this.Text.Length; 2645"];
2645 [label="FullWidth 2646"];
2646 [label="this.AdjustFlagsAndWidth(trailing); 2647"];
2647 [label="return 'byte'; 2648"];
2648 [label="FullWidth = this.Text.Length; 2649"];
2649 [label="FullWidth 2650"];
2650 [label="this.AdjustFlagsAndWidth(trailing); 2651"];
2651 [label="return 'sbyte'; 2652"];
2652 [label="FullWidth = this.Text.Length; 2653"];
2653 [label="FullWidth 2654"];
2654 [label="return 'sbyte'; 2655"];
2655 [label="FullWidth = this.Text.Length; 2656"];
2656 [label="FullWidth 2657"];
2657 [label="this.AdjustFlagsAndWidth(leading); 2658"];
2658 [label="return 'sbyte'; 2659"];
2659 [label="FullWidth = this.Text.Length; 2660"];
2660 [label="FullWidth 2661"];
2661 [label="this.AdjustFlagsAndWidth(trailing); 2662"];
2662 [label="return 'sbyte'; 2663"];
2663 [label="FullWidth = this.Text.Length; 2664"];
2664 [label="FullWidth 2665"];
2665 [label="this.AdjustFlagsAndWidth(trailing); 2666"];
2666 [label="return 'short'; 2667"];
2667 [label="FullWidth = this.Text.Length; 2668"];
2668 [label="FullWidth 2669"];
2669 [label="return 'short'; 2670"];
2670 [label="FullWidth = this.Text.Length; 2671"];
2671 [label="FullWidth 2672"];
2672 [label="this.AdjustFlagsAndWidth(leading); 2673"];
2673 [label="return 'short'; 2674"];
2674 [label="FullWidth = this.Text.Length; 2675"];
2675 [label="FullWidth 2676"];
2676 [label="this.AdjustFlagsAndWidth(trailing); 2677"];
2677 [label="return 'short'; 2678"];
2678 [label="FullWidth = this.Text.Length; 2679"];
2679 [label="FullWidth 2680"];
2680 [label="this.AdjustFlagsAndWidth(trailing); 2681"];
2681 [label="return 'ushort'; 2682"];
2682 [label="FullWidth = this.Text.Length; 2683"];
2683 [label="FullWidth 2684"];
2684 [label="return 'ushort'; 2685"];
2685 [label="FullWidth = this.Text.Length; 2686"];
2686 [label="FullWidth 2687"];
2687 [label="this.AdjustFlagsAndWidth(leading); 2688"];
2688 [label="return 'ushort'; 2689"];
2689 [label="FullWidth = this.Text.Length; 2690"];
2690 [label="FullWidth 2691"];
2691 [label="this.AdjustFlagsAndWidth(trailing); 2692"];
2692 [label="return 'ushort'; 2693"];
2693 [label="FullWidth = this.Text.Length; 2694"];
2694 [label="FullWidth 2695"];
2695 [label="this.AdjustFlagsAndWidth(trailing); 2696"];
2696 [label="return 'int'; 2697"];
2697 [label="FullWidth = this.Text.Length; 2698"];
2698 [label="FullWidth 2699"];
2699 [label="return 'int'; 2700"];
2700 [label="FullWidth = this.Text.Length; 2701"];
2701 [label="FullWidth 2702"];
2702 [label="this.AdjustFlagsAndWidth(leading); 2703"];
2703 [label="return 'int'; 2704"];
2704 [label="FullWidth = this.Text.Length; 2705"];
2705 [label="FullWidth 2706"];
2706 [label="this.AdjustFlagsAndWidth(trailing); 2707"];
2707 [label="return 'int'; 2708"];
2708 [label="FullWidth = this.Text.Length; 2709"];
2709 [label="FullWidth 2710"];
2710 [label="this.AdjustFlagsAndWidth(trailing); 2711"];
2711 [label="return 'uint'; 2712"];
2712 [label="FullWidth = this.Text.Length; 2713"];
2713 [label="FullWidth 2714"];
2714 [label="return 'uint'; 2715"];
2715 [label="FullWidth = this.Text.Length; 2716"];
2716 [label="FullWidth 2717"];
2717 [label="this.AdjustFlagsAndWidth(leading); 2718"];
2718 [label="return 'uint'; 2719"];
2719 [label="FullWidth = this.Text.Length; 2720"];
2720 [label="FullWidth 2721"];
2721 [label="this.AdjustFlagsAndWidth(trailing); 2722"];
2722 [label="return 'uint'; 2723"];
2723 [label="FullWidth = this.Text.Length; 2724"];
2724 [label="FullWidth 2725"];
2725 [label="this.AdjustFlagsAndWidth(trailing); 2726"];
2726 [label="return 'long'; 2727"];
2727 [label="FullWidth = this.Text.Length; 2728"];
2728 [label="FullWidth 2729"];
2729 [label="return 'long'; 2730"];
2730 [label="FullWidth = this.Text.Length; 2731"];
2731 [label="FullWidth 2732"];
2732 [label="this.AdjustFlagsAndWidth(leading); 2733"];
2733 [label="return 'long'; 2734"];
2734 [label="FullWidth = this.Text.Length; 2735"];
2735 [label="FullWidth 2736"];
2736 [label="this.AdjustFlagsAndWidth(trailing); 2737"];
2737 [label="return 'long'; 2738"];
2738 [label="FullWidth = this.Text.Length; 2739"];
2739 [label="FullWidth 2740"];
2740 [label="this.AdjustFlagsAndWidth(trailing); 2741"];
2741 [label="return 'ulong'; 2742"];
2742 [label="FullWidth = this.Text.Length; 2743"];
2743 [label="FullWidth 2744"];
2744 [label="return 'ulong'; 2745"];
2745 [label="FullWidth = this.Text.Length; 2746"];
2746 [label="FullWidth 2747"];
2747 [label="this.AdjustFlagsAndWidth(leading); 2748"];
2748 [label="return 'ulong'; 2749"];
2749 [label="FullWidth = this.Text.Length; 2750"];
2750 [label="FullWidth 2751"];
2751 [label="this.AdjustFlagsAndWidth(trailing); 2752"];
2752 [label="return 'ulong'; 2753"];
2753 [label="FullWidth = this.Text.Length; 2754"];
2754 [label="FullWidth 2755"];
2755 [label="this.AdjustFlagsAndWidth(trailing); 2756"];
2756 [label="return 'double'; 2757"];
2757 [label="FullWidth = this.Text.Length; 2758"];
2758 [label="FullWidth 2759"];
2759 [label="return 'double'; 2760"];
2760 [label="FullWidth = this.Text.Length; 2761"];
2761 [label="FullWidth 2762"];
2762 [label="this.AdjustFlagsAndWidth(leading); 2763"];
2763 [label="return 'double'; 2764"];
2764 [label="FullWidth = this.Text.Length; 2765"];
2765 [label="FullWidth 2766"];
2766 [label="this.AdjustFlagsAndWidth(trailing); 2767"];
2767 [label="return 'double'; 2768"];
2768 [label="FullWidth = this.Text.Length; 2769"];
2769 [label="FullWidth 2770"];
2770 [label="this.AdjustFlagsAndWidth(trailing); 2771"];
2771 [label="return 'float'; 2772"];
2772 [label="FullWidth = this.Text.Length; 2773"];
2773 [label="FullWidth 2774"];
2774 [label="return 'float'; 2775"];
2775 [label="FullWidth = this.Text.Length; 2776"];
2776 [label="FullWidth 2777"];
2777 [label="this.AdjustFlagsAndWidth(leading); 2778"];
2778 [label="return 'float'; 2779"];
2779 [label="FullWidth = this.Text.Length; 2780"];
2780 [label="FullWidth 2781"];
2781 [label="this.AdjustFlagsAndWidth(trailing); 2782"];
2782 [label="return 'float'; 2783"];
2783 [label="FullWidth = this.Text.Length; 2784"];
2784 [label="FullWidth 2785"];
2785 [label="this.AdjustFlagsAndWidth(trailing); 2786"];
2786 [label="return 'decimal'; 2787"];
2787 [label="FullWidth = this.Text.Length; 2788"];
2788 [label="FullWidth 2789"];
2789 [label="return 'decimal'; 2790"];
2790 [label="FullWidth = this.Text.Length; 2791"];
2791 [label="FullWidth 2792"];
2792 [label="this.AdjustFlagsAndWidth(leading); 2793"];
2793 [label="return 'decimal'; 2794"];
2794 [label="FullWidth = this.Text.Length; 2795"];
2795 [label="FullWidth 2796"];
2796 [label="this.AdjustFlagsAndWidth(trailing); 2797"];
2797 [label="return 'decimal'; 2798"];
2798 [label="FullWidth = this.Text.Length; 2799"];
2799 [label="FullWidth 2800"];
2800 [label="this.AdjustFlagsAndWidth(trailing); 2801"];
2801 [label="return 'string'; 2802"];
2802 [label="FullWidth = this.Text.Length; 2803"];
2803 [label="FullWidth 2804"];
2804 [label="return 'string'; 2805"];
2805 [label="FullWidth = this.Text.Length; 2806"];
2806 [label="FullWidth 2807"];
2807 [label="this.AdjustFlagsAndWidth(leading); 2808"];
2808 [label="return 'string'; 2809"];
2809 [label="FullWidth = this.Text.Length; 2810"];
2810 [label="FullWidth 2811"];
2811 [label="this.AdjustFlagsAndWidth(trailing); 2812"];
2812 [label="return 'string'; 2813"];
2813 [label="FullWidth = this.Text.Length; 2814"];
2814 [label="FullWidth 2815"];
2815 [label="this.AdjustFlagsAndWidth(trailing); 2816"];
2816 [label="return 'char'; 2817"];
2817 [label="FullWidth = this.Text.Length; 2818"];
2818 [label="FullWidth 2819"];
2819 [label="return 'char'; 2820"];
2820 [label="FullWidth = this.Text.Length; 2821"];
2821 [label="FullWidth 2822"];
2822 [label="this.AdjustFlagsAndWidth(leading); 2823"];
2823 [label="return 'char'; 2824"];
2824 [label="FullWidth = this.Text.Length; 2825"];
2825 [label="FullWidth 2826"];
2826 [label="this.AdjustFlagsAndWidth(trailing); 2827"];
2827 [label="return 'char'; 2828"];
2828 [label="FullWidth = this.Text.Length; 2829"];
2829 [label="FullWidth 2830"];
2830 [label="this.AdjustFlagsAndWidth(trailing); 2831"];
2831 [label="return 'void'; 2832"];
2832 [label="FullWidth = this.Text.Length; 2833"];
2833 [label="FullWidth 2834"];
2834 [label="return 'void'; 2835"];
2835 [label="FullWidth = this.Text.Length; 2836"];
2836 [label="FullWidth 2837"];
2837 [label="this.AdjustFlagsAndWidth(leading); 2838"];
2838 [label="return 'void'; 2839"];
2839 [label="FullWidth = this.Text.Length; 2840"];
2840 [label="FullWidth 2841"];
2841 [label="this.AdjustFlagsAndWidth(trailing); 2842"];
2842 [label="return 'void'; 2843"];
2843 [label="FullWidth = this.Text.Length; 2844"];
2844 [label="FullWidth 2845"];
2845 [label="this.AdjustFlagsAndWidth(trailing); 2846"];
2846 [label="return 'object'; 2847"];
2847 [label="FullWidth = this.Text.Length; 2848"];
2848 [label="FullWidth 2849"];
2849 [label="return 'object'; 2850"];
2850 [label="FullWidth = this.Text.Length; 2851"];
2851 [label="FullWidth 2852"];
2852 [label="this.AdjustFlagsAndWidth(leading); 2853"];
2853 [label="return 'object'; 2854"];
2854 [label="FullWidth = this.Text.Length; 2855"];
2855 [label="FullWidth 2856"];
2856 [label="this.AdjustFlagsAndWidth(trailing); 2857"];
2857 [label="return 'object'; 2858"];
2858 [label="FullWidth = this.Text.Length; 2859"];
2859 [label="FullWidth 2860"];
2860 [label="this.AdjustFlagsAndWidth(trailing); 2861"];
2861 [label="return 'typeof'; 2862"];
2862 [label="FullWidth = this.Text.Length; 2863"];
2863 [label="FullWidth 2864"];
2864 [label="return 'typeof'; 2865"];
2865 [label="FullWidth = this.Text.Length; 2866"];
2866 [label="FullWidth 2867"];
2867 [label="this.AdjustFlagsAndWidth(leading); 2868"];
2868 [label="return 'typeof'; 2869"];
2869 [label="FullWidth = this.Text.Length; 2870"];
2870 [label="FullWidth 2871"];
2871 [label="this.AdjustFlagsAndWidth(trailing); 2872"];
2872 [label="return 'typeof'; 2873"];
2873 [label="FullWidth = this.Text.Length; 2874"];
2874 [label="FullWidth 2875"];
2875 [label="this.AdjustFlagsAndWidth(trailing); 2876"];
2876 [label="return 'sizeof'; 2877"];
2877 [label="FullWidth = this.Text.Length; 2878"];
2878 [label="FullWidth 2879"];
2879 [label="return 'sizeof'; 2880"];
2880 [label="FullWidth = this.Text.Length; 2881"];
2881 [label="FullWidth 2882"];
2882 [label="this.AdjustFlagsAndWidth(leading); 2883"];
2883 [label="return 'sizeof'; 2884"];
2884 [label="FullWidth = this.Text.Length; 2885"];
2885 [label="FullWidth 2886"];
2886 [label="this.AdjustFlagsAndWidth(trailing); 2887"];
2887 [label="return 'sizeof'; 2888"];
2888 [label="FullWidth = this.Text.Length; 2889"];
2889 [label="FullWidth 2890"];
2890 [label="this.AdjustFlagsAndWidth(trailing); 2891"];
2891 [label="return 'null'; 2892"];
2892 [label="FullWidth = this.Text.Length; 2893"];
2893 [label="FullWidth 2894"];
2894 [label="return 'null'; 2895"];
2895 [label="FullWidth = this.Text.Length; 2896"];
2896 [label="FullWidth 2897"];
2897 [label="this.AdjustFlagsAndWidth(leading); 2898"];
2898 [label="return 'null'; 2899"];
2899 [label="FullWidth = this.Text.Length; 2900"];
2900 [label="FullWidth 2901"];
2901 [label="this.AdjustFlagsAndWidth(trailing); 2902"];
2902 [label="return 'null'; 2903"];
2903 [label="FullWidth = this.Text.Length; 2904"];
2904 [label="FullWidth 2905"];
2905 [label="this.AdjustFlagsAndWidth(trailing); 2906"];
2906 [label="return 'true'; 2907"];
2907 [label="FullWidth = this.Text.Length; 2908"];
2908 [label="FullWidth 2909"];
2909 [label="return 'true'; 2910"];
2910 [label="FullWidth = this.Text.Length; 2911"];
2911 [label="FullWidth 2912"];
2912 [label="this.AdjustFlagsAndWidth(leading); 2913"];
2913 [label="return 'true'; 2914"];
2914 [label="FullWidth = this.Text.Length; 2915"];
2915 [label="FullWidth 2916"];
2916 [label="this.AdjustFlagsAndWidth(trailing); 2917"];
2917 [label="return 'true'; 2918"];
2918 [label="FullWidth = this.Text.Length; 2919"];
2919 [label="FullWidth 2920"];
2920 [label="this.AdjustFlagsAndWidth(trailing); 2921"];
2921 [label="return 'false'; 2922"];
2922 [label="FullWidth = this.Text.Length; 2923"];
2923 [label="FullWidth 2924"];
2924 [label="return 'false'; 2925"];
2925 [label="FullWidth = this.Text.Length; 2926"];
2926 [label="FullWidth 2927"];
2927 [label="this.AdjustFlagsAndWidth(leading); 2928"];
2928 [label="return 'false'; 2929"];
2929 [label="FullWidth = this.Text.Length; 2930"];
2930 [label="FullWidth 2931"];
2931 [label="this.AdjustFlagsAndWidth(trailing); 2932"];
2932 [label="return 'false'; 2933"];
2933 [label="FullWidth = this.Text.Length; 2934"];
2934 [label="FullWidth 2935"];
2935 [label="this.AdjustFlagsAndWidth(trailing); 2936"];
2936 [label="return 'if'; 2937"];
2937 [label="FullWidth = this.Text.Length; 2938"];
2938 [label="FullWidth 2939"];
2939 [label="return 'if'; 2940"];
2940 [label="FullWidth = this.Text.Length; 2941"];
2941 [label="FullWidth 2942"];
2942 [label="this.AdjustFlagsAndWidth(leading); 2943"];
2943 [label="return 'if'; 2944"];
2944 [label="FullWidth = this.Text.Length; 2945"];
2945 [label="FullWidth 2946"];
2946 [label="this.AdjustFlagsAndWidth(trailing); 2947"];
2947 [label="return 'if'; 2948"];
2948 [label="FullWidth = this.Text.Length; 2949"];
2949 [label="FullWidth 2950"];
2950 [label="this.AdjustFlagsAndWidth(trailing); 2951"];
2951 [label="return 'else'; 2952"];
2952 [label="FullWidth = this.Text.Length; 2953"];
2953 [label="FullWidth 2954"];
2954 [label="return 'else'; 2955"];
2955 [label="FullWidth = this.Text.Length; 2956"];
2956 [label="FullWidth 2957"];
2957 [label="this.AdjustFlagsAndWidth(leading); 2958"];
2958 [label="return 'else'; 2959"];
2959 [label="FullWidth = this.Text.Length; 2960"];
2960 [label="FullWidth 2961"];
2961 [label="this.AdjustFlagsAndWidth(trailing); 2962"];
2962 [label="return 'else'; 2963"];
2963 [label="FullWidth = this.Text.Length; 2964"];
2964 [label="FullWidth 2965"];
2965 [label="this.AdjustFlagsAndWidth(trailing); 2966"];
2966 [label="return 'while'; 2967"];
2967 [label="FullWidth = this.Text.Length; 2968"];
2968 [label="FullWidth 2969"];
2969 [label="return 'while'; 2970"];
2970 [label="FullWidth = this.Text.Length; 2971"];
2971 [label="FullWidth 2972"];
2972 [label="this.AdjustFlagsAndWidth(leading); 2973"];
2973 [label="return 'while'; 2974"];
2974 [label="FullWidth = this.Text.Length; 2975"];
2975 [label="FullWidth 2976"];
2976 [label="this.AdjustFlagsAndWidth(trailing); 2977"];
2977 [label="return 'while'; 2978"];
2978 [label="FullWidth = this.Text.Length; 2979"];
2979 [label="FullWidth 2980"];
2980 [label="this.AdjustFlagsAndWidth(trailing); 2981"];
2981 [label="return 'for'; 2982"];
2982 [label="FullWidth = this.Text.Length; 2983"];
2983 [label="FullWidth 2984"];
2984 [label="return 'for'; 2985"];
2985 [label="FullWidth = this.Text.Length; 2986"];
2986 [label="FullWidth 2987"];
2987 [label="this.AdjustFlagsAndWidth(leading); 2988"];
2988 [label="return 'for'; 2989"];
2989 [label="FullWidth = this.Text.Length; 2990"];
2990 [label="FullWidth 2991"];
2991 [label="this.AdjustFlagsAndWidth(trailing); 2992"];
2992 [label="return 'for'; 2993"];
2993 [label="FullWidth = this.Text.Length; 2994"];
2994 [label="FullWidth 2995"];
2995 [label="this.AdjustFlagsAndWidth(trailing); 2996"];
2996 [label="return 'foreach'; 2997"];
2997 [label="FullWidth = this.Text.Length; 2998"];
2998 [label="FullWidth 2999"];
2999 [label="return 'foreach'; 3000"];
3000 [label="FullWidth = this.Text.Length; 3001"];
3001 [label="FullWidth 3002"];
3002 [label="this.AdjustFlagsAndWidth(leading); 3003"];
3003 [label="return 'foreach'; 3004"];
3004 [label="FullWidth = this.Text.Length; 3005"];
3005 [label="FullWidth 3006"];
3006 [label="this.AdjustFlagsAndWidth(trailing); 3007"];
3007 [label="return 'foreach'; 3008"];
3008 [label="FullWidth = this.Text.Length; 3009"];
3009 [label="FullWidth 3010"];
3010 [label="this.AdjustFlagsAndWidth(trailing); 3011"];
3011 [label="return 'do'; 3012"];
3012 [label="FullWidth = this.Text.Length; 3013"];
3013 [label="FullWidth 3014"];
3014 [label="return 'do'; 3015"];
3015 [label="FullWidth = this.Text.Length; 3016"];
3016 [label="FullWidth 3017"];
3017 [label="this.AdjustFlagsAndWidth(leading); 3018"];
3018 [label="return 'do'; 3019"];
3019 [label="FullWidth = this.Text.Length; 3020"];
3020 [label="FullWidth 3021"];
3021 [label="this.AdjustFlagsAndWidth(trailing); 3022"];
3022 [label="return 'do'; 3023"];
3023 [label="FullWidth = this.Text.Length; 3024"];
3024 [label="FullWidth 3025"];
3025 [label="this.AdjustFlagsAndWidth(trailing); 3026"];
3026 [label="return 'switch'; 3027"];
3027 [label="FullWidth = this.Text.Length; 3028"];
3028 [label="FullWidth 3029"];
3029 [label="return 'switch'; 3030"];
3030 [label="FullWidth = this.Text.Length; 3031"];
3031 [label="FullWidth 3032"];
3032 [label="this.AdjustFlagsAndWidth(leading); 3033"];
3033 [label="return 'switch'; 3034"];
3034 [label="FullWidth = this.Text.Length; 3035"];
3035 [label="FullWidth 3036"];
3036 [label="this.AdjustFlagsAndWidth(trailing); 3037"];
3037 [label="return 'switch'; 3038"];
3038 [label="FullWidth = this.Text.Length; 3039"];
3039 [label="FullWidth 3040"];
3040 [label="this.AdjustFlagsAndWidth(trailing); 3041"];
3041 [label="return 'case'; 3042"];
3042 [label="FullWidth = this.Text.Length; 3043"];
3043 [label="FullWidth 3044"];
3044 [label="return 'case'; 3045"];
3045 [label="FullWidth = this.Text.Length; 3046"];
3046 [label="FullWidth 3047"];
3047 [label="this.AdjustFlagsAndWidth(leading); 3048"];
3048 [label="return 'case'; 3049"];
3049 [label="FullWidth = this.Text.Length; 3050"];
3050 [label="FullWidth 3051"];
3051 [label="this.AdjustFlagsAndWidth(trailing); 3052"];
3052 [label="return 'case'; 3053"];
3053 [label="FullWidth = this.Text.Length; 3054"];
3054 [label="FullWidth 3055"];
3055 [label="this.AdjustFlagsAndWidth(trailing); 3056"];
3056 [label="return 'default'; 3057"];
3057 [label="FullWidth = this.Text.Length; 3058"];
3058 [label="FullWidth 3059"];
3059 [label="return 'default'; 3060"];
3060 [label="FullWidth = this.Text.Length; 3061"];
3061 [label="FullWidth 3062"];
3062 [label="this.AdjustFlagsAndWidth(leading); 3063"];
3063 [label="return 'default'; 3064"];
3064 [label="FullWidth = this.Text.Length; 3065"];
3065 [label="FullWidth 3066"];
3066 [label="this.AdjustFlagsAndWidth(trailing); 3067"];
3067 [label="return 'default'; 3068"];
3068 [label="FullWidth = this.Text.Length; 3069"];
3069 [label="FullWidth 3070"];
3070 [label="this.AdjustFlagsAndWidth(trailing); 3071"];
3071 [label="return 'try'; 3072"];
3072 [label="FullWidth = this.Text.Length; 3073"];
3073 [label="FullWidth 3074"];
3074 [label="return 'try'; 3075"];
3075 [label="FullWidth = this.Text.Length; 3076"];
3076 [label="FullWidth 3077"];
3077 [label="this.AdjustFlagsAndWidth(leading); 3078"];
3078 [label="return 'try'; 3079"];
3079 [label="FullWidth = this.Text.Length; 3080"];
3080 [label="FullWidth 3081"];
3081 [label="this.AdjustFlagsAndWidth(trailing); 3082"];
3082 [label="return 'try'; 3083"];
3083 [label="FullWidth = this.Text.Length; 3084"];
3084 [label="FullWidth 3085"];
3085 [label="this.AdjustFlagsAndWidth(trailing); 3086"];
3086 [label="return 'catch'; 3087"];
3087 [label="FullWidth = this.Text.Length; 3088"];
3088 [label="FullWidth 3089"];
3089 [label="return 'catch'; 3090"];
3090 [label="FullWidth = this.Text.Length; 3091"];
3091 [label="FullWidth 3092"];
3092 [label="this.AdjustFlagsAndWidth(leading); 3093"];
3093 [label="return 'catch'; 3094"];
3094 [label="FullWidth = this.Text.Length; 3095"];
3095 [label="FullWidth 3096"];
3096 [label="this.AdjustFlagsAndWidth(trailing); 3097"];
3097 [label="return 'catch'; 3098"];
3098 [label="FullWidth = this.Text.Length; 3099"];
3099 [label="FullWidth 3100"];
3100 [label="this.AdjustFlagsAndWidth(trailing); 3101"];
3101 [label="return 'finally'; 3102"];
3102 [label="FullWidth = this.Text.Length; 3103"];
3103 [label="FullWidth 3104"];
3104 [label="return 'finally'; 3105"];
3105 [label="FullWidth = this.Text.Length; 3106"];
3106 [label="FullWidth 3107"];
3107 [label="this.AdjustFlagsAndWidth(leading); 3108"];
3108 [label="return 'finally'; 3109"];
3109 [label="FullWidth = this.Text.Length; 3110"];
3110 [label="FullWidth 3111"];
3111 [label="this.AdjustFlagsAndWidth(trailing); 3112"];
3112 [label="return 'finally'; 3113"];
3113 [label="FullWidth = this.Text.Length; 3114"];
3114 [label="FullWidth 3115"];
3115 [label="this.AdjustFlagsAndWidth(trailing); 3116"];
3116 [label="return 'lock'; 3117"];
3117 [label="FullWidth = this.Text.Length; 3118"];
3118 [label="FullWidth 3119"];
3119 [label="return 'lock'; 3120"];
3120 [label="FullWidth = this.Text.Length; 3121"];
3121 [label="FullWidth 3122"];
3122 [label="this.AdjustFlagsAndWidth(leading); 3123"];
3123 [label="return 'lock'; 3124"];
3124 [label="FullWidth = this.Text.Length; 3125"];
3125 [label="FullWidth 3126"];
3126 [label="this.AdjustFlagsAndWidth(trailing); 3127"];
3127 [label="return 'lock'; 3128"];
3128 [label="FullWidth = this.Text.Length; 3129"];
3129 [label="FullWidth 3130"];
3130 [label="this.AdjustFlagsAndWidth(trailing); 3131"];
3131 [label="return 'goto'; 3132"];
3132 [label="FullWidth = this.Text.Length; 3133"];
3133 [label="FullWidth 3134"];
3134 [label="return 'goto'; 3135"];
3135 [label="FullWidth = this.Text.Length; 3136"];
3136 [label="FullWidth 3137"];
3137 [label="this.AdjustFlagsAndWidth(leading); 3138"];
3138 [label="return 'goto'; 3139"];
3139 [label="FullWidth = this.Text.Length; 3140"];
3140 [label="FullWidth 3141"];
3141 [label="this.AdjustFlagsAndWidth(trailing); 3142"];
3142 [label="return 'goto'; 3143"];
3143 [label="FullWidth = this.Text.Length; 3144"];
3144 [label="FullWidth 3145"];
3145 [label="this.AdjustFlagsAndWidth(trailing); 3146"];
3146 [label="return 'break'; 3147"];
3147 [label="FullWidth = this.Text.Length; 3148"];
3148 [label="FullWidth 3149"];
3149 [label="return 'break'; 3150"];
3150 [label="FullWidth = this.Text.Length; 3151"];
3151 [label="FullWidth 3152"];
3152 [label="this.AdjustFlagsAndWidth(leading); 3153"];
3153 [label="return 'break'; 3154"];
3154 [label="FullWidth = this.Text.Length; 3155"];
3155 [label="FullWidth 3156"];
3156 [label="this.AdjustFlagsAndWidth(trailing); 3157"];
3157 [label="return 'break'; 3158"];
3158 [label="FullWidth = this.Text.Length; 3159"];
3159 [label="FullWidth 3160"];
3160 [label="this.AdjustFlagsAndWidth(trailing); 3161"];
3161 [label="return 'continue'; 3162"];
3162 [label="FullWidth = this.Text.Length; 3163"];
3163 [label="FullWidth 3164"];
3164 [label="return 'continue'; 3165"];
3165 [label="FullWidth = this.Text.Length; 3166"];
3166 [label="FullWidth 3167"];
3167 [label="this.AdjustFlagsAndWidth(leading); 3168"];
3168 [label="return 'continue'; 3169"];
3169 [label="FullWidth = this.Text.Length; 3170"];
3170 [label="FullWidth 3171"];
3171 [label="this.AdjustFlagsAndWidth(trailing); 3172"];
3172 [label="return 'continue'; 3173"];
3173 [label="FullWidth = this.Text.Length; 3174"];
3174 [label="FullWidth 3175"];
3175 [label="this.AdjustFlagsAndWidth(trailing); 3176"];
3176 [label="return 'return'; 3177"];
3177 [label="FullWidth = this.Text.Length; 3178"];
3178 [label="FullWidth 3179"];
3179 [label="return 'return'; 3180"];
3180 [label="FullWidth = this.Text.Length; 3181"];
3181 [label="FullWidth 3182"];
3182 [label="this.AdjustFlagsAndWidth(leading); 3183"];
3183 [label="return 'return'; 3184"];
3184 [label="FullWidth = this.Text.Length; 3185"];
3185 [label="FullWidth 3186"];
3186 [label="this.AdjustFlagsAndWidth(trailing); 3187"];
3187 [label="return 'return'; 3188"];
3188 [label="FullWidth = this.Text.Length; 3189"];
3189 [label="FullWidth 3190"];
3190 [label="this.AdjustFlagsAndWidth(trailing); 3191"];
3191 [label="return 'throw'; 3192"];
3192 [label="FullWidth = this.Text.Length; 3193"];
3193 [label="FullWidth 3194"];
3194 [label="return 'throw'; 3195"];
3195 [label="FullWidth = this.Text.Length; 3196"];
3196 [label="FullWidth 3197"];
3197 [label="this.AdjustFlagsAndWidth(leading); 3198"];
3198 [label="return 'throw'; 3199"];
3199 [label="FullWidth = this.Text.Length; 3200"];
3200 [label="FullWidth 3201"];
3201 [label="this.AdjustFlagsAndWidth(trailing); 3202"];
3202 [label="return 'throw'; 3203"];
3203 [label="FullWidth = this.Text.Length; 3204"];
3204 [label="FullWidth 3205"];
3205 [label="this.AdjustFlagsAndWidth(trailing); 3206"];
3206 [label="return 'public'; 3207"];
3207 [label="FullWidth = this.Text.Length; 3208"];
3208 [label="FullWidth 3209"];
3209 [label="return 'public'; 3210"];
3210 [label="FullWidth = this.Text.Length; 3211"];
3211 [label="FullWidth 3212"];
3212 [label="this.AdjustFlagsAndWidth(leading); 3213"];
3213 [label="return 'public'; 3214"];
3214 [label="FullWidth = this.Text.Length; 3215"];
3215 [label="FullWidth 3216"];
3216 [label="this.AdjustFlagsAndWidth(trailing); 3217"];
3217 [label="return 'public'; 3218"];
3218 [label="FullWidth = this.Text.Length; 3219"];
3219 [label="FullWidth 3220"];
3220 [label="this.AdjustFlagsAndWidth(trailing); 3221"];
3221 [label="return 'private'; 3222"];
3222 [label="FullWidth = this.Text.Length; 3223"];
3223 [label="FullWidth 3224"];
3224 [label="return 'private'; 3225"];
3225 [label="FullWidth = this.Text.Length; 3226"];
3226 [label="FullWidth 3227"];
3227 [label="this.AdjustFlagsAndWidth(leading); 3228"];
3228 [label="return 'private'; 3229"];
3229 [label="FullWidth = this.Text.Length; 3230"];
3230 [label="FullWidth 3231"];
3231 [label="this.AdjustFlagsAndWidth(trailing); 3232"];
3232 [label="return 'private'; 3233"];
3233 [label="FullWidth = this.Text.Length; 3234"];
3234 [label="FullWidth 3235"];
3235 [label="this.AdjustFlagsAndWidth(trailing); 3236"];
3236 [label="return 'internal'; 3237"];
3237 [label="FullWidth = this.Text.Length; 3238"];
3238 [label="FullWidth 3239"];
3239 [label="return 'internal'; 3240"];
3240 [label="FullWidth = this.Text.Length; 3241"];
3241 [label="FullWidth 3242"];
3242 [label="this.AdjustFlagsAndWidth(leading); 3243"];
3243 [label="return 'internal'; 3244"];
3244 [label="FullWidth = this.Text.Length; 3245"];
3245 [label="FullWidth 3246"];
3246 [label="this.AdjustFlagsAndWidth(trailing); 3247"];
3247 [label="return 'internal'; 3248"];
3248 [label="FullWidth = this.Text.Length; 3249"];
3249 [label="FullWidth 3250"];
3250 [label="this.AdjustFlagsAndWidth(trailing); 3251"];
3251 [label="return 'protected'; 3252"];
3252 [label="FullWidth = this.Text.Length; 3253"];
3253 [label="FullWidth 3254"];
3254 [label="return 'protected'; 3255"];
3255 [label="FullWidth = this.Text.Length; 3256"];
3256 [label="FullWidth 3257"];
3257 [label="this.AdjustFlagsAndWidth(leading); 3258"];
3258 [label="return 'protected'; 3259"];
3259 [label="FullWidth = this.Text.Length; 3260"];
3260 [label="FullWidth 3261"];
3261 [label="this.AdjustFlagsAndWidth(trailing); 3262"];
3262 [label="return 'protected'; 3263"];
3263 [label="FullWidth = this.Text.Length; 3264"];
3264 [label="FullWidth 3265"];
3265 [label="this.AdjustFlagsAndWidth(trailing); 3266"];
3266 [label="return 'static'; 3267"];
3267 [label="FullWidth = this.Text.Length; 3268"];
3268 [label="FullWidth 3269"];
3269 [label="return 'static'; 3270"];
3270 [label="FullWidth = this.Text.Length; 3271"];
3271 [label="FullWidth 3272"];
3272 [label="this.AdjustFlagsAndWidth(leading); 3273"];
3273 [label="return 'static'; 3274"];
3274 [label="FullWidth = this.Text.Length; 3275"];
3275 [label="FullWidth 3276"];
3276 [label="this.AdjustFlagsAndWidth(trailing); 3277"];
3277 [label="return 'static'; 3278"];
3278 [label="FullWidth = this.Text.Length; 3279"];
3279 [label="FullWidth 3280"];
3280 [label="this.AdjustFlagsAndWidth(trailing); 3281"];
3281 [label="return 'readonly'; 3282"];
3282 [label="FullWidth = this.Text.Length; 3283"];
3283 [label="FullWidth 3284"];
3284 [label="return 'readonly'; 3285"];
3285 [label="FullWidth = this.Text.Length; 3286"];
3286 [label="FullWidth 3287"];
3287 [label="this.AdjustFlagsAndWidth(leading); 3288"];
3288 [label="return 'readonly'; 3289"];
3289 [label="FullWidth = this.Text.Length; 3290"];
3290 [label="FullWidth 3291"];
3291 [label="this.AdjustFlagsAndWidth(trailing); 3292"];
3292 [label="return 'readonly'; 3293"];
3293 [label="FullWidth = this.Text.Length; 3294"];
3294 [label="FullWidth 3295"];
3295 [label="this.AdjustFlagsAndWidth(trailing); 3296"];
3296 [label="return 'sealed'; 3297"];
3297 [label="FullWidth = this.Text.Length; 3298"];
3298 [label="FullWidth 3299"];
3299 [label="return 'sealed'; 3300"];
3300 [label="FullWidth = this.Text.Length; 3301"];
3301 [label="FullWidth 3302"];
3302 [label="this.AdjustFlagsAndWidth(leading); 3303"];
3303 [label="return 'sealed'; 3304"];
3304 [label="FullWidth = this.Text.Length; 3305"];
3305 [label="FullWidth 3306"];
3306 [label="this.AdjustFlagsAndWidth(trailing); 3307"];
3307 [label="return 'sealed'; 3308"];
3308 [label="FullWidth = this.Text.Length; 3309"];
3309 [label="FullWidth 3310"];
3310 [label="this.AdjustFlagsAndWidth(trailing); 3311"];
3311 [label="return 'const'; 3312"];
3312 [label="FullWidth = this.Text.Length; 3313"];
3313 [label="FullWidth 3314"];
3314 [label="return 'const'; 3315"];
3315 [label="FullWidth = this.Text.Length; 3316"];
3316 [label="FullWidth 3317"];
3317 [label="this.AdjustFlagsAndWidth(leading); 3318"];
3318 [label="return 'const'; 3319"];
3319 [label="FullWidth = this.Text.Length; 3320"];
3320 [label="FullWidth 3321"];
3321 [label="this.AdjustFlagsAndWidth(trailing); 3322"];
3322 [label="return 'const'; 3323"];
3323 [label="FullWidth = this.Text.Length; 3324"];
3324 [label="FullWidth 3325"];
3325 [label="this.AdjustFlagsAndWidth(trailing); 3326"];
3326 [label="return 'fixed'; 3327"];
3327 [label="FullWidth = this.Text.Length; 3328"];
3328 [label="FullWidth 3329"];
3329 [label="return 'fixed'; 3330"];
3330 [label="FullWidth = this.Text.Length; 3331"];
3331 [label="FullWidth 3332"];
3332 [label="this.AdjustFlagsAndWidth(leading); 3333"];
3333 [label="return 'fixed'; 3334"];
3334 [label="FullWidth = this.Text.Length; 3335"];
3335 [label="FullWidth 3336"];
3336 [label="this.AdjustFlagsAndWidth(trailing); 3337"];
3337 [label="return 'fixed'; 3338"];
3338 [label="FullWidth = this.Text.Length; 3339"];
3339 [label="FullWidth 3340"];
3340 [label="this.AdjustFlagsAndWidth(trailing); 3341"];
3341 [label="return 'stackalloc'; 3342"];
3342 [label="FullWidth = this.Text.Length; 3343"];
3343 [label="FullWidth 3344"];
3344 [label="return 'stackalloc'; 3345"];
3345 [label="FullWidth = this.Text.Length; 3346"];
3346 [label="FullWidth 3347"];
3347 [label="this.AdjustFlagsAndWidth(leading); 3348"];
3348 [label="return 'stackalloc'; 3349"];
3349 [label="FullWidth = this.Text.Length; 3350"];
3350 [label="FullWidth 3351"];
3351 [label="this.AdjustFlagsAndWidth(trailing); 3352"];
3352 [label="return 'stackalloc'; 3353"];
3353 [label="FullWidth = this.Text.Length; 3354"];
3354 [label="FullWidth 3355"];
3355 [label="this.AdjustFlagsAndWidth(trailing); 3356"];
3356 [label="return 'volatile'; 3357"];
3357 [label="FullWidth = this.Text.Length; 3358"];
3358 [label="FullWidth 3359"];
3359 [label="return 'volatile'; 3360"];
3360 [label="FullWidth = this.Text.Length; 3361"];
3361 [label="FullWidth 3362"];
3362 [label="this.AdjustFlagsAndWidth(leading); 3363"];
3363 [label="return 'volatile'; 3364"];
3364 [label="FullWidth = this.Text.Length; 3365"];
3365 [label="FullWidth 3366"];
3366 [label="this.AdjustFlagsAndWidth(trailing); 3367"];
3367 [label="return 'volatile'; 3368"];
3368 [label="FullWidth = this.Text.Length; 3369"];
3369 [label="FullWidth 3370"];
3370 [label="this.AdjustFlagsAndWidth(trailing); 3371"];
3371 [label="return 'new'; 3372"];
3372 [label="FullWidth = this.Text.Length; 3373"];
3373 [label="FullWidth 3374"];
3374 [label="return 'new'; 3375"];
3375 [label="FullWidth = this.Text.Length; 3376"];
3376 [label="FullWidth 3377"];
3377 [label="this.AdjustFlagsAndWidth(leading); 3378"];
3378 [label="return 'new'; 3379"];
3379 [label="FullWidth = this.Text.Length; 3380"];
3380 [label="FullWidth 3381"];
3381 [label="this.AdjustFlagsAndWidth(trailing); 3382"];
3382 [label="return 'new'; 3383"];
3383 [label="FullWidth = this.Text.Length; 3384"];
3384 [label="FullWidth 3385"];
3385 [label="this.AdjustFlagsAndWidth(trailing); 3386"];
3386 [label="return 'override'; 3387"];
3387 [label="FullWidth = this.Text.Length; 3388"];
3388 [label="FullWidth 3389"];
3389 [label="return 'override'; 3390"];
3390 [label="FullWidth = this.Text.Length; 3391"];
3391 [label="FullWidth 3392"];
3392 [label="this.AdjustFlagsAndWidth(leading); 3393"];
3393 [label="return 'override'; 3394"];
3394 [label="FullWidth = this.Text.Length; 3395"];
3395 [label="FullWidth 3396"];
3396 [label="this.AdjustFlagsAndWidth(trailing); 3397"];
3397 [label="return 'override'; 3398"];
3398 [label="FullWidth = this.Text.Length; 3399"];
3399 [label="FullWidth 3400"];
3400 [label="this.AdjustFlagsAndWidth(trailing); 3401"];
3401 [label="return 'abstract'; 3402"];
3402 [label="FullWidth = this.Text.Length; 3403"];
3403 [label="FullWidth 3404"];
3404 [label="return 'abstract'; 3405"];
3405 [label="FullWidth = this.Text.Length; 3406"];
3406 [label="FullWidth 3407"];
3407 [label="this.AdjustFlagsAndWidth(leading); 3408"];
3408 [label="return 'abstract'; 3409"];
3409 [label="FullWidth = this.Text.Length; 3410"];
3410 [label="FullWidth 3411"];
3411 [label="this.AdjustFlagsAndWidth(trailing); 3412"];
3412 [label="return 'abstract'; 3413"];
3413 [label="FullWidth = this.Text.Length; 3414"];
3414 [label="FullWidth 3415"];
3415 [label="this.AdjustFlagsAndWidth(trailing); 3416"];
3416 [label="return 'virtual'; 3417"];
3417 [label="FullWidth = this.Text.Length; 3418"];
3418 [label="FullWidth 3419"];
3419 [label="return 'virtual'; 3420"];
3420 [label="FullWidth = this.Text.Length; 3421"];
3421 [label="FullWidth 3422"];
3422 [label="this.AdjustFlagsAndWidth(leading); 3423"];
3423 [label="return 'virtual'; 3424"];
3424 [label="FullWidth = this.Text.Length; 3425"];
3425 [label="FullWidth 3426"];
3426 [label="this.AdjustFlagsAndWidth(trailing); 3427"];
3427 [label="return 'virtual'; 3428"];
3428 [label="FullWidth = this.Text.Length; 3429"];
3429 [label="FullWidth 3430"];
3430 [label="this.AdjustFlagsAndWidth(trailing); 3431"];
3431 [label="return 'event'; 3432"];
3432 [label="FullWidth = this.Text.Length; 3433"];
3433 [label="FullWidth 3434"];
3434 [label="return 'event'; 3435"];
3435 [label="FullWidth = this.Text.Length; 3436"];
3436 [label="FullWidth 3437"];
3437 [label="this.AdjustFlagsAndWidth(leading); 3438"];
3438 [label="return 'event'; 3439"];
3439 [label="FullWidth = this.Text.Length; 3440"];
3440 [label="FullWidth 3441"];
3441 [label="this.AdjustFlagsAndWidth(trailing); 3442"];
3442 [label="return 'event'; 3443"];
3443 [label="FullWidth = this.Text.Length; 3444"];
3444 [label="FullWidth 3445"];
3445 [label="this.AdjustFlagsAndWidth(trailing); 3446"];
3446 [label="return 'extern'; 3447"];
3447 [label="FullWidth = this.Text.Length; 3448"];
3448 [label="FullWidth 3449"];
3449 [label="return 'extern'; 3450"];
3450 [label="FullWidth = this.Text.Length; 3451"];
3451 [label="FullWidth 3452"];
3452 [label="this.AdjustFlagsAndWidth(leading); 3453"];
3453 [label="return 'extern'; 3454"];
3454 [label="FullWidth = this.Text.Length; 3455"];
3455 [label="FullWidth 3456"];
3456 [label="this.AdjustFlagsAndWidth(trailing); 3457"];
3457 [label="return 'extern'; 3458"];
3458 [label="FullWidth = this.Text.Length; 3459"];
3459 [label="FullWidth 3460"];
3460 [label="this.AdjustFlagsAndWidth(trailing); 3461"];
3461 [label="return 'ref'; 3462"];
3462 [label="FullWidth = this.Text.Length; 3463"];
3463 [label="FullWidth 3464"];
3464 [label="return 'ref'; 3465"];
3465 [label="FullWidth = this.Text.Length; 3466"];
3466 [label="FullWidth 3467"];
3467 [label="this.AdjustFlagsAndWidth(leading); 3468"];
3468 [label="return 'ref'; 3469"];
3469 [label="FullWidth = this.Text.Length; 3470"];
3470 [label="FullWidth 3471"];
3471 [label="this.AdjustFlagsAndWidth(trailing); 3472"];
3472 [label="return 'ref'; 3473"];
3473 [label="FullWidth = this.Text.Length; 3474"];
3474 [label="FullWidth 3475"];
3475 [label="this.AdjustFlagsAndWidth(trailing); 3476"];
3476 [label="return 'out'; 3477"];
3477 [label="FullWidth = this.Text.Length; 3478"];
3478 [label="FullWidth 3479"];
3479 [label="return 'out'; 3480"];
3480 [label="FullWidth = this.Text.Length; 3481"];
3481 [label="FullWidth 3482"];
3482 [label="this.AdjustFlagsAndWidth(leading); 3483"];
3483 [label="return 'out'; 3484"];
3484 [label="FullWidth = this.Text.Length; 3485"];
3485 [label="FullWidth 3486"];
3486 [label="this.AdjustFlagsAndWidth(trailing); 3487"];
3487 [label="return 'out'; 3488"];
3488 [label="FullWidth = this.Text.Length; 3489"];
3489 [label="FullWidth 3490"];
3490 [label="this.AdjustFlagsAndWidth(trailing); 3491"];
3491 [label="return 'in'; 3492"];
3492 [label="FullWidth = this.Text.Length; 3493"];
3493 [label="FullWidth 3494"];
3494 [label="return 'in'; 3495"];
3495 [label="FullWidth = this.Text.Length; 3496"];
3496 [label="FullWidth 3497"];
3497 [label="this.AdjustFlagsAndWidth(leading); 3498"];
3498 [label="return 'in'; 3499"];
3499 [label="FullWidth = this.Text.Length; 3500"];
3500 [label="FullWidth 3501"];
3501 [label="this.AdjustFlagsAndWidth(trailing); 3502"];
3502 [label="return 'in'; 3503"];
3503 [label="FullWidth = this.Text.Length; 3504"];
3504 [label="FullWidth 3505"];
3505 [label="this.AdjustFlagsAndWidth(trailing); 3506"];
3506 [label="return 'is'; 3507"];
3507 [label="FullWidth = this.Text.Length; 3508"];
3508 [label="FullWidth 3509"];
3509 [label="return 'is'; 3510"];
3510 [label="FullWidth = this.Text.Length; 3511"];
3511 [label="FullWidth 3512"];
3512 [label="this.AdjustFlagsAndWidth(leading); 3513"];
3513 [label="return 'is'; 3514"];
3514 [label="FullWidth = this.Text.Length; 3515"];
3515 [label="FullWidth 3516"];
3516 [label="this.AdjustFlagsAndWidth(trailing); 3517"];
3517 [label="return 'is'; 3518"];
3518 [label="FullWidth = this.Text.Length; 3519"];
3519 [label="FullWidth 3520"];
3520 [label="this.AdjustFlagsAndWidth(trailing); 3521"];
3521 [label="return 'as'; 3522"];
3522 [label="FullWidth = this.Text.Length; 3523"];
3523 [label="FullWidth 3524"];
3524 [label="return 'as'; 3525"];
3525 [label="FullWidth = this.Text.Length; 3526"];
3526 [label="FullWidth 3527"];
3527 [label="this.AdjustFlagsAndWidth(leading); 3528"];
3528 [label="return 'as'; 3529"];
3529 [label="FullWidth = this.Text.Length; 3530"];
3530 [label="FullWidth 3531"];
3531 [label="this.AdjustFlagsAndWidth(trailing); 3532"];
3532 [label="return 'as'; 3533"];
3533 [label="FullWidth = this.Text.Length; 3534"];
3534 [label="FullWidth 3535"];
3535 [label="this.AdjustFlagsAndWidth(trailing); 3536"];
3536 [label="return 'params'; 3537"];
3537 [label="FullWidth = this.Text.Length; 3538"];
3538 [label="FullWidth 3539"];
3539 [label="return 'params'; 3540"];
3540 [label="FullWidth = this.Text.Length; 3541"];
3541 [label="FullWidth 3542"];
3542 [label="this.AdjustFlagsAndWidth(leading); 3543"];
3543 [label="return 'params'; 3544"];
3544 [label="FullWidth = this.Text.Length; 3545"];
3545 [label="FullWidth 3546"];
3546 [label="this.AdjustFlagsAndWidth(trailing); 3547"];
3547 [label="return 'params'; 3548"];
3548 [label="FullWidth = this.Text.Length; 3549"];
3549 [label="FullWidth 3550"];
3550 [label="this.AdjustFlagsAndWidth(trailing); 3551"];
3551 [label="return '__arglist'; 3552"];
3552 [label="FullWidth = this.Text.Length; 3553"];
3553 [label="FullWidth 3554"];
3554 [label="return '__arglist'; 3555"];
3555 [label="FullWidth = this.Text.Length; 3556"];
3556 [label="FullWidth 3557"];
3557 [label="this.AdjustFlagsAndWidth(leading); 3558"];
3558 [label="return '__arglist'; 3559"];
3559 [label="FullWidth = this.Text.Length; 3560"];
3560 [label="FullWidth 3561"];
3561 [label="this.AdjustFlagsAndWidth(trailing); 3562"];
3562 [label="return '__arglist'; 3563"];
3563 [label="FullWidth = this.Text.Length; 3564"];
3564 [label="FullWidth 3565"];
3565 [label="this.AdjustFlagsAndWidth(trailing); 3566"];
3566 [label="return '__makeref'; 3567"];
3567 [label="FullWidth = this.Text.Length; 3568"];
3568 [label="FullWidth 3569"];
3569 [label="return '__makeref'; 3570"];
3570 [label="FullWidth = this.Text.Length; 3571"];
3571 [label="FullWidth 3572"];
3572 [label="this.AdjustFlagsAndWidth(leading); 3573"];
3573 [label="return '__makeref'; 3574"];
3574 [label="FullWidth = this.Text.Length; 3575"];
3575 [label="FullWidth 3576"];
3576 [label="this.AdjustFlagsAndWidth(trailing); 3577"];
3577 [label="return '__makeref'; 3578"];
3578 [label="FullWidth = this.Text.Length; 3579"];
3579 [label="FullWidth 3580"];
3580 [label="this.AdjustFlagsAndWidth(trailing); 3581"];
3581 [label="return '__reftype'; 3582"];
3582 [label="FullWidth = this.Text.Length; 3583"];
3583 [label="FullWidth 3584"];
3584 [label="return '__reftype'; 3585"];
3585 [label="FullWidth = this.Text.Length; 3586"];
3586 [label="FullWidth 3587"];
3587 [label="this.AdjustFlagsAndWidth(leading); 3588"];
3588 [label="return '__reftype'; 3589"];
3589 [label="FullWidth = this.Text.Length; 3590"];
3590 [label="FullWidth 3591"];
3591 [label="this.AdjustFlagsAndWidth(trailing); 3592"];
3592 [label="return '__reftype'; 3593"];
3593 [label="FullWidth = this.Text.Length; 3594"];
3594 [label="FullWidth 3595"];
3595 [label="this.AdjustFlagsAndWidth(trailing); 3596"];
3596 [label="return '__refvalue'; 3597"];
3597 [label="FullWidth = this.Text.Length; 3598"];
3598 [label="FullWidth 3599"];
3599 [label="return '__refvalue'; 3600"];
3600 [label="FullWidth = this.Text.Length; 3601"];
3601 [label="FullWidth 3602"];
3602 [label="this.AdjustFlagsAndWidth(leading); 3603"];
3603 [label="return '__refvalue'; 3604"];
3604 [label="FullWidth = this.Text.Length; 3605"];
3605 [label="FullWidth 3606"];
3606 [label="this.AdjustFlagsAndWidth(trailing); 3607"];
3607 [label="return '__refvalue'; 3608"];
3608 [label="FullWidth = this.Text.Length; 3609"];
3609 [label="FullWidth 3610"];
3610 [label="this.AdjustFlagsAndWidth(trailing); 3611"];
3611 [label="return 'this'; 3612"];
3612 [label="FullWidth = this.Text.Length; 3613"];
3613 [label="FullWidth 3614"];
3614 [label="return 'this'; 3615"];
3615 [label="FullWidth = this.Text.Length; 3616"];
3616 [label="FullWidth 3617"];
3617 [label="this.AdjustFlagsAndWidth(leading); 3618"];
3618 [label="return 'this'; 3619"];
3619 [label="FullWidth = this.Text.Length; 3620"];
3620 [label="FullWidth 3621"];
3621 [label="this.AdjustFlagsAndWidth(trailing); 3622"];
3622 [label="return 'this'; 3623"];
3623 [label="FullWidth = this.Text.Length; 3624"];
3624 [label="FullWidth 3625"];
3625 [label="this.AdjustFlagsAndWidth(trailing); 3626"];
3626 [label="return 'base'; 3627"];
3627 [label="FullWidth = this.Text.Length; 3628"];
3628 [label="FullWidth 3629"];
3629 [label="return 'base'; 3630"];
3630 [label="FullWidth = this.Text.Length; 3631"];
3631 [label="FullWidth 3632"];
3632 [label="this.AdjustFlagsAndWidth(leading); 3633"];
3633 [label="return 'base'; 3634"];
3634 [label="FullWidth = this.Text.Length; 3635"];
3635 [label="FullWidth 3636"];
3636 [label="this.AdjustFlagsAndWidth(trailing); 3637"];
3637 [label="return 'base'; 3638"];
3638 [label="FullWidth = this.Text.Length; 3639"];
3639 [label="FullWidth 3640"];
3640 [label="this.AdjustFlagsAndWidth(trailing); 3641"];
3641 [label="return 'namespace'; 3642"];
3642 [label="FullWidth = this.Text.Length; 3643"];
3643 [label="FullWidth 3644"];
3644 [label="return 'namespace'; 3645"];
3645 [label="FullWidth = this.Text.Length; 3646"];
3646 [label="FullWidth 3647"];
3647 [label="this.AdjustFlagsAndWidth(leading); 3648"];
3648 [label="return 'namespace'; 3649"];
3649 [label="FullWidth = this.Text.Length; 3650"];
3650 [label="FullWidth 3651"];
3651 [label="this.AdjustFlagsAndWidth(trailing); 3652"];
3652 [label="return 'namespace'; 3653"];
3653 [label="FullWidth = this.Text.Length; 3654"];
3654 [label="FullWidth 3655"];
3655 [label="this.AdjustFlagsAndWidth(trailing); 3656"];
3656 [label="return 'using'; 3657"];
3657 [label="FullWidth = this.Text.Length; 3658"];
3658 [label="FullWidth 3659"];
3659 [label="return 'using'; 3660"];
3660 [label="FullWidth = this.Text.Length; 3661"];
3661 [label="FullWidth 3662"];
3662 [label="this.AdjustFlagsAndWidth(leading); 3663"];
3663 [label="return 'using'; 3664"];
3664 [label="FullWidth = this.Text.Length; 3665"];
3665 [label="FullWidth 3666"];
3666 [label="this.AdjustFlagsAndWidth(trailing); 3667"];
3667 [label="return 'using'; 3668"];
3668 [label="FullWidth = this.Text.Length; 3669"];
3669 [label="FullWidth 3670"];
3670 [label="this.AdjustFlagsAndWidth(trailing); 3671"];
3671 [label="return 'class'; 3672"];
3672 [label="FullWidth = this.Text.Length; 3673"];
3673 [label="FullWidth 3674"];
3674 [label="return 'class'; 3675"];
3675 [label="FullWidth = this.Text.Length; 3676"];
3676 [label="FullWidth 3677"];
3677 [label="this.AdjustFlagsAndWidth(leading); 3678"];
3678 [label="return 'class'; 3679"];
3679 [label="FullWidth = this.Text.Length; 3680"];
3680 [label="FullWidth 3681"];
3681 [label="this.AdjustFlagsAndWidth(trailing); 3682"];
3682 [label="return 'class'; 3683"];
3683 [label="FullWidth = this.Text.Length; 3684"];
3684 [label="FullWidth 3685"];
3685 [label="this.AdjustFlagsAndWidth(trailing); 3686"];
3686 [label="return 'struct'; 3687"];
3687 [label="FullWidth = this.Text.Length; 3688"];
3688 [label="FullWidth 3689"];
3689 [label="return 'struct'; 3690"];
3690 [label="FullWidth = this.Text.Length; 3691"];
3691 [label="FullWidth 3692"];
3692 [label="this.AdjustFlagsAndWidth(leading); 3693"];
3693 [label="return 'struct'; 3694"];
3694 [label="FullWidth = this.Text.Length; 3695"];
3695 [label="FullWidth 3696"];
3696 [label="this.AdjustFlagsAndWidth(trailing); 3697"];
3697 [label="return 'struct'; 3698"];
3698 [label="FullWidth = this.Text.Length; 3699"];
3699 [label="FullWidth 3700"];
3700 [label="this.AdjustFlagsAndWidth(trailing); 3701"];
3701 [label="return 'interface'; 3702"];
3702 [label="FullWidth = this.Text.Length; 3703"];
3703 [label="FullWidth 3704"];
3704 [label="return 'interface'; 3705"];
3705 [label="FullWidth = this.Text.Length; 3706"];
3706 [label="FullWidth 3707"];
3707 [label="this.AdjustFlagsAndWidth(leading); 3708"];
3708 [label="return 'interface'; 3709"];
3709 [label="FullWidth = this.Text.Length; 3710"];
3710 [label="FullWidth 3711"];
3711 [label="this.AdjustFlagsAndWidth(trailing); 3712"];
3712 [label="return 'interface'; 3713"];
3713 [label="FullWidth = this.Text.Length; 3714"];
3714 [label="FullWidth 3715"];
3715 [label="this.AdjustFlagsAndWidth(trailing); 3716"];
3716 [label="return 'enum'; 3717"];
3717 [label="FullWidth = this.Text.Length; 3718"];
3718 [label="FullWidth 3719"];
3719 [label="return 'enum'; 3720"];
3720 [label="FullWidth = this.Text.Length; 3721"];
3721 [label="FullWidth 3722"];
3722 [label="this.AdjustFlagsAndWidth(leading); 3723"];
3723 [label="return 'enum'; 3724"];
3724 [label="FullWidth = this.Text.Length; 3725"];
3725 [label="FullWidth 3726"];
3726 [label="this.AdjustFlagsAndWidth(trailing); 3727"];
3727 [label="return 'enum'; 3728"];
3728 [label="FullWidth = this.Text.Length; 3729"];
3729 [label="FullWidth 3730"];
3730 [label="this.AdjustFlagsAndWidth(trailing); 3731"];
3731 [label="return 'delegate'; 3732"];
3732 [label="FullWidth = this.Text.Length; 3733"];
3733 [label="FullWidth 3734"];
3734 [label="return 'delegate'; 3735"];
3735 [label="FullWidth = this.Text.Length; 3736"];
3736 [label="FullWidth 3737"];
3737 [label="this.AdjustFlagsAndWidth(leading); 3738"];
3738 [label="return 'delegate'; 3739"];
3739 [label="FullWidth = this.Text.Length; 3740"];
3740 [label="FullWidth 3741"];
3741 [label="this.AdjustFlagsAndWidth(trailing); 3742"];
3742 [label="return 'delegate'; 3743"];
3743 [label="FullWidth = this.Text.Length; 3744"];
3744 [label="FullWidth 3745"];
3745 [label="this.AdjustFlagsAndWidth(trailing); 3746"];
3746 [label="return 'checked'; 3747"];
3747 [label="FullWidth = this.Text.Length; 3748"];
3748 [label="FullWidth 3749"];
3749 [label="return 'checked'; 3750"];
3750 [label="FullWidth = this.Text.Length; 3751"];
3751 [label="FullWidth 3752"];
3752 [label="this.AdjustFlagsAndWidth(leading); 3753"];
3753 [label="return 'checked'; 3754"];
3754 [label="FullWidth = this.Text.Length; 3755"];
3755 [label="FullWidth 3756"];
3756 [label="this.AdjustFlagsAndWidth(trailing); 3757"];
3757 [label="return 'checked'; 3758"];
3758 [label="FullWidth = this.Text.Length; 3759"];
3759 [label="FullWidth 3760"];
3760 [label="this.AdjustFlagsAndWidth(trailing); 3761"];
3761 [label="return 'unchecked'; 3762"];
3762 [label="FullWidth = this.Text.Length; 3763"];
3763 [label="FullWidth 3764"];
3764 [label="return 'unchecked'; 3765"];
3765 [label="FullWidth = this.Text.Length; 3766"];
3766 [label="FullWidth 3767"];
3767 [label="this.AdjustFlagsAndWidth(leading); 3768"];
3768 [label="return 'unchecked'; 3769"];
3769 [label="FullWidth = this.Text.Length; 3770"];
3770 [label="FullWidth 3771"];
3771 [label="this.AdjustFlagsAndWidth(trailing); 3772"];
3772 [label="return 'unchecked'; 3773"];
3773 [label="FullWidth = this.Text.Length; 3774"];
3774 [label="FullWidth 3775"];
3775 [label="this.AdjustFlagsAndWidth(trailing); 3776"];
3776 [label="return 'unsafe'; 3777"];
3777 [label="FullWidth = this.Text.Length; 3778"];
3778 [label="FullWidth 3779"];
3779 [label="return 'unsafe'; 3780"];
3780 [label="FullWidth = this.Text.Length; 3781"];
3781 [label="FullWidth 3782"];
3782 [label="this.AdjustFlagsAndWidth(leading); 3783"];
3783 [label="return 'unsafe'; 3784"];
3784 [label="FullWidth = this.Text.Length; 3785"];
3785 [label="FullWidth 3786"];
3786 [label="this.AdjustFlagsAndWidth(trailing); 3787"];
3787 [label="return 'unsafe'; 3788"];
3788 [label="FullWidth = this.Text.Length; 3789"];
3789 [label="FullWidth 3790"];
3790 [label="this.AdjustFlagsAndWidth(trailing); 3791"];
3791 [label="return 'operator'; 3792"];
3792 [label="FullWidth = this.Text.Length; 3793"];
3793 [label="FullWidth 3794"];
3794 [label="return 'operator'; 3795"];
3795 [label="FullWidth = this.Text.Length; 3796"];
3796 [label="FullWidth 3797"];
3797 [label="this.AdjustFlagsAndWidth(leading); 3798"];
3798 [label="return 'operator'; 3799"];
3799 [label="FullWidth = this.Text.Length; 3800"];
3800 [label="FullWidth 3801"];
3801 [label="this.AdjustFlagsAndWidth(trailing); 3802"];
3802 [label="return 'operator'; 3803"];
3803 [label="FullWidth = this.Text.Length; 3804"];
3804 [label="FullWidth 3805"];
3805 [label="this.AdjustFlagsAndWidth(trailing); 3806"];
3806 [label="return 'explicit'; 3807"];
3807 [label="FullWidth = this.Text.Length; 3808"];
3808 [label="FullWidth 3809"];
3809 [label="return 'explicit'; 3810"];
3810 [label="FullWidth = this.Text.Length; 3811"];
3811 [label="FullWidth 3812"];
3812 [label="this.AdjustFlagsAndWidth(leading); 3813"];
3813 [label="return 'explicit'; 3814"];
3814 [label="FullWidth = this.Text.Length; 3815"];
3815 [label="FullWidth 3816"];
3816 [label="this.AdjustFlagsAndWidth(trailing); 3817"];
3817 [label="return 'explicit'; 3818"];
3818 [label="FullWidth = this.Text.Length; 3819"];
3819 [label="FullWidth 3820"];
3820 [label="this.AdjustFlagsAndWidth(trailing); 3821"];
3821 [label="return 'implicit'; 3822"];
3822 [label="FullWidth = this.Text.Length; 3823"];
3823 [label="FullWidth 3824"];
3824 [label="return 'implicit'; 3825"];
3825 [label="FullWidth = this.Text.Length; 3826"];
3826 [label="FullWidth 3827"];
3827 [label="this.AdjustFlagsAndWidth(leading); 3828"];
3828 [label="return 'implicit'; 3829"];
3829 [label="FullWidth = this.Text.Length; 3830"];
3830 [label="FullWidth 3831"];
3831 [label="this.AdjustFlagsAndWidth(trailing); 3832"];
3832 [label="return 'implicit'; 3833"];
3833 [label="FullWidth = this.Text.Length; 3834"];
3834 [label="FullWidth 3835"];
3835 [label="this.AdjustFlagsAndWidth(trailing); 3836"];
3836 [label="return 'yield'; 3837"];
3837 [label="FullWidth = this.Text.Length; 3838"];
3838 [label="FullWidth 3839"];
3839 [label="return 'yield'; 3840"];
3840 [label="FullWidth = this.Text.Length; 3841"];
3841 [label="FullWidth 3842"];
3842 [label="this.AdjustFlagsAndWidth(leading); 3843"];
3843 [label="return 'yield'; 3844"];
3844 [label="FullWidth = this.Text.Length; 3845"];
3845 [label="FullWidth 3846"];
3846 [label="this.AdjustFlagsAndWidth(trailing); 3847"];
3847 [label="return 'yield'; 3848"];
3848 [label="FullWidth = this.Text.Length; 3849"];
3849 [label="FullWidth 3850"];
3850 [label="this.AdjustFlagsAndWidth(trailing); 3851"];
3851 [label="return 'partial'; 3852"];
3852 [label="FullWidth = this.Text.Length; 3853"];
3853 [label="FullWidth 3854"];
3854 [label="return 'partial'; 3855"];
3855 [label="FullWidth = this.Text.Length; 3856"];
3856 [label="FullWidth 3857"];
3857 [label="this.AdjustFlagsAndWidth(leading); 3858"];
3858 [label="return 'partial'; 3859"];
3859 [label="FullWidth = this.Text.Length; 3860"];
3860 [label="FullWidth 3861"];
3861 [label="this.AdjustFlagsAndWidth(trailing); 3862"];
3862 [label="return 'partial'; 3863"];
3863 [label="FullWidth = this.Text.Length; 3864"];
3864 [label="FullWidth 3865"];
3865 [label="this.AdjustFlagsAndWidth(trailing); 3866"];
3866 [label="return 'alias'; 3867"];
3867 [label="FullWidth = this.Text.Length; 3868"];
3868 [label="FullWidth 3869"];
3869 [label="return 'alias'; 3870"];
3870 [label="FullWidth = this.Text.Length; 3871"];
3871 [label="FullWidth 3872"];
3872 [label="this.AdjustFlagsAndWidth(leading); 3873"];
3873 [label="return 'alias'; 3874"];
3874 [label="FullWidth = this.Text.Length; 3875"];
3875 [label="FullWidth 3876"];
3876 [label="this.AdjustFlagsAndWidth(trailing); 3877"];
3877 [label="return 'alias'; 3878"];
3878 [label="FullWidth = this.Text.Length; 3879"];
3879 [label="FullWidth 3880"];
3880 [label="this.AdjustFlagsAndWidth(trailing); 3881"];
3881 [label="return 'global'; 3882"];
3882 [label="FullWidth = this.Text.Length; 3883"];
3883 [label="FullWidth 3884"];
3884 [label="return 'global'; 3885"];
3885 [label="FullWidth = this.Text.Length; 3886"];
3886 [label="FullWidth 3887"];
3887 [label="this.AdjustFlagsAndWidth(leading); 3888"];
3888 [label="return 'global'; 3889"];
3889 [label="FullWidth = this.Text.Length; 3890"];
3890 [label="FullWidth 3891"];
3891 [label="this.AdjustFlagsAndWidth(trailing); 3892"];
3892 [label="return 'global'; 3893"];
3893 [label="FullWidth = this.Text.Length; 3894"];
3894 [label="FullWidth 3895"];
3895 [label="this.AdjustFlagsAndWidth(trailing); 3896"];
3896 [label="return 'assembly'; 3897"];
3897 [label="FullWidth = this.Text.Length; 3898"];
3898 [label="FullWidth 3899"];
3899 [label="return 'assembly'; 3900"];
3900 [label="FullWidth = this.Text.Length; 3901"];
3901 [label="FullWidth 3902"];
3902 [label="this.AdjustFlagsAndWidth(leading); 3903"];
3903 [label="return 'assembly'; 3904"];
3904 [label="FullWidth = this.Text.Length; 3905"];
3905 [label="FullWidth 3906"];
3906 [label="this.AdjustFlagsAndWidth(trailing); 3907"];
3907 [label="return 'assembly'; 3908"];
3908 [label="FullWidth = this.Text.Length; 3909"];
3909 [label="FullWidth 3910"];
3910 [label="this.AdjustFlagsAndWidth(trailing); 3911"];
3911 [label="return 'module'; 3912"];
3912 [label="FullWidth = this.Text.Length; 3913"];
3913 [label="FullWidth 3914"];
3914 [label="return 'module'; 3915"];
3915 [label="FullWidth = this.Text.Length; 3916"];
3916 [label="FullWidth 3917"];
3917 [label="this.AdjustFlagsAndWidth(leading); 3918"];
3918 [label="return 'module'; 3919"];
3919 [label="FullWidth = this.Text.Length; 3920"];
3920 [label="FullWidth 3921"];
3921 [label="this.AdjustFlagsAndWidth(trailing); 3922"];
3922 [label="return 'module'; 3923"];
3923 [label="FullWidth = this.Text.Length; 3924"];
3924 [label="FullWidth 3925"];
3925 [label="this.AdjustFlagsAndWidth(trailing); 3926"];
3926 [label="return 'type'; 3927"];
3927 [label="FullWidth = this.Text.Length; 3928"];
3928 [label="FullWidth 3929"];
3929 [label="return 'type'; 3930"];
3930 [label="FullWidth = this.Text.Length; 3931"];
3931 [label="FullWidth 3932"];
3932 [label="this.AdjustFlagsAndWidth(leading); 3933"];
3933 [label="return 'type'; 3934"];
3934 [label="FullWidth = this.Text.Length; 3935"];
3935 [label="FullWidth 3936"];
3936 [label="this.AdjustFlagsAndWidth(trailing); 3937"];
3937 [label="return 'type'; 3938"];
3938 [label="FullWidth = this.Text.Length; 3939"];
3939 [label="FullWidth 3940"];
3940 [label="this.AdjustFlagsAndWidth(trailing); 3941"];
3941 [label="return 'field'; 3942"];
3942 [label="FullWidth = this.Text.Length; 3943"];
3943 [label="FullWidth 3944"];
3944 [label="return 'field'; 3945"];
3945 [label="FullWidth = this.Text.Length; 3946"];
3946 [label="FullWidth 3947"];
3947 [label="this.AdjustFlagsAndWidth(leading); 3948"];
3948 [label="return 'field'; 3949"];
3949 [label="FullWidth = this.Text.Length; 3950"];
3950 [label="FullWidth 3951"];
3951 [label="this.AdjustFlagsAndWidth(trailing); 3952"];
3952 [label="return 'field'; 3953"];
3953 [label="FullWidth = this.Text.Length; 3954"];
3954 [label="FullWidth 3955"];
3955 [label="this.AdjustFlagsAndWidth(trailing); 3956"];
3956 [label="return 'method'; 3957"];
3957 [label="FullWidth = this.Text.Length; 3958"];
3958 [label="FullWidth 3959"];
3959 [label="return 'method'; 3960"];
3960 [label="FullWidth = this.Text.Length; 3961"];
3961 [label="FullWidth 3962"];
3962 [label="this.AdjustFlagsAndWidth(leading); 3963"];
3963 [label="return 'method'; 3964"];
3964 [label="FullWidth = this.Text.Length; 3965"];
3965 [label="FullWidth 3966"];
3966 [label="this.AdjustFlagsAndWidth(trailing); 3967"];
3967 [label="return 'method'; 3968"];
3968 [label="FullWidth = this.Text.Length; 3969"];
3969 [label="FullWidth 3970"];
3970 [label="this.AdjustFlagsAndWidth(trailing); 3971"];
3971 [label="return 'param'; 3972"];
3972 [label="FullWidth = this.Text.Length; 3973"];
3973 [label="FullWidth 3974"];
3974 [label="return 'param'; 3975"];
3975 [label="FullWidth = this.Text.Length; 3976"];
3976 [label="FullWidth 3977"];
3977 [label="this.AdjustFlagsAndWidth(leading); 3978"];
3978 [label="return 'param'; 3979"];
3979 [label="FullWidth = this.Text.Length; 3980"];
3980 [label="FullWidth 3981"];
3981 [label="this.AdjustFlagsAndWidth(trailing); 3982"];
3982 [label="return 'param'; 3983"];
3983 [label="FullWidth = this.Text.Length; 3984"];
3984 [label="FullWidth 3985"];
3985 [label="this.AdjustFlagsAndWidth(trailing); 3986"];
3986 [label="return 'property'; 3987"];
3987 [label="FullWidth = this.Text.Length; 3988"];
3988 [label="FullWidth 3989"];
3989 [label="return 'property'; 3990"];
3990 [label="FullWidth = this.Text.Length; 3991"];
3991 [label="FullWidth 3992"];
3992 [label="this.AdjustFlagsAndWidth(leading); 3993"];
3993 [label="return 'property'; 3994"];
3994 [label="FullWidth = this.Text.Length; 3995"];
3995 [label="FullWidth 3996"];
3996 [label="this.AdjustFlagsAndWidth(trailing); 3997"];
3997 [label="return 'property'; 3998"];
3998 [label="FullWidth = this.Text.Length; 3999"];
3999 [label="FullWidth 4000"];
4000 [label="this.AdjustFlagsAndWidth(trailing); 4001"];
4001 [label="return 'typevar'; 4002"];
4002 [label="FullWidth = this.Text.Length; 4003"];
4003 [label="FullWidth 4004"];
4004 [label="return 'typevar'; 4005"];
4005 [label="FullWidth = this.Text.Length; 4006"];
4006 [label="FullWidth 4007"];
4007 [label="this.AdjustFlagsAndWidth(leading); 4008"];
4008 [label="return 'typevar'; 4009"];
4009 [label="FullWidth = this.Text.Length; 4010"];
4010 [label="FullWidth 4011"];
4011 [label="this.AdjustFlagsAndWidth(trailing); 4012"];
4012 [label="return 'typevar'; 4013"];
4013 [label="FullWidth = this.Text.Length; 4014"];
4014 [label="FullWidth 4015"];
4015 [label="this.AdjustFlagsAndWidth(trailing); 4016"];
4016 [label="return 'get'; 4017"];
4017 [label="FullWidth = this.Text.Length; 4018"];
4018 [label="FullWidth 4019"];
4019 [label="return 'get'; 4020"];
4020 [label="FullWidth = this.Text.Length; 4021"];
4021 [label="FullWidth 4022"];
4022 [label="this.AdjustFlagsAndWidth(leading); 4023"];
4023 [label="return 'get'; 4024"];
4024 [label="FullWidth = this.Text.Length; 4025"];
4025 [label="FullWidth 4026"];
4026 [label="this.AdjustFlagsAndWidth(trailing); 4027"];
4027 [label="return 'get'; 4028"];
4028 [label="FullWidth = this.Text.Length; 4029"];
4029 [label="FullWidth 4030"];
4030 [label="this.AdjustFlagsAndWidth(trailing); 4031"];
4031 [label="return 'set'; 4032"];
4032 [label="FullWidth = this.Text.Length; 4033"];
4033 [label="FullWidth 4034"];
4034 [label="return 'set'; 4035"];
4035 [label="FullWidth = this.Text.Length; 4036"];
4036 [label="FullWidth 4037"];
4037 [label="this.AdjustFlagsAndWidth(leading); 4038"];
4038 [label="return 'set'; 4039"];
4039 [label="FullWidth = this.Text.Length; 4040"];
4040 [label="FullWidth 4041"];
4041 [label="this.AdjustFlagsAndWidth(trailing); 4042"];
4042 [label="return 'set'; 4043"];
4043 [label="FullWidth = this.Text.Length; 4044"];
4044 [label="FullWidth 4045"];
4045 [label="this.AdjustFlagsAndWidth(trailing); 4046"];
4046 [label="return 'add'; 4047"];
4047 [label="FullWidth = this.Text.Length; 4048"];
4048 [label="FullWidth 4049"];
4049 [label="return 'add'; 4050"];
4050 [label="FullWidth = this.Text.Length; 4051"];
4051 [label="FullWidth 4052"];
4052 [label="this.AdjustFlagsAndWidth(leading); 4053"];
4053 [label="return 'add'; 4054"];
4054 [label="FullWidth = this.Text.Length; 4055"];
4055 [label="FullWidth 4056"];
4056 [label="this.AdjustFlagsAndWidth(trailing); 4057"];
4057 [label="return 'add'; 4058"];
4058 [label="FullWidth = this.Text.Length; 4059"];
4059 [label="FullWidth 4060"];
4060 [label="this.AdjustFlagsAndWidth(trailing); 4061"];
4061 [label="return 'remove'; 4062"];
4062 [label="FullWidth = this.Text.Length; 4063"];
4063 [label="FullWidth 4064"];
4064 [label="return 'remove'; 4065"];
4065 [label="FullWidth = this.Text.Length; 4066"];
4066 [label="FullWidth 4067"];
4067 [label="this.AdjustFlagsAndWidth(leading); 4068"];
4068 [label="return 'remove'; 4069"];
4069 [label="FullWidth = this.Text.Length; 4070"];
4070 [label="FullWidth 4071"];
4071 [label="this.AdjustFlagsAndWidth(trailing); 4072"];
4072 [label="return 'remove'; 4073"];
4073 [label="FullWidth = this.Text.Length; 4074"];
4074 [label="FullWidth 4075"];
4075 [label="this.AdjustFlagsAndWidth(trailing); 4076"];
4076 [label="return 'where'; 4077"];
4077 [label="FullWidth = this.Text.Length; 4078"];
4078 [label="FullWidth 4079"];
4079 [label="return 'where'; 4080"];
4080 [label="FullWidth = this.Text.Length; 4081"];
4081 [label="FullWidth 4082"];
4082 [label="this.AdjustFlagsAndWidth(leading); 4083"];
4083 [label="return 'where'; 4084"];
4084 [label="FullWidth = this.Text.Length; 4085"];
4085 [label="FullWidth 4086"];
4086 [label="this.AdjustFlagsAndWidth(trailing); 4087"];
4087 [label="return 'where'; 4088"];
4088 [label="FullWidth = this.Text.Length; 4089"];
4089 [label="FullWidth 4090"];
4090 [label="this.AdjustFlagsAndWidth(trailing); 4091"];
4091 [label="return 'from'; 4092"];
4092 [label="FullWidth = this.Text.Length; 4093"];
4093 [label="FullWidth 4094"];
4094 [label="return 'from'; 4095"];
4095 [label="FullWidth = this.Text.Length; 4096"];
4096 [label="FullWidth 4097"];
4097 [label="this.AdjustFlagsAndWidth(leading); 4098"];
4098 [label="return 'from'; 4099"];
4099 [label="FullWidth = this.Text.Length; 4100"];
4100 [label="FullWidth 4101"];
4101 [label="this.AdjustFlagsAndWidth(trailing); 4102"];
4102 [label="return 'from'; 4103"];
4103 [label="FullWidth = this.Text.Length; 4104"];
4104 [label="FullWidth 4105"];
4105 [label="this.AdjustFlagsAndWidth(trailing); 4106"];
4106 [label="return 'group'; 4107"];
4107 [label="FullWidth = this.Text.Length; 4108"];
4108 [label="FullWidth 4109"];
4109 [label="return 'group'; 4110"];
4110 [label="FullWidth = this.Text.Length; 4111"];
4111 [label="FullWidth 4112"];
4112 [label="this.AdjustFlagsAndWidth(leading); 4113"];
4113 [label="return 'group'; 4114"];
4114 [label="FullWidth = this.Text.Length; 4115"];
4115 [label="FullWidth 4116"];
4116 [label="this.AdjustFlagsAndWidth(trailing); 4117"];
4117 [label="return 'group'; 4118"];
4118 [label="FullWidth = this.Text.Length; 4119"];
4119 [label="FullWidth 4120"];
4120 [label="this.AdjustFlagsAndWidth(trailing); 4121"];
4121 [label="return 'join'; 4122"];
4122 [label="FullWidth = this.Text.Length; 4123"];
4123 [label="FullWidth 4124"];
4124 [label="return 'join'; 4125"];
4125 [label="FullWidth = this.Text.Length; 4126"];
4126 [label="FullWidth 4127"];
4127 [label="this.AdjustFlagsAndWidth(leading); 4128"];
4128 [label="return 'join'; 4129"];
4129 [label="FullWidth = this.Text.Length; 4130"];
4130 [label="FullWidth 4131"];
4131 [label="this.AdjustFlagsAndWidth(trailing); 4132"];
4132 [label="return 'join'; 4133"];
4133 [label="FullWidth = this.Text.Length; 4134"];
4134 [label="FullWidth 4135"];
4135 [label="this.AdjustFlagsAndWidth(trailing); 4136"];
4136 [label="return 'into'; 4137"];
4137 [label="FullWidth = this.Text.Length; 4138"];
4138 [label="FullWidth 4139"];
4139 [label="return 'into'; 4140"];
4140 [label="FullWidth = this.Text.Length; 4141"];
4141 [label="FullWidth 4142"];
4142 [label="this.AdjustFlagsAndWidth(leading); 4143"];
4143 [label="return 'into'; 4144"];
4144 [label="FullWidth = this.Text.Length; 4145"];
4145 [label="FullWidth 4146"];
4146 [label="this.AdjustFlagsAndWidth(trailing); 4147"];
4147 [label="return 'into'; 4148"];
4148 [label="FullWidth = this.Text.Length; 4149"];
4149 [label="FullWidth 4150"];
4150 [label="this.AdjustFlagsAndWidth(trailing); 4151"];
4151 [label="return 'let'; 4152"];
4152 [label="FullWidth = this.Text.Length; 4153"];
4153 [label="FullWidth 4154"];
4154 [label="return 'let'; 4155"];
4155 [label="FullWidth = this.Text.Length; 4156"];
4156 [label="FullWidth 4157"];
4157 [label="this.AdjustFlagsAndWidth(leading); 4158"];
4158 [label="return 'let'; 4159"];
4159 [label="FullWidth = this.Text.Length; 4160"];
4160 [label="FullWidth 4161"];
4161 [label="this.AdjustFlagsAndWidth(trailing); 4162"];
4162 [label="return 'let'; 4163"];
4163 [label="FullWidth = this.Text.Length; 4164"];
4164 [label="FullWidth 4165"];
4165 [label="this.AdjustFlagsAndWidth(trailing); 4166"];
4166 [label="return 'by'; 4167"];
4167 [label="FullWidth = this.Text.Length; 4168"];
4168 [label="FullWidth 4169"];
4169 [label="return 'by'; 4170"];
4170 [label="FullWidth = this.Text.Length; 4171"];
4171 [label="FullWidth 4172"];
4172 [label="this.AdjustFlagsAndWidth(leading); 4173"];
4173 [label="return 'by'; 4174"];
4174 [label="FullWidth = this.Text.Length; 4175"];
4175 [label="FullWidth 4176"];
4176 [label="this.AdjustFlagsAndWidth(trailing); 4177"];
4177 [label="return 'by'; 4178"];
4178 [label="FullWidth = this.Text.Length; 4179"];
4179 [label="FullWidth 4180"];
4180 [label="this.AdjustFlagsAndWidth(trailing); 4181"];
4181 [label="return 'select'; 4182"];
4182 [label="FullWidth = this.Text.Length; 4183"];
4183 [label="FullWidth 4184"];
4184 [label="return 'select'; 4185"];
4185 [label="FullWidth = this.Text.Length; 4186"];
4186 [label="FullWidth 4187"];
4187 [label="this.AdjustFlagsAndWidth(leading); 4188"];
4188 [label="return 'select'; 4189"];
4189 [label="FullWidth = this.Text.Length; 4190"];
4190 [label="FullWidth 4191"];
4191 [label="this.AdjustFlagsAndWidth(trailing); 4192"];
4192 [label="return 'select'; 4193"];
4193 [label="FullWidth = this.Text.Length; 4194"];
4194 [label="FullWidth 4195"];
4195 [label="this.AdjustFlagsAndWidth(trailing); 4196"];
4196 [label="return 'orderby'; 4197"];
4197 [label="FullWidth = this.Text.Length; 4198"];
4198 [label="FullWidth 4199"];
4199 [label="return 'orderby'; 4200"];
4200 [label="FullWidth = this.Text.Length; 4201"];
4201 [label="FullWidth 4202"];
4202 [label="this.AdjustFlagsAndWidth(leading); 4203"];
4203 [label="return 'orderby'; 4204"];
4204 [label="FullWidth = this.Text.Length; 4205"];
4205 [label="FullWidth 4206"];
4206 [label="this.AdjustFlagsAndWidth(trailing); 4207"];
4207 [label="return 'orderby'; 4208"];
4208 [label="FullWidth = this.Text.Length; 4209"];
4209 [label="FullWidth 4210"];
4210 [label="this.AdjustFlagsAndWidth(trailing); 4211"];
4211 [label="return 'on'; 4212"];
4212 [label="FullWidth = this.Text.Length; 4213"];
4213 [label="FullWidth 4214"];
4214 [label="return 'on'; 4215"];
4215 [label="FullWidth = this.Text.Length; 4216"];
4216 [label="FullWidth 4217"];
4217 [label="this.AdjustFlagsAndWidth(leading); 4218"];
4218 [label="return 'on'; 4219"];
4219 [label="FullWidth = this.Text.Length; 4220"];
4220 [label="FullWidth 4221"];
4221 [label="this.AdjustFlagsAndWidth(trailing); 4222"];
4222 [label="return 'on'; 4223"];
4223 [label="FullWidth = this.Text.Length; 4224"];
4224 [label="FullWidth 4225"];
4225 [label="this.AdjustFlagsAndWidth(trailing); 4226"];
4226 [label="return 'equals'; 4227"];
4227 [label="FullWidth = this.Text.Length; 4228"];
4228 [label="FullWidth 4229"];
4229 [label="return 'equals'; 4230"];
4230 [label="FullWidth = this.Text.Length; 4231"];
4231 [label="FullWidth 4232"];
4232 [label="this.AdjustFlagsAndWidth(leading); 4233"];
4233 [label="return 'equals'; 4234"];
4234 [label="FullWidth = this.Text.Length; 4235"];
4235 [label="FullWidth 4236"];
4236 [label="this.AdjustFlagsAndWidth(trailing); 4237"];
4237 [label="return 'equals'; 4238"];
4238 [label="FullWidth = this.Text.Length; 4239"];
4239 [label="FullWidth 4240"];
4240 [label="this.AdjustFlagsAndWidth(trailing); 4241"];
4241 [label="return 'ascending'; 4242"];
4242 [label="FullWidth = this.Text.Length; 4243"];
4243 [label="FullWidth 4244"];
4244 [label="return 'ascending'; 4245"];
4245 [label="FullWidth = this.Text.Length; 4246"];
4246 [label="FullWidth 4247"];
4247 [label="this.AdjustFlagsAndWidth(leading); 4248"];
4248 [label="return 'ascending'; 4249"];
4249 [label="FullWidth = this.Text.Length; 4250"];
4250 [label="FullWidth 4251"];
4251 [label="this.AdjustFlagsAndWidth(trailing); 4252"];
4252 [label="return 'ascending'; 4253"];
4253 [label="FullWidth = this.Text.Length; 4254"];
4254 [label="FullWidth 4255"];
4255 [label="this.AdjustFlagsAndWidth(trailing); 4256"];
4256 [label="return 'descending'; 4257"];
4257 [label="FullWidth = this.Text.Length; 4258"];
4258 [label="FullWidth 4259"];
4259 [label="return 'descending'; 4260"];
4260 [label="FullWidth = this.Text.Length; 4261"];
4261 [label="FullWidth 4262"];
4262 [label="this.AdjustFlagsAndWidth(leading); 4263"];
4263 [label="return 'descending'; 4264"];
4264 [label="FullWidth = this.Text.Length; 4265"];
4265 [label="FullWidth 4266"];
4266 [label="this.AdjustFlagsAndWidth(trailing); 4267"];
4267 [label="return 'descending'; 4268"];
4268 [label="FullWidth = this.Text.Length; 4269"];
4269 [label="FullWidth 4270"];
4270 [label="this.AdjustFlagsAndWidth(trailing); 4271"];
4271 [label="return 'nameof'; 4272"];
4272 [label="FullWidth = this.Text.Length; 4273"];
4273 [label="FullWidth 4274"];
4274 [label="return 'nameof'; 4275"];
4275 [label="FullWidth = this.Text.Length; 4276"];
4276 [label="FullWidth 4277"];
4277 [label="this.AdjustFlagsAndWidth(leading); 4278"];
4278 [label="return 'nameof'; 4279"];
4279 [label="FullWidth = this.Text.Length; 4280"];
4280 [label="FullWidth 4281"];
4281 [label="this.AdjustFlagsAndWidth(trailing); 4282"];
4282 [label="return 'nameof'; 4283"];
4283 [label="FullWidth = this.Text.Length; 4284"];
4284 [label="FullWidth 4285"];
4285 [label="this.AdjustFlagsAndWidth(trailing); 4286"];
4286 [label="return 'async'; 4287"];
4287 [label="FullWidth = this.Text.Length; 4288"];
4288 [label="FullWidth 4289"];
4289 [label="return 'async'; 4290"];
4290 [label="FullWidth = this.Text.Length; 4291"];
4291 [label="FullWidth 4292"];
4292 [label="this.AdjustFlagsAndWidth(leading); 4293"];
4293 [label="return 'async'; 4294"];
4294 [label="FullWidth = this.Text.Length; 4295"];
4295 [label="FullWidth 4296"];
4296 [label="this.AdjustFlagsAndWidth(trailing); 4297"];
4297 [label="return 'async'; 4298"];
4298 [label="FullWidth = this.Text.Length; 4299"];
4299 [label="FullWidth 4300"];
4300 [label="this.AdjustFlagsAndWidth(trailing); 4301"];
4301 [label="return 'await'; 4302"];
4302 [label="FullWidth = this.Text.Length; 4303"];
4303 [label="FullWidth 4304"];
4304 [label="return 'await'; 4305"];
4305 [label="FullWidth = this.Text.Length; 4306"];
4306 [label="FullWidth 4307"];
4307 [label="this.AdjustFlagsAndWidth(leading); 4308"];
4308 [label="return 'await'; 4309"];
4309 [label="FullWidth = this.Text.Length; 4310"];
4310 [label="FullWidth 4311"];
4311 [label="this.AdjustFlagsAndWidth(trailing); 4312"];
4312 [label="return 'await'; 4313"];
4313 [label="FullWidth = this.Text.Length; 4314"];
4314 [label="FullWidth 4315"];
4315 [label="this.AdjustFlagsAndWidth(trailing); 4316"];
4316 [label="return 'when'; 4317"];
4317 [label="FullWidth = this.Text.Length; 4318"];
4318 [label="FullWidth 4319"];
4319 [label="return 'when'; 4320"];
4320 [label="FullWidth = this.Text.Length; 4321"];
4321 [label="FullWidth 4322"];
4322 [label="this.AdjustFlagsAndWidth(leading); 4323"];
4323 [label="return 'when'; 4324"];
4324 [label="FullWidth = this.Text.Length; 4325"];
4325 [label="FullWidth 4326"];
4326 [label="this.AdjustFlagsAndWidth(trailing); 4327"];
4327 [label="return 'when'; 4328"];
4328 [label="FullWidth = this.Text.Length; 4329"];
4329 [label="FullWidth 4330"];
4330 [label="this.AdjustFlagsAndWidth(trailing); 4331"];
4331 [label="return 'or'; 4332"];
4332 [label="FullWidth = this.Text.Length; 4333"];
4333 [label="FullWidth 4334"];
4334 [label="return 'or'; 4335"];
4335 [label="FullWidth = this.Text.Length; 4336"];
4336 [label="FullWidth 4337"];
4337 [label="this.AdjustFlagsAndWidth(leading); 4338"];
4338 [label="return 'or'; 4339"];
4339 [label="FullWidth = this.Text.Length; 4340"];
4340 [label="FullWidth 4341"];
4341 [label="this.AdjustFlagsAndWidth(trailing); 4342"];
4342 [label="return 'or'; 4343"];
4343 [label="FullWidth = this.Text.Length; 4344"];
4344 [label="FullWidth 4345"];
4345 [label="this.AdjustFlagsAndWidth(trailing); 4346"];
4346 [label="return 'and'; 4347"];
4347 [label="FullWidth = this.Text.Length; 4348"];
4348 [label="FullWidth 4349"];
4349 [label="return 'and'; 4350"];
4350 [label="FullWidth = this.Text.Length; 4351"];
4351 [label="FullWidth 4352"];
4352 [label="this.AdjustFlagsAndWidth(leading); 4353"];
4353 [label="return 'and'; 4354"];
4354 [label="FullWidth = this.Text.Length; 4355"];
4355 [label="FullWidth 4356"];
4356 [label="this.AdjustFlagsAndWidth(trailing); 4357"];
4357 [label="return 'and'; 4358"];
4358 [label="FullWidth = this.Text.Length; 4359"];
4359 [label="FullWidth 4360"];
4360 [label="this.AdjustFlagsAndWidth(trailing); 4361"];
4361 [label="return 'not'; 4362"];
4362 [label="FullWidth = this.Text.Length; 4363"];
4363 [label="FullWidth 4364"];
4364 [label="return 'not'; 4365"];
4365 [label="FullWidth = this.Text.Length; 4366"];
4366 [label="FullWidth 4367"];
4367 [label="this.AdjustFlagsAndWidth(leading); 4368"];
4368 [label="return 'not'; 4369"];
4369 [label="FullWidth = this.Text.Length; 4370"];
4370 [label="FullWidth 4371"];
4371 [label="this.AdjustFlagsAndWidth(trailing); 4372"];
4372 [label="return 'not'; 4373"];
4373 [label="FullWidth = this.Text.Length; 4374"];
4374 [label="FullWidth 4375"];
4375 [label="this.AdjustFlagsAndWidth(trailing); 4376"];
4376 [label="return 'data'; 4377"];
4377 [label="FullWidth = this.Text.Length; 4378"];
4378 [label="FullWidth 4379"];
4379 [label="return 'data'; 4380"];
4380 [label="FullWidth = this.Text.Length; 4381"];
4381 [label="FullWidth 4382"];
4382 [label="this.AdjustFlagsAndWidth(leading); 4383"];
4383 [label="return 'data'; 4384"];
4384 [label="FullWidth = this.Text.Length; 4385"];
4385 [label="FullWidth 4386"];
4386 [label="this.AdjustFlagsAndWidth(trailing); 4387"];
4387 [label="return 'data'; 4388"];
4388 [label="FullWidth = this.Text.Length; 4389"];
4389 [label="FullWidth 4390"];
4390 [label="this.AdjustFlagsAndWidth(trailing); 4391"];
4391 [label="return 'with'; 4392"];
4392 [label="FullWidth = this.Text.Length; 4393"];
4393 [label="FullWidth 4394"];
4394 [label="return 'with'; 4395"];
4395 [label="FullWidth = this.Text.Length; 4396"];
4396 [label="FullWidth 4397"];
4397 [label="this.AdjustFlagsAndWidth(leading); 4398"];
4398 [label="return 'with'; 4399"];
4399 [label="FullWidth = this.Text.Length; 4400"];
4400 [label="FullWidth 4401"];
4401 [label="this.AdjustFlagsAndWidth(trailing); 4402"];
4402 [label="return 'with'; 4403"];
4403 [label="FullWidth = this.Text.Length; 4404"];
4404 [label="FullWidth 4405"];
4405 [label="this.AdjustFlagsAndWidth(trailing); 4406"];
4406 [label="return 'init'; 4407"];
4407 [label="FullWidth = this.Text.Length; 4408"];
4408 [label="FullWidth 4409"];
4409 [label="return 'init'; 4410"];
4410 [label="FullWidth = this.Text.Length; 4411"];
4411 [label="FullWidth 4412"];
4412 [label="this.AdjustFlagsAndWidth(leading); 4413"];
4413 [label="return 'init'; 4414"];
4414 [label="FullWidth = this.Text.Length; 4415"];
4415 [label="FullWidth 4416"];
4416 [label="this.AdjustFlagsAndWidth(trailing); 4417"];
4417 [label="return 'init'; 4418"];
4418 [label="FullWidth = this.Text.Length; 4419"];
4419 [label="FullWidth 4420"];
4420 [label="this.AdjustFlagsAndWidth(trailing); 4421"];
4421 [label="return 'record'; 4422"];
4422 [label="FullWidth = this.Text.Length; 4423"];
4423 [label="FullWidth 4424"];
4424 [label="return 'record'; 4425"];
4425 [label="FullWidth = this.Text.Length; 4426"];
4426 [label="FullWidth 4427"];
4427 [label="this.AdjustFlagsAndWidth(leading); 4428"];
4428 [label="return 'record'; 4429"];
4429 [label="FullWidth = this.Text.Length; 4430"];
4430 [label="FullWidth 4431"];
4431 [label="this.AdjustFlagsAndWidth(trailing); 4432"];
4432 [label="return 'record'; 4433"];
4433 [label="FullWidth = this.Text.Length; 4434"];
4434 [label="FullWidth 4435"];
4435 [label="this.AdjustFlagsAndWidth(trailing); 4436"];
4436 [label="return 'managed'; 4437"];
4437 [label="FullWidth = this.Text.Length; 4438"];
4438 [label="FullWidth 4439"];
4439 [label="return 'managed'; 4440"];
4440 [label="FullWidth = this.Text.Length; 4441"];
4441 [label="FullWidth 4442"];
4442 [label="this.AdjustFlagsAndWidth(leading); 4443"];
4443 [label="return 'managed'; 4444"];
4444 [label="FullWidth = this.Text.Length; 4445"];
4445 [label="FullWidth 4446"];
4446 [label="this.AdjustFlagsAndWidth(trailing); 4447"];
4447 [label="return 'managed'; 4448"];
4448 [label="FullWidth = this.Text.Length; 4449"];
4449 [label="FullWidth 4450"];
4450 [label="this.AdjustFlagsAndWidth(trailing); 4451"];
4451 [label="return 'unmanaged'; 4452"];
4452 [label="FullWidth = this.Text.Length; 4453"];
4453 [label="FullWidth 4454"];
4454 [label="return 'unmanaged'; 4455"];
4455 [label="FullWidth = this.Text.Length; 4456"];
4456 [label="FullWidth 4457"];
4457 [label="this.AdjustFlagsAndWidth(leading); 4458"];
4458 [label="return 'unmanaged'; 4459"];
4459 [label="FullWidth = this.Text.Length; 4460"];
4460 [label="FullWidth 4461"];
4461 [label="this.AdjustFlagsAndWidth(trailing); 4462"];
4462 [label="return 'unmanaged'; 4463"];
4463 [label="FullWidth = this.Text.Length; 4464"];
4464 [label="FullWidth 4465"];
4465 [label="this.AdjustFlagsAndWidth(trailing); 4466"];
4466 [label="return 'elif'; 4467"];
4467 [label="FullWidth = this.Text.Length; 4468"];
4468 [label="FullWidth 4469"];
4469 [label="return 'elif'; 4470"];
4470 [label="FullWidth = this.Text.Length; 4471"];
4471 [label="FullWidth 4472"];
4472 [label="this.AdjustFlagsAndWidth(leading); 4473"];
4473 [label="return 'elif'; 4474"];
4474 [label="FullWidth = this.Text.Length; 4475"];
4475 [label="FullWidth 4476"];
4476 [label="this.AdjustFlagsAndWidth(trailing); 4477"];
4477 [label="return 'elif'; 4478"];
4478 [label="FullWidth = this.Text.Length; 4479"];
4479 [label="FullWidth 4480"];
4480 [label="this.AdjustFlagsAndWidth(trailing); 4481"];
4481 [label="return 'endif'; 4482"];
4482 [label="FullWidth = this.Text.Length; 4483"];
4483 [label="FullWidth 4484"];
4484 [label="return 'endif'; 4485"];
4485 [label="FullWidth = this.Text.Length; 4486"];
4486 [label="FullWidth 4487"];
4487 [label="this.AdjustFlagsAndWidth(leading); 4488"];
4488 [label="return 'endif'; 4489"];
4489 [label="FullWidth = this.Text.Length; 4490"];
4490 [label="FullWidth 4491"];
4491 [label="this.AdjustFlagsAndWidth(trailing); 4492"];
4492 [label="return 'endif'; 4493"];
4493 [label="FullWidth = this.Text.Length; 4494"];
4494 [label="FullWidth 4495"];
4495 [label="this.AdjustFlagsAndWidth(trailing); 4496"];
4496 [label="return 'region'; 4497"];
4497 [label="FullWidth = this.Text.Length; 4498"];
4498 [label="FullWidth 4499"];
4499 [label="return 'region'; 4500"];
4500 [label="FullWidth = this.Text.Length; 4501"];
4501 [label="FullWidth 4502"];
4502 [label="this.AdjustFlagsAndWidth(leading); 4503"];
4503 [label="return 'region'; 4504"];
4504 [label="FullWidth = this.Text.Length; 4505"];
4505 [label="FullWidth 4506"];
4506 [label="this.AdjustFlagsAndWidth(trailing); 4507"];
4507 [label="return 'region'; 4508"];
4508 [label="FullWidth = this.Text.Length; 4509"];
4509 [label="FullWidth 4510"];
4510 [label="this.AdjustFlagsAndWidth(trailing); 4511"];
4511 [label="return 'endregion'; 4512"];
4512 [label="FullWidth = this.Text.Length; 4513"];
4513 [label="FullWidth 4514"];
4514 [label="return 'endregion'; 4515"];
4515 [label="FullWidth = this.Text.Length; 4516"];
4516 [label="FullWidth 4517"];
4517 [label="this.AdjustFlagsAndWidth(leading); 4518"];
4518 [label="return 'endregion'; 4519"];
4519 [label="FullWidth = this.Text.Length; 4520"];
4520 [label="FullWidth 4521"];
4521 [label="this.AdjustFlagsAndWidth(trailing); 4522"];
4522 [label="return 'endregion'; 4523"];
4523 [label="FullWidth = this.Text.Length; 4524"];
4524 [label="FullWidth 4525"];
4525 [label="this.AdjustFlagsAndWidth(trailing); 4526"];
4526 [label="return 'define'; 4527"];
4527 [label="FullWidth = this.Text.Length; 4528"];
4528 [label="FullWidth 4529"];
4529 [label="return 'define'; 4530"];
4530 [label="FullWidth = this.Text.Length; 4531"];
4531 [label="FullWidth 4532"];
4532 [label="this.AdjustFlagsAndWidth(leading); 4533"];
4533 [label="return 'define'; 4534"];
4534 [label="FullWidth = this.Text.Length; 4535"];
4535 [label="FullWidth 4536"];
4536 [label="this.AdjustFlagsAndWidth(trailing); 4537"];
4537 [label="return 'define'; 4538"];
4538 [label="FullWidth = this.Text.Length; 4539"];
4539 [label="FullWidth 4540"];
4540 [label="this.AdjustFlagsAndWidth(trailing); 4541"];
4541 [label="return 'undef'; 4542"];
4542 [label="FullWidth = this.Text.Length; 4543"];
4543 [label="FullWidth 4544"];
4544 [label="return 'undef'; 4545"];
4545 [label="FullWidth = this.Text.Length; 4546"];
4546 [label="FullWidth 4547"];
4547 [label="this.AdjustFlagsAndWidth(leading); 4548"];
4548 [label="return 'undef'; 4549"];
4549 [label="FullWidth = this.Text.Length; 4550"];
4550 [label="FullWidth 4551"];
4551 [label="this.AdjustFlagsAndWidth(trailing); 4552"];
4552 [label="return 'undef'; 4553"];
4553 [label="FullWidth = this.Text.Length; 4554"];
4554 [label="FullWidth 4555"];
4555 [label="this.AdjustFlagsAndWidth(trailing); 4556"];
4556 [label="return 'warning'; 4557"];
4557 [label="FullWidth = this.Text.Length; 4558"];
4558 [label="FullWidth 4559"];
4559 [label="return 'warning'; 4560"];
4560 [label="FullWidth = this.Text.Length; 4561"];
4561 [label="FullWidth 4562"];
4562 [label="this.AdjustFlagsAndWidth(leading); 4563"];
4563 [label="return 'warning'; 4564"];
4564 [label="FullWidth = this.Text.Length; 4565"];
4565 [label="FullWidth 4566"];
4566 [label="this.AdjustFlagsAndWidth(trailing); 4567"];
4567 [label="return 'warning'; 4568"];
4568 [label="FullWidth = this.Text.Length; 4569"];
4569 [label="FullWidth 4570"];
4570 [label="this.AdjustFlagsAndWidth(trailing); 4571"];
4571 [label="return 'error'; 4572"];
4572 [label="FullWidth = this.Text.Length; 4573"];
4573 [label="FullWidth 4574"];
4574 [label="return 'error'; 4575"];
4575 [label="FullWidth = this.Text.Length; 4576"];
4576 [label="FullWidth 4577"];
4577 [label="this.AdjustFlagsAndWidth(leading); 4578"];
4578 [label="return 'error'; 4579"];
4579 [label="FullWidth = this.Text.Length; 4580"];
4580 [label="FullWidth 4581"];
4581 [label="this.AdjustFlagsAndWidth(trailing); 4582"];
4582 [label="return 'error'; 4583"];
4583 [label="FullWidth = this.Text.Length; 4584"];
4584 [label="FullWidth 4585"];
4585 [label="this.AdjustFlagsAndWidth(trailing); 4586"];
4586 [label="return 'line'; 4587"];
4587 [label="FullWidth = this.Text.Length; 4588"];
4588 [label="FullWidth 4589"];
4589 [label="return 'line'; 4590"];
4590 [label="FullWidth = this.Text.Length; 4591"];
4591 [label="FullWidth 4592"];
4592 [label="this.AdjustFlagsAndWidth(leading); 4593"];
4593 [label="return 'line'; 4594"];
4594 [label="FullWidth = this.Text.Length; 4595"];
4595 [label="FullWidth 4596"];
4596 [label="this.AdjustFlagsAndWidth(trailing); 4597"];
4597 [label="return 'line'; 4598"];
4598 [label="FullWidth = this.Text.Length; 4599"];
4599 [label="FullWidth 4600"];
4600 [label="this.AdjustFlagsAndWidth(trailing); 4601"];
4601 [label="return 'pragma'; 4602"];
4602 [label="FullWidth = this.Text.Length; 4603"];
4603 [label="FullWidth 4604"];
4604 [label="return 'pragma'; 4605"];
4605 [label="FullWidth = this.Text.Length; 4606"];
4606 [label="FullWidth 4607"];
4607 [label="this.AdjustFlagsAndWidth(leading); 4608"];
4608 [label="return 'pragma'; 4609"];
4609 [label="FullWidth = this.Text.Length; 4610"];
4610 [label="FullWidth 4611"];
4611 [label="this.AdjustFlagsAndWidth(trailing); 4612"];
4612 [label="return 'pragma'; 4613"];
4613 [label="FullWidth = this.Text.Length; 4614"];
4614 [label="FullWidth 4615"];
4615 [label="this.AdjustFlagsAndWidth(trailing); 4616"];
4616 [label="return 'hidden'; 4617"];
4617 [label="FullWidth = this.Text.Length; 4618"];
4618 [label="FullWidth 4619"];
4619 [label="return 'hidden'; 4620"];
4620 [label="FullWidth = this.Text.Length; 4621"];
4621 [label="FullWidth 4622"];
4622 [label="this.AdjustFlagsAndWidth(leading); 4623"];
4623 [label="return 'hidden'; 4624"];
4624 [label="FullWidth = this.Text.Length; 4625"];
4625 [label="FullWidth 4626"];
4626 [label="this.AdjustFlagsAndWidth(trailing); 4627"];
4627 [label="return 'hidden'; 4628"];
4628 [label="FullWidth = this.Text.Length; 4629"];
4629 [label="FullWidth 4630"];
4630 [label="this.AdjustFlagsAndWidth(trailing); 4631"];
4631 [label="return 'checksum'; 4632"];
4632 [label="FullWidth = this.Text.Length; 4633"];
4633 [label="FullWidth 4634"];
4634 [label="return 'checksum'; 4635"];
4635 [label="FullWidth = this.Text.Length; 4636"];
4636 [label="FullWidth 4637"];
4637 [label="this.AdjustFlagsAndWidth(leading); 4638"];
4638 [label="return 'checksum'; 4639"];
4639 [label="FullWidth = this.Text.Length; 4640"];
4640 [label="FullWidth 4641"];
4641 [label="this.AdjustFlagsAndWidth(trailing); 4642"];
4642 [label="return 'checksum'; 4643"];
4643 [label="FullWidth = this.Text.Length; 4644"];
4644 [label="FullWidth 4645"];
4645 [label="this.AdjustFlagsAndWidth(trailing); 4646"];
4646 [label="return 'disable'; 4647"];
4647 [label="FullWidth = this.Text.Length; 4648"];
4648 [label="FullWidth 4649"];
4649 [label="return 'disable'; 4650"];
4650 [label="FullWidth = this.Text.Length; 4651"];
4651 [label="FullWidth 4652"];
4652 [label="this.AdjustFlagsAndWidth(leading); 4653"];
4653 [label="return 'disable'; 4654"];
4654 [label="FullWidth = this.Text.Length; 4655"];
4655 [label="FullWidth 4656"];
4656 [label="this.AdjustFlagsAndWidth(trailing); 4657"];
4657 [label="return 'disable'; 4658"];
4658 [label="FullWidth = this.Text.Length; 4659"];
4659 [label="FullWidth 4660"];
4660 [label="this.AdjustFlagsAndWidth(trailing); 4661"];
4661 [label="return 'restore'; 4662"];
4662 [label="FullWidth = this.Text.Length; 4663"];
4663 [label="FullWidth 4664"];
4664 [label="return 'restore'; 4665"];
4665 [label="FullWidth = this.Text.Length; 4666"];
4666 [label="FullWidth 4667"];
4667 [label="this.AdjustFlagsAndWidth(leading); 4668"];
4668 [label="return 'restore'; 4669"];
4669 [label="FullWidth = this.Text.Length; 4670"];
4670 [label="FullWidth 4671"];
4671 [label="this.AdjustFlagsAndWidth(trailing); 4672"];
4672 [label="return 'restore'; 4673"];
4673 [label="FullWidth = this.Text.Length; 4674"];
4674 [label="FullWidth 4675"];
4675 [label="this.AdjustFlagsAndWidth(trailing); 4676"];
4676 [label="return 'r'; 4677"];
4677 [label="FullWidth = this.Text.Length; 4678"];
4678 [label="FullWidth 4679"];
4679 [label="return 'r'; 4680"];
4680 [label="FullWidth = this.Text.Length; 4681"];
4681 [label="FullWidth 4682"];
4682 [label="this.AdjustFlagsAndWidth(leading); 4683"];
4683 [label="return 'r'; 4684"];
4684 [label="FullWidth = this.Text.Length; 4685"];
4685 [label="FullWidth 4686"];
4686 [label="this.AdjustFlagsAndWidth(trailing); 4687"];
4687 [label="return 'r'; 4688"];
4688 [label="FullWidth = this.Text.Length; 4689"];
4689 [label="FullWidth 4690"];
4690 [label="this.AdjustFlagsAndWidth(trailing); 4691"];
4691 [label="return '$\\''; 4692"];
4692 [label="FullWidth = this.Text.Length; 4693"];
4693 [label="FullWidth 4694"];
4694 [label="return '$\\''; 4695"];
4695 [label="FullWidth = this.Text.Length; 4696"];
4696 [label="FullWidth 4697"];
4697 [label="this.AdjustFlagsAndWidth(leading); 4698"];
4698 [label="return '$\\''; 4699"];
4699 [label="FullWidth = this.Text.Length; 4700"];
4700 [label="FullWidth 4701"];
4701 [label="this.AdjustFlagsAndWidth(trailing); 4702"];
4702 [label="return '$\\''; 4703"];
4703 [label="FullWidth = this.Text.Length; 4704"];
4704 [label="FullWidth 4705"];
4705 [label="this.AdjustFlagsAndWidth(trailing); 4706"];
4706 [label="return '\\''; 4707"];
4707 [label="FullWidth = this.Text.Length; 4708"];
4708 [label="FullWidth 4709"];
4709 [label="return '\\''; 4710"];
4710 [label="FullWidth = this.Text.Length; 4711"];
4711 [label="FullWidth 4712"];
4712 [label="this.AdjustFlagsAndWidth(leading); 4713"];
4713 [label="return '\\''; 4714"];
4714 [label="FullWidth = this.Text.Length; 4715"];
4715 [label="FullWidth 4716"];
4716 [label="this.AdjustFlagsAndWidth(trailing); 4717"];
4717 [label="return '\\''; 4718"];
4718 [label="FullWidth = this.Text.Length; 4719"];
4719 [label="FullWidth 4720"];
4720 [label="this.AdjustFlagsAndWidth(trailing); 4721"];
4721 [label="return '$@\\''; 4722"];
4722 [label="FullWidth = this.Text.Length; 4723"];
4723 [label="FullWidth 4724"];
4724 [label="return '$@\\''; 4725"];
4725 [label="FullWidth = this.Text.Length; 4726"];
4726 [label="FullWidth 4727"];
4727 [label="this.AdjustFlagsAndWidth(leading); 4728"];
4728 [label="return '$@\\''; 4729"];
4729 [label="FullWidth = this.Text.Length; 4730"];
4730 [label="FullWidth 4731"];
4731 [label="this.AdjustFlagsAndWidth(trailing); 4732"];
4732 [label="return '$@\\''; 4733"];
4733 [label="FullWidth = this.Text.Length; 4734"];
4734 [label="FullWidth 4735"];
4735 [label="this.AdjustFlagsAndWidth(trailing); 4736"];
4736 [label="return 'load'; 4737"];
4737 [label="FullWidth = this.Text.Length; 4738"];
4738 [label="FullWidth 4739"];
4739 [label="return 'load'; 4740"];
4740 [label="FullWidth = this.Text.Length; 4741"];
4741 [label="FullWidth 4742"];
4742 [label="this.AdjustFlagsAndWidth(leading); 4743"];
4743 [label="return 'load'; 4744"];
4744 [label="FullWidth = this.Text.Length; 4745"];
4745 [label="FullWidth 4746"];
4746 [label="this.AdjustFlagsAndWidth(trailing); 4747"];
4747 [label="return 'load'; 4748"];
4748 [label="FullWidth = this.Text.Length; 4749"];
4749 [label="FullWidth 4750"];
4750 [label="this.AdjustFlagsAndWidth(trailing); 4751"];
4751 [label="return 'nullable'; 4752"];
4752 [label="FullWidth = this.Text.Length; 4753"];
4753 [label="FullWidth 4754"];
4754 [label="return 'nullable'; 4755"];
4755 [label="FullWidth = this.Text.Length; 4756"];
4756 [label="FullWidth 4757"];
4757 [label="this.AdjustFlagsAndWidth(leading); 4758"];
4758 [label="return 'nullable'; 4759"];
4759 [label="FullWidth = this.Text.Length; 4760"];
4760 [label="FullWidth 4761"];
4761 [label="this.AdjustFlagsAndWidth(trailing); 4762"];
4762 [label="return 'nullable'; 4763"];
4763 [label="FullWidth = this.Text.Length; 4764"];
4764 [label="FullWidth 4765"];
4765 [label="this.AdjustFlagsAndWidth(trailing); 4766"];
4766 [label="return 'enable'; 4767"];
4767 [label="FullWidth = this.Text.Length; 4768"];
4768 [label="FullWidth 4769"];
4769 [label="return 'enable'; 4770"];
4770 [label="FullWidth = this.Text.Length; 4771"];
4771 [label="FullWidth 4772"];
4772 [label="this.AdjustFlagsAndWidth(leading); 4773"];
4773 [label="return 'enable'; 4774"];
4774 [label="FullWidth = this.Text.Length; 4775"];
4775 [label="FullWidth 4776"];
4776 [label="this.AdjustFlagsAndWidth(trailing); 4777"];
4777 [label="return 'enable'; 4778"];
4778 [label="FullWidth = this.Text.Length; 4779"];
4779 [label="FullWidth 4780"];
4780 [label="this.AdjustFlagsAndWidth(trailing); 4781"];
4781 [label="return 'warnings'; 4782"];
4782 [label="FullWidth = this.Text.Length; 4783"];
4783 [label="FullWidth 4784"];
4784 [label="return 'warnings'; 4785"];
4785 [label="FullWidth = this.Text.Length; 4786"];
4786 [label="FullWidth 4787"];
4787 [label="this.AdjustFlagsAndWidth(leading); 4788"];
4788 [label="return 'warnings'; 4789"];
4789 [label="FullWidth = this.Text.Length; 4790"];
4790 [label="FullWidth 4791"];
4791 [label="this.AdjustFlagsAndWidth(trailing); 4792"];
4792 [label="return 'warnings'; 4793"];
4793 [label="FullWidth = this.Text.Length; 4794"];
4794 [label="FullWidth 4795"];
4795 [label="this.AdjustFlagsAndWidth(trailing); 4796"];
4796 [label="return 'annotations'; 4797"];
4797 [label="FullWidth = this.Text.Length; 4798"];
4798 [label="FullWidth 4799"];
4799 [label="return 'annotations'; 4800"];
4800 [label="FullWidth = this.Text.Length; 4801"];
4801 [label="FullWidth 4802"];
4802 [label="this.AdjustFlagsAndWidth(leading); 4803"];
4803 [label="return 'annotations'; 4804"];
4804 [label="FullWidth = this.Text.Length; 4805"];
4805 [label="FullWidth 4806"];
4806 [label="this.AdjustFlagsAndWidth(trailing); 4807"];
4807 [label="return 'annotations'; 4808"];
4808 [label="FullWidth = this.Text.Length; 4809"];
4809 [label="FullWidth 4810"];
4810 [label="this.AdjustFlagsAndWidth(trailing); 4811"];
4811 [label="return 'var'; 4812"];
4812 [label="FullWidth = this.Text.Length; 4813"];
4813 [label="FullWidth 4814"];
4814 [label="return 'var'; 4815"];
4815 [label="FullWidth = this.Text.Length; 4816"];
4816 [label="FullWidth 4817"];
4817 [label="this.AdjustFlagsAndWidth(leading); 4818"];
4818 [label="return 'var'; 4819"];
4819 [label="FullWidth = this.Text.Length; 4820"];
4820 [label="FullWidth 4821"];
4821 [label="this.AdjustFlagsAndWidth(trailing); 4822"];
4822 [label="return 'var'; 4823"];
4823 [label="FullWidth = this.Text.Length; 4824"];
4824 [label="FullWidth 4825"];
4825 [label="this.AdjustFlagsAndWidth(trailing); 4826"];
4826 [label="return '_'; 4827"];
4827 [label="FullWidth = this.Text.Length; 4828"];
4828 [label="FullWidth 4829"];
4829 [label="return '_'; 4830"];
4830 [label="FullWidth = this.Text.Length; 4831"];
4831 [label="FullWidth 4832"];
4832 [label="this.AdjustFlagsAndWidth(leading); 4833"];
4833 [label="return '_'; 4834"];
4834 [label="FullWidth = this.Text.Length; 4835"];
4835 [label="FullWidth 4836"];
4836 [label="this.AdjustFlagsAndWidth(trailing); 4837"];
4837 [label="return '_'; 4838"];
4838 [label="FullWidth = this.Text.Length; 4839"];
4839 [label="FullWidth 4840"];
4840 [label="this.AdjustFlagsAndWidth(trailing); 4841"];
4841 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 4842"];
4842 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 4843"];
4843 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 4844"];
4844 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 4845"];
4845 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 4846"];
4846 [label="SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing) 4847"];
4847 [label="param Identifier(SyntaxKind contextualKind) 4848"];
4848 [label="param Identifier(GreenNode leading) 4849"];
4849 [label="param Identifier(string text) 4850"];
4850 [label="param Identifier(string valueText) 4851"];
4851 [label="param Identifier(GreenNode trailing) 4852"];
4852 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 4853"];
4853 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifierWithTrivia), r => new SyntaxIdentifierWithTrivia(r)); 4854"];
4854 [label="return new SyntaxIdentifierWithTrivia(contextualKind, text, valueText, leading, trailing); 4855"];
4855 [label="return new SyntaxIdentifierWithTrivia(contextualKind, text, valueText, leading, trailing); 4856"];
4856 [label="return new SyntaxIdentifierWithTrivia(contextualKind, text, valueText, leading, trailing); 4857"];
4857 [label="return new SyntaxIdentifierWithTrivia(contextualKind, text, valueText, leading, trailing); 4858"];
4858 [label="return new SyntaxIdentifierWithTrivia(contextualKind, text, valueText, leading, trailing); 4859"];
4859 [label="return new SyntaxIdentifierWithTrivia(contextualKind, text, valueText, leading, trailing); 4860"];
4860 [label="new SyntaxIdentifierWithTrivia(contextualKind, text, valueText, leading, trailing) 4861"];
4861 [label="param SyntaxIdentifierWithTrivia(SyntaxKind contextualKind) 4862"];
4862 [label="param SyntaxIdentifierWithTrivia(string text) 4863"];
4863 [label="param SyntaxIdentifierWithTrivia(string valueText) 4864"];
4864 [label="param SyntaxIdentifierWithTrivia(GreenNode leading) 4865"];
4865 [label="param SyntaxIdentifierWithTrivia(GreenNode trailing) 4866"];
4866 [label="param SyntaxIdentifierWithTrivia(this) 4867"];
4867 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifierExtended), r => new SyntaxIdentifierExtended(r)); 4868"];
4868 [label="contextualKind 4869"];
4869 [label="text 4870"];
4870 [label="valueText 4871"];
4871 [label="param SyntaxIdentifierWithTrivia(this) 4872"];
4872 [label="param SyntaxIdentifierExtended(SyntaxKind contextualKind) 4873"];
4873 [label="param SyntaxIdentifierExtended(string text) 4874"];
4874 [label="param SyntaxIdentifierExtended(string valueText) 4875"];
4875 [label="param SyntaxIdentifierExtended(this) 4876"];
4876 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifier), r => new SyntaxIdentifier(r)); 4877"];
4877 [label="text 4878"];
4878 [label="param SyntaxIdentifierExtended(this) 4879"];
4879 [label="param SyntaxIdentifier(string text) 4880"];
4880 [label="param SyntaxIdentifier(this) 4881"];
4881 [label="SyntaxKind.IdentifierToken 4882"];
4882 [label="text 4883"];
4883 [label="param SyntaxIdentifier(this) 4884"];
4884 [label="param SyntaxToken(SyntaxKind kind) 4885"];
4885 [label="param SyntaxToken(int fullWidth) 4886"];
4886 [label="param SyntaxToken(this) 4887"];
4887 [label="kind 4888"];
4888 [label="fullWidth 4889"];
4889 [label="param SyntaxToken(this) 4890"];
4890 [label="param CSharpSyntaxNode(SyntaxKind kind) 4891"];
4891 [label="param CSharpSyntaxNode(int fullWidth) 4892"];
4892 [label="param CSharpSyntaxNode(this) 4893"];
4893 [label="kind 4894"];
4894 [label="fullWidth 4895"];
4895 [label="param CSharpSyntaxNode(this) 4896"];
4896 [label="param CSharpSyntaxNode(this) 4897"];
4897 [label="GreenStats.NoteGreen(this); 4898"];
4898 [label="GreenStats.NoteGreen(this); 4899"];
4899 [label="this.flags |= NodeFlags.IsNotMissing; 4900"];
4900 [label="this.flags 4901"];
4901 [label="TextField 4902"];
4902 [label="this.TextField 4903"];
4903 [label="contextualKind 4904"];
4904 [label="valueText 4905"];
4905 [label="this.contextualKind 4906"];
4906 [label="this.valueText 4907"];
4907 [label="_leading 4908"];
4908 [label="_trailing 4909"];
4909 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    _leading = leading;\n                } 4910"];
4910 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    _leading = leading;\n                } 4911"];
4911 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    _trailing = trailing;\n                } 4912"];
4912 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    _trailing = trailing;\n                } 4913"];
4913 [label="this.AdjustFlagsAndWidth(trailing); 4914"];
4914 [label="this.AdjustFlagsAndWidth(trailing); 4915"];
4915 [label="_trailing 4916"];
4916 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 4917"];
4917 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 4918"];
4918 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 4919"];
4919 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 4920"];
4920 [label="return token; 4921"];
4921 [label="this.AddLexedToken(token); 4922"];
4922 [label="this.AddLexedToken(token) 4923"];
4923 [label="param AddLexedToken(SyntaxToken token) 4924"];
4924 [label="param AddLexedToken(this) 4925"];
4925 [label="Debug.Assert(token != null); 4926"];
4926 [label="Debug.Assert(token != null); 4927"];
4927 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 4928"];
4928 [label="_lexedTokens[_tokenCount].Value = token; 4929"];
4929 [label="_lexedTokens[_tokenCount].Value 4930"];
4930 [label="_tokenCount 4931"];
4931 [label="this.AddLexedToken(token); 4932"];
4932 [label="token.Kind 4933"];
4933 [label="get { return (SyntaxKind)this.RawKind; } 4934"];
4934 [label="return (SyntaxKind)this.RawKind; 4935"];
4935 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 4936"];
4936 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 4937"];
4937 [label="TextWindow.Start(); 4938"];
4938 [label="get\n            {\n                return _lexemeStart;\n            } 4939"];
4939 [label="return _lexemeStart; 4940"];
4940 [label="param LookupToken(char[] textBuffer) 4941"];
4941 [label="param LookupToken(int keyStart) 4942"];
4942 [label="param LookupToken(int keyLength) 4943"];
4943 [label="param LookupToken(int hashCode) 4944"];
4944 [label="param LookupToken(Func<SyntaxToken> createTokenFunction) 4945"];
4945 [label="param LookupToken(this) 4946"];
4946 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 4947"];
4947 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 4948"];
4948 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 4949"];
4949 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 4950"];
4950 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 4951"];
4951 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 4952"];
4952 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 4953"];
4953 [label="value = createTokenFunction(); 4954"];
4954 [label="value = createTokenFunction(); 4955"];
4955 [label="param CreateQuickToken(this) 4956"];
4956 [label="TextWindow.Width 4957"];
4957 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 4958"];
4958 [label="var quickWidth = TextWindow.Width; 4959"];
4959 [label="TextWindow.LexemeStartPosition 4960"];
4960 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 4961"];
4961 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 4962"];
4962 [label="TextWindow.Reset(TextWindow.LexemeStartPosition) 4963"];
4963 [label="param Reset(int position) 4964"];
4964 [label="param Reset(this) 4965"];
4965 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 4966"];
4966 [label="this.LexSyntaxToken() 4967"];
4967 [label="param LexSyntaxToken(this) 4968"];
4968 [label="_leadingTriviaCache.Clear(); 4969"];
4969 [label="TextWindow.Position 4970"];
4970 [label="get\n            {\n                return _basis + _offset;\n            } 4971"];
4971 [label="param LexSyntaxTrivia(bool afterFirstToken) 4972"];
4972 [label="param LexSyntaxTrivia(bool isTrailing) 4973"];
4973 [label="bool onlyWhitespaceOnLine = !isTrailing; 4974"];
4974 [label="TextWindow.Start(); 4975"];
4975 [label="this.Start(); 4976"];
4976 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 4977"];
4977 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 4978"];
4978 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 4979"];
4979 [label="if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        } 4980"];
4980 [label="IsConflictMarkerTrivia() 4981"];
4981 [label="param IsConflictMarkerTrivia(this) 4982"];
4982 [label="TextWindow.Position 4983"];
4983 [label="get\n            {\n                return _basis + _offset;\n            } 4984"];
4984 [label="var position = TextWindow.Position; 4985"];
4985 [label="TextWindow.Text 4986"];
4986 [label="=> _text 4987"];
4987 [label="var text = TextWindow.Text; 4988"];
4988 [label="if (position == 0 || SyntaxFacts.IsNewLine(text[position - 1]))\n            {\n                var firstCh = text[position];\n                Debug.Assert(firstCh == '<' || firstCh == '=' || firstCh == '>');\n\n                if ((position + s_conflictMarkerLength) <= text.Length)\n                {\n                    for (int i = 0, n = s_conflictMarkerLength; i < n; i++)\n                    {\n                        if (text[position + i] != firstCh)\n                        {\n                            return false;\n                        }\n                    }\n\n                    if (firstCh == '=')\n                    {\n                        return true;\n                    }\n\n                    return (position + s_conflictMarkerLength) < text.Length &&\n                        text[position + s_conflictMarkerLength] == ' ';\n                }\n            } 4989"];
4989 [label="if (position == 0 || SyntaxFacts.IsNewLine(text[position - 1]))\n            {\n                var firstCh = text[position];\n                Debug.Assert(firstCh == '<' || firstCh == '=' || firstCh == '>');\n\n                if ((position + s_conflictMarkerLength) <= text.Length)\n                {\n                    for (int i = 0, n = s_conflictMarkerLength; i < n; i++)\n                    {\n                        if (text[position + i] != firstCh)\n                        {\n                            return false;\n                        }\n                    }\n\n                    if (firstCh == '=')\n                    {\n                        return true;\n                    }\n\n                    return (position + s_conflictMarkerLength) < text.Length &&\n                        text[position + s_conflictMarkerLength] == ' ';\n                }\n            } 4990"];
4990 [label="if (position == 0 || SyntaxFacts.IsNewLine(text[position - 1]))\n            {\n                var firstCh = text[position];\n                Debug.Assert(firstCh == '<' || firstCh == '=' || firstCh == '>');\n\n                if ((position + s_conflictMarkerLength) <= text.Length)\n                {\n                    for (int i = 0, n = s_conflictMarkerLength; i < n; i++)\n                    {\n                        if (text[position + i] != firstCh)\n                        {\n                            return false;\n                        }\n                    }\n\n                    if (firstCh == '=')\n                    {\n                        return true;\n                    }\n\n                    return (position + s_conflictMarkerLength) < text.Length &&\n                        text[position + s_conflictMarkerLength] == ' ';\n                }\n            } 4991"];
4991 [label="SyntaxFacts.IsNewLine(text[position - 1]) 4992"];
4992 [label="param IsNewLine(char ch) 4993"];
4993 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 4994"];
4994 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 4995"];
4995 [label="return false; 4996"];
4996 [label="if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            } 4997"];
4997 [label="return; 4998"];
4998 [label="this.Start(); 4999"];
4999 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5000"];
5000 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5001"];
5001 [label="GetFullWidth(leading) 5002"];
5002 [label="param GetFullWidth(SyntaxListBuilder builder) 5003"];
5003 [label="int width = 0; 5004"];
5004 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5005"];
5005 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5006"];
5006 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 5007"];
5007 [label="return width; 5008"];
5008 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5009"];
5009 [label="this.GetErrors(GetFullWidth(leading)) 5010"];
5010 [label="param GetErrors(int leadingTriviaWidth) 5011"];
5011 [label="param GetErrors(this) 5012"];
5012 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5013"];
5013 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5014"];
5014 [label="return null; 5015"];
5015 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5016"];
5016 [label="param LexSyntaxTrivia(bool afterFirstToken) 5017"];
5017 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5018"];
5018 [label="param AddTrivia(this) 5019"];
5019 [label="this.HasErrors 5020"];
5020 [label="get { return _errors != null; } 5021"];
5021 [label="return _errors != null; 5022"];
5022 [label="return _errors != null; 5023"];
5023 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 5024"];
5024 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 5025"];
5025 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 5026"];
5026 [label="return; 5027"];
5027 [label="param Create(SyntaxDiagnosticInfo[] errors) 5028"];
5028 [label="param Create(this) 5029"];
5029 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 5030"];
5030 [label="SyntaxToken token; 5031"];
5031 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 5032"];
5032 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 5033"];
5033 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 5034"];
5034 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 5035"];
5035 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 5036"];
5036 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 5037"];
5037 [label="param Token(GreenNode leading) 5038"];
5038 [label="param Token(SyntaxKind kind) 5039"];
5039 [label="param Token(GreenNode trailing) 5040"];
5040 [label="return SyntaxToken.Create(kind, leading, trailing); 5041"];
5041 [label="return SyntaxToken.Create(kind, leading, trailing); 5042"];
5042 [label="return SyntaxToken.Create(kind, leading, trailing); 5043"];
5043 [label="SyntaxToken.Create(kind, leading, trailing) 5044"];
5044 [label="param Create(SyntaxKind kind) 5045"];
5045 [label="param Create(GreenNode leading) 5046"];
5046 [label="param Create(GreenNode trailing) 5047"];
5047 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 5048"];
5048 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 5049"];
5049 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 5050"];
5050 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 5051"];
5051 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 5052"];
5052 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 5053"];
5053 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 5054"];
5054 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5055"];
5055 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5056"];
5056 [label="return token; 5057"];
5057 [label="var token = this.LexSyntaxToken(); 5058"];
5058 [label="Debug.Assert(quickWidth == token.FullWidth); 5059"];
5059 [label="return token; 5060"];
5060 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 5061"];
5061 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 5062"];
5062 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 5063"];
5063 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 5064"];
5064 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 5065"];
5065 [label="return value; 5066"];
5066 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 5067"];
5067 [label="this.AddLexedToken(token); 5068"];
5068 [label="param AddLexedToken(SyntaxToken token) 5069"];
5069 [label="Debug.Assert(token != null); 5070"];
5070 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 5071"];
5071 [label="_lexedTokens[_tokenCount].Value = token; 5072"];
5072 [label="_lexedTokens[_tokenCount].Value 5073"];
5073 [label="get { return (SyntaxKind)this.RawKind; } 5074"];
5074 [label="return (SyntaxKind)this.RawKind; 5075"];
5075 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 5076"];
5076 [label="TextWindow.Start(); 5077"];
5077 [label="TextWindow.Width 5078"];
5078 [label="var quickWidth = TextWindow.Width; 5079"];
5079 [label="TextWindow.Position 5080"];
5080 [label="param LexSyntaxTrivia(bool afterFirstToken) 5081"];
5081 [label="bool onlyWhitespaceOnLine = !isTrailing; 5082"];
5082 [label="this.Start(); 5083"];
5083 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5084"];
5084 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 5085"];
5085 [label="return; 5086"];
5086 [label="this.Start(); 5087"];
5087 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5088"];
5088 [label="param TryGetKeywordKind(out SyntaxKind kind) 5089"];
5089 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 5090"];
5090 [label="return SyntaxKind.NewKeyword; 5091"];
5091 [label="return false; 5092"];
5092 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 5093"];
5093 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5094"];
5094 [label="GetFullWidth(leading) 5095"];
5095 [label="param GetFullWidth(SyntaxListBuilder builder) 5096"];
5096 [label="int width = 0; 5097"];
5097 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5098"];
5098 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5099"];
5099 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 5100"];
5100 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 5101"];
5101 [label="return width; 5102"];
5102 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5103"];
5103 [label="this.GetErrors(GetFullWidth(leading)) 5104"];
5104 [label="param GetErrors(int leadingTriviaWidth) 5105"];
5105 [label="param GetErrors(this) 5106"];
5106 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5107"];
5107 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5108"];
5108 [label="return null; 5109"];
5109 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5110"];
5110 [label="param LexSyntaxTrivia(bool afterFirstToken) 5111"];
5111 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5112"];
5112 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5113"];
5113 [label="param AddTrivia(this) 5114"];
5114 [label="this.HasErrors 5115"];
5115 [label="get { return _errors != null; } 5116"];
5116 [label="return _errors != null; 5117"];
5117 [label="return _errors != null; 5118"];
5118 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 5119"];
5119 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 5120"];
5120 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 5121"];
5121 [label="return; 5122"];
5122 [label="param Create(SyntaxDiagnosticInfo[] errors) 5123"];
5123 [label="param Create(this) 5124"];
5124 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 5125"];
5125 [label="SyntaxToken token; 5126"];
5126 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 5127"];
5127 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 5128"];
5128 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 5129"];
5129 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 5130"];
5130 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 5131"];
5131 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5132"];
5132 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5133"];
5133 [label="Debug.Assert(quickWidth == token.FullWidth); 5134"];
5134 [label="this.AddLexedToken(token); 5135"];
5135 [label="param AddLexedToken(SyntaxToken token) 5136"];
5136 [label="Debug.Assert(token != null); 5137"];
5137 [label="_lexedTokens[_tokenCount].Value 5138"];
5138 [label="get { return (SyntaxKind)this.RawKind; } 5139"];
5139 [label="return (SyntaxKind)this.RawKind; 5140"];
5140 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 5141"];
5141 [label="TextWindow.Start(); 5142"];
5142 [label="TextWindow.Width 5143"];
5143 [label="var quickWidth = TextWindow.Width; 5144"];
5144 [label="param LexSyntaxTrivia(bool afterFirstToken) 5145"];
5145 [label="bool onlyWhitespaceOnLine = !isTrailing; 5146"];
5146 [label="this.Start(); 5147"];
5147 [label="this.Start(); 5148"];
5148 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5149"];
5149 [label="GetFullWidth(leading) 5150"];
5150 [label="param GetFullWidth(SyntaxListBuilder builder) 5151"];
5151 [label="int width = 0; 5152"];
5152 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5153"];
5153 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5154"];
5154 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 5155"];
5155 [label="return width; 5156"];
5156 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5157"];
5157 [label="this.GetErrors(GetFullWidth(leading)) 5158"];
5158 [label="param GetErrors(int leadingTriviaWidth) 5159"];
5159 [label="param GetErrors(this) 5160"];
5160 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5161"];
5161 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5162"];
5162 [label="return null; 5163"];
5163 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5164"];
5164 [label="param Create(SyntaxDiagnosticInfo[] errors) 5165"];
5165 [label="param Create(this) 5166"];
5166 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 5167"];
5167 [label="SyntaxToken token; 5168"];
5168 [label="return s_tokensWithNoTrivia[(int)kind].Value; 5169"];
5169 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5170"];
5170 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5171"];
5171 [label="Debug.Assert(quickWidth == token.FullWidth); 5172"];
5172 [label="this.AddLexedToken(token); 5173"];
5173 [label="param AddLexedToken(SyntaxToken token) 5174"];
5174 [label="Debug.Assert(token != null); 5175"];
5175 [label="_lexedTokens[_tokenCount].Value 5176"];
5176 [label="get { return (SyntaxKind)this.RawKind; } 5177"];
5177 [label="return (SyntaxKind)this.RawKind; 5178"];
5178 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 5179"];
5179 [label="TextWindow.Start(); 5180"];
5180 [label="TextWindow.Width 5181"];
5181 [label="var quickWidth = TextWindow.Width; 5182"];
5182 [label="param LexSyntaxTrivia(bool afterFirstToken) 5183"];
5183 [label="bool onlyWhitespaceOnLine = !isTrailing; 5184"];
5184 [label="this.Start(); 5185"];
5185 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5186"];
5186 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 5187"];
5187 [label="return; 5188"];
5188 [label="this.Start(); 5189"];
5189 [label="param TryGetKeywordKind(out SyntaxKind kind) 5190"];
5190 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 5191"];
5191 [label="return SyntaxKind.IntKeyword; 5192"];
5192 [label="return false; 5193"];
5193 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 5194"];
5194 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5195"];
5195 [label="GetFullWidth(leading) 5196"];
5196 [label="param GetFullWidth(SyntaxListBuilder builder) 5197"];
5197 [label="int width = 0; 5198"];
5198 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5199"];
5199 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5200"];
5200 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 5201"];
5201 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 5202"];
5202 [label="return width; 5203"];
5203 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5204"];
5204 [label="this.GetErrors(GetFullWidth(leading)) 5205"];
5205 [label="param GetErrors(int leadingTriviaWidth) 5206"];
5206 [label="param GetErrors(this) 5207"];
5207 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5208"];
5208 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5209"];
5209 [label="return null; 5210"];
5210 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5211"];
5211 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5212"];
5212 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 5213"];
5213 [label="return; 5214"];
5214 [label="param Create(SyntaxDiagnosticInfo[] errors) 5215"];
5215 [label="param Create(this) 5216"];
5216 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 5217"];
5217 [label="SyntaxToken token; 5218"];
5218 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 5219"];
5219 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 5220"];
5220 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 5221"];
5221 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 5222"];
5222 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 5223"];
5223 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5224"];
5224 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5225"];
5225 [label="Debug.Assert(quickWidth == token.FullWidth); 5226"];
5226 [label="this.AddLexedToken(token); 5227"];
5227 [label="param AddLexedToken(SyntaxToken token) 5228"];
5228 [label="Debug.Assert(token != null); 5229"];
5229 [label="_lexedTokens[_tokenCount].Value 5230"];
5230 [label="get { return (SyntaxKind)this.RawKind; } 5231"];
5231 [label="return (SyntaxKind)this.RawKind; 5232"];
5232 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 5233"];
5233 [label="TextWindow.Start(); 5234"];
5234 [label="TextWindow.Width 5235"];
5235 [label="var quickWidth = TextWindow.Width; 5236"];
5236 [label="param LexSyntaxTrivia(bool afterFirstToken) 5237"];
5237 [label="bool onlyWhitespaceOnLine = !isTrailing; 5238"];
5238 [label="this.Start(); 5239"];
5239 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5240"];
5240 [label="this.Start(); 5241"];
5241 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5242"];
5242 [label="GetFullWidth(leading) 5243"];
5243 [label="param GetFullWidth(SyntaxListBuilder builder) 5244"];
5244 [label="int width = 0; 5245"];
5245 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5246"];
5246 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5247"];
5247 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 5248"];
5248 [label="return width; 5249"];
5249 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5250"];
5250 [label="this.GetErrors(GetFullWidth(leading)) 5251"];
5251 [label="param GetErrors(int leadingTriviaWidth) 5252"];
5252 [label="param GetErrors(this) 5253"];
5253 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5254"];
5254 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5255"];
5255 [label="return null; 5256"];
5256 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5257"];
5257 [label="param AddTrivia(this) 5258"];
5258 [label="this.HasErrors 5259"];
5259 [label="get { return _errors != null; } 5260"];
5260 [label="return _errors != null; 5261"];
5261 [label="return _errors != null; 5262"];
5262 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 5263"];
5263 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 5264"];
5264 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 5265"];
5265 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5266"];
5266 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 5267"];
5267 [label="return; 5268"];
5268 [label="param Create(SyntaxDiagnosticInfo[] errors) 5269"];
5269 [label="param Create(this) 5270"];
5270 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 5271"];
5271 [label="SyntaxToken token; 5272"];
5272 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 5273"];
5273 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5274"];
5274 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5275"];
5275 [label="Debug.Assert(quickWidth == token.FullWidth); 5276"];
5276 [label="this.AddLexedToken(token); 5277"];
5277 [label="param AddLexedToken(SyntaxToken token) 5278"];
5278 [label="Debug.Assert(token != null); 5279"];
5279 [label="_lexedTokens[_tokenCount].Value 5280"];
5280 [label="get { return (SyntaxKind)this.RawKind; } 5281"];
5281 [label="return (SyntaxKind)this.RawKind; 5282"];
5282 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 5283"];
5283 [label="TextWindow.Start(); 5284"];
5284 [label="var quickWidth = TextWindow.Width; 5285"];
5285 [label="param LexSyntaxTrivia(bool afterFirstToken) 5286"];
5286 [label="bool onlyWhitespaceOnLine = !isTrailing; 5287"];
5287 [label="this.Start(); 5288"];
5288 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5289"];
5289 [label="this.Start(); 5290"];
5290 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5291"];
5291 [label="GetFullWidth(leading) 5292"];
5292 [label="param GetFullWidth(SyntaxListBuilder builder) 5293"];
5293 [label="int width = 0; 5294"];
5294 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5295"];
5295 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5296"];
5296 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 5297"];
5297 [label="return width; 5298"];
5298 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5299"];
5299 [label="this.GetErrors(GetFullWidth(leading)) 5300"];
5300 [label="param GetErrors(int leadingTriviaWidth) 5301"];
5301 [label="param GetErrors(this) 5302"];
5302 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5303"];
5303 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5304"];
5304 [label="return null; 5305"];
5305 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5306"];
5306 [label="param Create(SyntaxDiagnosticInfo[] errors) 5307"];
5307 [label="param Create(this) 5308"];
5308 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 5309"];
5309 [label="SyntaxToken token; 5310"];
5310 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 5311"];
5311 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 5312"];
5312 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 5313"];
5313 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 5314"];
5314 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 5315"];
5315 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5316"];
5316 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5317"];
5317 [label="Debug.Assert(quickWidth == token.FullWidth); 5318"];
5318 [label="param AddTrivia(this) 5319"];
5319 [label="this.HasErrors 5320"];
5320 [label="get { return _errors != null; } 5321"];
5321 [label="return _errors != null; 5322"];
5322 [label="return _errors != null; 5323"];
5323 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 5324"];
5324 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 5325"];
5325 [label="this.Position 5326"];
5326 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 5327"];
5327 [label="return false; 5328"];
5328 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5329"];
5329 [label="return InvalidCharacter; 5330"];
5330 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 5331"];
5331 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 5332"];
5332 [label="SyntaxFacts.IsWhitespace(ch) 5333"];
5333 [label="param IsWhitespace(char ch) 5334"];
5334 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 5335"];
5335 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 5336"];
5336 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 5337"];
5337 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 5338"];
5338 [label="SyntaxFacts.IsNewLine(ch) 5339"];
5339 [label="param IsNewLine(char ch) 5340"];
5340 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 5341"];
5341 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 5342"];
5342 [label="return; 5343"];
5343 [label="return (SyntaxKind)this.RawKind; 5344"];
5344 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 5345"];
5345 [label="param LexSyntaxTrivia(bool afterFirstToken) 5346"];
5346 [label="bool onlyWhitespaceOnLine = !isTrailing; 5347"];
5347 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5348"];
5348 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 5349"];
5349 [label="return false; 5350"];
5350 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 5351"];
5351 [label="return InvalidCharacter; 5352"];
5352 [label="param IsReallyAtEnd(this) 5353"];
5353 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 5354"];
5354 [label="Position 5355"];
5355 [label="get\n            {\n                return _basis + _offset;\n            } 5356"];
5356 [label="return _basis + _offset; 5357"];
5357 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 5358"];
5358 [label="ConsList<Directive>.Empty 5359"];
5359 [label="new DirectiveStack(ConsList<Directive>.Empty) 5360"];
5360 [label="param DirectiveStack(ConsList<Directive> directives) 5361"];
5361 [label="param DirectiveStack(this) 5362"];
5362 [label="_directives 5363"];
5363 [label="Empty = new DirectiveStack(ConsList<Directive>.Empty) 5364"];
5364 [label="null 5365"];
5365 [label="new DirectiveStack(null) 5366"];
5366 [label="param DirectiveStack(ConsList<Directive> directives) 5367"];
5367 [label="param DirectiveStack(this) 5368"];
5368 [label="_directives 5369"];
5369 [label="Null = new DirectiveStack(null) 5370"];
5370 [label="param HasUnfinishedIf(this) 5371"];
5371 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 5372"];
5372 [label="GetPreviousIfElifElseOrRegion(_directives) 5373"];
5373 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 5374"];
5374 [label="var current = directives; 5375"];
5375 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 5376"];
5376 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 5377"];
5377 [label="return current; 5378"];
5378 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 5379"];
5379 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 5380"];
5380 [label="param HasUnfinishedRegion(this) 5381"];
5381 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 5382"];
5382 [label="GetPreviousIfElifElseOrRegion(_directives) 5383"];
5383 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 5384"];
5384 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 5385"];
5385 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 5386"];
5386 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 5387"];
5387 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 5388"];
5388 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5389"];
5389 [label="param GetFullWidth(SyntaxListBuilder builder) 5390"];
5390 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 5391"];
5391 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 5392"];
5392 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 5393"];
5393 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 5394"];
5394 [label="return null; 5395"];
5395 [label="var errors = this.GetErrors(GetFullWidth(leading)); 5396"];
5396 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 5397"];
5397 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 5398"];
5398 [label="SyntaxFacts.IsWhitespace(ch) 5399"];
5399 [label="param IsWhitespace(char ch) 5400"];
5400 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 5401"];
5401 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 5402"];
5402 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 5403"];
5403 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 5404"];
5404 [label="SyntaxFacts.IsNewLine(ch) 5405"];
5405 [label="param IsNewLine(char ch) 5406"];
5406 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 5407"];
5407 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 5408"];
5408 [label="return; 5409"];
5409 [label="param Create(SyntaxDiagnosticInfo[] errors) 5410"];
5410 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 5411"];
5411 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 5412"];
5412 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 5413"];
5413 [label="param Token(GreenNode leading) 5414"];
5414 [label="param Token(SyntaxKind kind) 5415"];
5415 [label="param Token(GreenNode trailing) 5416"];
5416 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 5417"];
5417 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 5418"];
5418 [label="this.AddLexedToken(token); 5419"];
5419 [label="param AddLexedToken(SyntaxToken token) 5420"];
5420 [label="Debug.Assert(token != null); 5421"];
5421 [label="_lexedTokens[_tokenCount].Value 5422"];
5422 [label="get { return (SyntaxKind)this.RawKind; } 5423"];
5423 [label="return (SyntaxKind)this.RawKind; 5424"];
5424 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 5425"];
5425 [label="this.PreLex(); 5426"];
5426 [label="new SyntaxListPool() 5427"];
5427 [label="_pool = new SyntaxListPool() 5428"];
5428 [label="_syntaxFactoryContext 5429"];
5429 [label="_syntaxFactory 5430"];
5430 [label="_recursionDepth 5431"];
5431 [label="_termState 5432"];
5432 [label="_isInTry 5433"];
5433 [label="_checkedTopLevelStatementsFeatureAvailability 5434"];
5434 [label="_syntaxFactoryContext = new SyntaxFactoryContext(); 5435"];
5435 [label="_syntaxFactoryContext 5436"];
5436 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 5437"];
5437 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 5438"];
5438 [label="_syntaxFactory 5439"];
5439 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 5440"];
5440 [label="parser.ParseStatement() 5441"];
5441 [label="param ParseStatement(this) 5442"];
5442 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 5443"];
5443 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 5444"];
5444 [label="ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))) 5445"];
5445 [label="param ParseWithStackGuard(Func<TNode> parseFunc) 5446"];
5446 [label="param ParseWithStackGuard(Func<TNode> createEmptyNodeFunc) 5447"];
5447 [label="param ParseWithStackGuard(this) 5448"];
5448 [label="Debug.Assert(_recursionDepth == 0); 5449"];
5449 [label="Debug.Assert(_recursionDepth == 0); 5450"];
5450 [label="return parseFunc(); 5451"];
5451 [label="return parseFunc(); 5452"];
5452 [label="=> ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 5453"];
5453 [label="ParseAttributeDeclarations() 5454"];
5454 [label="param ParseAttributeDeclarations(this) 5455"];
5455 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 5456"];
5456 [label="var saveTerm = _termState; 5457"];
5457 [label="_termState |= TerminatorState.IsAttributeDeclarationTerminator; 5458"];
5458 [label="_termState 5459"];
5459 [label="this.IsPossibleAttributeDeclaration() 5460"];
5460 [label="param IsPossibleAttributeDeclaration(this) 5461"];
5461 [label="this.CurrentToken 5462"];
5462 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5463"];
5463 [label="this.FetchCurrentToken() 5464"];
5464 [label="param FetchCurrentToken(this) 5465"];
5465 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5466"];
5466 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 5467"];
5467 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 5468"];
5468 [label="return _lexedTokens[_tokenOffset]; 5469"];
5469 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 5470"];
5470 [label="_currentToken 5471"];
5471 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 5472"];
5472 [label="this.CurrentToken.Kind 5473"];
5473 [label="get { return (SyntaxKind)this.RawKind; } 5474"];
5474 [label="return (SyntaxKind)this.RawKind; 5475"];
5475 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 5476"];
5476 [label="_termState 5477"];
5477 [label="return attributes.ToList(); 5478"];
5478 [label="_pool.Free(attributes); 5479"];
5479 [label="_pool.Free(attributes); 5480"];
5480 [label="false 5481"];
5481 [label="isGlobal: false 5482"];
5482 [label="ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 5483"];
5483 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 5484"];
5484 [label="param ParseStatementCore(bool isGlobal) 5485"];
5485 [label="param ParseStatementCore(this) 5486"];
5486 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 5487"];
5487 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 5488"];
5488 [label="canReuseStatement(attributes, isGlobal) 5489"];
5489 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 5490"];
5490 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 5491"];
5491 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 5492"];
5492 [label="this.IsIncrementalAndFactoryContextMatches 5493"];
5493 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 5494"];
5494 [label="base.IsIncremental 5495"];
5495 [label="get\n            {\n                return _isIncremental;\n            } 5496"];
5496 [label="return _isIncremental; 5497"];
5497 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 5498"];
5498 [label="return false; 5499"];
5499 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 5500"];
5500 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 5501"];
5501 [label="this.GetResetPoint() 5502"];
5502 [label="param GetResetPoint(this) 5503"];
5503 [label="base.GetResetPoint() 5504"];
5504 [label="param GetResetPoint(this) 5505"];
5505 [label="CurrentTokenPosition 5506"];
5506 [label="=> _firstToken + _tokenOffset 5507"];
5507 [label="_firstToken + _tokenOffset 5508"];
5508 [label="var pos = CurrentTokenPosition; 5509"];
5509 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 5510"];
5510 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 5511"];
5511 [label="_resetStart 5512"];
5512 [label="_resetCount 5513"];
5513 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 5514"];
5514 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 5515"];
5515 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 5516"];
5516 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 5517"];
5517 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 5518"];
5518 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 5519"];
5519 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 5520"];
5520 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 5521"];
5521 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 5522"];
5522 [label="param ResetPoint(TerminatorState terminatorState) 5523"];
5523 [label="param ResetPoint(bool isInTry) 5524"];
5524 [label="param ResetPoint(bool isInAsync) 5525"];
5525 [label="param ResetPoint(int queryDepth) 5526"];
5526 [label="param ResetPoint(this) 5527"];
5527 [label="this.BaseResetPoint 5528"];
5528 [label="this.TerminatorState 5529"];
5529 [label="this.IsInTry 5530"];
5530 [label="this.IsInAsync 5531"];
5531 [label="this.QueryDepth 5532"];
5532 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 5533"];
5533 [label="_recursionDepth 5534"];
5534 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 5535"];
5535 [label="StatementSyntax result; 5536"];
5536 [label="this.CurrentToken 5537"];
5537 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5538"];
5538 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 5539"];
5539 [label="switch (this.CurrentToken.Kind)\n                {\n                    case SyntaxKind.FixedKeyword:\n                        return this.ParseFixedStatement(attributes);\n                    case SyntaxKind.BreakKeyword:\n                        return this.ParseBreakStatement(attributes);\n                    case SyntaxKind.ContinueKeyword:\n                        return this.ParseContinueStatement(attributes);\n                    case SyntaxKind.TryKeyword:\n                    case SyntaxKind.CatchKeyword:\n                    case SyntaxKind.FinallyKeyword:\n                        return this.ParseTryStatement(attributes);\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                        return this.ParseCheckedStatement(attributes);\n                    case SyntaxKind.DoKeyword:\n                        return this.ParseDoStatement(attributes);\n                    case SyntaxKind.ForKeyword:\n                        return this.ParseForOrForEachStatement(attributes);\n                    case SyntaxKind.ForEachKeyword:\n                        return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                    case SyntaxKind.GotoKeyword:\n                        return this.ParseGotoStatement(attributes);\n                    case SyntaxKind.IfKeyword:\n                        return this.ParseIfStatement(attributes);\n                    case SyntaxKind.ElseKeyword:\n                        // Including 'else' keyword to handle 'else without if' error cases \n                        return this.ParseMisplacedElse(attributes);\n                    case SyntaxKind.LockKeyword:\n                        return this.ParseLockStatement(attributes);\n                    case SyntaxKind.ReturnKeyword:\n                        return this.ParseReturnStatement(attributes);\n                    case SyntaxKind.SwitchKeyword:\n                        return this.ParseSwitchStatement(attributes);\n                    case SyntaxKind.ThrowKeyword:\n                        return this.ParseThrowStatement(attributes);\n                    case SyntaxKind.UnsafeKeyword:\n                        result = TryParseStatementStartingWithUnsafe(attributes);\n                        if (result != null)\n                            return result;\n                        break;\n                    case SyntaxKind.UsingKeyword:\n                        return ParseStatementStartingWithUsing(attributes);\n                    case SyntaxKind.WhileKeyword:\n                        return this.ParseWhileStatement(attributes);\n                    case SyntaxKind.OpenBraceToken:\n                        return this.ParseBlock(attributes);\n                    case SyntaxKind.SemicolonToken:\n                        return _syntaxFactory.EmptyStatement(attributes, this.EatToken());\n                    case SyntaxKind.IdentifierToken:\n                        result = TryParseStatementStartingWithIdentifier(attributes, isGlobal);\n                        if (result != null)\n                            return result;\n                        break;\n                } 5540"];
5540 [label="this.CurrentToken.Kind 5541"];
5541 [label="get { return (SyntaxKind)this.RawKind; } 5542"];
5542 [label="return (SyntaxKind)this.RawKind; 5543"];
5543 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 5544"];
5544 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 5545"];
5545 [label="TryParseStatementStartingWithIdentifier(attributes, isGlobal) 5546"];
5546 [label="param TryParseStatementStartingWithIdentifier(SyntaxList<AttributeListSyntax> attributes) 5547"];
5547 [label="param TryParseStatementStartingWithIdentifier(bool isGlobal) 5548"];
5548 [label="param TryParseStatementStartingWithIdentifier(this) 5549"];
5549 [label="this.CurrentToken 5550"];
5550 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5551"];
5551 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.ForEachKeyword)\n            {\n                return this.ParseForEachStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncStreams));\n            }\n            else if (IsPossibleAwaitUsing())\n            {\n                if (PeekToken(2).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // `await using Type ...` is handled below in ParseLocalDeclarationStatement\n                    return this.ParseUsingStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncUsing));\n                }\n            }\n            else if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 5552"];
5552 [label="this.CurrentToken.ContextualKind 5553"];
5553 [label="get { return this.contextualKind; } 5554"];
5554 [label="return this.contextualKind; 5555"];
5555 [label="IsPossibleAwaitUsing() 5556"];
5556 [label="=> CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 5557"];
5557 [label="CurrentToken 5558"];
5558 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5559"];
5559 [label="CurrentToken.ContextualKind 5560"];
5560 [label="get { return this.contextualKind; } 5561"];
5561 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 5562"];
5562 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 5563"];
5563 [label="if (IsPossibleAwaitUsing())\n            {\n                if (PeekToken(2).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // `await using Type ...` is handled below in ParseLocalDeclarationStatement\n                    return this.ParseUsingStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncUsing));\n                }\n            }\n            else if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 5564"];
5564 [label="this.IsPossibleLabeledStatement() 5565"];
5565 [label="param IsPossibleLabeledStatement(this) 5566"];
5566 [label="return this.PeekToken(1).Kind == SyntaxKind.ColonToken && this.IsTrueIdentifier(); 5567"];
5567 [label="this.PeekToken(1) 5568"];
5568 [label="param PeekToken(int n) 5569"];
5569 [label="param PeekToken(this) 5570"];
5570 [label="Debug.Assert(n >= 0); 5571"];
5571 [label="Debug.Assert(n >= 0); 5572"];
5572 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5573"];
5573 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 5574"];
5574 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 5575"];
5575 [label="return _lexedTokens[_tokenOffset + n]; 5576"];
5576 [label="return _lexedTokens[_tokenOffset + n]; 5577"];
5577 [label="this.PeekToken(1).Kind 5578"];
5578 [label="get { return (SyntaxKind)this.RawKind; } 5579"];
5579 [label="if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 5580"];
5580 [label="this.IsPossibleYieldStatement() 5581"];
5581 [label="param IsPossibleYieldStatement(this) 5582"];
5582 [label="this.CurrentToken 5583"];
5583 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5584"];
5584 [label="return this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword && (this.PeekToken(1).Kind == SyntaxKind.ReturnKeyword || this.PeekToken(1).Kind == SyntaxKind.BreakKeyword); 5585"];
5585 [label="this.CurrentToken.ContextualKind 5586"];
5586 [label="get { return this.contextualKind; } 5587"];
5587 [label="if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 5588"];
5588 [label="this.IsPossibleAwaitExpressionStatement() 5589"];
5589 [label="param IsPossibleAwaitExpressionStatement(this) 5590"];
5590 [label="this.IsScript 5591"];
5591 [label="get { return Options.Kind == SourceCodeKind.Script; } 5592"];
5592 [label="Options 5593"];
5593 [label="get { return this.lexer.Options; } 5594"];
5594 [label="this.lexer.Options 5595"];
5595 [label="get { return _options; } 5596"];
5596 [label="return _options; 5597"];
5597 [label="return this.lexer.Options; 5598"];
5598 [label="return Options.Kind == SourceCodeKind.Script; 5599"];
5599 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 5600"];
5600 [label="this.IsInAsync 5601"];
5601 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 5602"];
5602 [label="return _syntaxFactoryContext.IsInAsync; 5603"];
5603 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 5604"];
5604 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 5605"];
5605 [label="if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 5606"];
5606 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 5607"];
5607 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 5608"];
5608 [label="this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript) 5609"];
5609 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 5610"];
5610 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 5611"];
5611 [label="param IsQueryExpression(this) 5612"];
5612 [label="this.CurrentToken 5613"];
5613 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5614"];
5614 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 5615"];
5615 [label="this.CurrentToken.ContextualKind 5616"];
5616 [label="get { return this.contextualKind; } 5617"];
5617 [label="return false; 5618"];
5618 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 5619"];
5619 [label="return null; 5620"];
5620 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 5621"];
5621 [label="if (result != null)\n                            return result; 5622"];
5622 [label="if (result != null)\n                            return result; 5623"];
5623 [label="return ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement); 5624"];
5624 [label="return ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement); 5625"];
5625 [label="return ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement); 5626"];
5626 [label="ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement) 5627"];
5627 [label="param ParseStatementCoreRest(SyntaxList<AttributeListSyntax> attributes) 5628"];
5628 [label="param ParseStatementCoreRest(bool isGlobal) 5629"];
5629 [label="param ParseStatementCoreRest(ref ResetPoint resetPointBeforeStatement) 5630"];
5630 [label="param ParseStatementCoreRest(this) 5631"];
5631 [label="isGlobal = isGlobal && IsScript; 5632"];
5632 [label="if (!this.IsPossibleLocalDeclarationStatement(isGlobal))\n            {\n                return this.ParseExpressionStatement(attributes);\n            } 5633"];
5633 [label="this.IsPossibleLocalDeclarationStatement(isGlobal) 5634"];
5634 [label="param IsPossibleLocalDeclarationStatement(bool isGlobalScriptLevel) 5635"];
5635 [label="param IsPossibleLocalDeclarationStatement(this) 5636"];
5636 [label="this.CurrentToken 5637"];
5637 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5638"];
5638 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 5639"];
5639 [label="var tk = this.CurrentToken.Kind; 5640"];
5640 [label="this.CurrentToken.Kind 5641"];
5641 [label="get { return (SyntaxKind)this.RawKind; } 5642"];
5642 [label="return (SyntaxKind)this.RawKind; 5643"];
5643 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 5644"];
5644 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 5645"];
5645 [label="IsDeclarationModifier(tk) 5646"];
5646 [label="param IsDeclarationModifier(SyntaxKind kind) 5647"];
5647 [label="switch (kind)\n            {\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 5648"];
5648 [label="return false; 5649"];
5649 [label="SyntaxFacts.IsPredefinedType(tk) 5650"];
5650 [label="param IsPredefinedType(SyntaxKind kind) 5651"];
5651 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 5652"];
5652 [label="return false; 5653"];
5653 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 5654"];
5654 [label="if (tk == SyntaxKind.UsingKeyword)\n            {\n                Debug.Assert(PeekToken(1).Kind != SyntaxKind.OpenParenToken);\n                return true;\n            } 5655"];
5655 [label="IsPossibleAwaitUsing() 5656"];
5656 [label="=> CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 5657"];
5657 [label="CurrentToken 5658"];
5658 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5659"];
5659 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 5660"];
5660 [label="CurrentToken.ContextualKind 5661"];
5661 [label="get { return this.contextualKind; } 5662"];
5662 [label="return this.contextualKind; 5663"];
5663 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 5664"];
5664 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 5665"];
5665 [label="if (IsPossibleAwaitUsing())\n            {\n                Debug.Assert(PeekToken(2).Kind != SyntaxKind.OpenParenToken);\n                return true;\n            } 5666"];
5666 [label="this.CurrentToken 5667"];
5667 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5668"];
5668 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 5669"];
5669 [label="tk = this.CurrentToken.ContextualKind; 5670"];
5670 [label="this.CurrentToken.ContextualKind 5671"];
5671 [label="get { return this.contextualKind; } 5672"];
5672 [label="return this.contextualKind; 5673"];
5673 [label="var isPossibleAttributeOrModifier = (IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken)\n                && (tk != SyntaxKind.AsyncKeyword || ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: true)); 5674"];
5674 [label="IsAdditionalLocalFunctionModifier(tk) 5675"];
5675 [label="param IsAdditionalLocalFunctionModifier(SyntaxKind kind) 5676"];
5676 [label="switch (kind)\n            {\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.ExternKeyword:\n                // Not a valid modifier, but we should parse to give a good\n                // error message\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PrivateKeyword:\n                    return true;\n\n                default:\n                    return false;\n            } 5677"];
5677 [label="return false; 5678"];
5678 [label="var isPossibleAttributeOrModifier = (IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken)\n                && (tk != SyntaxKind.AsyncKeyword || ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: true)); 5679"];
5679 [label="if (isPossibleAttributeOrModifier)\n            {\n                return true;\n            } 5680"];
5680 [label="return IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(isGlobalScriptLevel); 5681"];
5681 [label="IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(isGlobalScriptLevel) 5682"];
5682 [label="param IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(bool isGlobalScriptLevel) 5683"];
5683 [label="param IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(this) 5684"];
5684 [label="this.CurrentToken 5685"];
5685 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5686"];
5686 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 5687"];
5687 [label="bool? typedIdentifier = IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false); 5688"];
5688 [label="bool? typedIdentifier = IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false); 5689"];
5689 [label="this.PeekToken(1) 5690"];
5690 [label="param PeekToken(int n) 5691"];
5691 [label="param PeekToken(this) 5692"];
5692 [label="Debug.Assert(n >= 0); 5693"];
5693 [label="Debug.Assert(n >= 0); 5694"];
5694 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5695"];
5695 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 5696"];
5696 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 5697"];
5697 [label="return _lexedTokens[_tokenOffset + n]; 5698"];
5698 [label="return _lexedTokens[_tokenOffset + n]; 5699"];
5699 [label="IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false) 5700"];
5700 [label="param IsPossibleTypedIdentifierStart(SyntaxToken current) 5701"];
5701 [label="param IsPossibleTypedIdentifierStart(SyntaxToken next) 5702"];
5702 [label="param IsPossibleTypedIdentifierStart(bool allowThisKeyword) 5703"];
5703 [label="param IsPossibleTypedIdentifierStart(this) 5704"];
5704 [label="if (IsTrueIdentifier(current))\n            {\n                switch (next.Kind)\n                {\n                    // tokens that can be in type names...\n                    case SyntaxKind.DotToken:\n                    case SyntaxKind.AsteriskToken:\n                    case SyntaxKind.QuestionToken:\n                    case SyntaxKind.OpenBracketToken:\n                    case SyntaxKind.LessThanToken:\n                    case SyntaxKind.ColonColonToken:\n                        return null;\n\n                    case SyntaxKind.OpenParenToken:\n                        if (current.IsIdentifierVar())\n                        {\n                            // potentially either a tuple type in a local declaration (true), or\n                            // a tuple lvalue in a deconstruction assignment (false).\n                            return null;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n\n                    case SyntaxKind.IdentifierToken:\n                        return IsTrueIdentifier(next);\n\n                    case SyntaxKind.ThisKeyword:\n                        return allowThisKeyword;\n\n                    default:\n                        return false;\n                }\n            } 5705"];
5705 [label="IsTrueIdentifier(current) 5706"];
5706 [label="param IsTrueIdentifier(SyntaxToken token) 5707"];
5707 [label="param IsTrueIdentifier(this) 5708"];
5708 [label="token.Kind 5709"];
5709 [label="get { return (SyntaxKind)this.RawKind; } 5710"];
5710 [label="return (SyntaxKind)this.RawKind; 5711"];
5711 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 5712"];
5712 [label="this.IsInQuery 5713"];
5713 [label="get { return _syntaxFactoryContext.IsInQuery; } 5714"];
5714 [label="return _syntaxFactoryContext.IsInQuery; 5715"];
5715 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 5716"];
5716 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 5717"];
5717 [label="next.Kind 5718"];
5718 [label="get { return (SyntaxKind)this.RawKind; } 5719"];
5719 [label="switch (next.Kind)\n                {\n                    // tokens that can be in type names...\n                    case SyntaxKind.DotToken:\n                    case SyntaxKind.AsteriskToken:\n                    case SyntaxKind.QuestionToken:\n                    case SyntaxKind.OpenBracketToken:\n                    case SyntaxKind.LessThanToken:\n                    case SyntaxKind.ColonColonToken:\n                        return null;\n\n                    case SyntaxKind.OpenParenToken:\n                        if (current.IsIdentifierVar())\n                        {\n                            // potentially either a tuple type in a local declaration (true), or\n                            // a tuple lvalue in a deconstruction assignment (false).\n                            return null;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n\n                    case SyntaxKind.IdentifierToken:\n                        return IsTrueIdentifier(next);\n\n                    case SyntaxKind.ThisKeyword:\n                        return allowThisKeyword;\n\n                    default:\n                        return false;\n                } 5720"];
5720 [label="return false; 5721"];
5721 [label="if (typedIdentifier != null)\n            {\n                return typedIdentifier.Value;\n            } 5722"];
5722 [label="if (typedIdentifier != null)\n            {\n                return typedIdentifier.Value;\n            } 5723"];
5723 [label="return typedIdentifier.Value; 5724"];
5724 [label="return IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(isGlobalScriptLevel); 5725"];
5725 [label="if (!this.IsPossibleLocalDeclarationStatement(isGlobal))\n            {\n                return this.ParseExpressionStatement(attributes);\n            } 5726"];
5726 [label="return this.ParseExpressionStatement(attributes); 5727"];
5727 [label="this.ParseExpressionStatement(attributes) 5728"];
5728 [label="param ParseExpressionStatement(SyntaxList<AttributeListSyntax> attributes) 5729"];
5729 [label="param ParseExpressionStatement(this) 5730"];
5730 [label="return ParseExpressionStatement(attributes, this.ParseExpressionCore()); 5731"];
5731 [label="this.ParseExpressionCore() 5732"];
5732 [label="param ParseExpressionCore(this) 5733"];
5733 [label="return this.ParseSubExpression(Precedence.Expression); 5734"];
5734 [label="this.ParseSubExpression(Precedence.Expression) 5735"];
5735 [label="param ParseSubExpression(Precedence precedence) 5736"];
5736 [label="param ParseSubExpression(this) 5737"];
5737 [label="_recursionDepth 5738"];
5738 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 5739"];
5739 [label="var result = ParseSubExpressionCore(precedence); 5740"];
5740 [label="ParseSubExpressionCore(precedence) 5741"];
5741 [label="param ParseSubExpressionCore(Precedence precedence) 5742"];
5742 [label="param ParseSubExpressionCore(this) 5743"];
5743 [label="ExpressionSyntax leftOperand; 5744"];
5744 [label="Precedence newPrecedence = 0; 5745"];
5745 [label="this.CurrentToken 5746"];
5746 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5747"];
5747 [label="var tk = this.CurrentToken.Kind; 5748"];
5748 [label="this.CurrentToken.Kind 5749"];
5749 [label="get { return (SyntaxKind)this.RawKind; } 5750"];
5750 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 5751"];
5751 [label="IsInvalidSubExpression(tk) 5752"];
5752 [label="param IsInvalidSubExpression(SyntaxKind kind) 5753"];
5753 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 5754"];
5754 [label="return false; 5755"];
5755 [label="if (IsExpectedPrefixUnaryOperator(tk))\n            {\n                var opKind = SyntaxFacts.GetPrefixUnaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n                var opToken = this.EatToken();\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.PrefixUnaryExpression(opKind, opToken, operand);\n            }\n            else if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5756"];
5756 [label="IsExpectedPrefixUnaryOperator(tk) 5757"];
5757 [label="param IsExpectedPrefixUnaryOperator(SyntaxKind kind) 5758"];
5758 [label="return SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword; 5759"];
5759 [label="SyntaxFacts.IsPrefixUnaryExpression(kind) 5760"];
5760 [label="param IsPrefixUnaryExpression(SyntaxKind token) 5761"];
5761 [label="return GetPrefixUnaryExpression(token) != SyntaxKind.None; 5762"];
5762 [label="GetPrefixUnaryExpression(token) 5763"];
5763 [label="param GetPrefixUnaryExpression(SyntaxKind token) 5764"];
5764 [label="switch (token)\n            {\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.UnaryPlusExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.UnaryMinusExpression;\n                case SyntaxKind.TildeToken:\n                    return SyntaxKind.BitwiseNotExpression;\n                case SyntaxKind.ExclamationToken:\n                    return SyntaxKind.LogicalNotExpression;\n                case SyntaxKind.PlusPlusToken:\n                    return SyntaxKind.PreIncrementExpression;\n                case SyntaxKind.MinusMinusToken:\n                    return SyntaxKind.PreDecrementExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.AddressOfExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.PointerIndirectionExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.IndexExpression;\n                default:\n                    return SyntaxKind.None;\n            } 5765"];
5765 [label="return SyntaxKind.None; 5766"];
5766 [label="if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5767"];
5767 [label="IsAwaitExpression() 5768"];
5768 [label="param IsAwaitExpression(this) 5769"];
5769 [label="this.CurrentToken 5770"];
5770 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5771"];
5771 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 5772"];
5772 [label="this.CurrentToken.ContextualKind 5773"];
5773 [label="get { return this.contextualKind; } 5774"];
5774 [label="return this.contextualKind; 5775"];
5775 [label="return false; 5776"];
5776 [label="if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5777"];
5777 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5778"];
5778 [label="this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false) 5779"];
5779 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 5780"];
5780 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 5781"];
5781 [label="param IsQueryExpression(this) 5782"];
5782 [label="this.CurrentToken 5783"];
5783 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5784"];
5784 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 5785"];
5785 [label="this.CurrentToken.ContextualKind 5786"];
5786 [label="get { return this.contextualKind; } 5787"];
5787 [label="return this.contextualKind; 5788"];
5788 [label="return false; 5789"];
5789 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5790"];
5790 [label="this.CurrentToken 5791"];
5791 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5792"];
5792 [label="this.CurrentToken.ContextualKind 5793"];
5793 [label="get { return this.contextualKind; } 5794"];
5794 [label="return this.contextualKind; 5795"];
5795 [label="if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5796"];
5796 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5797"];
5797 [label="this.IsPossibleDeconstructionLeft(precedence) 5798"];
5798 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 5799"];
5799 [label="param IsPossibleDeconstructionLeft(this) 5800"];
5800 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 5801"];
5801 [label="this.CurrentToken 5802"];
5802 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5803"];
5803 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 5804"];
5804 [label="this.CurrentToken.IsIdentifierVar() 5805"];
5805 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 5806"];
5806 [label="node.ContextualKind 5807"];
5807 [label="get { return this.contextualKind; } 5808"];
5808 [label="return node.ContextualKind == SyntaxKind.VarKeyword; 5809"];
5809 [label="this.CurrentToken 5810"];
5810 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5811"];
5811 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 5812"];
5812 [label="this.CurrentToken.Kind 5813"];
5813 [label="get { return (SyntaxKind)this.RawKind; } 5814"];
5814 [label="IsPredefinedType(this.CurrentToken.Kind) 5815"];
5815 [label="param IsPredefinedType(SyntaxKind keyword) 5816"];
5816 [label="return SyntaxFacts.IsPredefinedType(keyword); 5817"];
5817 [label="SyntaxFacts.IsPredefinedType(keyword) 5818"];
5818 [label="param IsPredefinedType(SyntaxKind kind) 5819"];
5819 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 5820"];
5820 [label="return false; 5821"];
5821 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 5822"];
5822 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 5823"];
5823 [label="return false; 5824"];
5824 [label="leftOperand = this.ParseTerm(precedence); 5825"];
5825 [label="this.ParseTerm(precedence) 5826"];
5826 [label="param ParseTerm(Precedence precedence) 5827"];
5827 [label="=> this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 5828"];
5828 [label="precedence 5829"];
5829 [label="ParseTermWithoutPostfix(precedence) 5830"];
5830 [label="param ParseTermWithoutPostfix(Precedence precedence) 5831"];
5831 [label="param ParseTermWithoutPostfix(this) 5832"];
5832 [label="this.CurrentToken 5833"];
5833 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5834"];
5834 [label="var tk = this.CurrentToken.Kind; 5835"];
5835 [label="this.CurrentToken.Kind 5836"];
5836 [label="get { return (SyntaxKind)this.RawKind; } 5837"];
5837 [label="switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                    return this.ParseTypeOfExpression();\n                case SyntaxKind.DefaultKeyword:\n                    return this.ParseDefaultExpression();\n                case SyntaxKind.SizeOfKeyword:\n                    return this.ParseSizeOfExpression();\n                case SyntaxKind.MakeRefKeyword:\n                    return this.ParseMakeRefExpression();\n                case SyntaxKind.RefTypeKeyword:\n                    return this.ParseRefTypeExpression();\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    return this.ParseCheckedOrUncheckedExpression();\n                case SyntaxKind.RefValueKeyword:\n                    return this.ParseRefValueExpression();\n                case SyntaxKind.ColonColonToken:\n                    // misplaced ::\n                    // Calling ParseAliasQualifiedName will cause us to create a missing identifier node that then\n                    // properly consumes the :: and the reset of the alias name afterwards.\n                    return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return this.ParseLambdaExpression();\n                case SyntaxKind.StaticKeyword:\n                    if (this.IsPossibleAnonymousMethodExpression())\n                    {\n                        return this.ParseAnonymousMethodExpression();\n                    }\n                    else if (this.IsPossibleLambdaExpression(precedence))\n                    {\n                        return this.ParseLambdaExpression();\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.ThisKeyword:\n                    return _syntaxFactory.ThisExpression(this.EatToken());\n                case SyntaxKind.BaseKeyword:\n                    return ParseBaseExpression();\n\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                    return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken());\n                case SyntaxKind.InterpolatedStringStartToken:\n                    throw new NotImplementedException(); // this should not occur because these tokens are produced and parsed immediately\n                case SyntaxKind.InterpolatedStringToken:\n                    return this.ParseInterpolatedStringToken();\n                case SyntaxKind.OpenParenToken:\n                    return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence);\n                case SyntaxKind.NewKeyword:\n                    return this.ParseNewExpression();\n                case SyntaxKind.StackAllocKeyword:\n                    return this.ParseStackAllocExpression();\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseAnonymousMethodExpression();\n                case SyntaxKind.RefKeyword:\n                    // ref is not expected to appear in this position.\n                    return this.AddError(ParsePossibleRefExpression(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                default:\n                    // check for intrinsic type followed by '.'\n                    if (IsPredefinedType(tk))\n                    {\n                        var expr = _syntaxFactory.PredefinedType(this.EatToken());\n\n                        if (this.CurrentToken.Kind != SyntaxKind.DotToken || tk == SyntaxKind.VoidKeyword)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n                    else\n                    {\n                        var expr = this.CreateMissingIdentifierName();\n\n                        if (tk == SyntaxKind.EndOfFileToken)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_ExpressionExpected);\n                        }\n                        else\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n            } 5838"];
5838 [label="this.IsTrueIdentifier() 5839"];
5839 [label="param IsTrueIdentifier(this) 5840"];
5840 [label="this.CurrentToken 5841"];
5841 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5842"];
5842 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 5843"];
5843 [label="this.CurrentToken.Kind 5844"];
5844 [label="get { return (SyntaxKind)this.RawKind; } 5845"];
5845 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 5846"];
5846 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 5847"];
5847 [label="this.CurrentToken 5848"];
5848 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5849"];
5849 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 5850"];
5850 [label="this.CurrentToken.ContextualKind 5851"];
5851 [label="get { return this.contextualKind; } 5852"];
5852 [label="return false; 5853"];
5853 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 5854"];
5854 [label="IsCurrentTokenQueryKeywordInQuery() 5855"];
5855 [label="param IsCurrentTokenQueryKeywordInQuery(this) 5856"];
5856 [label="this.IsInQuery 5857"];
5857 [label="get { return _syntaxFactoryContext.IsInQuery; } 5858"];
5858 [label="return _syntaxFactoryContext.IsInQuery; 5859"];
5859 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 5860"];
5860 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 5861"];
5861 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 5862"];
5862 [label="IsCurrentTokenWhereOfConstraintClause() 5863"];
5863 [label="param IsCurrentTokenWhereOfConstraintClause(this) 5864"];
5864 [label="this.CurrentToken 5865"];
5865 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5866"];
5866 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 5867"];
5867 [label="this.CurrentToken.ContextualKind 5868"];
5868 [label="get { return this.contextualKind; } 5869"];
5869 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 5870"];
5870 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 5871"];
5871 [label="return true; 5872"];
5872 [label="if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    } 5873"];
5873 [label="this.IsPossibleAnonymousMethodExpression() 5874"];
5874 [label="param IsPossibleAnonymousMethodExpression(this) 5875"];
5875 [label="var tokenIndex = 0; 5876"];
5876 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 5877"];
5877 [label="this.PeekToken(tokenIndex) 5878"];
5878 [label="param PeekToken(int n) 5879"];
5879 [label="param PeekToken(this) 5880"];
5880 [label="Debug.Assert(n >= 0); 5881"];
5881 [label="Debug.Assert(n >= 0); 5882"];
5882 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5883"];
5883 [label="return _lexedTokens[_tokenOffset + n]; 5884"];
5884 [label="this.PeekToken(tokenIndex).Kind 5885"];
5885 [label="get { return (SyntaxKind)this.RawKind; } 5886"];
5886 [label="this.PeekToken(tokenIndex) 5887"];
5887 [label="param PeekToken(int n) 5888"];
5888 [label="param PeekToken(this) 5889"];
5889 [label="Debug.Assert(n >= 0); 5890"];
5890 [label="Debug.Assert(n >= 0); 5891"];
5891 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5892"];
5892 [label="return _lexedTokens[_tokenOffset + n]; 5893"];
5893 [label="this.PeekToken(tokenIndex).ContextualKind 5894"];
5894 [label="get { return this.contextualKind; } 5895"];
5895 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 5896"];
5896 [label="return this.PeekToken(tokenIndex).Kind == SyntaxKind.DelegateKeyword; 5897"];
5897 [label="this.PeekToken(tokenIndex) 5898"];
5898 [label="param PeekToken(int n) 5899"];
5899 [label="param PeekToken(this) 5900"];
5900 [label="Debug.Assert(n >= 0); 5901"];
5901 [label="Debug.Assert(n >= 0); 5902"];
5902 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5903"];
5903 [label="return _lexedTokens[_tokenOffset + n]; 5904"];
5904 [label="this.PeekToken(tokenIndex).Kind 5905"];
5905 [label="get { return (SyntaxKind)this.RawKind; } 5906"];
5906 [label="if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 5907"];
5907 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 5908"];
5908 [label="this.IsPossibleLambdaExpression(precedence) 5909"];
5909 [label="param IsPossibleLambdaExpression(Precedence precedence) 5910"];
5910 [label="param IsPossibleLambdaExpression(this) 5911"];
5911 [label="this.CurrentToken 5912"];
5912 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5913"];
5913 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 5914"];
5914 [label="this.CurrentToken.Kind 5915"];
5915 [label="get { return (SyntaxKind)this.RawKind; } 5916"];
5916 [label="this.CurrentToken 5917"];
5917 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5918"];
5918 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 5919"];
5919 [label="this.IsTrueIdentifier(this.CurrentToken) 5920"];
5920 [label="param IsTrueIdentifier(SyntaxToken token) 5921"];
5921 [label="param IsTrueIdentifier(this) 5922"];
5922 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 5923"];
5923 [label="if (precedence > Precedence.Lambda)\n            {\n                return false;\n            } 5924"];
5924 [label="int peekIndex; 5925"];
5925 [label="bool seenStatic; 5926"];
5926 [label="this.CurrentToken 5927"];
5927 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5928"];
5928 [label="if (this.CurrentToken.Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 1;\n                seenStatic = true;\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 5929"];
5929 [label="this.CurrentToken.Kind 5930"];
5930 [label="get { return (SyntaxKind)this.RawKind; } 5931"];
5931 [label="this.CurrentToken 5932"];
5932 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 5933"];
5933 [label="this.CurrentToken.ContextualKind 5934"];
5934 [label="get { return this.contextualKind; } 5935"];
5935 [label="peekIndex = 0; 5936"];
5936 [label="seenStatic = false; 5937"];
5937 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on => then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static =>`\n                // 2. `async static =>`\n\n                // This is an error case, but we have enough code in front of us to be certain\n                // the user was trying to write a static lambda.\n                return true;\n            } 5938"];
5938 [label="this.PeekToken(peekIndex) 5939"];
5939 [label="param PeekToken(int n) 5940"];
5940 [label="param PeekToken(this) 5941"];
5941 [label="Debug.Assert(n >= 0); 5942"];
5942 [label="Debug.Assert(n >= 0); 5943"];
5943 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5944"];
5944 [label="this.PeekToken(peekIndex).Kind 5945"];
5945 [label="get { return (SyntaxKind)this.RawKind; } 5946"];
5946 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 5947"];
5947 [label="this.PeekToken(peekIndex) 5948"];
5948 [label="param PeekToken(int n) 5949"];
5949 [label="param PeekToken(this) 5950"];
5950 [label="Debug.Assert(n >= 0); 5951"];
5951 [label="Debug.Assert(n >= 0); 5952"];
5952 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5953"];
5953 [label="this.PeekToken(peekIndex).Kind 5954"];
5954 [label="get { return (SyntaxKind)this.RawKind; } 5955"];
5955 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 5956"];
5956 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 5957"];
5957 [label="this.PeekToken(peekIndex + 1) 5958"];
5958 [label="param PeekToken(int n) 5959"];
5959 [label="param PeekToken(this) 5960"];
5960 [label="Debug.Assert(n >= 0); 5961"];
5961 [label="Debug.Assert(n >= 0); 5962"];
5962 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5963"];
5963 [label="this.PeekToken(peekIndex + 1).Kind 5964"];
5964 [label="get { return (SyntaxKind)this.RawKind; } 5965"];
5965 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 5966"];
5966 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on ( then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static (...\n                // 2. `async static (...\n                return true;\n            } 5967"];
5967 [label="this.PeekToken(peekIndex) 5968"];
5968 [label="param PeekToken(int n) 5969"];
5969 [label="param PeekToken(this) 5970"];
5970 [label="Debug.Assert(n >= 0); 5971"];
5971 [label="Debug.Assert(n >= 0); 5972"];
5972 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5973"];
5973 [label="this.PeekToken(peekIndex).Kind 5974"];
5974 [label="get { return (SyntaxKind)this.RawKind; } 5975"];
5975 [label="if (this.PeekToken(peekIndex).ContextualKind != SyntaxKind.AsyncKeyword)\n            {\n                return false;\n            } 5976"];
5976 [label="this.PeekToken(peekIndex) 5977"];
5977 [label="param PeekToken(int n) 5978"];
5978 [label="param PeekToken(this) 5979"];
5979 [label="Debug.Assert(n >= 0); 5980"];
5980 [label="Debug.Assert(n >= 0); 5981"];
5981 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5982"];
5982 [label="this.PeekToken(peekIndex).ContextualKind 5983"];
5983 [label="get { return this.contextualKind; } 5984"];
5984 [label="return false; 5985"];
5985 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 5986"];
5986 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 5987"];
5987 [label="this.IsPossibleDeconstructionLeft(precedence) 5988"];
5988 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 5989"];
5989 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 5990"];
5990 [label="this.ParseAliasQualifiedName(NameOptions.InExpression) 5991"];
5991 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 5992"];
5992 [label="param ParseAliasQualifiedName(this) 5993"];
5993 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 5994"];
5994 [label="this.ParseSimpleName(allowedParts) 5995"];
5995 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 5996"];
5996 [label="param ParseSimpleName(this) 5997"];
5997 [label="var id = this.ParseIdentifierName(); 5998"];
5998 [label="this.ParseIdentifierName() 5999"];
5999 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 6000"];
6000 [label="param ParseIdentifierName(this) 6001"];
6001 [label="this.IsIncrementalAndFactoryContextMatches 6002"];
6002 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 6003"];
6003 [label="base.IsIncremental 6004"];
6004 [label="get\n            {\n                return _isIncremental;\n            } 6005"];
6005 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 6006"];
6006 [label="return false; 6007"];
6007 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 6008"];
6008 [label="var tk = ParseIdentifierToken(code); 6009"];
6009 [label="ParseIdentifierToken(code) 6010"];
6010 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 6011"];
6011 [label="param ParseIdentifierToken(this) 6012"];
6012 [label="this.CurrentToken 6013"];
6013 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6014"];
6014 [label="var ctk = this.CurrentToken.Kind; 6015"];
6015 [label="this.CurrentToken.Kind 6016"];
6016 [label="get { return (SyntaxKind)this.RawKind; } 6017"];
6017 [label="if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Goo {\n                // } Because we're parsing an attribute argument we'll end up consuming the 'partial' identifier and\n                // we'll eventually end up in a pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see 'partial' we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, code);\n                return name;\n            } 6018"];
6018 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 6019"];
6019 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 6020"];
6020 [label="this.CurrentToken 6021"];
6021 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6022"];
6022 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 6023"];
6023 [label="this.CurrentToken.ContextualKind 6024"];
6024 [label="get { return this.contextualKind; } 6025"];
6025 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 6026"];
6026 [label="IsCurrentTokenQueryKeywordInQuery() 6027"];
6027 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 6028"];
6028 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 6029"];
6029 [label="this.EatToken() 6030"];
6030 [label="param EatToken(this) 6031"];
6031 [label="this.CurrentToken 6032"];
6032 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6033"];
6033 [label="var ct = this.CurrentToken; 6034"];
6034 [label="MoveToNextToken() 6035"];
6035 [label="param MoveToNextToken(this) 6036"];
6036 [label="_currentToken.GetTrailingTrivia() 6037"];
6037 [label="param GetTrailingTrivia(this) 6038"];
6038 [label="return _trailing; 6039"];
6039 [label="_prevTokenTrailingTrivia = _currentToken.GetTrailingTrivia(); 6040"];
6040 [label="_prevTokenTrailingTrivia 6041"];
6041 [label="_currentToken = null; 6042"];
6042 [label="_currentToken 6043"];
6043 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6044"];
6044 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6045"];
6045 [label="_tokenOffset 6046"];
6046 [label="MoveToNextToken(); 6047"];
6047 [label="return ct; 6048"];
6048 [label="SyntaxToken identifierToken = this.EatToken(); 6049"];
6049 [label="this.IsInAsync 6050"];
6050 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 6051"];
6051 [label="return _syntaxFactoryContext.IsInAsync; 6052"];
6052 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 6053"];
6053 [label="return identifierToken; 6054"];
6054 [label="var tk = ParseIdentifierToken(code); 6055"];
6055 [label="return SyntaxFactory.IdentifierName(tk); 6056"];
6056 [label="return SyntaxFactory.IdentifierName(tk); 6057"];
6057 [label="return SyntaxFactory.IdentifierName(tk); 6058"];
6058 [label="param CSharpSyntaxNode(SyntaxKind kind) 6059"];
6059 [label="param CSharpSyntaxNode(this) 6060"];
6060 [label="kind 6061"];
6061 [label="param CSharpSyntaxNode(this) 6062"];
6062 [label="param CSharpSyntaxNode(this) 6063"];
6063 [label="GreenStats.NoteGreen(this); 6064"];
6064 [label="GreenStats.NoteGreen(this); 6065"];
6065 [label="var id = this.ParseIdentifierName(); 6066"];
6066 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 6067"];
6067 [label="SimpleNameSyntax name = id; 6068"];
6068 [label="this.CurrentToken 6069"];
6069 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6070"];
6070 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6071"];
6071 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 6072"];
6072 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 6073"];
6073 [label="this.CurrentToken.Kind 6074"];
6074 [label="get { return (SyntaxKind)this.RawKind; } 6075"];
6075 [label="return name; 6076"];
6076 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 6077"];
6077 [label="this.CurrentToken 6078"];
6078 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6079"];
6079 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6080"];
6080 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 6081"];
6081 [label="this.CurrentToken.Kind 6082"];
6082 [label="get { return (SyntaxKind)this.RawKind; } 6083"];
6083 [label="return name; 6084"];
6084 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 6085"];
6085 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 6086"];
6086 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 6087"];
6087 [label="return ParseExpressionContinued(leftOperand, precedence); 6088"];
6088 [label="return ParseExpressionContinued(leftOperand, precedence); 6089"];
6089 [label="ParseExpressionContinued(leftOperand, precedence) 6090"];
6090 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 6091"];
6091 [label="param ParseExpressionContinued(Precedence precedence) 6092"];
6092 [label="param ParseExpressionContinued(this) 6093"];
6093 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 6094"];
6094 [label="this.CurrentToken 6095"];
6095 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6096"];
6096 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6097"];
6097 [label="var tk = this.CurrentToken.ContextualKind; 6098"];
6098 [label="this.CurrentToken.ContextualKind 6099"];
6099 [label="get\n            {\n                return this.Kind;\n            } 6100"];
6100 [label="this.Kind 6101"];
6101 [label="get { return (SyntaxKind)this.RawKind; } 6102"];
6102 [label="return this.Kind; 6103"];
6103 [label="bool isAssignmentOperator = false; 6104"];
6104 [label="SyntaxKind opKind; 6105"];
6105 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 6106"];
6106 [label="IsExpectedBinaryOperator(tk) 6107"];
6107 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 6108"];
6108 [label="return SyntaxFacts.IsBinaryExpression(kind); 6109"];
6109 [label="SyntaxFacts.IsBinaryExpression(kind) 6110"];
6110 [label="param IsBinaryExpression(SyntaxKind token) 6111"];
6111 [label="return GetBinaryExpression(token) != SyntaxKind.None; 6112"];
6112 [label="GetBinaryExpression(token) 6113"];
6113 [label="param GetBinaryExpression(SyntaxKind token) 6114"];
6114 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 6115"];
6115 [label="return SyntaxKind.None; 6116"];
6116 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 6117"];
6117 [label="IsExpectedAssignmentOperator(tk) 6118"];
6118 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 6119"];
6119 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 6120"];
6120 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 6121"];
6121 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 6122"];
6122 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 6123"];
6123 [label="return true; 6124"];
6124 [label="opKind = SyntaxFacts.GetAssignmentExpression(tk); 6125"];
6125 [label="SyntaxFacts.GetAssignmentExpression(tk) 6126"];
6126 [label="param GetAssignmentExpression(SyntaxKind token) 6127"];
6127 [label="switch (token)\n            {\n                case SyntaxKind.BarEqualsToken:\n                    return SyntaxKind.OrAssignmentExpression;\n                case SyntaxKind.AmpersandEqualsToken:\n                    return SyntaxKind.AndAssignmentExpression;\n                case SyntaxKind.CaretEqualsToken:\n                    return SyntaxKind.ExclusiveOrAssignmentExpression;\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return SyntaxKind.LeftShiftAssignmentExpression;\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return SyntaxKind.RightShiftAssignmentExpression;\n                case SyntaxKind.PlusEqualsToken:\n                    return SyntaxKind.AddAssignmentExpression;\n                case SyntaxKind.MinusEqualsToken:\n                    return SyntaxKind.SubtractAssignmentExpression;\n                case SyntaxKind.AsteriskEqualsToken:\n                    return SyntaxKind.MultiplyAssignmentExpression;\n                case SyntaxKind.SlashEqualsToken:\n                    return SyntaxKind.DivideAssignmentExpression;\n                case SyntaxKind.PercentEqualsToken:\n                    return SyntaxKind.ModuloAssignmentExpression;\n                case SyntaxKind.EqualsToken:\n                    return SyntaxKind.SimpleAssignmentExpression;\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return SyntaxKind.CoalesceAssignmentExpression;\n                default:\n                    return SyntaxKind.None;\n            } 6128"];
6128 [label="return SyntaxKind.SimpleAssignmentExpression; 6129"];
6129 [label="isAssignmentOperator = true; 6130"];
6130 [label="var newPrecedence = GetPrecedence(opKind); 6131"];
6131 [label="GetPrecedence(opKind) 6132"];
6132 [label="param GetPrecedence(SyntaxKind op) 6133"];
6133 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 6134"];
6134 [label="return Precedence.Assignment; 6135"];
6135 [label="bool doubleOp = false; 6136"];
6136 [label="if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                } 6137"];
6137 [label="if (newPrecedence < precedence)\n                {\n                    break;\n                } 6138"];
6138 [label="if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                } 6139"];
6139 [label="if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                } 6140"];
6140 [label="IsRightAssociative(opKind) 6141"];
6141 [label="param IsRightAssociative(SyntaxKind op) 6142"];
6142 [label="switch (op)\n            {\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                case SyntaxKind.CoalesceExpression:\n                    return true;\n                default:\n                    return false;\n            } 6143"];
6143 [label="return true; 6144"];
6144 [label="if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                } 6145"];
6145 [label="var opToken = this.EatContextualToken(tk); 6146"];
6146 [label="var opToken = this.EatContextualToken(tk); 6147"];
6147 [label="this.EatContextualToken(tk) 6148"];
6148 [label="param EatContextualToken(SyntaxKind kind) 6149"];
6149 [label="param EatContextualToken(bool reportError = true) 6150"];
6150 [label="param EatContextualToken(this) 6151"];
6151 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 6152"];
6152 [label="SyntaxFacts.IsAnyToken(kind) 6153"];
6153 [label="param IsAnyToken(SyntaxKind kind) 6154"];
6154 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 6155"];
6155 [label="return true; 6156"];
6156 [label="this.CurrentToken 6157"];
6157 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6158"];
6158 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6159"];
6159 [label="var contextualKind = this.CurrentToken.ContextualKind; 6160"];
6160 [label="this.CurrentToken.ContextualKind 6161"];
6161 [label="get\n            {\n                return this.Kind;\n            } 6162"];
6162 [label="this.Kind 6163"];
6163 [label="get { return (SyntaxKind)this.RawKind; } 6164"];
6164 [label="return this.Kind; 6165"];
6165 [label="if (contextualKind != kind)\n            {\n                return CreateMissingToken(kind, contextualKind, reportError);\n            }\n            else\n            {\n                return ConvertToKeyword(this.EatToken());\n            } 6166"];
6166 [label="this.EatToken() 6167"];
6167 [label="param GetTrailingTrivia(this) 6168"];
6168 [label="return this.TrailingField; 6169"];
6169 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6170"];
6170 [label="MoveToNextToken(); 6171"];
6171 [label="return ConvertToKeyword(this.EatToken()); 6172"];
6172 [label="ConvertToKeyword(this.EatToken()) 6173"];
6173 [label="param ConvertToKeyword(SyntaxToken token) 6174"];
6174 [label="token.Kind 6175"];
6175 [label="get { return (SyntaxKind)this.RawKind; } 6176"];
6176 [label="if (token.Kind != token.ContextualKind)\n            {\n                var kw = token.IsMissing\n                        ? SyntaxFactory.MissingToken(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node)\n                        : SyntaxFactory.Token(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node);\n                var d = token.GetDiagnostics();\n                if (d != null && d.Length > 0)\n                {\n                    kw = kw.WithDiagnosticsGreen(d);\n                }\n\n                return kw;\n            } 6177"];
6177 [label="token.ContextualKind 6178"];
6178 [label="get\n            {\n                return this.Kind;\n            } 6179"];
6179 [label="if (token.Kind != token.ContextualKind)\n            {\n                var kw = token.IsMissing\n                        ? SyntaxFactory.MissingToken(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node)\n                        : SyntaxFactory.Token(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node);\n                var d = token.GetDiagnostics();\n                if (d != null && d.Length > 0)\n                {\n                    kw = kw.WithDiagnosticsGreen(d);\n                }\n\n                return kw;\n            } 6180"];
6180 [label="if (token.Kind != token.ContextualKind)\n            {\n                var kw = token.IsMissing\n                        ? SyntaxFactory.MissingToken(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node)\n                        : SyntaxFactory.Token(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node);\n                var d = token.GetDiagnostics();\n                if (d != null && d.Length > 0)\n                {\n                    kw = kw.WithDiagnosticsGreen(d);\n                }\n\n                return kw;\n            } 6181"];
6181 [label="return token; 6182"];
6182 [label="leftOperand.Kind 6183"];
6183 [label="get { return (SyntaxKind)this.RawKind; } 6184"];
6184 [label="var leftPrecedence = GetPrecedence(leftOperand.Kind); 6185"];
6185 [label="GetPrecedence(leftOperand.Kind) 6186"];
6186 [label="param GetPrecedence(SyntaxKind op) 6187"];
6187 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 6188"];
6188 [label="return Precedence.Primary; 6189"];
6189 [label="if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                } 6190"];
6190 [label="if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                } 6191"];
6191 [label="if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                } 6192"];
6192 [label="if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                } 6193"];
6193 [label="if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                } 6194"];
6194 [label="ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence); 6195"];
6195 [label="CurrentToken 6196"];
6196 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6197"];
6197 [label="return _lexedTokens[_tokenOffset]; 6198"];
6198 [label="ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence); 6199"];
6199 [label="CurrentToken.Kind 6200"];
6200 [label="get { return (SyntaxKind)this.RawKind; } 6201"];
6201 [label="opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword 6202"];
6202 [label="ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence); 6203"];
6203 [label="this.ParseSubExpression(newPrecedence) 6204"];
6204 [label="param ParseSubExpression(Precedence precedence) 6205"];
6205 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 6206"];
6206 [label="ExpressionSyntax leftOperand; 6207"];
6207 [label="Precedence newPrecedence = 0; 6208"];
6208 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 6209"];
6209 [label="IsInvalidSubExpression(tk) 6210"];
6210 [label="param IsInvalidSubExpression(SyntaxKind kind) 6211"];
6211 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 6212"];
6212 [label="return false; 6213"];
6213 [label="param IsAwaitExpression(this) 6214"];
6214 [label="this.CurrentToken 6215"];
6215 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6216"];
6216 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 6217"];
6217 [label="this.CurrentToken.ContextualKind 6218"];
6218 [label="get\n            {\n                return this.Kind;\n            } 6219"];
6219 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 6220"];
6220 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 6221"];
6221 [label="param IsQueryExpression(this) 6222"];
6222 [label="this.CurrentToken 6223"];
6223 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6224"];
6224 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 6225"];
6225 [label="this.CurrentToken.ContextualKind 6226"];
6226 [label="get\n            {\n                return this.Kind;\n            } 6227"];
6227 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 6228"];
6228 [label="this.ParseNewExpression() 6229"];
6229 [label="param ParseNewExpression(this) 6230"];
6230 [label="this.CurrentToken 6231"];
6231 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6232"];
6232 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.NewKeyword); 6233"];
6233 [label="this.CurrentToken.Kind 6234"];
6234 [label="get { return (SyntaxKind)this.RawKind; } 6235"];
6235 [label="this.IsAnonymousType() 6236"];
6236 [label="param IsAnonymousType(this) 6237"];
6237 [label="this.CurrentToken 6238"];
6238 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6239"];
6239 [label="return this.CurrentToken.Kind == SyntaxKind.NewKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken; 6240"];
6240 [label="this.CurrentToken.Kind 6241"];
6241 [label="get { return (SyntaxKind)this.RawKind; } 6242"];
6242 [label="return this.CurrentToken.Kind == SyntaxKind.NewKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken; 6243"];
6243 [label="this.PeekToken(1) 6244"];
6244 [label="param PeekToken(int n) 6245"];
6245 [label="param PeekToken(this) 6246"];
6246 [label="Debug.Assert(n >= 0); 6247"];
6247 [label="Debug.Assert(n >= 0); 6248"];
6248 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6249"];
6249 [label="return _lexedTokens[_tokenOffset + n]; 6250"];
6250 [label="this.PeekToken(1).Kind 6251"];
6251 [label="get { return (SyntaxKind)this.RawKind; } 6252"];
6252 [label="return this.CurrentToken.Kind == SyntaxKind.NewKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken; 6253"];
6253 [label="if (this.IsAnonymousType())\n            {\n                return this.ParseAnonymousTypeExpression();\n            }\n            else if (this.IsImplicitlyTypedArray())\n            {\n                return this.ParseImplicitlyTypedArrayCreation();\n            }\n            else\n            {\n                // assume object creation as default case\n                return this.ParseArrayOrObjectCreationExpression();\n            } 6254"];
6254 [label="this.IsImplicitlyTypedArray() 6255"];
6255 [label="param IsImplicitlyTypedArray(this) 6256"];
6256 [label="this.CurrentToken 6257"];
6257 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6258"];
6258 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.NewKeyword || this.CurrentToken.Kind == SyntaxKind.StackAllocKeyword); 6259"];
6259 [label="this.CurrentToken.Kind 6260"];
6260 [label="get { return (SyntaxKind)this.RawKind; } 6261"];
6261 [label="return this.PeekToken(1).Kind == SyntaxKind.OpenBracketToken; 6262"];
6262 [label="this.PeekToken(1) 6263"];
6263 [label="param PeekToken(int n) 6264"];
6264 [label="param PeekToken(this) 6265"];
6265 [label="Debug.Assert(n >= 0); 6266"];
6266 [label="Debug.Assert(n >= 0); 6267"];
6267 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6268"];
6268 [label="return _lexedTokens[_tokenOffset + n]; 6269"];
6269 [label="this.PeekToken(1).Kind 6270"];
6270 [label="get { return (SyntaxKind)this.RawKind; } 6271"];
6271 [label="if (this.IsImplicitlyTypedArray())\n            {\n                return this.ParseImplicitlyTypedArrayCreation();\n            }\n            else\n            {\n                // assume object creation as default case\n                return this.ParseArrayOrObjectCreationExpression();\n            } 6272"];
6272 [label="this.ParseArrayOrObjectCreationExpression() 6273"];
6273 [label="param ParseArrayOrObjectCreationExpression(this) 6274"];
6274 [label="SyntaxToken @new = this.EatToken(SyntaxKind.NewKeyword); 6275"];
6275 [label="this.EatToken(SyntaxKind.NewKeyword) 6276"];
6276 [label="param EatToken(SyntaxKind kind) 6277"];
6277 [label="param EatToken(this) 6278"];
6278 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 6279"];
6279 [label="SyntaxFacts.IsAnyToken(kind) 6280"];
6280 [label="param IsAnyToken(SyntaxKind kind) 6281"];
6281 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 6282"];
6282 [label="return true; 6283"];
6283 [label="this.CurrentToken 6284"];
6284 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6285"];
6285 [label="var ct = this.CurrentToken; 6286"];
6286 [label="ct.Kind 6287"];
6287 [label="get { return (SyntaxKind)this.RawKind; } 6288"];
6288 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 6289"];
6289 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 6290"];
6290 [label="MoveToNextToken() 6291"];
6291 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6292"];
6292 [label="MoveToNextToken(); 6293"];
6293 [label="return ct; 6294"];
6294 [label="TypeSyntax type = null; 6295"];
6295 [label="InitializerExpressionSyntax initializer = null; 6296"];
6296 [label="IsImplicitObjectCreation() 6297"];
6297 [label="param IsImplicitObjectCreation(this) 6298"];
6298 [label="this.CurrentToken 6299"];
6299 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6300"];
6300 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6301"];
6301 [label="return _lexedTokens[_tokenOffset]; 6302"];
6302 [label="if (this.CurrentToken.Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            } 6303"];
6303 [label="this.CurrentToken.Kind 6304"];
6304 [label="get { return (SyntaxKind)this.RawKind; } 6305"];
6305 [label="this.GetResetPoint() 6306"];
6306 [label="param GetResetPoint(this) 6307"];
6307 [label="_firstToken + _tokenOffset 6308"];
6308 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 6309"];
6309 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 6310"];
6310 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 6311"];
6311 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 6312"];
6312 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 6313"];
6313 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 6314"];
6314 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 6315"];
6315 [label="param ResetPoint(TerminatorState terminatorState) 6316"];
6316 [label="param ResetPoint(bool isInTry) 6317"];
6317 [label="param ResetPoint(bool isInAsync) 6318"];
6318 [label="param ResetPoint(int queryDepth) 6319"];
6319 [label="param ResetPoint(this) 6320"];
6320 [label="this.BaseResetPoint 6321"];
6321 [label="this.TerminatorState 6322"];
6322 [label="this.IsInTry 6323"];
6323 [label="this.IsInAsync 6324"];
6324 [label="this.QueryDepth 6325"];
6325 [label="var point = this.GetResetPoint(); 6326"];
6326 [label="this.EatToken() 6327"];
6327 [label="param EatToken(this) 6328"];
6328 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6329"];
6329 [label="param GetTrailingTrivia(this) 6330"];
6330 [label="return null; 6331"];
6331 [label="_prevTokenTrailingTrivia 6332"];
6332 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6333"];
6333 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6334"];
6334 [label="_tokenOffset 6335"];
6335 [label="MoveToNextToken(); 6336"];
6336 [label="this.EatToken(); 6337"];
6337 [label="ScanTypeFlags scanTypeFlags = ScanTupleType(out _); 6338"];
6338 [label="ScanTupleType(out _) 6339"];
6339 [label="param ScanTupleType(out SyntaxToken lastTokenOfType) 6340"];
6340 [label="param ScanTupleType(this) 6341"];
6341 [label="var tupleElementType = ScanType(out lastTokenOfType); 6342"];
6342 [label="var tupleElementType = ScanType(out lastTokenOfType); 6343"];
6343 [label="ScanType(out lastTokenOfType) 6344"];
6344 [label="param ScanType(out SyntaxToken lastTokenOfType) 6345"];
6345 [label="param ScanType(bool forPattern = false) 6346"];
6346 [label="param ScanType(this) 6347"];
6347 [label="forPattern 6348"];
6348 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 6349"];
6349 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 6350"];
6350 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 6351"];
6351 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 6352"];
6352 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6353"];
6353 [label="return true; 6354"];
6354 [label="param GetTrailingTrivia(this) 6355"];
6355 [label="return null; 6356"];
6356 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6357"];
6357 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6358"];
6358 [label="MoveToNextToken(); 6359"];
6359 [label="param IsMakingProgress(ref int lastTokenPosition) 6360"];
6360 [label="param IsMakingProgress(bool assertIfFalse = true) 6361"];
6361 [label="param IsMakingProgress(this) 6362"];
6362 [label="CurrentTokenPosition 6363"];
6363 [label="=> _firstToken + _tokenOffset 6364"];
6364 [label="_firstToken + _tokenOffset 6365"];
6365 [label="var pos = CurrentTokenPosition; 6366"];
6366 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 6367"];
6367 [label="lastTokenPosition = pos; 6368"];
6368 [label="return true; 6369"];
6369 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 6370"];
6370 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6371"];
6371 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 6372"];
6372 [label="if (tupleElementType != ScanTypeFlags.NotType)\n            {\n                if (IsTrueIdentifier())\n                {\n                    lastTokenOfType = this.EatToken();\n                }\n\n                if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    do\n                    {\n                        lastTokenOfType = this.EatToken();\n                        tupleElementType = ScanType(out lastTokenOfType);\n\n                        if (tupleElementType == ScanTypeFlags.NotType)\n                        {\n                            lastTokenOfType = this.EatToken();\n                            return ScanTypeFlags.NotType;\n                        }\n\n                        if (IsTrueIdentifier())\n                        {\n                            lastTokenOfType = this.EatToken();\n                        }\n                    }\n                    while (this.CurrentToken.Kind == SyntaxKind.CommaToken);\n\n                    if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken)\n                    {\n                        lastTokenOfType = this.EatToken();\n                        return ScanTypeFlags.TupleType;\n                    }\n                }\n            } 6373"];
6373 [label="IsTrueIdentifier() 6374"];
6374 [label="return false; 6375"];
6375 [label="if (IsTrueIdentifier())\n                {\n                    lastTokenOfType = this.EatToken();\n                } 6376"];
6376 [label="this.CurrentToken 6377"];
6377 [label="if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    do\n                    {\n                        lastTokenOfType = this.EatToken();\n                        tupleElementType = ScanType(out lastTokenOfType);\n\n                        if (tupleElementType == ScanTypeFlags.NotType)\n                        {\n                            lastTokenOfType = this.EatToken();\n                            return ScanTypeFlags.NotType;\n                        }\n\n                        if (IsTrueIdentifier())\n                        {\n                            lastTokenOfType = this.EatToken();\n                        }\n                    }\n                    while (this.CurrentToken.Kind == SyntaxKind.CommaToken);\n\n                    if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken)\n                    {\n                        lastTokenOfType = this.EatToken();\n                        return ScanTypeFlags.TupleType;\n                    }\n                } 6378"];
6378 [label="this.CurrentToken.Kind 6379"];
6379 [label="get { return (SyntaxKind)this.RawKind; } 6380"];
6380 [label="this.EatToken() 6381"];
6381 [label="param EatToken(this) 6382"];
6382 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6383"];
6383 [label="param GetTrailingTrivia(this) 6384"];
6384 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6385"];
6385 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6386"];
6386 [label="_tokenOffset 6387"];
6387 [label="MoveToNextToken(); 6388"];
6388 [label="lastTokenOfType = this.EatToken(); 6389"];
6389 [label="tupleElementType = ScanType(out lastTokenOfType); 6390"];
6390 [label="tupleElementType = ScanType(out lastTokenOfType); 6391"];
6391 [label="ScanType(out lastTokenOfType) 6392"];
6392 [label="param ScanType(out SyntaxToken lastTokenOfType) 6393"];
6393 [label="param ScanType(bool forPattern = false) 6394"];
6394 [label="param ScanType(this) 6395"];
6395 [label="forPattern 6396"];
6396 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 6397"];
6397 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 6398"];
6398 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6399"];
6399 [label="param GetTrailingTrivia(this) 6400"];
6400 [label="return null; 6401"];
6401 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6402"];
6402 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6403"];
6403 [label="MoveToNextToken(); 6404"];
6404 [label="param IsMakingProgress(bool assertIfFalse = true) 6405"];
6405 [label="CurrentTokenPosition 6406"];
6406 [label="if (tupleElementType == ScanTypeFlags.NotType)\n                        {\n                            lastTokenOfType = this.EatToken();\n                            return ScanTypeFlags.NotType;\n                        } 6407"];
6407 [label="IsTrueIdentifier() 6408"];
6408 [label="param IsTrueIdentifier(this) 6409"];
6409 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6410"];
6410 [label="return false; 6411"];
6411 [label="if (IsTrueIdentifier())\n                        {\n                            lastTokenOfType = this.EatToken();\n                        } 6412"];
6412 [label="this.CurrentToken 6413"];
6413 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6414"];
6414 [label="do\n                    {\n                        lastTokenOfType = this.EatToken();\n                        tupleElementType = ScanType(out lastTokenOfType);\n\n                        if (tupleElementType == ScanTypeFlags.NotType)\n                        {\n                            lastTokenOfType = this.EatToken();\n                            return ScanTypeFlags.NotType;\n                        }\n\n                        if (IsTrueIdentifier())\n                        {\n                            lastTokenOfType = this.EatToken();\n                        }\n                    }\n                    while (this.CurrentToken.Kind == SyntaxKind.CommaToken); 6415"];
6415 [label="this.CurrentToken.Kind 6416"];
6416 [label="get { return (SyntaxKind)this.RawKind; } 6417"];
6417 [label="this.CurrentToken 6418"];
6418 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6419"];
6419 [label="if (this.CurrentToken.Kind == SyntaxKind.CloseParenToken)\n                    {\n                        lastTokenOfType = this.EatToken();\n                        return ScanTypeFlags.TupleType;\n                    } 6420"];
6420 [label="this.CurrentToken.Kind 6421"];
6421 [label="get { return (SyntaxKind)this.RawKind; } 6422"];
6422 [label="this.EatToken() 6423"];
6423 [label="param GetTrailingTrivia(this) 6424"];
6424 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6425"];
6425 [label="MoveToNextToken(); 6426"];
6426 [label="lastTokenOfType = this.EatToken(); 6427"];
6427 [label="return ScanTypeFlags.TupleType; 6428"];
6428 [label="if (scanTypeFlags != ScanTypeFlags.NotType)\n                {\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.QuestionToken:    // e.g. `new(a, b)?()`\n                        case SyntaxKind.OpenBracketToken: // e.g. `new(a, b)[]`\n                        case SyntaxKind.OpenParenToken:   // e.g. `new(a, b)()` for better error recovery\n                            return false;\n                    }\n                } 6429"];
6429 [label="this.CurrentToken 6430"];
6430 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6431"];
6431 [label="return _lexedTokens[_tokenOffset]; 6432"];
6432 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.QuestionToken:    // e.g. `new(a, b)?()`\n                        case SyntaxKind.OpenBracketToken: // e.g. `new(a, b)[]`\n                        case SyntaxKind.OpenParenToken:   // e.g. `new(a, b)()` for better error recovery\n                            return false;\n                    } 6433"];
6433 [label="this.CurrentToken.Kind 6434"];
6434 [label="get { return (SyntaxKind)this.RawKind; } 6435"];
6435 [label="return false; 6436"];
6436 [label="this.Reset(ref point); 6437"];
6437 [label="this.Reset(ref point) 6438"];
6438 [label="param Reset(ref ResetPoint state) 6439"];
6439 [label="param Reset(this) 6440"];
6440 [label="_termState 6441"];
6441 [label="_isInTry 6442"];
6442 [label="_syntaxFactoryContext.IsInAsync 6443"];
6443 [label="_syntaxFactoryContext.QueryDepth 6444"];
6444 [label="base.Reset(ref state.BaseResetPoint); 6445"];
6445 [label="base.Reset(ref state.BaseResetPoint) 6446"];
6446 [label="param Reset(ref ResetPoint point) 6447"];
6447 [label="param Reset(this) 6448"];
6448 [label="var offset = point.Position - _firstToken; 6449"];
6449 [label="Debug.Assert(offset >= 0); 6450"];
6450 [label="Debug.Assert(offset >= 0); 6451"];
6451 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 6452"];
6452 [label="_mode 6453"];
6453 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 6454"];
6454 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 6455"];
6455 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 6456"];
6456 [label="_tokenOffset 6457"];
6457 [label="_currentToken = null; 6458"];
6458 [label="_currentToken 6459"];
6459 [label="_currentNode = default(BlendedNode); 6460"];
6460 [label="_currentNode 6461"];
6461 [label="_prevTokenTrailingTrivia 6462"];
6462 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 6463"];
6463 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 6464"];
6464 [label="base.Reset(ref state.BaseResetPoint); 6465"];
6465 [label="this.Reset(ref point); 6466"];
6466 [label="this.Release(ref point); 6467"];
6467 [label="this.Release(ref point) 6468"];
6468 [label="param Release(ref ResetPoint state) 6469"];
6469 [label="param Release(this) 6470"];
6470 [label="base.Release(ref state.BaseResetPoint); 6471"];
6471 [label="base.Release(ref state.BaseResetPoint) 6472"];
6472 [label="param Release(ref ResetPoint point) 6473"];
6473 [label="param Release(this) 6474"];
6474 [label="Debug.Assert(_resetCount == point.ResetCount); 6475"];
6475 [label="_resetCount 6476"];
6476 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 6477"];
6477 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 6478"];
6478 [label="base.Release(ref state.BaseResetPoint); 6479"];
6479 [label="this.Release(ref point); 6480"];
6480 [label="if (IsImplicitObjectCreation())\n            {\n                @new = CheckFeatureAvailability(@new, MessageID.IDS_FeatureImplicitObjectCreation);\n            }\n            else\n            {\n                type = this.ParseType(ParseTypeMode.NewExpression);\n                if (type.Kind == SyntaxKind.ArrayType)\n                {\n                    // Check for an initializer.\n                    if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                    {\n                        initializer = this.ParseArrayInitializer();\n                    }\n\n                    return _syntaxFactory.ArrayCreationExpression(@new, (ArrayTypeSyntax)type, initializer);\n                }\n            } 6481"];
6481 [label="type = this.ParseType(ParseTypeMode.NewExpression); 6482"];
6482 [label="this.ParseType(ParseTypeMode.NewExpression) 6483"];
6483 [label="param ParseType(ParseTypeMode mode = ParseTypeMode.Normal) 6484"];
6484 [label="param ParseType(this) 6485"];
6485 [label="this.CurrentToken 6486"];
6486 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6487"];
6487 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6488"];
6488 [label="return _lexedTokens[_tokenOffset]; 6489"];
6489 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 6490"];
6490 [label="this.CurrentToken.Kind 6491"];
6491 [label="get { return (SyntaxKind)this.RawKind; } 6492"];
6492 [label="return ParseTypeCore(mode); 6493"];
6493 [label="return ParseTypeCore(mode); 6494"];
6494 [label="return ParseTypeCore(mode); 6495"];
6495 [label="param ParseUnderlyingType(ParseTypeMode mode) 6496"];
6496 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 6497"];
6497 [label="param ParseUnderlyingType(this) 6498"];
6498 [label="this.CurrentToken 6499"];
6499 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6500"];
6500 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 6501"];
6501 [label="this.CurrentToken.Kind 6502"];
6502 [label="get { return (SyntaxKind)this.RawKind; } 6503"];
6503 [label="IsPredefinedType(this.CurrentToken.Kind) 6504"];
6504 [label="param IsPredefinedType(SyntaxKind keyword) 6505"];
6505 [label="IsTrueIdentifier() 6506"];
6506 [label="param IsTrueIdentifier(this) 6507"];
6507 [label="return false; 6508"];
6508 [label="if (IsTrueIdentifier() || this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                return this.ParseQualifiedName(options);\n            } 6509"];
6509 [label="this.CurrentToken 6510"];
6510 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6511"];
6511 [label="if (IsTrueIdentifier() || this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                return this.ParseQualifiedName(options);\n            } 6512"];
6512 [label="this.CurrentToken.Kind 6513"];
6513 [label="get { return (SyntaxKind)this.RawKind; } 6514"];
6514 [label="if (IsTrueIdentifier() || this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                return this.ParseQualifiedName(options);\n            } 6515"];
6515 [label="this.CurrentToken 6516"];
6516 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6517"];
6517 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                return this.ParseTupleType();\n            }\n            else if (IsFunctionPointerStart())\n            {\n                return ParseFunctionPointerTypeSyntax();\n            } 6518"];
6518 [label="this.CurrentToken.Kind 6519"];
6519 [label="get { return (SyntaxKind)this.RawKind; } 6520"];
6520 [label="this.ParseTupleType() 6521"];
6521 [label="param ParseTupleType(this) 6522"];
6522 [label="var open = this.EatToken(SyntaxKind.OpenParenToken); 6523"];
6523 [label="this.EatToken(SyntaxKind.OpenParenToken) 6524"];
6524 [label="param EatToken(SyntaxKind kind) 6525"];
6525 [label="param EatToken(this) 6526"];
6526 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 6527"];
6527 [label="SyntaxFacts.IsAnyToken(kind) 6528"];
6528 [label="param IsAnyToken(SyntaxKind kind) 6529"];
6529 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 6530"];
6530 [label="return true; 6531"];
6531 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 6532"];
6532 [label="param GetTrailingTrivia(this) 6533"];
6533 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6534"];
6534 [label="MoveToNextToken(); 6535"];
6535 [label="return ct; 6536"];
6536 [label="var list = _pool.AllocateSeparated<TupleElementSyntax>(); 6537"];
6537 [label="this.CurrentToken 6538"];
6538 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6539"];
6539 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6540"];
6540 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 6541"];
6541 [label="if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n                {\n                    var element = ParseTupleElement();\n                    list.Add(element);\n\n                    while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        var comma = this.EatToken(SyntaxKind.CommaToken);\n                        list.AddSeparator(comma);\n\n                        element = ParseTupleElement();\n                        list.Add(element);\n                    }\n                } 6542"];
6542 [label="this.CurrentToken.Kind 6543"];
6543 [label="get { return (SyntaxKind)this.RawKind; } 6544"];
6544 [label="ParseTupleElement() 6545"];
6545 [label="param ParseTupleElement(this) 6546"];
6546 [label="var type = ParseType(); 6547"];
6547 [label="ParseType() 6548"];
6548 [label="param ParseType(ParseTypeMode mode = ParseTypeMode.Normal) 6549"];
6549 [label="param ParseType(this) 6550"];
6550 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 6551"];
6551 [label="this.CurrentToken.Kind 6552"];
6552 [label="get { return (SyntaxKind)this.RawKind; } 6553"];
6553 [label="return ParseTypeCore(mode); 6554"];
6554 [label="param ParseUnderlyingType(ParseTypeMode mode) 6555"];
6555 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 6556"];
6556 [label="this.CurrentToken 6557"];
6557 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6558"];
6558 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 6559"];
6559 [label="this.CurrentToken.Kind 6560"];
6560 [label="get { return (SyntaxKind)this.RawKind; } 6561"];
6561 [label="IsPredefinedType(this.CurrentToken.Kind) 6562"];
6562 [label="param IsPredefinedType(SyntaxKind keyword) 6563"];
6563 [label="this.EatToken() 6564"];
6564 [label="param GetTrailingTrivia(this) 6565"];
6565 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6566"];
6566 [label="MoveToNextToken(); 6567"];
6567 [label="var token = this.EatToken(); 6568"];
6568 [label="token.Kind 6569"];
6569 [label="get { return (SyntaxKind)this.RawKind; } 6570"];
6570 [label="if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                } 6571"];
6571 [label="return _syntaxFactory.PredefinedType(token); 6572"];
6572 [label="return _syntaxFactory.PredefinedType(token); 6573"];
6573 [label="param TryGetNode(int kind) 6574"];
6574 [label="param TryGetNode(GreenNode child1) 6575"];
6575 [label="param TryGetNode(SyntaxFactoryContext context) 6576"];
6576 [label="param TryGetNode(out int hash) 6577"];
6577 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 6578"];
6578 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 6579"];
6579 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 6580"];
6580 [label="GetNodeFlags(context) 6581"];
6581 [label="param GetNodeFlags(SyntaxFactoryContext context) 6582"];
6582 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 6583"];
6583 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 6584"];
6584 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 6585"];
6585 [label="return flags; 6586"];
6586 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 6587"];
6587 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 6588"];
6588 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 6589"];
6589 [label="param SetFactoryContext(SyntaxFactoryContext context) 6590"];
6590 [label="param SetFactoryContext(this) 6591"];
6591 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 6592"];
6592 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 6593"];
6593 [label="param IsMakingProgress(bool assertIfFalse = true) 6594"];
6594 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6595"];
6595 [label="SyntaxToken name = null; 6596"];
6596 [label="IsTrueIdentifier() 6597"];
6597 [label="param IsTrueIdentifier(this) 6598"];
6598 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6599"];
6599 [label="return false; 6600"];
6600 [label="if (IsTrueIdentifier())\n            {\n                name = this.ParseIdentifierToken();\n            } 6601"];
6601 [label="return _syntaxFactory.TupleElement(type, name); 6602"];
6602 [label="return _syntaxFactory.TupleElement(type, name); 6603"];
6603 [label="return _syntaxFactory.TupleElement(type, name); 6604"];
6604 [label="return _syntaxFactory.TupleElement(type, name); 6605"];
6605 [label="param TryGetNode(int kind) 6606"];
6606 [label="param TryGetNode(GreenNode child1) 6607"];
6607 [label="param TryGetNode(GreenNode child2) 6608"];
6608 [label="param TryGetNode(SyntaxFactoryContext context) 6609"];
6609 [label="param TryGetNode(out int hash) 6610"];
6610 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 6611"];
6611 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 6612"];
6612 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 6613"];
6613 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 6614"];
6614 [label="GetNodeFlags(context) 6615"];
6615 [label="param GetNodeFlags(SyntaxFactoryContext context) 6616"];
6616 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 6617"];
6617 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 6618"];
6618 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 6619"];
6619 [label="return flags; 6620"];
6620 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 6621"];
6621 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 6622"];
6622 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 6623"];
6623 [label="param SetFactoryContext(SyntaxFactoryContext context) 6624"];
6624 [label="param SetFactoryContext(this) 6625"];
6625 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 6626"];
6626 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 6627"];
6627 [label="var element = ParseTupleElement(); 6628"];
6628 [label="list.Add(element); 6629"];
6629 [label="this.CurrentToken 6630"];
6630 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6631"];
6631 [label="while (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        var comma = this.EatToken(SyntaxKind.CommaToken);\n                        list.AddSeparator(comma);\n\n                        element = ParseTupleElement();\n                        list.Add(element);\n                    } 6632"];
6632 [label="this.CurrentToken.Kind 6633"];
6633 [label="get { return (SyntaxKind)this.RawKind; } 6634"];
6634 [label="var comma = this.EatToken(SyntaxKind.CommaToken); 6635"];
6635 [label="this.EatToken(SyntaxKind.CommaToken) 6636"];
6636 [label="param EatToken(SyntaxKind kind) 6637"];
6637 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 6638"];
6638 [label="SyntaxFacts.IsAnyToken(kind) 6639"];
6639 [label="param IsAnyToken(SyntaxKind kind) 6640"];
6640 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 6641"];
6641 [label="return true; 6642"];
6642 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6643"];
6643 [label="MoveToNextToken(); 6644"];
6644 [label="return ct; 6645"];
6645 [label="list.AddSeparator(comma); 6646"];
6646 [label="ParseTupleElement() 6647"];
6647 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6648"];
6648 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 6649"];
6649 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 6650"];
6650 [label="this.CurrentToken.Kind 6651"];
6651 [label="get { return (SyntaxKind)this.RawKind; } 6652"];
6652 [label="param ParseUnderlyingType(ParseTypeMode mode) 6653"];
6653 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 6654"];
6654 [label="param GetTrailingTrivia(this) 6655"];
6655 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6656"];
6656 [label="MoveToNextToken(); 6657"];
6657 [label="token.Kind 6658"];
6658 [label="if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                } 6659"];
6659 [label="param TryGetNode(SyntaxFactoryContext context) 6660"];
6660 [label="param GetNodeFlags(SyntaxFactoryContext context) 6661"];
6661 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 6662"];
6662 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 6663"];
6663 [label="param IsMakingProgress(bool assertIfFalse = true) 6664"];
6664 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6665"];
6665 [label="IsTrueIdentifier() 6666"];
6666 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6667"];
6667 [label="return false; 6668"];
6668 [label="if (IsTrueIdentifier())\n            {\n                name = this.ParseIdentifierToken();\n            } 6669"];
6669 [label="param TryGetNode(SyntaxFactoryContext context) 6670"];
6670 [label="param GetNodeFlags(SyntaxFactoryContext context) 6671"];
6671 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 6672"];
6672 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 6673"];
6673 [label="element = ParseTupleElement(); 6674"];
6674 [label="list.Add(element); 6675"];
6675 [label="if (list.Count < 2)\n                {\n                    if (list.Count < 1)\n                    {\n                        list.Add(_syntaxFactory.TupleElement(this.CreateMissingIdentifierName(), identifier: null));\n                    }\n\n                    list.AddSeparator(SyntaxFactory.MissingToken(SyntaxKind.CommaToken));\n                    var missing = this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TupleTooFewElements);\n                    list.Add(_syntaxFactory.TupleElement(missing, identifier: null));\n                } 6676"];
6676 [label="if (list.Count < 2)\n                {\n                    if (list.Count < 1)\n                    {\n                        list.Add(_syntaxFactory.TupleElement(this.CreateMissingIdentifierName(), identifier: null));\n                    }\n\n                    list.AddSeparator(SyntaxFactory.MissingToken(SyntaxKind.CommaToken));\n                    var missing = this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_TupleTooFewElements);\n                    list.Add(_syntaxFactory.TupleElement(missing, identifier: null));\n                } 6677"];
6677 [label="var close = this.EatToken(SyntaxKind.CloseParenToken); 6678"];
6678 [label="this.EatToken(SyntaxKind.CloseParenToken) 6679"];
6679 [label="param EatToken(SyntaxKind kind) 6680"];
6680 [label="param EatToken(this) 6681"];
6681 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 6682"];
6682 [label="SyntaxFacts.IsAnyToken(kind) 6683"];
6683 [label="param IsAnyToken(SyntaxKind kind) 6684"];
6684 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 6685"];
6685 [label="return true; 6686"];
6686 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6687"];
6687 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 6688"];
6688 [label="param GetTrailingTrivia(this) 6689"];
6689 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6690"];
6690 [label="MoveToNextToken(); 6691"];
6691 [label="var result = _syntaxFactory.TupleType(open, list, close); 6692"];
6692 [label="var result = _syntaxFactory.TupleType(open, list, close); 6693"];
6693 [label="var result = _syntaxFactory.TupleType(open, list, close); 6694"];
6694 [label="var result = _syntaxFactory.TupleType(open, list, close); 6695"];
6695 [label="=> true 6696"];
6696 [label="true 6697"];
6697 [label="var result = _syntaxFactory.TupleType(open, list, close); 6698"];
6698 [label="param TryGetNode(int kind) 6699"];
6699 [label="param TryGetNode(GreenNode child1) 6700"];
6700 [label="param TryGetNode(GreenNode child2) 6701"];
6701 [label="param TryGetNode(GreenNode child3) 6702"];
6702 [label="param TryGetNode(SyntaxFactoryContext context) 6703"];
6703 [label="param TryGetNode(out int hash) 6704"];
6704 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 6705"];
6705 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 6706"];
6706 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 6707"];
6707 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 6708"];
6708 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 6709"];
6709 [label="GetNodeFlags(context) 6710"];
6710 [label="param GetNodeFlags(SyntaxFactoryContext context) 6711"];
6711 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 6712"];
6712 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 6713"];
6713 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 6714"];
6714 [label="return flags; 6715"];
6715 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 6716"];
6716 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 6717"];
6717 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 6718"];
6718 [label="param SetFactoryContext(SyntaxFactoryContext context) 6719"];
6719 [label="param SetFactoryContext(this) 6720"];
6720 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 6721"];
6721 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 6722"];
6722 [label="result = CheckFeatureAvailability(result, MessageID.IDS_FeatureTuples); 6723"];
6723 [label="result = CheckFeatureAvailability(result, MessageID.IDS_FeatureTuples); 6724"];
6724 [label="result = CheckFeatureAvailability(result, MessageID.IDS_FeatureTuples); 6725"];
6725 [label="CheckFeatureAvailability(result, MessageID.IDS_FeatureTuples) 6726"];
6726 [label="param CheckFeatureAvailability(TNode node) 6727"];
6727 [label="param CheckFeatureAvailability(MessageID feature) 6728"];
6728 [label="param CheckFeatureAvailability(bool forceWarning = false) 6729"];
6729 [label="param CheckFeatureAvailability(this) 6730"];
6730 [label="this.Options 6731"];
6731 [label="get { return this.lexer.Options; } 6732"];
6732 [label="this.lexer.Options 6733"];
6733 [label="get { return _options; } 6734"];
6734 [label="return _options; 6735"];
6735 [label="return this.lexer.Options; 6736"];
6736 [label="LanguageVersion availableVersion = this.Options.LanguageVersion; 6737"];
6737 [label="LanguageVersion requiredVersion = feature.RequiredVersion(); 6738"];
6738 [label="feature.RequiredVersion() 6739"];
6739 [label="param RequiredVersion(this MessageID feature) 6740"];
6740 [label="Debug.Assert(RequiredFeature(feature) == null); 6741"];
6741 [label="RequiredFeature(feature) 6742"];
6742 [label="param RequiredFeature(this MessageID feature) 6743"];
6743 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 6744"];
6744 [label="return null; 6745"];
6745 [label="Debug.Assert(RequiredFeature(feature) == null); 6746"];
6746 [label="switch (feature)\n            {\n                // C# preview features.\n                case MessageID.IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction:\n                    return LanguageVersion.Preview;\n                // C# 9.0 features.\n                case MessageID.IDS_FeatureLambdaDiscardParameters: // semantic check\n                case MessageID.IDS_FeatureFunctionPointers:\n                case MessageID.IDS_FeatureLocalFunctionAttributes: // syntax check\n                case MessageID.IDS_FeatureExternLocalFunctions: // syntax check\n                case MessageID.IDS_FeatureImplicitObjectCreation: // syntax check\n                case MessageID.IDS_FeatureMemberNotNull:\n                case MessageID.IDS_FeatureAndPattern:\n                case MessageID.IDS_FeatureNotPattern:\n                case MessageID.IDS_FeatureOrPattern:\n                case MessageID.IDS_FeatureParenthesizedPattern:\n                case MessageID.IDS_FeatureTypePattern:\n                case MessageID.IDS_FeatureRelationalPattern:\n                case MessageID.IDS_FeatureExtensionGetEnumerator: // semantic check\n                case MessageID.IDS_FeatureExtensionGetAsyncEnumerator: // semantic check\n                case MessageID.IDS_FeatureNativeInt:\n                case MessageID.IDS_FeatureExtendedPartialMethods: // semantic check\n                case MessageID.IDS_TopLevelStatements:\n                case MessageID.IDS_FeatureInitOnlySetters: // semantic check\n                case MessageID.IDS_FeatureRecords:\n                case MessageID.IDS_FeatureTargetTypedConditional:  // semantic check\n                case MessageID.IDS_FeatureCovariantReturnsForOverrides: // semantic check\n                case MessageID.IDS_FeatureStaticAnonymousFunction: // syntax check\n                case MessageID.IDS_FeatureModuleInitializers: // semantic check on method attribute\n                case MessageID.IDS_FeatureDefaultTypeParameterConstraint:\n                    return LanguageVersion.CSharp9;\n\n                case MessageID.IDS_FeatureVarianceSafetyForStaticInterfaceMembers: //semantic check\n                case MessageID.IDS_FeatureConstantInterpolatedStrings: //semantic check\n                    return LanguageVersion.Preview;\n\n                // C# 8.0 features.\n                case MessageID.IDS_FeatureAltInterpolatedVerbatimStrings:\n                case MessageID.IDS_FeatureCoalesceAssignmentExpression:\n                case MessageID.IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator:\n                case MessageID.IDS_FeatureNullableReferenceTypes: // syntax and semantic check\n                case MessageID.IDS_FeatureIndexOperator: // semantic check\n                case MessageID.IDS_FeatureRangeOperator: // semantic check\n                case MessageID.IDS_FeatureAsyncStreams:\n                case MessageID.IDS_FeatureRecursivePatterns:\n                case MessageID.IDS_FeatureUsingDeclarations:\n                case MessageID.IDS_FeatureStaticLocalFunctions:\n                case MessageID.IDS_FeatureNameShadowingInNestedFunctions:\n                case MessageID.IDS_FeatureUnmanagedConstructedTypes: // semantic check\n                case MessageID.IDS_FeatureObsoleteOnPropertyAccessor:\n                case MessageID.IDS_FeatureReadOnlyMembers:\n                case MessageID.IDS_DefaultInterfaceImplementation: // semantic check\n                case MessageID.IDS_OverrideWithConstraints: // semantic check\n                case MessageID.IDS_FeatureNestedStackalloc: // semantic check\n                case MessageID.IDS_FeatureNotNullGenericTypeConstraint:// semantic check\n                case MessageID.IDS_FeatureSwitchExpression:\n                case MessageID.IDS_FeatureAsyncUsing:\n                case MessageID.IDS_FeatureNullPointerConstantPattern: //semantic check\n                    return LanguageVersion.CSharp8;\n\n                // C# 7.3 features.\n                case MessageID.IDS_FeatureAttributesOnBackingFields: // semantic check\n                case MessageID.IDS_FeatureImprovedOverloadCandidates: // semantic check\n                case MessageID.IDS_FeatureTupleEquality: // semantic check\n                case MessageID.IDS_FeatureRefReassignment:\n                case MessageID.IDS_FeatureRefFor:\n                case MessageID.IDS_FeatureRefForEach:\n                case MessageID.IDS_FeatureEnumGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureDelegateGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureUnmanagedGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureStackAllocInitializer:\n                case MessageID.IDS_FeatureExpressionVariablesInQueriesAndInitializers: // semantic check\n                case MessageID.IDS_FeatureExtensibleFixedStatement:  // semantic check\n                case MessageID.IDS_FeatureIndexingMovableFixedBuffers: //semantic check\n                    return LanguageVersion.CSharp7_3;\n\n                // C# 7.2 features.\n                case MessageID.IDS_FeatureNonTrailingNamedArguments: // semantic check\n                case MessageID.IDS_FeatureLeadingDigitSeparator:\n                case MessageID.IDS_FeaturePrivateProtected:\n                case MessageID.IDS_FeatureReadOnlyReferences:\n                case MessageID.IDS_FeatureRefStructs:\n                case MessageID.IDS_FeatureReadOnlyStructs:\n                case MessageID.IDS_FeatureRefExtensionMethods:\n                case MessageID.IDS_FeatureRefConditional:\n                    return LanguageVersion.CSharp7_2;\n\n                // C# 7.1 features.\n                case MessageID.IDS_FeatureAsyncMain:\n                case MessageID.IDS_FeatureDefaultLiteral:\n                case MessageID.IDS_FeatureInferredTupleNames:\n                case MessageID.IDS_FeatureGenericPatternMatching:\n                    return LanguageVersion.CSharp7_1;\n\n                // C# 7 features.\n                case MessageID.IDS_FeatureBinaryLiteral:\n                case MessageID.IDS_FeatureDigitSeparator:\n                case MessageID.IDS_FeatureLocalFunctions:\n                case MessageID.IDS_FeatureRefLocalsReturns:\n                case MessageID.IDS_FeaturePatternMatching:\n                case MessageID.IDS_FeatureThrowExpression:\n                case MessageID.IDS_FeatureTuples:\n                case MessageID.IDS_FeatureOutVar:\n                case MessageID.IDS_FeatureExpressionBodiedAccessor:\n                case MessageID.IDS_FeatureExpressionBodiedDeOrConstructor:\n                case MessageID.IDS_FeatureDiscards:\n                    return LanguageVersion.CSharp7;\n\n                // C# 6 features.\n                case MessageID.IDS_FeatureExceptionFilter:\n                case MessageID.IDS_FeatureAutoPropertyInitializer:\n                case MessageID.IDS_FeatureNullPropagatingOperator:\n                case MessageID.IDS_FeatureExpressionBodiedMethod:\n                case MessageID.IDS_FeatureExpressionBodiedProperty:\n                case MessageID.IDS_FeatureExpressionBodiedIndexer:\n                case MessageID.IDS_FeatureNameof:\n                case MessageID.IDS_FeatureDictionaryInitializer:\n                case MessageID.IDS_FeatureUsingStatic:\n                case MessageID.IDS_FeatureInterpolatedStrings:\n                case MessageID.IDS_AwaitInCatchAndFinally:\n                case MessageID.IDS_FeatureReadonlyAutoImplementedProperties:\n                    return LanguageVersion.CSharp6;\n\n                // C# 5 features.\n                case MessageID.IDS_FeatureAsync:\n                    return LanguageVersion.CSharp5;\n\n                // C# 4 features.\n                case MessageID.IDS_FeatureDynamic: // Checked in the binder.\n                case MessageID.IDS_FeatureTypeVariance:\n                case MessageID.IDS_FeatureNamedArgument:\n                case MessageID.IDS_FeatureOptionalParameter:\n                    return LanguageVersion.CSharp4;\n\n                // C# 3 features.\n                case MessageID.IDS_FeatureImplicitArray:\n                case MessageID.IDS_FeatureAnonymousTypes:\n                case MessageID.IDS_FeatureObjectInitializer:\n                case MessageID.IDS_FeatureCollectionInitializer:\n                case MessageID.IDS_FeatureLambda:\n                case MessageID.IDS_FeatureQueryExpression:\n                case MessageID.IDS_FeatureExtensionMethod:\n                case MessageID.IDS_FeaturePartialMethod:\n                case MessageID.IDS_FeatureImplicitLocal: // Checked in the binder.\n                case MessageID.IDS_FeatureAutoImplementedProperties:\n                    return LanguageVersion.CSharp3;\n\n                // C# 2 features.\n                case MessageID.IDS_FeatureGenerics: // Also affects crefs.\n                case MessageID.IDS_FeatureAnonDelegates:\n                case MessageID.IDS_FeatureGlobalNamespace: // Also affects crefs.\n                case MessageID.IDS_FeatureFixedBuffer:\n                case MessageID.IDS_FeatureStaticClasses:\n                case MessageID.IDS_FeaturePartialTypes:\n                case MessageID.IDS_FeaturePropertyAccessorMods:\n                case MessageID.IDS_FeatureExternAlias:\n                case MessageID.IDS_FeatureIterators:\n                case MessageID.IDS_FeatureDefault:\n                case MessageID.IDS_FeatureNullable:\n                case MessageID.IDS_FeaturePragma: // Checked in the directive parser.\n                case MessageID.IDS_FeatureSwitchOnBool: // Checked in the binder.\n                    return LanguageVersion.CSharp2;\n\n                // Special C# 2 feature: only a warning in C# 1.\n                case MessageID.IDS_FeatureModuleAttrLoc:\n                    return LanguageVersion.CSharp1;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(feature);\n            } 6747"];
6747 [label="return LanguageVersion.CSharp7; 6748"];
6748 [label="switch (feature)\n            {\n                case MessageID.IDS_FeatureModuleAttrLoc:\n                    return availableVersion >= LanguageVersion.CSharp2\n                        ? node\n                        : this.AddError(node, ErrorCode.WRN_NonECMAFeature, feature.Localize());\n\n                case MessageID.IDS_FeatureAltInterpolatedVerbatimStrings:\n                    return availableVersion >= requiredVersion\n                        ? node\n                        : this.AddError(node, ErrorCode.ERR_AltInterpolatedVerbatimStringsNotAvailable,\n                            new CSharpRequiredLanguageVersion(requiredVersion));\n            } 6749"];
6749 [label="var info = feature.GetFeatureAvailabilityDiagnosticInfo(this.Options); 6750"];
6750 [label="this.Options 6751"];
6751 [label="get { return this.lexer.Options; } 6752"];
6752 [label="this.lexer.Options 6753"];
6753 [label="get { return _options; } 6754"];
6754 [label="return _options; 6755"];
6755 [label="return this.lexer.Options; 6756"];
6756 [label="var info = feature.GetFeatureAvailabilityDiagnosticInfo(this.Options); 6757"];
6757 [label="feature.GetFeatureAvailabilityDiagnosticInfo(this.Options) 6758"];
6758 [label="param GetFeatureAvailabilityDiagnosticInfo(this MessageID feature) 6759"];
6759 [label="param GetFeatureAvailabilityDiagnosticInfo(CSharpParseOptions options) 6760"];
6760 [label="feature 6761"];
6761 [label="options.IsFeatureEnabled(feature) 6762"];
6762 [label="param IsFeatureEnabled(MessageID feature) 6763"];
6763 [label="param IsFeatureEnabled(this) 6764"];
6764 [label="string? featureFlag = feature.RequiredFeature(); 6765"];
6765 [label="feature.RequiredFeature() 6766"];
6766 [label="param RequiredFeature(this MessageID feature) 6767"];
6767 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 6768"];
6768 [label="return null; 6769"];
6769 [label="if (featureFlag != null)\n            {\n                return Features.ContainsKey(featureFlag);\n            } 6770"];
6770 [label="if (featureFlag != null)\n            {\n                return Features.ContainsKey(featureFlag);\n            } 6771"];
6771 [label="LanguageVersion availableVersion = LanguageVersion; 6772"];
6772 [label="LanguageVersion requiredVersion = feature.RequiredVersion(); 6773"];
6773 [label="feature.RequiredVersion() 6774"];
6774 [label="param RequiredVersion(this MessageID feature) 6775"];
6775 [label="Debug.Assert(RequiredFeature(feature) == null); 6776"];
6776 [label="RequiredFeature(feature) 6777"];
6777 [label="param RequiredFeature(this MessageID feature) 6778"];
6778 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 6779"];
6779 [label="return null; 6780"];
6780 [label="Debug.Assert(RequiredFeature(feature) == null); 6781"];
6781 [label="switch (feature)\n            {\n                // C# preview features.\n                case MessageID.IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction:\n                    return LanguageVersion.Preview;\n                // C# 9.0 features.\n                case MessageID.IDS_FeatureLambdaDiscardParameters: // semantic check\n                case MessageID.IDS_FeatureFunctionPointers:\n                case MessageID.IDS_FeatureLocalFunctionAttributes: // syntax check\n                case MessageID.IDS_FeatureExternLocalFunctions: // syntax check\n                case MessageID.IDS_FeatureImplicitObjectCreation: // syntax check\n                case MessageID.IDS_FeatureMemberNotNull:\n                case MessageID.IDS_FeatureAndPattern:\n                case MessageID.IDS_FeatureNotPattern:\n                case MessageID.IDS_FeatureOrPattern:\n                case MessageID.IDS_FeatureParenthesizedPattern:\n                case MessageID.IDS_FeatureTypePattern:\n                case MessageID.IDS_FeatureRelationalPattern:\n                case MessageID.IDS_FeatureExtensionGetEnumerator: // semantic check\n                case MessageID.IDS_FeatureExtensionGetAsyncEnumerator: // semantic check\n                case MessageID.IDS_FeatureNativeInt:\n                case MessageID.IDS_FeatureExtendedPartialMethods: // semantic check\n                case MessageID.IDS_TopLevelStatements:\n                case MessageID.IDS_FeatureInitOnlySetters: // semantic check\n                case MessageID.IDS_FeatureRecords:\n                case MessageID.IDS_FeatureTargetTypedConditional:  // semantic check\n                case MessageID.IDS_FeatureCovariantReturnsForOverrides: // semantic check\n                case MessageID.IDS_FeatureStaticAnonymousFunction: // syntax check\n                case MessageID.IDS_FeatureModuleInitializers: // semantic check on method attribute\n                case MessageID.IDS_FeatureDefaultTypeParameterConstraint:\n                    return LanguageVersion.CSharp9;\n\n                case MessageID.IDS_FeatureVarianceSafetyForStaticInterfaceMembers: //semantic check\n                case MessageID.IDS_FeatureConstantInterpolatedStrings: //semantic check\n                    return LanguageVersion.Preview;\n\n                // C# 8.0 features.\n                case MessageID.IDS_FeatureAltInterpolatedVerbatimStrings:\n                case MessageID.IDS_FeatureCoalesceAssignmentExpression:\n                case MessageID.IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator:\n                case MessageID.IDS_FeatureNullableReferenceTypes: // syntax and semantic check\n                case MessageID.IDS_FeatureIndexOperator: // semantic check\n                case MessageID.IDS_FeatureRangeOperator: // semantic check\n                case MessageID.IDS_FeatureAsyncStreams:\n                case MessageID.IDS_FeatureRecursivePatterns:\n                case MessageID.IDS_FeatureUsingDeclarations:\n                case MessageID.IDS_FeatureStaticLocalFunctions:\n                case MessageID.IDS_FeatureNameShadowingInNestedFunctions:\n                case MessageID.IDS_FeatureUnmanagedConstructedTypes: // semantic check\n                case MessageID.IDS_FeatureObsoleteOnPropertyAccessor:\n                case MessageID.IDS_FeatureReadOnlyMembers:\n                case MessageID.IDS_DefaultInterfaceImplementation: // semantic check\n                case MessageID.IDS_OverrideWithConstraints: // semantic check\n                case MessageID.IDS_FeatureNestedStackalloc: // semantic check\n                case MessageID.IDS_FeatureNotNullGenericTypeConstraint:// semantic check\n                case MessageID.IDS_FeatureSwitchExpression:\n                case MessageID.IDS_FeatureAsyncUsing:\n                case MessageID.IDS_FeatureNullPointerConstantPattern: //semantic check\n                    return LanguageVersion.CSharp8;\n\n                // C# 7.3 features.\n                case MessageID.IDS_FeatureAttributesOnBackingFields: // semantic check\n                case MessageID.IDS_FeatureImprovedOverloadCandidates: // semantic check\n                case MessageID.IDS_FeatureTupleEquality: // semantic check\n                case MessageID.IDS_FeatureRefReassignment:\n                case MessageID.IDS_FeatureRefFor:\n                case MessageID.IDS_FeatureRefForEach:\n                case MessageID.IDS_FeatureEnumGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureDelegateGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureUnmanagedGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureStackAllocInitializer:\n                case MessageID.IDS_FeatureExpressionVariablesInQueriesAndInitializers: // semantic check\n                case MessageID.IDS_FeatureExtensibleFixedStatement:  // semantic check\n                case MessageID.IDS_FeatureIndexingMovableFixedBuffers: //semantic check\n                    return LanguageVersion.CSharp7_3;\n\n                // C# 7.2 features.\n                case MessageID.IDS_FeatureNonTrailingNamedArguments: // semantic check\n                case MessageID.IDS_FeatureLeadingDigitSeparator:\n                case MessageID.IDS_FeaturePrivateProtected:\n                case MessageID.IDS_FeatureReadOnlyReferences:\n                case MessageID.IDS_FeatureRefStructs:\n                case MessageID.IDS_FeatureReadOnlyStructs:\n                case MessageID.IDS_FeatureRefExtensionMethods:\n                case MessageID.IDS_FeatureRefConditional:\n                    return LanguageVersion.CSharp7_2;\n\n                // C# 7.1 features.\n                case MessageID.IDS_FeatureAsyncMain:\n                case MessageID.IDS_FeatureDefaultLiteral:\n                case MessageID.IDS_FeatureInferredTupleNames:\n                case MessageID.IDS_FeatureGenericPatternMatching:\n                    return LanguageVersion.CSharp7_1;\n\n                // C# 7 features.\n                case MessageID.IDS_FeatureBinaryLiteral:\n                case MessageID.IDS_FeatureDigitSeparator:\n                case MessageID.IDS_FeatureLocalFunctions:\n                case MessageID.IDS_FeatureRefLocalsReturns:\n                case MessageID.IDS_FeaturePatternMatching:\n                case MessageID.IDS_FeatureThrowExpression:\n                case MessageID.IDS_FeatureTuples:\n                case MessageID.IDS_FeatureOutVar:\n                case MessageID.IDS_FeatureExpressionBodiedAccessor:\n                case MessageID.IDS_FeatureExpressionBodiedDeOrConstructor:\n                case MessageID.IDS_FeatureDiscards:\n                    return LanguageVersion.CSharp7;\n\n                // C# 6 features.\n                case MessageID.IDS_FeatureExceptionFilter:\n                case MessageID.IDS_FeatureAutoPropertyInitializer:\n                case MessageID.IDS_FeatureNullPropagatingOperator:\n                case MessageID.IDS_FeatureExpressionBodiedMethod:\n                case MessageID.IDS_FeatureExpressionBodiedProperty:\n                case MessageID.IDS_FeatureExpressionBodiedIndexer:\n                case MessageID.IDS_FeatureNameof:\n                case MessageID.IDS_FeatureDictionaryInitializer:\n                case MessageID.IDS_FeatureUsingStatic:\n                case MessageID.IDS_FeatureInterpolatedStrings:\n                case MessageID.IDS_AwaitInCatchAndFinally:\n                case MessageID.IDS_FeatureReadonlyAutoImplementedProperties:\n                    return LanguageVersion.CSharp6;\n\n                // C# 5 features.\n                case MessageID.IDS_FeatureAsync:\n                    return LanguageVersion.CSharp5;\n\n                // C# 4 features.\n                case MessageID.IDS_FeatureDynamic: // Checked in the binder.\n                case MessageID.IDS_FeatureTypeVariance:\n                case MessageID.IDS_FeatureNamedArgument:\n                case MessageID.IDS_FeatureOptionalParameter:\n                    return LanguageVersion.CSharp4;\n\n                // C# 3 features.\n                case MessageID.IDS_FeatureImplicitArray:\n                case MessageID.IDS_FeatureAnonymousTypes:\n                case MessageID.IDS_FeatureObjectInitializer:\n                case MessageID.IDS_FeatureCollectionInitializer:\n                case MessageID.IDS_FeatureLambda:\n                case MessageID.IDS_FeatureQueryExpression:\n                case MessageID.IDS_FeatureExtensionMethod:\n                case MessageID.IDS_FeaturePartialMethod:\n                case MessageID.IDS_FeatureImplicitLocal: // Checked in the binder.\n                case MessageID.IDS_FeatureAutoImplementedProperties:\n                    return LanguageVersion.CSharp3;\n\n                // C# 2 features.\n                case MessageID.IDS_FeatureGenerics: // Also affects crefs.\n                case MessageID.IDS_FeatureAnonDelegates:\n                case MessageID.IDS_FeatureGlobalNamespace: // Also affects crefs.\n                case MessageID.IDS_FeatureFixedBuffer:\n                case MessageID.IDS_FeatureStaticClasses:\n                case MessageID.IDS_FeaturePartialTypes:\n                case MessageID.IDS_FeaturePropertyAccessorMods:\n                case MessageID.IDS_FeatureExternAlias:\n                case MessageID.IDS_FeatureIterators:\n                case MessageID.IDS_FeatureDefault:\n                case MessageID.IDS_FeatureNullable:\n                case MessageID.IDS_FeaturePragma: // Checked in the directive parser.\n                case MessageID.IDS_FeatureSwitchOnBool: // Checked in the binder.\n                    return LanguageVersion.CSharp2;\n\n                // Special C# 2 feature: only a warning in C# 1.\n                case MessageID.IDS_FeatureModuleAttrLoc:\n                    return LanguageVersion.CSharp1;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(feature);\n            } 6782"];
6782 [label="return LanguageVersion.CSharp7; 6783"];
6783 [label="return availableVersion >= requiredVersion; 6784"];
6784 [label="null 6785"];
6785 [label="options.IsFeatureEnabled(feature) ? null : GetDisabledFeatureDiagnosticInfo(feature, options.LanguageVersion) 6786"];
6786 [label="if (info != null)\n            {\n                if (forceWarning)\n                {\n                    return AddError(node, ErrorCode.WRN_ErrorOverride, info, (int)info.Code);\n                }\n\n                return AddError(node, info.Code, info.Arguments);\n            } 6787"];
6787 [label="if (info != null)\n            {\n                if (forceWarning)\n                {\n                    return AddError(node, ErrorCode.WRN_ErrorOverride, info, (int)info.Code);\n                }\n\n                return AddError(node, info.Code, info.Arguments);\n            } 6788"];
6788 [label="return node; 6789"];
6789 [label="return result; 6790"];
6790 [label="_pool.Free(list); 6791"];
6791 [label="_pool.Free(list); 6792"];
6792 [label="return this.ParseTupleType(); 6793"];
6793 [label="return ParseTypeCore(mode); 6794"];
6794 [label="param IsMakingProgress(bool assertIfFalse = true) 6795"];
6795 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6796"];
6796 [label="Debug.Assert(n >= 0); 6797"];
6797 [label="Debug.Assert(n >= 0); 6798"];
6798 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6799"];
6799 [label="param EatNullableQualifierIfApplicable(ParseTypeMode mode) 6800"];
6800 [label="param EatNullableQualifierIfApplicable(this) 6801"];
6801 [label="this.CurrentToken 6802"];
6802 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6803"];
6803 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.QuestionToken); 6804"];
6804 [label="this.CurrentToken.Kind 6805"];
6805 [label="get { return (SyntaxKind)this.RawKind; } 6806"];
6806 [label="this.GetResetPoint() 6807"];
6807 [label="param GetResetPoint(this) 6808"];
6808 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 6809"];
6809 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 6810"];
6810 [label="param ResetPoint(this) 6811"];
6811 [label="var resetPoint = this.GetResetPoint(); 6812"];
6812 [label="this.EatToken() 6813"];
6813 [label="param EatToken(this) 6814"];
6814 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6815"];
6815 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6816"];
6816 [label="MoveToNextToken(); 6817"];
6817 [label="var questionToken = this.EatToken(); 6818"];
6818 [label="if (!canFollowNullableType(mode))\n                {\n                    // Restore current token index\n                    this.Reset(ref resetPoint);\n                    return null;\n                } 6819"];
6819 [label="canFollowNullableType(mode) 6820"];
6820 [label="bool canFollowNullableType(ParseTypeMode lMode)\n                {\n                    switch (lMode)\n                    {\n                        case ParseTypeMode.AfterIs:\n                        case ParseTypeMode.DefinitePattern:\n                        case ParseTypeMode.AsExpression:\n                            // These contexts might be a type that is at the end of an expression.\n                            // In these contexts we only permit the nullable qualifier if it is followed\n                            // by a token that could not start an expression, because for backward\n                            // compatibility we want to consider a `?` token as part of the `?:`\n                            // operator if possible.\n                            return !CanStartExpression();\n                        case ParseTypeMode.NewExpression:\n                            // A nullable qualifier is permitted as part of the type in a `new` expression.\n                            // e.g. `new int?()` is allowed.  It creates a null value of type `Nullable<int>`.\n                            // Similarly `new int? {}` is allowed.\n                            return\n                                this.CurrentToken.Kind == SyntaxKind.OpenParenToken ||   // ctor parameters\n                                this.CurrentToken.Kind == SyntaxKind.OpenBracketToken ||   // array type\n                                this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;   // object initializer\n                        default:\n                            return true;\n                    }\n                } 6821"];
6821 [label="bool canFollowNullableType(ParseTypeMode lMode)\n                {\n                    switch (lMode)\n                    {\n                        case ParseTypeMode.AfterIs:\n                        case ParseTypeMode.DefinitePattern:\n                        case ParseTypeMode.AsExpression:\n                            // These contexts might be a type that is at the end of an expression.\n                            // In these contexts we only permit the nullable qualifier if it is followed\n                            // by a token that could not start an expression, because for backward\n                            // compatibility we want to consider a `?` token as part of the `?:`\n                            // operator if possible.\n                            return !CanStartExpression();\n                        case ParseTypeMode.NewExpression:\n                            // A nullable qualifier is permitted as part of the type in a `new` expression.\n                            // e.g. `new int?()` is allowed.  It creates a null value of type `Nullable<int>`.\n                            // Similarly `new int? {}` is allowed.\n                            return\n                                this.CurrentToken.Kind == SyntaxKind.OpenParenToken ||   // ctor parameters\n                                this.CurrentToken.Kind == SyntaxKind.OpenBracketToken ||   // array type\n                                this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;   // object initializer\n                        default:\n                            return true;\n                    }\n                } 6822"];
6822 [label="switch (lMode)\n                    {\n                        case ParseTypeMode.AfterIs:\n                        case ParseTypeMode.DefinitePattern:\n                        case ParseTypeMode.AsExpression:\n                            // These contexts might be a type that is at the end of an expression.\n                            // In these contexts we only permit the nullable qualifier if it is followed\n                            // by a token that could not start an expression, because for backward\n                            // compatibility we want to consider a `?` token as part of the `?:`\n                            // operator if possible.\n                            return !CanStartExpression();\n                        case ParseTypeMode.NewExpression:\n                            // A nullable qualifier is permitted as part of the type in a `new` expression.\n                            // e.g. `new int?()` is allowed.  It creates a null value of type `Nullable<int>`.\n                            // Similarly `new int? {}` is allowed.\n                            return\n                                this.CurrentToken.Kind == SyntaxKind.OpenParenToken ||   // ctor parameters\n                                this.CurrentToken.Kind == SyntaxKind.OpenBracketToken ||   // array type\n                                this.CurrentToken.Kind == SyntaxKind.OpenBraceToken;   // object initializer\n                        default:\n                            return true;\n                    } 6823"];
6823 [label="this.CurrentToken 6824"];
6824 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6825"];
6825 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6826"];
6826 [label="return\n                                this.CurrentToken.Kind == SyntaxKind.OpenParenToken ||   // ctor parameters\n                                this.CurrentToken.Kind == SyntaxKind.OpenBracketToken ||   // array type\n                                this.CurrentToken.Kind == SyntaxKind.OpenBraceToken; 6827"];
6827 [label="this.CurrentToken.Kind 6828"];
6828 [label="get { return (SyntaxKind)this.RawKind; } 6829"];
6829 [label="this.CurrentToken 6830"];
6830 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6831"];
6831 [label="return\n                                this.CurrentToken.Kind == SyntaxKind.OpenParenToken ||   // ctor parameters\n                                this.CurrentToken.Kind == SyntaxKind.OpenBracketToken ||   // array type\n                                this.CurrentToken.Kind == SyntaxKind.OpenBraceToken; 6832"];
6832 [label="this.CurrentToken.Kind 6833"];
6833 [label="get { return (SyntaxKind)this.RawKind; } 6834"];
6834 [label="return\n                                this.CurrentToken.Kind == SyntaxKind.OpenParenToken ||   // ctor parameters\n                                this.CurrentToken.Kind == SyntaxKind.OpenBracketToken ||   // array type\n                                this.CurrentToken.Kind == SyntaxKind.OpenBraceToken; 6835"];
6835 [label="this.CurrentToken 6836"];
6836 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6837"];
6837 [label="return\n                                this.CurrentToken.Kind == SyntaxKind.OpenParenToken ||   // ctor parameters\n                                this.CurrentToken.Kind == SyntaxKind.OpenBracketToken ||   // array type\n                                this.CurrentToken.Kind == SyntaxKind.OpenBraceToken; 6838"];
6838 [label="this.CurrentToken.Kind 6839"];
6839 [label="get { return (SyntaxKind)this.RawKind; } 6840"];
6840 [label="return\n                                this.CurrentToken.Kind == SyntaxKind.OpenParenToken ||   // ctor parameters\n                                this.CurrentToken.Kind == SyntaxKind.OpenBracketToken ||   // array type\n                                this.CurrentToken.Kind == SyntaxKind.OpenBraceToken; 6841"];
6841 [label="return CheckFeatureAvailability(questionToken, MessageID.IDS_FeatureNullable); 6842"];
6842 [label="return CheckFeatureAvailability(questionToken, MessageID.IDS_FeatureNullable); 6843"];
6843 [label="return CheckFeatureAvailability(questionToken, MessageID.IDS_FeatureNullable); 6844"];
6844 [label="CheckFeatureAvailability(questionToken, MessageID.IDS_FeatureNullable) 6845"];
6845 [label="param CheckFeatureAvailability(TNode node) 6846"];
6846 [label="param CheckFeatureAvailability(MessageID feature) 6847"];
6847 [label="param CheckFeatureAvailability(bool forceWarning = false) 6848"];
6848 [label="param CheckFeatureAvailability(this) 6849"];
6849 [label="this.Options 6850"];
6850 [label="get { return this.lexer.Options; } 6851"];
6851 [label="this.lexer.Options 6852"];
6852 [label="get { return _options; } 6853"];
6853 [label="return _options; 6854"];
6854 [label="return this.lexer.Options; 6855"];
6855 [label="LanguageVersion availableVersion = this.Options.LanguageVersion; 6856"];
6856 [label="LanguageVersion requiredVersion = feature.RequiredVersion(); 6857"];
6857 [label="feature.RequiredVersion() 6858"];
6858 [label="param RequiredVersion(this MessageID feature) 6859"];
6859 [label="Debug.Assert(RequiredFeature(feature) == null); 6860"];
6860 [label="RequiredFeature(feature) 6861"];
6861 [label="param RequiredFeature(this MessageID feature) 6862"];
6862 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 6863"];
6863 [label="return null; 6864"];
6864 [label="Debug.Assert(RequiredFeature(feature) == null); 6865"];
6865 [label="switch (feature)\n            {\n                // C# preview features.\n                case MessageID.IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction:\n                    return LanguageVersion.Preview;\n                // C# 9.0 features.\n                case MessageID.IDS_FeatureLambdaDiscardParameters: // semantic check\n                case MessageID.IDS_FeatureFunctionPointers:\n                case MessageID.IDS_FeatureLocalFunctionAttributes: // syntax check\n                case MessageID.IDS_FeatureExternLocalFunctions: // syntax check\n                case MessageID.IDS_FeatureImplicitObjectCreation: // syntax check\n                case MessageID.IDS_FeatureMemberNotNull:\n                case MessageID.IDS_FeatureAndPattern:\n                case MessageID.IDS_FeatureNotPattern:\n                case MessageID.IDS_FeatureOrPattern:\n                case MessageID.IDS_FeatureParenthesizedPattern:\n                case MessageID.IDS_FeatureTypePattern:\n                case MessageID.IDS_FeatureRelationalPattern:\n                case MessageID.IDS_FeatureExtensionGetEnumerator: // semantic check\n                case MessageID.IDS_FeatureExtensionGetAsyncEnumerator: // semantic check\n                case MessageID.IDS_FeatureNativeInt:\n                case MessageID.IDS_FeatureExtendedPartialMethods: // semantic check\n                case MessageID.IDS_TopLevelStatements:\n                case MessageID.IDS_FeatureInitOnlySetters: // semantic check\n                case MessageID.IDS_FeatureRecords:\n                case MessageID.IDS_FeatureTargetTypedConditional:  // semantic check\n                case MessageID.IDS_FeatureCovariantReturnsForOverrides: // semantic check\n                case MessageID.IDS_FeatureStaticAnonymousFunction: // syntax check\n                case MessageID.IDS_FeatureModuleInitializers: // semantic check on method attribute\n                case MessageID.IDS_FeatureDefaultTypeParameterConstraint:\n                    return LanguageVersion.CSharp9;\n\n                case MessageID.IDS_FeatureVarianceSafetyForStaticInterfaceMembers: //semantic check\n                case MessageID.IDS_FeatureConstantInterpolatedStrings: //semantic check\n                    return LanguageVersion.Preview;\n\n                // C# 8.0 features.\n                case MessageID.IDS_FeatureAltInterpolatedVerbatimStrings:\n                case MessageID.IDS_FeatureCoalesceAssignmentExpression:\n                case MessageID.IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator:\n                case MessageID.IDS_FeatureNullableReferenceTypes: // syntax and semantic check\n                case MessageID.IDS_FeatureIndexOperator: // semantic check\n                case MessageID.IDS_FeatureRangeOperator: // semantic check\n                case MessageID.IDS_FeatureAsyncStreams:\n                case MessageID.IDS_FeatureRecursivePatterns:\n                case MessageID.IDS_FeatureUsingDeclarations:\n                case MessageID.IDS_FeatureStaticLocalFunctions:\n                case MessageID.IDS_FeatureNameShadowingInNestedFunctions:\n                case MessageID.IDS_FeatureUnmanagedConstructedTypes: // semantic check\n                case MessageID.IDS_FeatureObsoleteOnPropertyAccessor:\n                case MessageID.IDS_FeatureReadOnlyMembers:\n                case MessageID.IDS_DefaultInterfaceImplementation: // semantic check\n                case MessageID.IDS_OverrideWithConstraints: // semantic check\n                case MessageID.IDS_FeatureNestedStackalloc: // semantic check\n                case MessageID.IDS_FeatureNotNullGenericTypeConstraint:// semantic check\n                case MessageID.IDS_FeatureSwitchExpression:\n                case MessageID.IDS_FeatureAsyncUsing:\n                case MessageID.IDS_FeatureNullPointerConstantPattern: //semantic check\n                    return LanguageVersion.CSharp8;\n\n                // C# 7.3 features.\n                case MessageID.IDS_FeatureAttributesOnBackingFields: // semantic check\n                case MessageID.IDS_FeatureImprovedOverloadCandidates: // semantic check\n                case MessageID.IDS_FeatureTupleEquality: // semantic check\n                case MessageID.IDS_FeatureRefReassignment:\n                case MessageID.IDS_FeatureRefFor:\n                case MessageID.IDS_FeatureRefForEach:\n                case MessageID.IDS_FeatureEnumGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureDelegateGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureUnmanagedGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureStackAllocInitializer:\n                case MessageID.IDS_FeatureExpressionVariablesInQueriesAndInitializers: // semantic check\n                case MessageID.IDS_FeatureExtensibleFixedStatement:  // semantic check\n                case MessageID.IDS_FeatureIndexingMovableFixedBuffers: //semantic check\n                    return LanguageVersion.CSharp7_3;\n\n                // C# 7.2 features.\n                case MessageID.IDS_FeatureNonTrailingNamedArguments: // semantic check\n                case MessageID.IDS_FeatureLeadingDigitSeparator:\n                case MessageID.IDS_FeaturePrivateProtected:\n                case MessageID.IDS_FeatureReadOnlyReferences:\n                case MessageID.IDS_FeatureRefStructs:\n                case MessageID.IDS_FeatureReadOnlyStructs:\n                case MessageID.IDS_FeatureRefExtensionMethods:\n                case MessageID.IDS_FeatureRefConditional:\n                    return LanguageVersion.CSharp7_2;\n\n                // C# 7.1 features.\n                case MessageID.IDS_FeatureAsyncMain:\n                case MessageID.IDS_FeatureDefaultLiteral:\n                case MessageID.IDS_FeatureInferredTupleNames:\n                case MessageID.IDS_FeatureGenericPatternMatching:\n                    return LanguageVersion.CSharp7_1;\n\n                // C# 7 features.\n                case MessageID.IDS_FeatureBinaryLiteral:\n                case MessageID.IDS_FeatureDigitSeparator:\n                case MessageID.IDS_FeatureLocalFunctions:\n                case MessageID.IDS_FeatureRefLocalsReturns:\n                case MessageID.IDS_FeaturePatternMatching:\n                case MessageID.IDS_FeatureThrowExpression:\n                case MessageID.IDS_FeatureTuples:\n                case MessageID.IDS_FeatureOutVar:\n                case MessageID.IDS_FeatureExpressionBodiedAccessor:\n                case MessageID.IDS_FeatureExpressionBodiedDeOrConstructor:\n                case MessageID.IDS_FeatureDiscards:\n                    return LanguageVersion.CSharp7;\n\n                // C# 6 features.\n                case MessageID.IDS_FeatureExceptionFilter:\n                case MessageID.IDS_FeatureAutoPropertyInitializer:\n                case MessageID.IDS_FeatureNullPropagatingOperator:\n                case MessageID.IDS_FeatureExpressionBodiedMethod:\n                case MessageID.IDS_FeatureExpressionBodiedProperty:\n                case MessageID.IDS_FeatureExpressionBodiedIndexer:\n                case MessageID.IDS_FeatureNameof:\n                case MessageID.IDS_FeatureDictionaryInitializer:\n                case MessageID.IDS_FeatureUsingStatic:\n                case MessageID.IDS_FeatureInterpolatedStrings:\n                case MessageID.IDS_AwaitInCatchAndFinally:\n                case MessageID.IDS_FeatureReadonlyAutoImplementedProperties:\n                    return LanguageVersion.CSharp6;\n\n                // C# 5 features.\n                case MessageID.IDS_FeatureAsync:\n                    return LanguageVersion.CSharp5;\n\n                // C# 4 features.\n                case MessageID.IDS_FeatureDynamic: // Checked in the binder.\n                case MessageID.IDS_FeatureTypeVariance:\n                case MessageID.IDS_FeatureNamedArgument:\n                case MessageID.IDS_FeatureOptionalParameter:\n                    return LanguageVersion.CSharp4;\n\n                // C# 3 features.\n                case MessageID.IDS_FeatureImplicitArray:\n                case MessageID.IDS_FeatureAnonymousTypes:\n                case MessageID.IDS_FeatureObjectInitializer:\n                case MessageID.IDS_FeatureCollectionInitializer:\n                case MessageID.IDS_FeatureLambda:\n                case MessageID.IDS_FeatureQueryExpression:\n                case MessageID.IDS_FeatureExtensionMethod:\n                case MessageID.IDS_FeaturePartialMethod:\n                case MessageID.IDS_FeatureImplicitLocal: // Checked in the binder.\n                case MessageID.IDS_FeatureAutoImplementedProperties:\n                    return LanguageVersion.CSharp3;\n\n                // C# 2 features.\n                case MessageID.IDS_FeatureGenerics: // Also affects crefs.\n                case MessageID.IDS_FeatureAnonDelegates:\n                case MessageID.IDS_FeatureGlobalNamespace: // Also affects crefs.\n                case MessageID.IDS_FeatureFixedBuffer:\n                case MessageID.IDS_FeatureStaticClasses:\n                case MessageID.IDS_FeaturePartialTypes:\n                case MessageID.IDS_FeaturePropertyAccessorMods:\n                case MessageID.IDS_FeatureExternAlias:\n                case MessageID.IDS_FeatureIterators:\n                case MessageID.IDS_FeatureDefault:\n                case MessageID.IDS_FeatureNullable:\n                case MessageID.IDS_FeaturePragma: // Checked in the directive parser.\n                case MessageID.IDS_FeatureSwitchOnBool: // Checked in the binder.\n                    return LanguageVersion.CSharp2;\n\n                // Special C# 2 feature: only a warning in C# 1.\n                case MessageID.IDS_FeatureModuleAttrLoc:\n                    return LanguageVersion.CSharp1;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(feature);\n            } 6866"];
6866 [label="return LanguageVersion.CSharp2; 6867"];
6867 [label="switch (feature)\n            {\n                case MessageID.IDS_FeatureModuleAttrLoc:\n                    return availableVersion >= LanguageVersion.CSharp2\n                        ? node\n                        : this.AddError(node, ErrorCode.WRN_NonECMAFeature, feature.Localize());\n\n                case MessageID.IDS_FeatureAltInterpolatedVerbatimStrings:\n                    return availableVersion >= requiredVersion\n                        ? node\n                        : this.AddError(node, ErrorCode.ERR_AltInterpolatedVerbatimStringsNotAvailable,\n                            new CSharpRequiredLanguageVersion(requiredVersion));\n            } 6868"];
6868 [label="var info = feature.GetFeatureAvailabilityDiagnosticInfo(this.Options); 6869"];
6869 [label="this.Options 6870"];
6870 [label="get { return this.lexer.Options; } 6871"];
6871 [label="this.lexer.Options 6872"];
6872 [label="get { return _options; } 6873"];
6873 [label="return _options; 6874"];
6874 [label="return this.lexer.Options; 6875"];
6875 [label="var info = feature.GetFeatureAvailabilityDiagnosticInfo(this.Options); 6876"];
6876 [label="feature.GetFeatureAvailabilityDiagnosticInfo(this.Options) 6877"];
6877 [label="param GetFeatureAvailabilityDiagnosticInfo(this MessageID feature) 6878"];
6878 [label="param GetFeatureAvailabilityDiagnosticInfo(CSharpParseOptions options) 6879"];
6879 [label="feature 6880"];
6880 [label="options.IsFeatureEnabled(feature) 6881"];
6881 [label="param IsFeatureEnabled(MessageID feature) 6882"];
6882 [label="param IsFeatureEnabled(this) 6883"];
6883 [label="string? featureFlag = feature.RequiredFeature(); 6884"];
6884 [label="feature.RequiredFeature() 6885"];
6885 [label="param RequiredFeature(this MessageID feature) 6886"];
6886 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 6887"];
6887 [label="return null; 6888"];
6888 [label="if (featureFlag != null)\n            {\n                return Features.ContainsKey(featureFlag);\n            } 6889"];
6889 [label="if (featureFlag != null)\n            {\n                return Features.ContainsKey(featureFlag);\n            } 6890"];
6890 [label="LanguageVersion availableVersion = LanguageVersion; 6891"];
6891 [label="LanguageVersion requiredVersion = feature.RequiredVersion(); 6892"];
6892 [label="feature.RequiredVersion() 6893"];
6893 [label="param RequiredVersion(this MessageID feature) 6894"];
6894 [label="Debug.Assert(RequiredFeature(feature) == null); 6895"];
6895 [label="RequiredFeature(feature) 6896"];
6896 [label="param RequiredFeature(this MessageID feature) 6897"];
6897 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 6898"];
6898 [label="return null; 6899"];
6899 [label="Debug.Assert(RequiredFeature(feature) == null); 6900"];
6900 [label="switch (feature)\n            {\n                // C# preview features.\n                case MessageID.IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction:\n                    return LanguageVersion.Preview;\n                // C# 9.0 features.\n                case MessageID.IDS_FeatureLambdaDiscardParameters: // semantic check\n                case MessageID.IDS_FeatureFunctionPointers:\n                case MessageID.IDS_FeatureLocalFunctionAttributes: // syntax check\n                case MessageID.IDS_FeatureExternLocalFunctions: // syntax check\n                case MessageID.IDS_FeatureImplicitObjectCreation: // syntax check\n                case MessageID.IDS_FeatureMemberNotNull:\n                case MessageID.IDS_FeatureAndPattern:\n                case MessageID.IDS_FeatureNotPattern:\n                case MessageID.IDS_FeatureOrPattern:\n                case MessageID.IDS_FeatureParenthesizedPattern:\n                case MessageID.IDS_FeatureTypePattern:\n                case MessageID.IDS_FeatureRelationalPattern:\n                case MessageID.IDS_FeatureExtensionGetEnumerator: // semantic check\n                case MessageID.IDS_FeatureExtensionGetAsyncEnumerator: // semantic check\n                case MessageID.IDS_FeatureNativeInt:\n                case MessageID.IDS_FeatureExtendedPartialMethods: // semantic check\n                case MessageID.IDS_TopLevelStatements:\n                case MessageID.IDS_FeatureInitOnlySetters: // semantic check\n                case MessageID.IDS_FeatureRecords:\n                case MessageID.IDS_FeatureTargetTypedConditional:  // semantic check\n                case MessageID.IDS_FeatureCovariantReturnsForOverrides: // semantic check\n                case MessageID.IDS_FeatureStaticAnonymousFunction: // syntax check\n                case MessageID.IDS_FeatureModuleInitializers: // semantic check on method attribute\n                case MessageID.IDS_FeatureDefaultTypeParameterConstraint:\n                    return LanguageVersion.CSharp9;\n\n                case MessageID.IDS_FeatureVarianceSafetyForStaticInterfaceMembers: //semantic check\n                case MessageID.IDS_FeatureConstantInterpolatedStrings: //semantic check\n                    return LanguageVersion.Preview;\n\n                // C# 8.0 features.\n                case MessageID.IDS_FeatureAltInterpolatedVerbatimStrings:\n                case MessageID.IDS_FeatureCoalesceAssignmentExpression:\n                case MessageID.IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator:\n                case MessageID.IDS_FeatureNullableReferenceTypes: // syntax and semantic check\n                case MessageID.IDS_FeatureIndexOperator: // semantic check\n                case MessageID.IDS_FeatureRangeOperator: // semantic check\n                case MessageID.IDS_FeatureAsyncStreams:\n                case MessageID.IDS_FeatureRecursivePatterns:\n                case MessageID.IDS_FeatureUsingDeclarations:\n                case MessageID.IDS_FeatureStaticLocalFunctions:\n                case MessageID.IDS_FeatureNameShadowingInNestedFunctions:\n                case MessageID.IDS_FeatureUnmanagedConstructedTypes: // semantic check\n                case MessageID.IDS_FeatureObsoleteOnPropertyAccessor:\n                case MessageID.IDS_FeatureReadOnlyMembers:\n                case MessageID.IDS_DefaultInterfaceImplementation: // semantic check\n                case MessageID.IDS_OverrideWithConstraints: // semantic check\n                case MessageID.IDS_FeatureNestedStackalloc: // semantic check\n                case MessageID.IDS_FeatureNotNullGenericTypeConstraint:// semantic check\n                case MessageID.IDS_FeatureSwitchExpression:\n                case MessageID.IDS_FeatureAsyncUsing:\n                case MessageID.IDS_FeatureNullPointerConstantPattern: //semantic check\n                    return LanguageVersion.CSharp8;\n\n                // C# 7.3 features.\n                case MessageID.IDS_FeatureAttributesOnBackingFields: // semantic check\n                case MessageID.IDS_FeatureImprovedOverloadCandidates: // semantic check\n                case MessageID.IDS_FeatureTupleEquality: // semantic check\n                case MessageID.IDS_FeatureRefReassignment:\n                case MessageID.IDS_FeatureRefFor:\n                case MessageID.IDS_FeatureRefForEach:\n                case MessageID.IDS_FeatureEnumGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureDelegateGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureUnmanagedGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureStackAllocInitializer:\n                case MessageID.IDS_FeatureExpressionVariablesInQueriesAndInitializers: // semantic check\n                case MessageID.IDS_FeatureExtensibleFixedStatement:  // semantic check\n                case MessageID.IDS_FeatureIndexingMovableFixedBuffers: //semantic check\n                    return LanguageVersion.CSharp7_3;\n\n                // C# 7.2 features.\n                case MessageID.IDS_FeatureNonTrailingNamedArguments: // semantic check\n                case MessageID.IDS_FeatureLeadingDigitSeparator:\n                case MessageID.IDS_FeaturePrivateProtected:\n                case MessageID.IDS_FeatureReadOnlyReferences:\n                case MessageID.IDS_FeatureRefStructs:\n                case MessageID.IDS_FeatureReadOnlyStructs:\n                case MessageID.IDS_FeatureRefExtensionMethods:\n                case MessageID.IDS_FeatureRefConditional:\n                    return LanguageVersion.CSharp7_2;\n\n                // C# 7.1 features.\n                case MessageID.IDS_FeatureAsyncMain:\n                case MessageID.IDS_FeatureDefaultLiteral:\n                case MessageID.IDS_FeatureInferredTupleNames:\n                case MessageID.IDS_FeatureGenericPatternMatching:\n                    return LanguageVersion.CSharp7_1;\n\n                // C# 7 features.\n                case MessageID.IDS_FeatureBinaryLiteral:\n                case MessageID.IDS_FeatureDigitSeparator:\n                case MessageID.IDS_FeatureLocalFunctions:\n                case MessageID.IDS_FeatureRefLocalsReturns:\n                case MessageID.IDS_FeaturePatternMatching:\n                case MessageID.IDS_FeatureThrowExpression:\n                case MessageID.IDS_FeatureTuples:\n                case MessageID.IDS_FeatureOutVar:\n                case MessageID.IDS_FeatureExpressionBodiedAccessor:\n                case MessageID.IDS_FeatureExpressionBodiedDeOrConstructor:\n                case MessageID.IDS_FeatureDiscards:\n                    return LanguageVersion.CSharp7;\n\n                // C# 6 features.\n                case MessageID.IDS_FeatureExceptionFilter:\n                case MessageID.IDS_FeatureAutoPropertyInitializer:\n                case MessageID.IDS_FeatureNullPropagatingOperator:\n                case MessageID.IDS_FeatureExpressionBodiedMethod:\n                case MessageID.IDS_FeatureExpressionBodiedProperty:\n                case MessageID.IDS_FeatureExpressionBodiedIndexer:\n                case MessageID.IDS_FeatureNameof:\n                case MessageID.IDS_FeatureDictionaryInitializer:\n                case MessageID.IDS_FeatureUsingStatic:\n                case MessageID.IDS_FeatureInterpolatedStrings:\n                case MessageID.IDS_AwaitInCatchAndFinally:\n                case MessageID.IDS_FeatureReadonlyAutoImplementedProperties:\n                    return LanguageVersion.CSharp6;\n\n                // C# 5 features.\n                case MessageID.IDS_FeatureAsync:\n                    return LanguageVersion.CSharp5;\n\n                // C# 4 features.\n                case MessageID.IDS_FeatureDynamic: // Checked in the binder.\n                case MessageID.IDS_FeatureTypeVariance:\n                case MessageID.IDS_FeatureNamedArgument:\n                case MessageID.IDS_FeatureOptionalParameter:\n                    return LanguageVersion.CSharp4;\n\n                // C# 3 features.\n                case MessageID.IDS_FeatureImplicitArray:\n                case MessageID.IDS_FeatureAnonymousTypes:\n                case MessageID.IDS_FeatureObjectInitializer:\n                case MessageID.IDS_FeatureCollectionInitializer:\n                case MessageID.IDS_FeatureLambda:\n                case MessageID.IDS_FeatureQueryExpression:\n                case MessageID.IDS_FeatureExtensionMethod:\n                case MessageID.IDS_FeaturePartialMethod:\n                case MessageID.IDS_FeatureImplicitLocal: // Checked in the binder.\n                case MessageID.IDS_FeatureAutoImplementedProperties:\n                    return LanguageVersion.CSharp3;\n\n                // C# 2 features.\n                case MessageID.IDS_FeatureGenerics: // Also affects crefs.\n                case MessageID.IDS_FeatureAnonDelegates:\n                case MessageID.IDS_FeatureGlobalNamespace: // Also affects crefs.\n                case MessageID.IDS_FeatureFixedBuffer:\n                case MessageID.IDS_FeatureStaticClasses:\n                case MessageID.IDS_FeaturePartialTypes:\n                case MessageID.IDS_FeaturePropertyAccessorMods:\n                case MessageID.IDS_FeatureExternAlias:\n                case MessageID.IDS_FeatureIterators:\n                case MessageID.IDS_FeatureDefault:\n                case MessageID.IDS_FeatureNullable:\n                case MessageID.IDS_FeaturePragma: // Checked in the directive parser.\n                case MessageID.IDS_FeatureSwitchOnBool: // Checked in the binder.\n                    return LanguageVersion.CSharp2;\n\n                // Special C# 2 feature: only a warning in C# 1.\n                case MessageID.IDS_FeatureModuleAttrLoc:\n                    return LanguageVersion.CSharp1;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(feature);\n            } 6901"];
6901 [label="return LanguageVersion.CSharp2; 6902"];
6902 [label="return availableVersion >= requiredVersion; 6903"];
6903 [label="null 6904"];
6904 [label="options.IsFeatureEnabled(feature) ? null : GetDisabledFeatureDiagnosticInfo(feature, options.LanguageVersion) 6905"];
6905 [label="if (info != null)\n            {\n                if (forceWarning)\n                {\n                    return AddError(node, ErrorCode.WRN_ErrorOverride, info, (int)info.Code);\n                }\n\n                return AddError(node, info.Code, info.Arguments);\n            } 6906"];
6906 [label="if (info != null)\n            {\n                if (forceWarning)\n                {\n                    return AddError(node, ErrorCode.WRN_ErrorOverride, info, (int)info.Code);\n                }\n\n                return AddError(node, info.Code, info.Arguments);\n            } 6907"];
6907 [label="this.Release(ref resetPoint); 6908"];
6908 [label="this.Release(ref resetPoint) 6909"];
6909 [label="param Release(ref ResetPoint state) 6910"];
6910 [label="param Release(this) 6911"];
6911 [label="base.Release(ref state.BaseResetPoint); 6912"];
6912 [label="base.Release(ref state.BaseResetPoint) 6913"];
6913 [label="param Release(ref ResetPoint point) 6914"];
6914 [label="Debug.Assert(_resetCount == point.ResetCount); 6915"];
6915 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 6916"];
6916 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 6917"];
6917 [label="base.Release(ref state.BaseResetPoint); 6918"];
6918 [label="this.Release(ref resetPoint); 6919"];
6919 [label="GetNodeFlags(context) 6920"];
6920 [label="param GetNodeFlags(SyntaxFactoryContext context) 6921"];
6921 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 6922"];
6922 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 6923"];
6923 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 6924"];
6924 [label="return flags; 6925"];
6925 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 6926"];
6926 [label="param SetFactoryContext(SyntaxFactoryContext context) 6927"];
6927 [label="param SetFactoryContext(this) 6928"];
6928 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 6929"];
6929 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 6930"];
6930 [label="param IsMakingProgress(bool assertIfFalse = true) 6931"];
6931 [label="type.Kind 6932"];
6932 [label="get { return (SyntaxKind)this.RawKind; } 6933"];
6933 [label="if (type.Kind == SyntaxKind.ArrayType)\n                {\n                    // Check for an initializer.\n                    if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                    {\n                        initializer = this.ParseArrayInitializer();\n                    }\n\n                    return _syntaxFactory.ArrayCreationExpression(@new, (ArrayTypeSyntax)type, initializer);\n                } 6934"];
6934 [label="ArgumentListSyntax argumentList = null; 6935"];
6935 [label="this.CurrentToken 6936"];
6936 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6937"];
6937 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6938"];
6938 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n            {\n                argumentList = this.ParseParenthesizedArgumentList();\n            } 6939"];
6939 [label="this.CurrentToken.Kind 6940"];
6940 [label="get { return (SyntaxKind)this.RawKind; } 6941"];
6941 [label="this.CurrentToken 6942"];
6942 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 6943"];
6943 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 6944"];
6944 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n            {\n                initializer = this.ParseObjectOrCollectionInitializer();\n            } 6945"];
6945 [label="this.CurrentToken.Kind 6946"];
6946 [label="get { return (SyntaxKind)this.RawKind; } 6947"];
6947 [label="this.ParseObjectOrCollectionInitializer() 6948"];
6948 [label="param ParseObjectOrCollectionInitializer(this) 6949"];
6949 [label="var openBrace = this.EatToken(SyntaxKind.OpenBraceToken); 6950"];
6950 [label="this.EatToken(SyntaxKind.OpenBraceToken) 6951"];
6951 [label="param EatToken(SyntaxKind kind) 6952"];
6952 [label="param EatToken(this) 6953"];
6953 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 6954"];
6954 [label="SyntaxFacts.IsAnyToken(kind) 6955"];
6955 [label="param IsAnyToken(SyntaxKind kind) 6956"];
6956 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 6957"];
6957 [label="return true; 6958"];
6958 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 6959"];
6959 [label="param GetTrailingTrivia(this) 6960"];
6960 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 6961"];
6961 [label="MoveToNextToken(); 6962"];
6962 [label="var initializers = _pool.AllocateSeparated<ExpressionSyntax>(); 6963"];
6963 [label="bool isObjectInitializer; 6964"];
6964 [label="this.ParseObjectOrCollectionInitializerMembers(ref openBrace, initializers, out isObjectInitializer); 6965"];
6965 [label="this.ParseObjectOrCollectionInitializerMembers(ref openBrace, initializers, out isObjectInitializer); 6966"];
6966 [label="this.ParseObjectOrCollectionInitializerMembers(ref openBrace, initializers, out isObjectInitializer); 6967"];
6967 [label="this.ParseObjectOrCollectionInitializerMembers(ref openBrace, initializers, out isObjectInitializer); 6968"];
6968 [label="this.ParseObjectOrCollectionInitializerMembers(ref openBrace, initializers, out isObjectInitializer); 6969"];
6969 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 6970"];
6970 [label="Debug.Assert(initializers.Count > 0 || isObjectInitializer); 6971"];
6971 [label="Debug.Assert(initializers.Count > 0 || isObjectInitializer); 6972"];
6972 [label="Debug.Assert(initializers.Count > 0 || isObjectInitializer); 6973"];
6973 [label="openBrace = CheckFeatureAvailability(openBrace, isObjectInitializer ? MessageID.IDS_FeatureObjectInitializer : MessageID.IDS_FeatureCollectionInitializer); 6974"];
6974 [label="isObjectInitializer 6975"];
6975 [label="openBrace = CheckFeatureAvailability(openBrace, isObjectInitializer ? MessageID.IDS_FeatureObjectInitializer : MessageID.IDS_FeatureCollectionInitializer); 6976"];
6976 [label="openBrace = CheckFeatureAvailability(openBrace, isObjectInitializer ? MessageID.IDS_FeatureObjectInitializer : MessageID.IDS_FeatureCollectionInitializer); 6977"];
6977 [label="CheckFeatureAvailability(openBrace, isObjectInitializer ? MessageID.IDS_FeatureObjectInitializer : MessageID.IDS_FeatureCollectionInitializer) 6978"];
6978 [label="param CheckFeatureAvailability(TNode node) 6979"];
6979 [label="param CheckFeatureAvailability(MessageID feature) 6980"];
6980 [label="param CheckFeatureAvailability(bool forceWarning = false) 6981"];
6981 [label="param CheckFeatureAvailability(this) 6982"];
6982 [label="this.Options 6983"];
6983 [label="get { return this.lexer.Options; } 6984"];
6984 [label="this.lexer.Options 6985"];
6985 [label="get { return _options; } 6986"];
6986 [label="return _options; 6987"];
6987 [label="return this.lexer.Options; 6988"];
6988 [label="LanguageVersion availableVersion = this.Options.LanguageVersion; 6989"];
6989 [label="LanguageVersion requiredVersion = feature.RequiredVersion(); 6990"];
6990 [label="feature.RequiredVersion() 6991"];
6991 [label="param RequiredVersion(this MessageID feature) 6992"];
6992 [label="Debug.Assert(RequiredFeature(feature) == null); 6993"];
6993 [label="RequiredFeature(feature) 6994"];
6994 [label="param RequiredFeature(this MessageID feature) 6995"];
6995 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 6996"];
6996 [label="return null; 6997"];
6997 [label="Debug.Assert(RequiredFeature(feature) == null); 6998"];
6998 [label="switch (feature)\n            {\n                // C# preview features.\n                case MessageID.IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction:\n                    return LanguageVersion.Preview;\n                // C# 9.0 features.\n                case MessageID.IDS_FeatureLambdaDiscardParameters: // semantic check\n                case MessageID.IDS_FeatureFunctionPointers:\n                case MessageID.IDS_FeatureLocalFunctionAttributes: // syntax check\n                case MessageID.IDS_FeatureExternLocalFunctions: // syntax check\n                case MessageID.IDS_FeatureImplicitObjectCreation: // syntax check\n                case MessageID.IDS_FeatureMemberNotNull:\n                case MessageID.IDS_FeatureAndPattern:\n                case MessageID.IDS_FeatureNotPattern:\n                case MessageID.IDS_FeatureOrPattern:\n                case MessageID.IDS_FeatureParenthesizedPattern:\n                case MessageID.IDS_FeatureTypePattern:\n                case MessageID.IDS_FeatureRelationalPattern:\n                case MessageID.IDS_FeatureExtensionGetEnumerator: // semantic check\n                case MessageID.IDS_FeatureExtensionGetAsyncEnumerator: // semantic check\n                case MessageID.IDS_FeatureNativeInt:\n                case MessageID.IDS_FeatureExtendedPartialMethods: // semantic check\n                case MessageID.IDS_TopLevelStatements:\n                case MessageID.IDS_FeatureInitOnlySetters: // semantic check\n                case MessageID.IDS_FeatureRecords:\n                case MessageID.IDS_FeatureTargetTypedConditional:  // semantic check\n                case MessageID.IDS_FeatureCovariantReturnsForOverrides: // semantic check\n                case MessageID.IDS_FeatureStaticAnonymousFunction: // syntax check\n                case MessageID.IDS_FeatureModuleInitializers: // semantic check on method attribute\n                case MessageID.IDS_FeatureDefaultTypeParameterConstraint:\n                    return LanguageVersion.CSharp9;\n\n                case MessageID.IDS_FeatureVarianceSafetyForStaticInterfaceMembers: //semantic check\n                case MessageID.IDS_FeatureConstantInterpolatedStrings: //semantic check\n                    return LanguageVersion.Preview;\n\n                // C# 8.0 features.\n                case MessageID.IDS_FeatureAltInterpolatedVerbatimStrings:\n                case MessageID.IDS_FeatureCoalesceAssignmentExpression:\n                case MessageID.IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator:\n                case MessageID.IDS_FeatureNullableReferenceTypes: // syntax and semantic check\n                case MessageID.IDS_FeatureIndexOperator: // semantic check\n                case MessageID.IDS_FeatureRangeOperator: // semantic check\n                case MessageID.IDS_FeatureAsyncStreams:\n                case MessageID.IDS_FeatureRecursivePatterns:\n                case MessageID.IDS_FeatureUsingDeclarations:\n                case MessageID.IDS_FeatureStaticLocalFunctions:\n                case MessageID.IDS_FeatureNameShadowingInNestedFunctions:\n                case MessageID.IDS_FeatureUnmanagedConstructedTypes: // semantic check\n                case MessageID.IDS_FeatureObsoleteOnPropertyAccessor:\n                case MessageID.IDS_FeatureReadOnlyMembers:\n                case MessageID.IDS_DefaultInterfaceImplementation: // semantic check\n                case MessageID.IDS_OverrideWithConstraints: // semantic check\n                case MessageID.IDS_FeatureNestedStackalloc: // semantic check\n                case MessageID.IDS_FeatureNotNullGenericTypeConstraint:// semantic check\n                case MessageID.IDS_FeatureSwitchExpression:\n                case MessageID.IDS_FeatureAsyncUsing:\n                case MessageID.IDS_FeatureNullPointerConstantPattern: //semantic check\n                    return LanguageVersion.CSharp8;\n\n                // C# 7.3 features.\n                case MessageID.IDS_FeatureAttributesOnBackingFields: // semantic check\n                case MessageID.IDS_FeatureImprovedOverloadCandidates: // semantic check\n                case MessageID.IDS_FeatureTupleEquality: // semantic check\n                case MessageID.IDS_FeatureRefReassignment:\n                case MessageID.IDS_FeatureRefFor:\n                case MessageID.IDS_FeatureRefForEach:\n                case MessageID.IDS_FeatureEnumGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureDelegateGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureUnmanagedGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureStackAllocInitializer:\n                case MessageID.IDS_FeatureExpressionVariablesInQueriesAndInitializers: // semantic check\n                case MessageID.IDS_FeatureExtensibleFixedStatement:  // semantic check\n                case MessageID.IDS_FeatureIndexingMovableFixedBuffers: //semantic check\n                    return LanguageVersion.CSharp7_3;\n\n                // C# 7.2 features.\n                case MessageID.IDS_FeatureNonTrailingNamedArguments: // semantic check\n                case MessageID.IDS_FeatureLeadingDigitSeparator:\n                case MessageID.IDS_FeaturePrivateProtected:\n                case MessageID.IDS_FeatureReadOnlyReferences:\n                case MessageID.IDS_FeatureRefStructs:\n                case MessageID.IDS_FeatureReadOnlyStructs:\n                case MessageID.IDS_FeatureRefExtensionMethods:\n                case MessageID.IDS_FeatureRefConditional:\n                    return LanguageVersion.CSharp7_2;\n\n                // C# 7.1 features.\n                case MessageID.IDS_FeatureAsyncMain:\n                case MessageID.IDS_FeatureDefaultLiteral:\n                case MessageID.IDS_FeatureInferredTupleNames:\n                case MessageID.IDS_FeatureGenericPatternMatching:\n                    return LanguageVersion.CSharp7_1;\n\n                // C# 7 features.\n                case MessageID.IDS_FeatureBinaryLiteral:\n                case MessageID.IDS_FeatureDigitSeparator:\n                case MessageID.IDS_FeatureLocalFunctions:\n                case MessageID.IDS_FeatureRefLocalsReturns:\n                case MessageID.IDS_FeaturePatternMatching:\n                case MessageID.IDS_FeatureThrowExpression:\n                case MessageID.IDS_FeatureTuples:\n                case MessageID.IDS_FeatureOutVar:\n                case MessageID.IDS_FeatureExpressionBodiedAccessor:\n                case MessageID.IDS_FeatureExpressionBodiedDeOrConstructor:\n                case MessageID.IDS_FeatureDiscards:\n                    return LanguageVersion.CSharp7;\n\n                // C# 6 features.\n                case MessageID.IDS_FeatureExceptionFilter:\n                case MessageID.IDS_FeatureAutoPropertyInitializer:\n                case MessageID.IDS_FeatureNullPropagatingOperator:\n                case MessageID.IDS_FeatureExpressionBodiedMethod:\n                case MessageID.IDS_FeatureExpressionBodiedProperty:\n                case MessageID.IDS_FeatureExpressionBodiedIndexer:\n                case MessageID.IDS_FeatureNameof:\n                case MessageID.IDS_FeatureDictionaryInitializer:\n                case MessageID.IDS_FeatureUsingStatic:\n                case MessageID.IDS_FeatureInterpolatedStrings:\n                case MessageID.IDS_AwaitInCatchAndFinally:\n                case MessageID.IDS_FeatureReadonlyAutoImplementedProperties:\n                    return LanguageVersion.CSharp6;\n\n                // C# 5 features.\n                case MessageID.IDS_FeatureAsync:\n                    return LanguageVersion.CSharp5;\n\n                // C# 4 features.\n                case MessageID.IDS_FeatureDynamic: // Checked in the binder.\n                case MessageID.IDS_FeatureTypeVariance:\n                case MessageID.IDS_FeatureNamedArgument:\n                case MessageID.IDS_FeatureOptionalParameter:\n                    return LanguageVersion.CSharp4;\n\n                // C# 3 features.\n                case MessageID.IDS_FeatureImplicitArray:\n                case MessageID.IDS_FeatureAnonymousTypes:\n                case MessageID.IDS_FeatureObjectInitializer:\n                case MessageID.IDS_FeatureCollectionInitializer:\n                case MessageID.IDS_FeatureLambda:\n                case MessageID.IDS_FeatureQueryExpression:\n                case MessageID.IDS_FeatureExtensionMethod:\n                case MessageID.IDS_FeaturePartialMethod:\n                case MessageID.IDS_FeatureImplicitLocal: // Checked in the binder.\n                case MessageID.IDS_FeatureAutoImplementedProperties:\n                    return LanguageVersion.CSharp3;\n\n                // C# 2 features.\n                case MessageID.IDS_FeatureGenerics: // Also affects crefs.\n                case MessageID.IDS_FeatureAnonDelegates:\n                case MessageID.IDS_FeatureGlobalNamespace: // Also affects crefs.\n                case MessageID.IDS_FeatureFixedBuffer:\n                case MessageID.IDS_FeatureStaticClasses:\n                case MessageID.IDS_FeaturePartialTypes:\n                case MessageID.IDS_FeaturePropertyAccessorMods:\n                case MessageID.IDS_FeatureExternAlias:\n                case MessageID.IDS_FeatureIterators:\n                case MessageID.IDS_FeatureDefault:\n                case MessageID.IDS_FeatureNullable:\n                case MessageID.IDS_FeaturePragma: // Checked in the directive parser.\n                case MessageID.IDS_FeatureSwitchOnBool: // Checked in the binder.\n                    return LanguageVersion.CSharp2;\n\n                // Special C# 2 feature: only a warning in C# 1.\n                case MessageID.IDS_FeatureModuleAttrLoc:\n                    return LanguageVersion.CSharp1;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(feature);\n            } 6999"];
6999 [label="return LanguageVersion.CSharp3; 7000"];
7000 [label="switch (feature)\n            {\n                case MessageID.IDS_FeatureModuleAttrLoc:\n                    return availableVersion >= LanguageVersion.CSharp2\n                        ? node\n                        : this.AddError(node, ErrorCode.WRN_NonECMAFeature, feature.Localize());\n\n                case MessageID.IDS_FeatureAltInterpolatedVerbatimStrings:\n                    return availableVersion >= requiredVersion\n                        ? node\n                        : this.AddError(node, ErrorCode.ERR_AltInterpolatedVerbatimStringsNotAvailable,\n                            new CSharpRequiredLanguageVersion(requiredVersion));\n            } 7001"];
7001 [label="var info = feature.GetFeatureAvailabilityDiagnosticInfo(this.Options); 7002"];
7002 [label="this.Options 7003"];
7003 [label="get { return this.lexer.Options; } 7004"];
7004 [label="this.lexer.Options 7005"];
7005 [label="get { return _options; } 7006"];
7006 [label="return _options; 7007"];
7007 [label="return this.lexer.Options; 7008"];
7008 [label="var info = feature.GetFeatureAvailabilityDiagnosticInfo(this.Options); 7009"];
7009 [label="feature.GetFeatureAvailabilityDiagnosticInfo(this.Options) 7010"];
7010 [label="param GetFeatureAvailabilityDiagnosticInfo(this MessageID feature) 7011"];
7011 [label="param GetFeatureAvailabilityDiagnosticInfo(CSharpParseOptions options) 7012"];
7012 [label="feature 7013"];
7013 [label="options.IsFeatureEnabled(feature) 7014"];
7014 [label="param IsFeatureEnabled(MessageID feature) 7015"];
7015 [label="param IsFeatureEnabled(this) 7016"];
7016 [label="string? featureFlag = feature.RequiredFeature(); 7017"];
7017 [label="feature.RequiredFeature() 7018"];
7018 [label="param RequiredFeature(this MessageID feature) 7019"];
7019 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 7020"];
7020 [label="return null; 7021"];
7021 [label="if (featureFlag != null)\n            {\n                return Features.ContainsKey(featureFlag);\n            } 7022"];
7022 [label="if (featureFlag != null)\n            {\n                return Features.ContainsKey(featureFlag);\n            } 7023"];
7023 [label="LanguageVersion availableVersion = LanguageVersion; 7024"];
7024 [label="LanguageVersion requiredVersion = feature.RequiredVersion(); 7025"];
7025 [label="feature.RequiredVersion() 7026"];
7026 [label="param RequiredVersion(this MessageID feature) 7027"];
7027 [label="Debug.Assert(RequiredFeature(feature) == null); 7028"];
7028 [label="RequiredFeature(feature) 7029"];
7029 [label="param RequiredFeature(this MessageID feature) 7030"];
7030 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 7031"];
7031 [label="return null; 7032"];
7032 [label="Debug.Assert(RequiredFeature(feature) == null); 7033"];
7033 [label="switch (feature)\n            {\n                // C# preview features.\n                case MessageID.IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction:\n                    return LanguageVersion.Preview;\n                // C# 9.0 features.\n                case MessageID.IDS_FeatureLambdaDiscardParameters: // semantic check\n                case MessageID.IDS_FeatureFunctionPointers:\n                case MessageID.IDS_FeatureLocalFunctionAttributes: // syntax check\n                case MessageID.IDS_FeatureExternLocalFunctions: // syntax check\n                case MessageID.IDS_FeatureImplicitObjectCreation: // syntax check\n                case MessageID.IDS_FeatureMemberNotNull:\n                case MessageID.IDS_FeatureAndPattern:\n                case MessageID.IDS_FeatureNotPattern:\n                case MessageID.IDS_FeatureOrPattern:\n                case MessageID.IDS_FeatureParenthesizedPattern:\n                case MessageID.IDS_FeatureTypePattern:\n                case MessageID.IDS_FeatureRelationalPattern:\n                case MessageID.IDS_FeatureExtensionGetEnumerator: // semantic check\n                case MessageID.IDS_FeatureExtensionGetAsyncEnumerator: // semantic check\n                case MessageID.IDS_FeatureNativeInt:\n                case MessageID.IDS_FeatureExtendedPartialMethods: // semantic check\n                case MessageID.IDS_TopLevelStatements:\n                case MessageID.IDS_FeatureInitOnlySetters: // semantic check\n                case MessageID.IDS_FeatureRecords:\n                case MessageID.IDS_FeatureTargetTypedConditional:  // semantic check\n                case MessageID.IDS_FeatureCovariantReturnsForOverrides: // semantic check\n                case MessageID.IDS_FeatureStaticAnonymousFunction: // syntax check\n                case MessageID.IDS_FeatureModuleInitializers: // semantic check on method attribute\n                case MessageID.IDS_FeatureDefaultTypeParameterConstraint:\n                    return LanguageVersion.CSharp9;\n\n                case MessageID.IDS_FeatureVarianceSafetyForStaticInterfaceMembers: //semantic check\n                case MessageID.IDS_FeatureConstantInterpolatedStrings: //semantic check\n                    return LanguageVersion.Preview;\n\n                // C# 8.0 features.\n                case MessageID.IDS_FeatureAltInterpolatedVerbatimStrings:\n                case MessageID.IDS_FeatureCoalesceAssignmentExpression:\n                case MessageID.IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator:\n                case MessageID.IDS_FeatureNullableReferenceTypes: // syntax and semantic check\n                case MessageID.IDS_FeatureIndexOperator: // semantic check\n                case MessageID.IDS_FeatureRangeOperator: // semantic check\n                case MessageID.IDS_FeatureAsyncStreams:\n                case MessageID.IDS_FeatureRecursivePatterns:\n                case MessageID.IDS_FeatureUsingDeclarations:\n                case MessageID.IDS_FeatureStaticLocalFunctions:\n                case MessageID.IDS_FeatureNameShadowingInNestedFunctions:\n                case MessageID.IDS_FeatureUnmanagedConstructedTypes: // semantic check\n                case MessageID.IDS_FeatureObsoleteOnPropertyAccessor:\n                case MessageID.IDS_FeatureReadOnlyMembers:\n                case MessageID.IDS_DefaultInterfaceImplementation: // semantic check\n                case MessageID.IDS_OverrideWithConstraints: // semantic check\n                case MessageID.IDS_FeatureNestedStackalloc: // semantic check\n                case MessageID.IDS_FeatureNotNullGenericTypeConstraint:// semantic check\n                case MessageID.IDS_FeatureSwitchExpression:\n                case MessageID.IDS_FeatureAsyncUsing:\n                case MessageID.IDS_FeatureNullPointerConstantPattern: //semantic check\n                    return LanguageVersion.CSharp8;\n\n                // C# 7.3 features.\n                case MessageID.IDS_FeatureAttributesOnBackingFields: // semantic check\n                case MessageID.IDS_FeatureImprovedOverloadCandidates: // semantic check\n                case MessageID.IDS_FeatureTupleEquality: // semantic check\n                case MessageID.IDS_FeatureRefReassignment:\n                case MessageID.IDS_FeatureRefFor:\n                case MessageID.IDS_FeatureRefForEach:\n                case MessageID.IDS_FeatureEnumGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureDelegateGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureUnmanagedGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureStackAllocInitializer:\n                case MessageID.IDS_FeatureExpressionVariablesInQueriesAndInitializers: // semantic check\n                case MessageID.IDS_FeatureExtensibleFixedStatement:  // semantic check\n                case MessageID.IDS_FeatureIndexingMovableFixedBuffers: //semantic check\n                    return LanguageVersion.CSharp7_3;\n\n                // C# 7.2 features.\n                case MessageID.IDS_FeatureNonTrailingNamedArguments: // semantic check\n                case MessageID.IDS_FeatureLeadingDigitSeparator:\n                case MessageID.IDS_FeaturePrivateProtected:\n                case MessageID.IDS_FeatureReadOnlyReferences:\n                case MessageID.IDS_FeatureRefStructs:\n                case MessageID.IDS_FeatureReadOnlyStructs:\n                case MessageID.IDS_FeatureRefExtensionMethods:\n                case MessageID.IDS_FeatureRefConditional:\n                    return LanguageVersion.CSharp7_2;\n\n                // C# 7.1 features.\n                case MessageID.IDS_FeatureAsyncMain:\n                case MessageID.IDS_FeatureDefaultLiteral:\n                case MessageID.IDS_FeatureInferredTupleNames:\n                case MessageID.IDS_FeatureGenericPatternMatching:\n                    return LanguageVersion.CSharp7_1;\n\n                // C# 7 features.\n                case MessageID.IDS_FeatureBinaryLiteral:\n                case MessageID.IDS_FeatureDigitSeparator:\n                case MessageID.IDS_FeatureLocalFunctions:\n                case MessageID.IDS_FeatureRefLocalsReturns:\n                case MessageID.IDS_FeaturePatternMatching:\n                case MessageID.IDS_FeatureThrowExpression:\n                case MessageID.IDS_FeatureTuples:\n                case MessageID.IDS_FeatureOutVar:\n                case MessageID.IDS_FeatureExpressionBodiedAccessor:\n                case MessageID.IDS_FeatureExpressionBodiedDeOrConstructor:\n                case MessageID.IDS_FeatureDiscards:\n                    return LanguageVersion.CSharp7;\n\n                // C# 6 features.\n                case MessageID.IDS_FeatureExceptionFilter:\n                case MessageID.IDS_FeatureAutoPropertyInitializer:\n                case MessageID.IDS_FeatureNullPropagatingOperator:\n                case MessageID.IDS_FeatureExpressionBodiedMethod:\n                case MessageID.IDS_FeatureExpressionBodiedProperty:\n                case MessageID.IDS_FeatureExpressionBodiedIndexer:\n                case MessageID.IDS_FeatureNameof:\n                case MessageID.IDS_FeatureDictionaryInitializer:\n                case MessageID.IDS_FeatureUsingStatic:\n                case MessageID.IDS_FeatureInterpolatedStrings:\n                case MessageID.IDS_AwaitInCatchAndFinally:\n                case MessageID.IDS_FeatureReadonlyAutoImplementedProperties:\n                    return LanguageVersion.CSharp6;\n\n                // C# 5 features.\n                case MessageID.IDS_FeatureAsync:\n                    return LanguageVersion.CSharp5;\n\n                // C# 4 features.\n                case MessageID.IDS_FeatureDynamic: // Checked in the binder.\n                case MessageID.IDS_FeatureTypeVariance:\n                case MessageID.IDS_FeatureNamedArgument:\n                case MessageID.IDS_FeatureOptionalParameter:\n                    return LanguageVersion.CSharp4;\n\n                // C# 3 features.\n                case MessageID.IDS_FeatureImplicitArray:\n                case MessageID.IDS_FeatureAnonymousTypes:\n                case MessageID.IDS_FeatureObjectInitializer:\n                case MessageID.IDS_FeatureCollectionInitializer:\n                case MessageID.IDS_FeatureLambda:\n                case MessageID.IDS_FeatureQueryExpression:\n                case MessageID.IDS_FeatureExtensionMethod:\n                case MessageID.IDS_FeaturePartialMethod:\n                case MessageID.IDS_FeatureImplicitLocal: // Checked in the binder.\n                case MessageID.IDS_FeatureAutoImplementedProperties:\n                    return LanguageVersion.CSharp3;\n\n                // C# 2 features.\n                case MessageID.IDS_FeatureGenerics: // Also affects crefs.\n                case MessageID.IDS_FeatureAnonDelegates:\n                case MessageID.IDS_FeatureGlobalNamespace: // Also affects crefs.\n                case MessageID.IDS_FeatureFixedBuffer:\n                case MessageID.IDS_FeatureStaticClasses:\n                case MessageID.IDS_FeaturePartialTypes:\n                case MessageID.IDS_FeaturePropertyAccessorMods:\n                case MessageID.IDS_FeatureExternAlias:\n                case MessageID.IDS_FeatureIterators:\n                case MessageID.IDS_FeatureDefault:\n                case MessageID.IDS_FeatureNullable:\n                case MessageID.IDS_FeaturePragma: // Checked in the directive parser.\n                case MessageID.IDS_FeatureSwitchOnBool: // Checked in the binder.\n                    return LanguageVersion.CSharp2;\n\n                // Special C# 2 feature: only a warning in C# 1.\n                case MessageID.IDS_FeatureModuleAttrLoc:\n                    return LanguageVersion.CSharp1;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(feature);\n            } 7034"];
7034 [label="return LanguageVersion.CSharp3; 7035"];
7035 [label="return availableVersion >= requiredVersion; 7036"];
7036 [label="null 7037"];
7037 [label="options.IsFeatureEnabled(feature) ? null : GetDisabledFeatureDiagnosticInfo(feature, options.LanguageVersion) 7038"];
7038 [label="if (info != null)\n            {\n                if (forceWarning)\n                {\n                    return AddError(node, ErrorCode.WRN_ErrorOverride, info, (int)info.Code);\n                }\n\n                return AddError(node, info.Code, info.Arguments);\n            } 7039"];
7039 [label="if (info != null)\n            {\n                if (forceWarning)\n                {\n                    return AddError(node, ErrorCode.WRN_ErrorOverride, info, (int)info.Code);\n                }\n\n                return AddError(node, info.Code, info.Arguments);\n            } 7040"];
7040 [label="var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken); 7041"];
7041 [label="this.EatToken(SyntaxKind.CloseBraceToken) 7042"];
7042 [label="param EatToken(SyntaxKind kind) 7043"];
7043 [label="param EatToken(this) 7044"];
7044 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 7045"];
7045 [label="SyntaxFacts.IsAnyToken(kind) 7046"];
7046 [label="param IsAnyToken(SyntaxKind kind) 7047"];
7047 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 7048"];
7048 [label="return true; 7049"];
7049 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 7050"];
7050 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 7051"];
7051 [label="param GetTrailingTrivia(this) 7052"];
7052 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 7053"];
7053 [label="MoveToNextToken(); 7054"];
7054 [label="isObjectInitializer 7055"];
7055 [label="return _syntaxFactory.InitializerExpression(\n                    isObjectInitializer ?\n                        SyntaxKind.ObjectInitializerExpression :\n                        SyntaxKind.CollectionInitializerExpression,\n                    openBrace,\n                    initializers,\n                    closeBrace); 7056"];
7056 [label="return _syntaxFactory.InitializerExpression(\n                    isObjectInitializer ?\n                        SyntaxKind.ObjectInitializerExpression :\n                        SyntaxKind.CollectionInitializerExpression,\n                    openBrace,\n                    initializers,\n                    closeBrace); 7057"];
7057 [label="return _syntaxFactory.InitializerExpression(\n                    isObjectInitializer ?\n                        SyntaxKind.ObjectInitializerExpression :\n                        SyntaxKind.CollectionInitializerExpression,\n                    openBrace,\n                    initializers,\n                    closeBrace); 7058"];
7058 [label="return _syntaxFactory.InitializerExpression(\n                    isObjectInitializer ?\n                        SyntaxKind.ObjectInitializerExpression :\n                        SyntaxKind.CollectionInitializerExpression,\n                    openBrace,\n                    initializers,\n                    closeBrace); 7059"];
7059 [label="return _syntaxFactory.InitializerExpression(\n                    isObjectInitializer ?\n                        SyntaxKind.ObjectInitializerExpression :\n                        SyntaxKind.CollectionInitializerExpression,\n                    openBrace,\n                    initializers,\n                    closeBrace); 7060"];
7060 [label="return _syntaxFactory.InitializerExpression(\n                    isObjectInitializer ?\n                        SyntaxKind.ObjectInitializerExpression :\n                        SyntaxKind.CollectionInitializerExpression,\n                    openBrace,\n                    initializers,\n                    closeBrace); 7061"];
7061 [label="param TryGetNode(SyntaxFactoryContext context) 7062"];
7062 [label="param GetNodeFlags(SyntaxFactoryContext context) 7063"];
7063 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 7064"];
7064 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 7065"];
7065 [label="param SetFactoryContext(SyntaxFactoryContext context) 7066"];
7066 [label="param SetFactoryContext(this) 7067"];
7067 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 7068"];
7068 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 7069"];
7069 [label="_pool.Free(initializers); 7070"];
7070 [label="_pool.Free(initializers); 7071"];
7071 [label="initializer = this.ParseObjectOrCollectionInitializer(); 7072"];
7072 [label="if (argumentList == null && initializer == null)\n            {\n                argumentList = _syntaxFactory.ArgumentList(\n                    this.EatToken(SyntaxKind.OpenParenToken, ErrorCode.ERR_BadNewExpr, reportError: type?.ContainsDiagnostics == false),\n                    default(SeparatedSyntaxList<ArgumentSyntax>),\n                    SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken));\n            } 7073"];
7073 [label="if (argumentList == null && initializer == null)\n            {\n                argumentList = _syntaxFactory.ArgumentList(\n                    this.EatToken(SyntaxKind.OpenParenToken, ErrorCode.ERR_BadNewExpr, reportError: type?.ContainsDiagnostics == false),\n                    default(SeparatedSyntaxList<ArgumentSyntax>),\n                    SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken));\n            } 7074"];
7074 [label="if (argumentList == null && initializer == null)\n            {\n                argumentList = _syntaxFactory.ArgumentList(\n                    this.EatToken(SyntaxKind.OpenParenToken, ErrorCode.ERR_BadNewExpr, reportError: type?.ContainsDiagnostics == false),\n                    default(SeparatedSyntaxList<ArgumentSyntax>),\n                    SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken));\n            } 7075"];
7075 [label="if (argumentList == null && initializer == null)\n            {\n                argumentList = _syntaxFactory.ArgumentList(\n                    this.EatToken(SyntaxKind.OpenParenToken, ErrorCode.ERR_BadNewExpr, reportError: type?.ContainsDiagnostics == false),\n                    default(SeparatedSyntaxList<ArgumentSyntax>),\n                    SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken));\n            } 7076"];
7076 [label="return type is null\n                ? (ExpressionSyntax)_syntaxFactory.ImplicitObjectCreationExpression(@new, argumentList, initializer)\n                : (ExpressionSyntax)_syntaxFactory.ObjectCreationExpression(@new, type, argumentList, initializer); 7077"];
7077 [label="type is null 7078"];
7078 [label="return type is null\n                ? (ExpressionSyntax)_syntaxFactory.ImplicitObjectCreationExpression(@new, argumentList, initializer)\n                : (ExpressionSyntax)_syntaxFactory.ObjectCreationExpression(@new, type, argumentList, initializer); 7079"];
7079 [label="return type is null\n                ? (ExpressionSyntax)_syntaxFactory.ImplicitObjectCreationExpression(@new, argumentList, initializer)\n                : (ExpressionSyntax)_syntaxFactory.ObjectCreationExpression(@new, type, argumentList, initializer); 7080"];
7080 [label="return type is null\n                ? (ExpressionSyntax)_syntaxFactory.ImplicitObjectCreationExpression(@new, argumentList, initializer)\n                : (ExpressionSyntax)_syntaxFactory.ObjectCreationExpression(@new, type, argumentList, initializer); 7081"];
7081 [label="param SetFactoryContext(SyntaxFactoryContext context) 7082"];
7082 [label="param SetFactoryContext(this) 7083"];
7083 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 7084"];
7084 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 7085"];
7085 [label="return this.ParseArrayOrObjectCreationExpression(); 7086"];
7086 [label="return this.ParseNewExpression(); 7087"];
7087 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 7088"];
7088 [label="return ParseExpressionContinued(leftOperand, precedence); 7089"];
7089 [label="return ParseExpressionContinued(leftOperand, precedence); 7090"];
7090 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 7091"];
7091 [label="param ParseExpressionContinued(Precedence precedence) 7092"];
7092 [label="bool isAssignmentOperator = false; 7093"];
7093 [label="SyntaxKind opKind; 7094"];
7094 [label="return false; 7095"];
7095 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 7096"];
7096 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 7097"];
7097 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 7098"];
7098 [label="CurrentToken 7099"];
7099 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 7100"];
7100 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 7101"];
7101 [label="CurrentToken.Kind 7102"];
7102 [label="get { return (SyntaxKind)this.RawKind; } 7103"];
7103 [label="return leftOperand; 7104"];
7104 [label="_ = GetPrecedence(result.Kind); 7105"];
7105 [label="result.Kind 7106"];
7106 [label="get { return (SyntaxKind)this.RawKind; } 7107"];
7107 [label="_ = GetPrecedence(result.Kind); 7108"];
7108 [label="GetPrecedence(result.Kind) 7109"];
7109 [label="param GetPrecedence(SyntaxKind op) 7110"];
7110 [label="return Precedence.Primary; 7111"];
7111 [label="_recursionDepth 7112"];
7112 [label="return result; 7113"];
7113 [label="if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    } 7114"];
7114 [label="leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs); 7115"];
7115 [label="leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs); 7116"];
7116 [label="leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs); 7117"];
7117 [label="leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs); 7118"];
7118 [label="leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs); 7119"];
7119 [label="leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs); 7120"];
7120 [label="GetNodeFlags(context) 7121"];
7121 [label="param GetNodeFlags(SyntaxFactoryContext context) 7122"];
7122 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 7123"];
7123 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 7124"];
7124 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 7125"];
7125 [label="return flags; 7126"];
7126 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 7127"];
7127 [label="param SetFactoryContext(SyntaxFactoryContext context) 7128"];
7128 [label="param SetFactoryContext(this) 7129"];
7129 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 7130"];
7130 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 7131"];
7131 [label="return false; 7132"];
7132 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 7133"];
7133 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 7134"];
7134 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 7135"];
7135 [label="CurrentToken 7136"];
7136 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 7137"];
7137 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 7138"];
7138 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 7139"];
7139 [label="CurrentToken.Kind 7140"];
7140 [label="get { return (SyntaxKind)this.RawKind; } 7141"];
7141 [label="_ = GetPrecedence(result.Kind); 7142"];
7142 [label="result.Kind 7143"];
7143 [label="get { return (SyntaxKind)this.RawKind; } 7144"];
7144 [label="_ = GetPrecedence(result.Kind); 7145"];
7145 [label="GetPrecedence(result.Kind) 7146"];
7146 [label="param GetPrecedence(SyntaxKind op) 7147"];
7147 [label="return ParseExpressionStatement(attributes, this.ParseExpressionCore()); 7148"];
7148 [label="ParseExpressionStatement(attributes, this.ParseExpressionCore()) 7149"];
7149 [label="param ParseExpressionStatement(SyntaxList<AttributeListSyntax> attributes) 7150"];
7150 [label="param ParseExpressionStatement(ExpressionSyntax expression) 7151"];
7151 [label="param ParseExpressionStatement(this) 7152"];
7152 [label="SyntaxToken semicolon; 7153"];
7153 [label="IsScript 7154"];
7154 [label="get { return Options.Kind == SourceCodeKind.Script; } 7155"];
7155 [label="Options 7156"];
7156 [label="get { return this.lexer.Options; } 7157"];
7157 [label="this.lexer.Options 7158"];
7158 [label="get { return _options; } 7159"];
7159 [label="return _options; 7160"];
7160 [label="return this.lexer.Options; 7161"];
7161 [label="return Options.Kind == SourceCodeKind.Script; 7162"];
7162 [label="if (IsScript && this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n            {\n                semicolon = SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                // Do not report an error if the expression is not a statement expression.\n                // The error is reported in semantic analysis.\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            } 7163"];
7163 [label="semicolon = this.EatToken(SyntaxKind.SemicolonToken); 7164"];
7164 [label="this.EatToken(SyntaxKind.SemicolonToken) 7165"];
7165 [label="param EatToken(SyntaxKind kind) 7166"];
7166 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 7167"];
7167 [label="SyntaxFacts.IsAnyToken(kind) 7168"];
7168 [label="param IsAnyToken(SyntaxKind kind) 7169"];
7169 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 7170"];
7170 [label="return true; 7171"];
7171 [label="param GetTrailingTrivia(this) 7172"];
7172 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 7173"];
7173 [label="MoveToNextToken(); 7174"];
7174 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 7175"];
7175 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 7176"];
7176 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 7177"];
7177 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 7178"];
7178 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 7179"];
7179 [label="GetNodeFlags(context) 7180"];
7180 [label="param GetNodeFlags(SyntaxFactoryContext context) 7181"];
7181 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 7182"];
7182 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 7183"];
7183 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 7184"];
7184 [label="return flags; 7185"];
7185 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 7186"];
7186 [label="param CSharpSyntaxNode(this) 7187"];
7187 [label="GreenStats.NoteGreen(this); 7188"];
7188 [label="param SetFactoryContext(SyntaxFactoryContext context) 7189"];
7189 [label="param SetFactoryContext(this) 7190"];
7190 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 7191"];
7191 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 7192"];
7192 [label="_recursionDepth 7193"];
7193 [label="this.Release(ref resetPointBeforeStatement); 7194"];
7194 [label="this.Release(ref resetPointBeforeStatement) 7195"];
7195 [label="param Release(ref ResetPoint state) 7196"];
7196 [label="param Release(this) 7197"];
7197 [label="base.Release(ref state.BaseResetPoint); 7198"];
7198 [label="base.Release(ref state.BaseResetPoint) 7199"];
7199 [label="param Release(ref ResetPoint point) 7200"];
7200 [label="param Release(this) 7201"];
7201 [label="Debug.Assert(_resetCount == point.ResetCount); 7202"];
7202 [label="_resetCount 7203"];
7203 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 7204"];
7204 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 7205"];
7205 [label="_resetStart = -1; 7206"];
7206 [label="_resetStart 7207"];
7207 [label="base.Release(ref state.BaseResetPoint); 7208"];
7208 [label="this.Release(ref resetPointBeforeStatement); 7209"];
7209 [label="return parseFunc(); 7210"];
7210 [label="var node = parser.ParseStatement(); 7211"];
7211 [label="if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node); 7212"];
7212 [label="node = parser.ConsumeUnexpectedTokens(node); 7213"];
7213 [label="parser.ConsumeUnexpectedTokens(node) 7214"];
7214 [label="param ConsumeUnexpectedTokens(TNode node) 7215"];
7215 [label="param ConsumeUnexpectedTokens(this) 7216"];
7216 [label="this.CurrentToken 7217"];
7217 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 7218"];
7218 [label="this.FetchCurrentToken() 7219"];
7219 [label="param FetchCurrentToken(this) 7220"];
7220 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 7221"];
7221 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 7222"];
7222 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 7223"];
7223 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken) return node; 7224"];
7224 [label="this.CurrentToken.Kind 7225"];
7225 [label="get { return (SyntaxKind)this.RawKind; } 7226"];
7226 [label="return node; 7227"];
7227 [label="return (StatementSyntax)node.CreateRed(); 7228"];
7228 [label="return (StatementSyntax)node.CreateRed(); 7229"];
7229 [label="return (StatementSyntax)node.CreateRed(); 7230"];
7230 [label="param CSharpSyntaxNode(GreenNode green) 7231"];
7231 [label="param CSharpSyntaxNode(SyntaxNode? parent) 7232"];
7232 [label="param CSharpSyntaxNode(int position) 7233"];
7233 [label="param CSharpSyntaxNode(this) 7234"];
7234 [label="green 7235"];
7235 [label="parent 7236"];
7236 [label="position 7237"];
7237 [label="param CSharpSyntaxNode(this) 7238"];
7238 [label="param CSharpSyntaxNode(this) 7239"];
7239 [label="CustomAssert.Equal(text, node.ToFullString()); 7240"];
7240 [label="CustomAssert.Equal(text, node.ToFullString()); 7241"];
7241 [label="CustomAssert.Equal(text, node.ToFullString()); 7242"];
7242 [label="=> true 7243"];
7243 [label="true 7244"];
7244 [label="param WriteTokenTo(System.IO.TextWriter writer) 7245"];
7245 [label="param WriteTokenTo(bool leading) 7246"];
7246 [label="param WriteTokenTo(bool trailing) 7247"];
7247 [label="param WriteTokenTo(this) 7248"];
7248 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 7249"];
7249 [label="this.GetLeadingTrivia() 7250"];
7250 [label="param GetLeadingTrivia(this) 7251"];
7251 [label="return _leading; 7252"];
7252 [label="var trivia = this.GetLeadingTrivia(); 7253"];
7253 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 7254"];
7254 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 7255"];
7255 [label="this.Text 7256"];
7256 [label="get { return this.TextField; } 7257"];
7257 [label="return this.TextField; 7258"];
7258 [label="writer.Write(this.Text); 7259"];
7259 [label="writer.Write(this.Text); 7260"];
7260 [label="if (trailing)\n            {\n                var trivia = this.GetTrailingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 7261"];
7261 [label="this.GetTrailingTrivia() 7262"];
7262 [label="param GetTrailingTrivia(this) 7263"];
7263 [label="return _trailing; 7264"];
7264 [label="var trivia = this.GetTrailingTrivia(); 7265"];
7265 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 7266"];
7266 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 7267"];
7267 [label="trivia.WriteTo(writer, true, true); 7268"];
7268 [label="trivia.WriteTo(writer, true, true); 7269"];
7269 [label="=> true 7270"];
7270 [label="true 7271"];
7271 [label="param WriteTriviaTo(System.IO.TextWriter writer) 7272"];
7272 [label="param WriteTriviaTo(this) 7273"];
7273 [label="writer.Write(Text); 7274"];
7274 [label="writer.Write(Text); 7275"];
7275 [label="param GetLeadingTrivia(this) 7276"];
7276 [label="return this.LeadingField; 7277"];
7277 [label="var trivia = this.GetLeadingTrivia(); 7278"];
7278 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 7279"];
7279 [label="get { return SyntaxFacts.GetText(this.Kind); } 7280"];
7280 [label="this.Kind 7281"];
7281 [label="get { return (SyntaxKind)this.RawKind; } 7282"];
7282 [label="return (SyntaxKind)this.RawKind; 7283"];
7283 [label="return SyntaxFacts.GetText(this.Kind); 7284"];
7284 [label="SyntaxFacts.GetText(this.Kind) 7285"];
7285 [label="param GetText(SyntaxKind kind) 7286"];
7286 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 7287"];
7287 [label="return '='; 7288"];
7288 [label="param GetTrailingTrivia(this) 7289"];
7289 [label="=> true 7290"];
7290 [label="return this.LeadingField; 7291"];
7291 [label="var trivia = this.GetLeadingTrivia(); 7292"];
7292 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 7293"];
7293 [label="return 'new'; 7294"];
7294 [label="=> true 7295"];
7295 [label="param GetLeadingTrivia(this) 7296"];
7296 [label="return null; 7297"];
7297 [label="var trivia = this.GetLeadingTrivia(); 7298"];
7298 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 7299"];
7299 [label="return '('; 7300"];
7300 [label="param GetTrailingTrivia(this) 7301"];
7301 [label="var trivia = this.GetTrailingTrivia(); 7302"];
7302 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 7303"];
7303 [label="return 'int'; 7304"];
7304 [label="return this.LeadingField; 7305"];
7305 [label="var trivia = this.GetLeadingTrivia(); 7306"];
7306 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 7307"];
7307 [label="return ','; 7308"];
7308 [label="=> true 7309"];
7309 [label="return ')'; 7310"];
7310 [label="return this.LeadingField; 7311"];
7311 [label="var trivia = this.GetLeadingTrivia(); 7312"];
7312 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 7313"];
7313 [label="return '?'; 7314"];
7314 [label="=> true 7315"];
7315 [label="return '{'; 7316"];
7316 [label="return '}'; 7317"];
7317 [label="return ';'; 7318"];
7318 [label="node.GetDiagnostics() 7319"];
7319 [label="param GetDiagnostics(this) 7320"];
7320 [label="this.SyntaxTree 7321"];
7321 [label="get\n            {\n                var result = this._syntaxTree ?? ComputeSyntaxTree(this);\n                Debug.Assert(result != null);\n                return result;\n            } 7322"];
7322 [label="var result = this._syntaxTree ?? ComputeSyntaxTree(this); 7323"];
7323 [label="ComputeSyntaxTree(this) 7324"];
7324 [label="param ComputeSyntaxTree(CSharpSyntaxNode node) 7325"];
7325 [label="ArrayBuilder<CSharpSyntaxNode>? nodes = null; 7326"];
7326 [label="SyntaxTree? tree = null; 7327"];
7327 [label="while (true)\n            {\n                tree = node._syntaxTree;\n                if (tree != null)\n                {\n                    break;\n                }\n\n                var parent = node.Parent;\n                if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                }\n\n                tree = parent._syntaxTree;\n                if (tree != null)\n                {\n                    node._syntaxTree = tree;\n                    break;\n                }\n\n                (nodes ?? (nodes = ArrayBuilder<CSharpSyntaxNode>.GetInstance())).Add(node);\n                node = parent;\n            } 7328"];
7328 [label="tree = node._syntaxTree; 7329"];
7329 [label="if (tree != null)\n                {\n                    break;\n                } 7330"];
7330 [label="if (tree != null)\n                {\n                    break;\n                } 7331"];
7331 [label="node.Parent 7332"];
7332 [label="get\n            {\n                return (CSharpSyntaxNode?)base.Parent;\n            } 7333"];
7333 [label="return (CSharpSyntaxNode?)base.Parent; 7334"];
7334 [label="var parent = node.Parent; 7335"];
7335 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 7336"];
7336 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 7337"];
7337 [label="new DummySyntaxTree() 7338"];
7338 [label="param DummySyntaxTree(this) 7339"];
7339 [label="param CSharpSyntaxTree(this) 7340"];
7340 [label="_hasDirectives 7341"];
7341 [label="_lazyLineDirectiveMap 7342"];
7342 [label="_lazyPragmaWarningStateMap 7343"];
7343 [label="_lazyNullableContextStateMap 7344"];
7344 [label="_lazyIsGeneratedCode = GeneratedKind.Unknown 7345"];
7345 [label="_node 7346"];
7346 [label="_node = this.CloneNodeAsRoot(SyntaxFactory.ParseCompilationUnit(string.Empty)); 7347"];
7347 [label="_node = this.CloneNodeAsRoot(SyntaxFactory.ParseCompilationUnit(string.Empty)); 7348"];
7348 [label="SyntaxFactory.ParseCompilationUnit(string.Empty) 7349"];
7349 [label="param ParseCompilationUnit(string text) 7350"];
7350 [label="param ParseCompilationUnit(int offset = 0) 7351"];
7351 [label="param ParseCompilationUnit(CSharpParseOptions? options = null) 7352"];
7352 [label="using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                return (CompilationUnitSyntax)node.CreateRed();\n            } 7353"];
7353 [label="using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                return (CompilationUnitSyntax)node.CreateRed();\n            } 7354"];
7354 [label="using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                return (CompilationUnitSyntax)node.CreateRed();\n            } 7355"];
7355 [label="MakeLexer(text, offset, options) 7356"];
7356 [label="param MakeLexer(string text) 7357"];
7357 [label="param MakeLexer(int offset) 7358"];
7358 [label="param MakeLexer(CSharpParseOptions? options = null) 7359"];
7359 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 7360"];
7360 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 7361"];
7361 [label="MakeSourceText(text, offset) 7362"];
7362 [label="param MakeSourceText(string text) 7363"];
7363 [label="param MakeSourceText(int offset) 7364"];
7364 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 7365"];
7365 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 7366"];
7366 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 7367"];
7367 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 7368"];
7368 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 7369"];
7369 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 7370"];
7370 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 7371"];
7371 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 7372"];
7372 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 7373"];
7373 [label="new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default) 7374"];
7374 [label="param Lexer(CSharpParseOptions options) 7375"];
7375 [label="param Lexer(bool allowPreprocessorDirectives = true) 7376"];
7376 [label="param Lexer(bool interpolationFollowedByColon = false) 7377"];
7377 [label="param Lexer(this) 7378"];
7378 [label="param Lexer(this) 7379"];
7379 [label="param AbstractLexer(this) 7380"];
7380 [label="TextWindow 7381"];
7381 [label="_errors 7382"];
7382 [label="this.TextWindow = new SlidingTextWindow(text); 7383"];
7383 [label="new SlidingTextWindow(text) 7384"];
7384 [label="param SlidingTextWindow(this) 7385"];
7385 [label="_text 7386"];
7386 [label="_basis 7387"];
7387 [label="_offset 7388"];
7388 [label="_textEnd 7389"];
7389 [label="_characterWindow 7390"];
7390 [label="_characterWindowCount 7391"];
7391 [label="_lexemeStart 7392"];
7392 [label="_strings 7393"];
7393 [label="_basis = 0; 7394"];
7394 [label="_basis 7395"];
7395 [label="_offset = 0; 7396"];
7396 [label="_offset 7397"];
7397 [label="_strings = StringTable.GetInstance(); 7398"];
7398 [label="_strings 7399"];
7399 [label="_lexemeStart = 0; 7400"];
7400 [label="_lexemeStart 7401"];
7401 [label="this.TextWindow 7402"];
7402 [label="_options 7403"];
7403 [label="_mode 7404"];
7404 [label="_builder 7405"];
7405 [label="_identBuffer 7406"];
7406 [label="_identLen 7407"];
7407 [label="_cache 7408"];
7408 [label="_allowPreprocessorDirectives 7409"];
7409 [label="_interpolationFollowedByColon 7410"];
7410 [label="_xmlParser 7411"];
7411 [label="_badTokenCount 7412"];
7412 [label="10 7413"];
7413 [label="new SyntaxListBuilder(10) 7414"];
7414 [label="_leadingTriviaCache = new SyntaxListBuilder(10) 7415"];
7415 [label="10 7416"];
7416 [label="new SyntaxListBuilder(10) 7417"];
7417 [label="_trailingTriviaCache = new SyntaxListBuilder(10) 7418"];
7418 [label="_createWhitespaceTriviaFunction 7419"];
7419 [label="_createQuickTokenFunction 7420"];
7420 [label="Debug.Assert(options != null); 7421"];
7421 [label="Debug.Assert(options != null); 7422"];
7422 [label="_options 7423"];
7423 [label="_builder = new StringBuilder(); 7424"];
7424 [label="_builder 7425"];
7425 [label="_identBuffer = new char[32]; 7426"];
7426 [label="_identBuffer 7427"];
7427 [label="_cache = new LexerCache(); 7428"];
7428 [label="new LexerCache() 7429"];
7429 [label="param LexerCache(this) 7430"];
7430 [label="_triviaMap 7431"];
7431 [label="_tokenMap 7432"];
7432 [label="_keywordKindMap 7433"];
7433 [label="_triviaMap = TextKeyedCache<SyntaxTrivia>.GetInstance(); 7434"];
7434 [label="_triviaMap 7435"];
7435 [label="_tokenMap = TextKeyedCache<SyntaxToken>.GetInstance(); 7436"];
7436 [label="_tokenMap 7437"];
7437 [label="_cache 7438"];
7438 [label="_createQuickTokenFunction 7439"];
7439 [label="_allowPreprocessorDirectives 7440"];
7440 [label="_interpolationFollowedByColon 7441"];
7441 [label="using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                return (CompilationUnitSyntax)node.CreateRed();\n            } 7442"];
7442 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                return (CompilationUnitSyntax)node.CreateRed();\n            } 7443"];
7443 [label="MakeParser(lexer) 7444"];
7444 [label="param MakeParser(InternalSyntax.Lexer lexer) 7445"];
7445 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 7446"];
7446 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 7447"];
7447 [label="new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null) 7448"];
7448 [label="param LanguageParser(Lexer lexer) 7449"];
7449 [label="param LanguageParser(CSharp.CSharpSyntaxNode oldTree) 7450"];
7450 [label="param LanguageParser(IEnumerable<TextChangeRange> changes) 7451"];
7451 [label="param LanguageParser(LexerMode lexerMode = LexerMode.Syntax) 7452"];
7452 [label="param LanguageParser(CancellationToken cancellationToken = default(CancellationToken)) 7453"];
7453 [label="param LanguageParser(this) 7454"];
7454 [label="lexer 7455"];
7455 [label="lexerMode 7456"];
7456 [label="oldTree 7457"];
7457 [label="changes 7458"];
7458 [label="false 7459"];
7459 [label="true 7460"];
7460 [label="cancellationToken 7461"];
7461 [label="param LanguageParser(this) 7462"];
7462 [label="param SyntaxParser(Lexer lexer) 7463"];
7463 [label="param SyntaxParser(LexerMode mode) 7464"];
7464 [label="param SyntaxParser(CSharp.CSharpSyntaxNode oldTree) 7465"];
7465 [label="param SyntaxParser(IEnumerable<TextChangeRange> changes) 7466"];
7466 [label="param SyntaxParser(bool allowModeReset) 7467"];
7467 [label="param SyntaxParser(bool preLexIfNotIncremental = false) 7468"];
7468 [label="param SyntaxParser(CancellationToken cancellationToken = default(CancellationToken)) 7469"];
7469 [label="param SyntaxParser(this) 7470"];
7470 [label="lexer 7471"];
7471 [label="_isIncremental 7472"];
7472 [label="_allowModeReset 7473"];
7473 [label="_mode 7474"];
7474 [label="_currentToken 7475"];
7475 [label="_lexedTokens 7476"];
7476 [label="_prevTokenTrailingTrivia 7477"];
7477 [label="_firstToken 7478"];
7478 [label="_tokenOffset 7479"];
7479 [label="_tokenCount 7480"];
7480 [label="_resetCount 7481"];
7481 [label="_resetStart 7482"];
7482 [label="_blendedTokens 7483"];
7483 [label="this.lexer 7484"];
7484 [label="_mode 7485"];
7485 [label="_allowModeReset 7486"];
7486 [label="this.cancellationToken 7487"];
7487 [label="_currentNode = default(BlendedNode); 7488"];
7488 [label="_currentNode 7489"];
7489 [label="_isIncremental = oldTree != null; 7490"];
7490 [label="_isIncremental = oldTree != null; 7491"];
7491 [label="_isIncremental 7492"];
7492 [label="this.IsIncremental 7493"];
7493 [label="get\n            {\n                return _isIncremental;\n            } 7494"];
7494 [label="return _isIncremental; 7495"];
7495 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 7496"];
7496 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 7497"];
7497 [label="_firstBlender = default(Blender); 7498"];
7498 [label="_firstBlender 7499"];
7499 [label="_lexedTokens = new ArrayElement<SyntaxToken>[32]; 7500"];
7500 [label="_lexedTokens 7501"];
7501 [label="this.IsIncremental 7502"];
7502 [label="get\n            {\n                return _isIncremental;\n            } 7503"];
7503 [label="return _isIncremental; 7504"];
7504 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 7505"];
7505 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 7506"];
7506 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 7507"];
7507 [label="this.PreLex() 7508"];
7508 [label="param PreLex(this) 7509"];
7509 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 7510"];
7510 [label="this.lexer.TextWindow.Text 7511"];
7511 [label="=> _text 7512"];
7512 [label="_text 7513"];
7513 [label="var lexer = this.lexer; 7514"];
7514 [label="var mode = _mode; 7515"];
7515 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 7516"];
7516 [label="TokensLexed++; 7517"];
7517 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 7518"];
7518 [label="TextWindow.Start(); 7519"];
7519 [label="param LexSyntaxTrivia(bool afterFirstToken) 7520"];
7520 [label="bool onlyWhitespaceOnLine = !isTrailing; 7521"];
7521 [label="this.Start(); 7522"];
7522 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 7523"];
7523 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 7524"];
7524 [label="SyntaxFacts.IsWhitespace(ch) 7525"];
7525 [label="param IsWhitespace(char ch) 7526"];
7526 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 7527"];
7527 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 7528"];
7528 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 7529"];
7529 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 7530"];
7530 [label="SyntaxFacts.IsNewLine(ch) 7531"];
7531 [label="param IsNewLine(char ch) 7532"];
7532 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 7533"];
7533 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 7534"];
7534 [label="return; 7535"];
7535 [label="this.Start(); 7536"];
7536 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 7537"];
7537 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 7538"];
7538 [label="var errors = this.GetErrors(GetFullWidth(leading)); 7539"];
7539 [label="GetFullWidth(leading) 7540"];
7540 [label="param GetFullWidth(SyntaxListBuilder builder) 7541"];
7541 [label="int width = 0; 7542"];
7542 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 7543"];
7543 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 7544"];
7544 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 7545"];
7545 [label="return width; 7546"];
7546 [label="var errors = this.GetErrors(GetFullWidth(leading)); 7547"];
7547 [label="this.GetErrors(GetFullWidth(leading)) 7548"];
7548 [label="param GetErrors(int leadingTriviaWidth) 7549"];
7549 [label="param GetErrors(this) 7550"];
7550 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 7551"];
7551 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 7552"];
7552 [label="return null; 7553"];
7553 [label="var errors = this.GetErrors(GetFullWidth(leading)); 7554"];
7554 [label="param LexSyntaxTrivia(bool afterFirstToken) 7555"];
7555 [label="param Create(SyntaxDiagnosticInfo[] errors) 7556"];
7556 [label="param Create(this) 7557"];
7557 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 7558"];
7558 [label="SyntaxToken token; 7559"];
7559 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 7560"];
7560 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 7561"];
7561 [label="param Token(GreenNode leading) 7562"];
7562 [label="param Token(SyntaxKind kind) 7563"];
7563 [label="param Token(GreenNode trailing) 7564"];
7564 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 7565"];
7565 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 7566"];
7566 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 7567"];
7567 [label="this.AddLexedToken(token); 7568"];
7568 [label="param AddLexedToken(SyntaxToken token) 7569"];
7569 [label="Debug.Assert(token != null); 7570"];
7570 [label="Debug.Assert(token != null); 7571"];
7571 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 7572"];
7572 [label="_lexedTokens[_tokenCount].Value = token; 7573"];
7573 [label="_lexedTokens[_tokenCount].Value 7574"];
7574 [label="this.AddLexedToken(token); 7575"];
7575 [label="token.Kind 7576"];
7576 [label="get { return (SyntaxKind)this.RawKind; } 7577"];
7577 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 7578"];
7578 [label="this.PreLex(); 7579"];
7579 [label="new SyntaxListPool() 7580"];
7580 [label="_pool = new SyntaxListPool() 7581"];
7581 [label="_syntaxFactoryContext 7582"];
7582 [label="_syntaxFactory 7583"];
7583 [label="_recursionDepth 7584"];
7584 [label="_termState 7585"];
7585 [label="_isInTry 7586"];
7586 [label="_checkedTopLevelStatementsFeatureAvailability 7587"];
7587 [label="_syntaxFactoryContext = new SyntaxFactoryContext(); 7588"];
7588 [label="_syntaxFactoryContext 7589"];
7589 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 7590"];
7590 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 7591"];
7591 [label="_syntaxFactory 7592"];
7592 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                return (CompilationUnitSyntax)node.CreateRed();\n            } 7593"];
7593 [label="parser.ParseCompilationUnit() 7594"];
7594 [label="param ParseCompilationUnit(this) 7595"];
7595 [label="return ParseWithStackGuard(\n                ParseCompilationUnitCore,\n                () => SyntaxFactory.CompilationUnit(\n                        new SyntaxList<ExternAliasDirectiveSyntax>(),\n                        new SyntaxList<UsingDirectiveSyntax>(),\n                        new SyntaxList<AttributeListSyntax>(),\n                        new SyntaxList<MemberDeclarationSyntax>(),\n                        SyntaxFactory.Token(SyntaxKind.EndOfFileToken))); 7596"];
7596 [label="return ParseWithStackGuard(\n                ParseCompilationUnitCore,\n                () => SyntaxFactory.CompilationUnit(\n                        new SyntaxList<ExternAliasDirectiveSyntax>(),\n                        new SyntaxList<UsingDirectiveSyntax>(),\n                        new SyntaxList<AttributeListSyntax>(),\n                        new SyntaxList<MemberDeclarationSyntax>(),\n                        SyntaxFactory.Token(SyntaxKind.EndOfFileToken))); 7597"];
7597 [label="ParseWithStackGuard(\n                ParseCompilationUnitCore,\n                () => SyntaxFactory.CompilationUnit(\n                        new SyntaxList<ExternAliasDirectiveSyntax>(),\n                        new SyntaxList<UsingDirectiveSyntax>(),\n                        new SyntaxList<AttributeListSyntax>(),\n                        new SyntaxList<MemberDeclarationSyntax>(),\n                        SyntaxFactory.Token(SyntaxKind.EndOfFileToken))) 7598"];
7598 [label="param ParseWithStackGuard(Func<TNode> parseFunc) 7599"];
7599 [label="param ParseWithStackGuard(Func<TNode> createEmptyNodeFunc) 7600"];
7600 [label="param ParseWithStackGuard(this) 7601"];
7601 [label="Debug.Assert(_recursionDepth == 0); 7602"];
7602 [label="Debug.Assert(_recursionDepth == 0); 7603"];
7603 [label="return parseFunc(); 7604"];
7604 [label="return parseFunc(); 7605"];
7605 [label="param ParseCompilationUnitCore(this) 7606"];
7606 [label="SyntaxToken tmp = null; 7607"];
7607 [label="SyntaxListBuilder initialBadNodes = null; 7608"];
7608 [label="var body = new NamespaceBodyBuilder(_pool); 7609"];
7609 [label="var body = new NamespaceBodyBuilder(_pool); 7610"];
7610 [label="new NamespaceBodyBuilder(_pool) 7611"];
7611 [label="param NamespaceBodyBuilder(SyntaxListPool pool) 7612"];
7612 [label="param NamespaceBodyBuilder(this) 7613"];
7613 [label="Externs = pool.Allocate<ExternAliasDirectiveSyntax>(); 7614"];
7614 [label="Externs 7615"];
7615 [label="Usings = pool.Allocate<UsingDirectiveSyntax>(); 7616"];
7616 [label="Usings 7617"];
7617 [label="Attributes = pool.Allocate<AttributeListSyntax>(); 7618"];
7618 [label="Attributes 7619"];
7619 [label="Members = pool.Allocate<MemberDeclarationSyntax>(); 7620"];
7620 [label="Members 7621"];
7621 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 7622"];
7622 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 7623"];
7623 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 7624"];
7624 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 7625"];
7625 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 7626"];
7626 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 7627"];
7627 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 7628"];
7628 [label="return _syntaxFactoryContext.IsInAsync; 7629"];
7629 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 7630"];
7630 [label="this.FetchCurrentToken() 7631"];
7631 [label="param FetchCurrentToken(this) 7632"];
7632 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 7633"];
7633 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 7634"];
7634 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 7635"];
7635 [label="return _lexedTokens[_tokenOffset]; 7636"];
7636 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 7637"];
7637 [label="_currentToken 7638"];
7638 [label="get { return (SyntaxKind)this.RawKind; } 7639"];
7639 [label="return (SyntaxKind)this.RawKind; 7640"];
7640 [label="param AddIncompleteMembers(ref SyntaxListBuilder<MemberDeclarationSyntax> incompleteMembers) 7641"];
7641 [label="param AddIncompleteMembers(ref NamespaceBodyBuilder body) 7642"];
7642 [label="if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            } 7643"];
7643 [label="if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            } 7644"];
7644 [label="var eof = this.EatToken(SyntaxKind.EndOfFileToken); 7645"];
7645 [label="this.EatToken(SyntaxKind.EndOfFileToken) 7646"];
7646 [label="param EatToken(SyntaxKind kind) 7647"];
7647 [label="param EatToken(this) 7648"];
7648 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 7649"];
7649 [label="SyntaxFacts.IsAnyToken(kind) 7650"];
7650 [label="param IsAnyToken(SyntaxKind kind) 7651"];
7651 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 7652"];
7652 [label="return true; 7653"];
7653 [label="this.CurrentToken 7654"];
7654 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 7655"];
7655 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 7656"];
7656 [label="var ct = this.CurrentToken; 7657"];
7657 [label="ct.Kind 7658"];
7658 [label="get { return (SyntaxKind)this.RawKind; } 7659"];
7659 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 7660"];
7660 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 7661"];
7661 [label="MoveToNextToken() 7662"];
7662 [label="param MoveToNextToken(this) 7663"];
7663 [label="_currentToken.GetTrailingTrivia() 7664"];
7664 [label="param GetTrailingTrivia(this) 7665"];
7665 [label="return null; 7666"];
7666 [label="_prevTokenTrailingTrivia = _currentToken.GetTrailingTrivia(); 7667"];
7667 [label="_prevTokenTrailingTrivia 7668"];
7668 [label="_currentToken = null; 7669"];
7669 [label="_currentToken 7670"];
7670 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 7671"];
7671 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 7672"];
7672 [label="_tokenOffset 7673"];
7673 [label="MoveToNextToken(); 7674"];
7674 [label="return ct; 7675"];
7675 [label="var result = _syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof); 7676"];
7676 [label="var result = _syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof); 7677"];
7677 [label="var result = _syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof); 7678"];
7678 [label="var result = _syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof); 7679"];
7679 [label="param CSharpSyntaxNode(SyntaxKind kind) 7680"];
7680 [label="param CSharpSyntaxNode(this) 7681"];
7681 [label="kind 7682"];
7682 [label="param CSharpSyntaxNode(this) 7683"];
7683 [label="param CSharpSyntaxNode(this) 7684"];
7684 [label="GreenStats.NoteGreen(this); 7685"];
7685 [label="GreenStats.NoteGreen(this); 7686"];
7686 [label="param SetFactoryContext(SyntaxFactoryContext context) 7687"];
7687 [label="param SetFactoryContext(this) 7688"];
7688 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 7689"];
7689 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 7690"];
7690 [label="if (initialBadNodes != null)\n                {\n                    // attach initial bad nodes as leading trivia on first token\n                    result = AddLeadingSkippedSyntax(result, initialBadNodes.ToListNode());\n                    _pool.Free(initialBadNodes);\n                } 7691"];
7691 [label="if (initialBadNodes != null)\n                {\n                    // attach initial bad nodes as leading trivia on first token\n                    result = AddLeadingSkippedSyntax(result, initialBadNodes.ToListNode());\n                    _pool.Free(initialBadNodes);\n                } 7692"];
7692 [label="return result; 7693"];
7693 [label="body.Free(_pool); 7694"];
7694 [label="body.Free(_pool) 7695"];
7695 [label="param Free(SyntaxListPool pool) 7696"];
7696 [label="param Free(this) 7697"];
7697 [label="pool.Free(Members); 7698"];
7698 [label="pool.Free(Members); 7699"];
7699 [label="pool.Free(Attributes); 7700"];
7700 [label="pool.Free(Attributes); 7701"];
7701 [label="pool.Free(Usings); 7702"];
7702 [label="pool.Free(Usings); 7703"];
7703 [label="pool.Free(Externs); 7704"];
7704 [label="pool.Free(Externs); 7705"];
7705 [label="body.Free(_pool); 7706"];
7706 [label="return parseFunc(); 7707"];
7707 [label="var node = parser.ParseCompilationUnit(); 7708"];
7708 [label="return (CompilationUnitSyntax)node.CreateRed(); 7709"];
7709 [label="return (CompilationUnitSyntax)node.CreateRed(); 7710"];
7710 [label="return (CompilationUnitSyntax)node.CreateRed(); 7711"];
7711 [label="param CSharpSyntaxNode(GreenNode green) 7712"];
7712 [label="param CSharpSyntaxNode(SyntaxNode? parent) 7713"];
7713 [label="param CSharpSyntaxNode(int position) 7714"];
7714 [label="param CSharpSyntaxNode(this) 7715"];
7715 [label="green 7716"];
7716 [label="parent 7717"];
7717 [label="position 7718"];
7718 [label="param CSharpSyntaxNode(this) 7719"];
7719 [label="param CSharpSyntaxNode(this) 7720"];
7720 [label="_node = this.CloneNodeAsRoot(SyntaxFactory.ParseCompilationUnit(string.Empty)); 7721"];
7721 [label="this.CloneNodeAsRoot(SyntaxFactory.ParseCompilationUnit(string.Empty)) 7722"];
7722 [label="param CloneNodeAsRoot(T node) 7723"];
7723 [label="param CloneNodeAsRoot(this) 7724"];
7724 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 7725"];
7725 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 7726"];
7726 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 7727"];
7727 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 7728"];
7728 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 7729"];
7729 [label="param CSharpSyntaxNode(this) 7730"];
7730 [label="_node 7731"];
7731 [label="Dummy = new DummySyntaxTree() 7732"];
7732 [label="Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null); 7733"];
7733 [label="Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null); 7734"];
7734 [label="CSharpSyntaxTree.CreateWithoutClone(node) 7735"];
7735 [label="param CreateWithoutClone(CSharpSyntaxNode root) 7736"];
7736 [label="Debug.Assert(root != null); 7737"];
7737 [label="Debug.Assert(root != null); 7738"];
7738 [label="return new ParsedSyntaxTree(\n                textOpt: null,\n                encodingOpt: null,\n                checksumAlgorithm: SourceHashAlgorithm.Sha1,\n                path: '',\n                options: CSharpParseOptions.Default,\n                root: root,\n                directives: InternalSyntax.DirectiveStack.Empty,\n                diagnosticOptions: null,\n                cloneRoot: false); 7739"];
7739 [label="return new ParsedSyntaxTree(\n                textOpt: null,\n                encodingOpt: null,\n                checksumAlgorithm: SourceHashAlgorithm.Sha1,\n                path: '',\n                options: CSharpParseOptions.Default,\n                root: root,\n                directives: InternalSyntax.DirectiveStack.Empty,\n                diagnosticOptions: null,\n                cloneRoot: false); 7740"];
7740 [label="return new ParsedSyntaxTree(\n                textOpt: null,\n                encodingOpt: null,\n                checksumAlgorithm: SourceHashAlgorithm.Sha1,\n                path: '',\n                options: CSharpParseOptions.Default,\n                root: root,\n                directives: InternalSyntax.DirectiveStack.Empty,\n                diagnosticOptions: null,\n                cloneRoot: false); 7741"];
7741 [label="return new ParsedSyntaxTree(\n                textOpt: null,\n                encodingOpt: null,\n                checksumAlgorithm: SourceHashAlgorithm.Sha1,\n                path: '',\n                options: CSharpParseOptions.Default,\n                root: root,\n                directives: InternalSyntax.DirectiveStack.Empty,\n                diagnosticOptions: null,\n                cloneRoot: false); 7742"];
7742 [label="return new ParsedSyntaxTree(\n                textOpt: null,\n                encodingOpt: null,\n                checksumAlgorithm: SourceHashAlgorithm.Sha1,\n                path: '',\n                options: CSharpParseOptions.Default,\n                root: root,\n                directives: InternalSyntax.DirectiveStack.Empty,\n                diagnosticOptions: null,\n                cloneRoot: false); 7743"];
7743 [label="new ParsedSyntaxTree(\n                textOpt: null,\n                encodingOpt: null,\n                checksumAlgorithm: SourceHashAlgorithm.Sha1,\n                path: '',\n                options: CSharpParseOptions.Default,\n                root: root,\n                directives: InternalSyntax.DirectiveStack.Empty,\n                diagnosticOptions: null,\n                cloneRoot: false) 7744"];
7744 [label="param ParsedSyntaxTree(SourceText? textOpt) 7745"];
7745 [label="param ParsedSyntaxTree(Encoding? encodingOpt) 7746"];
7746 [label="param ParsedSyntaxTree(SourceHashAlgorithm checksumAlgorithm) 7747"];
7747 [label="param ParsedSyntaxTree(string path) 7748"];
7748 [label="param ParsedSyntaxTree(CSharpParseOptions options) 7749"];
7749 [label="param ParsedSyntaxTree(CSharpSyntaxNode root) 7750"];
7750 [label="param ParsedSyntaxTree(Syntax.InternalSyntax.DirectiveStack directives) 7751"];
7751 [label="param ParsedSyntaxTree(ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions) 7752"];
7752 [label="param ParsedSyntaxTree(bool cloneRoot) 7753"];
7753 [label="param ParsedSyntaxTree(this) 7754"];
7754 [label="param ParsedSyntaxTree(this) 7755"];
7755 [label="param CSharpSyntaxTree(this) 7756"];
7756 [label="param CSharpSyntaxTree(this) 7757"];
7757 [label="_hasDirectives 7758"];
7758 [label="_lazyLineDirectiveMap 7759"];
7759 [label="_lazyPragmaWarningStateMap 7760"];
7760 [label="_lazyNullableContextStateMap 7761"];
7761 [label="_lazyIsGeneratedCode = GeneratedKind.Unknown 7762"];
7762 [label="_options 7763"];
7763 [label="_path 7764"];
7764 [label="_root 7765"];
7765 [label="_hasCompilationUnitRoot 7766"];
7766 [label="_encodingOpt 7767"];
7767 [label="_checksumAlgorithm 7768"];
7768 [label="_diagnosticOptions 7769"];
7769 [label="_lazyText 7770"];
7770 [label="Debug.Assert(root != null); 7771"];
7771 [label="Debug.Assert(root != null); 7772"];
7772 [label="Debug.Assert(options != null); 7773"];
7773 [label="Debug.Assert(options != null); 7774"];
7774 [label="Debug.Assert(textOpt == null || textOpt.Encoding == encodingOpt && textOpt.ChecksumAlgorithm == checksumAlgorithm); 7775"];
7775 [label="Debug.Assert(textOpt == null || textOpt.Encoding == encodingOpt && textOpt.ChecksumAlgorithm == checksumAlgorithm); 7776"];
7776 [label="_lazyText 7777"];
7777 [label="_encodingOpt = encodingOpt ?? textOpt?.Encoding; 7778"];
7778 [label="_encodingOpt = encodingOpt ?? textOpt?.Encoding; 7779"];
7779 [label="_encodingOpt 7780"];
7780 [label="_checksumAlgorithm 7781"];
7781 [label="_options 7782"];
7782 [label="_path = path ?? string.Empty; 7783"];
7783 [label="_path 7784"];
7784 [label="cloneRoot 7785"];
7785 [label="_root = cloneRoot ? this.CloneNodeAsRoot(root) : root; 7786"];
7786 [label="_root 7787"];
7787 [label="root.Kind() 7788"];
7788 [label="param Kind(this) 7789"];
7789 [label="return (SyntaxKind)this.Green.RawKind; 7790"];
7790 [label="_hasCompilationUnitRoot = root.Kind() == SyntaxKind.CompilationUnit; 7791"];
7791 [label="_hasCompilationUnitRoot 7792"];
7792 [label="_diagnosticOptions = diagnosticOptions ?? EmptyDiagnosticOptions; 7793"];
7793 [label="_diagnosticOptions = diagnosticOptions ?? EmptyDiagnosticOptions; 7794"];
7794 [label="_diagnosticOptions 7795"];
7795 [label="this.SetDirectiveStack(directives); 7796"];
7796 [label="this.SetDirectiveStack(directives) 7797"];
7797 [label="param SetDirectiveStack(InternalSyntax.DirectiveStack directives) 7798"];
7798 [label="param SetDirectiveStack(this) 7799"];
7799 [label="_directives 7800"];
7800 [label="_hasDirectives = true; 7801"];
7801 [label="_hasDirectives 7802"];
7802 [label="this.SetDirectiveStack(directives); 7803"];
7803 [label="Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null); 7804"];
7804 [label="Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null); 7805"];
7805 [label="Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null); 7806"];
7806 [label="tree = node._syntaxTree; 7807"];
7807 [label="if (nodes != null)\n            {\n                Debug.Assert(tree != null);\n\n                foreach (var n in nodes)\n                {\n                    var existingTree = n._syntaxTree;\n                    if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    }\n                    n._syntaxTree = tree;\n                }\n\n                nodes.Free();\n            } 7808"];
7808 [label="if (nodes != null)\n            {\n                Debug.Assert(tree != null);\n\n                foreach (var n in nodes)\n                {\n                    var existingTree = n._syntaxTree;\n                    if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    }\n                    n._syntaxTree = tree;\n                }\n\n                nodes.Free();\n            } 7809"];
7809 [label="return tree; 7810"];
7810 [label="Debug.Assert(result != null); 7811"];
7811 [label="Debug.Assert(result != null); 7812"];
7812 [label="return result; 7813"];
7813 [label="return this.SyntaxTree.GetDiagnostics(this); 7814"];
7814 [label="return this.SyntaxTree.GetDiagnostics(this); 7815"];
7815 [label="this.SyntaxTree.GetDiagnostics(this) 7816"];
7816 [label="param GetDiagnostics(SyntaxNode node) 7817"];
7817 [label="param GetDiagnostics(this) 7818"];
7818 [label="if (node == null)\n            {\n                throw new ArgumentNullException(nameof(node));\n            } 7819"];
7819 [label="if (node == null)\n            {\n                throw new ArgumentNullException(nameof(node));\n            } 7820"];
7820 [label="return GetDiagnostics(node.Green, node.Position); 7821"];
7821 [label="GetDiagnostics(node.Green, node.Position) 7822"];
7822 [label="param GetDiagnostics(GreenNode greenNode) 7823"];
7823 [label="param GetDiagnostics(int position) 7824"];
7824 [label="param GetDiagnostics(this) 7825"];
7825 [label="if (greenNode == null)\n            {\n                throw new InvalidOperationException();\n            } 7826"];
7826 [label="if (greenNode == null)\n            {\n                throw new InvalidOperationException();\n            } 7827"];
7827 [label="if (greenNode.ContainsDiagnostics)\n            {\n                return EnumerateDiagnostics(greenNode, position);\n            } 7828"];
7828 [label="return SpecializedCollections.EmptyEnumerable<Diagnostic>(); 7829"];
7829 [label="return GetDiagnostics(node.Green, node.Position); 7830"];
7830 [label="return this.SyntaxTree.GetDiagnostics(this); 7831"];
7831 [label="var actualErrors = node.GetDiagnostics(); 7832"];
7832 [label="actualErrors.Verify(expectedErrors); 7833"];
7833 [label="actualErrors.Verify(expectedErrors); 7834"];
7834 [label="actualErrors.Verify(expectedErrors) 7835"];
7835 [label="param Verify(this IEnumerable<Diagnostic> actual) 7836"];
7836 [label="param Verify(params DiagnosticDescription[] expected) 7837"];
7837 [label="Verify(actual, expected, errorCodeOnly: false); 7838"];
7838 [label="Verify(actual, expected, errorCodeOnly: false); 7839"];
7839 [label="Verify(actual, expected, errorCodeOnly: false); 7840"];
7840 [label="Verify(actual, expected, errorCodeOnly: false) 7841"];
7841 [label="param Verify(IEnumerable<Diagnostic> actual) 7842"];
7842 [label="param Verify(DiagnosticDescription[] expected) 7843"];
7843 [label="param Verify(bool errorCodeOnly) 7844"];
7844 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 7845"];
7845 [label="if (expected == null)\n            {\n                throw new ArgumentException('Must specify expected errors.', nameof(expected));\n            } 7846"];
7846 [label="var includeDefaultSeverity = expected.Any() && expected.All(e => e.DefaultSeverity != null); 7847"];
7847 [label="var includeEffectiveSeverity = expected.Any() && expected.All(e => e.EffectiveSeverity != null); 7848"];
7848 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 7849"];
7849 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 7850"];
7850 [label="var unmatched = actual.Select(d => new DiagnosticDescription(d, errorCodeOnly, includeDefaultSeverity, includeEffectiveSeverity))\n                                  .ToList(); 7851"];
7851 [label="foreach (var d in expected)\n            {\n                int index = unmatched.IndexOf(d);\n                if (index > -1)\n                {\n                    unmatched.RemoveAt(index);\n                }\n                else\n                {\n                    CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n                }\n            } 7852"];
7852 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 7853"];
7853 [label="if (unmatched.Count > 0)\n            {\n                CustomAssert.True(false, DiagnosticDescription.GetAssertText(expected, actual));\n            } 7854"];
7854 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 7855"];
7855 [label="{ } 7856"];
7856 [label="None = { } 7857"];
7857 [label="null 7858"];
7858 [label="Any = null 7859"];
7859 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 7860"];
7860 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 7861"];
7861 [label="DiagnosticDescription.GetAssertText(expected, actual) 7862"];
7862 [label="param GetAssertText(DiagnosticDescription[] expected) 7863"];
7863 [label="param GetAssertText(IEnumerable<Diagnostic> actual) 7864"];
7864 [label="const int CSharp = 1; 7865"];
7865 [label="const int VisualBasic = 2; 7866"];
7866 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 7867"];
7867 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 7868"];
7868 [label="actual.Any() && actual.First() is CSDiagnostic 7869"];
7869 [label="var language = actual.Any() && actual.First() is CSDiagnostic ? CSharp : VisualBasic; 7870"];
7870 [label="var includeDiagnosticMessagesAsComments = (language == CSharp); 7871"];
7871 [label="int indentDepth = (language == CSharp) ? 4 : 1; 7872"];
7872 [label="(language == CSharp) 7873"];
7873 [label="var includeDefaultSeverity = expected.Any() && expected.All(d => d.DefaultSeverity != null); 7874"];
7874 [label="var includeEffectiveSeverity = expected.Any() && expected.All(d => d.EffectiveSeverity != null); 7875"];
7875 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 7876"];
7876 [label="IsSortedOrEmpty(expected) 7877"];
7877 [label="param IsSortedOrEmpty(DiagnosticDescription[] diagnostics) 7878"];
7878 [label="new LinePositionComparer() 7879"];
7879 [label="param LinePositionComparer(this) 7880"];
7880 [label="Instance = new LinePositionComparer() 7881"];
7881 [label="var comparer = LinePositionComparer.Instance; 7882"];
7882 [label="DiagnosticDescription last = null; 7883"];
7883 [label="foreach (var diagnostic in diagnostics)\n            {\n                if (diagnostic._startPosition == null)\n                {\n                    return false;\n                }\n                if (last != null && comparer.Compare(last._startPosition, diagnostic._startPosition) > 0)\n                {\n                    return false;\n                }\n                last = diagnostic;\n            } 7884"];
7884 [label="return true; 7885"];
7885 [label="if (IsSortedOrEmpty(expected))\n            {\n                // If this is a new test (empty expectations) or a test that's already sorted,\n                // we sort the actual diagnostics to minimize diff noise as diagnostics change.\n                actual = Sort(actual);\n            } 7886"];
7886 [label="actual = Sort(actual); 7887"];
7887 [label="Sort(actual) 7888"];
7888 [label="param Sort(IEnumerable<Diagnostic> diagnostics) 7889"];
7889 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 7890"];
7890 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 7891"];
7891 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 7892"];
7892 [label="return diagnostics.OrderBy(d => d.Location.GetMappedLineSpan().StartLinePosition, LinePositionComparer.Instance); 7893"];
7893 [label="var assertText = new StringBuilder(); 7894"];
7894 [label="assertText.AppendLine(); 7895"];
7895 [label="int i; 7896"];
7896 [label="assertText.AppendLine('Expected:'); 7897"];
7897 [label="assertText.AppendLine('Expected:'); 7898"];
7898 [label="var expectedText = ArrayBuilder<string>.GetInstance(); 7899"];
7899 [label="foreach (var d in expected)\n            {\n                expectedText.Add(GetDiagnosticDescription(d, indentDepth));\n            } 7900"];
7900 [label="GetCommaSeparatedLines(assertText, expectedText); 7901"];
7901 [label="GetCommaSeparatedLines(assertText, expectedText); 7902"];
7902 [label="GetCommaSeparatedLines(assertText, expectedText) 7903"];
7903 [label="param GetCommaSeparatedLines(StringBuilder sb) 7904"];
7904 [label="param GetCommaSeparatedLines(ArrayBuilder<string> lines) 7905"];
7905 [label="int n = lines.Count; 7906"];
7906 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 7907"];
7907 [label="for (int i = 0; i < n; i++)\n            {\n                sb.Append(lines[i]);\n                if (i < n - 1)\n                {\n                    sb.Append(',');\n                }\n                sb.AppendLine();\n            } 7908"];
7908 [label="GetCommaSeparatedLines(assertText, expectedText); 7909"];
7909 [label="assertText.AppendLine('Actual:'); 7910"];
7910 [label="assertText.AppendLine('Actual:'); 7911"];
7911 [label="var actualText = ArrayBuilder<string>.GetInstance(); 7912"];
7912 [label="var e = actual.GetEnumerator(); 7913"];
7913 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 7914"];
7914 [label="for (i = 0; e.MoveNext(); i++)\n            {\n                Diagnostic d = e.Current;\n                string message = d.ToString();\n                if (Regex.Match(message, @'{\\d+}').Success)\n                {\n                    Assert.True(false, 'Diagnostic messages should never contain unsubstituted placeholders.\\n    ' + message);\n                }\n\n                if (i > 0)\n                {\n                    assertText.AppendLine(',');\n                }\n\n                if (includeDiagnosticMessagesAsComments)\n                {\n                    Indent(assertText, indentDepth);\n                    assertText.Append('// ');\n                    assertText.AppendLine(d.ToString());\n                    var l = d.Location;\n                    if (l.IsInSource)\n                    {\n                        Indent(assertText, indentDepth);\n                        assertText.Append('// ');\n                        assertText.AppendLine(l.SourceTree.GetText().Lines.GetLineFromPosition(l.SourceSpan.Start).ToString());\n                    }\n                }\n\n                var description = new DiagnosticDescription(d, errorCodeOnly: false, includeDefaultSeverity, includeEffectiveSeverity);\n                var diffDescription = description;\n                var idx = Array.IndexOf(expected, description);\n                if (idx != -1)\n                {\n                    diffDescription = expected[idx];\n                }\n                assertText.Append(GetDiagnosticDescription(description, indentDepth));\n                actualText.Add(GetDiagnosticDescription(diffDescription, indentDepth));\n            } 7915"];
7915 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 7916"];
7916 [label="if (i > 0)\n            {\n                assertText.AppendLine();\n            } 7917"];
7917 [label="assertText.AppendLine('Diff:'); 7918"];
7918 [label="assertText.AppendLine('Diff:'); 7919"];
7919 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 7920"];
7920 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 7921"];
7921 [label="new[] { '\\r', '\\n' } 7922"];
7922 [label="'\\r' 7923"];
7923 [label="'\\n' 7924"];
7924 [label="new[] { '\\r', '\\n' } 7925"];
7925 [label="new[] { '\\r', '\\n' } 7926"];
7926 [label="s_lineSplitChars = new[] { '\\r', '\\n' } 7927"];
7927 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 7928"];
7928 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 7929"];
7929 [label="DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine) 7930"];
7930 [label="param DiffReport(IEnumerable<T> expected) 7931"];
7931 [label="param DiffReport(IEnumerable<T> actual) 7932"];
7932 [label="param DiffReport(string separator) 7933"];
7933 [label="param DiffReport(IEqualityComparer<T> comparer = null) 7934"];
7934 [label="param DiffReport(Func<T, string> toString = null) 7935"];
7935 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 7936"];
7936 [label="var lcs = (comparer != null) ? new LCS<T>(comparer) : LCS<T>.Default; 7937"];
7937 [label="(comparer != null) 7938"];
7938 [label="EqualityComparer<T>.Default 7939"];
7939 [label="new LCS<T>(EqualityComparer<T>.Default) 7940"];
7940 [label="param LCS(IEqualityComparer<T> comparer) 7941"];
7941 [label="param LCS(this) 7942"];
7942 [label="1 7943"];
7943 [label="DeleteCost = 1 7944"];
7944 [label="1 7945"];
7945 [label="InsertCost = 1 7946"];
7946 [label="2 7947"];
7947 [label="UpdateCost = 2 7948"];
7948 [label="param LongestCommonSubsequence(this) 7949"];
7949 [label="_comparer 7950"];
7950 [label="_comparer 7951"];
7951 [label="Default = new LCS<T>(EqualityComparer<T>.Default) 7952"];
7952 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 7953"];
7953 [label="toString = toString ?? new Func<T, string>(obj => obj.ToString()); 7954"];
7954 [label="IList<T> expectedList = expected as IList<T> ?? new List<T>(expected); 7955"];
7955 [label="IList<T> actualList = actual as IList<T> ?? new List<T>(actual); 7956"];
7956 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 7957"];
7957 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 7958"];
7958 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 7959"];
7959 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 7960"];
7960 [label="lcs.CalculateDiff(expectedList, actualList, toString) 7961"];
7961 [label="param CalculateDiff(IList<T> sequenceA) 7962"];
7962 [label="param CalculateDiff(IList<T> sequenceB) 7963"];
7963 [label="param CalculateDiff(Func<T, string> toString) 7964"];
7964 [label="param CalculateDiff(this) 7965"];
7965 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 7966"];
7966 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 7967"];
7967 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 7968"];
7968 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 7969"];
7969 [label="GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count) 7970"];
7970 [label="param GetEdits(TSequence sequenceA) 7971"];
7971 [label="param GetEdits(int lengthA) 7972"];
7972 [label="param GetEdits(TSequence sequenceB) 7973"];
7973 [label="param GetEdits(int lengthB) 7974"];
7974 [label="param GetEdits(this) 7975"];
7975 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 7976"];
7976 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 7977"];
7977 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 7978"];
7978 [label="int[,] d = ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB); 7979"];
7979 [label="ComputeCostMatrix(sequenceA, lengthA, sequenceB, lengthB) 7980"];
7980 [label="param ComputeCostMatrix(TSequence sequenceA) 7981"];
7981 [label="param ComputeCostMatrix(int lengthA) 7982"];
7982 [label="param ComputeCostMatrix(TSequence sequenceB) 7983"];
7983 [label="param ComputeCostMatrix(int lengthB) 7984"];
7984 [label="param ComputeCostMatrix(this) 7985"];
7985 [label="var la = lengthA + 1; 7986"];
7986 [label="var la = lengthA + 1; 7987"];
7987 [label="var lb = lengthB + 1; 7988"];
7988 [label="var lb = lengthB + 1; 7989"];
7989 [label="var d = new int[la, lb]; 7990"];
7990 [label="d[0, 0] = 0; 7991"];
7991 [label="d[0, 0] 7992"];
7992 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 7993"];
7993 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    d[i, 0] = d[i - 1, 0] + DeleteCost;\n                } 7994"];
7994 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 7995"];
7995 [label="for (int j = 1; j <= lengthB; j++)\n                {\n                    d[0, j] = d[0, j - 1] + InsertCost;\n                } 7996"];
7996 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 7997"];
7997 [label="for (int i = 1; i <= lengthA; i++)\n                {\n                    for (int j = 1; j <= lengthB; j++)\n                    {\n                        int m1 = d[i - 1, j - 1] + (ItemsEqual(sequenceA, i - 1, sequenceB, j - 1) ? 0 : UpdateCost);\n                        int m2 = d[i - 1, j] + DeleteCost;\n                        int m3 = d[i, j - 1] + InsertCost;\n                        d[i, j] = Math.Min(Math.Min(m1, m2), m3);\n                    }\n                } 7998"];
7998 [label="return d; 7999"];
7999 [label="int i = lengthA; 8000"];
8000 [label="int j = lengthB; 8001"];
8001 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 8002"];
8002 [label="while (i != 0 && j != 0)\n                {\n                    if (d[i, j] == d[i - 1, j] + DeleteCost)\n                    {\n                        i--;\n                        yield return new Edit(EditKind.Delete, i, -1);\n                    }\n                    else if (d[i, j] == d[i, j - 1] + InsertCost)\n                    {\n                        j--;\n                        yield return new Edit(EditKind.Insert, -1, j);\n                    }\n                    else\n                    {\n                        i--;\n                        j--;\n                        yield return new Edit(EditKind.Update, i, j);\n                    }\n                } 8003"];
8003 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 8004"];
8004 [label="while (i > 0)\n                {\n                    i--;\n                    yield return new Edit(EditKind.Delete, i, -1);\n                } 8005"];
8005 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 8006"];
8006 [label="while (j > 0)\n                {\n                    j--;\n                    yield return new Edit(EditKind.Insert, -1, j);\n                } 8007"];
8007 [label="param GetEdits(this) 8008"];
8008 [label="foreach (var edit in GetEdits(sequenceA, sequenceA.Count, sequenceB, sequenceB.Count).Reverse())\n                {\n                    switch (edit.Kind)\n                    {\n                        case EditKind.Delete:\n                            yield return '--> ' + toString(sequenceA[edit.IndexA]);\n                            break;\n\n                        case EditKind.Insert:\n                            yield return '++> ' + toString(sequenceB[edit.IndexB]);\n                            break;\n\n                        case EditKind.Update:\n                            yield return '    ' + toString(sequenceB[edit.IndexB]);\n                            break;\n                    }\n                } 8009"];
8009 [label="param CalculateDiff(this) 8010"];
8010 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 8011"];
8011 [label="return string.Join(separator, lcs.CalculateDiff(expectedList, actualList, toString)); 8012"];
8012 [label="assertText.Append(DiffUtil.DiffReport(expectedText, actualText, separator: Environment.NewLine)); 8013"];
8013 [label="actualText.Free(); 8014"];
8014 [label="expectedText.Free(); 8015"];
8015 [label="return assertText.ToString(); 8016"];
8016 [label="CustomAssert.True(true, DiagnosticDescription.GetAssertText(expected, actual)); 8017"];
8017 [label="actualErrors.Verify(expectedErrors); 8018"];
8018 [label="UsingNode(node); 8019"];
8019 [label="UsingNode(node) 8020"];
8020 [label="param UsingNode(CSharpSyntaxNode root) 8021"];
8021 [label="param UsingNode(this) 8022"];
8022 [label="VerifyEnumeratorConsumed() 8023"];
8023 [label="param VerifyEnumeratorConsumed(this) 8024"];
8024 [label="if (_treeEnumerator != null)\n            {\n                var hasNext = _treeEnumerator.MoveNext();\n                if (hasNext)\n                {\n                    DumpAndCleanup();\n                    CustomAssert.False(hasNext, 'Test contains unconsumed syntax left over from UsingNode()');\n                }\n            } 8025"];
8025 [label="if (_treeEnumerator != null)\n            {\n                var hasNext = _treeEnumerator.MoveNext();\n                if (hasNext)\n                {\n                    DumpAndCleanup();\n                    CustomAssert.False(hasNext, 'Test contains unconsumed syntax left over from UsingNode()');\n                }\n            } 8026"];
8026 [label="VerifyEnumeratorConsumed(); 8027"];
8027 [label="_node 8028"];
8028 [label="var nodes = EnumerateNodes(root, dump: false); 8029"];
8029 [label="var nodes = EnumerateNodes(root, dump: false); 8030"];
8030 [label="EnumerateNodes(root, dump: false) 8031"];
8031 [label="param EnumerateNodes(CSharpSyntaxNode node) 8032"];
8032 [label="param EnumerateNodes(bool dump) 8033"];
8033 [label="param EnumerateNodes(this) 8034"];
8034 [label="Print(node, dump); 8035"];
8035 [label="Print(node, dump); 8036"];
8036 [label="Print(node, dump); 8037"];
8037 [label="yield return node; 8038"];
8038 [label="yield return node; 8039"];
8039 [label="var stack = new Stack<ChildSyntaxList.Enumerator>(24); 8040"];
8040 [label="stack.Push(node.ChildNodesAndTokens().GetEnumerator()); 8041"];
8041 [label="stack.Push(node.ChildNodesAndTokens().GetEnumerator()); 8042"];
8042 [label="Open(dump); 8043"];
8043 [label="Open(dump) 8044"];
8044 [label="param Open(bool dump) 8045"];
8045 [label="param Open(this) 8046"];
8046 [label="if (dump)\n            {\n                _output.WriteLine('{');\n            } 8047"];
8047 [label="Open(dump); 8048"];
8048 [label="while (stack.Count > 0)\n            {\n                var en = stack.Pop();\n                if (!en.MoveNext())\n                {\n                    // no more down this branch\n                    Close(dump);\n                    continue;\n                }\n\n                var current = en.Current;\n                stack.Push(en); // put it back on stack (struct enumerator)\n\n                Print(current, dump);\n                yield return current;\n\n                if (current.IsNode)\n                {\n                    // not token, so consider children\n                    stack.Push(current.ChildNodesAndTokens().GetEnumerator());\n                    Open(dump);\n                    continue;\n                }\n            } 8049"];
8049 [label="while (stack.Count > 0)\n            {\n                var en = stack.Pop();\n                if (!en.MoveNext())\n                {\n                    // no more down this branch\n                    Close(dump);\n                    continue;\n                }\n\n                var current = en.Current;\n                stack.Push(en); // put it back on stack (struct enumerator)\n\n                Print(current, dump);\n                yield return current;\n\n                if (current.IsNode)\n                {\n                    // not token, so consider children\n                    stack.Push(current.ChildNodesAndTokens().GetEnumerator());\n                    Open(dump);\n                    continue;\n                }\n            } 8050"];
8050 [label="var en = stack.Pop(); 8051"];
8051 [label="if (!en.MoveNext())\n                {\n                    // no more down this branch\n                    Close(dump);\n                    continue;\n                } 8052"];
8052 [label="var current = en.Current; 8053"];
8053 [label="en.Current 8054"];
8054 [label="param CSharpSyntaxNode(GreenNode green) 8055"];
8055 [label="param CSharpSyntaxNode(SyntaxNode? parent) 8056"];
8056 [label="param CSharpSyntaxNode(int position) 8057"];
8057 [label="param CSharpSyntaxNode(this) 8058"];
8058 [label="stack.Push(en); 8059"];
8059 [label="stack.Push(en); 8060"];
8060 [label="Print(current, dump); 8061"];
8061 [label="Print(current, dump); 8062"];
8062 [label="Print(current, dump); 8063"];
8063 [label="yield return node; 8064"];
8064 [label="if (current.IsNode)\n                {\n                    // not token, so consider children\n                    stack.Push(current.ChildNodesAndTokens().GetEnumerator());\n                    Open(dump);\n                    continue;\n                } 8065"];
8065 [label="stack.Push(current.ChildNodesAndTokens().GetEnumerator()); 8066"];
8066 [label="Open(dump); 8067"];
8067 [label="Open(dump) 8068"];
8068 [label="param Open(bool dump) 8069"];
8069 [label="param Open(this) 8070"];
8070 [label="if (dump)\n            {\n                _output.WriteLine('{');\n            } 8071"];
8071 [label="Open(dump); 8072"];
8072 [label="yield return node; 8073"];
8073 [label="Open(dump); 8074"];
8074 [label="Open(dump) 8075"];
8075 [label="param Open(bool dump) 8076"];
8076 [label="param Open(this) 8077"];
8077 [label="if (dump)\n            {\n                _output.WriteLine('{');\n            } 8078"];
8078 [label="Open(dump); 8079"];
8079 [label="=> true 8080"];
8080 [label="Close(dump); 8081"];
8081 [label="Close(dump) 8082"];
8082 [label="param Close(bool dump) 8083"];
8083 [label="param Close(this) 8084"];
8084 [label="if (dump)\n            {\n                _output.WriteLine('}');\n            } 8085"];
8085 [label="Close(dump); 8086"];
8086 [label="Done(dump); 8087"];
8087 [label="Done(dump) 8088"];
8088 [label="param Done(bool dump) 8089"];
8089 [label="param Done(this) 8090"];
8090 [label="if (dump)\n            {\n                _output.WriteLine('EOF();');\n            } 8091"];
8091 [label="Done(dump); 8092"];
8092 [label="var nodes = EnumerateNodes(root, dump: false); 8093"];
8093 [label="_treeEnumerator = nodes.GetEnumerator(); 8094"];
8094 [label="_treeEnumerator 8095"];
8095 [label="UsingNode(node); 8096"];
8096 [label="N(SyntaxKind.ExpressionStatement); 8097"];
8097 [label="N(SyntaxKind.ExpressionStatement); 8098"];
8098 [label="N(SyntaxKind.ExpressionStatement) 8099"];
8099 [label="param N(SyntaxKind kind) 8100"];
8100 [label="param N(string? value = null) 8101"];
8101 [label="param N(this) 8102"];
8102 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8103"];
8103 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8104"];
8104 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8105"];
8105 [label="_treeEnumerator.Current 8106"];
8106 [label="param Kind(this SyntaxNodeOrToken nodeOrToken) 8107"];
8107 [label="var rawKind = nodeOrToken.RawKind; 8108"];
8108 [label="return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None; 8109"];
8109 [label="IsCSharpKind(rawKind) 8110"];
8110 [label="param IsCSharpKind(int rawKind) 8111"];
8111 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8112"];
8112 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8113"];
8113 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8114"];
8114 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8115"];
8115 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8116"];
8116 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8117"];
8117 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8118"];
8118 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8119"];
8119 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8120"];
8120 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8121"];
8121 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8122"];
8122 [label="return _treeEnumerator.Current; 8123"];
8123 [label="N(SyntaxKind.ExpressionStatement); 8124"];
8124 [label="N(SyntaxKind.SimpleAssignmentExpression); 8125"];
8125 [label="N(SyntaxKind.SimpleAssignmentExpression); 8126"];
8126 [label="N(SyntaxKind.SimpleAssignmentExpression) 8127"];
8127 [label="param N(SyntaxKind kind) 8128"];
8128 [label="param N(string? value = null) 8129"];
8129 [label="param N(this) 8130"];
8130 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8131"];
8131 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8132"];
8132 [label="_treeEnumerator.Current 8133"];
8133 [label="IsCSharpKind(rawKind) 8134"];
8134 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8135"];
8135 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8136"];
8136 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8137"];
8137 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8138"];
8138 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8139"];
8139 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8140"];
8140 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8141"];
8141 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8142"];
8142 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8143"];
8143 [label="return _treeEnumerator.Current; 8144"];
8144 [label="N(SyntaxKind.SimpleAssignmentExpression); 8145"];
8145 [label="N(SyntaxKind.IdentifierName); 8146"];
8146 [label="N(SyntaxKind.IdentifierName); 8147"];
8147 [label="N(SyntaxKind.IdentifierName) 8148"];
8148 [label="param N(SyntaxKind kind) 8149"];
8149 [label="param N(string? value = null) 8150"];
8150 [label="param N(this) 8151"];
8151 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8152"];
8152 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8153"];
8153 [label="_treeEnumerator.Current 8154"];
8154 [label="IsCSharpKind(rawKind) 8155"];
8155 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8156"];
8156 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8157"];
8157 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8158"];
8158 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8159"];
8159 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8160"];
8160 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8161"];
8161 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8162"];
8162 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8163"];
8163 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8164"];
8164 [label="return _treeEnumerator.Current; 8165"];
8165 [label="N(SyntaxKind.IdentifierName); 8166"];
8166 [label="N(SyntaxKind.IdentifierToken, '_'); 8167"];
8167 [label="N(SyntaxKind.IdentifierToken, '_'); 8168"];
8168 [label="N(SyntaxKind.IdentifierToken, '_') 8169"];
8169 [label="param N(SyntaxKind kind) 8170"];
8170 [label="param N(string? value = null) 8171"];
8171 [label="param N(this) 8172"];
8172 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8173"];
8173 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8174"];
8174 [label="_treeEnumerator.Current 8175"];
8175 [label="IsCSharpKind(rawKind) 8176"];
8176 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8177"];
8177 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8178"];
8178 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8179"];
8179 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8180"];
8180 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8181"];
8181 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8182"];
8182 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8183"];
8183 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8184"];
8184 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8185"];
8185 [label="_treeEnumerator.Current 8186"];
8186 [label="param ToString(this) 8187"];
8187 [label="this.Text 8188"];
8188 [label="get { return this.TextField; } 8189"];
8189 [label="return this.Text; 8190"];
8190 [label="CustomAssert.Equal(_treeEnumerator.Current.ToString(), value); 8191"];
8191 [label="CustomAssert.Equal(_treeEnumerator.Current.ToString(), value); 8192"];
8192 [label="return _treeEnumerator.Current; 8193"];
8193 [label="N(SyntaxKind.EqualsToken); 8194"];
8194 [label="N(SyntaxKind.EqualsToken); 8195"];
8195 [label="N(SyntaxKind.EqualsToken) 8196"];
8196 [label="param N(SyntaxKind kind) 8197"];
8197 [label="param N(string? value = null) 8198"];
8198 [label="param N(this) 8199"];
8199 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8200"];
8200 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8201"];
8201 [label="_treeEnumerator.Current 8202"];
8202 [label="IsCSharpKind(rawKind) 8203"];
8203 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8204"];
8204 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8205"];
8205 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8206"];
8206 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8207"];
8207 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8208"];
8208 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8209"];
8209 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8210"];
8210 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8211"];
8211 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8212"];
8212 [label="return _treeEnumerator.Current; 8213"];
8213 [label="N(SyntaxKind.EqualsToken); 8214"];
8214 [label="N(SyntaxKind.ObjectCreationExpression); 8215"];
8215 [label="N(SyntaxKind.ObjectCreationExpression); 8216"];
8216 [label="N(SyntaxKind.ObjectCreationExpression) 8217"];
8217 [label="param N(SyntaxKind kind) 8218"];
8218 [label="param N(string? value = null) 8219"];
8219 [label="param N(this) 8220"];
8220 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8221"];
8221 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8222"];
8222 [label="_treeEnumerator.Current 8223"];
8223 [label="IsCSharpKind(rawKind) 8224"];
8224 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8225"];
8225 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8226"];
8226 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8227"];
8227 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8228"];
8228 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8229"];
8229 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8230"];
8230 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8231"];
8231 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8232"];
8232 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8233"];
8233 [label="return _treeEnumerator.Current; 8234"];
8234 [label="N(SyntaxKind.ObjectCreationExpression); 8235"];
8235 [label="N(SyntaxKind.NewKeyword); 8236"];
8236 [label="N(SyntaxKind.NewKeyword); 8237"];
8237 [label="N(SyntaxKind.NewKeyword) 8238"];
8238 [label="param N(SyntaxKind kind) 8239"];
8239 [label="param N(string? value = null) 8240"];
8240 [label="param N(this) 8241"];
8241 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8242"];
8242 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8243"];
8243 [label="_treeEnumerator.Current 8244"];
8244 [label="IsCSharpKind(rawKind) 8245"];
8245 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8246"];
8246 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8247"];
8247 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8248"];
8248 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8249"];
8249 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8250"];
8250 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8251"];
8251 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8252"];
8252 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8253"];
8253 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8254"];
8254 [label="return _treeEnumerator.Current; 8255"];
8255 [label="N(SyntaxKind.NewKeyword); 8256"];
8256 [label="N(SyntaxKind.NullableType); 8257"];
8257 [label="N(SyntaxKind.NullableType); 8258"];
8258 [label="N(SyntaxKind.NullableType) 8259"];
8259 [label="param N(SyntaxKind kind) 8260"];
8260 [label="param N(string? value = null) 8261"];
8261 [label="param N(this) 8262"];
8262 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8263"];
8263 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8264"];
8264 [label="_treeEnumerator.Current 8265"];
8265 [label="IsCSharpKind(rawKind) 8266"];
8266 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8267"];
8267 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8268"];
8268 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8269"];
8269 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8270"];
8270 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8271"];
8271 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8272"];
8272 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8273"];
8273 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8274"];
8274 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8275"];
8275 [label="return _treeEnumerator.Current; 8276"];
8276 [label="N(SyntaxKind.NullableType); 8277"];
8277 [label="N(SyntaxKind.TupleType); 8278"];
8278 [label="N(SyntaxKind.TupleType); 8279"];
8279 [label="N(SyntaxKind.TupleType) 8280"];
8280 [label="param N(SyntaxKind kind) 8281"];
8281 [label="param N(string? value = null) 8282"];
8282 [label="param N(this) 8283"];
8283 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8284"];
8284 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8285"];
8285 [label="_treeEnumerator.Current 8286"];
8286 [label="IsCSharpKind(rawKind) 8287"];
8287 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8288"];
8288 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8289"];
8289 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8290"];
8290 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8291"];
8291 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8292"];
8292 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8293"];
8293 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8294"];
8294 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8295"];
8295 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8296"];
8296 [label="return _treeEnumerator.Current; 8297"];
8297 [label="N(SyntaxKind.TupleType); 8298"];
8298 [label="N(SyntaxKind.OpenParenToken); 8299"];
8299 [label="N(SyntaxKind.OpenParenToken); 8300"];
8300 [label="N(SyntaxKind.OpenParenToken) 8301"];
8301 [label="param N(SyntaxKind kind) 8302"];
8302 [label="param N(string? value = null) 8303"];
8303 [label="param N(this) 8304"];
8304 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8305"];
8305 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8306"];
8306 [label="_treeEnumerator.Current 8307"];
8307 [label="IsCSharpKind(rawKind) 8308"];
8308 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8309"];
8309 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8310"];
8310 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8311"];
8311 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8312"];
8312 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8313"];
8313 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8314"];
8314 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8315"];
8315 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8316"];
8316 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8317"];
8317 [label="return _treeEnumerator.Current; 8318"];
8318 [label="N(SyntaxKind.OpenParenToken); 8319"];
8319 [label="N(SyntaxKind.TupleElement); 8320"];
8320 [label="N(SyntaxKind.TupleElement); 8321"];
8321 [label="N(SyntaxKind.TupleElement) 8322"];
8322 [label="param N(SyntaxKind kind) 8323"];
8323 [label="param N(string? value = null) 8324"];
8324 [label="param N(this) 8325"];
8325 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8326"];
8326 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8327"];
8327 [label="_treeEnumerator.Current 8328"];
8328 [label="IsCSharpKind(rawKind) 8329"];
8329 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8330"];
8330 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8331"];
8331 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8332"];
8332 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8333"];
8333 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8334"];
8334 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8335"];
8335 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8336"];
8336 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8337"];
8337 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8338"];
8338 [label="return _treeEnumerator.Current; 8339"];
8339 [label="N(SyntaxKind.TupleElement); 8340"];
8340 [label="N(SyntaxKind.PredefinedType); 8341"];
8341 [label="N(SyntaxKind.PredefinedType); 8342"];
8342 [label="N(SyntaxKind.PredefinedType) 8343"];
8343 [label="param N(SyntaxKind kind) 8344"];
8344 [label="param N(string? value = null) 8345"];
8345 [label="param N(this) 8346"];
8346 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8347"];
8347 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8348"];
8348 [label="_treeEnumerator.Current 8349"];
8349 [label="IsCSharpKind(rawKind) 8350"];
8350 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8351"];
8351 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8352"];
8352 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8353"];
8353 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8354"];
8354 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8355"];
8355 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8356"];
8356 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8357"];
8357 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8358"];
8358 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8359"];
8359 [label="return _treeEnumerator.Current; 8360"];
8360 [label="N(SyntaxKind.PredefinedType); 8361"];
8361 [label="N(SyntaxKind.IntKeyword); 8362"];
8362 [label="N(SyntaxKind.IntKeyword); 8363"];
8363 [label="N(SyntaxKind.IntKeyword) 8364"];
8364 [label="param N(SyntaxKind kind) 8365"];
8365 [label="param N(string? value = null) 8366"];
8366 [label="param N(this) 8367"];
8367 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8368"];
8368 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8369"];
8369 [label="_treeEnumerator.Current 8370"];
8370 [label="IsCSharpKind(rawKind) 8371"];
8371 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8372"];
8372 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8373"];
8373 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8374"];
8374 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8375"];
8375 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8376"];
8376 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8377"];
8377 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8378"];
8378 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8379"];
8379 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8380"];
8380 [label="return _treeEnumerator.Current; 8381"];
8381 [label="N(SyntaxKind.IntKeyword); 8382"];
8382 [label="N(SyntaxKind.CommaToken); 8383"];
8383 [label="N(SyntaxKind.CommaToken); 8384"];
8384 [label="N(SyntaxKind.CommaToken) 8385"];
8385 [label="param N(SyntaxKind kind) 8386"];
8386 [label="param N(string? value = null) 8387"];
8387 [label="param N(this) 8388"];
8388 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8389"];
8389 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8390"];
8390 [label="_treeEnumerator.Current 8391"];
8391 [label="IsCSharpKind(rawKind) 8392"];
8392 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8393"];
8393 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8394"];
8394 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8395"];
8395 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8396"];
8396 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8397"];
8397 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8398"];
8398 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8399"];
8399 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8400"];
8400 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8401"];
8401 [label="return _treeEnumerator.Current; 8402"];
8402 [label="N(SyntaxKind.CommaToken); 8403"];
8403 [label="N(SyntaxKind.TupleElement); 8404"];
8404 [label="N(SyntaxKind.TupleElement); 8405"];
8405 [label="N(SyntaxKind.TupleElement) 8406"];
8406 [label="param N(SyntaxKind kind) 8407"];
8407 [label="param N(string? value = null) 8408"];
8408 [label="param N(this) 8409"];
8409 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8410"];
8410 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8411"];
8411 [label="_treeEnumerator.Current 8412"];
8412 [label="IsCSharpKind(rawKind) 8413"];
8413 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8414"];
8414 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8415"];
8415 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8416"];
8416 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8417"];
8417 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8418"];
8418 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8419"];
8419 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8420"];
8420 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8421"];
8421 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8422"];
8422 [label="return _treeEnumerator.Current; 8423"];
8423 [label="N(SyntaxKind.TupleElement); 8424"];
8424 [label="N(SyntaxKind.PredefinedType); 8425"];
8425 [label="N(SyntaxKind.PredefinedType); 8426"];
8426 [label="N(SyntaxKind.PredefinedType) 8427"];
8427 [label="param N(SyntaxKind kind) 8428"];
8428 [label="param N(string? value = null) 8429"];
8429 [label="param N(this) 8430"];
8430 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8431"];
8431 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8432"];
8432 [label="_treeEnumerator.Current 8433"];
8433 [label="IsCSharpKind(rawKind) 8434"];
8434 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8435"];
8435 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8436"];
8436 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8437"];
8437 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8438"];
8438 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8439"];
8439 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8440"];
8440 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8441"];
8441 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8442"];
8442 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8443"];
8443 [label="return _treeEnumerator.Current; 8444"];
8444 [label="N(SyntaxKind.PredefinedType); 8445"];
8445 [label="N(SyntaxKind.IntKeyword); 8446"];
8446 [label="N(SyntaxKind.IntKeyword); 8447"];
8447 [label="N(SyntaxKind.IntKeyword) 8448"];
8448 [label="param N(SyntaxKind kind) 8449"];
8449 [label="param N(string? value = null) 8450"];
8450 [label="param N(this) 8451"];
8451 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8452"];
8452 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8453"];
8453 [label="_treeEnumerator.Current 8454"];
8454 [label="IsCSharpKind(rawKind) 8455"];
8455 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8456"];
8456 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8457"];
8457 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8458"];
8458 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8459"];
8459 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8460"];
8460 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8461"];
8461 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8462"];
8462 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8463"];
8463 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8464"];
8464 [label="return _treeEnumerator.Current; 8465"];
8465 [label="N(SyntaxKind.IntKeyword); 8466"];
8466 [label="N(SyntaxKind.CloseParenToken); 8467"];
8467 [label="N(SyntaxKind.CloseParenToken); 8468"];
8468 [label="N(SyntaxKind.CloseParenToken) 8469"];
8469 [label="param N(SyntaxKind kind) 8470"];
8470 [label="param N(string? value = null) 8471"];
8471 [label="param N(this) 8472"];
8472 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8473"];
8473 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8474"];
8474 [label="_treeEnumerator.Current 8475"];
8475 [label="IsCSharpKind(rawKind) 8476"];
8476 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8477"];
8477 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8478"];
8478 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8479"];
8479 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8480"];
8480 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8481"];
8481 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8482"];
8482 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8483"];
8483 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8484"];
8484 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8485"];
8485 [label="return _treeEnumerator.Current; 8486"];
8486 [label="N(SyntaxKind.CloseParenToken); 8487"];
8487 [label="N(SyntaxKind.QuestionToken); 8488"];
8488 [label="N(SyntaxKind.QuestionToken); 8489"];
8489 [label="N(SyntaxKind.QuestionToken) 8490"];
8490 [label="param N(SyntaxKind kind) 8491"];
8491 [label="param N(string? value = null) 8492"];
8492 [label="param N(this) 8493"];
8493 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8494"];
8494 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8495"];
8495 [label="_treeEnumerator.Current 8496"];
8496 [label="IsCSharpKind(rawKind) 8497"];
8497 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8498"];
8498 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8499"];
8499 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8500"];
8500 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8501"];
8501 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8502"];
8502 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8503"];
8503 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8504"];
8504 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8505"];
8505 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8506"];
8506 [label="return _treeEnumerator.Current; 8507"];
8507 [label="N(SyntaxKind.QuestionToken); 8508"];
8508 [label="N(SyntaxKind.ObjectInitializerExpression); 8509"];
8509 [label="N(SyntaxKind.ObjectInitializerExpression); 8510"];
8510 [label="N(SyntaxKind.ObjectInitializerExpression) 8511"];
8511 [label="param N(SyntaxKind kind) 8512"];
8512 [label="param N(string? value = null) 8513"];
8513 [label="param N(this) 8514"];
8514 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8515"];
8515 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8516"];
8516 [label="_treeEnumerator.Current 8517"];
8517 [label="IsCSharpKind(rawKind) 8518"];
8518 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8519"];
8519 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8520"];
8520 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8521"];
8521 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8522"];
8522 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8523"];
8523 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8524"];
8524 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8525"];
8525 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8526"];
8526 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8527"];
8527 [label="return _treeEnumerator.Current; 8528"];
8528 [label="N(SyntaxKind.ObjectInitializerExpression); 8529"];
8529 [label="N(SyntaxKind.OpenBraceToken); 8530"];
8530 [label="N(SyntaxKind.OpenBraceToken); 8531"];
8531 [label="N(SyntaxKind.OpenBraceToken) 8532"];
8532 [label="param N(SyntaxKind kind) 8533"];
8533 [label="param N(string? value = null) 8534"];
8534 [label="param N(this) 8535"];
8535 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8536"];
8536 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8537"];
8537 [label="_treeEnumerator.Current 8538"];
8538 [label="IsCSharpKind(rawKind) 8539"];
8539 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8540"];
8540 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8541"];
8541 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8542"];
8542 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8543"];
8543 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8544"];
8544 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8545"];
8545 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8546"];
8546 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8547"];
8547 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8548"];
8548 [label="return _treeEnumerator.Current; 8549"];
8549 [label="N(SyntaxKind.OpenBraceToken); 8550"];
8550 [label="N(SyntaxKind.CloseBraceToken); 8551"];
8551 [label="N(SyntaxKind.CloseBraceToken); 8552"];
8552 [label="N(SyntaxKind.CloseBraceToken) 8553"];
8553 [label="param N(SyntaxKind kind) 8554"];
8554 [label="param N(string? value = null) 8555"];
8555 [label="param N(this) 8556"];
8556 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8557"];
8557 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8558"];
8558 [label="_treeEnumerator.Current 8559"];
8559 [label="IsCSharpKind(rawKind) 8560"];
8560 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8561"];
8561 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8562"];
8562 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8563"];
8563 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8564"];
8564 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8565"];
8565 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8566"];
8566 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8567"];
8567 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8568"];
8568 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8569"];
8569 [label="return _treeEnumerator.Current; 8570"];
8570 [label="N(SyntaxKind.CloseBraceToken); 8571"];
8571 [label="N(SyntaxKind.SemicolonToken); 8572"];
8572 [label="N(SyntaxKind.SemicolonToken); 8573"];
8573 [label="N(SyntaxKind.SemicolonToken) 8574"];
8574 [label="param N(SyntaxKind kind) 8575"];
8575 [label="param N(string? value = null) 8576"];
8576 [label="param N(this) 8577"];
8577 [label="CustomAssert.True(_treeEnumerator!.MoveNext()); 8578"];
8578 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8579"];
8579 [label="_treeEnumerator.Current 8580"];
8580 [label="IsCSharpKind(rawKind) 8581"];
8581 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 8582"];
8582 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 8583"];
8583 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8584"];
8584 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8585"];
8585 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 8586"];
8586 [label="CustomAssert.Equal(kind, _treeEnumerator.Current.Kind()); 8587"];
8587 [label="CustomAssert.False(_treeEnumerator.Current.IsMissing); 8588"];
8588 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8589"];
8589 [label="if (value != null)\n                {\n                    CustomAssert.Equal(_treeEnumerator.Current.ToString(), value);\n                } 8590"];
8590 [label="return _treeEnumerator.Current; 8591"];
8591 [label="N(SyntaxKind.SemicolonToken); 8592"];
8592 [label="EOF() 8593"];
8593 [label="param EOF(this) 8594"];
8594 [label="if (_treeEnumerator!.MoveNext())\n            {\n                var tk = _treeEnumerator.Current.Kind();\n                DumpAndCleanup();\n                CustomAssert.False(true, 'Found unexpected node or token of kind: ' + tk);\n            } 8595"];
8595 [label="EOF(); 8596"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 1;
192 -> 1;
193 -> 191;
193 -> 1;
194 -> 193;
194 -> 192;
195 -> 192;
196 -> 195;
197 -> 196;
198 -> 197;
199 -> 198;
199 -> 197;
200 -> 195;
200 -> 192;
201 -> 195;
201 -> 192;
202 -> 195;
202 -> 192;
203 -> 194;
203 -> 195;
203 -> 192;
204 -> 1;
204 -> 2;
204 -> 199;
204 -> 200;
204 -> 201;
204 -> 203;
205 -> 1;
206 -> 1;
207 -> 1;
208 -> 206;
208 -> 207;
209 -> 206;
209 -> 207;
210 -> 205;
210 -> 207;
211 -> 208;
211 -> 207;
212 -> 207;
213 -> 209;
213 -> 207;
214 -> 207;
215 -> 211;
215 -> 214;
216 -> 212;
216 -> 214;
217 -> 213;
217 -> 214;
218 -> 210;
218 -> 214;
220 -> 219;
221 -> 220;
223 -> 221;
223 -> 222;
224 -> 222;
225 -> 222;
226 -> 223;
226 -> 222;
227 -> 224;
227 -> 226;
228 -> 0;
228 -> 227;
229 -> 222;
230 -> 228;
230 -> 229;
230 -> 222;
232 -> 0;
232 -> 222;
233 -> 223;
233 -> 222;
234 -> 222;
235 -> 232;
235 -> 234;
236 -> 233;
236 -> 234;
237 -> 235;
237 -> 234;
238 -> 236;
238 -> 234;
239 -> 234;
240 -> 234;
241 -> 237;
241 -> 240;
242 -> 238;
242 -> 240;
243 -> 239;
243 -> 240;
244 -> 239;
244 -> 240;
245 -> 239;
245 -> 240;
246 -> 241;
246 -> 240;
247 -> 243;
247 -> 240;
248 -> 244;
248 -> 240;
250 -> 249;
251 -> 242;
251 -> 240;
252 -> 240;
253 -> 246;
253 -> 252;
254 -> 247;
254 -> 252;
255 -> 248;
255 -> 252;
256 -> 251;
256 -> 252;
257 -> 245;
257 -> 252;
258 -> 253;
258 -> 252;
259 -> 254;
259 -> 252;
260 -> 255;
260 -> 252;
261 -> 256;
261 -> 252;
262 -> 252;
263 -> 262;
263 -> 258;
263 -> 259;
263 -> 260;
263 -> 261;
263 -> 252;
264 -> 262;
264 -> 252;
265 -> 264;
265 -> 263;
265 -> 252;
266 -> 245;
266 -> 240;
267 -> 242;
267 -> 245;
267 -> 240;
268 -> 241;
268 -> 0;
268 -> 240;
269 -> 239;
269 -> 222;
270 -> 224;
270 -> 222;
271 -> 269;
271 -> 270;
272 -> 271;
275 -> 273;
275 -> 274;
276 -> 274;
277 -> 274;
278 -> 275;
278 -> 274;
279 -> 276;
279 -> 278;
280 -> 0;
280 -> 279;
281 -> 274;
282 -> 280;
282 -> 281;
282 -> 274;
283 -> 0;
283 -> 274;
284 -> 275;
284 -> 274;
285 -> 274;
286 -> 283;
286 -> 285;
287 -> 284;
287 -> 285;
288 -> 286;
288 -> 285;
289 -> 287;
289 -> 285;
290 -> 285;
291 -> 285;
292 -> 288;
292 -> 291;
293 -> 289;
293 -> 291;
294 -> 290;
294 -> 291;
295 -> 290;
295 -> 291;
296 -> 290;
296 -> 291;
297 -> 292;
297 -> 291;
298 -> 294;
298 -> 291;
299 -> 295;
299 -> 291;
300 -> 293;
300 -> 291;
301 -> 291;
302 -> 297;
302 -> 301;
303 -> 298;
303 -> 301;
304 -> 299;
304 -> 301;
305 -> 300;
305 -> 301;
306 -> 296;
306 -> 301;
307 -> 302;
307 -> 301;
308 -> 303;
308 -> 301;
309 -> 304;
309 -> 301;
310 -> 305;
310 -> 301;
311 -> 301;
312 -> 311;
312 -> 307;
312 -> 308;
312 -> 309;
312 -> 310;
312 -> 301;
313 -> 311;
313 -> 301;
314 -> 313;
314 -> 312;
314 -> 301;
315 -> 296;
315 -> 291;
316 -> 293;
316 -> 296;
316 -> 291;
317 -> 292;
317 -> 0;
317 -> 291;
318 -> 290;
318 -> 274;
319 -> 276;
319 -> 274;
320 -> 318;
320 -> 319;
321 -> 320;
324 -> 322;
324 -> 323;
325 -> 323;
326 -> 323;
327 -> 324;
327 -> 323;
328 -> 325;
328 -> 327;
329 -> 0;
329 -> 328;
330 -> 323;
331 -> 329;
331 -> 330;
331 -> 323;
332 -> 0;
332 -> 323;
333 -> 324;
333 -> 323;
334 -> 323;
335 -> 332;
335 -> 334;
336 -> 333;
336 -> 334;
337 -> 335;
337 -> 334;
338 -> 336;
338 -> 334;
339 -> 334;
340 -> 334;
341 -> 337;
341 -> 340;
342 -> 338;
342 -> 340;
343 -> 339;
343 -> 340;
344 -> 339;
344 -> 340;
345 -> 339;
345 -> 340;
346 -> 341;
346 -> 340;
347 -> 343;
347 -> 340;
348 -> 344;
348 -> 340;
349 -> 342;
349 -> 340;
350 -> 340;
351 -> 346;
351 -> 350;
352 -> 347;
352 -> 350;
353 -> 348;
353 -> 350;
354 -> 349;
354 -> 350;
355 -> 345;
355 -> 350;
356 -> 351;
356 -> 350;
357 -> 352;
357 -> 350;
358 -> 353;
358 -> 350;
359 -> 354;
359 -> 350;
360 -> 350;
361 -> 360;
361 -> 356;
361 -> 357;
361 -> 358;
361 -> 359;
361 -> 350;
362 -> 360;
362 -> 350;
363 -> 362;
363 -> 361;
363 -> 350;
364 -> 345;
364 -> 340;
365 -> 342;
365 -> 345;
365 -> 340;
366 -> 341;
366 -> 0;
366 -> 340;
367 -> 339;
367 -> 323;
368 -> 325;
368 -> 323;
369 -> 367;
369 -> 368;
370 -> 369;
373 -> 371;
373 -> 372;
374 -> 372;
375 -> 0;
375 -> 372;
376 -> 373;
376 -> 372;
377 -> 372;
378 -> 375;
378 -> 377;
379 -> 376;
379 -> 377;
380 -> 378;
380 -> 377;
381 -> 379;
381 -> 377;
382 -> 377;
383 -> 377;
384 -> 380;
384 -> 383;
385 -> 381;
385 -> 383;
386 -> 382;
386 -> 383;
387 -> 382;
387 -> 383;
388 -> 382;
388 -> 383;
389 -> 384;
389 -> 383;
390 -> 386;
390 -> 383;
391 -> 387;
391 -> 383;
392 -> 385;
392 -> 383;
393 -> 383;
394 -> 389;
394 -> 393;
395 -> 390;
395 -> 393;
396 -> 391;
396 -> 393;
397 -> 392;
397 -> 393;
398 -> 388;
398 -> 393;
399 -> 394;
399 -> 393;
400 -> 395;
400 -> 393;
401 -> 396;
401 -> 393;
402 -> 397;
402 -> 393;
403 -> 393;
404 -> 403;
404 -> 399;
404 -> 400;
404 -> 401;
404 -> 402;
404 -> 393;
405 -> 403;
405 -> 393;
406 -> 405;
406 -> 404;
406 -> 393;
407 -> 388;
407 -> 383;
408 -> 385;
408 -> 388;
408 -> 383;
409 -> 384;
409 -> 0;
409 -> 383;
410 -> 382;
410 -> 372;
411 -> 374;
411 -> 372;
412 -> 410;
412 -> 411;
413 -> 412;
416 -> 414;
416 -> 415;
417 -> 415;
418 -> 0;
418 -> 415;
419 -> 416;
419 -> 415;
420 -> 415;
421 -> 418;
421 -> 420;
422 -> 419;
422 -> 420;
423 -> 421;
423 -> 420;
424 -> 422;
424 -> 420;
425 -> 420;
426 -> 420;
427 -> 423;
427 -> 426;
428 -> 424;
428 -> 426;
429 -> 425;
429 -> 426;
430 -> 425;
430 -> 426;
431 -> 425;
431 -> 426;
432 -> 427;
432 -> 426;
433 -> 429;
433 -> 426;
434 -> 430;
434 -> 426;
435 -> 428;
435 -> 426;
436 -> 426;
437 -> 432;
437 -> 436;
438 -> 433;
438 -> 436;
439 -> 434;
439 -> 436;
440 -> 435;
440 -> 436;
441 -> 431;
441 -> 436;
442 -> 437;
442 -> 436;
443 -> 438;
443 -> 436;
444 -> 439;
444 -> 436;
445 -> 440;
445 -> 436;
446 -> 436;
447 -> 446;
447 -> 442;
447 -> 443;
447 -> 444;
447 -> 445;
447 -> 436;
448 -> 446;
448 -> 436;
449 -> 448;
449 -> 447;
449 -> 436;
450 -> 431;
450 -> 426;
451 -> 428;
451 -> 431;
451 -> 426;
452 -> 427;
452 -> 0;
452 -> 426;
453 -> 425;
453 -> 415;
454 -> 417;
454 -> 415;
455 -> 453;
455 -> 454;
456 -> 455;
457 -> 220;
459 -> 458;
461 -> 457;
461 -> 460;
462 -> 459;
462 -> 460;
463 -> 460;
464 -> 461;
464 -> 460;
465 -> 462;
465 -> 464;
466 -> 0;
466 -> 465;
467 -> 460;
468 -> 466;
468 -> 467;
468 -> 460;
469 -> 0;
469 -> 460;
470 -> 461;
470 -> 460;
471 -> 460;
472 -> 469;
472 -> 471;
473 -> 470;
473 -> 471;
474 -> 472;
474 -> 471;
475 -> 473;
475 -> 471;
476 -> 471;
477 -> 471;
478 -> 474;
478 -> 477;
479 -> 475;
479 -> 477;
480 -> 476;
480 -> 477;
481 -> 476;
481 -> 477;
482 -> 476;
482 -> 477;
483 -> 478;
483 -> 477;
484 -> 480;
484 -> 477;
485 -> 481;
485 -> 477;
486 -> 479;
486 -> 477;
487 -> 477;
488 -> 483;
488 -> 487;
489 -> 484;
489 -> 487;
490 -> 485;
490 -> 487;
491 -> 486;
491 -> 487;
492 -> 482;
492 -> 487;
493 -> 488;
493 -> 487;
494 -> 489;
494 -> 487;
495 -> 490;
495 -> 487;
496 -> 491;
496 -> 487;
497 -> 487;
498 -> 497;
498 -> 493;
498 -> 494;
498 -> 495;
498 -> 496;
498 -> 487;
499 -> 497;
499 -> 487;
500 -> 499;
500 -> 498;
500 -> 487;
501 -> 482;
501 -> 477;
502 -> 479;
502 -> 482;
502 -> 477;
503 -> 478;
503 -> 0;
503 -> 477;
504 -> 476;
504 -> 460;
505 -> 462;
505 -> 460;
506 -> 504;
506 -> 460;
507 -> 460;
508 -> 0;
508 -> 507;
508 -> 460;
509 -> 506;
509 -> 507;
509 -> 500;
509 -> 501;
509 -> 502;
509 -> 508;
509 -> 0;
509 -> 460;
510 -> 509;
510 -> 507;
511 -> 509;
511 -> 507;
512 -> 507;
513 -> 511;
513 -> 512;
514 -> 513;
514 -> 509;
514 -> 512;
515 -> 514;
515 -> 507;
516 -> 511;
516 -> 509;
516 -> 507;
517 -> 510;
517 -> 507;
518 -> 507;
519 -> 507;
520 -> 515;
520 -> 519;
521 -> 516;
521 -> 519;
522 -> 516;
522 -> 519;
523 -> 517;
523 -> 519;
524 -> 518;
524 -> 519;
525 -> 519;
526 -> 524;
526 -> 525;
527 -> 525;
528 -> 527;
528 -> 520;
528 -> 522;
528 -> 523;
528 -> 521;
528 -> 516;
528 -> 525;
529 -> 527;
529 -> 525;
530 -> 524;
530 -> 519;
531 -> 520;
531 -> 0;
531 -> 519;
532 -> 528;
535 -> 534;
537 -> 533;
537 -> 536;
538 -> 535;
538 -> 536;
539 -> 536;
540 -> 537;
540 -> 536;
541 -> 538;
541 -> 540;
542 -> 0;
542 -> 541;
543 -> 536;
544 -> 542;
544 -> 543;
544 -> 536;
545 -> 0;
545 -> 536;
546 -> 537;
546 -> 536;
547 -> 536;
548 -> 545;
548 -> 547;
549 -> 546;
549 -> 547;
550 -> 548;
550 -> 547;
551 -> 549;
551 -> 547;
552 -> 547;
553 -> 547;
554 -> 550;
554 -> 553;
555 -> 551;
555 -> 553;
556 -> 552;
556 -> 553;
557 -> 552;
557 -> 553;
558 -> 552;
558 -> 553;
559 -> 554;
559 -> 553;
560 -> 556;
560 -> 553;
561 -> 557;
561 -> 553;
562 -> 555;
562 -> 553;
563 -> 553;
564 -> 559;
564 -> 563;
565 -> 560;
565 -> 563;
566 -> 561;
566 -> 563;
567 -> 562;
567 -> 563;
568 -> 558;
568 -> 563;
569 -> 564;
569 -> 563;
570 -> 565;
570 -> 563;
571 -> 566;
571 -> 563;
572 -> 567;
572 -> 563;
573 -> 563;
574 -> 573;
574 -> 569;
574 -> 570;
574 -> 571;
574 -> 572;
574 -> 563;
575 -> 573;
575 -> 563;
576 -> 575;
576 -> 574;
576 -> 563;
577 -> 558;
577 -> 553;
578 -> 555;
578 -> 558;
578 -> 553;
579 -> 554;
579 -> 0;
579 -> 553;
580 -> 552;
580 -> 536;
581 -> 538;
581 -> 536;
582 -> 580;
582 -> 536;
583 -> 536;
584 -> 0;
584 -> 583;
584 -> 536;
585 -> 582;
585 -> 583;
585 -> 576;
585 -> 577;
585 -> 578;
585 -> 584;
585 -> 528;
585 -> 536;
586 -> 583;
587 -> 583;
588 -> 583;
589 -> 587;
589 -> 588;
590 -> 588;
591 -> 589;
591 -> 590;
592 -> 590;
593 -> 592;
593 -> 590;
594 -> 589;
594 -> 588;
595 -> 585;
595 -> 0;
595 -> 588;
596 -> 585;
599 -> 598;
601 -> 597;
601 -> 600;
602 -> 599;
602 -> 600;
603 -> 600;
604 -> 601;
604 -> 600;
605 -> 602;
605 -> 604;
606 -> 0;
606 -> 605;
607 -> 600;
608 -> 606;
608 -> 607;
608 -> 600;
609 -> 0;
609 -> 600;
610 -> 601;
610 -> 600;
611 -> 600;
612 -> 609;
612 -> 611;
613 -> 610;
613 -> 611;
614 -> 612;
614 -> 611;
615 -> 613;
615 -> 611;
616 -> 611;
617 -> 611;
618 -> 614;
618 -> 617;
619 -> 615;
619 -> 617;
620 -> 616;
620 -> 617;
621 -> 616;
621 -> 617;
622 -> 616;
622 -> 617;
623 -> 618;
623 -> 617;
624 -> 620;
624 -> 617;
625 -> 621;
625 -> 617;
626 -> 619;
626 -> 617;
627 -> 617;
628 -> 623;
628 -> 627;
629 -> 624;
629 -> 627;
630 -> 625;
630 -> 627;
631 -> 626;
631 -> 627;
632 -> 622;
632 -> 627;
633 -> 628;
633 -> 627;
634 -> 629;
634 -> 627;
635 -> 630;
635 -> 627;
636 -> 631;
636 -> 627;
637 -> 627;
638 -> 637;
638 -> 633;
638 -> 634;
638 -> 635;
638 -> 636;
638 -> 627;
639 -> 637;
639 -> 627;
640 -> 639;
640 -> 638;
640 -> 627;
641 -> 622;
641 -> 617;
642 -> 619;
642 -> 622;
642 -> 617;
643 -> 618;
643 -> 0;
643 -> 617;
644 -> 616;
644 -> 600;
645 -> 602;
645 -> 600;
646 -> 644;
646 -> 600;
647 -> 600;
648 -> 0;
648 -> 647;
648 -> 600;
649 -> 646;
649 -> 647;
649 -> 640;
649 -> 641;
649 -> 642;
649 -> 648;
649 -> 585;
649 -> 600;
650 -> 647;
651 -> 647;
652 -> 647;
653 -> 651;
653 -> 652;
654 -> 652;
655 -> 653;
655 -> 654;
656 -> 654;
657 -> 656;
657 -> 654;
658 -> 653;
658 -> 652;
659 -> 649;
659 -> 0;
659 -> 652;
660 -> 649;
663 -> 662;
665 -> 661;
665 -> 664;
666 -> 663;
666 -> 664;
667 -> 0;
667 -> 664;
668 -> 665;
668 -> 664;
669 -> 664;
670 -> 667;
670 -> 669;
671 -> 668;
671 -> 669;
672 -> 670;
672 -> 669;
673 -> 671;
673 -> 669;
674 -> 669;
675 -> 669;
676 -> 672;
676 -> 675;
677 -> 673;
677 -> 675;
678 -> 674;
678 -> 675;
679 -> 674;
679 -> 675;
680 -> 674;
680 -> 675;
681 -> 676;
681 -> 675;
682 -> 678;
682 -> 675;
683 -> 679;
683 -> 675;
684 -> 677;
684 -> 675;
685 -> 675;
686 -> 681;
686 -> 685;
687 -> 682;
687 -> 685;
688 -> 683;
688 -> 685;
689 -> 684;
689 -> 685;
690 -> 680;
690 -> 685;
691 -> 686;
691 -> 685;
692 -> 687;
692 -> 685;
693 -> 688;
693 -> 685;
694 -> 689;
694 -> 685;
695 -> 685;
696 -> 695;
696 -> 691;
696 -> 692;
696 -> 693;
696 -> 694;
696 -> 685;
697 -> 695;
697 -> 685;
698 -> 697;
698 -> 696;
698 -> 685;
699 -> 680;
699 -> 675;
700 -> 677;
700 -> 680;
700 -> 675;
701 -> 676;
701 -> 0;
701 -> 675;
702 -> 674;
702 -> 664;
703 -> 666;
703 -> 664;
704 -> 702;
704 -> 664;
705 -> 664;
706 -> 0;
706 -> 705;
706 -> 664;
707 -> 704;
707 -> 705;
707 -> 698;
707 -> 699;
707 -> 700;
707 -> 706;
707 -> 649;
707 -> 664;
708 -> 705;
709 -> 705;
710 -> 705;
711 -> 709;
711 -> 710;
712 -> 710;
713 -> 711;
713 -> 712;
714 -> 712;
715 -> 714;
715 -> 712;
716 -> 711;
716 -> 710;
717 -> 707;
717 -> 0;
717 -> 710;
718 -> 707;
721 -> 720;
723 -> 719;
723 -> 722;
724 -> 721;
724 -> 722;
725 -> 0;
725 -> 722;
726 -> 723;
726 -> 722;
727 -> 722;
728 -> 725;
728 -> 727;
729 -> 726;
729 -> 727;
730 -> 728;
730 -> 727;
731 -> 729;
731 -> 727;
732 -> 727;
733 -> 727;
734 -> 730;
734 -> 733;
735 -> 731;
735 -> 733;
736 -> 732;
736 -> 733;
737 -> 732;
737 -> 733;
738 -> 732;
738 -> 733;
739 -> 734;
739 -> 733;
740 -> 736;
740 -> 733;
741 -> 737;
741 -> 733;
742 -> 735;
742 -> 733;
743 -> 733;
744 -> 739;
744 -> 743;
745 -> 740;
745 -> 743;
746 -> 741;
746 -> 743;
747 -> 742;
747 -> 743;
748 -> 738;
748 -> 743;
749 -> 744;
749 -> 743;
750 -> 745;
750 -> 743;
751 -> 746;
751 -> 743;
752 -> 747;
752 -> 743;
753 -> 743;
754 -> 753;
754 -> 749;
754 -> 750;
754 -> 751;
754 -> 752;
754 -> 743;
755 -> 753;
755 -> 743;
756 -> 755;
756 -> 754;
756 -> 743;
757 -> 738;
757 -> 733;
758 -> 735;
758 -> 738;
758 -> 733;
759 -> 734;
759 -> 0;
759 -> 733;
760 -> 732;
760 -> 722;
761 -> 724;
761 -> 722;
762 -> 760;
762 -> 722;
763 -> 722;
764 -> 0;
764 -> 763;
764 -> 722;
765 -> 762;
765 -> 763;
765 -> 756;
765 -> 757;
765 -> 758;
765 -> 764;
765 -> 707;
765 -> 722;
766 -> 763;
767 -> 763;
768 -> 763;
769 -> 767;
769 -> 768;
770 -> 768;
771 -> 769;
771 -> 770;
772 -> 770;
773 -> 772;
773 -> 770;
774 -> 769;
774 -> 768;
775 -> 765;
775 -> 0;
775 -> 768;
776 -> 765;
777 -> 0;
779 -> 778;
781 -> 777;
781 -> 780;
782 -> 779;
782 -> 780;
783 -> 0;
783 -> 780;
784 -> 781;
784 -> 780;
785 -> 780;
786 -> 783;
786 -> 785;
787 -> 784;
787 -> 785;
788 -> 786;
788 -> 785;
789 -> 787;
789 -> 785;
790 -> 785;
791 -> 785;
792 -> 788;
792 -> 791;
793 -> 789;
793 -> 791;
794 -> 790;
794 -> 791;
795 -> 790;
795 -> 791;
796 -> 790;
796 -> 791;
797 -> 792;
797 -> 791;
798 -> 794;
798 -> 791;
799 -> 795;
799 -> 791;
800 -> 793;
800 -> 791;
801 -> 791;
802 -> 797;
802 -> 801;
803 -> 798;
803 -> 801;
804 -> 799;
804 -> 801;
805 -> 800;
805 -> 801;
806 -> 796;
806 -> 801;
807 -> 802;
807 -> 801;
808 -> 803;
808 -> 801;
809 -> 804;
809 -> 801;
810 -> 805;
810 -> 801;
811 -> 801;
812 -> 811;
812 -> 807;
812 -> 808;
812 -> 809;
812 -> 810;
812 -> 801;
813 -> 811;
813 -> 801;
814 -> 813;
814 -> 812;
814 -> 801;
815 -> 796;
815 -> 791;
816 -> 793;
816 -> 796;
816 -> 791;
817 -> 792;
817 -> 0;
817 -> 791;
818 -> 790;
818 -> 780;
819 -> 782;
819 -> 780;
820 -> 818;
820 -> 780;
821 -> 780;
822 -> 0;
822 -> 821;
822 -> 780;
823 -> 820;
823 -> 821;
823 -> 814;
823 -> 815;
823 -> 816;
823 -> 822;
823 -> 765;
823 -> 780;
824 -> 821;
825 -> 821;
826 -> 821;
827 -> 825;
827 -> 826;
828 -> 826;
829 -> 827;
829 -> 828;
830 -> 828;
831 -> 830;
831 -> 828;
832 -> 827;
832 -> 826;
833 -> 823;
833 -> 0;
833 -> 826;
834 -> 823;
837 -> 272;
837 -> 836;
838 -> 836;
839 -> 837;
839 -> 836;
840 -> 838;
840 -> 839;
840 -> 265;
840 -> 266;
840 -> 267;
840 -> 836;
842 -> 321;
842 -> 841;
843 -> 841;
844 -> 842;
844 -> 841;
845 -> 843;
845 -> 844;
845 -> 314;
845 -> 315;
845 -> 316;
845 -> 841;
847 -> 370;
847 -> 846;
848 -> 846;
849 -> 847;
849 -> 846;
850 -> 848;
850 -> 849;
850 -> 363;
850 -> 364;
850 -> 365;
850 -> 846;
852 -> 413;
852 -> 851;
853 -> 851;
854 -> 852;
854 -> 851;
855 -> 853;
855 -> 854;
855 -> 406;
855 -> 407;
855 -> 408;
855 -> 851;
857 -> 456;
857 -> 856;
858 -> 856;
859 -> 857;
859 -> 856;
860 -> 858;
860 -> 859;
860 -> 449;
860 -> 450;
860 -> 451;
860 -> 856;
862 -> 532;
862 -> 861;
863 -> 861;
864 -> 862;
864 -> 861;
865 -> 863;
865 -> 864;
865 -> 823;
865 -> 861;
867 -> 596;
867 -> 866;
868 -> 866;
869 -> 867;
869 -> 866;
870 -> 868;
870 -> 869;
870 -> 865;
870 -> 866;
872 -> 660;
872 -> 871;
873 -> 871;
874 -> 872;
874 -> 871;
875 -> 873;
875 -> 874;
875 -> 870;
875 -> 871;
877 -> 718;
877 -> 876;
878 -> 876;
879 -> 877;
879 -> 876;
880 -> 878;
880 -> 879;
880 -> 875;
880 -> 876;
882 -> 776;
882 -> 881;
883 -> 881;
884 -> 882;
884 -> 881;
885 -> 883;
885 -> 884;
885 -> 880;
885 -> 881;
887 -> 834;
887 -> 886;
888 -> 886;
889 -> 887;
889 -> 886;
890 -> 888;
890 -> 889;
890 -> 885;
890 -> 886;
891 -> 215;
891 -> 214;
892 -> 216;
892 -> 214;
893 -> 214;
894 -> 214;
895 -> 891;
895 -> 894;
896 -> 893;
896 -> 894;
897 -> 892;
897 -> 894;
898 -> 893;
898 -> 894;
899 -> 895;
899 -> 894;
900 -> 896;
900 -> 894;
901 -> 897;
901 -> 894;
902 -> 894;
903 -> 899;
903 -> 902;
904 -> 900;
904 -> 902;
905 -> 901;
905 -> 902;
906 -> 903;
906 -> 902;
907 -> 904;
907 -> 902;
908 -> 902;
909 -> 906;
909 -> 908;
910 -> 907;
910 -> 908;
911 -> 909;
911 -> 908;
912 -> 0;
912 -> 908;
913 -> 908;
914 -> 910;
914 -> 908;
915 -> 911;
915 -> 914;
915 -> 908;
917 -> 916;
918 -> 916;
919 -> 916;
920 -> 916;
921 -> 916;
922 -> 917;
922 -> 916;
923 -> 918;
923 -> 916;
924 -> 919;
924 -> 916;
925 -> 920;
925 -> 916;
926 -> 925;
926 -> 916;
927 -> 0;
927 -> 916;
928 -> 922;
928 -> 921;
929 -> 923;
929 -> 921;
930 -> 924;
930 -> 921;
931 -> 926;
931 -> 921;
932 -> 927;
932 -> 921;
933 -> 921;
934 -> 930;
934 -> 921;
935 -> 929;
935 -> 921;
936 -> 933;
936 -> 934;
936 -> 935;
936 -> 921;
937 -> 933;
937 -> 921;
938 -> 933;
938 -> 921;
939 -> 933;
939 -> 921;
940 -> 928;
940 -> 933;
940 -> 921;
941 -> 928;
941 -> 921;
942 -> 921;
943 -> 941;
943 -> 942;
944 -> 943;
944 -> 942;
945 -> 0;
945 -> 944;
946 -> 945;
946 -> 933;
946 -> 921;
947 -> 931;
947 -> 921;
948 -> 947;
948 -> 933;
948 -> 921;
949 -> 932;
949 -> 921;
950 -> 0;
950 -> 921;
951 -> 949;
951 -> 933;
951 -> 921;
952 -> 916;
954 -> 953;
957 -> 956;
959 -> 958;
970 -> 961;
970 -> 960;
971 -> 962;
971 -> 960;
972 -> 963;
972 -> 960;
973 -> 964;
973 -> 960;
974 -> 965;
974 -> 960;
975 -> 966;
975 -> 960;
976 -> 967;
976 -> 960;
977 -> 968;
977 -> 960;
978 -> 969;
978 -> 960;
979 -> 960;
981 -> 980;
982 -> 952;
982 -> 902;
983 -> 982;
983 -> 905;
983 -> 902;
984 -> 902;
985 -> 902;
986 -> 915;
986 -> 985;
987 -> 983;
987 -> 985;
988 -> 984;
988 -> 985;
989 -> 984;
989 -> 985;
990 -> 984;
990 -> 985;
991 -> 986;
991 -> 985;
992 -> 985;
993 -> 991;
993 -> 992;
994 -> 990;
994 -> 992;
995 -> 994;
995 -> 992;
996 -> 994;
996 -> 992;
997 -> 0;
999 -> 998;
1001 -> 1000;
1002 -> 1001;
1003 -> 993;
1003 -> 992;
1004 -> 992;
1005 -> 992;
1006 -> 1003;
1006 -> 1005;
1007 -> 1004;
1007 -> 1005;
1008 -> 1007;
1008 -> 1005;
1009 -> 1007;
1009 -> 1005;
1010 -> 1007;
1010 -> 1005;
1011 -> 1007;
1011 -> 1005;
1012 -> 1007;
1012 -> 1005;
1013 -> 1007;
1013 -> 1005;
1014 -> 1007;
1014 -> 1005;
1015 -> 1007;
1015 -> 1005;
1016 -> 1006;
1016 -> 1007;
1016 -> 1005;
1017 -> 1005;
1018 -> 1017;
1018 -> 1007;
1018 -> 1005;
1019 -> 1005;
1020 -> 1019;
1020 -> 1007;
1020 -> 1005;
1021 -> 1006;
1021 -> 915;
1021 -> 1007;
1021 -> 1005;
1022 -> 1005;
1023 -> 1022;
1023 -> 1007;
1023 -> 1005;
1024 -> 1002;
1024 -> 1001;
1024 -> 1005;
1025 -> 1024;
1025 -> 1007;
1025 -> 1005;
1026 -> 1005;
1027 -> 1026;
1027 -> 1007;
1027 -> 1005;
1028 -> 1004;
1028 -> 994;
1028 -> 992;
1029 -> 990;
1029 -> 985;
1030 -> 990;
1030 -> 985;
1031 -> 990;
1031 -> 985;
1032 -> 990;
1032 -> 985;
1033 -> 990;
1033 -> 985;
1034 -> 990;
1034 -> 985;
1035 -> 990;
1035 -> 985;
1036 -> 990;
1036 -> 985;
1037 -> 990;
1037 -> 985;
1038 -> 990;
1038 -> 985;
1039 -> 985;
1040 -> 1039;
1040 -> 985;
1041 -> 1040;
1041 -> 990;
1041 -> 985;
1042 -> 985;
1043 -> 1042;
1043 -> 985;
1044 -> 1043;
1044 -> 990;
1044 -> 985;
1045 -> 990;
1045 -> 985;
1046 -> 990;
1046 -> 985;
1047 -> 985;
1048 -> 987;
1048 -> 1047;
1048 -> 985;
1049 -> 987;
1049 -> 990;
1049 -> 985;
1050 -> 985;
1051 -> 1050;
1051 -> 990;
1051 -> 985;
1052 -> 985;
1053 -> 1052;
1053 -> 990;
1053 -> 985;
1056 -> 1054;
1056 -> 1055;
1057 -> 1056;
1059 -> 1058;
1060 -> 985;
1061 -> 985;
1062 -> 1060;
1062 -> 1061;
1063 -> 1062;
1063 -> 1061;
1064 -> 1062;
1064 -> 1061;
1065 -> 1062;
1065 -> 1061;
1066 -> 1061;
1067 -> 1066;
1067 -> 1062;
1067 -> 1061;
1068 -> 1061;
1069 -> 1068;
1069 -> 1062;
1069 -> 1061;
1070 -> 1057;
1070 -> 1056;
1070 -> 1061;
1071 -> 1070;
1071 -> 1062;
1071 -> 1061;
1072 -> 1060;
1072 -> 990;
1072 -> 985;
1073 -> 990;
1073 -> 985;
1074 -> 988;
1074 -> 990;
1074 -> 985;
1075 -> 989;
1075 -> 990;
1075 -> 985;
1076 -> 984;
1076 -> 894;
1077 -> 1076;
1077 -> 894;
1078 -> 894;
1079 -> 1077;
1079 -> 1078;
1080 -> 0;
1081 -> 1079;
1081 -> 1078;
1082 -> 1078;
1083 -> 1078;
1084 -> 1081;
1084 -> 1083;
1085 -> 1082;
1085 -> 1083;
1086 -> 1082;
1086 -> 1083;
1087 -> 1082;
1087 -> 1083;
1088 -> 1082;
1088 -> 1083;
1089 -> 1082;
1089 -> 1083;
1092 -> 1090;
1092 -> 1091;
1093 -> 1092;
1094 -> 1084;
1094 -> 1083;
1095 -> 1087;
1095 -> 1083;
1096 -> 1085;
1096 -> 1083;
1097 -> 1086;
1097 -> 1083;
1098 -> 1083;
1099 -> 1083;
1100 -> 1088;
1100 -> 1083;
1101 -> 1083;
1102 -> 1094;
1102 -> 1101;
1103 -> 1095;
1103 -> 1101;
1104 -> 1096;
1104 -> 1101;
1105 -> 1097;
1105 -> 1101;
1106 -> 1098;
1106 -> 1101;
1107 -> 1099;
1107 -> 1101;
1108 -> 1100;
1108 -> 1101;
1109 -> 1089;
1109 -> 1101;
1110 -> 1109;
1110 -> 1101;
1111 -> 1109;
1111 -> 1101;
1112 -> 1109;
1112 -> 1101;
1113 -> 1109;
1113 -> 1101;
1114 -> 1109;
1114 -> 1101;
1115 -> 1109;
1115 -> 1101;
1116 -> 1109;
1116 -> 1101;
1117 -> 1109;
1117 -> 1101;
1118 -> 1109;
1118 -> 1101;
1119 -> 1109;
1119 -> 1101;
1120 -> 1109;
1120 -> 1101;
1121 -> 1109;
1121 -> 1101;
1122 -> 1109;
1122 -> 1101;
1123 -> 1102;
1123 -> 1109;
1123 -> 1101;
1124 -> 1103;
1124 -> 1109;
1124 -> 1101;
1125 -> 1106;
1125 -> 1109;
1125 -> 1101;
1126 -> 1108;
1126 -> 1109;
1126 -> 1101;
1127 -> 1101;
1128 -> 1127;
1128 -> 1109;
1128 -> 1101;
1129 -> 1101;
1130 -> 1104;
1130 -> 1129;
1130 -> 1101;
1131 -> 1130;
1131 -> 1109;
1131 -> 1101;
1132 -> 1101;
1133 -> 1109;
1133 -> 1132;
1134 -> 1133;
1134 -> 1131;
1134 -> 1132;
1135 -> 1134;
1135 -> 1101;
1136 -> 1135;
1136 -> 1106;
1136 -> 1101;
1137 -> 1136;
1138 -> 1137;
1138 -> 1109;
1138 -> 1136;
1139 -> 1136;
1140 -> 1139;
1140 -> 1109;
1140 -> 1136;
1141 -> 1101;
1142 -> 1109;
1142 -> 1141;
1143 -> 1142;
1143 -> 1131;
1143 -> 1141;
1144 -> 1143;
1144 -> 1101;
1145 -> 1107;
1145 -> 1144;
1145 -> 1101;
1146 -> 1145;
1146 -> 1108;
1146 -> 1082;
1146 -> 1101;
1147 -> 1146;
1148 -> 1109;
1148 -> 1147;
1149 -> 1147;
1150 -> 1147;
1151 -> 1148;
1151 -> 1123;
1151 -> 1028;
1151 -> 1150;
1152 -> 1151;
1152 -> 1016;
1152 -> 1150;
1153 -> 1152;
1153 -> 1147;
1154 -> 1153;
1154 -> 1147;
1155 -> 1154;
1155 -> 1148;
1155 -> 1147;
1156 -> 1148;
1156 -> 1123;
1156 -> 1147;
1157 -> 1148;
1157 -> 1124;
1157 -> 1147;
1158 -> 1147;
1159 -> 1158;
1159 -> 1153;
1159 -> 1147;
1160 -> 1157;
1160 -> 1159;
1161 -> 1159;
1162 -> 1160;
1162 -> 1161;
1163 -> 1156;
1163 -> 1161;
1164 -> 955;
1164 -> 1161;
1165 -> 1162;
1165 -> 1163;
1165 -> 1161;
1166 -> 1163;
1166 -> 1165;
1166 -> 1161;
1167 -> 1163;
1167 -> 1028;
1167 -> 996;
1167 -> 1049;
1167 -> 1165;
1167 -> 1051;
1167 -> 1053;
1167 -> 1033;
1167 -> 1072;
1167 -> 1074;
1167 -> 1075;
1167 -> 1037;
1167 -> 1038;
1167 -> 1041;
1167 -> 1044;
1167 -> 1045;
1167 -> 1073;
1167 -> 1016;
1167 -> 1018;
1167 -> 1020;
1167 -> 1021;
1167 -> 1025;
1167 -> 1013;
1167 -> 1027;
1167 -> 1023;
1167 -> 915;
1167 -> 1040;
1167 -> 1043;
1167 -> 936;
1167 -> 937;
1167 -> 951;
1167 -> 938;
1167 -> 946;
1167 -> 939;
1167 -> 940;
1167 -> 948;
1167 -> 949;
1167 -> 947;
1167 -> 1050;
1167 -> 1052;
1167 -> 1067;
1167 -> 1069;
1167 -> 1071;
1167 -> 1070;
1167 -> 1068;
1167 -> 1066;
1167 -> 1022;
1167 -> 1024;
1167 -> 1166;
1168 -> 1166;
1169 -> 1167;
1169 -> 1168;
1170 -> 1168;
1171 -> 1169;
1171 -> 1167;
1171 -> 1170;
1172 -> 1171;
1172 -> 1167;
1172 -> 1170;
1173 -> 1168;
1174 -> 1168;
1175 -> 1174;
1175 -> 1169;
1175 -> 1168;
1176 -> 1167;
1176 -> 1168;
1177 -> 1176;
1177 -> 1167;
1177 -> 1168;
1178 -> 1167;
1178 -> 1177;
1178 -> 1172;
1178 -> 1175;
1178 -> 1166;
1179 -> 1167;
1179 -> 1168;
1180 -> 1179;
1180 -> 1178;
1180 -> 1168;
1181 -> 1167;
1181 -> 1168;
1182 -> 1181;
1182 -> 1180;
1182 -> 1168;
1183 -> 1167;
1183 -> 1168;
1184 -> 1167;
1184 -> 1168;
1185 -> 1184;
1185 -> 1182;
1185 -> 1183;
1185 -> 1168;
1186 -> 1185;
1186 -> 1184;
1186 -> 1168;
1187 -> 1167;
1187 -> 1168;
1188 -> 1187;
1188 -> 1182;
1188 -> 1168;
1189 -> 1167;
1189 -> 1188;
1189 -> 1182;
1189 -> 1186;
1189 -> 1166;
1190 -> 1167;
1190 -> 1168;
1191 -> 1167;
1191 -> 1168;
1192 -> 1190;
1192 -> 1191;
1192 -> 1189;
1192 -> 1168;
1193 -> 1168;
1194 -> 1192;
1194 -> 1193;
1194 -> 1168;
1195 -> 1192;
1195 -> 1191;
1195 -> 1189;
1195 -> 1168;
1196 -> 1192;
1196 -> 1191;
1196 -> 1194;
1197 -> 1166;
1198 -> 1163;
1198 -> 1197;
1199 -> 1198;
1199 -> 1196;
1199 -> 1197;
1200 -> 1197;
1201 -> 1198;
1201 -> 1199;
1201 -> 1200;
1202 -> 1201;
1202 -> 1199;
1202 -> 1200;
1203 -> 1202;
1203 -> 1197;
1204 -> 1197;
1205 -> 1198;
1205 -> 1199;
1205 -> 1197;
1206 -> 1197;
1207 -> 1203;
1207 -> 1206;
1208 -> 1204;
1208 -> 1206;
1209 -> 1205;
1209 -> 1206;
1210 -> 1198;
1210 -> 1206;
1211 -> 1208;
1211 -> 1206;
1212 -> 1206;
1213 -> 1212;
1214 -> 1210;
1214 -> 1213;
1215 -> 1213;
1216 -> 1214;
1216 -> 1199;
1216 -> 1215;
1217 -> 1213;
1218 -> 1213;
1219 -> 1218;
1219 -> 1214;
1219 -> 1213;
1220 -> 1212;
1221 -> 1212;
1222 -> 1210;
1222 -> 1199;
1222 -> 1221;
1223 -> 1222;
1223 -> 1199;
1223 -> 1221;
1224 -> 1221;
1225 -> 1222;
1225 -> 1224;
1226 -> 1225;
1226 -> 1199;
1226 -> 1224;
1227 -> 1226;
1228 -> 1225;
1228 -> 1227;
1229 -> 1228;
1229 -> 1199;
1229 -> 1227;
1230 -> 1229;
1230 -> 1226;
1231 -> 1226;
1232 -> 1225;
1232 -> 1199;
1232 -> 1216;
1232 -> 1231;
1232 -> 1226;
1233 -> 1225;
1233 -> 1199;
1233 -> 1216;
1233 -> 1219;
1233 -> 1226;
1234 -> 1225;
1234 -> 1199;
1234 -> 1226;
1235 -> 1225;
1235 -> 1199;
1235 -> 1216;
1235 -> 1219;
1235 -> 1226;
1236 -> 1225;
1236 -> 1199;
1236 -> 1226;
1237 -> 1235;
1237 -> 1226;
1238 -> 1225;
1238 -> 1237;
1238 -> 1235;
1238 -> 1226;
1239 -> 1238;
1239 -> 1225;
1239 -> 1226;
1240 -> 1226;
1241 -> 1235;
1241 -> 1240;
1241 -> 1226;
1242 -> 1241;
1242 -> 1221;
1243 -> 1222;
1243 -> 1237;
1243 -> 1239;
1243 -> 1221;
1244 -> 1243;
1244 -> 1212;
1245 -> 1212;
1246 -> 1244;
1246 -> 1245;
1246 -> 1212;
1247 -> 1246;
1248 -> 1244;
1248 -> 1212;
1249 -> 1248;
1250 -> 1198;
1250 -> 1237;
1250 -> 1209;
1250 -> 1197;
1251 -> 1197;
1252 -> 1197;
1253 -> 1198;
1253 -> 1252;
1254 -> 1252;
1255 -> 1253;
1255 -> 1237;
1255 -> 1254;
1256 -> 1252;
1257 -> 1252;
1258 -> 1257;
1258 -> 1253;
1258 -> 1252;
1259 -> 1197;
1260 -> 1251;
1260 -> 1197;
1261 -> 1260;
1261 -> 1198;
1261 -> 1237;
1261 -> 1239;
1261 -> 1209;
1261 -> 1255;
1261 -> 1258;
1261 -> 1251;
1261 -> 1197;
1262 -> 1197;
1263 -> 1261;
1263 -> 1262;
1264 -> 1263;
1264 -> 1261;
1264 -> 1262;
1265 -> 1261;
1265 -> 1264;
1265 -> 1262;
1266 -> 1261;
1266 -> 1264;
1266 -> 1262;
1267 -> 1261;
1267 -> 1262;
1268 -> 1261;
1268 -> 1262;
1269 -> 0;
1269 -> 1267;
1269 -> 1262;
1270 -> 1267;
1270 -> 1262;
1271 -> 1262;
1272 -> 1270;
1272 -> 1271;
1273 -> 1268;
1273 -> 1271;
1274 -> 1272;
1274 -> 1271;
1275 -> 1274;
1275 -> 1273;
1275 -> 1266;
1275 -> 1269;
1275 -> 1271;
1276 -> 1271;
1277 -> 1275;
1277 -> 1276;
1278 -> 1275;
1278 -> 1276;
1279 -> 1275;
1279 -> 1276;
1280 -> 1275;
1280 -> 1276;
1281 -> 1277;
1281 -> 1276;
1282 -> 1278;
1282 -> 1276;
1283 -> 1279;
1283 -> 1276;
1284 -> 1280;
1284 -> 1275;
1284 -> 1281;
1284 -> 1282;
1284 -> 1283;
1284 -> 1276;
1285 -> 1284;
1286 -> 0;
1286 -> 1285;
1287 -> 1285;
1288 -> 1286;
1288 -> 1287;
1289 -> 1268;
1289 -> 1287;
1290 -> 1289;
1290 -> 1284;
1290 -> 1287;
1291 -> 1287;
1292 -> 1290;
1292 -> 1291;
1293 -> 1292;
1293 -> 0;
1293 -> 1291;
1294 -> 1293;
1294 -> 1288;
1294 -> 1287;
1295 -> 1284;
1295 -> 1294;
1296 -> 1294;
1297 -> 1295;
1297 -> 1296;
1298 -> 1295;
1298 -> 1296;
1299 -> 1268;
1299 -> 1284;
1299 -> 1296;
1300 -> 1297;
1300 -> 1059;
1300 -> 1296;
1302 -> 1301;
1303 -> 1301;
1304 -> 1297;
1304 -> 1296;
1305 -> 1304;
1305 -> 1299;
1305 -> 1284;
1305 -> 1296;
1306 -> 1296;
1307 -> 1305;
1307 -> 1306;
1308 -> 1307;
1308 -> 1306;
1309 -> 0;
1309 -> 1308;
1310 -> 1305;
1310 -> 1306;
1311 -> 1310;
1311 -> 1306;
1312 -> 0;
1312 -> 1311;
1313 -> 1305;
1313 -> 1312;
1313 -> 1309;
1313 -> 1296;
1314 -> 1313;
1314 -> 0;
1314 -> 1296;
1315 -> 1284;
1315 -> 1313;
1315 -> 1314;
1316 -> 1314;
1317 -> 1315;
1317 -> 1316;
1318 -> 1317;
1318 -> 1316;
1319 -> 1318;
1320 -> 1284;
1320 -> 1313;
1320 -> 1319;
1321 -> 0;
1321 -> 1284;
1321 -> 1319;
1322 -> 1284;
1322 -> 1313;
1322 -> 1321;
1322 -> 0;
1322 -> 1285;
1323 -> 1284;
1324 -> 1284;
1324 -> 1323;
1324 -> 1313;
1324 -> 1321;
1324 -> 1320;
1324 -> 1197;
1325 -> 1250;
1325 -> 1197;
1326 -> 1197;
1327 -> 1325;
1327 -> 1326;
1328 -> 1326;
1329 -> 1326;
1330 -> 1327;
1330 -> 1329;
1330 -> 1326;
1331 -> 1330;
1332 -> 1331;
1332 -> 1327;
1332 -> 1324;
1332 -> 1330;
1333 -> 1328;
1333 -> 1326;
1334 -> 1333;
1334 -> 1197;
1335 -> 1197;
1336 -> 1334;
1336 -> 1335;
1337 -> 1198;
1337 -> 1335;
1338 -> 1335;
1339 -> 1337;
1339 -> 1324;
1339 -> 1338;
1339 -> 1335;
1340 -> 1339;
1341 -> 1340;
1341 -> 1197;
1342 -> 1198;
1342 -> 1324;
1342 -> 1197;
1343 -> 1197;
1344 -> 1198;
1344 -> 1342;
1344 -> 1197;
1345 -> 1197;
1346 -> 1343;
1346 -> 1345;
1347 -> 1343;
1347 -> 1345;
1348 -> 1344;
1348 -> 1345;
1349 -> 1198;
1349 -> 1345;
1350 -> 1347;
1350 -> 1345;
1351 -> 1345;
1352 -> 1351;
1353 -> 1349;
1353 -> 1352;
1354 -> 1352;
1355 -> 1353;
1355 -> 1342;
1355 -> 1354;
1356 -> 1352;
1357 -> 1352;
1358 -> 1357;
1358 -> 1353;
1358 -> 1352;
1359 -> 1351;
1360 -> 1351;
1361 -> 1349;
1361 -> 1342;
1361 -> 1360;
1362 -> 1361;
1362 -> 1342;
1362 -> 1360;
1363 -> 1361;
1363 -> 1351;
1364 -> 1351;
1365 -> 1363;
1365 -> 1364;
1365 -> 1351;
1366 -> 1349;
1366 -> 1342;
1366 -> 1355;
1366 -> 1358;
1366 -> 1365;
1367 -> 1365;
1368 -> 1366;
1368 -> 1367;
1369 -> 1366;
1369 -> 1367;
1370 -> 1369;
1370 -> 1366;
1370 -> 1367;
1371 -> 1366;
1371 -> 1370;
1371 -> 1367;
1372 -> 1366;
1372 -> 1367;
1373 -> 1372;
1373 -> 1370;
1373 -> 1367;
1374 -> 1348;
1374 -> 1365;
1375 -> 1365;
1376 -> 1373;
1376 -> 1375;
1377 -> 1374;
1377 -> 1375;
1378 -> 1349;
1378 -> 1375;
1379 -> 1375;
1380 -> 1378;
1380 -> 1379;
1381 -> 1379;
1382 -> 1380;
1382 -> 1373;
1382 -> 1381;
1382 -> 1379;
1383 -> 1382;
1383 -> 1375;
1384 -> 1375;
1385 -> 1377;
1385 -> 1384;
1385 -> 1375;
1386 -> 1376;
1386 -> 1375;
1387 -> 1377;
1387 -> 1386;
1387 -> 1373;
1387 -> 1375;
1388 -> 1387;
1388 -> 1360;
1389 -> 1387;
1390 -> 1387;
1390 -> 1351;
1391 -> 1347;
1391 -> 1390;
1392 -> 1390;
1393 -> 1198;
1393 -> 1387;
1393 -> 1377;
1393 -> 1197;
1394 -> 1324;
1394 -> 1197;
1395 -> 1250;
1395 -> 1197;
1396 -> 1393;
1396 -> 1197;
1397 -> 1341;
1397 -> 1197;
1398 -> 1197;
1399 -> 1394;
1399 -> 1398;
1400 -> 1395;
1400 -> 1398;
1401 -> 1396;
1401 -> 1398;
1402 -> 1397;
1402 -> 1398;
1403 -> 1198;
1403 -> 1398;
1404 -> 1399;
1404 -> 1324;
1404 -> 0;
1404 -> 1398;
1405 -> 1398;
1406 -> 1399;
1406 -> 1324;
1406 -> 1405;
1406 -> 1398;
1407 -> 1400;
1407 -> 1387;
1407 -> 1358;
1407 -> 1377;
1407 -> 1398;
1408 -> 1401;
1408 -> 1407;
1408 -> 1398;
1409 -> 1398;
1410 -> 1399;
1410 -> 1324;
1410 -> 1398;
1411 -> 1399;
1411 -> 1324;
1411 -> 1410;
1412 -> 1399;
1412 -> 1324;
1412 -> 1411;
1413 -> 1407;
1413 -> 1411;
1414 -> 1408;
1414 -> 1411;
1415 -> 1411;
1416 -> 1412;
1416 -> 1415;
1417 -> 1413;
1417 -> 1415;
1418 -> 1412;
1418 -> 1415;
1419 -> 1412;
1419 -> 1415;
1420 -> 1414;
1420 -> 1415;
1421 -> 0;
1422 -> 0;
1424 -> 1422;
1424 -> 1423;
1425 -> 1424;
1426 -> 1425;
1428 -> 1422;
1428 -> 1427;
1429 -> 1428;
1430 -> 1429;
1432 -> 1422;
1432 -> 1431;
1433 -> 1432;
1434 -> 1433;
1436 -> 1422;
1436 -> 1435;
1437 -> 1436;
1438 -> 1437;
1440 -> 1421;
1441 -> 1440;
1441 -> 1422;
1442 -> 1426;
1442 -> 1425;
1442 -> 1440;
1442 -> 1441;
1443 -> 1440;
1443 -> 1441;
1444 -> 1441;
1445 -> 1441;
1446 -> 1443;
1446 -> 1445;
1447 -> 1444;
1447 -> 1445;
1448 -> 1446;
1448 -> 1445;
1449 -> 1445;
1450 -> 1448;
1450 -> 1449;
1451 -> 1447;
1451 -> 1449;
1452 -> 1450;
1452 -> 1449;
1453 -> 1449;
1454 -> 1453;
1454 -> 1452;
1454 -> 1449;
1455 -> 1453;
1455 -> 1449;
1456 -> 1455;
1456 -> 1454;
1456 -> 1449;
1457 -> 1445;
1458 -> 1447;
1458 -> 1457;
1459 -> 1457;
1460 -> 1458;
1460 -> 1459;
1461 -> 1460;
1461 -> 1456;
1461 -> 1459;
1462 -> 1461;
1462 -> 1457;
1463 -> 1457;
1464 -> 1462;
1464 -> 1463;
1465 -> 1464;
1465 -> 1463;
1466 -> 1465;
1467 -> 1466;
1467 -> 1445;
1468 -> 1467;
1468 -> 1447;
1468 -> 1445;
1469 -> 1447;
1469 -> 1456;
1469 -> 0;
1469 -> 1445;
1470 -> 1469;
1470 -> 1447;
1470 -> 1445;
1471 -> 1444;
1471 -> 1442;
1471 -> 1441;
1473 -> 1430;
1473 -> 1429;
1473 -> 1440;
1473 -> 1441;
1474 -> 1440;
1474 -> 1441;
1475 -> 834;
1475 -> 1441;
1476 -> 1441;
1477 -> 1441;
1478 -> 1474;
1478 -> 1477;
1479 -> 1475;
1479 -> 1477;
1480 -> 1475;
1480 -> 1477;
1481 -> 1476;
1481 -> 1477;
1482 -> 1478;
1482 -> 1477;
1483 -> 1477;
1484 -> 1482;
1484 -> 1483;
1485 -> 1481;
1485 -> 1483;
1486 -> 1484;
1486 -> 1483;
1487 -> 1483;
1488 -> 1486;
1488 -> 1487;
1489 -> 1485;
1489 -> 1487;
1490 -> 1488;
1490 -> 1487;
1491 -> 1487;
1492 -> 1491;
1492 -> 1490;
1492 -> 1487;
1493 -> 1491;
1493 -> 1487;
1494 -> 1493;
1494 -> 1492;
1494 -> 1487;
1495 -> 1483;
1496 -> 1485;
1496 -> 1495;
1497 -> 1495;
1498 -> 1496;
1498 -> 1497;
1499 -> 1498;
1499 -> 1494;
1499 -> 1497;
1500 -> 1499;
1500 -> 1495;
1501 -> 1495;
1502 -> 1500;
1502 -> 1501;
1503 -> 1502;
1503 -> 1501;
1504 -> 1503;
1505 -> 1504;
1505 -> 1483;
1506 -> 1505;
1506 -> 1485;
1506 -> 1483;
1507 -> 1485;
1507 -> 1494;
1507 -> 0;
1507 -> 1483;
1508 -> 1507;
1508 -> 1485;
1508 -> 1483;
1509 -> 1481;
1509 -> 1477;
1510 -> 1481;
1510 -> 1477;
1511 -> 1477;
1512 -> 1479;
1512 -> 1511;
1512 -> 1477;
1513 -> 1479;
1513 -> 1512;
1514 -> 1481;
1514 -> 1513;
1514 -> 1494;
1514 -> 1506;
1514 -> 1508;
1514 -> 1509;
1514 -> 1510;
1514 -> 890;
1514 -> 1512;
1515 -> 1479;
1515 -> 1481;
1515 -> 1512;
1516 -> 1477;
1517 -> 1480;
1517 -> 1516;
1517 -> 1477;
1518 -> 1480;
1518 -> 1517;
1519 -> 1481;
1519 -> 1518;
1519 -> 1514;
1519 -> 1515;
1519 -> 1517;
1520 -> 1480;
1520 -> 1481;
1520 -> 1517;
1521 -> 1476;
1521 -> 1473;
1521 -> 1441;
1522 -> 1434;
1522 -> 1433;
1522 -> 1440;
1522 -> 1441;
1523 -> 1440;
1523 -> 1441;
1524 -> 1441;
1525 -> 413;
1525 -> 1441;
1526 -> 1441;
1527 -> 1523;
1527 -> 1526;
1528 -> 1524;
1528 -> 1526;
1529 -> 1525;
1529 -> 1526;
1530 -> 1524;
1530 -> 1526;
1531 -> 1527;
1531 -> 1526;
1532 -> 1526;
1533 -> 1531;
1533 -> 1532;
1534 -> 1530;
1534 -> 1532;
1535 -> 1533;
1535 -> 1532;
1536 -> 1532;
1537 -> 1535;
1537 -> 1536;
1538 -> 1534;
1538 -> 1536;
1539 -> 1537;
1539 -> 1536;
1540 -> 1536;
1541 -> 1540;
1541 -> 1539;
1541 -> 1536;
1542 -> 1540;
1542 -> 1536;
1543 -> 1542;
1543 -> 1541;
1543 -> 1536;
1544 -> 1532;
1545 -> 1534;
1545 -> 1544;
1546 -> 1544;
1547 -> 1545;
1547 -> 1546;
1548 -> 1547;
1548 -> 1543;
1548 -> 1546;
1549 -> 1548;
1549 -> 1544;
1550 -> 1544;
1551 -> 1549;
1551 -> 1550;
1552 -> 1551;
1552 -> 1550;
1553 -> 1552;
1554 -> 1553;
1554 -> 1532;
1555 -> 1554;
1555 -> 1534;
1555 -> 1532;
1556 -> 1534;
1556 -> 1543;
1556 -> 0;
1556 -> 1532;
1557 -> 1556;
1557 -> 1534;
1557 -> 1532;
1558 -> 1530;
1558 -> 1526;
1559 -> 1530;
1559 -> 1526;
1560 -> 1526;
1561 -> 1528;
1561 -> 1560;
1561 -> 1526;
1562 -> 1526;
1563 -> 1529;
1563 -> 1562;
1563 -> 1526;
1564 -> 1529;
1564 -> 1563;
1565 -> 1530;
1565 -> 1564;
1565 -> 1543;
1565 -> 1555;
1565 -> 1557;
1565 -> 1558;
1565 -> 1559;
1565 -> 855;
1565 -> 1563;
1566 -> 1529;
1566 -> 1530;
1566 -> 1563;
1567 -> 1524;
1567 -> 1522;
1567 -> 1441;
1568 -> 1438;
1568 -> 1437;
1568 -> 1440;
1568 -> 1441;
1569 -> 1440;
1569 -> 1441;
1570 -> 1441;
1571 -> 272;
1571 -> 1441;
1572 -> 1441;
1573 -> 1569;
1573 -> 1572;
1574 -> 1570;
1574 -> 1572;
1575 -> 1571;
1575 -> 1572;
1576 -> 1570;
1576 -> 1572;
1577 -> 1573;
1577 -> 1572;
1578 -> 1572;
1579 -> 1577;
1579 -> 1578;
1580 -> 1576;
1580 -> 1578;
1581 -> 1579;
1581 -> 1578;
1582 -> 1578;
1583 -> 1581;
1583 -> 1582;
1584 -> 1580;
1584 -> 1582;
1585 -> 1583;
1585 -> 1582;
1586 -> 1582;
1587 -> 1586;
1587 -> 1585;
1587 -> 1582;
1588 -> 1586;
1588 -> 1582;
1589 -> 1588;
1589 -> 1587;
1589 -> 1582;
1590 -> 1578;
1591 -> 1580;
1591 -> 1590;
1592 -> 1590;
1593 -> 1591;
1593 -> 1592;
1594 -> 1593;
1594 -> 1589;
1594 -> 1592;
1595 -> 1594;
1595 -> 1590;
1596 -> 1590;
1597 -> 1595;
1597 -> 1596;
1598 -> 1597;
1598 -> 1596;
1599 -> 1598;
1600 -> 1599;
1600 -> 1578;
1601 -> 1600;
1601 -> 1580;
1601 -> 1578;
1602 -> 1580;
1602 -> 1589;
1602 -> 0;
1602 -> 1578;
1603 -> 1602;
1603 -> 1580;
1603 -> 1578;
1604 -> 1576;
1604 -> 1572;
1605 -> 1576;
1605 -> 1572;
1606 -> 1572;
1607 -> 1574;
1607 -> 1606;
1607 -> 1572;
1608 -> 1572;
1609 -> 1575;
1609 -> 1608;
1609 -> 1572;
1610 -> 1575;
1610 -> 1609;
1611 -> 1576;
1611 -> 1610;
1611 -> 1589;
1611 -> 1601;
1611 -> 1603;
1611 -> 1604;
1611 -> 1605;
1611 -> 840;
1611 -> 1609;
1612 -> 1575;
1612 -> 1576;
1612 -> 1609;
1613 -> 1570;
1613 -> 1568;
1613 -> 1441;
1614 -> 1426;
1614 -> 1425;
1614 -> 1441;
1615 -> 1444;
1615 -> 1445;
1616 -> 1615;
1616 -> 1445;
1617 -> 1616;
1617 -> 1449;
1618 -> 1617;
1618 -> 1449;
1619 -> 1453;
1619 -> 1618;
1619 -> 1449;
1620 -> 1455;
1620 -> 1619;
1620 -> 1449;
1621 -> 1460;
1621 -> 1620;
1621 -> 1459;
1622 -> 1621;
1622 -> 1457;
1623 -> 1622;
1623 -> 1463;
1624 -> 1623;
1624 -> 1463;
1625 -> 1624;
1626 -> 1625;
1626 -> 1445;
1627 -> 1626;
1627 -> 1447;
1627 -> 1445;
1628 -> 1447;
1628 -> 1620;
1628 -> 0;
1628 -> 1445;
1629 -> 1628;
1629 -> 1447;
1629 -> 1445;
1630 -> 1444;
1630 -> 1614;
1630 -> 1441;
1631 -> 1430;
1631 -> 1429;
1631 -> 1441;
1632 -> 1476;
1632 -> 1477;
1633 -> 1632;
1633 -> 1477;
1634 -> 1633;
1634 -> 1483;
1635 -> 1634;
1635 -> 1483;
1636 -> 1635;
1636 -> 1487;
1637 -> 1636;
1637 -> 1487;
1638 -> 1491;
1638 -> 1637;
1638 -> 1487;
1639 -> 1493;
1639 -> 1638;
1639 -> 1487;
1640 -> 1498;
1640 -> 1639;
1640 -> 1497;
1641 -> 1640;
1641 -> 1495;
1642 -> 1641;
1642 -> 1501;
1643 -> 1642;
1643 -> 1501;
1644 -> 1643;
1645 -> 1644;
1645 -> 1483;
1646 -> 1645;
1646 -> 1485;
1646 -> 1483;
1647 -> 1485;
1647 -> 1639;
1647 -> 0;
1647 -> 1483;
1648 -> 1647;
1648 -> 1485;
1648 -> 1483;
1649 -> 1481;
1649 -> 1513;
1649 -> 1639;
1649 -> 1646;
1649 -> 1648;
1649 -> 1509;
1649 -> 1510;
1649 -> 1519;
1649 -> 1520;
1649 -> 1512;
1650 -> 1476;
1650 -> 1631;
1650 -> 1441;
1651 -> 1434;
1651 -> 1433;
1651 -> 1441;
1652 -> 1524;
1652 -> 1526;
1653 -> 1652;
1653 -> 1526;
1654 -> 1653;
1654 -> 1532;
1655 -> 1654;
1655 -> 1532;
1656 -> 1655;
1656 -> 1536;
1657 -> 1656;
1657 -> 1536;
1658 -> 1540;
1658 -> 1657;
1658 -> 1536;
1659 -> 1542;
1659 -> 1658;
1659 -> 1536;
1660 -> 1547;
1660 -> 1659;
1660 -> 1546;
1661 -> 1660;
1661 -> 1544;
1662 -> 1661;
1662 -> 1550;
1663 -> 1662;
1663 -> 1550;
1664 -> 1663;
1665 -> 1664;
1665 -> 1532;
1666 -> 1665;
1666 -> 1534;
1666 -> 1532;
1667 -> 1534;
1667 -> 1659;
1667 -> 0;
1667 -> 1532;
1668 -> 1667;
1668 -> 1534;
1668 -> 1532;
1669 -> 1530;
1669 -> 1564;
1669 -> 1659;
1669 -> 1666;
1669 -> 1668;
1669 -> 1558;
1669 -> 1559;
1669 -> 1565;
1669 -> 1566;
1669 -> 1563;
1670 -> 1524;
1670 -> 1651;
1670 -> 1441;
1671 -> 1438;
1671 -> 1437;
1671 -> 1441;
1672 -> 1570;
1672 -> 1572;
1673 -> 1672;
1673 -> 1572;
1674 -> 1673;
1674 -> 1578;
1675 -> 1674;
1675 -> 1578;
1676 -> 1675;
1676 -> 1582;
1677 -> 1676;
1677 -> 1582;
1678 -> 1586;
1678 -> 1677;
1678 -> 1582;
1679 -> 1588;
1679 -> 1678;
1679 -> 1582;
1680 -> 1593;
1680 -> 1679;
1680 -> 1592;
1681 -> 1680;
1681 -> 1590;
1682 -> 1681;
1682 -> 1596;
1683 -> 1682;
1683 -> 1596;
1684 -> 1683;
1685 -> 1684;
1685 -> 1578;
1686 -> 1685;
1686 -> 1580;
1686 -> 1578;
1687 -> 1580;
1687 -> 1679;
1687 -> 0;
1687 -> 1578;
1688 -> 1687;
1688 -> 1580;
1688 -> 1578;
1689 -> 1576;
1689 -> 1610;
1689 -> 1679;
1689 -> 1686;
1689 -> 1688;
1689 -> 1604;
1689 -> 1605;
1689 -> 1611;
1689 -> 1612;
1689 -> 1609;
1690 -> 1570;
1690 -> 1671;
1690 -> 1441;
1691 -> 1624;
1692 -> 1691;
1692 -> 1445;
1693 -> 1692;
1693 -> 1447;
1693 -> 1445;
1694 -> 1643;
1695 -> 1694;
1695 -> 1483;
1696 -> 1695;
1696 -> 1485;
1696 -> 1483;
1697 -> 1481;
1697 -> 1513;
1697 -> 1639;
1697 -> 1696;
1697 -> 1648;
1697 -> 1509;
1697 -> 1510;
1697 -> 1649;
1697 -> 1520;
1697 -> 1512;
1698 -> 1663;
1699 -> 1698;
1699 -> 1532;
1700 -> 1699;
1700 -> 1534;
1700 -> 1532;
1701 -> 1530;
1701 -> 1564;
1701 -> 1659;
1701 -> 1700;
1701 -> 1668;
1701 -> 1558;
1701 -> 1559;
1701 -> 1669;
1701 -> 1566;
1701 -> 1563;
1702 -> 1683;
1703 -> 1702;
1703 -> 1578;
1704 -> 1703;
1704 -> 1580;
1704 -> 1578;
1705 -> 1576;
1705 -> 1610;
1705 -> 1679;
1705 -> 1704;
1705 -> 1688;
1705 -> 1604;
1705 -> 1605;
1705 -> 1689;
1705 -> 1612;
1705 -> 1609;
1706 -> 1624;
1707 -> 1706;
1707 -> 1445;
1708 -> 1707;
1708 -> 1447;
1708 -> 1445;
1709 -> 1643;
1710 -> 1709;
1710 -> 1483;
1711 -> 1710;
1711 -> 1485;
1711 -> 1483;
1712 -> 1481;
1712 -> 1513;
1712 -> 1639;
1712 -> 1711;
1712 -> 1648;
1712 -> 1509;
1712 -> 1510;
1712 -> 1697;
1712 -> 1520;
1712 -> 1512;
1713 -> 1663;
1714 -> 1713;
1714 -> 1532;
1715 -> 1714;
1715 -> 1534;
1715 -> 1532;
1716 -> 1530;
1716 -> 1564;
1716 -> 1659;
1716 -> 1715;
1716 -> 1668;
1716 -> 1558;
1716 -> 1559;
1716 -> 1701;
1716 -> 1566;
1716 -> 1563;
1717 -> 1683;
1718 -> 1717;
1718 -> 1578;
1719 -> 1718;
1719 -> 1580;
1719 -> 1578;
1720 -> 1576;
1720 -> 1610;
1720 -> 1679;
1720 -> 1719;
1720 -> 1688;
1720 -> 1604;
1720 -> 1605;
1720 -> 1705;
1720 -> 1612;
1720 -> 1609;
1721 -> 1624;
1722 -> 1721;
1722 -> 1445;
1723 -> 1722;
1723 -> 1447;
1723 -> 1445;
1724 -> 1643;
1725 -> 1724;
1725 -> 1483;
1726 -> 1725;
1726 -> 1485;
1726 -> 1483;
1727 -> 1481;
1727 -> 1513;
1727 -> 1639;
1727 -> 1726;
1727 -> 1648;
1727 -> 1509;
1727 -> 1510;
1727 -> 1712;
1727 -> 1520;
1727 -> 1512;
1728 -> 1663;
1729 -> 1728;
1729 -> 1532;
1730 -> 1729;
1730 -> 1534;
1730 -> 1532;
1731 -> 1530;
1731 -> 1564;
1731 -> 1659;
1731 -> 1730;
1731 -> 1668;
1731 -> 1558;
1731 -> 1559;
1731 -> 1716;
1731 -> 1566;
1731 -> 1563;
1732 -> 1683;
1733 -> 1732;
1733 -> 1578;
1734 -> 1733;
1734 -> 1580;
1734 -> 1578;
1735 -> 1576;
1735 -> 1610;
1735 -> 1679;
1735 -> 1734;
1735 -> 1688;
1735 -> 1604;
1735 -> 1605;
1735 -> 1720;
1735 -> 1612;
1735 -> 1609;
1736 -> 1624;
1737 -> 1736;
1737 -> 1445;
1738 -> 1737;
1738 -> 1447;
1738 -> 1445;
1739 -> 1643;
1740 -> 1739;
1740 -> 1483;
1741 -> 1740;
1741 -> 1485;
1741 -> 1483;
1742 -> 1481;
1742 -> 1513;
1742 -> 1639;
1742 -> 1741;
1742 -> 1648;
1742 -> 1509;
1742 -> 1510;
1742 -> 1727;
1742 -> 1520;
1742 -> 1512;
1743 -> 1663;
1744 -> 1743;
1744 -> 1532;
1745 -> 1744;
1745 -> 1534;
1745 -> 1532;
1746 -> 1530;
1746 -> 1564;
1746 -> 1659;
1746 -> 1745;
1746 -> 1668;
1746 -> 1558;
1746 -> 1559;
1746 -> 1731;
1746 -> 1566;
1746 -> 1563;
1747 -> 1683;
1748 -> 1747;
1748 -> 1578;
1749 -> 1748;
1749 -> 1580;
1749 -> 1578;
1750 -> 1576;
1750 -> 1610;
1750 -> 1679;
1750 -> 1749;
1750 -> 1688;
1750 -> 1604;
1750 -> 1605;
1750 -> 1735;
1750 -> 1612;
1750 -> 1609;
1751 -> 1624;
1752 -> 1751;
1752 -> 1445;
1753 -> 1752;
1753 -> 1447;
1753 -> 1445;
1754 -> 1643;
1755 -> 1754;
1755 -> 1483;
1756 -> 1755;
1756 -> 1485;
1756 -> 1483;
1757 -> 1481;
1757 -> 1513;
1757 -> 1639;
1757 -> 1756;
1757 -> 1648;
1757 -> 1509;
1757 -> 1510;
1757 -> 1742;
1757 -> 1520;
1757 -> 1512;
1758 -> 1663;
1759 -> 1758;
1759 -> 1532;
1760 -> 1759;
1760 -> 1534;
1760 -> 1532;
1761 -> 1530;
1761 -> 1564;
1761 -> 1659;
1761 -> 1760;
1761 -> 1668;
1761 -> 1558;
1761 -> 1559;
1761 -> 1746;
1761 -> 1566;
1761 -> 1563;
1762 -> 1683;
1763 -> 1762;
1763 -> 1578;
1764 -> 1763;
1764 -> 1580;
1764 -> 1578;
1765 -> 1576;
1765 -> 1610;
1765 -> 1679;
1765 -> 1764;
1765 -> 1688;
1765 -> 1604;
1765 -> 1605;
1765 -> 1750;
1765 -> 1612;
1765 -> 1609;
1766 -> 1624;
1767 -> 1766;
1767 -> 1445;
1768 -> 1767;
1768 -> 1447;
1768 -> 1445;
1769 -> 1643;
1770 -> 1769;
1770 -> 1483;
1771 -> 1770;
1771 -> 1485;
1771 -> 1483;
1772 -> 1481;
1772 -> 1513;
1772 -> 1639;
1772 -> 1771;
1772 -> 1648;
1772 -> 1509;
1772 -> 1510;
1772 -> 1757;
1772 -> 1520;
1772 -> 1512;
1773 -> 1663;
1774 -> 1773;
1774 -> 1532;
1775 -> 1774;
1775 -> 1534;
1775 -> 1532;
1776 -> 1530;
1776 -> 1564;
1776 -> 1659;
1776 -> 1775;
1776 -> 1668;
1776 -> 1558;
1776 -> 1559;
1776 -> 1761;
1776 -> 1566;
1776 -> 1563;
1777 -> 1683;
1778 -> 1777;
1778 -> 1578;
1779 -> 1778;
1779 -> 1580;
1779 -> 1578;
1780 -> 1576;
1780 -> 1610;
1780 -> 1679;
1780 -> 1779;
1780 -> 1688;
1780 -> 1604;
1780 -> 1605;
1780 -> 1765;
1780 -> 1612;
1780 -> 1609;
1781 -> 1624;
1782 -> 1781;
1782 -> 1445;
1783 -> 1782;
1783 -> 1447;
1783 -> 1445;
1784 -> 1643;
1785 -> 1784;
1785 -> 1483;
1786 -> 1785;
1786 -> 1485;
1786 -> 1483;
1787 -> 1481;
1787 -> 1513;
1787 -> 1639;
1787 -> 1786;
1787 -> 1648;
1787 -> 1509;
1787 -> 1510;
1787 -> 1772;
1787 -> 1520;
1787 -> 1512;
1788 -> 1663;
1789 -> 1788;
1789 -> 1532;
1790 -> 1789;
1790 -> 1534;
1790 -> 1532;
1791 -> 1530;
1791 -> 1564;
1791 -> 1659;
1791 -> 1790;
1791 -> 1668;
1791 -> 1558;
1791 -> 1559;
1791 -> 1776;
1791 -> 1566;
1791 -> 1563;
1792 -> 1683;
1793 -> 1792;
1793 -> 1578;
1794 -> 1793;
1794 -> 1580;
1794 -> 1578;
1795 -> 1576;
1795 -> 1610;
1795 -> 1679;
1795 -> 1794;
1795 -> 1688;
1795 -> 1604;
1795 -> 1605;
1795 -> 1780;
1795 -> 1612;
1795 -> 1609;
1796 -> 1624;
1797 -> 1796;
1797 -> 1445;
1798 -> 1797;
1798 -> 1447;
1798 -> 1445;
1799 -> 1643;
1800 -> 1799;
1800 -> 1483;
1801 -> 1800;
1801 -> 1485;
1801 -> 1483;
1802 -> 1481;
1802 -> 1513;
1802 -> 1639;
1802 -> 1801;
1802 -> 1648;
1802 -> 1509;
1802 -> 1510;
1802 -> 1787;
1802 -> 1520;
1802 -> 1512;
1803 -> 1663;
1804 -> 1803;
1804 -> 1532;
1805 -> 1804;
1805 -> 1534;
1805 -> 1532;
1806 -> 1530;
1806 -> 1564;
1806 -> 1659;
1806 -> 1805;
1806 -> 1668;
1806 -> 1558;
1806 -> 1559;
1806 -> 1791;
1806 -> 1566;
1806 -> 1563;
1807 -> 1683;
1808 -> 1807;
1808 -> 1578;
1809 -> 1808;
1809 -> 1580;
1809 -> 1578;
1810 -> 1576;
1810 -> 1610;
1810 -> 1679;
1810 -> 1809;
1810 -> 1688;
1810 -> 1604;
1810 -> 1605;
1810 -> 1795;
1810 -> 1612;
1810 -> 1609;
1811 -> 1624;
1812 -> 1811;
1812 -> 1445;
1813 -> 1812;
1813 -> 1447;
1813 -> 1445;
1814 -> 1643;
1815 -> 1814;
1815 -> 1483;
1816 -> 1815;
1816 -> 1485;
1816 -> 1483;
1817 -> 1481;
1817 -> 1513;
1817 -> 1639;
1817 -> 1816;
1817 -> 1648;
1817 -> 1509;
1817 -> 1510;
1817 -> 1802;
1817 -> 1520;
1817 -> 1512;
1818 -> 1663;
1819 -> 1818;
1819 -> 1532;
1820 -> 1819;
1820 -> 1534;
1820 -> 1532;
1821 -> 1530;
1821 -> 1564;
1821 -> 1659;
1821 -> 1820;
1821 -> 1668;
1821 -> 1558;
1821 -> 1559;
1821 -> 1806;
1821 -> 1566;
1821 -> 1563;
1822 -> 1683;
1823 -> 1822;
1823 -> 1578;
1824 -> 1823;
1824 -> 1580;
1824 -> 1578;
1825 -> 1576;
1825 -> 1610;
1825 -> 1679;
1825 -> 1824;
1825 -> 1688;
1825 -> 1604;
1825 -> 1605;
1825 -> 1810;
1825 -> 1612;
1825 -> 1609;
1826 -> 1624;
1827 -> 1826;
1827 -> 1445;
1828 -> 1827;
1828 -> 1447;
1828 -> 1445;
1829 -> 1643;
1830 -> 1829;
1830 -> 1483;
1831 -> 1830;
1831 -> 1485;
1831 -> 1483;
1832 -> 1481;
1832 -> 1513;
1832 -> 1639;
1832 -> 1831;
1832 -> 1648;
1832 -> 1509;
1832 -> 1510;
1832 -> 1817;
1832 -> 1520;
1832 -> 1512;
1833 -> 1663;
1834 -> 1833;
1834 -> 1532;
1835 -> 1834;
1835 -> 1534;
1835 -> 1532;
1836 -> 1530;
1836 -> 1564;
1836 -> 1659;
1836 -> 1835;
1836 -> 1668;
1836 -> 1558;
1836 -> 1559;
1836 -> 1821;
1836 -> 1566;
1836 -> 1563;
1837 -> 1683;
1838 -> 1837;
1838 -> 1578;
1839 -> 1838;
1839 -> 1580;
1839 -> 1578;
1840 -> 1576;
1840 -> 1610;
1840 -> 1679;
1840 -> 1839;
1840 -> 1688;
1840 -> 1604;
1840 -> 1605;
1840 -> 1825;
1840 -> 1612;
1840 -> 1609;
1841 -> 1624;
1842 -> 1841;
1842 -> 1445;
1843 -> 1842;
1843 -> 1447;
1843 -> 1445;
1844 -> 1643;
1845 -> 1844;
1845 -> 1483;
1846 -> 1845;
1846 -> 1485;
1846 -> 1483;
1847 -> 1481;
1847 -> 1513;
1847 -> 1639;
1847 -> 1846;
1847 -> 1648;
1847 -> 1509;
1847 -> 1510;
1847 -> 1832;
1847 -> 1520;
1847 -> 1512;
1848 -> 1663;
1849 -> 1848;
1849 -> 1532;
1850 -> 1849;
1850 -> 1534;
1850 -> 1532;
1851 -> 1530;
1851 -> 1564;
1851 -> 1659;
1851 -> 1850;
1851 -> 1668;
1851 -> 1558;
1851 -> 1559;
1851 -> 1836;
1851 -> 1566;
1851 -> 1563;
1852 -> 1683;
1853 -> 1852;
1853 -> 1578;
1854 -> 1853;
1854 -> 1580;
1854 -> 1578;
1855 -> 1576;
1855 -> 1610;
1855 -> 1679;
1855 -> 1854;
1855 -> 1688;
1855 -> 1604;
1855 -> 1605;
1855 -> 1840;
1855 -> 1612;
1855 -> 1609;
1856 -> 1624;
1857 -> 1856;
1857 -> 1445;
1858 -> 1857;
1858 -> 1447;
1858 -> 1445;
1859 -> 1643;
1860 -> 1859;
1860 -> 1483;
1861 -> 1860;
1861 -> 1485;
1861 -> 1483;
1862 -> 1481;
1862 -> 1513;
1862 -> 1639;
1862 -> 1861;
1862 -> 1648;
1862 -> 1509;
1862 -> 1510;
1862 -> 1847;
1862 -> 1520;
1862 -> 1512;
1863 -> 1663;
1864 -> 1863;
1864 -> 1532;
1865 -> 1864;
1865 -> 1534;
1865 -> 1532;
1866 -> 1530;
1866 -> 1564;
1866 -> 1659;
1866 -> 1865;
1866 -> 1668;
1866 -> 1558;
1866 -> 1559;
1866 -> 1851;
1866 -> 1566;
1866 -> 1563;
1867 -> 1683;
1868 -> 1867;
1868 -> 1578;
1869 -> 1868;
1869 -> 1580;
1869 -> 1578;
1870 -> 1576;
1870 -> 1610;
1870 -> 1679;
1870 -> 1869;
1870 -> 1688;
1870 -> 1604;
1870 -> 1605;
1870 -> 1855;
1870 -> 1612;
1870 -> 1609;
1871 -> 1624;
1872 -> 1871;
1872 -> 1445;
1873 -> 1872;
1873 -> 1447;
1873 -> 1445;
1874 -> 1643;
1875 -> 1874;
1875 -> 1483;
1876 -> 1875;
1876 -> 1485;
1876 -> 1483;
1877 -> 1481;
1877 -> 1513;
1877 -> 1639;
1877 -> 1876;
1877 -> 1648;
1877 -> 1509;
1877 -> 1510;
1877 -> 1862;
1877 -> 1520;
1877 -> 1512;
1878 -> 1663;
1879 -> 1878;
1879 -> 1532;
1880 -> 1879;
1880 -> 1534;
1880 -> 1532;
1881 -> 1530;
1881 -> 1564;
1881 -> 1659;
1881 -> 1880;
1881 -> 1668;
1881 -> 1558;
1881 -> 1559;
1881 -> 1866;
1881 -> 1566;
1881 -> 1563;
1882 -> 1683;
1883 -> 1882;
1883 -> 1578;
1884 -> 1883;
1884 -> 1580;
1884 -> 1578;
1885 -> 1576;
1885 -> 1610;
1885 -> 1679;
1885 -> 1884;
1885 -> 1688;
1885 -> 1604;
1885 -> 1605;
1885 -> 1870;
1885 -> 1612;
1885 -> 1609;
1886 -> 1624;
1887 -> 1886;
1887 -> 1445;
1888 -> 1887;
1888 -> 1447;
1888 -> 1445;
1889 -> 1643;
1890 -> 1889;
1890 -> 1483;
1891 -> 1890;
1891 -> 1485;
1891 -> 1483;
1892 -> 1481;
1892 -> 1513;
1892 -> 1639;
1892 -> 1891;
1892 -> 1648;
1892 -> 1509;
1892 -> 1510;
1892 -> 1877;
1892 -> 1520;
1892 -> 1512;
1893 -> 1663;
1894 -> 1893;
1894 -> 1532;
1895 -> 1894;
1895 -> 1534;
1895 -> 1532;
1896 -> 1530;
1896 -> 1564;
1896 -> 1659;
1896 -> 1895;
1896 -> 1668;
1896 -> 1558;
1896 -> 1559;
1896 -> 1881;
1896 -> 1566;
1896 -> 1563;
1897 -> 1683;
1898 -> 1897;
1898 -> 1578;
1899 -> 1898;
1899 -> 1580;
1899 -> 1578;
1900 -> 1576;
1900 -> 1610;
1900 -> 1679;
1900 -> 1899;
1900 -> 1688;
1900 -> 1604;
1900 -> 1605;
1900 -> 1885;
1900 -> 1612;
1900 -> 1609;
1901 -> 1624;
1902 -> 1901;
1902 -> 1445;
1903 -> 1902;
1903 -> 1447;
1903 -> 1445;
1904 -> 1643;
1905 -> 1904;
1905 -> 1483;
1906 -> 1905;
1906 -> 1485;
1906 -> 1483;
1907 -> 1481;
1907 -> 1513;
1907 -> 1639;
1907 -> 1906;
1907 -> 1648;
1907 -> 1509;
1907 -> 1510;
1907 -> 1892;
1907 -> 1520;
1907 -> 1512;
1908 -> 1663;
1909 -> 1908;
1909 -> 1532;
1910 -> 1909;
1910 -> 1534;
1910 -> 1532;
1911 -> 1530;
1911 -> 1564;
1911 -> 1659;
1911 -> 1910;
1911 -> 1668;
1911 -> 1558;
1911 -> 1559;
1911 -> 1896;
1911 -> 1566;
1911 -> 1563;
1912 -> 1683;
1913 -> 1912;
1913 -> 1578;
1914 -> 1913;
1914 -> 1580;
1914 -> 1578;
1915 -> 1576;
1915 -> 1610;
1915 -> 1679;
1915 -> 1914;
1915 -> 1688;
1915 -> 1604;
1915 -> 1605;
1915 -> 1900;
1915 -> 1612;
1915 -> 1609;
1916 -> 1624;
1917 -> 1916;
1917 -> 1445;
1918 -> 1917;
1918 -> 1447;
1918 -> 1445;
1919 -> 1643;
1920 -> 1919;
1920 -> 1483;
1921 -> 1920;
1921 -> 1485;
1921 -> 1483;
1922 -> 1481;
1922 -> 1513;
1922 -> 1639;
1922 -> 1921;
1922 -> 1648;
1922 -> 1509;
1922 -> 1510;
1922 -> 1907;
1922 -> 1520;
1922 -> 1512;
1923 -> 1663;
1924 -> 1923;
1924 -> 1532;
1925 -> 1924;
1925 -> 1534;
1925 -> 1532;
1926 -> 1530;
1926 -> 1564;
1926 -> 1659;
1926 -> 1925;
1926 -> 1668;
1926 -> 1558;
1926 -> 1559;
1926 -> 1911;
1926 -> 1566;
1926 -> 1563;
1927 -> 1683;
1928 -> 1927;
1928 -> 1578;
1929 -> 1928;
1929 -> 1580;
1929 -> 1578;
1930 -> 1576;
1930 -> 1610;
1930 -> 1679;
1930 -> 1929;
1930 -> 1688;
1930 -> 1604;
1930 -> 1605;
1930 -> 1915;
1930 -> 1612;
1930 -> 1609;
1931 -> 1624;
1932 -> 1931;
1932 -> 1445;
1933 -> 1932;
1933 -> 1447;
1933 -> 1445;
1934 -> 1643;
1935 -> 1934;
1935 -> 1483;
1936 -> 1935;
1936 -> 1485;
1936 -> 1483;
1937 -> 1481;
1937 -> 1513;
1937 -> 1639;
1937 -> 1936;
1937 -> 1648;
1937 -> 1509;
1937 -> 1510;
1937 -> 1922;
1937 -> 1520;
1937 -> 1512;
1938 -> 1663;
1939 -> 1938;
1939 -> 1532;
1940 -> 1939;
1940 -> 1534;
1940 -> 1532;
1941 -> 1530;
1941 -> 1564;
1941 -> 1659;
1941 -> 1940;
1941 -> 1668;
1941 -> 1558;
1941 -> 1559;
1941 -> 1926;
1941 -> 1566;
1941 -> 1563;
1942 -> 1683;
1943 -> 1942;
1943 -> 1578;
1944 -> 1943;
1944 -> 1580;
1944 -> 1578;
1945 -> 1576;
1945 -> 1610;
1945 -> 1679;
1945 -> 1944;
1945 -> 1688;
1945 -> 1604;
1945 -> 1605;
1945 -> 1930;
1945 -> 1612;
1945 -> 1609;
1946 -> 1624;
1947 -> 1946;
1947 -> 1445;
1948 -> 1947;
1948 -> 1447;
1948 -> 1445;
1949 -> 1643;
1950 -> 1949;
1950 -> 1483;
1951 -> 1950;
1951 -> 1485;
1951 -> 1483;
1952 -> 1481;
1952 -> 1513;
1952 -> 1639;
1952 -> 1951;
1952 -> 1648;
1952 -> 1509;
1952 -> 1510;
1952 -> 1937;
1952 -> 1520;
1952 -> 1512;
1953 -> 1663;
1954 -> 1953;
1954 -> 1532;
1955 -> 1954;
1955 -> 1534;
1955 -> 1532;
1956 -> 1530;
1956 -> 1564;
1956 -> 1659;
1956 -> 1955;
1956 -> 1668;
1956 -> 1558;
1956 -> 1559;
1956 -> 1941;
1956 -> 1566;
1956 -> 1563;
1957 -> 1683;
1958 -> 1957;
1958 -> 1578;
1959 -> 1958;
1959 -> 1580;
1959 -> 1578;
1960 -> 1576;
1960 -> 1610;
1960 -> 1679;
1960 -> 1959;
1960 -> 1688;
1960 -> 1604;
1960 -> 1605;
1960 -> 1945;
1960 -> 1612;
1960 -> 1609;
1961 -> 1624;
1962 -> 1961;
1962 -> 1445;
1963 -> 1962;
1963 -> 1447;
1963 -> 1445;
1964 -> 1643;
1965 -> 1964;
1965 -> 1483;
1966 -> 1965;
1966 -> 1485;
1966 -> 1483;
1967 -> 1481;
1967 -> 1513;
1967 -> 1639;
1967 -> 1966;
1967 -> 1648;
1967 -> 1509;
1967 -> 1510;
1967 -> 1952;
1967 -> 1520;
1967 -> 1512;
1968 -> 1663;
1969 -> 1968;
1969 -> 1532;
1970 -> 1969;
1970 -> 1534;
1970 -> 1532;
1971 -> 1530;
1971 -> 1564;
1971 -> 1659;
1971 -> 1970;
1971 -> 1668;
1971 -> 1558;
1971 -> 1559;
1971 -> 1956;
1971 -> 1566;
1971 -> 1563;
1972 -> 1683;
1973 -> 1972;
1973 -> 1578;
1974 -> 1973;
1974 -> 1580;
1974 -> 1578;
1975 -> 1576;
1975 -> 1610;
1975 -> 1679;
1975 -> 1974;
1975 -> 1688;
1975 -> 1604;
1975 -> 1605;
1975 -> 1960;
1975 -> 1612;
1975 -> 1609;
1976 -> 1624;
1977 -> 1976;
1977 -> 1445;
1978 -> 1977;
1978 -> 1447;
1978 -> 1445;
1979 -> 1643;
1980 -> 1979;
1980 -> 1483;
1981 -> 1980;
1981 -> 1485;
1981 -> 1483;
1982 -> 1481;
1982 -> 1513;
1982 -> 1639;
1982 -> 1981;
1982 -> 1648;
1982 -> 1509;
1982 -> 1510;
1982 -> 1967;
1982 -> 1520;
1982 -> 1512;
1983 -> 1663;
1984 -> 1983;
1984 -> 1532;
1985 -> 1984;
1985 -> 1534;
1985 -> 1532;
1986 -> 1530;
1986 -> 1564;
1986 -> 1659;
1986 -> 1985;
1986 -> 1668;
1986 -> 1558;
1986 -> 1559;
1986 -> 1971;
1986 -> 1566;
1986 -> 1563;
1987 -> 1683;
1988 -> 1987;
1988 -> 1578;
1989 -> 1988;
1989 -> 1580;
1989 -> 1578;
1990 -> 1576;
1990 -> 1610;
1990 -> 1679;
1990 -> 1989;
1990 -> 1688;
1990 -> 1604;
1990 -> 1605;
1990 -> 1975;
1990 -> 1612;
1990 -> 1609;
1991 -> 1624;
1992 -> 1991;
1992 -> 1445;
1993 -> 1992;
1993 -> 1447;
1993 -> 1445;
1994 -> 1643;
1995 -> 1994;
1995 -> 1483;
1996 -> 1995;
1996 -> 1485;
1996 -> 1483;
1997 -> 1481;
1997 -> 1513;
1997 -> 1639;
1997 -> 1996;
1997 -> 1648;
1997 -> 1509;
1997 -> 1510;
1997 -> 1982;
1997 -> 1520;
1997 -> 1512;
1998 -> 1663;
1999 -> 1998;
1999 -> 1532;
2000 -> 1999;
2000 -> 1534;
2000 -> 1532;
2001 -> 1530;
2001 -> 1564;
2001 -> 1659;
2001 -> 2000;
2001 -> 1668;
2001 -> 1558;
2001 -> 1559;
2001 -> 1986;
2001 -> 1566;
2001 -> 1563;
2002 -> 1683;
2003 -> 2002;
2003 -> 1578;
2004 -> 2003;
2004 -> 1580;
2004 -> 1578;
2005 -> 1576;
2005 -> 1610;
2005 -> 1679;
2005 -> 2004;
2005 -> 1688;
2005 -> 1604;
2005 -> 1605;
2005 -> 1990;
2005 -> 1612;
2005 -> 1609;
2006 -> 1624;
2007 -> 2006;
2007 -> 1445;
2008 -> 2007;
2008 -> 1447;
2008 -> 1445;
2009 -> 1643;
2010 -> 2009;
2010 -> 1483;
2011 -> 2010;
2011 -> 1485;
2011 -> 1483;
2012 -> 1481;
2012 -> 1513;
2012 -> 1639;
2012 -> 2011;
2012 -> 1648;
2012 -> 1509;
2012 -> 1510;
2012 -> 1997;
2012 -> 1520;
2012 -> 1512;
2013 -> 1663;
2014 -> 2013;
2014 -> 1532;
2015 -> 2014;
2015 -> 1534;
2015 -> 1532;
2016 -> 1530;
2016 -> 1564;
2016 -> 1659;
2016 -> 2015;
2016 -> 1668;
2016 -> 1558;
2016 -> 1559;
2016 -> 2001;
2016 -> 1566;
2016 -> 1563;
2017 -> 1683;
2018 -> 2017;
2018 -> 1578;
2019 -> 2018;
2019 -> 1580;
2019 -> 1578;
2020 -> 1576;
2020 -> 1610;
2020 -> 1679;
2020 -> 2019;
2020 -> 1688;
2020 -> 1604;
2020 -> 1605;
2020 -> 2005;
2020 -> 1612;
2020 -> 1609;
2021 -> 1624;
2022 -> 2021;
2022 -> 1445;
2023 -> 2022;
2023 -> 1447;
2023 -> 1445;
2024 -> 1643;
2025 -> 2024;
2025 -> 1483;
2026 -> 2025;
2026 -> 1485;
2026 -> 1483;
2027 -> 1481;
2027 -> 1513;
2027 -> 1639;
2027 -> 2026;
2027 -> 1648;
2027 -> 1509;
2027 -> 1510;
2027 -> 2012;
2027 -> 1520;
2027 -> 1512;
2028 -> 1663;
2029 -> 2028;
2029 -> 1532;
2030 -> 2029;
2030 -> 1534;
2030 -> 1532;
2031 -> 1530;
2031 -> 1564;
2031 -> 1659;
2031 -> 2030;
2031 -> 1668;
2031 -> 1558;
2031 -> 1559;
2031 -> 2016;
2031 -> 1566;
2031 -> 1563;
2032 -> 1683;
2033 -> 2032;
2033 -> 1578;
2034 -> 2033;
2034 -> 1580;
2034 -> 1578;
2035 -> 1576;
2035 -> 1610;
2035 -> 1679;
2035 -> 2034;
2035 -> 1688;
2035 -> 1604;
2035 -> 1605;
2035 -> 2020;
2035 -> 1612;
2035 -> 1609;
2036 -> 1624;
2037 -> 2036;
2037 -> 1445;
2038 -> 2037;
2038 -> 1447;
2038 -> 1445;
2039 -> 1643;
2040 -> 2039;
2040 -> 1483;
2041 -> 2040;
2041 -> 1485;
2041 -> 1483;
2042 -> 1481;
2042 -> 1513;
2042 -> 1639;
2042 -> 2041;
2042 -> 1648;
2042 -> 1509;
2042 -> 1510;
2042 -> 2027;
2042 -> 1520;
2042 -> 1512;
2043 -> 1663;
2044 -> 2043;
2044 -> 1532;
2045 -> 2044;
2045 -> 1534;
2045 -> 1532;
2046 -> 1530;
2046 -> 1564;
2046 -> 1659;
2046 -> 2045;
2046 -> 1668;
2046 -> 1558;
2046 -> 1559;
2046 -> 2031;
2046 -> 1566;
2046 -> 1563;
2047 -> 1683;
2048 -> 2047;
2048 -> 1578;
2049 -> 2048;
2049 -> 1580;
2049 -> 1578;
2050 -> 1576;
2050 -> 1610;
2050 -> 1679;
2050 -> 2049;
2050 -> 1688;
2050 -> 1604;
2050 -> 1605;
2050 -> 2035;
2050 -> 1612;
2050 -> 1609;
2051 -> 1624;
2052 -> 2051;
2052 -> 1445;
2053 -> 2052;
2053 -> 1447;
2053 -> 1445;
2054 -> 1643;
2055 -> 2054;
2055 -> 1483;
2056 -> 2055;
2056 -> 1485;
2056 -> 1483;
2057 -> 1481;
2057 -> 1513;
2057 -> 1639;
2057 -> 2056;
2057 -> 1648;
2057 -> 1509;
2057 -> 1510;
2057 -> 2042;
2057 -> 1520;
2057 -> 1512;
2058 -> 1663;
2059 -> 2058;
2059 -> 1532;
2060 -> 2059;
2060 -> 1534;
2060 -> 1532;
2061 -> 1530;
2061 -> 1564;
2061 -> 1659;
2061 -> 2060;
2061 -> 1668;
2061 -> 1558;
2061 -> 1559;
2061 -> 2046;
2061 -> 1566;
2061 -> 1563;
2062 -> 1683;
2063 -> 2062;
2063 -> 1578;
2064 -> 2063;
2064 -> 1580;
2064 -> 1578;
2065 -> 1576;
2065 -> 1610;
2065 -> 1679;
2065 -> 2064;
2065 -> 1688;
2065 -> 1604;
2065 -> 1605;
2065 -> 2050;
2065 -> 1612;
2065 -> 1609;
2066 -> 1624;
2067 -> 2066;
2067 -> 1445;
2068 -> 2067;
2068 -> 1447;
2068 -> 1445;
2069 -> 1643;
2070 -> 2069;
2070 -> 1483;
2071 -> 2070;
2071 -> 1485;
2071 -> 1483;
2072 -> 1481;
2072 -> 1513;
2072 -> 1639;
2072 -> 2071;
2072 -> 1648;
2072 -> 1509;
2072 -> 1510;
2072 -> 2057;
2072 -> 1520;
2072 -> 1512;
2073 -> 1663;
2074 -> 2073;
2074 -> 1532;
2075 -> 2074;
2075 -> 1534;
2075 -> 1532;
2076 -> 1530;
2076 -> 1564;
2076 -> 1659;
2076 -> 2075;
2076 -> 1668;
2076 -> 1558;
2076 -> 1559;
2076 -> 2061;
2076 -> 1566;
2076 -> 1563;
2077 -> 1683;
2078 -> 2077;
2078 -> 1578;
2079 -> 2078;
2079 -> 1580;
2079 -> 1578;
2080 -> 1576;
2080 -> 1610;
2080 -> 1679;
2080 -> 2079;
2080 -> 1688;
2080 -> 1604;
2080 -> 1605;
2080 -> 2065;
2080 -> 1612;
2080 -> 1609;
2081 -> 1624;
2082 -> 2081;
2082 -> 1445;
2083 -> 2082;
2083 -> 1447;
2083 -> 1445;
2084 -> 1643;
2085 -> 2084;
2085 -> 1483;
2086 -> 2085;
2086 -> 1485;
2086 -> 1483;
2087 -> 1481;
2087 -> 1513;
2087 -> 1639;
2087 -> 2086;
2087 -> 1648;
2087 -> 1509;
2087 -> 1510;
2087 -> 2072;
2087 -> 1520;
2087 -> 1512;
2088 -> 1663;
2089 -> 2088;
2089 -> 1532;
2090 -> 2089;
2090 -> 1534;
2090 -> 1532;
2091 -> 1530;
2091 -> 1564;
2091 -> 1659;
2091 -> 2090;
2091 -> 1668;
2091 -> 1558;
2091 -> 1559;
2091 -> 2076;
2091 -> 1566;
2091 -> 1563;
2092 -> 1683;
2093 -> 2092;
2093 -> 1578;
2094 -> 2093;
2094 -> 1580;
2094 -> 1578;
2095 -> 1576;
2095 -> 1610;
2095 -> 1679;
2095 -> 2094;
2095 -> 1688;
2095 -> 1604;
2095 -> 1605;
2095 -> 2080;
2095 -> 1612;
2095 -> 1609;
2096 -> 1624;
2097 -> 2096;
2097 -> 1445;
2098 -> 2097;
2098 -> 1447;
2098 -> 1445;
2099 -> 1643;
2100 -> 2099;
2100 -> 1483;
2101 -> 2100;
2101 -> 1485;
2101 -> 1483;
2102 -> 1481;
2102 -> 1513;
2102 -> 1639;
2102 -> 2101;
2102 -> 1648;
2102 -> 1509;
2102 -> 1510;
2102 -> 2087;
2102 -> 1520;
2102 -> 1512;
2103 -> 1663;
2104 -> 2103;
2104 -> 1532;
2105 -> 2104;
2105 -> 1534;
2105 -> 1532;
2106 -> 1530;
2106 -> 1564;
2106 -> 1659;
2106 -> 2105;
2106 -> 1668;
2106 -> 1558;
2106 -> 1559;
2106 -> 2091;
2106 -> 1566;
2106 -> 1563;
2107 -> 1683;
2108 -> 2107;
2108 -> 1578;
2109 -> 2108;
2109 -> 1580;
2109 -> 1578;
2110 -> 1576;
2110 -> 1610;
2110 -> 1679;
2110 -> 2109;
2110 -> 1688;
2110 -> 1604;
2110 -> 1605;
2110 -> 2095;
2110 -> 1612;
2110 -> 1609;
2111 -> 0;
2111 -> 1624;
2112 -> 2111;
2112 -> 1445;
2113 -> 2112;
2113 -> 1447;
2113 -> 1445;
2114 -> 0;
2114 -> 1643;
2115 -> 2114;
2115 -> 1483;
2116 -> 2115;
2116 -> 1485;
2116 -> 1483;
2117 -> 1481;
2117 -> 1513;
2117 -> 1639;
2117 -> 2116;
2117 -> 1648;
2117 -> 1509;
2117 -> 1510;
2117 -> 2102;
2117 -> 1520;
2117 -> 1512;
2118 -> 0;
2118 -> 1663;
2119 -> 2118;
2119 -> 1532;
2120 -> 2119;
2120 -> 1534;
2120 -> 1532;
2121 -> 1530;
2121 -> 1564;
2121 -> 1659;
2121 -> 2120;
2121 -> 1668;
2121 -> 1558;
2121 -> 1559;
2121 -> 2106;
2121 -> 1566;
2121 -> 1563;
2122 -> 0;
2122 -> 1683;
2123 -> 2122;
2123 -> 1578;
2124 -> 2123;
2124 -> 1580;
2124 -> 1578;
2125 -> 1576;
2125 -> 1610;
2125 -> 1679;
2125 -> 2124;
2125 -> 1688;
2125 -> 1604;
2125 -> 1605;
2125 -> 2110;
2125 -> 1612;
2125 -> 1609;
2126 -> 1624;
2127 -> 2126;
2127 -> 1445;
2128 -> 2127;
2128 -> 1447;
2128 -> 1445;
2129 -> 1643;
2130 -> 2129;
2130 -> 1483;
2131 -> 2130;
2131 -> 1485;
2131 -> 1483;
2132 -> 1481;
2132 -> 1513;
2132 -> 1639;
2132 -> 2131;
2132 -> 1648;
2132 -> 1509;
2132 -> 1510;
2132 -> 2117;
2132 -> 1520;
2132 -> 1512;
2133 -> 1663;
2134 -> 2133;
2134 -> 1532;
2135 -> 2134;
2135 -> 1534;
2135 -> 1532;
2136 -> 1530;
2136 -> 1564;
2136 -> 1659;
2136 -> 2135;
2136 -> 1668;
2136 -> 1558;
2136 -> 1559;
2136 -> 2121;
2136 -> 1566;
2136 -> 1563;
2137 -> 1683;
2138 -> 2137;
2138 -> 1578;
2139 -> 2138;
2139 -> 1580;
2139 -> 1578;
2140 -> 1576;
2140 -> 1610;
2140 -> 1679;
2140 -> 2139;
2140 -> 1688;
2140 -> 1604;
2140 -> 1605;
2140 -> 2125;
2140 -> 1612;
2140 -> 1609;
2141 -> 1624;
2142 -> 2141;
2142 -> 1445;
2143 -> 2142;
2143 -> 1447;
2143 -> 1445;
2144 -> 1643;
2145 -> 2144;
2145 -> 1483;
2146 -> 2145;
2146 -> 1485;
2146 -> 1483;
2147 -> 1481;
2147 -> 1513;
2147 -> 1639;
2147 -> 2146;
2147 -> 1648;
2147 -> 1509;
2147 -> 1510;
2147 -> 2132;
2147 -> 1520;
2147 -> 1512;
2148 -> 1663;
2149 -> 2148;
2149 -> 1532;
2150 -> 2149;
2150 -> 1534;
2150 -> 1532;
2151 -> 1530;
2151 -> 1564;
2151 -> 1659;
2151 -> 2150;
2151 -> 1668;
2151 -> 1558;
2151 -> 1559;
2151 -> 2136;
2151 -> 1566;
2151 -> 1563;
2152 -> 1683;
2153 -> 2152;
2153 -> 1578;
2154 -> 2153;
2154 -> 1580;
2154 -> 1578;
2155 -> 1576;
2155 -> 1610;
2155 -> 1679;
2155 -> 2154;
2155 -> 1688;
2155 -> 1604;
2155 -> 1605;
2155 -> 2140;
2155 -> 1612;
2155 -> 1609;
2156 -> 1624;
2157 -> 2156;
2157 -> 1445;
2158 -> 2157;
2158 -> 1447;
2158 -> 1445;
2159 -> 1643;
2160 -> 2159;
2160 -> 1483;
2161 -> 2160;
2161 -> 1485;
2161 -> 1483;
2162 -> 1481;
2162 -> 1513;
2162 -> 1639;
2162 -> 2161;
2162 -> 1648;
2162 -> 1509;
2162 -> 1510;
2162 -> 2147;
2162 -> 1520;
2162 -> 1512;
2163 -> 1663;
2164 -> 2163;
2164 -> 1532;
2165 -> 2164;
2165 -> 1534;
2165 -> 1532;
2166 -> 1530;
2166 -> 1564;
2166 -> 1659;
2166 -> 2165;
2166 -> 1668;
2166 -> 1558;
2166 -> 1559;
2166 -> 2151;
2166 -> 1566;
2166 -> 1563;
2167 -> 1683;
2168 -> 2167;
2168 -> 1578;
2169 -> 2168;
2169 -> 1580;
2169 -> 1578;
2170 -> 1576;
2170 -> 1610;
2170 -> 1679;
2170 -> 2169;
2170 -> 1688;
2170 -> 1604;
2170 -> 1605;
2170 -> 2155;
2170 -> 1612;
2170 -> 1609;
2171 -> 1624;
2172 -> 2171;
2172 -> 1445;
2173 -> 2172;
2173 -> 1447;
2173 -> 1445;
2174 -> 1643;
2175 -> 2174;
2175 -> 1483;
2176 -> 2175;
2176 -> 1485;
2176 -> 1483;
2177 -> 1481;
2177 -> 1513;
2177 -> 1639;
2177 -> 2176;
2177 -> 1648;
2177 -> 1509;
2177 -> 1510;
2177 -> 2162;
2177 -> 1520;
2177 -> 1512;
2178 -> 1663;
2179 -> 2178;
2179 -> 1532;
2180 -> 2179;
2180 -> 1534;
2180 -> 1532;
2181 -> 1530;
2181 -> 1564;
2181 -> 1659;
2181 -> 2180;
2181 -> 1668;
2181 -> 1558;
2181 -> 1559;
2181 -> 2166;
2181 -> 1566;
2181 -> 1563;
2182 -> 1683;
2183 -> 2182;
2183 -> 1578;
2184 -> 2183;
2184 -> 1580;
2184 -> 1578;
2185 -> 1576;
2185 -> 1610;
2185 -> 1679;
2185 -> 2184;
2185 -> 1688;
2185 -> 1604;
2185 -> 1605;
2185 -> 2170;
2185 -> 1612;
2185 -> 1609;
2186 -> 1624;
2187 -> 2186;
2187 -> 1445;
2188 -> 2187;
2188 -> 1447;
2188 -> 1445;
2189 -> 1643;
2190 -> 2189;
2190 -> 1483;
2191 -> 2190;
2191 -> 1485;
2191 -> 1483;
2192 -> 1481;
2192 -> 1513;
2192 -> 1639;
2192 -> 2191;
2192 -> 1648;
2192 -> 1509;
2192 -> 1510;
2192 -> 2177;
2192 -> 1520;
2192 -> 1512;
2193 -> 1663;
2194 -> 2193;
2194 -> 1532;
2195 -> 2194;
2195 -> 1534;
2195 -> 1532;
2196 -> 1530;
2196 -> 1564;
2196 -> 1659;
2196 -> 2195;
2196 -> 1668;
2196 -> 1558;
2196 -> 1559;
2196 -> 2181;
2196 -> 1566;
2196 -> 1563;
2197 -> 1683;
2198 -> 2197;
2198 -> 1578;
2199 -> 2198;
2199 -> 1580;
2199 -> 1578;
2200 -> 1576;
2200 -> 1610;
2200 -> 1679;
2200 -> 2199;
2200 -> 1688;
2200 -> 1604;
2200 -> 1605;
2200 -> 2185;
2200 -> 1612;
2200 -> 1609;
2201 -> 1624;
2202 -> 2201;
2202 -> 1445;
2203 -> 2202;
2203 -> 1447;
2203 -> 1445;
2204 -> 1643;
2205 -> 2204;
2205 -> 1483;
2206 -> 2205;
2206 -> 1485;
2206 -> 1483;
2207 -> 1481;
2207 -> 1513;
2207 -> 1639;
2207 -> 2206;
2207 -> 1648;
2207 -> 1509;
2207 -> 1510;
2207 -> 2192;
2207 -> 1520;
2207 -> 1512;
2208 -> 1663;
2209 -> 2208;
2209 -> 1532;
2210 -> 2209;
2210 -> 1534;
2210 -> 1532;
2211 -> 1530;
2211 -> 1564;
2211 -> 1659;
2211 -> 2210;
2211 -> 1668;
2211 -> 1558;
2211 -> 1559;
2211 -> 2196;
2211 -> 1566;
2211 -> 1563;
2212 -> 1683;
2213 -> 2212;
2213 -> 1578;
2214 -> 2213;
2214 -> 1580;
2214 -> 1578;
2215 -> 1576;
2215 -> 1610;
2215 -> 1679;
2215 -> 2214;
2215 -> 1688;
2215 -> 1604;
2215 -> 1605;
2215 -> 2200;
2215 -> 1612;
2215 -> 1609;
2216 -> 1624;
2217 -> 2216;
2217 -> 1445;
2218 -> 2217;
2218 -> 1447;
2218 -> 1445;
2219 -> 1643;
2220 -> 2219;
2220 -> 1483;
2221 -> 2220;
2221 -> 1485;
2221 -> 1483;
2222 -> 1481;
2222 -> 1513;
2222 -> 1639;
2222 -> 2221;
2222 -> 1648;
2222 -> 1509;
2222 -> 1510;
2222 -> 2207;
2222 -> 1520;
2222 -> 1512;
2223 -> 1663;
2224 -> 2223;
2224 -> 1532;
2225 -> 2224;
2225 -> 1534;
2225 -> 1532;
2226 -> 1530;
2226 -> 1564;
2226 -> 1659;
2226 -> 2225;
2226 -> 1668;
2226 -> 1558;
2226 -> 1559;
2226 -> 2211;
2226 -> 1566;
2226 -> 1563;
2227 -> 1683;
2228 -> 2227;
2228 -> 1578;
2229 -> 2228;
2229 -> 1580;
2229 -> 1578;
2230 -> 1576;
2230 -> 1610;
2230 -> 1679;
2230 -> 2229;
2230 -> 1688;
2230 -> 1604;
2230 -> 1605;
2230 -> 2215;
2230 -> 1612;
2230 -> 1609;
2231 -> 1624;
2232 -> 2231;
2232 -> 1445;
2233 -> 2232;
2233 -> 1447;
2233 -> 1445;
2234 -> 1643;
2235 -> 2234;
2235 -> 1483;
2236 -> 2235;
2236 -> 1485;
2236 -> 1483;
2237 -> 1481;
2237 -> 1513;
2237 -> 1639;
2237 -> 2236;
2237 -> 1648;
2237 -> 1509;
2237 -> 1510;
2237 -> 2222;
2237 -> 1520;
2237 -> 1512;
2238 -> 1663;
2239 -> 2238;
2239 -> 1532;
2240 -> 2239;
2240 -> 1534;
2240 -> 1532;
2241 -> 1530;
2241 -> 1564;
2241 -> 1659;
2241 -> 2240;
2241 -> 1668;
2241 -> 1558;
2241 -> 1559;
2241 -> 2226;
2241 -> 1566;
2241 -> 1563;
2242 -> 1683;
2243 -> 2242;
2243 -> 1578;
2244 -> 2243;
2244 -> 1580;
2244 -> 1578;
2245 -> 1576;
2245 -> 1610;
2245 -> 1679;
2245 -> 2244;
2245 -> 1688;
2245 -> 1604;
2245 -> 1605;
2245 -> 2230;
2245 -> 1612;
2245 -> 1609;
2246 -> 1624;
2247 -> 2246;
2247 -> 1445;
2248 -> 2247;
2248 -> 1447;
2248 -> 1445;
2249 -> 1643;
2250 -> 2249;
2250 -> 1483;
2251 -> 2250;
2251 -> 1485;
2251 -> 1483;
2252 -> 1481;
2252 -> 1513;
2252 -> 1639;
2252 -> 2251;
2252 -> 1648;
2252 -> 1509;
2252 -> 1510;
2252 -> 2237;
2252 -> 1520;
2252 -> 1512;
2253 -> 1663;
2254 -> 2253;
2254 -> 1532;
2255 -> 2254;
2255 -> 1534;
2255 -> 1532;
2256 -> 1530;
2256 -> 1564;
2256 -> 1659;
2256 -> 2255;
2256 -> 1668;
2256 -> 1558;
2256 -> 1559;
2256 -> 2241;
2256 -> 1566;
2256 -> 1563;
2257 -> 1683;
2258 -> 2257;
2258 -> 1578;
2259 -> 2258;
2259 -> 1580;
2259 -> 1578;
2260 -> 1576;
2260 -> 1610;
2260 -> 1679;
2260 -> 2259;
2260 -> 1688;
2260 -> 1604;
2260 -> 1605;
2260 -> 2245;
2260 -> 1612;
2260 -> 1609;
2261 -> 1624;
2262 -> 2261;
2262 -> 1445;
2263 -> 2262;
2263 -> 1447;
2263 -> 1445;
2264 -> 1643;
2265 -> 2264;
2265 -> 1483;
2266 -> 2265;
2266 -> 1485;
2266 -> 1483;
2267 -> 1481;
2267 -> 1513;
2267 -> 1639;
2267 -> 2266;
2267 -> 1648;
2267 -> 1509;
2267 -> 1510;
2267 -> 2252;
2267 -> 1520;
2267 -> 1512;
2268 -> 1663;
2269 -> 2268;
2269 -> 1532;
2270 -> 2269;
2270 -> 1534;
2270 -> 1532;
2271 -> 1530;
2271 -> 1564;
2271 -> 1659;
2271 -> 2270;
2271 -> 1668;
2271 -> 1558;
2271 -> 1559;
2271 -> 2256;
2271 -> 1566;
2271 -> 1563;
2272 -> 1683;
2273 -> 2272;
2273 -> 1578;
2274 -> 2273;
2274 -> 1580;
2274 -> 1578;
2275 -> 1576;
2275 -> 1610;
2275 -> 1679;
2275 -> 2274;
2275 -> 1688;
2275 -> 1604;
2275 -> 1605;
2275 -> 2260;
2275 -> 1612;
2275 -> 1609;
2276 -> 1624;
2277 -> 2276;
2277 -> 1445;
2278 -> 2277;
2278 -> 1447;
2278 -> 1445;
2279 -> 1643;
2280 -> 2279;
2280 -> 1483;
2281 -> 2280;
2281 -> 1485;
2281 -> 1483;
2282 -> 1481;
2282 -> 1513;
2282 -> 1639;
2282 -> 2281;
2282 -> 1648;
2282 -> 1509;
2282 -> 1510;
2282 -> 2267;
2282 -> 1520;
2282 -> 1512;
2283 -> 1663;
2284 -> 2283;
2284 -> 1532;
2285 -> 2284;
2285 -> 1534;
2285 -> 1532;
2286 -> 1530;
2286 -> 1564;
2286 -> 1659;
2286 -> 2285;
2286 -> 1668;
2286 -> 1558;
2286 -> 1559;
2286 -> 2271;
2286 -> 1566;
2286 -> 1563;
2287 -> 1683;
2288 -> 2287;
2288 -> 1578;
2289 -> 2288;
2289 -> 1580;
2289 -> 1578;
2290 -> 1576;
2290 -> 1610;
2290 -> 1679;
2290 -> 2289;
2290 -> 1688;
2290 -> 1604;
2290 -> 1605;
2290 -> 2275;
2290 -> 1612;
2290 -> 1609;
2291 -> 1624;
2292 -> 2291;
2292 -> 1445;
2293 -> 2292;
2293 -> 1447;
2293 -> 1445;
2294 -> 1643;
2295 -> 2294;
2295 -> 1483;
2296 -> 2295;
2296 -> 1485;
2296 -> 1483;
2297 -> 1481;
2297 -> 1513;
2297 -> 1639;
2297 -> 2296;
2297 -> 1648;
2297 -> 1509;
2297 -> 1510;
2297 -> 2282;
2297 -> 1520;
2297 -> 1512;
2298 -> 1663;
2299 -> 2298;
2299 -> 1532;
2300 -> 2299;
2300 -> 1534;
2300 -> 1532;
2301 -> 1530;
2301 -> 1564;
2301 -> 1659;
2301 -> 2300;
2301 -> 1668;
2301 -> 1558;
2301 -> 1559;
2301 -> 2286;
2301 -> 1566;
2301 -> 1563;
2302 -> 1683;
2303 -> 2302;
2303 -> 1578;
2304 -> 2303;
2304 -> 1580;
2304 -> 1578;
2305 -> 1576;
2305 -> 1610;
2305 -> 1679;
2305 -> 2304;
2305 -> 1688;
2305 -> 1604;
2305 -> 1605;
2305 -> 2290;
2305 -> 1612;
2305 -> 1609;
2306 -> 1624;
2307 -> 2306;
2307 -> 1445;
2308 -> 2307;
2308 -> 1447;
2308 -> 1445;
2309 -> 1643;
2310 -> 2309;
2310 -> 1483;
2311 -> 2310;
2311 -> 1485;
2311 -> 1483;
2312 -> 1481;
2312 -> 1513;
2312 -> 1639;
2312 -> 2311;
2312 -> 1648;
2312 -> 1509;
2312 -> 1510;
2312 -> 2297;
2312 -> 1520;
2312 -> 1512;
2313 -> 1663;
2314 -> 2313;
2314 -> 1532;
2315 -> 2314;
2315 -> 1534;
2315 -> 1532;
2316 -> 1530;
2316 -> 1564;
2316 -> 1659;
2316 -> 2315;
2316 -> 1668;
2316 -> 1558;
2316 -> 1559;
2316 -> 2301;
2316 -> 1566;
2316 -> 1563;
2317 -> 1683;
2318 -> 2317;
2318 -> 1578;
2319 -> 2318;
2319 -> 1580;
2319 -> 1578;
2320 -> 1576;
2320 -> 1610;
2320 -> 1679;
2320 -> 2319;
2320 -> 1688;
2320 -> 1604;
2320 -> 1605;
2320 -> 2305;
2320 -> 1612;
2320 -> 1609;
2321 -> 1624;
2322 -> 2321;
2322 -> 1445;
2323 -> 2322;
2323 -> 1447;
2323 -> 1445;
2324 -> 1643;
2325 -> 2324;
2325 -> 1483;
2326 -> 2325;
2326 -> 1485;
2326 -> 1483;
2327 -> 1481;
2327 -> 1513;
2327 -> 1639;
2327 -> 2326;
2327 -> 1648;
2327 -> 1509;
2327 -> 1510;
2327 -> 2312;
2327 -> 1520;
2327 -> 1512;
2328 -> 1663;
2329 -> 2328;
2329 -> 1532;
2330 -> 2329;
2330 -> 1534;
2330 -> 1532;
2331 -> 1530;
2331 -> 1564;
2331 -> 1659;
2331 -> 2330;
2331 -> 1668;
2331 -> 1558;
2331 -> 1559;
2331 -> 2316;
2331 -> 1566;
2331 -> 1563;
2332 -> 1683;
2333 -> 2332;
2333 -> 1578;
2334 -> 2333;
2334 -> 1580;
2334 -> 1578;
2335 -> 1576;
2335 -> 1610;
2335 -> 1679;
2335 -> 2334;
2335 -> 1688;
2335 -> 1604;
2335 -> 1605;
2335 -> 2320;
2335 -> 1612;
2335 -> 1609;
2336 -> 1624;
2337 -> 2336;
2337 -> 1445;
2338 -> 2337;
2338 -> 1447;
2338 -> 1445;
2339 -> 1643;
2340 -> 2339;
2340 -> 1483;
2341 -> 2340;
2341 -> 1485;
2341 -> 1483;
2342 -> 1481;
2342 -> 1513;
2342 -> 1639;
2342 -> 2341;
2342 -> 1648;
2342 -> 1509;
2342 -> 1510;
2342 -> 2327;
2342 -> 1520;
2342 -> 1512;
2343 -> 1663;
2344 -> 2343;
2344 -> 1532;
2345 -> 2344;
2345 -> 1534;
2345 -> 1532;
2346 -> 1530;
2346 -> 1564;
2346 -> 1659;
2346 -> 2345;
2346 -> 1668;
2346 -> 1558;
2346 -> 1559;
2346 -> 2331;
2346 -> 1566;
2346 -> 1563;
2347 -> 1683;
2348 -> 2347;
2348 -> 1578;
2349 -> 2348;
2349 -> 1580;
2349 -> 1578;
2350 -> 1576;
2350 -> 1610;
2350 -> 1679;
2350 -> 2349;
2350 -> 1688;
2350 -> 1604;
2350 -> 1605;
2350 -> 2335;
2350 -> 1612;
2350 -> 1609;
2351 -> 1624;
2352 -> 2351;
2352 -> 1445;
2353 -> 2352;
2353 -> 1447;
2353 -> 1445;
2354 -> 1643;
2355 -> 2354;
2355 -> 1483;
2356 -> 2355;
2356 -> 1485;
2356 -> 1483;
2357 -> 1481;
2357 -> 1513;
2357 -> 1639;
2357 -> 2356;
2357 -> 1648;
2357 -> 1509;
2357 -> 1510;
2357 -> 2342;
2357 -> 1520;
2357 -> 1512;
2358 -> 1663;
2359 -> 2358;
2359 -> 1532;
2360 -> 2359;
2360 -> 1534;
2360 -> 1532;
2361 -> 1530;
2361 -> 1564;
2361 -> 1659;
2361 -> 2360;
2361 -> 1668;
2361 -> 1558;
2361 -> 1559;
2361 -> 2346;
2361 -> 1566;
2361 -> 1563;
2362 -> 1683;
2363 -> 2362;
2363 -> 1578;
2364 -> 2363;
2364 -> 1580;
2364 -> 1578;
2365 -> 1576;
2365 -> 1610;
2365 -> 1679;
2365 -> 2364;
2365 -> 1688;
2365 -> 1604;
2365 -> 1605;
2365 -> 2350;
2365 -> 1612;
2365 -> 1609;
2366 -> 1624;
2367 -> 2366;
2367 -> 1445;
2368 -> 2367;
2368 -> 1447;
2368 -> 1445;
2369 -> 1643;
2370 -> 2369;
2370 -> 1483;
2371 -> 2370;
2371 -> 1485;
2371 -> 1483;
2372 -> 1481;
2372 -> 1513;
2372 -> 1639;
2372 -> 2371;
2372 -> 1648;
2372 -> 1509;
2372 -> 1510;
2372 -> 2357;
2372 -> 1520;
2372 -> 1512;
2373 -> 1663;
2374 -> 2373;
2374 -> 1532;
2375 -> 2374;
2375 -> 1534;
2375 -> 1532;
2376 -> 1530;
2376 -> 1564;
2376 -> 1659;
2376 -> 2375;
2376 -> 1668;
2376 -> 1558;
2376 -> 1559;
2376 -> 2361;
2376 -> 1566;
2376 -> 1563;
2377 -> 1683;
2378 -> 2377;
2378 -> 1578;
2379 -> 2378;
2379 -> 1580;
2379 -> 1578;
2380 -> 1576;
2380 -> 1610;
2380 -> 1679;
2380 -> 2379;
2380 -> 1688;
2380 -> 1604;
2380 -> 1605;
2380 -> 2365;
2380 -> 1612;
2380 -> 1609;
2381 -> 1624;
2382 -> 2381;
2382 -> 1445;
2383 -> 2382;
2383 -> 1447;
2383 -> 1445;
2384 -> 1643;
2385 -> 2384;
2385 -> 1483;
2386 -> 2385;
2386 -> 1485;
2386 -> 1483;
2387 -> 1481;
2387 -> 1513;
2387 -> 1639;
2387 -> 2386;
2387 -> 1648;
2387 -> 1509;
2387 -> 1510;
2387 -> 2372;
2387 -> 1520;
2387 -> 1512;
2388 -> 1663;
2389 -> 2388;
2389 -> 1532;
2390 -> 2389;
2390 -> 1534;
2390 -> 1532;
2391 -> 1530;
2391 -> 1564;
2391 -> 1659;
2391 -> 2390;
2391 -> 1668;
2391 -> 1558;
2391 -> 1559;
2391 -> 2376;
2391 -> 1566;
2391 -> 1563;
2392 -> 1683;
2393 -> 2392;
2393 -> 1578;
2394 -> 2393;
2394 -> 1580;
2394 -> 1578;
2395 -> 1576;
2395 -> 1610;
2395 -> 1679;
2395 -> 2394;
2395 -> 1688;
2395 -> 1604;
2395 -> 1605;
2395 -> 2380;
2395 -> 1612;
2395 -> 1609;
2396 -> 1624;
2397 -> 2396;
2397 -> 1445;
2398 -> 2397;
2398 -> 1447;
2398 -> 1445;
2399 -> 1643;
2400 -> 2399;
2400 -> 1483;
2401 -> 2400;
2401 -> 1485;
2401 -> 1483;
2402 -> 1481;
2402 -> 1513;
2402 -> 1639;
2402 -> 2401;
2402 -> 1648;
2402 -> 1509;
2402 -> 1510;
2402 -> 2387;
2402 -> 1520;
2402 -> 1512;
2403 -> 1663;
2404 -> 2403;
2404 -> 1532;
2405 -> 2404;
2405 -> 1534;
2405 -> 1532;
2406 -> 1530;
2406 -> 1564;
2406 -> 1659;
2406 -> 2405;
2406 -> 1668;
2406 -> 1558;
2406 -> 1559;
2406 -> 2391;
2406 -> 1566;
2406 -> 1563;
2407 -> 1683;
2408 -> 2407;
2408 -> 1578;
2409 -> 2408;
2409 -> 1580;
2409 -> 1578;
2410 -> 1576;
2410 -> 1610;
2410 -> 1679;
2410 -> 2409;
2410 -> 1688;
2410 -> 1604;
2410 -> 1605;
2410 -> 2395;
2410 -> 1612;
2410 -> 1609;
2411 -> 1624;
2412 -> 2411;
2412 -> 1445;
2413 -> 2412;
2413 -> 1447;
2413 -> 1445;
2414 -> 1643;
2415 -> 2414;
2415 -> 1483;
2416 -> 2415;
2416 -> 1485;
2416 -> 1483;
2417 -> 1481;
2417 -> 1513;
2417 -> 1639;
2417 -> 2416;
2417 -> 1648;
2417 -> 1509;
2417 -> 1510;
2417 -> 2402;
2417 -> 1520;
2417 -> 1512;
2418 -> 1663;
2419 -> 2418;
2419 -> 1532;
2420 -> 2419;
2420 -> 1534;
2420 -> 1532;
2421 -> 1530;
2421 -> 1564;
2421 -> 1659;
2421 -> 2420;
2421 -> 1668;
2421 -> 1558;
2421 -> 1559;
2421 -> 2406;
2421 -> 1566;
2421 -> 1563;
2422 -> 1683;
2423 -> 2422;
2423 -> 1578;
2424 -> 2423;
2424 -> 1580;
2424 -> 1578;
2425 -> 1576;
2425 -> 1610;
2425 -> 1679;
2425 -> 2424;
2425 -> 1688;
2425 -> 1604;
2425 -> 1605;
2425 -> 2410;
2425 -> 1612;
2425 -> 1609;
2426 -> 1624;
2427 -> 2426;
2427 -> 1445;
2428 -> 2427;
2428 -> 1447;
2428 -> 1445;
2429 -> 1643;
2430 -> 2429;
2430 -> 1483;
2431 -> 2430;
2431 -> 1485;
2431 -> 1483;
2432 -> 1481;
2432 -> 1513;
2432 -> 1639;
2432 -> 2431;
2432 -> 1648;
2432 -> 1509;
2432 -> 1510;
2432 -> 2417;
2432 -> 1520;
2432 -> 1512;
2433 -> 1663;
2434 -> 2433;
2434 -> 1532;
2435 -> 2434;
2435 -> 1534;
2435 -> 1532;
2436 -> 1530;
2436 -> 1564;
2436 -> 1659;
2436 -> 2435;
2436 -> 1668;
2436 -> 1558;
2436 -> 1559;
2436 -> 2421;
2436 -> 1566;
2436 -> 1563;
2437 -> 1683;
2438 -> 2437;
2438 -> 1578;
2439 -> 2438;
2439 -> 1580;
2439 -> 1578;
2440 -> 1576;
2440 -> 1610;
2440 -> 1679;
2440 -> 2439;
2440 -> 1688;
2440 -> 1604;
2440 -> 1605;
2440 -> 2425;
2440 -> 1612;
2440 -> 1609;
2441 -> 1624;
2442 -> 2441;
2442 -> 1445;
2443 -> 2442;
2443 -> 1447;
2443 -> 1445;
2444 -> 1643;
2445 -> 2444;
2445 -> 1483;
2446 -> 2445;
2446 -> 1485;
2446 -> 1483;
2447 -> 1481;
2447 -> 1513;
2447 -> 1639;
2447 -> 2446;
2447 -> 1648;
2447 -> 1509;
2447 -> 1510;
2447 -> 2432;
2447 -> 1520;
2447 -> 1512;
2448 -> 1663;
2449 -> 2448;
2449 -> 1532;
2450 -> 2449;
2450 -> 1534;
2450 -> 1532;
2451 -> 1530;
2451 -> 1564;
2451 -> 1659;
2451 -> 2450;
2451 -> 1668;
2451 -> 1558;
2451 -> 1559;
2451 -> 2436;
2451 -> 1566;
2451 -> 1563;
2452 -> 1683;
2453 -> 2452;
2453 -> 1578;
2454 -> 2453;
2454 -> 1580;
2454 -> 1578;
2455 -> 1576;
2455 -> 1610;
2455 -> 1679;
2455 -> 2454;
2455 -> 1688;
2455 -> 1604;
2455 -> 1605;
2455 -> 2440;
2455 -> 1612;
2455 -> 1609;
2456 -> 1624;
2457 -> 2456;
2457 -> 1445;
2458 -> 2457;
2458 -> 1447;
2458 -> 1445;
2459 -> 1643;
2460 -> 2459;
2460 -> 1483;
2461 -> 2460;
2461 -> 1485;
2461 -> 1483;
2462 -> 1481;
2462 -> 1513;
2462 -> 1639;
2462 -> 2461;
2462 -> 1648;
2462 -> 1509;
2462 -> 1510;
2462 -> 2447;
2462 -> 1520;
2462 -> 1512;
2463 -> 1663;
2464 -> 2463;
2464 -> 1532;
2465 -> 2464;
2465 -> 1534;
2465 -> 1532;
2466 -> 1530;
2466 -> 1564;
2466 -> 1659;
2466 -> 2465;
2466 -> 1668;
2466 -> 1558;
2466 -> 1559;
2466 -> 2451;
2466 -> 1566;
2466 -> 1563;
2467 -> 1683;
2468 -> 2467;
2468 -> 1578;
2469 -> 2468;
2469 -> 1580;
2469 -> 1578;
2470 -> 1576;
2470 -> 1610;
2470 -> 1679;
2470 -> 2469;
2470 -> 1688;
2470 -> 1604;
2470 -> 1605;
2470 -> 2455;
2470 -> 1612;
2470 -> 1609;
2471 -> 1624;
2472 -> 2471;
2472 -> 1445;
2473 -> 2472;
2473 -> 1447;
2473 -> 1445;
2474 -> 1643;
2475 -> 2474;
2475 -> 1483;
2476 -> 2475;
2476 -> 1485;
2476 -> 1483;
2477 -> 1481;
2477 -> 1513;
2477 -> 1639;
2477 -> 2476;
2477 -> 1648;
2477 -> 1509;
2477 -> 1510;
2477 -> 2462;
2477 -> 1520;
2477 -> 1512;
2478 -> 1663;
2479 -> 2478;
2479 -> 1532;
2480 -> 2479;
2480 -> 1534;
2480 -> 1532;
2481 -> 1530;
2481 -> 1564;
2481 -> 1659;
2481 -> 2480;
2481 -> 1668;
2481 -> 1558;
2481 -> 1559;
2481 -> 2466;
2481 -> 1566;
2481 -> 1563;
2482 -> 1683;
2483 -> 2482;
2483 -> 1578;
2484 -> 2483;
2484 -> 1580;
2484 -> 1578;
2485 -> 1576;
2485 -> 1610;
2485 -> 1679;
2485 -> 2484;
2485 -> 1688;
2485 -> 1604;
2485 -> 1605;
2485 -> 2470;
2485 -> 1612;
2485 -> 1609;
2486 -> 1624;
2487 -> 2486;
2487 -> 1445;
2488 -> 2487;
2488 -> 1447;
2488 -> 1445;
2489 -> 1643;
2490 -> 2489;
2490 -> 1483;
2491 -> 2490;
2491 -> 1485;
2491 -> 1483;
2492 -> 1481;
2492 -> 1513;
2492 -> 1639;
2492 -> 2491;
2492 -> 1648;
2492 -> 1509;
2492 -> 1510;
2492 -> 2477;
2492 -> 1520;
2492 -> 1512;
2493 -> 1663;
2494 -> 2493;
2494 -> 1532;
2495 -> 2494;
2495 -> 1534;
2495 -> 1532;
2496 -> 1530;
2496 -> 1564;
2496 -> 1659;
2496 -> 2495;
2496 -> 1668;
2496 -> 1558;
2496 -> 1559;
2496 -> 2481;
2496 -> 1566;
2496 -> 1563;
2497 -> 1683;
2498 -> 2497;
2498 -> 1578;
2499 -> 2498;
2499 -> 1580;
2499 -> 1578;
2500 -> 1576;
2500 -> 1610;
2500 -> 1679;
2500 -> 2499;
2500 -> 1688;
2500 -> 1604;
2500 -> 1605;
2500 -> 2485;
2500 -> 1612;
2500 -> 1609;
2501 -> 1624;
2502 -> 2501;
2502 -> 1445;
2503 -> 2502;
2503 -> 1447;
2503 -> 1445;
2504 -> 1643;
2505 -> 2504;
2505 -> 1483;
2506 -> 2505;
2506 -> 1485;
2506 -> 1483;
2507 -> 1481;
2507 -> 1513;
2507 -> 1639;
2507 -> 2506;
2507 -> 1648;
2507 -> 1509;
2507 -> 1510;
2507 -> 2492;
2507 -> 1520;
2507 -> 1512;
2508 -> 1663;
2509 -> 2508;
2509 -> 1532;
2510 -> 2509;
2510 -> 1534;
2510 -> 1532;
2511 -> 1530;
2511 -> 1564;
2511 -> 1659;
2511 -> 2510;
2511 -> 1668;
2511 -> 1558;
2511 -> 1559;
2511 -> 2496;
2511 -> 1566;
2511 -> 1563;
2512 -> 1683;
2513 -> 2512;
2513 -> 1578;
2514 -> 2513;
2514 -> 1580;
2514 -> 1578;
2515 -> 1576;
2515 -> 1610;
2515 -> 1679;
2515 -> 2514;
2515 -> 1688;
2515 -> 1604;
2515 -> 1605;
2515 -> 2500;
2515 -> 1612;
2515 -> 1609;
2516 -> 1624;
2517 -> 2516;
2517 -> 1445;
2518 -> 2517;
2518 -> 1447;
2518 -> 1445;
2519 -> 1643;
2520 -> 2519;
2520 -> 1483;
2521 -> 2520;
2521 -> 1485;
2521 -> 1483;
2522 -> 1481;
2522 -> 1513;
2522 -> 1639;
2522 -> 2521;
2522 -> 1648;
2522 -> 1509;
2522 -> 1510;
2522 -> 2507;
2522 -> 1520;
2522 -> 1512;
2523 -> 1663;
2524 -> 2523;
2524 -> 1532;
2525 -> 2524;
2525 -> 1534;
2525 -> 1532;
2526 -> 1530;
2526 -> 1564;
2526 -> 1659;
2526 -> 2525;
2526 -> 1668;
2526 -> 1558;
2526 -> 1559;
2526 -> 2511;
2526 -> 1566;
2526 -> 1563;
2527 -> 1683;
2528 -> 2527;
2528 -> 1578;
2529 -> 2528;
2529 -> 1580;
2529 -> 1578;
2530 -> 1576;
2530 -> 1610;
2530 -> 1679;
2530 -> 2529;
2530 -> 1688;
2530 -> 1604;
2530 -> 1605;
2530 -> 2515;
2530 -> 1612;
2530 -> 1609;
2531 -> 1624;
2532 -> 2531;
2532 -> 1445;
2533 -> 2532;
2533 -> 1447;
2533 -> 1445;
2534 -> 1643;
2535 -> 2534;
2535 -> 1483;
2536 -> 2535;
2536 -> 1485;
2536 -> 1483;
2537 -> 1481;
2537 -> 1513;
2537 -> 1639;
2537 -> 2536;
2537 -> 1648;
2537 -> 1509;
2537 -> 1510;
2537 -> 2522;
2537 -> 1520;
2537 -> 1512;
2538 -> 1663;
2539 -> 2538;
2539 -> 1532;
2540 -> 2539;
2540 -> 1534;
2540 -> 1532;
2541 -> 1530;
2541 -> 1564;
2541 -> 1659;
2541 -> 2540;
2541 -> 1668;
2541 -> 1558;
2541 -> 1559;
2541 -> 2526;
2541 -> 1566;
2541 -> 1563;
2542 -> 1683;
2543 -> 2542;
2543 -> 1578;
2544 -> 2543;
2544 -> 1580;
2544 -> 1578;
2545 -> 1576;
2545 -> 1610;
2545 -> 1679;
2545 -> 2544;
2545 -> 1688;
2545 -> 1604;
2545 -> 1605;
2545 -> 2530;
2545 -> 1612;
2545 -> 1609;
2546 -> 1624;
2547 -> 2546;
2547 -> 1445;
2548 -> 2547;
2548 -> 1447;
2548 -> 1445;
2549 -> 1643;
2550 -> 2549;
2550 -> 1483;
2551 -> 2550;
2551 -> 1485;
2551 -> 1483;
2552 -> 1481;
2552 -> 1513;
2552 -> 1639;
2552 -> 2551;
2552 -> 1648;
2552 -> 1509;
2552 -> 1510;
2552 -> 2537;
2552 -> 1520;
2552 -> 1512;
2553 -> 1663;
2554 -> 2553;
2554 -> 1532;
2555 -> 2554;
2555 -> 1534;
2555 -> 1532;
2556 -> 1530;
2556 -> 1564;
2556 -> 1659;
2556 -> 2555;
2556 -> 1668;
2556 -> 1558;
2556 -> 1559;
2556 -> 2541;
2556 -> 1566;
2556 -> 1563;
2557 -> 1683;
2558 -> 2557;
2558 -> 1578;
2559 -> 2558;
2559 -> 1580;
2559 -> 1578;
2560 -> 1576;
2560 -> 1610;
2560 -> 1679;
2560 -> 2559;
2560 -> 1688;
2560 -> 1604;
2560 -> 1605;
2560 -> 2545;
2560 -> 1612;
2560 -> 1609;
2561 -> 1624;
2562 -> 2561;
2562 -> 1445;
2563 -> 2562;
2563 -> 1447;
2563 -> 1445;
2564 -> 1643;
2565 -> 2564;
2565 -> 1483;
2566 -> 2565;
2566 -> 1485;
2566 -> 1483;
2567 -> 1481;
2567 -> 1513;
2567 -> 1639;
2567 -> 2566;
2567 -> 1648;
2567 -> 1509;
2567 -> 1510;
2567 -> 2552;
2567 -> 1520;
2567 -> 1512;
2568 -> 1663;
2569 -> 2568;
2569 -> 1532;
2570 -> 2569;
2570 -> 1534;
2570 -> 1532;
2571 -> 1530;
2571 -> 1564;
2571 -> 1659;
2571 -> 2570;
2571 -> 1668;
2571 -> 1558;
2571 -> 1559;
2571 -> 2556;
2571 -> 1566;
2571 -> 1563;
2572 -> 1683;
2573 -> 2572;
2573 -> 1578;
2574 -> 2573;
2574 -> 1580;
2574 -> 1578;
2575 -> 1576;
2575 -> 1610;
2575 -> 1679;
2575 -> 2574;
2575 -> 1688;
2575 -> 1604;
2575 -> 1605;
2575 -> 2560;
2575 -> 1612;
2575 -> 1609;
2576 -> 1624;
2577 -> 2576;
2577 -> 1445;
2578 -> 2577;
2578 -> 1447;
2578 -> 1445;
2579 -> 1643;
2580 -> 2579;
2580 -> 1483;
2581 -> 2580;
2581 -> 1485;
2581 -> 1483;
2582 -> 1481;
2582 -> 1513;
2582 -> 1639;
2582 -> 2581;
2582 -> 1648;
2582 -> 1509;
2582 -> 1510;
2582 -> 2567;
2582 -> 1520;
2582 -> 1512;
2583 -> 1663;
2584 -> 2583;
2584 -> 1532;
2585 -> 2584;
2585 -> 1534;
2585 -> 1532;
2586 -> 1530;
2586 -> 1564;
2586 -> 1659;
2586 -> 2585;
2586 -> 1668;
2586 -> 1558;
2586 -> 1559;
2586 -> 2571;
2586 -> 1566;
2586 -> 1563;
2587 -> 1683;
2588 -> 2587;
2588 -> 1578;
2589 -> 2588;
2589 -> 1580;
2589 -> 1578;
2590 -> 1576;
2590 -> 1610;
2590 -> 1679;
2590 -> 2589;
2590 -> 1688;
2590 -> 1604;
2590 -> 1605;
2590 -> 2575;
2590 -> 1612;
2590 -> 1609;
2591 -> 1624;
2592 -> 2591;
2592 -> 1445;
2593 -> 2592;
2593 -> 1447;
2593 -> 1445;
2594 -> 1643;
2595 -> 2594;
2595 -> 1483;
2596 -> 2595;
2596 -> 1485;
2596 -> 1483;
2597 -> 1481;
2597 -> 1513;
2597 -> 1639;
2597 -> 2596;
2597 -> 1648;
2597 -> 1509;
2597 -> 1510;
2597 -> 2582;
2597 -> 1520;
2597 -> 1512;
2598 -> 1663;
2599 -> 2598;
2599 -> 1532;
2600 -> 2599;
2600 -> 1534;
2600 -> 1532;
2601 -> 1530;
2601 -> 1564;
2601 -> 1659;
2601 -> 2600;
2601 -> 1668;
2601 -> 1558;
2601 -> 1559;
2601 -> 2586;
2601 -> 1566;
2601 -> 1563;
2602 -> 1683;
2603 -> 2602;
2603 -> 1578;
2604 -> 2603;
2604 -> 1580;
2604 -> 1578;
2605 -> 1576;
2605 -> 1610;
2605 -> 1679;
2605 -> 2604;
2605 -> 1688;
2605 -> 1604;
2605 -> 1605;
2605 -> 2590;
2605 -> 1612;
2605 -> 1609;
2606 -> 1624;
2607 -> 2606;
2607 -> 1445;
2608 -> 2607;
2608 -> 1447;
2608 -> 1445;
2609 -> 1643;
2610 -> 2609;
2610 -> 1483;
2611 -> 2610;
2611 -> 1485;
2611 -> 1483;
2612 -> 1481;
2612 -> 1513;
2612 -> 1639;
2612 -> 2611;
2612 -> 1648;
2612 -> 1509;
2612 -> 1510;
2612 -> 2597;
2612 -> 1520;
2612 -> 1512;
2613 -> 1663;
2614 -> 2613;
2614 -> 1532;
2615 -> 2614;
2615 -> 1534;
2615 -> 1532;
2616 -> 1530;
2616 -> 1564;
2616 -> 1659;
2616 -> 2615;
2616 -> 1668;
2616 -> 1558;
2616 -> 1559;
2616 -> 2601;
2616 -> 1566;
2616 -> 1563;
2617 -> 1683;
2618 -> 2617;
2618 -> 1578;
2619 -> 2618;
2619 -> 1580;
2619 -> 1578;
2620 -> 1576;
2620 -> 1610;
2620 -> 1679;
2620 -> 2619;
2620 -> 1688;
2620 -> 1604;
2620 -> 1605;
2620 -> 2605;
2620 -> 1612;
2620 -> 1609;
2621 -> 1624;
2622 -> 2621;
2622 -> 1445;
2623 -> 2622;
2623 -> 1447;
2623 -> 1445;
2624 -> 1643;
2625 -> 2624;
2625 -> 1483;
2626 -> 2625;
2626 -> 1485;
2626 -> 1483;
2627 -> 1481;
2627 -> 1513;
2627 -> 1639;
2627 -> 2626;
2627 -> 1648;
2627 -> 1509;
2627 -> 1510;
2627 -> 2612;
2627 -> 1520;
2627 -> 1512;
2628 -> 1663;
2629 -> 2628;
2629 -> 1532;
2630 -> 2629;
2630 -> 1534;
2630 -> 1532;
2631 -> 1530;
2631 -> 1564;
2631 -> 1659;
2631 -> 2630;
2631 -> 1668;
2631 -> 1558;
2631 -> 1559;
2631 -> 2616;
2631 -> 1566;
2631 -> 1563;
2632 -> 1683;
2633 -> 2632;
2633 -> 1578;
2634 -> 2633;
2634 -> 1580;
2634 -> 1578;
2635 -> 1576;
2635 -> 1610;
2635 -> 1679;
2635 -> 2634;
2635 -> 1688;
2635 -> 1604;
2635 -> 1605;
2635 -> 2620;
2635 -> 1612;
2635 -> 1609;
2636 -> 1624;
2637 -> 2636;
2637 -> 1445;
2638 -> 2637;
2638 -> 1447;
2638 -> 1445;
2639 -> 1643;
2640 -> 2639;
2640 -> 1483;
2641 -> 2640;
2641 -> 1485;
2641 -> 1483;
2642 -> 1481;
2642 -> 1513;
2642 -> 1639;
2642 -> 2641;
2642 -> 1648;
2642 -> 1509;
2642 -> 1510;
2642 -> 2627;
2642 -> 1520;
2642 -> 1512;
2643 -> 1663;
2644 -> 2643;
2644 -> 1532;
2645 -> 2644;
2645 -> 1534;
2645 -> 1532;
2646 -> 1530;
2646 -> 1564;
2646 -> 1659;
2646 -> 2645;
2646 -> 1668;
2646 -> 1558;
2646 -> 1559;
2646 -> 2631;
2646 -> 1566;
2646 -> 1563;
2647 -> 1683;
2648 -> 2647;
2648 -> 1578;
2649 -> 2648;
2649 -> 1580;
2649 -> 1578;
2650 -> 1576;
2650 -> 1610;
2650 -> 1679;
2650 -> 2649;
2650 -> 1688;
2650 -> 1604;
2650 -> 1605;
2650 -> 2635;
2650 -> 1612;
2650 -> 1609;
2651 -> 1624;
2652 -> 2651;
2652 -> 1445;
2653 -> 2652;
2653 -> 1447;
2653 -> 1445;
2654 -> 1643;
2655 -> 2654;
2655 -> 1483;
2656 -> 2655;
2656 -> 1485;
2656 -> 1483;
2657 -> 1481;
2657 -> 1513;
2657 -> 1639;
2657 -> 2656;
2657 -> 1648;
2657 -> 1509;
2657 -> 1510;
2657 -> 2642;
2657 -> 1520;
2657 -> 1512;
2658 -> 1663;
2659 -> 2658;
2659 -> 1532;
2660 -> 2659;
2660 -> 1534;
2660 -> 1532;
2661 -> 1530;
2661 -> 1564;
2661 -> 1659;
2661 -> 2660;
2661 -> 1668;
2661 -> 1558;
2661 -> 1559;
2661 -> 2646;
2661 -> 1566;
2661 -> 1563;
2662 -> 1683;
2663 -> 2662;
2663 -> 1578;
2664 -> 2663;
2664 -> 1580;
2664 -> 1578;
2665 -> 1576;
2665 -> 1610;
2665 -> 1679;
2665 -> 2664;
2665 -> 1688;
2665 -> 1604;
2665 -> 1605;
2665 -> 2650;
2665 -> 1612;
2665 -> 1609;
2666 -> 1624;
2667 -> 2666;
2667 -> 1445;
2668 -> 2667;
2668 -> 1447;
2668 -> 1445;
2669 -> 1643;
2670 -> 2669;
2670 -> 1483;
2671 -> 2670;
2671 -> 1485;
2671 -> 1483;
2672 -> 1481;
2672 -> 1513;
2672 -> 1639;
2672 -> 2671;
2672 -> 1648;
2672 -> 1509;
2672 -> 1510;
2672 -> 2657;
2672 -> 1520;
2672 -> 1512;
2673 -> 1663;
2674 -> 2673;
2674 -> 1532;
2675 -> 2674;
2675 -> 1534;
2675 -> 1532;
2676 -> 1530;
2676 -> 1564;
2676 -> 1659;
2676 -> 2675;
2676 -> 1668;
2676 -> 1558;
2676 -> 1559;
2676 -> 2661;
2676 -> 1566;
2676 -> 1563;
2677 -> 1683;
2678 -> 2677;
2678 -> 1578;
2679 -> 2678;
2679 -> 1580;
2679 -> 1578;
2680 -> 1576;
2680 -> 1610;
2680 -> 1679;
2680 -> 2679;
2680 -> 1688;
2680 -> 1604;
2680 -> 1605;
2680 -> 2665;
2680 -> 1612;
2680 -> 1609;
2681 -> 1624;
2682 -> 2681;
2682 -> 1445;
2683 -> 2682;
2683 -> 1447;
2683 -> 1445;
2684 -> 1643;
2685 -> 2684;
2685 -> 1483;
2686 -> 2685;
2686 -> 1485;
2686 -> 1483;
2687 -> 1481;
2687 -> 1513;
2687 -> 1639;
2687 -> 2686;
2687 -> 1648;
2687 -> 1509;
2687 -> 1510;
2687 -> 2672;
2687 -> 1520;
2687 -> 1512;
2688 -> 1663;
2689 -> 2688;
2689 -> 1532;
2690 -> 2689;
2690 -> 1534;
2690 -> 1532;
2691 -> 1530;
2691 -> 1564;
2691 -> 1659;
2691 -> 2690;
2691 -> 1668;
2691 -> 1558;
2691 -> 1559;
2691 -> 2676;
2691 -> 1566;
2691 -> 1563;
2692 -> 1683;
2693 -> 2692;
2693 -> 1578;
2694 -> 2693;
2694 -> 1580;
2694 -> 1578;
2695 -> 1576;
2695 -> 1610;
2695 -> 1679;
2695 -> 2694;
2695 -> 1688;
2695 -> 1604;
2695 -> 1605;
2695 -> 2680;
2695 -> 1612;
2695 -> 1609;
2696 -> 1624;
2697 -> 2696;
2697 -> 1445;
2698 -> 2697;
2698 -> 1447;
2698 -> 1445;
2699 -> 1643;
2700 -> 2699;
2700 -> 1483;
2701 -> 2700;
2701 -> 1485;
2701 -> 1483;
2702 -> 1481;
2702 -> 1513;
2702 -> 1639;
2702 -> 2701;
2702 -> 1648;
2702 -> 1509;
2702 -> 1510;
2702 -> 2687;
2702 -> 1520;
2702 -> 1512;
2703 -> 1663;
2704 -> 2703;
2704 -> 1532;
2705 -> 2704;
2705 -> 1534;
2705 -> 1532;
2706 -> 1530;
2706 -> 1564;
2706 -> 1659;
2706 -> 2705;
2706 -> 1668;
2706 -> 1558;
2706 -> 1559;
2706 -> 2691;
2706 -> 1566;
2706 -> 1563;
2707 -> 1683;
2708 -> 2707;
2708 -> 1578;
2709 -> 2708;
2709 -> 1580;
2709 -> 1578;
2710 -> 1576;
2710 -> 1610;
2710 -> 1679;
2710 -> 2709;
2710 -> 1688;
2710 -> 1604;
2710 -> 1605;
2710 -> 2695;
2710 -> 1612;
2710 -> 1609;
2711 -> 1624;
2712 -> 2711;
2712 -> 1445;
2713 -> 2712;
2713 -> 1447;
2713 -> 1445;
2714 -> 1643;
2715 -> 2714;
2715 -> 1483;
2716 -> 2715;
2716 -> 1485;
2716 -> 1483;
2717 -> 1481;
2717 -> 1513;
2717 -> 1639;
2717 -> 2716;
2717 -> 1648;
2717 -> 1509;
2717 -> 1510;
2717 -> 2702;
2717 -> 1520;
2717 -> 1512;
2718 -> 1663;
2719 -> 2718;
2719 -> 1532;
2720 -> 2719;
2720 -> 1534;
2720 -> 1532;
2721 -> 1530;
2721 -> 1564;
2721 -> 1659;
2721 -> 2720;
2721 -> 1668;
2721 -> 1558;
2721 -> 1559;
2721 -> 2706;
2721 -> 1566;
2721 -> 1563;
2722 -> 1683;
2723 -> 2722;
2723 -> 1578;
2724 -> 2723;
2724 -> 1580;
2724 -> 1578;
2725 -> 1576;
2725 -> 1610;
2725 -> 1679;
2725 -> 2724;
2725 -> 1688;
2725 -> 1604;
2725 -> 1605;
2725 -> 2710;
2725 -> 1612;
2725 -> 1609;
2726 -> 1624;
2727 -> 2726;
2727 -> 1445;
2728 -> 2727;
2728 -> 1447;
2728 -> 1445;
2729 -> 1643;
2730 -> 2729;
2730 -> 1483;
2731 -> 2730;
2731 -> 1485;
2731 -> 1483;
2732 -> 1481;
2732 -> 1513;
2732 -> 1639;
2732 -> 2731;
2732 -> 1648;
2732 -> 1509;
2732 -> 1510;
2732 -> 2717;
2732 -> 1520;
2732 -> 1512;
2733 -> 1663;
2734 -> 2733;
2734 -> 1532;
2735 -> 2734;
2735 -> 1534;
2735 -> 1532;
2736 -> 1530;
2736 -> 1564;
2736 -> 1659;
2736 -> 2735;
2736 -> 1668;
2736 -> 1558;
2736 -> 1559;
2736 -> 2721;
2736 -> 1566;
2736 -> 1563;
2737 -> 1683;
2738 -> 2737;
2738 -> 1578;
2739 -> 2738;
2739 -> 1580;
2739 -> 1578;
2740 -> 1576;
2740 -> 1610;
2740 -> 1679;
2740 -> 2739;
2740 -> 1688;
2740 -> 1604;
2740 -> 1605;
2740 -> 2725;
2740 -> 1612;
2740 -> 1609;
2741 -> 1624;
2742 -> 2741;
2742 -> 1445;
2743 -> 2742;
2743 -> 1447;
2743 -> 1445;
2744 -> 1643;
2745 -> 2744;
2745 -> 1483;
2746 -> 2745;
2746 -> 1485;
2746 -> 1483;
2747 -> 1481;
2747 -> 1513;
2747 -> 1639;
2747 -> 2746;
2747 -> 1648;
2747 -> 1509;
2747 -> 1510;
2747 -> 2732;
2747 -> 1520;
2747 -> 1512;
2748 -> 1663;
2749 -> 2748;
2749 -> 1532;
2750 -> 2749;
2750 -> 1534;
2750 -> 1532;
2751 -> 1530;
2751 -> 1564;
2751 -> 1659;
2751 -> 2750;
2751 -> 1668;
2751 -> 1558;
2751 -> 1559;
2751 -> 2736;
2751 -> 1566;
2751 -> 1563;
2752 -> 1683;
2753 -> 2752;
2753 -> 1578;
2754 -> 2753;
2754 -> 1580;
2754 -> 1578;
2755 -> 1576;
2755 -> 1610;
2755 -> 1679;
2755 -> 2754;
2755 -> 1688;
2755 -> 1604;
2755 -> 1605;
2755 -> 2740;
2755 -> 1612;
2755 -> 1609;
2756 -> 1624;
2757 -> 2756;
2757 -> 1445;
2758 -> 2757;
2758 -> 1447;
2758 -> 1445;
2759 -> 1643;
2760 -> 2759;
2760 -> 1483;
2761 -> 2760;
2761 -> 1485;
2761 -> 1483;
2762 -> 1481;
2762 -> 1513;
2762 -> 1639;
2762 -> 2761;
2762 -> 1648;
2762 -> 1509;
2762 -> 1510;
2762 -> 2747;
2762 -> 1520;
2762 -> 1512;
2763 -> 1663;
2764 -> 2763;
2764 -> 1532;
2765 -> 2764;
2765 -> 1534;
2765 -> 1532;
2766 -> 1530;
2766 -> 1564;
2766 -> 1659;
2766 -> 2765;
2766 -> 1668;
2766 -> 1558;
2766 -> 1559;
2766 -> 2751;
2766 -> 1566;
2766 -> 1563;
2767 -> 1683;
2768 -> 2767;
2768 -> 1578;
2769 -> 2768;
2769 -> 1580;
2769 -> 1578;
2770 -> 1576;
2770 -> 1610;
2770 -> 1679;
2770 -> 2769;
2770 -> 1688;
2770 -> 1604;
2770 -> 1605;
2770 -> 2755;
2770 -> 1612;
2770 -> 1609;
2771 -> 1624;
2772 -> 2771;
2772 -> 1445;
2773 -> 2772;
2773 -> 1447;
2773 -> 1445;
2774 -> 1643;
2775 -> 2774;
2775 -> 1483;
2776 -> 2775;
2776 -> 1485;
2776 -> 1483;
2777 -> 1481;
2777 -> 1513;
2777 -> 1639;
2777 -> 2776;
2777 -> 1648;
2777 -> 1509;
2777 -> 1510;
2777 -> 2762;
2777 -> 1520;
2777 -> 1512;
2778 -> 1663;
2779 -> 2778;
2779 -> 1532;
2780 -> 2779;
2780 -> 1534;
2780 -> 1532;
2781 -> 1530;
2781 -> 1564;
2781 -> 1659;
2781 -> 2780;
2781 -> 1668;
2781 -> 1558;
2781 -> 1559;
2781 -> 2766;
2781 -> 1566;
2781 -> 1563;
2782 -> 1683;
2783 -> 2782;
2783 -> 1578;
2784 -> 2783;
2784 -> 1580;
2784 -> 1578;
2785 -> 1576;
2785 -> 1610;
2785 -> 1679;
2785 -> 2784;
2785 -> 1688;
2785 -> 1604;
2785 -> 1605;
2785 -> 2770;
2785 -> 1612;
2785 -> 1609;
2786 -> 1624;
2787 -> 2786;
2787 -> 1445;
2788 -> 2787;
2788 -> 1447;
2788 -> 1445;
2789 -> 1643;
2790 -> 2789;
2790 -> 1483;
2791 -> 2790;
2791 -> 1485;
2791 -> 1483;
2792 -> 1481;
2792 -> 1513;
2792 -> 1639;
2792 -> 2791;
2792 -> 1648;
2792 -> 1509;
2792 -> 1510;
2792 -> 2777;
2792 -> 1520;
2792 -> 1512;
2793 -> 1663;
2794 -> 2793;
2794 -> 1532;
2795 -> 2794;
2795 -> 1534;
2795 -> 1532;
2796 -> 1530;
2796 -> 1564;
2796 -> 1659;
2796 -> 2795;
2796 -> 1668;
2796 -> 1558;
2796 -> 1559;
2796 -> 2781;
2796 -> 1566;
2796 -> 1563;
2797 -> 1683;
2798 -> 2797;
2798 -> 1578;
2799 -> 2798;
2799 -> 1580;
2799 -> 1578;
2800 -> 1576;
2800 -> 1610;
2800 -> 1679;
2800 -> 2799;
2800 -> 1688;
2800 -> 1604;
2800 -> 1605;
2800 -> 2785;
2800 -> 1612;
2800 -> 1609;
2801 -> 1624;
2802 -> 2801;
2802 -> 1445;
2803 -> 2802;
2803 -> 1447;
2803 -> 1445;
2804 -> 1643;
2805 -> 2804;
2805 -> 1483;
2806 -> 2805;
2806 -> 1485;
2806 -> 1483;
2807 -> 1481;
2807 -> 1513;
2807 -> 1639;
2807 -> 2806;
2807 -> 1648;
2807 -> 1509;
2807 -> 1510;
2807 -> 2792;
2807 -> 1520;
2807 -> 1512;
2808 -> 1663;
2809 -> 2808;
2809 -> 1532;
2810 -> 2809;
2810 -> 1534;
2810 -> 1532;
2811 -> 1530;
2811 -> 1564;
2811 -> 1659;
2811 -> 2810;
2811 -> 1668;
2811 -> 1558;
2811 -> 1559;
2811 -> 2796;
2811 -> 1566;
2811 -> 1563;
2812 -> 1683;
2813 -> 2812;
2813 -> 1578;
2814 -> 2813;
2814 -> 1580;
2814 -> 1578;
2815 -> 1576;
2815 -> 1610;
2815 -> 1679;
2815 -> 2814;
2815 -> 1688;
2815 -> 1604;
2815 -> 1605;
2815 -> 2800;
2815 -> 1612;
2815 -> 1609;
2816 -> 1624;
2817 -> 2816;
2817 -> 1445;
2818 -> 2817;
2818 -> 1447;
2818 -> 1445;
2819 -> 1643;
2820 -> 2819;
2820 -> 1483;
2821 -> 2820;
2821 -> 1485;
2821 -> 1483;
2822 -> 1481;
2822 -> 1513;
2822 -> 1639;
2822 -> 2821;
2822 -> 1648;
2822 -> 1509;
2822 -> 1510;
2822 -> 2807;
2822 -> 1520;
2822 -> 1512;
2823 -> 1663;
2824 -> 2823;
2824 -> 1532;
2825 -> 2824;
2825 -> 1534;
2825 -> 1532;
2826 -> 1530;
2826 -> 1564;
2826 -> 1659;
2826 -> 2825;
2826 -> 1668;
2826 -> 1558;
2826 -> 1559;
2826 -> 2811;
2826 -> 1566;
2826 -> 1563;
2827 -> 1683;
2828 -> 2827;
2828 -> 1578;
2829 -> 2828;
2829 -> 1580;
2829 -> 1578;
2830 -> 1576;
2830 -> 1610;
2830 -> 1679;
2830 -> 2829;
2830 -> 1688;
2830 -> 1604;
2830 -> 1605;
2830 -> 2815;
2830 -> 1612;
2830 -> 1609;
2831 -> 1624;
2832 -> 2831;
2832 -> 1445;
2833 -> 2832;
2833 -> 1447;
2833 -> 1445;
2834 -> 1643;
2835 -> 2834;
2835 -> 1483;
2836 -> 2835;
2836 -> 1485;
2836 -> 1483;
2837 -> 1481;
2837 -> 1513;
2837 -> 1639;
2837 -> 2836;
2837 -> 1648;
2837 -> 1509;
2837 -> 1510;
2837 -> 2822;
2837 -> 1520;
2837 -> 1512;
2838 -> 1663;
2839 -> 2838;
2839 -> 1532;
2840 -> 2839;
2840 -> 1534;
2840 -> 1532;
2841 -> 1530;
2841 -> 1564;
2841 -> 1659;
2841 -> 2840;
2841 -> 1668;
2841 -> 1558;
2841 -> 1559;
2841 -> 2826;
2841 -> 1566;
2841 -> 1563;
2842 -> 1683;
2843 -> 2842;
2843 -> 1578;
2844 -> 2843;
2844 -> 1580;
2844 -> 1578;
2845 -> 1576;
2845 -> 1610;
2845 -> 1679;
2845 -> 2844;
2845 -> 1688;
2845 -> 1604;
2845 -> 1605;
2845 -> 2830;
2845 -> 1612;
2845 -> 1609;
2846 -> 1624;
2847 -> 2846;
2847 -> 1445;
2848 -> 2847;
2848 -> 1447;
2848 -> 1445;
2849 -> 1643;
2850 -> 2849;
2850 -> 1483;
2851 -> 2850;
2851 -> 1485;
2851 -> 1483;
2852 -> 1481;
2852 -> 1513;
2852 -> 1639;
2852 -> 2851;
2852 -> 1648;
2852 -> 1509;
2852 -> 1510;
2852 -> 2837;
2852 -> 1520;
2852 -> 1512;
2853 -> 1663;
2854 -> 2853;
2854 -> 1532;
2855 -> 2854;
2855 -> 1534;
2855 -> 1532;
2856 -> 1530;
2856 -> 1564;
2856 -> 1659;
2856 -> 2855;
2856 -> 1668;
2856 -> 1558;
2856 -> 1559;
2856 -> 2841;
2856 -> 1566;
2856 -> 1563;
2857 -> 1683;
2858 -> 2857;
2858 -> 1578;
2859 -> 2858;
2859 -> 1580;
2859 -> 1578;
2860 -> 1576;
2860 -> 1610;
2860 -> 1679;
2860 -> 2859;
2860 -> 1688;
2860 -> 1604;
2860 -> 1605;
2860 -> 2845;
2860 -> 1612;
2860 -> 1609;
2861 -> 1624;
2862 -> 2861;
2862 -> 1445;
2863 -> 2862;
2863 -> 1447;
2863 -> 1445;
2864 -> 1643;
2865 -> 2864;
2865 -> 1483;
2866 -> 2865;
2866 -> 1485;
2866 -> 1483;
2867 -> 1481;
2867 -> 1513;
2867 -> 1639;
2867 -> 2866;
2867 -> 1648;
2867 -> 1509;
2867 -> 1510;
2867 -> 2852;
2867 -> 1520;
2867 -> 1512;
2868 -> 1663;
2869 -> 2868;
2869 -> 1532;
2870 -> 2869;
2870 -> 1534;
2870 -> 1532;
2871 -> 1530;
2871 -> 1564;
2871 -> 1659;
2871 -> 2870;
2871 -> 1668;
2871 -> 1558;
2871 -> 1559;
2871 -> 2856;
2871 -> 1566;
2871 -> 1563;
2872 -> 1683;
2873 -> 2872;
2873 -> 1578;
2874 -> 2873;
2874 -> 1580;
2874 -> 1578;
2875 -> 1576;
2875 -> 1610;
2875 -> 1679;
2875 -> 2874;
2875 -> 1688;
2875 -> 1604;
2875 -> 1605;
2875 -> 2860;
2875 -> 1612;
2875 -> 1609;
2876 -> 1624;
2877 -> 2876;
2877 -> 1445;
2878 -> 2877;
2878 -> 1447;
2878 -> 1445;
2879 -> 1643;
2880 -> 2879;
2880 -> 1483;
2881 -> 2880;
2881 -> 1485;
2881 -> 1483;
2882 -> 1481;
2882 -> 1513;
2882 -> 1639;
2882 -> 2881;
2882 -> 1648;
2882 -> 1509;
2882 -> 1510;
2882 -> 2867;
2882 -> 1520;
2882 -> 1512;
2883 -> 1663;
2884 -> 2883;
2884 -> 1532;
2885 -> 2884;
2885 -> 1534;
2885 -> 1532;
2886 -> 1530;
2886 -> 1564;
2886 -> 1659;
2886 -> 2885;
2886 -> 1668;
2886 -> 1558;
2886 -> 1559;
2886 -> 2871;
2886 -> 1566;
2886 -> 1563;
2887 -> 1683;
2888 -> 2887;
2888 -> 1578;
2889 -> 2888;
2889 -> 1580;
2889 -> 1578;
2890 -> 1576;
2890 -> 1610;
2890 -> 1679;
2890 -> 2889;
2890 -> 1688;
2890 -> 1604;
2890 -> 1605;
2890 -> 2875;
2890 -> 1612;
2890 -> 1609;
2891 -> 1624;
2892 -> 2891;
2892 -> 1445;
2893 -> 2892;
2893 -> 1447;
2893 -> 1445;
2894 -> 1643;
2895 -> 2894;
2895 -> 1483;
2896 -> 2895;
2896 -> 1485;
2896 -> 1483;
2897 -> 1481;
2897 -> 1513;
2897 -> 1639;
2897 -> 2896;
2897 -> 1648;
2897 -> 1509;
2897 -> 1510;
2897 -> 2882;
2897 -> 1520;
2897 -> 1512;
2898 -> 1663;
2899 -> 2898;
2899 -> 1532;
2900 -> 2899;
2900 -> 1534;
2900 -> 1532;
2901 -> 1530;
2901 -> 1564;
2901 -> 1659;
2901 -> 2900;
2901 -> 1668;
2901 -> 1558;
2901 -> 1559;
2901 -> 2886;
2901 -> 1566;
2901 -> 1563;
2902 -> 1683;
2903 -> 2902;
2903 -> 1578;
2904 -> 2903;
2904 -> 1580;
2904 -> 1578;
2905 -> 1576;
2905 -> 1610;
2905 -> 1679;
2905 -> 2904;
2905 -> 1688;
2905 -> 1604;
2905 -> 1605;
2905 -> 2890;
2905 -> 1612;
2905 -> 1609;
2906 -> 1624;
2907 -> 2906;
2907 -> 1445;
2908 -> 2907;
2908 -> 1447;
2908 -> 1445;
2909 -> 1643;
2910 -> 2909;
2910 -> 1483;
2911 -> 2910;
2911 -> 1485;
2911 -> 1483;
2912 -> 1481;
2912 -> 1513;
2912 -> 1639;
2912 -> 2911;
2912 -> 1648;
2912 -> 1509;
2912 -> 1510;
2912 -> 2897;
2912 -> 1520;
2912 -> 1512;
2913 -> 1663;
2914 -> 2913;
2914 -> 1532;
2915 -> 2914;
2915 -> 1534;
2915 -> 1532;
2916 -> 1530;
2916 -> 1564;
2916 -> 1659;
2916 -> 2915;
2916 -> 1668;
2916 -> 1558;
2916 -> 1559;
2916 -> 2901;
2916 -> 1566;
2916 -> 1563;
2917 -> 1683;
2918 -> 2917;
2918 -> 1578;
2919 -> 2918;
2919 -> 1580;
2919 -> 1578;
2920 -> 1576;
2920 -> 1610;
2920 -> 1679;
2920 -> 2919;
2920 -> 1688;
2920 -> 1604;
2920 -> 1605;
2920 -> 2905;
2920 -> 1612;
2920 -> 1609;
2921 -> 1624;
2922 -> 2921;
2922 -> 1445;
2923 -> 2922;
2923 -> 1447;
2923 -> 1445;
2924 -> 1643;
2925 -> 2924;
2925 -> 1483;
2926 -> 2925;
2926 -> 1485;
2926 -> 1483;
2927 -> 1481;
2927 -> 1513;
2927 -> 1639;
2927 -> 2926;
2927 -> 1648;
2927 -> 1509;
2927 -> 1510;
2927 -> 2912;
2927 -> 1520;
2927 -> 1512;
2928 -> 1663;
2929 -> 2928;
2929 -> 1532;
2930 -> 2929;
2930 -> 1534;
2930 -> 1532;
2931 -> 1530;
2931 -> 1564;
2931 -> 1659;
2931 -> 2930;
2931 -> 1668;
2931 -> 1558;
2931 -> 1559;
2931 -> 2916;
2931 -> 1566;
2931 -> 1563;
2932 -> 1683;
2933 -> 2932;
2933 -> 1578;
2934 -> 2933;
2934 -> 1580;
2934 -> 1578;
2935 -> 1576;
2935 -> 1610;
2935 -> 1679;
2935 -> 2934;
2935 -> 1688;
2935 -> 1604;
2935 -> 1605;
2935 -> 2920;
2935 -> 1612;
2935 -> 1609;
2936 -> 1624;
2937 -> 2936;
2937 -> 1445;
2938 -> 2937;
2938 -> 1447;
2938 -> 1445;
2939 -> 1643;
2940 -> 2939;
2940 -> 1483;
2941 -> 2940;
2941 -> 1485;
2941 -> 1483;
2942 -> 1481;
2942 -> 1513;
2942 -> 1639;
2942 -> 2941;
2942 -> 1648;
2942 -> 1509;
2942 -> 1510;
2942 -> 2927;
2942 -> 1520;
2942 -> 1512;
2943 -> 1663;
2944 -> 2943;
2944 -> 1532;
2945 -> 2944;
2945 -> 1534;
2945 -> 1532;
2946 -> 1530;
2946 -> 1564;
2946 -> 1659;
2946 -> 2945;
2946 -> 1668;
2946 -> 1558;
2946 -> 1559;
2946 -> 2931;
2946 -> 1566;
2946 -> 1563;
2947 -> 1683;
2948 -> 2947;
2948 -> 1578;
2949 -> 2948;
2949 -> 1580;
2949 -> 1578;
2950 -> 1576;
2950 -> 1610;
2950 -> 1679;
2950 -> 2949;
2950 -> 1688;
2950 -> 1604;
2950 -> 1605;
2950 -> 2935;
2950 -> 1612;
2950 -> 1609;
2951 -> 1624;
2952 -> 2951;
2952 -> 1445;
2953 -> 2952;
2953 -> 1447;
2953 -> 1445;
2954 -> 1643;
2955 -> 2954;
2955 -> 1483;
2956 -> 2955;
2956 -> 1485;
2956 -> 1483;
2957 -> 1481;
2957 -> 1513;
2957 -> 1639;
2957 -> 2956;
2957 -> 1648;
2957 -> 1509;
2957 -> 1510;
2957 -> 2942;
2957 -> 1520;
2957 -> 1512;
2958 -> 1663;
2959 -> 2958;
2959 -> 1532;
2960 -> 2959;
2960 -> 1534;
2960 -> 1532;
2961 -> 1530;
2961 -> 1564;
2961 -> 1659;
2961 -> 2960;
2961 -> 1668;
2961 -> 1558;
2961 -> 1559;
2961 -> 2946;
2961 -> 1566;
2961 -> 1563;
2962 -> 1683;
2963 -> 2962;
2963 -> 1578;
2964 -> 2963;
2964 -> 1580;
2964 -> 1578;
2965 -> 1576;
2965 -> 1610;
2965 -> 1679;
2965 -> 2964;
2965 -> 1688;
2965 -> 1604;
2965 -> 1605;
2965 -> 2950;
2965 -> 1612;
2965 -> 1609;
2966 -> 1624;
2967 -> 2966;
2967 -> 1445;
2968 -> 2967;
2968 -> 1447;
2968 -> 1445;
2969 -> 1643;
2970 -> 2969;
2970 -> 1483;
2971 -> 2970;
2971 -> 1485;
2971 -> 1483;
2972 -> 1481;
2972 -> 1513;
2972 -> 1639;
2972 -> 2971;
2972 -> 1648;
2972 -> 1509;
2972 -> 1510;
2972 -> 2957;
2972 -> 1520;
2972 -> 1512;
2973 -> 1663;
2974 -> 2973;
2974 -> 1532;
2975 -> 2974;
2975 -> 1534;
2975 -> 1532;
2976 -> 1530;
2976 -> 1564;
2976 -> 1659;
2976 -> 2975;
2976 -> 1668;
2976 -> 1558;
2976 -> 1559;
2976 -> 2961;
2976 -> 1566;
2976 -> 1563;
2977 -> 1683;
2978 -> 2977;
2978 -> 1578;
2979 -> 2978;
2979 -> 1580;
2979 -> 1578;
2980 -> 1576;
2980 -> 1610;
2980 -> 1679;
2980 -> 2979;
2980 -> 1688;
2980 -> 1604;
2980 -> 1605;
2980 -> 2965;
2980 -> 1612;
2980 -> 1609;
2981 -> 1624;
2982 -> 2981;
2982 -> 1445;
2983 -> 2982;
2983 -> 1447;
2983 -> 1445;
2984 -> 1643;
2985 -> 2984;
2985 -> 1483;
2986 -> 2985;
2986 -> 1485;
2986 -> 1483;
2987 -> 1481;
2987 -> 1513;
2987 -> 1639;
2987 -> 2986;
2987 -> 1648;
2987 -> 1509;
2987 -> 1510;
2987 -> 2972;
2987 -> 1520;
2987 -> 1512;
2988 -> 1663;
2989 -> 2988;
2989 -> 1532;
2990 -> 2989;
2990 -> 1534;
2990 -> 1532;
2991 -> 1530;
2991 -> 1564;
2991 -> 1659;
2991 -> 2990;
2991 -> 1668;
2991 -> 1558;
2991 -> 1559;
2991 -> 2976;
2991 -> 1566;
2991 -> 1563;
2992 -> 1683;
2993 -> 2992;
2993 -> 1578;
2994 -> 2993;
2994 -> 1580;
2994 -> 1578;
2995 -> 1576;
2995 -> 1610;
2995 -> 1679;
2995 -> 2994;
2995 -> 1688;
2995 -> 1604;
2995 -> 1605;
2995 -> 2980;
2995 -> 1612;
2995 -> 1609;
2996 -> 1624;
2997 -> 2996;
2997 -> 1445;
2998 -> 2997;
2998 -> 1447;
2998 -> 1445;
2999 -> 1643;
3000 -> 2999;
3000 -> 1483;
3001 -> 3000;
3001 -> 1485;
3001 -> 1483;
3002 -> 1481;
3002 -> 1513;
3002 -> 1639;
3002 -> 3001;
3002 -> 1648;
3002 -> 1509;
3002 -> 1510;
3002 -> 2987;
3002 -> 1520;
3002 -> 1512;
3003 -> 1663;
3004 -> 3003;
3004 -> 1532;
3005 -> 3004;
3005 -> 1534;
3005 -> 1532;
3006 -> 1530;
3006 -> 1564;
3006 -> 1659;
3006 -> 3005;
3006 -> 1668;
3006 -> 1558;
3006 -> 1559;
3006 -> 2991;
3006 -> 1566;
3006 -> 1563;
3007 -> 1683;
3008 -> 3007;
3008 -> 1578;
3009 -> 3008;
3009 -> 1580;
3009 -> 1578;
3010 -> 1576;
3010 -> 1610;
3010 -> 1679;
3010 -> 3009;
3010 -> 1688;
3010 -> 1604;
3010 -> 1605;
3010 -> 2995;
3010 -> 1612;
3010 -> 1609;
3011 -> 1624;
3012 -> 3011;
3012 -> 1445;
3013 -> 3012;
3013 -> 1447;
3013 -> 1445;
3014 -> 1643;
3015 -> 3014;
3015 -> 1483;
3016 -> 3015;
3016 -> 1485;
3016 -> 1483;
3017 -> 1481;
3017 -> 1513;
3017 -> 1639;
3017 -> 3016;
3017 -> 1648;
3017 -> 1509;
3017 -> 1510;
3017 -> 3002;
3017 -> 1520;
3017 -> 1512;
3018 -> 1663;
3019 -> 3018;
3019 -> 1532;
3020 -> 3019;
3020 -> 1534;
3020 -> 1532;
3021 -> 1530;
3021 -> 1564;
3021 -> 1659;
3021 -> 3020;
3021 -> 1668;
3021 -> 1558;
3021 -> 1559;
3021 -> 3006;
3021 -> 1566;
3021 -> 1563;
3022 -> 1683;
3023 -> 3022;
3023 -> 1578;
3024 -> 3023;
3024 -> 1580;
3024 -> 1578;
3025 -> 1576;
3025 -> 1610;
3025 -> 1679;
3025 -> 3024;
3025 -> 1688;
3025 -> 1604;
3025 -> 1605;
3025 -> 3010;
3025 -> 1612;
3025 -> 1609;
3026 -> 1624;
3027 -> 3026;
3027 -> 1445;
3028 -> 3027;
3028 -> 1447;
3028 -> 1445;
3029 -> 1643;
3030 -> 3029;
3030 -> 1483;
3031 -> 3030;
3031 -> 1485;
3031 -> 1483;
3032 -> 1481;
3032 -> 1513;
3032 -> 1639;
3032 -> 3031;
3032 -> 1648;
3032 -> 1509;
3032 -> 1510;
3032 -> 3017;
3032 -> 1520;
3032 -> 1512;
3033 -> 1663;
3034 -> 3033;
3034 -> 1532;
3035 -> 3034;
3035 -> 1534;
3035 -> 1532;
3036 -> 1530;
3036 -> 1564;
3036 -> 1659;
3036 -> 3035;
3036 -> 1668;
3036 -> 1558;
3036 -> 1559;
3036 -> 3021;
3036 -> 1566;
3036 -> 1563;
3037 -> 1683;
3038 -> 3037;
3038 -> 1578;
3039 -> 3038;
3039 -> 1580;
3039 -> 1578;
3040 -> 1576;
3040 -> 1610;
3040 -> 1679;
3040 -> 3039;
3040 -> 1688;
3040 -> 1604;
3040 -> 1605;
3040 -> 3025;
3040 -> 1612;
3040 -> 1609;
3041 -> 1624;
3042 -> 3041;
3042 -> 1445;
3043 -> 3042;
3043 -> 1447;
3043 -> 1445;
3044 -> 1643;
3045 -> 3044;
3045 -> 1483;
3046 -> 3045;
3046 -> 1485;
3046 -> 1483;
3047 -> 1481;
3047 -> 1513;
3047 -> 1639;
3047 -> 3046;
3047 -> 1648;
3047 -> 1509;
3047 -> 1510;
3047 -> 3032;
3047 -> 1520;
3047 -> 1512;
3048 -> 1663;
3049 -> 3048;
3049 -> 1532;
3050 -> 3049;
3050 -> 1534;
3050 -> 1532;
3051 -> 1530;
3051 -> 1564;
3051 -> 1659;
3051 -> 3050;
3051 -> 1668;
3051 -> 1558;
3051 -> 1559;
3051 -> 3036;
3051 -> 1566;
3051 -> 1563;
3052 -> 1683;
3053 -> 3052;
3053 -> 1578;
3054 -> 3053;
3054 -> 1580;
3054 -> 1578;
3055 -> 1576;
3055 -> 1610;
3055 -> 1679;
3055 -> 3054;
3055 -> 1688;
3055 -> 1604;
3055 -> 1605;
3055 -> 3040;
3055 -> 1612;
3055 -> 1609;
3056 -> 1624;
3057 -> 3056;
3057 -> 1445;
3058 -> 3057;
3058 -> 1447;
3058 -> 1445;
3059 -> 1643;
3060 -> 3059;
3060 -> 1483;
3061 -> 3060;
3061 -> 1485;
3061 -> 1483;
3062 -> 1481;
3062 -> 1513;
3062 -> 1639;
3062 -> 3061;
3062 -> 1648;
3062 -> 1509;
3062 -> 1510;
3062 -> 3047;
3062 -> 1520;
3062 -> 1512;
3063 -> 1663;
3064 -> 3063;
3064 -> 1532;
3065 -> 3064;
3065 -> 1534;
3065 -> 1532;
3066 -> 1530;
3066 -> 1564;
3066 -> 1659;
3066 -> 3065;
3066 -> 1668;
3066 -> 1558;
3066 -> 1559;
3066 -> 3051;
3066 -> 1566;
3066 -> 1563;
3067 -> 1683;
3068 -> 3067;
3068 -> 1578;
3069 -> 3068;
3069 -> 1580;
3069 -> 1578;
3070 -> 1576;
3070 -> 1610;
3070 -> 1679;
3070 -> 3069;
3070 -> 1688;
3070 -> 1604;
3070 -> 1605;
3070 -> 3055;
3070 -> 1612;
3070 -> 1609;
3071 -> 1624;
3072 -> 3071;
3072 -> 1445;
3073 -> 3072;
3073 -> 1447;
3073 -> 1445;
3074 -> 1643;
3075 -> 3074;
3075 -> 1483;
3076 -> 3075;
3076 -> 1485;
3076 -> 1483;
3077 -> 1481;
3077 -> 1513;
3077 -> 1639;
3077 -> 3076;
3077 -> 1648;
3077 -> 1509;
3077 -> 1510;
3077 -> 3062;
3077 -> 1520;
3077 -> 1512;
3078 -> 1663;
3079 -> 3078;
3079 -> 1532;
3080 -> 3079;
3080 -> 1534;
3080 -> 1532;
3081 -> 1530;
3081 -> 1564;
3081 -> 1659;
3081 -> 3080;
3081 -> 1668;
3081 -> 1558;
3081 -> 1559;
3081 -> 3066;
3081 -> 1566;
3081 -> 1563;
3082 -> 1683;
3083 -> 3082;
3083 -> 1578;
3084 -> 3083;
3084 -> 1580;
3084 -> 1578;
3085 -> 1576;
3085 -> 1610;
3085 -> 1679;
3085 -> 3084;
3085 -> 1688;
3085 -> 1604;
3085 -> 1605;
3085 -> 3070;
3085 -> 1612;
3085 -> 1609;
3086 -> 1624;
3087 -> 3086;
3087 -> 1445;
3088 -> 3087;
3088 -> 1447;
3088 -> 1445;
3089 -> 1643;
3090 -> 3089;
3090 -> 1483;
3091 -> 3090;
3091 -> 1485;
3091 -> 1483;
3092 -> 1481;
3092 -> 1513;
3092 -> 1639;
3092 -> 3091;
3092 -> 1648;
3092 -> 1509;
3092 -> 1510;
3092 -> 3077;
3092 -> 1520;
3092 -> 1512;
3093 -> 1663;
3094 -> 3093;
3094 -> 1532;
3095 -> 3094;
3095 -> 1534;
3095 -> 1532;
3096 -> 1530;
3096 -> 1564;
3096 -> 1659;
3096 -> 3095;
3096 -> 1668;
3096 -> 1558;
3096 -> 1559;
3096 -> 3081;
3096 -> 1566;
3096 -> 1563;
3097 -> 1683;
3098 -> 3097;
3098 -> 1578;
3099 -> 3098;
3099 -> 1580;
3099 -> 1578;
3100 -> 1576;
3100 -> 1610;
3100 -> 1679;
3100 -> 3099;
3100 -> 1688;
3100 -> 1604;
3100 -> 1605;
3100 -> 3085;
3100 -> 1612;
3100 -> 1609;
3101 -> 1624;
3102 -> 3101;
3102 -> 1445;
3103 -> 3102;
3103 -> 1447;
3103 -> 1445;
3104 -> 1643;
3105 -> 3104;
3105 -> 1483;
3106 -> 3105;
3106 -> 1485;
3106 -> 1483;
3107 -> 1481;
3107 -> 1513;
3107 -> 1639;
3107 -> 3106;
3107 -> 1648;
3107 -> 1509;
3107 -> 1510;
3107 -> 3092;
3107 -> 1520;
3107 -> 1512;
3108 -> 1663;
3109 -> 3108;
3109 -> 1532;
3110 -> 3109;
3110 -> 1534;
3110 -> 1532;
3111 -> 1530;
3111 -> 1564;
3111 -> 1659;
3111 -> 3110;
3111 -> 1668;
3111 -> 1558;
3111 -> 1559;
3111 -> 3096;
3111 -> 1566;
3111 -> 1563;
3112 -> 1683;
3113 -> 3112;
3113 -> 1578;
3114 -> 3113;
3114 -> 1580;
3114 -> 1578;
3115 -> 1576;
3115 -> 1610;
3115 -> 1679;
3115 -> 3114;
3115 -> 1688;
3115 -> 1604;
3115 -> 1605;
3115 -> 3100;
3115 -> 1612;
3115 -> 1609;
3116 -> 1624;
3117 -> 3116;
3117 -> 1445;
3118 -> 3117;
3118 -> 1447;
3118 -> 1445;
3119 -> 1643;
3120 -> 3119;
3120 -> 1483;
3121 -> 3120;
3121 -> 1485;
3121 -> 1483;
3122 -> 1481;
3122 -> 1513;
3122 -> 1639;
3122 -> 3121;
3122 -> 1648;
3122 -> 1509;
3122 -> 1510;
3122 -> 3107;
3122 -> 1520;
3122 -> 1512;
3123 -> 1663;
3124 -> 3123;
3124 -> 1532;
3125 -> 3124;
3125 -> 1534;
3125 -> 1532;
3126 -> 1530;
3126 -> 1564;
3126 -> 1659;
3126 -> 3125;
3126 -> 1668;
3126 -> 1558;
3126 -> 1559;
3126 -> 3111;
3126 -> 1566;
3126 -> 1563;
3127 -> 1683;
3128 -> 3127;
3128 -> 1578;
3129 -> 3128;
3129 -> 1580;
3129 -> 1578;
3130 -> 1576;
3130 -> 1610;
3130 -> 1679;
3130 -> 3129;
3130 -> 1688;
3130 -> 1604;
3130 -> 1605;
3130 -> 3115;
3130 -> 1612;
3130 -> 1609;
3131 -> 1624;
3132 -> 3131;
3132 -> 1445;
3133 -> 3132;
3133 -> 1447;
3133 -> 1445;
3134 -> 1643;
3135 -> 3134;
3135 -> 1483;
3136 -> 3135;
3136 -> 1485;
3136 -> 1483;
3137 -> 1481;
3137 -> 1513;
3137 -> 1639;
3137 -> 3136;
3137 -> 1648;
3137 -> 1509;
3137 -> 1510;
3137 -> 3122;
3137 -> 1520;
3137 -> 1512;
3138 -> 1663;
3139 -> 3138;
3139 -> 1532;
3140 -> 3139;
3140 -> 1534;
3140 -> 1532;
3141 -> 1530;
3141 -> 1564;
3141 -> 1659;
3141 -> 3140;
3141 -> 1668;
3141 -> 1558;
3141 -> 1559;
3141 -> 3126;
3141 -> 1566;
3141 -> 1563;
3142 -> 1683;
3143 -> 3142;
3143 -> 1578;
3144 -> 3143;
3144 -> 1580;
3144 -> 1578;
3145 -> 1576;
3145 -> 1610;
3145 -> 1679;
3145 -> 3144;
3145 -> 1688;
3145 -> 1604;
3145 -> 1605;
3145 -> 3130;
3145 -> 1612;
3145 -> 1609;
3146 -> 1624;
3147 -> 3146;
3147 -> 1445;
3148 -> 3147;
3148 -> 1447;
3148 -> 1445;
3149 -> 1643;
3150 -> 3149;
3150 -> 1483;
3151 -> 3150;
3151 -> 1485;
3151 -> 1483;
3152 -> 1481;
3152 -> 1513;
3152 -> 1639;
3152 -> 3151;
3152 -> 1648;
3152 -> 1509;
3152 -> 1510;
3152 -> 3137;
3152 -> 1520;
3152 -> 1512;
3153 -> 1663;
3154 -> 3153;
3154 -> 1532;
3155 -> 3154;
3155 -> 1534;
3155 -> 1532;
3156 -> 1530;
3156 -> 1564;
3156 -> 1659;
3156 -> 3155;
3156 -> 1668;
3156 -> 1558;
3156 -> 1559;
3156 -> 3141;
3156 -> 1566;
3156 -> 1563;
3157 -> 1683;
3158 -> 3157;
3158 -> 1578;
3159 -> 3158;
3159 -> 1580;
3159 -> 1578;
3160 -> 1576;
3160 -> 1610;
3160 -> 1679;
3160 -> 3159;
3160 -> 1688;
3160 -> 1604;
3160 -> 1605;
3160 -> 3145;
3160 -> 1612;
3160 -> 1609;
3161 -> 1624;
3162 -> 3161;
3162 -> 1445;
3163 -> 3162;
3163 -> 1447;
3163 -> 1445;
3164 -> 1643;
3165 -> 3164;
3165 -> 1483;
3166 -> 3165;
3166 -> 1485;
3166 -> 1483;
3167 -> 1481;
3167 -> 1513;
3167 -> 1639;
3167 -> 3166;
3167 -> 1648;
3167 -> 1509;
3167 -> 1510;
3167 -> 3152;
3167 -> 1520;
3167 -> 1512;
3168 -> 1663;
3169 -> 3168;
3169 -> 1532;
3170 -> 3169;
3170 -> 1534;
3170 -> 1532;
3171 -> 1530;
3171 -> 1564;
3171 -> 1659;
3171 -> 3170;
3171 -> 1668;
3171 -> 1558;
3171 -> 1559;
3171 -> 3156;
3171 -> 1566;
3171 -> 1563;
3172 -> 1683;
3173 -> 3172;
3173 -> 1578;
3174 -> 3173;
3174 -> 1580;
3174 -> 1578;
3175 -> 1576;
3175 -> 1610;
3175 -> 1679;
3175 -> 3174;
3175 -> 1688;
3175 -> 1604;
3175 -> 1605;
3175 -> 3160;
3175 -> 1612;
3175 -> 1609;
3176 -> 1624;
3177 -> 3176;
3177 -> 1445;
3178 -> 3177;
3178 -> 1447;
3178 -> 1445;
3179 -> 1643;
3180 -> 3179;
3180 -> 1483;
3181 -> 3180;
3181 -> 1485;
3181 -> 1483;
3182 -> 1481;
3182 -> 1513;
3182 -> 1639;
3182 -> 3181;
3182 -> 1648;
3182 -> 1509;
3182 -> 1510;
3182 -> 3167;
3182 -> 1520;
3182 -> 1512;
3183 -> 1663;
3184 -> 3183;
3184 -> 1532;
3185 -> 3184;
3185 -> 1534;
3185 -> 1532;
3186 -> 1530;
3186 -> 1564;
3186 -> 1659;
3186 -> 3185;
3186 -> 1668;
3186 -> 1558;
3186 -> 1559;
3186 -> 3171;
3186 -> 1566;
3186 -> 1563;
3187 -> 1683;
3188 -> 3187;
3188 -> 1578;
3189 -> 3188;
3189 -> 1580;
3189 -> 1578;
3190 -> 1576;
3190 -> 1610;
3190 -> 1679;
3190 -> 3189;
3190 -> 1688;
3190 -> 1604;
3190 -> 1605;
3190 -> 3175;
3190 -> 1612;
3190 -> 1609;
3191 -> 1624;
3192 -> 3191;
3192 -> 1445;
3193 -> 3192;
3193 -> 1447;
3193 -> 1445;
3194 -> 1643;
3195 -> 3194;
3195 -> 1483;
3196 -> 3195;
3196 -> 1485;
3196 -> 1483;
3197 -> 1481;
3197 -> 1513;
3197 -> 1639;
3197 -> 3196;
3197 -> 1648;
3197 -> 1509;
3197 -> 1510;
3197 -> 3182;
3197 -> 1520;
3197 -> 1512;
3198 -> 1663;
3199 -> 3198;
3199 -> 1532;
3200 -> 3199;
3200 -> 1534;
3200 -> 1532;
3201 -> 1530;
3201 -> 1564;
3201 -> 1659;
3201 -> 3200;
3201 -> 1668;
3201 -> 1558;
3201 -> 1559;
3201 -> 3186;
3201 -> 1566;
3201 -> 1563;
3202 -> 1683;
3203 -> 3202;
3203 -> 1578;
3204 -> 3203;
3204 -> 1580;
3204 -> 1578;
3205 -> 1576;
3205 -> 1610;
3205 -> 1679;
3205 -> 3204;
3205 -> 1688;
3205 -> 1604;
3205 -> 1605;
3205 -> 3190;
3205 -> 1612;
3205 -> 1609;
3206 -> 1624;
3207 -> 3206;
3207 -> 1445;
3208 -> 3207;
3208 -> 1447;
3208 -> 1445;
3209 -> 1643;
3210 -> 3209;
3210 -> 1483;
3211 -> 3210;
3211 -> 1485;
3211 -> 1483;
3212 -> 1481;
3212 -> 1513;
3212 -> 1639;
3212 -> 3211;
3212 -> 1648;
3212 -> 1509;
3212 -> 1510;
3212 -> 3197;
3212 -> 1520;
3212 -> 1512;
3213 -> 1663;
3214 -> 3213;
3214 -> 1532;
3215 -> 3214;
3215 -> 1534;
3215 -> 1532;
3216 -> 1530;
3216 -> 1564;
3216 -> 1659;
3216 -> 3215;
3216 -> 1668;
3216 -> 1558;
3216 -> 1559;
3216 -> 3201;
3216 -> 1566;
3216 -> 1563;
3217 -> 1683;
3218 -> 3217;
3218 -> 1578;
3219 -> 3218;
3219 -> 1580;
3219 -> 1578;
3220 -> 1576;
3220 -> 1610;
3220 -> 1679;
3220 -> 3219;
3220 -> 1688;
3220 -> 1604;
3220 -> 1605;
3220 -> 3205;
3220 -> 1612;
3220 -> 1609;
3221 -> 1624;
3222 -> 3221;
3222 -> 1445;
3223 -> 3222;
3223 -> 1447;
3223 -> 1445;
3224 -> 1643;
3225 -> 3224;
3225 -> 1483;
3226 -> 3225;
3226 -> 1485;
3226 -> 1483;
3227 -> 1481;
3227 -> 1513;
3227 -> 1639;
3227 -> 3226;
3227 -> 1648;
3227 -> 1509;
3227 -> 1510;
3227 -> 3212;
3227 -> 1520;
3227 -> 1512;
3228 -> 1663;
3229 -> 3228;
3229 -> 1532;
3230 -> 3229;
3230 -> 1534;
3230 -> 1532;
3231 -> 1530;
3231 -> 1564;
3231 -> 1659;
3231 -> 3230;
3231 -> 1668;
3231 -> 1558;
3231 -> 1559;
3231 -> 3216;
3231 -> 1566;
3231 -> 1563;
3232 -> 1683;
3233 -> 3232;
3233 -> 1578;
3234 -> 3233;
3234 -> 1580;
3234 -> 1578;
3235 -> 1576;
3235 -> 1610;
3235 -> 1679;
3235 -> 3234;
3235 -> 1688;
3235 -> 1604;
3235 -> 1605;
3235 -> 3220;
3235 -> 1612;
3235 -> 1609;
3236 -> 1624;
3237 -> 3236;
3237 -> 1445;
3238 -> 3237;
3238 -> 1447;
3238 -> 1445;
3239 -> 1643;
3240 -> 3239;
3240 -> 1483;
3241 -> 3240;
3241 -> 1485;
3241 -> 1483;
3242 -> 1481;
3242 -> 1513;
3242 -> 1639;
3242 -> 3241;
3242 -> 1648;
3242 -> 1509;
3242 -> 1510;
3242 -> 3227;
3242 -> 1520;
3242 -> 1512;
3243 -> 1663;
3244 -> 3243;
3244 -> 1532;
3245 -> 3244;
3245 -> 1534;
3245 -> 1532;
3246 -> 1530;
3246 -> 1564;
3246 -> 1659;
3246 -> 3245;
3246 -> 1668;
3246 -> 1558;
3246 -> 1559;
3246 -> 3231;
3246 -> 1566;
3246 -> 1563;
3247 -> 1683;
3248 -> 3247;
3248 -> 1578;
3249 -> 3248;
3249 -> 1580;
3249 -> 1578;
3250 -> 1576;
3250 -> 1610;
3250 -> 1679;
3250 -> 3249;
3250 -> 1688;
3250 -> 1604;
3250 -> 1605;
3250 -> 3235;
3250 -> 1612;
3250 -> 1609;
3251 -> 1624;
3252 -> 3251;
3252 -> 1445;
3253 -> 3252;
3253 -> 1447;
3253 -> 1445;
3254 -> 1643;
3255 -> 3254;
3255 -> 1483;
3256 -> 3255;
3256 -> 1485;
3256 -> 1483;
3257 -> 1481;
3257 -> 1513;
3257 -> 1639;
3257 -> 3256;
3257 -> 1648;
3257 -> 1509;
3257 -> 1510;
3257 -> 3242;
3257 -> 1520;
3257 -> 1512;
3258 -> 1663;
3259 -> 3258;
3259 -> 1532;
3260 -> 3259;
3260 -> 1534;
3260 -> 1532;
3261 -> 1530;
3261 -> 1564;
3261 -> 1659;
3261 -> 3260;
3261 -> 1668;
3261 -> 1558;
3261 -> 1559;
3261 -> 3246;
3261 -> 1566;
3261 -> 1563;
3262 -> 1683;
3263 -> 3262;
3263 -> 1578;
3264 -> 3263;
3264 -> 1580;
3264 -> 1578;
3265 -> 1576;
3265 -> 1610;
3265 -> 1679;
3265 -> 3264;
3265 -> 1688;
3265 -> 1604;
3265 -> 1605;
3265 -> 3250;
3265 -> 1612;
3265 -> 1609;
3266 -> 1624;
3267 -> 3266;
3267 -> 1445;
3268 -> 3267;
3268 -> 1447;
3268 -> 1445;
3269 -> 1643;
3270 -> 3269;
3270 -> 1483;
3271 -> 3270;
3271 -> 1485;
3271 -> 1483;
3272 -> 1481;
3272 -> 1513;
3272 -> 1639;
3272 -> 3271;
3272 -> 1648;
3272 -> 1509;
3272 -> 1510;
3272 -> 3257;
3272 -> 1520;
3272 -> 1512;
3273 -> 1663;
3274 -> 3273;
3274 -> 1532;
3275 -> 3274;
3275 -> 1534;
3275 -> 1532;
3276 -> 1530;
3276 -> 1564;
3276 -> 1659;
3276 -> 3275;
3276 -> 1668;
3276 -> 1558;
3276 -> 1559;
3276 -> 3261;
3276 -> 1566;
3276 -> 1563;
3277 -> 1683;
3278 -> 3277;
3278 -> 1578;
3279 -> 3278;
3279 -> 1580;
3279 -> 1578;
3280 -> 1576;
3280 -> 1610;
3280 -> 1679;
3280 -> 3279;
3280 -> 1688;
3280 -> 1604;
3280 -> 1605;
3280 -> 3265;
3280 -> 1612;
3280 -> 1609;
3281 -> 1624;
3282 -> 3281;
3282 -> 1445;
3283 -> 3282;
3283 -> 1447;
3283 -> 1445;
3284 -> 1643;
3285 -> 3284;
3285 -> 1483;
3286 -> 3285;
3286 -> 1485;
3286 -> 1483;
3287 -> 1481;
3287 -> 1513;
3287 -> 1639;
3287 -> 3286;
3287 -> 1648;
3287 -> 1509;
3287 -> 1510;
3287 -> 3272;
3287 -> 1520;
3287 -> 1512;
3288 -> 1663;
3289 -> 3288;
3289 -> 1532;
3290 -> 3289;
3290 -> 1534;
3290 -> 1532;
3291 -> 1530;
3291 -> 1564;
3291 -> 1659;
3291 -> 3290;
3291 -> 1668;
3291 -> 1558;
3291 -> 1559;
3291 -> 3276;
3291 -> 1566;
3291 -> 1563;
3292 -> 1683;
3293 -> 3292;
3293 -> 1578;
3294 -> 3293;
3294 -> 1580;
3294 -> 1578;
3295 -> 1576;
3295 -> 1610;
3295 -> 1679;
3295 -> 3294;
3295 -> 1688;
3295 -> 1604;
3295 -> 1605;
3295 -> 3280;
3295 -> 1612;
3295 -> 1609;
3296 -> 1624;
3297 -> 3296;
3297 -> 1445;
3298 -> 3297;
3298 -> 1447;
3298 -> 1445;
3299 -> 1643;
3300 -> 3299;
3300 -> 1483;
3301 -> 3300;
3301 -> 1485;
3301 -> 1483;
3302 -> 1481;
3302 -> 1513;
3302 -> 1639;
3302 -> 3301;
3302 -> 1648;
3302 -> 1509;
3302 -> 1510;
3302 -> 3287;
3302 -> 1520;
3302 -> 1512;
3303 -> 1663;
3304 -> 3303;
3304 -> 1532;
3305 -> 3304;
3305 -> 1534;
3305 -> 1532;
3306 -> 1530;
3306 -> 1564;
3306 -> 1659;
3306 -> 3305;
3306 -> 1668;
3306 -> 1558;
3306 -> 1559;
3306 -> 3291;
3306 -> 1566;
3306 -> 1563;
3307 -> 1683;
3308 -> 3307;
3308 -> 1578;
3309 -> 3308;
3309 -> 1580;
3309 -> 1578;
3310 -> 1576;
3310 -> 1610;
3310 -> 1679;
3310 -> 3309;
3310 -> 1688;
3310 -> 1604;
3310 -> 1605;
3310 -> 3295;
3310 -> 1612;
3310 -> 1609;
3311 -> 1624;
3312 -> 3311;
3312 -> 1445;
3313 -> 3312;
3313 -> 1447;
3313 -> 1445;
3314 -> 1643;
3315 -> 3314;
3315 -> 1483;
3316 -> 3315;
3316 -> 1485;
3316 -> 1483;
3317 -> 1481;
3317 -> 1513;
3317 -> 1639;
3317 -> 3316;
3317 -> 1648;
3317 -> 1509;
3317 -> 1510;
3317 -> 3302;
3317 -> 1520;
3317 -> 1512;
3318 -> 1663;
3319 -> 3318;
3319 -> 1532;
3320 -> 3319;
3320 -> 1534;
3320 -> 1532;
3321 -> 1530;
3321 -> 1564;
3321 -> 1659;
3321 -> 3320;
3321 -> 1668;
3321 -> 1558;
3321 -> 1559;
3321 -> 3306;
3321 -> 1566;
3321 -> 1563;
3322 -> 1683;
3323 -> 3322;
3323 -> 1578;
3324 -> 3323;
3324 -> 1580;
3324 -> 1578;
3325 -> 1576;
3325 -> 1610;
3325 -> 1679;
3325 -> 3324;
3325 -> 1688;
3325 -> 1604;
3325 -> 1605;
3325 -> 3310;
3325 -> 1612;
3325 -> 1609;
3326 -> 1624;
3327 -> 3326;
3327 -> 1445;
3328 -> 3327;
3328 -> 1447;
3328 -> 1445;
3329 -> 1643;
3330 -> 3329;
3330 -> 1483;
3331 -> 3330;
3331 -> 1485;
3331 -> 1483;
3332 -> 1481;
3332 -> 1513;
3332 -> 1639;
3332 -> 3331;
3332 -> 1648;
3332 -> 1509;
3332 -> 1510;
3332 -> 3317;
3332 -> 1520;
3332 -> 1512;
3333 -> 1663;
3334 -> 3333;
3334 -> 1532;
3335 -> 3334;
3335 -> 1534;
3335 -> 1532;
3336 -> 1530;
3336 -> 1564;
3336 -> 1659;
3336 -> 3335;
3336 -> 1668;
3336 -> 1558;
3336 -> 1559;
3336 -> 3321;
3336 -> 1566;
3336 -> 1563;
3337 -> 1683;
3338 -> 3337;
3338 -> 1578;
3339 -> 3338;
3339 -> 1580;
3339 -> 1578;
3340 -> 1576;
3340 -> 1610;
3340 -> 1679;
3340 -> 3339;
3340 -> 1688;
3340 -> 1604;
3340 -> 1605;
3340 -> 3325;
3340 -> 1612;
3340 -> 1609;
3341 -> 1624;
3342 -> 3341;
3342 -> 1445;
3343 -> 3342;
3343 -> 1447;
3343 -> 1445;
3344 -> 1643;
3345 -> 3344;
3345 -> 1483;
3346 -> 3345;
3346 -> 1485;
3346 -> 1483;
3347 -> 1481;
3347 -> 1513;
3347 -> 1639;
3347 -> 3346;
3347 -> 1648;
3347 -> 1509;
3347 -> 1510;
3347 -> 3332;
3347 -> 1520;
3347 -> 1512;
3348 -> 1663;
3349 -> 3348;
3349 -> 1532;
3350 -> 3349;
3350 -> 1534;
3350 -> 1532;
3351 -> 1530;
3351 -> 1564;
3351 -> 1659;
3351 -> 3350;
3351 -> 1668;
3351 -> 1558;
3351 -> 1559;
3351 -> 3336;
3351 -> 1566;
3351 -> 1563;
3352 -> 1683;
3353 -> 3352;
3353 -> 1578;
3354 -> 3353;
3354 -> 1580;
3354 -> 1578;
3355 -> 1576;
3355 -> 1610;
3355 -> 1679;
3355 -> 3354;
3355 -> 1688;
3355 -> 1604;
3355 -> 1605;
3355 -> 3340;
3355 -> 1612;
3355 -> 1609;
3356 -> 1624;
3357 -> 3356;
3357 -> 1445;
3358 -> 3357;
3358 -> 1447;
3358 -> 1445;
3359 -> 1643;
3360 -> 3359;
3360 -> 1483;
3361 -> 3360;
3361 -> 1485;
3361 -> 1483;
3362 -> 1481;
3362 -> 1513;
3362 -> 1639;
3362 -> 3361;
3362 -> 1648;
3362 -> 1509;
3362 -> 1510;
3362 -> 3347;
3362 -> 1520;
3362 -> 1512;
3363 -> 1663;
3364 -> 3363;
3364 -> 1532;
3365 -> 3364;
3365 -> 1534;
3365 -> 1532;
3366 -> 1530;
3366 -> 1564;
3366 -> 1659;
3366 -> 3365;
3366 -> 1668;
3366 -> 1558;
3366 -> 1559;
3366 -> 3351;
3366 -> 1566;
3366 -> 1563;
3367 -> 1683;
3368 -> 3367;
3368 -> 1578;
3369 -> 3368;
3369 -> 1580;
3369 -> 1578;
3370 -> 1576;
3370 -> 1610;
3370 -> 1679;
3370 -> 3369;
3370 -> 1688;
3370 -> 1604;
3370 -> 1605;
3370 -> 3355;
3370 -> 1612;
3370 -> 1609;
3371 -> 1624;
3372 -> 3371;
3372 -> 1445;
3373 -> 3372;
3373 -> 1447;
3373 -> 1445;
3374 -> 1643;
3375 -> 3374;
3375 -> 1483;
3376 -> 3375;
3376 -> 1485;
3376 -> 1483;
3377 -> 1481;
3377 -> 1513;
3377 -> 1639;
3377 -> 3376;
3377 -> 1648;
3377 -> 1509;
3377 -> 1510;
3377 -> 3362;
3377 -> 1520;
3377 -> 1512;
3378 -> 1663;
3379 -> 3378;
3379 -> 1532;
3380 -> 3379;
3380 -> 1534;
3380 -> 1532;
3381 -> 1530;
3381 -> 1564;
3381 -> 1659;
3381 -> 3380;
3381 -> 1668;
3381 -> 1558;
3381 -> 1559;
3381 -> 3366;
3381 -> 1566;
3381 -> 1563;
3382 -> 1683;
3383 -> 3382;
3383 -> 1578;
3384 -> 3383;
3384 -> 1580;
3384 -> 1578;
3385 -> 1576;
3385 -> 1610;
3385 -> 1679;
3385 -> 3384;
3385 -> 1688;
3385 -> 1604;
3385 -> 1605;
3385 -> 3370;
3385 -> 1612;
3385 -> 1609;
3386 -> 1624;
3387 -> 3386;
3387 -> 1445;
3388 -> 3387;
3388 -> 1447;
3388 -> 1445;
3389 -> 1643;
3390 -> 3389;
3390 -> 1483;
3391 -> 3390;
3391 -> 1485;
3391 -> 1483;
3392 -> 1481;
3392 -> 1513;
3392 -> 1639;
3392 -> 3391;
3392 -> 1648;
3392 -> 1509;
3392 -> 1510;
3392 -> 3377;
3392 -> 1520;
3392 -> 1512;
3393 -> 1663;
3394 -> 3393;
3394 -> 1532;
3395 -> 3394;
3395 -> 1534;
3395 -> 1532;
3396 -> 1530;
3396 -> 1564;
3396 -> 1659;
3396 -> 3395;
3396 -> 1668;
3396 -> 1558;
3396 -> 1559;
3396 -> 3381;
3396 -> 1566;
3396 -> 1563;
3397 -> 1683;
3398 -> 3397;
3398 -> 1578;
3399 -> 3398;
3399 -> 1580;
3399 -> 1578;
3400 -> 1576;
3400 -> 1610;
3400 -> 1679;
3400 -> 3399;
3400 -> 1688;
3400 -> 1604;
3400 -> 1605;
3400 -> 3385;
3400 -> 1612;
3400 -> 1609;
3401 -> 1624;
3402 -> 3401;
3402 -> 1445;
3403 -> 3402;
3403 -> 1447;
3403 -> 1445;
3404 -> 1643;
3405 -> 3404;
3405 -> 1483;
3406 -> 3405;
3406 -> 1485;
3406 -> 1483;
3407 -> 1481;
3407 -> 1513;
3407 -> 1639;
3407 -> 3406;
3407 -> 1648;
3407 -> 1509;
3407 -> 1510;
3407 -> 3392;
3407 -> 1520;
3407 -> 1512;
3408 -> 1663;
3409 -> 3408;
3409 -> 1532;
3410 -> 3409;
3410 -> 1534;
3410 -> 1532;
3411 -> 1530;
3411 -> 1564;
3411 -> 1659;
3411 -> 3410;
3411 -> 1668;
3411 -> 1558;
3411 -> 1559;
3411 -> 3396;
3411 -> 1566;
3411 -> 1563;
3412 -> 1683;
3413 -> 3412;
3413 -> 1578;
3414 -> 3413;
3414 -> 1580;
3414 -> 1578;
3415 -> 1576;
3415 -> 1610;
3415 -> 1679;
3415 -> 3414;
3415 -> 1688;
3415 -> 1604;
3415 -> 1605;
3415 -> 3400;
3415 -> 1612;
3415 -> 1609;
3416 -> 1624;
3417 -> 3416;
3417 -> 1445;
3418 -> 3417;
3418 -> 1447;
3418 -> 1445;
3419 -> 1643;
3420 -> 3419;
3420 -> 1483;
3421 -> 3420;
3421 -> 1485;
3421 -> 1483;
3422 -> 1481;
3422 -> 1513;
3422 -> 1639;
3422 -> 3421;
3422 -> 1648;
3422 -> 1509;
3422 -> 1510;
3422 -> 3407;
3422 -> 1520;
3422 -> 1512;
3423 -> 1663;
3424 -> 3423;
3424 -> 1532;
3425 -> 3424;
3425 -> 1534;
3425 -> 1532;
3426 -> 1530;
3426 -> 1564;
3426 -> 1659;
3426 -> 3425;
3426 -> 1668;
3426 -> 1558;
3426 -> 1559;
3426 -> 3411;
3426 -> 1566;
3426 -> 1563;
3427 -> 1683;
3428 -> 3427;
3428 -> 1578;
3429 -> 3428;
3429 -> 1580;
3429 -> 1578;
3430 -> 1576;
3430 -> 1610;
3430 -> 1679;
3430 -> 3429;
3430 -> 1688;
3430 -> 1604;
3430 -> 1605;
3430 -> 3415;
3430 -> 1612;
3430 -> 1609;
3431 -> 1624;
3432 -> 3431;
3432 -> 1445;
3433 -> 3432;
3433 -> 1447;
3433 -> 1445;
3434 -> 1643;
3435 -> 3434;
3435 -> 1483;
3436 -> 3435;
3436 -> 1485;
3436 -> 1483;
3437 -> 1481;
3437 -> 1513;
3437 -> 1639;
3437 -> 3436;
3437 -> 1648;
3437 -> 1509;
3437 -> 1510;
3437 -> 3422;
3437 -> 1520;
3437 -> 1512;
3438 -> 1663;
3439 -> 3438;
3439 -> 1532;
3440 -> 3439;
3440 -> 1534;
3440 -> 1532;
3441 -> 1530;
3441 -> 1564;
3441 -> 1659;
3441 -> 3440;
3441 -> 1668;
3441 -> 1558;
3441 -> 1559;
3441 -> 3426;
3441 -> 1566;
3441 -> 1563;
3442 -> 1683;
3443 -> 3442;
3443 -> 1578;
3444 -> 3443;
3444 -> 1580;
3444 -> 1578;
3445 -> 1576;
3445 -> 1610;
3445 -> 1679;
3445 -> 3444;
3445 -> 1688;
3445 -> 1604;
3445 -> 1605;
3445 -> 3430;
3445 -> 1612;
3445 -> 1609;
3446 -> 1624;
3447 -> 3446;
3447 -> 1445;
3448 -> 3447;
3448 -> 1447;
3448 -> 1445;
3449 -> 1643;
3450 -> 3449;
3450 -> 1483;
3451 -> 3450;
3451 -> 1485;
3451 -> 1483;
3452 -> 1481;
3452 -> 1513;
3452 -> 1639;
3452 -> 3451;
3452 -> 1648;
3452 -> 1509;
3452 -> 1510;
3452 -> 3437;
3452 -> 1520;
3452 -> 1512;
3453 -> 1663;
3454 -> 3453;
3454 -> 1532;
3455 -> 3454;
3455 -> 1534;
3455 -> 1532;
3456 -> 1530;
3456 -> 1564;
3456 -> 1659;
3456 -> 3455;
3456 -> 1668;
3456 -> 1558;
3456 -> 1559;
3456 -> 3441;
3456 -> 1566;
3456 -> 1563;
3457 -> 1683;
3458 -> 3457;
3458 -> 1578;
3459 -> 3458;
3459 -> 1580;
3459 -> 1578;
3460 -> 1576;
3460 -> 1610;
3460 -> 1679;
3460 -> 3459;
3460 -> 1688;
3460 -> 1604;
3460 -> 1605;
3460 -> 3445;
3460 -> 1612;
3460 -> 1609;
3461 -> 1624;
3462 -> 3461;
3462 -> 1445;
3463 -> 3462;
3463 -> 1447;
3463 -> 1445;
3464 -> 1643;
3465 -> 3464;
3465 -> 1483;
3466 -> 3465;
3466 -> 1485;
3466 -> 1483;
3467 -> 1481;
3467 -> 1513;
3467 -> 1639;
3467 -> 3466;
3467 -> 1648;
3467 -> 1509;
3467 -> 1510;
3467 -> 3452;
3467 -> 1520;
3467 -> 1512;
3468 -> 1663;
3469 -> 3468;
3469 -> 1532;
3470 -> 3469;
3470 -> 1534;
3470 -> 1532;
3471 -> 1530;
3471 -> 1564;
3471 -> 1659;
3471 -> 3470;
3471 -> 1668;
3471 -> 1558;
3471 -> 1559;
3471 -> 3456;
3471 -> 1566;
3471 -> 1563;
3472 -> 1683;
3473 -> 3472;
3473 -> 1578;
3474 -> 3473;
3474 -> 1580;
3474 -> 1578;
3475 -> 1576;
3475 -> 1610;
3475 -> 1679;
3475 -> 3474;
3475 -> 1688;
3475 -> 1604;
3475 -> 1605;
3475 -> 3460;
3475 -> 1612;
3475 -> 1609;
3476 -> 1624;
3477 -> 3476;
3477 -> 1445;
3478 -> 3477;
3478 -> 1447;
3478 -> 1445;
3479 -> 1643;
3480 -> 3479;
3480 -> 1483;
3481 -> 3480;
3481 -> 1485;
3481 -> 1483;
3482 -> 1481;
3482 -> 1513;
3482 -> 1639;
3482 -> 3481;
3482 -> 1648;
3482 -> 1509;
3482 -> 1510;
3482 -> 3467;
3482 -> 1520;
3482 -> 1512;
3483 -> 1663;
3484 -> 3483;
3484 -> 1532;
3485 -> 3484;
3485 -> 1534;
3485 -> 1532;
3486 -> 1530;
3486 -> 1564;
3486 -> 1659;
3486 -> 3485;
3486 -> 1668;
3486 -> 1558;
3486 -> 1559;
3486 -> 3471;
3486 -> 1566;
3486 -> 1563;
3487 -> 1683;
3488 -> 3487;
3488 -> 1578;
3489 -> 3488;
3489 -> 1580;
3489 -> 1578;
3490 -> 1576;
3490 -> 1610;
3490 -> 1679;
3490 -> 3489;
3490 -> 1688;
3490 -> 1604;
3490 -> 1605;
3490 -> 3475;
3490 -> 1612;
3490 -> 1609;
3491 -> 1624;
3492 -> 3491;
3492 -> 1445;
3493 -> 3492;
3493 -> 1447;
3493 -> 1445;
3494 -> 1643;
3495 -> 3494;
3495 -> 1483;
3496 -> 3495;
3496 -> 1485;
3496 -> 1483;
3497 -> 1481;
3497 -> 1513;
3497 -> 1639;
3497 -> 3496;
3497 -> 1648;
3497 -> 1509;
3497 -> 1510;
3497 -> 3482;
3497 -> 1520;
3497 -> 1512;
3498 -> 1663;
3499 -> 3498;
3499 -> 1532;
3500 -> 3499;
3500 -> 1534;
3500 -> 1532;
3501 -> 1530;
3501 -> 1564;
3501 -> 1659;
3501 -> 3500;
3501 -> 1668;
3501 -> 1558;
3501 -> 1559;
3501 -> 3486;
3501 -> 1566;
3501 -> 1563;
3502 -> 1683;
3503 -> 3502;
3503 -> 1578;
3504 -> 3503;
3504 -> 1580;
3504 -> 1578;
3505 -> 1576;
3505 -> 1610;
3505 -> 1679;
3505 -> 3504;
3505 -> 1688;
3505 -> 1604;
3505 -> 1605;
3505 -> 3490;
3505 -> 1612;
3505 -> 1609;
3506 -> 1624;
3507 -> 3506;
3507 -> 1445;
3508 -> 3507;
3508 -> 1447;
3508 -> 1445;
3509 -> 1643;
3510 -> 3509;
3510 -> 1483;
3511 -> 3510;
3511 -> 1485;
3511 -> 1483;
3512 -> 1481;
3512 -> 1513;
3512 -> 1639;
3512 -> 3511;
3512 -> 1648;
3512 -> 1509;
3512 -> 1510;
3512 -> 3497;
3512 -> 1520;
3512 -> 1512;
3513 -> 1663;
3514 -> 3513;
3514 -> 1532;
3515 -> 3514;
3515 -> 1534;
3515 -> 1532;
3516 -> 1530;
3516 -> 1564;
3516 -> 1659;
3516 -> 3515;
3516 -> 1668;
3516 -> 1558;
3516 -> 1559;
3516 -> 3501;
3516 -> 1566;
3516 -> 1563;
3517 -> 1683;
3518 -> 3517;
3518 -> 1578;
3519 -> 3518;
3519 -> 1580;
3519 -> 1578;
3520 -> 1576;
3520 -> 1610;
3520 -> 1679;
3520 -> 3519;
3520 -> 1688;
3520 -> 1604;
3520 -> 1605;
3520 -> 3505;
3520 -> 1612;
3520 -> 1609;
3521 -> 1624;
3522 -> 3521;
3522 -> 1445;
3523 -> 3522;
3523 -> 1447;
3523 -> 1445;
3524 -> 1643;
3525 -> 3524;
3525 -> 1483;
3526 -> 3525;
3526 -> 1485;
3526 -> 1483;
3527 -> 1481;
3527 -> 1513;
3527 -> 1639;
3527 -> 3526;
3527 -> 1648;
3527 -> 1509;
3527 -> 1510;
3527 -> 3512;
3527 -> 1520;
3527 -> 1512;
3528 -> 1663;
3529 -> 3528;
3529 -> 1532;
3530 -> 3529;
3530 -> 1534;
3530 -> 1532;
3531 -> 1530;
3531 -> 1564;
3531 -> 1659;
3531 -> 3530;
3531 -> 1668;
3531 -> 1558;
3531 -> 1559;
3531 -> 3516;
3531 -> 1566;
3531 -> 1563;
3532 -> 1683;
3533 -> 3532;
3533 -> 1578;
3534 -> 3533;
3534 -> 1580;
3534 -> 1578;
3535 -> 1576;
3535 -> 1610;
3535 -> 1679;
3535 -> 3534;
3535 -> 1688;
3535 -> 1604;
3535 -> 1605;
3535 -> 3520;
3535 -> 1612;
3535 -> 1609;
3536 -> 1624;
3537 -> 3536;
3537 -> 1445;
3538 -> 3537;
3538 -> 1447;
3538 -> 1445;
3539 -> 1643;
3540 -> 3539;
3540 -> 1483;
3541 -> 3540;
3541 -> 1485;
3541 -> 1483;
3542 -> 1481;
3542 -> 1513;
3542 -> 1639;
3542 -> 3541;
3542 -> 1648;
3542 -> 1509;
3542 -> 1510;
3542 -> 3527;
3542 -> 1520;
3542 -> 1512;
3543 -> 1663;
3544 -> 3543;
3544 -> 1532;
3545 -> 3544;
3545 -> 1534;
3545 -> 1532;
3546 -> 1530;
3546 -> 1564;
3546 -> 1659;
3546 -> 3545;
3546 -> 1668;
3546 -> 1558;
3546 -> 1559;
3546 -> 3531;
3546 -> 1566;
3546 -> 1563;
3547 -> 1683;
3548 -> 3547;
3548 -> 1578;
3549 -> 3548;
3549 -> 1580;
3549 -> 1578;
3550 -> 1576;
3550 -> 1610;
3550 -> 1679;
3550 -> 3549;
3550 -> 1688;
3550 -> 1604;
3550 -> 1605;
3550 -> 3535;
3550 -> 1612;
3550 -> 1609;
3551 -> 1624;
3552 -> 3551;
3552 -> 1445;
3553 -> 3552;
3553 -> 1447;
3553 -> 1445;
3554 -> 1643;
3555 -> 3554;
3555 -> 1483;
3556 -> 3555;
3556 -> 1485;
3556 -> 1483;
3557 -> 1481;
3557 -> 1513;
3557 -> 1639;
3557 -> 3556;
3557 -> 1648;
3557 -> 1509;
3557 -> 1510;
3557 -> 3542;
3557 -> 1520;
3557 -> 1512;
3558 -> 1663;
3559 -> 3558;
3559 -> 1532;
3560 -> 3559;
3560 -> 1534;
3560 -> 1532;
3561 -> 1530;
3561 -> 1564;
3561 -> 1659;
3561 -> 3560;
3561 -> 1668;
3561 -> 1558;
3561 -> 1559;
3561 -> 3546;
3561 -> 1566;
3561 -> 1563;
3562 -> 1683;
3563 -> 3562;
3563 -> 1578;
3564 -> 3563;
3564 -> 1580;
3564 -> 1578;
3565 -> 1576;
3565 -> 1610;
3565 -> 1679;
3565 -> 3564;
3565 -> 1688;
3565 -> 1604;
3565 -> 1605;
3565 -> 3550;
3565 -> 1612;
3565 -> 1609;
3566 -> 1624;
3567 -> 3566;
3567 -> 1445;
3568 -> 3567;
3568 -> 1447;
3568 -> 1445;
3569 -> 1643;
3570 -> 3569;
3570 -> 1483;
3571 -> 3570;
3571 -> 1485;
3571 -> 1483;
3572 -> 1481;
3572 -> 1513;
3572 -> 1639;
3572 -> 3571;
3572 -> 1648;
3572 -> 1509;
3572 -> 1510;
3572 -> 3557;
3572 -> 1520;
3572 -> 1512;
3573 -> 1663;
3574 -> 3573;
3574 -> 1532;
3575 -> 3574;
3575 -> 1534;
3575 -> 1532;
3576 -> 1530;
3576 -> 1564;
3576 -> 1659;
3576 -> 3575;
3576 -> 1668;
3576 -> 1558;
3576 -> 1559;
3576 -> 3561;
3576 -> 1566;
3576 -> 1563;
3577 -> 1683;
3578 -> 3577;
3578 -> 1578;
3579 -> 3578;
3579 -> 1580;
3579 -> 1578;
3580 -> 1576;
3580 -> 1610;
3580 -> 1679;
3580 -> 3579;
3580 -> 1688;
3580 -> 1604;
3580 -> 1605;
3580 -> 3565;
3580 -> 1612;
3580 -> 1609;
3581 -> 1624;
3582 -> 3581;
3582 -> 1445;
3583 -> 3582;
3583 -> 1447;
3583 -> 1445;
3584 -> 1643;
3585 -> 3584;
3585 -> 1483;
3586 -> 3585;
3586 -> 1485;
3586 -> 1483;
3587 -> 1481;
3587 -> 1513;
3587 -> 1639;
3587 -> 3586;
3587 -> 1648;
3587 -> 1509;
3587 -> 1510;
3587 -> 3572;
3587 -> 1520;
3587 -> 1512;
3588 -> 1663;
3589 -> 3588;
3589 -> 1532;
3590 -> 3589;
3590 -> 1534;
3590 -> 1532;
3591 -> 1530;
3591 -> 1564;
3591 -> 1659;
3591 -> 3590;
3591 -> 1668;
3591 -> 1558;
3591 -> 1559;
3591 -> 3576;
3591 -> 1566;
3591 -> 1563;
3592 -> 1683;
3593 -> 3592;
3593 -> 1578;
3594 -> 3593;
3594 -> 1580;
3594 -> 1578;
3595 -> 1576;
3595 -> 1610;
3595 -> 1679;
3595 -> 3594;
3595 -> 1688;
3595 -> 1604;
3595 -> 1605;
3595 -> 3580;
3595 -> 1612;
3595 -> 1609;
3596 -> 1624;
3597 -> 3596;
3597 -> 1445;
3598 -> 3597;
3598 -> 1447;
3598 -> 1445;
3599 -> 1643;
3600 -> 3599;
3600 -> 1483;
3601 -> 3600;
3601 -> 1485;
3601 -> 1483;
3602 -> 1481;
3602 -> 1513;
3602 -> 1639;
3602 -> 3601;
3602 -> 1648;
3602 -> 1509;
3602 -> 1510;
3602 -> 3587;
3602 -> 1520;
3602 -> 1512;
3603 -> 1663;
3604 -> 3603;
3604 -> 1532;
3605 -> 3604;
3605 -> 1534;
3605 -> 1532;
3606 -> 1530;
3606 -> 1564;
3606 -> 1659;
3606 -> 3605;
3606 -> 1668;
3606 -> 1558;
3606 -> 1559;
3606 -> 3591;
3606 -> 1566;
3606 -> 1563;
3607 -> 1683;
3608 -> 3607;
3608 -> 1578;
3609 -> 3608;
3609 -> 1580;
3609 -> 1578;
3610 -> 1576;
3610 -> 1610;
3610 -> 1679;
3610 -> 3609;
3610 -> 1688;
3610 -> 1604;
3610 -> 1605;
3610 -> 3595;
3610 -> 1612;
3610 -> 1609;
3611 -> 1624;
3612 -> 3611;
3612 -> 1445;
3613 -> 3612;
3613 -> 1447;
3613 -> 1445;
3614 -> 1643;
3615 -> 3614;
3615 -> 1483;
3616 -> 3615;
3616 -> 1485;
3616 -> 1483;
3617 -> 1481;
3617 -> 1513;
3617 -> 1639;
3617 -> 3616;
3617 -> 1648;
3617 -> 1509;
3617 -> 1510;
3617 -> 3602;
3617 -> 1520;
3617 -> 1512;
3618 -> 1663;
3619 -> 3618;
3619 -> 1532;
3620 -> 3619;
3620 -> 1534;
3620 -> 1532;
3621 -> 1530;
3621 -> 1564;
3621 -> 1659;
3621 -> 3620;
3621 -> 1668;
3621 -> 1558;
3621 -> 1559;
3621 -> 3606;
3621 -> 1566;
3621 -> 1563;
3622 -> 1683;
3623 -> 3622;
3623 -> 1578;
3624 -> 3623;
3624 -> 1580;
3624 -> 1578;
3625 -> 1576;
3625 -> 1610;
3625 -> 1679;
3625 -> 3624;
3625 -> 1688;
3625 -> 1604;
3625 -> 1605;
3625 -> 3610;
3625 -> 1612;
3625 -> 1609;
3626 -> 1624;
3627 -> 3626;
3627 -> 1445;
3628 -> 3627;
3628 -> 1447;
3628 -> 1445;
3629 -> 1643;
3630 -> 3629;
3630 -> 1483;
3631 -> 3630;
3631 -> 1485;
3631 -> 1483;
3632 -> 1481;
3632 -> 1513;
3632 -> 1639;
3632 -> 3631;
3632 -> 1648;
3632 -> 1509;
3632 -> 1510;
3632 -> 3617;
3632 -> 1520;
3632 -> 1512;
3633 -> 1663;
3634 -> 3633;
3634 -> 1532;
3635 -> 3634;
3635 -> 1534;
3635 -> 1532;
3636 -> 1530;
3636 -> 1564;
3636 -> 1659;
3636 -> 3635;
3636 -> 1668;
3636 -> 1558;
3636 -> 1559;
3636 -> 3621;
3636 -> 1566;
3636 -> 1563;
3637 -> 1683;
3638 -> 3637;
3638 -> 1578;
3639 -> 3638;
3639 -> 1580;
3639 -> 1578;
3640 -> 1576;
3640 -> 1610;
3640 -> 1679;
3640 -> 3639;
3640 -> 1688;
3640 -> 1604;
3640 -> 1605;
3640 -> 3625;
3640 -> 1612;
3640 -> 1609;
3641 -> 1624;
3642 -> 3641;
3642 -> 1445;
3643 -> 3642;
3643 -> 1447;
3643 -> 1445;
3644 -> 1643;
3645 -> 3644;
3645 -> 1483;
3646 -> 3645;
3646 -> 1485;
3646 -> 1483;
3647 -> 1481;
3647 -> 1513;
3647 -> 1639;
3647 -> 3646;
3647 -> 1648;
3647 -> 1509;
3647 -> 1510;
3647 -> 3632;
3647 -> 1520;
3647 -> 1512;
3648 -> 1663;
3649 -> 3648;
3649 -> 1532;
3650 -> 3649;
3650 -> 1534;
3650 -> 1532;
3651 -> 1530;
3651 -> 1564;
3651 -> 1659;
3651 -> 3650;
3651 -> 1668;
3651 -> 1558;
3651 -> 1559;
3651 -> 3636;
3651 -> 1566;
3651 -> 1563;
3652 -> 1683;
3653 -> 3652;
3653 -> 1578;
3654 -> 3653;
3654 -> 1580;
3654 -> 1578;
3655 -> 1576;
3655 -> 1610;
3655 -> 1679;
3655 -> 3654;
3655 -> 1688;
3655 -> 1604;
3655 -> 1605;
3655 -> 3640;
3655 -> 1612;
3655 -> 1609;
3656 -> 1624;
3657 -> 3656;
3657 -> 1445;
3658 -> 3657;
3658 -> 1447;
3658 -> 1445;
3659 -> 1643;
3660 -> 3659;
3660 -> 1483;
3661 -> 3660;
3661 -> 1485;
3661 -> 1483;
3662 -> 1481;
3662 -> 1513;
3662 -> 1639;
3662 -> 3661;
3662 -> 1648;
3662 -> 1509;
3662 -> 1510;
3662 -> 3647;
3662 -> 1520;
3662 -> 1512;
3663 -> 1663;
3664 -> 3663;
3664 -> 1532;
3665 -> 3664;
3665 -> 1534;
3665 -> 1532;
3666 -> 1530;
3666 -> 1564;
3666 -> 1659;
3666 -> 3665;
3666 -> 1668;
3666 -> 1558;
3666 -> 1559;
3666 -> 3651;
3666 -> 1566;
3666 -> 1563;
3667 -> 1683;
3668 -> 3667;
3668 -> 1578;
3669 -> 3668;
3669 -> 1580;
3669 -> 1578;
3670 -> 1576;
3670 -> 1610;
3670 -> 1679;
3670 -> 3669;
3670 -> 1688;
3670 -> 1604;
3670 -> 1605;
3670 -> 3655;
3670 -> 1612;
3670 -> 1609;
3671 -> 1624;
3672 -> 3671;
3672 -> 1445;
3673 -> 3672;
3673 -> 1447;
3673 -> 1445;
3674 -> 1643;
3675 -> 3674;
3675 -> 1483;
3676 -> 3675;
3676 -> 1485;
3676 -> 1483;
3677 -> 1481;
3677 -> 1513;
3677 -> 1639;
3677 -> 3676;
3677 -> 1648;
3677 -> 1509;
3677 -> 1510;
3677 -> 3662;
3677 -> 1520;
3677 -> 1512;
3678 -> 1663;
3679 -> 3678;
3679 -> 1532;
3680 -> 3679;
3680 -> 1534;
3680 -> 1532;
3681 -> 1530;
3681 -> 1564;
3681 -> 1659;
3681 -> 3680;
3681 -> 1668;
3681 -> 1558;
3681 -> 1559;
3681 -> 3666;
3681 -> 1566;
3681 -> 1563;
3682 -> 1683;
3683 -> 3682;
3683 -> 1578;
3684 -> 3683;
3684 -> 1580;
3684 -> 1578;
3685 -> 1576;
3685 -> 1610;
3685 -> 1679;
3685 -> 3684;
3685 -> 1688;
3685 -> 1604;
3685 -> 1605;
3685 -> 3670;
3685 -> 1612;
3685 -> 1609;
3686 -> 1624;
3687 -> 3686;
3687 -> 1445;
3688 -> 3687;
3688 -> 1447;
3688 -> 1445;
3689 -> 1643;
3690 -> 3689;
3690 -> 1483;
3691 -> 3690;
3691 -> 1485;
3691 -> 1483;
3692 -> 1481;
3692 -> 1513;
3692 -> 1639;
3692 -> 3691;
3692 -> 1648;
3692 -> 1509;
3692 -> 1510;
3692 -> 3677;
3692 -> 1520;
3692 -> 1512;
3693 -> 1663;
3694 -> 3693;
3694 -> 1532;
3695 -> 3694;
3695 -> 1534;
3695 -> 1532;
3696 -> 1530;
3696 -> 1564;
3696 -> 1659;
3696 -> 3695;
3696 -> 1668;
3696 -> 1558;
3696 -> 1559;
3696 -> 3681;
3696 -> 1566;
3696 -> 1563;
3697 -> 1683;
3698 -> 3697;
3698 -> 1578;
3699 -> 3698;
3699 -> 1580;
3699 -> 1578;
3700 -> 1576;
3700 -> 1610;
3700 -> 1679;
3700 -> 3699;
3700 -> 1688;
3700 -> 1604;
3700 -> 1605;
3700 -> 3685;
3700 -> 1612;
3700 -> 1609;
3701 -> 1624;
3702 -> 3701;
3702 -> 1445;
3703 -> 3702;
3703 -> 1447;
3703 -> 1445;
3704 -> 1643;
3705 -> 3704;
3705 -> 1483;
3706 -> 3705;
3706 -> 1485;
3706 -> 1483;
3707 -> 1481;
3707 -> 1513;
3707 -> 1639;
3707 -> 3706;
3707 -> 1648;
3707 -> 1509;
3707 -> 1510;
3707 -> 3692;
3707 -> 1520;
3707 -> 1512;
3708 -> 1663;
3709 -> 3708;
3709 -> 1532;
3710 -> 3709;
3710 -> 1534;
3710 -> 1532;
3711 -> 1530;
3711 -> 1564;
3711 -> 1659;
3711 -> 3710;
3711 -> 1668;
3711 -> 1558;
3711 -> 1559;
3711 -> 3696;
3711 -> 1566;
3711 -> 1563;
3712 -> 1683;
3713 -> 3712;
3713 -> 1578;
3714 -> 3713;
3714 -> 1580;
3714 -> 1578;
3715 -> 1576;
3715 -> 1610;
3715 -> 1679;
3715 -> 3714;
3715 -> 1688;
3715 -> 1604;
3715 -> 1605;
3715 -> 3700;
3715 -> 1612;
3715 -> 1609;
3716 -> 1624;
3717 -> 3716;
3717 -> 1445;
3718 -> 3717;
3718 -> 1447;
3718 -> 1445;
3719 -> 1643;
3720 -> 3719;
3720 -> 1483;
3721 -> 3720;
3721 -> 1485;
3721 -> 1483;
3722 -> 1481;
3722 -> 1513;
3722 -> 1639;
3722 -> 3721;
3722 -> 1648;
3722 -> 1509;
3722 -> 1510;
3722 -> 3707;
3722 -> 1520;
3722 -> 1512;
3723 -> 1663;
3724 -> 3723;
3724 -> 1532;
3725 -> 3724;
3725 -> 1534;
3725 -> 1532;
3726 -> 1530;
3726 -> 1564;
3726 -> 1659;
3726 -> 3725;
3726 -> 1668;
3726 -> 1558;
3726 -> 1559;
3726 -> 3711;
3726 -> 1566;
3726 -> 1563;
3727 -> 1683;
3728 -> 3727;
3728 -> 1578;
3729 -> 3728;
3729 -> 1580;
3729 -> 1578;
3730 -> 1576;
3730 -> 1610;
3730 -> 1679;
3730 -> 3729;
3730 -> 1688;
3730 -> 1604;
3730 -> 1605;
3730 -> 3715;
3730 -> 1612;
3730 -> 1609;
3731 -> 1624;
3732 -> 3731;
3732 -> 1445;
3733 -> 3732;
3733 -> 1447;
3733 -> 1445;
3734 -> 1643;
3735 -> 3734;
3735 -> 1483;
3736 -> 3735;
3736 -> 1485;
3736 -> 1483;
3737 -> 1481;
3737 -> 1513;
3737 -> 1639;
3737 -> 3736;
3737 -> 1648;
3737 -> 1509;
3737 -> 1510;
3737 -> 3722;
3737 -> 1520;
3737 -> 1512;
3738 -> 1663;
3739 -> 3738;
3739 -> 1532;
3740 -> 3739;
3740 -> 1534;
3740 -> 1532;
3741 -> 1530;
3741 -> 1564;
3741 -> 1659;
3741 -> 3740;
3741 -> 1668;
3741 -> 1558;
3741 -> 1559;
3741 -> 3726;
3741 -> 1566;
3741 -> 1563;
3742 -> 1683;
3743 -> 3742;
3743 -> 1578;
3744 -> 3743;
3744 -> 1580;
3744 -> 1578;
3745 -> 1576;
3745 -> 1610;
3745 -> 1679;
3745 -> 3744;
3745 -> 1688;
3745 -> 1604;
3745 -> 1605;
3745 -> 3730;
3745 -> 1612;
3745 -> 1609;
3746 -> 1624;
3747 -> 3746;
3747 -> 1445;
3748 -> 3747;
3748 -> 1447;
3748 -> 1445;
3749 -> 1643;
3750 -> 3749;
3750 -> 1483;
3751 -> 3750;
3751 -> 1485;
3751 -> 1483;
3752 -> 1481;
3752 -> 1513;
3752 -> 1639;
3752 -> 3751;
3752 -> 1648;
3752 -> 1509;
3752 -> 1510;
3752 -> 3737;
3752 -> 1520;
3752 -> 1512;
3753 -> 1663;
3754 -> 3753;
3754 -> 1532;
3755 -> 3754;
3755 -> 1534;
3755 -> 1532;
3756 -> 1530;
3756 -> 1564;
3756 -> 1659;
3756 -> 3755;
3756 -> 1668;
3756 -> 1558;
3756 -> 1559;
3756 -> 3741;
3756 -> 1566;
3756 -> 1563;
3757 -> 1683;
3758 -> 3757;
3758 -> 1578;
3759 -> 3758;
3759 -> 1580;
3759 -> 1578;
3760 -> 1576;
3760 -> 1610;
3760 -> 1679;
3760 -> 3759;
3760 -> 1688;
3760 -> 1604;
3760 -> 1605;
3760 -> 3745;
3760 -> 1612;
3760 -> 1609;
3761 -> 1624;
3762 -> 3761;
3762 -> 1445;
3763 -> 3762;
3763 -> 1447;
3763 -> 1445;
3764 -> 1643;
3765 -> 3764;
3765 -> 1483;
3766 -> 3765;
3766 -> 1485;
3766 -> 1483;
3767 -> 1481;
3767 -> 1513;
3767 -> 1639;
3767 -> 3766;
3767 -> 1648;
3767 -> 1509;
3767 -> 1510;
3767 -> 3752;
3767 -> 1520;
3767 -> 1512;
3768 -> 1663;
3769 -> 3768;
3769 -> 1532;
3770 -> 3769;
3770 -> 1534;
3770 -> 1532;
3771 -> 1530;
3771 -> 1564;
3771 -> 1659;
3771 -> 3770;
3771 -> 1668;
3771 -> 1558;
3771 -> 1559;
3771 -> 3756;
3771 -> 1566;
3771 -> 1563;
3772 -> 1683;
3773 -> 3772;
3773 -> 1578;
3774 -> 3773;
3774 -> 1580;
3774 -> 1578;
3775 -> 1576;
3775 -> 1610;
3775 -> 1679;
3775 -> 3774;
3775 -> 1688;
3775 -> 1604;
3775 -> 1605;
3775 -> 3760;
3775 -> 1612;
3775 -> 1609;
3776 -> 1624;
3777 -> 3776;
3777 -> 1445;
3778 -> 3777;
3778 -> 1447;
3778 -> 1445;
3779 -> 1643;
3780 -> 3779;
3780 -> 1483;
3781 -> 3780;
3781 -> 1485;
3781 -> 1483;
3782 -> 1481;
3782 -> 1513;
3782 -> 1639;
3782 -> 3781;
3782 -> 1648;
3782 -> 1509;
3782 -> 1510;
3782 -> 3767;
3782 -> 1520;
3782 -> 1512;
3783 -> 1663;
3784 -> 3783;
3784 -> 1532;
3785 -> 3784;
3785 -> 1534;
3785 -> 1532;
3786 -> 1530;
3786 -> 1564;
3786 -> 1659;
3786 -> 3785;
3786 -> 1668;
3786 -> 1558;
3786 -> 1559;
3786 -> 3771;
3786 -> 1566;
3786 -> 1563;
3787 -> 1683;
3788 -> 3787;
3788 -> 1578;
3789 -> 3788;
3789 -> 1580;
3789 -> 1578;
3790 -> 1576;
3790 -> 1610;
3790 -> 1679;
3790 -> 3789;
3790 -> 1688;
3790 -> 1604;
3790 -> 1605;
3790 -> 3775;
3790 -> 1612;
3790 -> 1609;
3791 -> 1624;
3792 -> 3791;
3792 -> 1445;
3793 -> 3792;
3793 -> 1447;
3793 -> 1445;
3794 -> 1643;
3795 -> 3794;
3795 -> 1483;
3796 -> 3795;
3796 -> 1485;
3796 -> 1483;
3797 -> 1481;
3797 -> 1513;
3797 -> 1639;
3797 -> 3796;
3797 -> 1648;
3797 -> 1509;
3797 -> 1510;
3797 -> 3782;
3797 -> 1520;
3797 -> 1512;
3798 -> 1663;
3799 -> 3798;
3799 -> 1532;
3800 -> 3799;
3800 -> 1534;
3800 -> 1532;
3801 -> 1530;
3801 -> 1564;
3801 -> 1659;
3801 -> 3800;
3801 -> 1668;
3801 -> 1558;
3801 -> 1559;
3801 -> 3786;
3801 -> 1566;
3801 -> 1563;
3802 -> 1683;
3803 -> 3802;
3803 -> 1578;
3804 -> 3803;
3804 -> 1580;
3804 -> 1578;
3805 -> 1576;
3805 -> 1610;
3805 -> 1679;
3805 -> 3804;
3805 -> 1688;
3805 -> 1604;
3805 -> 1605;
3805 -> 3790;
3805 -> 1612;
3805 -> 1609;
3806 -> 1624;
3807 -> 3806;
3807 -> 1445;
3808 -> 3807;
3808 -> 1447;
3808 -> 1445;
3809 -> 1643;
3810 -> 3809;
3810 -> 1483;
3811 -> 3810;
3811 -> 1485;
3811 -> 1483;
3812 -> 1481;
3812 -> 1513;
3812 -> 1639;
3812 -> 3811;
3812 -> 1648;
3812 -> 1509;
3812 -> 1510;
3812 -> 3797;
3812 -> 1520;
3812 -> 1512;
3813 -> 1663;
3814 -> 3813;
3814 -> 1532;
3815 -> 3814;
3815 -> 1534;
3815 -> 1532;
3816 -> 1530;
3816 -> 1564;
3816 -> 1659;
3816 -> 3815;
3816 -> 1668;
3816 -> 1558;
3816 -> 1559;
3816 -> 3801;
3816 -> 1566;
3816 -> 1563;
3817 -> 1683;
3818 -> 3817;
3818 -> 1578;
3819 -> 3818;
3819 -> 1580;
3819 -> 1578;
3820 -> 1576;
3820 -> 1610;
3820 -> 1679;
3820 -> 3819;
3820 -> 1688;
3820 -> 1604;
3820 -> 1605;
3820 -> 3805;
3820 -> 1612;
3820 -> 1609;
3821 -> 1624;
3822 -> 3821;
3822 -> 1445;
3823 -> 3822;
3823 -> 1447;
3823 -> 1445;
3824 -> 1643;
3825 -> 3824;
3825 -> 1483;
3826 -> 3825;
3826 -> 1485;
3826 -> 1483;
3827 -> 1481;
3827 -> 1513;
3827 -> 1639;
3827 -> 3826;
3827 -> 1648;
3827 -> 1509;
3827 -> 1510;
3827 -> 3812;
3827 -> 1520;
3827 -> 1512;
3828 -> 1663;
3829 -> 3828;
3829 -> 1532;
3830 -> 3829;
3830 -> 1534;
3830 -> 1532;
3831 -> 1530;
3831 -> 1564;
3831 -> 1659;
3831 -> 3830;
3831 -> 1668;
3831 -> 1558;
3831 -> 1559;
3831 -> 3816;
3831 -> 1566;
3831 -> 1563;
3832 -> 1683;
3833 -> 3832;
3833 -> 1578;
3834 -> 3833;
3834 -> 1580;
3834 -> 1578;
3835 -> 1576;
3835 -> 1610;
3835 -> 1679;
3835 -> 3834;
3835 -> 1688;
3835 -> 1604;
3835 -> 1605;
3835 -> 3820;
3835 -> 1612;
3835 -> 1609;
3836 -> 1624;
3837 -> 3836;
3837 -> 1445;
3838 -> 3837;
3838 -> 1447;
3838 -> 1445;
3839 -> 1643;
3840 -> 3839;
3840 -> 1483;
3841 -> 3840;
3841 -> 1485;
3841 -> 1483;
3842 -> 1481;
3842 -> 1513;
3842 -> 1639;
3842 -> 3841;
3842 -> 1648;
3842 -> 1509;
3842 -> 1510;
3842 -> 3827;
3842 -> 1520;
3842 -> 1512;
3843 -> 1663;
3844 -> 3843;
3844 -> 1532;
3845 -> 3844;
3845 -> 1534;
3845 -> 1532;
3846 -> 1530;
3846 -> 1564;
3846 -> 1659;
3846 -> 3845;
3846 -> 1668;
3846 -> 1558;
3846 -> 1559;
3846 -> 3831;
3846 -> 1566;
3846 -> 1563;
3847 -> 1683;
3848 -> 3847;
3848 -> 1578;
3849 -> 3848;
3849 -> 1580;
3849 -> 1578;
3850 -> 1576;
3850 -> 1610;
3850 -> 1679;
3850 -> 3849;
3850 -> 1688;
3850 -> 1604;
3850 -> 1605;
3850 -> 3835;
3850 -> 1612;
3850 -> 1609;
3851 -> 1624;
3852 -> 3851;
3852 -> 1445;
3853 -> 3852;
3853 -> 1447;
3853 -> 1445;
3854 -> 1643;
3855 -> 3854;
3855 -> 1483;
3856 -> 3855;
3856 -> 1485;
3856 -> 1483;
3857 -> 1481;
3857 -> 1513;
3857 -> 1639;
3857 -> 3856;
3857 -> 1648;
3857 -> 1509;
3857 -> 1510;
3857 -> 3842;
3857 -> 1520;
3857 -> 1512;
3858 -> 1663;
3859 -> 3858;
3859 -> 1532;
3860 -> 3859;
3860 -> 1534;
3860 -> 1532;
3861 -> 1530;
3861 -> 1564;
3861 -> 1659;
3861 -> 3860;
3861 -> 1668;
3861 -> 1558;
3861 -> 1559;
3861 -> 3846;
3861 -> 1566;
3861 -> 1563;
3862 -> 1683;
3863 -> 3862;
3863 -> 1578;
3864 -> 3863;
3864 -> 1580;
3864 -> 1578;
3865 -> 1576;
3865 -> 1610;
3865 -> 1679;
3865 -> 3864;
3865 -> 1688;
3865 -> 1604;
3865 -> 1605;
3865 -> 3850;
3865 -> 1612;
3865 -> 1609;
3866 -> 1624;
3867 -> 3866;
3867 -> 1445;
3868 -> 3867;
3868 -> 1447;
3868 -> 1445;
3869 -> 1643;
3870 -> 3869;
3870 -> 1483;
3871 -> 3870;
3871 -> 1485;
3871 -> 1483;
3872 -> 1481;
3872 -> 1513;
3872 -> 1639;
3872 -> 3871;
3872 -> 1648;
3872 -> 1509;
3872 -> 1510;
3872 -> 3857;
3872 -> 1520;
3872 -> 1512;
3873 -> 1663;
3874 -> 3873;
3874 -> 1532;
3875 -> 3874;
3875 -> 1534;
3875 -> 1532;
3876 -> 1530;
3876 -> 1564;
3876 -> 1659;
3876 -> 3875;
3876 -> 1668;
3876 -> 1558;
3876 -> 1559;
3876 -> 3861;
3876 -> 1566;
3876 -> 1563;
3877 -> 1683;
3878 -> 3877;
3878 -> 1578;
3879 -> 3878;
3879 -> 1580;
3879 -> 1578;
3880 -> 1576;
3880 -> 1610;
3880 -> 1679;
3880 -> 3879;
3880 -> 1688;
3880 -> 1604;
3880 -> 1605;
3880 -> 3865;
3880 -> 1612;
3880 -> 1609;
3881 -> 1624;
3882 -> 3881;
3882 -> 1445;
3883 -> 3882;
3883 -> 1447;
3883 -> 1445;
3884 -> 1643;
3885 -> 3884;
3885 -> 1483;
3886 -> 3885;
3886 -> 1485;
3886 -> 1483;
3887 -> 1481;
3887 -> 1513;
3887 -> 1639;
3887 -> 3886;
3887 -> 1648;
3887 -> 1509;
3887 -> 1510;
3887 -> 3872;
3887 -> 1520;
3887 -> 1512;
3888 -> 1663;
3889 -> 3888;
3889 -> 1532;
3890 -> 3889;
3890 -> 1534;
3890 -> 1532;
3891 -> 1530;
3891 -> 1564;
3891 -> 1659;
3891 -> 3890;
3891 -> 1668;
3891 -> 1558;
3891 -> 1559;
3891 -> 3876;
3891 -> 1566;
3891 -> 1563;
3892 -> 1683;
3893 -> 3892;
3893 -> 1578;
3894 -> 3893;
3894 -> 1580;
3894 -> 1578;
3895 -> 1576;
3895 -> 1610;
3895 -> 1679;
3895 -> 3894;
3895 -> 1688;
3895 -> 1604;
3895 -> 1605;
3895 -> 3880;
3895 -> 1612;
3895 -> 1609;
3896 -> 1624;
3897 -> 3896;
3897 -> 1445;
3898 -> 3897;
3898 -> 1447;
3898 -> 1445;
3899 -> 1643;
3900 -> 3899;
3900 -> 1483;
3901 -> 3900;
3901 -> 1485;
3901 -> 1483;
3902 -> 1481;
3902 -> 1513;
3902 -> 1639;
3902 -> 3901;
3902 -> 1648;
3902 -> 1509;
3902 -> 1510;
3902 -> 3887;
3902 -> 1520;
3902 -> 1512;
3903 -> 1663;
3904 -> 3903;
3904 -> 1532;
3905 -> 3904;
3905 -> 1534;
3905 -> 1532;
3906 -> 1530;
3906 -> 1564;
3906 -> 1659;
3906 -> 3905;
3906 -> 1668;
3906 -> 1558;
3906 -> 1559;
3906 -> 3891;
3906 -> 1566;
3906 -> 1563;
3907 -> 1683;
3908 -> 3907;
3908 -> 1578;
3909 -> 3908;
3909 -> 1580;
3909 -> 1578;
3910 -> 1576;
3910 -> 1610;
3910 -> 1679;
3910 -> 3909;
3910 -> 1688;
3910 -> 1604;
3910 -> 1605;
3910 -> 3895;
3910 -> 1612;
3910 -> 1609;
3911 -> 1624;
3912 -> 3911;
3912 -> 1445;
3913 -> 3912;
3913 -> 1447;
3913 -> 1445;
3914 -> 1643;
3915 -> 3914;
3915 -> 1483;
3916 -> 3915;
3916 -> 1485;
3916 -> 1483;
3917 -> 1481;
3917 -> 1513;
3917 -> 1639;
3917 -> 3916;
3917 -> 1648;
3917 -> 1509;
3917 -> 1510;
3917 -> 3902;
3917 -> 1520;
3917 -> 1512;
3918 -> 1663;
3919 -> 3918;
3919 -> 1532;
3920 -> 3919;
3920 -> 1534;
3920 -> 1532;
3921 -> 1530;
3921 -> 1564;
3921 -> 1659;
3921 -> 3920;
3921 -> 1668;
3921 -> 1558;
3921 -> 1559;
3921 -> 3906;
3921 -> 1566;
3921 -> 1563;
3922 -> 1683;
3923 -> 3922;
3923 -> 1578;
3924 -> 3923;
3924 -> 1580;
3924 -> 1578;
3925 -> 1576;
3925 -> 1610;
3925 -> 1679;
3925 -> 3924;
3925 -> 1688;
3925 -> 1604;
3925 -> 1605;
3925 -> 3910;
3925 -> 1612;
3925 -> 1609;
3926 -> 1624;
3927 -> 3926;
3927 -> 1445;
3928 -> 3927;
3928 -> 1447;
3928 -> 1445;
3929 -> 1643;
3930 -> 3929;
3930 -> 1483;
3931 -> 3930;
3931 -> 1485;
3931 -> 1483;
3932 -> 1481;
3932 -> 1513;
3932 -> 1639;
3932 -> 3931;
3932 -> 1648;
3932 -> 1509;
3932 -> 1510;
3932 -> 3917;
3932 -> 1520;
3932 -> 1512;
3933 -> 1663;
3934 -> 3933;
3934 -> 1532;
3935 -> 3934;
3935 -> 1534;
3935 -> 1532;
3936 -> 1530;
3936 -> 1564;
3936 -> 1659;
3936 -> 3935;
3936 -> 1668;
3936 -> 1558;
3936 -> 1559;
3936 -> 3921;
3936 -> 1566;
3936 -> 1563;
3937 -> 1683;
3938 -> 3937;
3938 -> 1578;
3939 -> 3938;
3939 -> 1580;
3939 -> 1578;
3940 -> 1576;
3940 -> 1610;
3940 -> 1679;
3940 -> 3939;
3940 -> 1688;
3940 -> 1604;
3940 -> 1605;
3940 -> 3925;
3940 -> 1612;
3940 -> 1609;
3941 -> 1624;
3942 -> 3941;
3942 -> 1445;
3943 -> 3942;
3943 -> 1447;
3943 -> 1445;
3944 -> 1643;
3945 -> 3944;
3945 -> 1483;
3946 -> 3945;
3946 -> 1485;
3946 -> 1483;
3947 -> 1481;
3947 -> 1513;
3947 -> 1639;
3947 -> 3946;
3947 -> 1648;
3947 -> 1509;
3947 -> 1510;
3947 -> 3932;
3947 -> 1520;
3947 -> 1512;
3948 -> 1663;
3949 -> 3948;
3949 -> 1532;
3950 -> 3949;
3950 -> 1534;
3950 -> 1532;
3951 -> 1530;
3951 -> 1564;
3951 -> 1659;
3951 -> 3950;
3951 -> 1668;
3951 -> 1558;
3951 -> 1559;
3951 -> 3936;
3951 -> 1566;
3951 -> 1563;
3952 -> 1683;
3953 -> 3952;
3953 -> 1578;
3954 -> 3953;
3954 -> 1580;
3954 -> 1578;
3955 -> 1576;
3955 -> 1610;
3955 -> 1679;
3955 -> 3954;
3955 -> 1688;
3955 -> 1604;
3955 -> 1605;
3955 -> 3940;
3955 -> 1612;
3955 -> 1609;
3956 -> 1624;
3957 -> 3956;
3957 -> 1445;
3958 -> 3957;
3958 -> 1447;
3958 -> 1445;
3959 -> 1643;
3960 -> 3959;
3960 -> 1483;
3961 -> 3960;
3961 -> 1485;
3961 -> 1483;
3962 -> 1481;
3962 -> 1513;
3962 -> 1639;
3962 -> 3961;
3962 -> 1648;
3962 -> 1509;
3962 -> 1510;
3962 -> 3947;
3962 -> 1520;
3962 -> 1512;
3963 -> 1663;
3964 -> 3963;
3964 -> 1532;
3965 -> 3964;
3965 -> 1534;
3965 -> 1532;
3966 -> 1530;
3966 -> 1564;
3966 -> 1659;
3966 -> 3965;
3966 -> 1668;
3966 -> 1558;
3966 -> 1559;
3966 -> 3951;
3966 -> 1566;
3966 -> 1563;
3967 -> 1683;
3968 -> 3967;
3968 -> 1578;
3969 -> 3968;
3969 -> 1580;
3969 -> 1578;
3970 -> 1576;
3970 -> 1610;
3970 -> 1679;
3970 -> 3969;
3970 -> 1688;
3970 -> 1604;
3970 -> 1605;
3970 -> 3955;
3970 -> 1612;
3970 -> 1609;
3971 -> 1624;
3972 -> 3971;
3972 -> 1445;
3973 -> 3972;
3973 -> 1447;
3973 -> 1445;
3974 -> 1643;
3975 -> 3974;
3975 -> 1483;
3976 -> 3975;
3976 -> 1485;
3976 -> 1483;
3977 -> 1481;
3977 -> 1513;
3977 -> 1639;
3977 -> 3976;
3977 -> 1648;
3977 -> 1509;
3977 -> 1510;
3977 -> 3962;
3977 -> 1520;
3977 -> 1512;
3978 -> 1663;
3979 -> 3978;
3979 -> 1532;
3980 -> 3979;
3980 -> 1534;
3980 -> 1532;
3981 -> 1530;
3981 -> 1564;
3981 -> 1659;
3981 -> 3980;
3981 -> 1668;
3981 -> 1558;
3981 -> 1559;
3981 -> 3966;
3981 -> 1566;
3981 -> 1563;
3982 -> 1683;
3983 -> 3982;
3983 -> 1578;
3984 -> 3983;
3984 -> 1580;
3984 -> 1578;
3985 -> 1576;
3985 -> 1610;
3985 -> 1679;
3985 -> 3984;
3985 -> 1688;
3985 -> 1604;
3985 -> 1605;
3985 -> 3970;
3985 -> 1612;
3985 -> 1609;
3986 -> 1624;
3987 -> 3986;
3987 -> 1445;
3988 -> 3987;
3988 -> 1447;
3988 -> 1445;
3989 -> 1643;
3990 -> 3989;
3990 -> 1483;
3991 -> 3990;
3991 -> 1485;
3991 -> 1483;
3992 -> 1481;
3992 -> 1513;
3992 -> 1639;
3992 -> 3991;
3992 -> 1648;
3992 -> 1509;
3992 -> 1510;
3992 -> 3977;
3992 -> 1520;
3992 -> 1512;
3993 -> 1663;
3994 -> 3993;
3994 -> 1532;
3995 -> 3994;
3995 -> 1534;
3995 -> 1532;
3996 -> 1530;
3996 -> 1564;
3996 -> 1659;
3996 -> 3995;
3996 -> 1668;
3996 -> 1558;
3996 -> 1559;
3996 -> 3981;
3996 -> 1566;
3996 -> 1563;
3997 -> 1683;
3998 -> 3997;
3998 -> 1578;
3999 -> 3998;
3999 -> 1580;
3999 -> 1578;
4000 -> 1576;
4000 -> 1610;
4000 -> 1679;
4000 -> 3999;
4000 -> 1688;
4000 -> 1604;
4000 -> 1605;
4000 -> 3985;
4000 -> 1612;
4000 -> 1609;
4001 -> 1624;
4002 -> 4001;
4002 -> 1445;
4003 -> 4002;
4003 -> 1447;
4003 -> 1445;
4004 -> 1643;
4005 -> 4004;
4005 -> 1483;
4006 -> 4005;
4006 -> 1485;
4006 -> 1483;
4007 -> 1481;
4007 -> 1513;
4007 -> 1639;
4007 -> 4006;
4007 -> 1648;
4007 -> 1509;
4007 -> 1510;
4007 -> 3992;
4007 -> 1520;
4007 -> 1512;
4008 -> 1663;
4009 -> 4008;
4009 -> 1532;
4010 -> 4009;
4010 -> 1534;
4010 -> 1532;
4011 -> 1530;
4011 -> 1564;
4011 -> 1659;
4011 -> 4010;
4011 -> 1668;
4011 -> 1558;
4011 -> 1559;
4011 -> 3996;
4011 -> 1566;
4011 -> 1563;
4012 -> 1683;
4013 -> 4012;
4013 -> 1578;
4014 -> 4013;
4014 -> 1580;
4014 -> 1578;
4015 -> 1576;
4015 -> 1610;
4015 -> 1679;
4015 -> 4014;
4015 -> 1688;
4015 -> 1604;
4015 -> 1605;
4015 -> 4000;
4015 -> 1612;
4015 -> 1609;
4016 -> 1624;
4017 -> 4016;
4017 -> 1445;
4018 -> 4017;
4018 -> 1447;
4018 -> 1445;
4019 -> 1643;
4020 -> 4019;
4020 -> 1483;
4021 -> 4020;
4021 -> 1485;
4021 -> 1483;
4022 -> 1481;
4022 -> 1513;
4022 -> 1639;
4022 -> 4021;
4022 -> 1648;
4022 -> 1509;
4022 -> 1510;
4022 -> 4007;
4022 -> 1520;
4022 -> 1512;
4023 -> 1663;
4024 -> 4023;
4024 -> 1532;
4025 -> 4024;
4025 -> 1534;
4025 -> 1532;
4026 -> 1530;
4026 -> 1564;
4026 -> 1659;
4026 -> 4025;
4026 -> 1668;
4026 -> 1558;
4026 -> 1559;
4026 -> 4011;
4026 -> 1566;
4026 -> 1563;
4027 -> 1683;
4028 -> 4027;
4028 -> 1578;
4029 -> 4028;
4029 -> 1580;
4029 -> 1578;
4030 -> 1576;
4030 -> 1610;
4030 -> 1679;
4030 -> 4029;
4030 -> 1688;
4030 -> 1604;
4030 -> 1605;
4030 -> 4015;
4030 -> 1612;
4030 -> 1609;
4031 -> 1624;
4032 -> 4031;
4032 -> 1445;
4033 -> 4032;
4033 -> 1447;
4033 -> 1445;
4034 -> 1643;
4035 -> 4034;
4035 -> 1483;
4036 -> 4035;
4036 -> 1485;
4036 -> 1483;
4037 -> 1481;
4037 -> 1513;
4037 -> 1639;
4037 -> 4036;
4037 -> 1648;
4037 -> 1509;
4037 -> 1510;
4037 -> 4022;
4037 -> 1520;
4037 -> 1512;
4038 -> 1663;
4039 -> 4038;
4039 -> 1532;
4040 -> 4039;
4040 -> 1534;
4040 -> 1532;
4041 -> 1530;
4041 -> 1564;
4041 -> 1659;
4041 -> 4040;
4041 -> 1668;
4041 -> 1558;
4041 -> 1559;
4041 -> 4026;
4041 -> 1566;
4041 -> 1563;
4042 -> 1683;
4043 -> 4042;
4043 -> 1578;
4044 -> 4043;
4044 -> 1580;
4044 -> 1578;
4045 -> 1576;
4045 -> 1610;
4045 -> 1679;
4045 -> 4044;
4045 -> 1688;
4045 -> 1604;
4045 -> 1605;
4045 -> 4030;
4045 -> 1612;
4045 -> 1609;
4046 -> 1624;
4047 -> 4046;
4047 -> 1445;
4048 -> 4047;
4048 -> 1447;
4048 -> 1445;
4049 -> 1643;
4050 -> 4049;
4050 -> 1483;
4051 -> 4050;
4051 -> 1485;
4051 -> 1483;
4052 -> 1481;
4052 -> 1513;
4052 -> 1639;
4052 -> 4051;
4052 -> 1648;
4052 -> 1509;
4052 -> 1510;
4052 -> 4037;
4052 -> 1520;
4052 -> 1512;
4053 -> 1663;
4054 -> 4053;
4054 -> 1532;
4055 -> 4054;
4055 -> 1534;
4055 -> 1532;
4056 -> 1530;
4056 -> 1564;
4056 -> 1659;
4056 -> 4055;
4056 -> 1668;
4056 -> 1558;
4056 -> 1559;
4056 -> 4041;
4056 -> 1566;
4056 -> 1563;
4057 -> 1683;
4058 -> 4057;
4058 -> 1578;
4059 -> 4058;
4059 -> 1580;
4059 -> 1578;
4060 -> 1576;
4060 -> 1610;
4060 -> 1679;
4060 -> 4059;
4060 -> 1688;
4060 -> 1604;
4060 -> 1605;
4060 -> 4045;
4060 -> 1612;
4060 -> 1609;
4061 -> 1624;
4062 -> 4061;
4062 -> 1445;
4063 -> 4062;
4063 -> 1447;
4063 -> 1445;
4064 -> 1643;
4065 -> 4064;
4065 -> 1483;
4066 -> 4065;
4066 -> 1485;
4066 -> 1483;
4067 -> 1481;
4067 -> 1513;
4067 -> 1639;
4067 -> 4066;
4067 -> 1648;
4067 -> 1509;
4067 -> 1510;
4067 -> 4052;
4067 -> 1520;
4067 -> 1512;
4068 -> 1663;
4069 -> 4068;
4069 -> 1532;
4070 -> 4069;
4070 -> 1534;
4070 -> 1532;
4071 -> 1530;
4071 -> 1564;
4071 -> 1659;
4071 -> 4070;
4071 -> 1668;
4071 -> 1558;
4071 -> 1559;
4071 -> 4056;
4071 -> 1566;
4071 -> 1563;
4072 -> 1683;
4073 -> 4072;
4073 -> 1578;
4074 -> 4073;
4074 -> 1580;
4074 -> 1578;
4075 -> 1576;
4075 -> 1610;
4075 -> 1679;
4075 -> 4074;
4075 -> 1688;
4075 -> 1604;
4075 -> 1605;
4075 -> 4060;
4075 -> 1612;
4075 -> 1609;
4076 -> 1624;
4077 -> 4076;
4077 -> 1445;
4078 -> 4077;
4078 -> 1447;
4078 -> 1445;
4079 -> 1643;
4080 -> 4079;
4080 -> 1483;
4081 -> 4080;
4081 -> 1485;
4081 -> 1483;
4082 -> 1481;
4082 -> 1513;
4082 -> 1639;
4082 -> 4081;
4082 -> 1648;
4082 -> 1509;
4082 -> 1510;
4082 -> 4067;
4082 -> 1520;
4082 -> 1512;
4083 -> 1663;
4084 -> 4083;
4084 -> 1532;
4085 -> 4084;
4085 -> 1534;
4085 -> 1532;
4086 -> 1530;
4086 -> 1564;
4086 -> 1659;
4086 -> 4085;
4086 -> 1668;
4086 -> 1558;
4086 -> 1559;
4086 -> 4071;
4086 -> 1566;
4086 -> 1563;
4087 -> 1683;
4088 -> 4087;
4088 -> 1578;
4089 -> 4088;
4089 -> 1580;
4089 -> 1578;
4090 -> 1576;
4090 -> 1610;
4090 -> 1679;
4090 -> 4089;
4090 -> 1688;
4090 -> 1604;
4090 -> 1605;
4090 -> 4075;
4090 -> 1612;
4090 -> 1609;
4091 -> 1624;
4092 -> 4091;
4092 -> 1445;
4093 -> 4092;
4093 -> 1447;
4093 -> 1445;
4094 -> 1643;
4095 -> 4094;
4095 -> 1483;
4096 -> 4095;
4096 -> 1485;
4096 -> 1483;
4097 -> 1481;
4097 -> 1513;
4097 -> 1639;
4097 -> 4096;
4097 -> 1648;
4097 -> 1509;
4097 -> 1510;
4097 -> 4082;
4097 -> 1520;
4097 -> 1512;
4098 -> 1663;
4099 -> 4098;
4099 -> 1532;
4100 -> 4099;
4100 -> 1534;
4100 -> 1532;
4101 -> 1530;
4101 -> 1564;
4101 -> 1659;
4101 -> 4100;
4101 -> 1668;
4101 -> 1558;
4101 -> 1559;
4101 -> 4086;
4101 -> 1566;
4101 -> 1563;
4102 -> 1683;
4103 -> 4102;
4103 -> 1578;
4104 -> 4103;
4104 -> 1580;
4104 -> 1578;
4105 -> 1576;
4105 -> 1610;
4105 -> 1679;
4105 -> 4104;
4105 -> 1688;
4105 -> 1604;
4105 -> 1605;
4105 -> 4090;
4105 -> 1612;
4105 -> 1609;
4106 -> 1624;
4107 -> 4106;
4107 -> 1445;
4108 -> 4107;
4108 -> 1447;
4108 -> 1445;
4109 -> 1643;
4110 -> 4109;
4110 -> 1483;
4111 -> 4110;
4111 -> 1485;
4111 -> 1483;
4112 -> 1481;
4112 -> 1513;
4112 -> 1639;
4112 -> 4111;
4112 -> 1648;
4112 -> 1509;
4112 -> 1510;
4112 -> 4097;
4112 -> 1520;
4112 -> 1512;
4113 -> 1663;
4114 -> 4113;
4114 -> 1532;
4115 -> 4114;
4115 -> 1534;
4115 -> 1532;
4116 -> 1530;
4116 -> 1564;
4116 -> 1659;
4116 -> 4115;
4116 -> 1668;
4116 -> 1558;
4116 -> 1559;
4116 -> 4101;
4116 -> 1566;
4116 -> 1563;
4117 -> 1683;
4118 -> 4117;
4118 -> 1578;
4119 -> 4118;
4119 -> 1580;
4119 -> 1578;
4120 -> 1576;
4120 -> 1610;
4120 -> 1679;
4120 -> 4119;
4120 -> 1688;
4120 -> 1604;
4120 -> 1605;
4120 -> 4105;
4120 -> 1612;
4120 -> 1609;
4121 -> 1624;
4122 -> 4121;
4122 -> 1445;
4123 -> 4122;
4123 -> 1447;
4123 -> 1445;
4124 -> 1643;
4125 -> 4124;
4125 -> 1483;
4126 -> 4125;
4126 -> 1485;
4126 -> 1483;
4127 -> 1481;
4127 -> 1513;
4127 -> 1639;
4127 -> 4126;
4127 -> 1648;
4127 -> 1509;
4127 -> 1510;
4127 -> 4112;
4127 -> 1520;
4127 -> 1512;
4128 -> 1663;
4129 -> 4128;
4129 -> 1532;
4130 -> 4129;
4130 -> 1534;
4130 -> 1532;
4131 -> 1530;
4131 -> 1564;
4131 -> 1659;
4131 -> 4130;
4131 -> 1668;
4131 -> 1558;
4131 -> 1559;
4131 -> 4116;
4131 -> 1566;
4131 -> 1563;
4132 -> 1683;
4133 -> 4132;
4133 -> 1578;
4134 -> 4133;
4134 -> 1580;
4134 -> 1578;
4135 -> 1576;
4135 -> 1610;
4135 -> 1679;
4135 -> 4134;
4135 -> 1688;
4135 -> 1604;
4135 -> 1605;
4135 -> 4120;
4135 -> 1612;
4135 -> 1609;
4136 -> 1624;
4137 -> 4136;
4137 -> 1445;
4138 -> 4137;
4138 -> 1447;
4138 -> 1445;
4139 -> 1643;
4140 -> 4139;
4140 -> 1483;
4141 -> 4140;
4141 -> 1485;
4141 -> 1483;
4142 -> 1481;
4142 -> 1513;
4142 -> 1639;
4142 -> 4141;
4142 -> 1648;
4142 -> 1509;
4142 -> 1510;
4142 -> 4127;
4142 -> 1520;
4142 -> 1512;
4143 -> 1663;
4144 -> 4143;
4144 -> 1532;
4145 -> 4144;
4145 -> 1534;
4145 -> 1532;
4146 -> 1530;
4146 -> 1564;
4146 -> 1659;
4146 -> 4145;
4146 -> 1668;
4146 -> 1558;
4146 -> 1559;
4146 -> 4131;
4146 -> 1566;
4146 -> 1563;
4147 -> 1683;
4148 -> 4147;
4148 -> 1578;
4149 -> 4148;
4149 -> 1580;
4149 -> 1578;
4150 -> 1576;
4150 -> 1610;
4150 -> 1679;
4150 -> 4149;
4150 -> 1688;
4150 -> 1604;
4150 -> 1605;
4150 -> 4135;
4150 -> 1612;
4150 -> 1609;
4151 -> 1624;
4152 -> 4151;
4152 -> 1445;
4153 -> 4152;
4153 -> 1447;
4153 -> 1445;
4154 -> 1643;
4155 -> 4154;
4155 -> 1483;
4156 -> 4155;
4156 -> 1485;
4156 -> 1483;
4157 -> 1481;
4157 -> 1513;
4157 -> 1639;
4157 -> 4156;
4157 -> 1648;
4157 -> 1509;
4157 -> 1510;
4157 -> 4142;
4157 -> 1520;
4157 -> 1512;
4158 -> 1663;
4159 -> 4158;
4159 -> 1532;
4160 -> 4159;
4160 -> 1534;
4160 -> 1532;
4161 -> 1530;
4161 -> 1564;
4161 -> 1659;
4161 -> 4160;
4161 -> 1668;
4161 -> 1558;
4161 -> 1559;
4161 -> 4146;
4161 -> 1566;
4161 -> 1563;
4162 -> 1683;
4163 -> 4162;
4163 -> 1578;
4164 -> 4163;
4164 -> 1580;
4164 -> 1578;
4165 -> 1576;
4165 -> 1610;
4165 -> 1679;
4165 -> 4164;
4165 -> 1688;
4165 -> 1604;
4165 -> 1605;
4165 -> 4150;
4165 -> 1612;
4165 -> 1609;
4166 -> 1624;
4167 -> 4166;
4167 -> 1445;
4168 -> 4167;
4168 -> 1447;
4168 -> 1445;
4169 -> 1643;
4170 -> 4169;
4170 -> 1483;
4171 -> 4170;
4171 -> 1485;
4171 -> 1483;
4172 -> 1481;
4172 -> 1513;
4172 -> 1639;
4172 -> 4171;
4172 -> 1648;
4172 -> 1509;
4172 -> 1510;
4172 -> 4157;
4172 -> 1520;
4172 -> 1512;
4173 -> 1663;
4174 -> 4173;
4174 -> 1532;
4175 -> 4174;
4175 -> 1534;
4175 -> 1532;
4176 -> 1530;
4176 -> 1564;
4176 -> 1659;
4176 -> 4175;
4176 -> 1668;
4176 -> 1558;
4176 -> 1559;
4176 -> 4161;
4176 -> 1566;
4176 -> 1563;
4177 -> 1683;
4178 -> 4177;
4178 -> 1578;
4179 -> 4178;
4179 -> 1580;
4179 -> 1578;
4180 -> 1576;
4180 -> 1610;
4180 -> 1679;
4180 -> 4179;
4180 -> 1688;
4180 -> 1604;
4180 -> 1605;
4180 -> 4165;
4180 -> 1612;
4180 -> 1609;
4181 -> 1624;
4182 -> 4181;
4182 -> 1445;
4183 -> 4182;
4183 -> 1447;
4183 -> 1445;
4184 -> 1643;
4185 -> 4184;
4185 -> 1483;
4186 -> 4185;
4186 -> 1485;
4186 -> 1483;
4187 -> 1481;
4187 -> 1513;
4187 -> 1639;
4187 -> 4186;
4187 -> 1648;
4187 -> 1509;
4187 -> 1510;
4187 -> 4172;
4187 -> 1520;
4187 -> 1512;
4188 -> 1663;
4189 -> 4188;
4189 -> 1532;
4190 -> 4189;
4190 -> 1534;
4190 -> 1532;
4191 -> 1530;
4191 -> 1564;
4191 -> 1659;
4191 -> 4190;
4191 -> 1668;
4191 -> 1558;
4191 -> 1559;
4191 -> 4176;
4191 -> 1566;
4191 -> 1563;
4192 -> 1683;
4193 -> 4192;
4193 -> 1578;
4194 -> 4193;
4194 -> 1580;
4194 -> 1578;
4195 -> 1576;
4195 -> 1610;
4195 -> 1679;
4195 -> 4194;
4195 -> 1688;
4195 -> 1604;
4195 -> 1605;
4195 -> 4180;
4195 -> 1612;
4195 -> 1609;
4196 -> 1624;
4197 -> 4196;
4197 -> 1445;
4198 -> 4197;
4198 -> 1447;
4198 -> 1445;
4199 -> 1643;
4200 -> 4199;
4200 -> 1483;
4201 -> 4200;
4201 -> 1485;
4201 -> 1483;
4202 -> 1481;
4202 -> 1513;
4202 -> 1639;
4202 -> 4201;
4202 -> 1648;
4202 -> 1509;
4202 -> 1510;
4202 -> 4187;
4202 -> 1520;
4202 -> 1512;
4203 -> 1663;
4204 -> 4203;
4204 -> 1532;
4205 -> 4204;
4205 -> 1534;
4205 -> 1532;
4206 -> 1530;
4206 -> 1564;
4206 -> 1659;
4206 -> 4205;
4206 -> 1668;
4206 -> 1558;
4206 -> 1559;
4206 -> 4191;
4206 -> 1566;
4206 -> 1563;
4207 -> 1683;
4208 -> 4207;
4208 -> 1578;
4209 -> 4208;
4209 -> 1580;
4209 -> 1578;
4210 -> 1576;
4210 -> 1610;
4210 -> 1679;
4210 -> 4209;
4210 -> 1688;
4210 -> 1604;
4210 -> 1605;
4210 -> 4195;
4210 -> 1612;
4210 -> 1609;
4211 -> 1624;
4212 -> 4211;
4212 -> 1445;
4213 -> 4212;
4213 -> 1447;
4213 -> 1445;
4214 -> 1643;
4215 -> 4214;
4215 -> 1483;
4216 -> 4215;
4216 -> 1485;
4216 -> 1483;
4217 -> 1481;
4217 -> 1513;
4217 -> 1639;
4217 -> 4216;
4217 -> 1648;
4217 -> 1509;
4217 -> 1510;
4217 -> 4202;
4217 -> 1520;
4217 -> 1512;
4218 -> 1663;
4219 -> 4218;
4219 -> 1532;
4220 -> 4219;
4220 -> 1534;
4220 -> 1532;
4221 -> 1530;
4221 -> 1564;
4221 -> 1659;
4221 -> 4220;
4221 -> 1668;
4221 -> 1558;
4221 -> 1559;
4221 -> 4206;
4221 -> 1566;
4221 -> 1563;
4222 -> 1683;
4223 -> 4222;
4223 -> 1578;
4224 -> 4223;
4224 -> 1580;
4224 -> 1578;
4225 -> 1576;
4225 -> 1610;
4225 -> 1679;
4225 -> 4224;
4225 -> 1688;
4225 -> 1604;
4225 -> 1605;
4225 -> 4210;
4225 -> 1612;
4225 -> 1609;
4226 -> 1624;
4227 -> 4226;
4227 -> 1445;
4228 -> 4227;
4228 -> 1447;
4228 -> 1445;
4229 -> 1643;
4230 -> 4229;
4230 -> 1483;
4231 -> 4230;
4231 -> 1485;
4231 -> 1483;
4232 -> 1481;
4232 -> 1513;
4232 -> 1639;
4232 -> 4231;
4232 -> 1648;
4232 -> 1509;
4232 -> 1510;
4232 -> 4217;
4232 -> 1520;
4232 -> 1512;
4233 -> 1663;
4234 -> 4233;
4234 -> 1532;
4235 -> 4234;
4235 -> 1534;
4235 -> 1532;
4236 -> 1530;
4236 -> 1564;
4236 -> 1659;
4236 -> 4235;
4236 -> 1668;
4236 -> 1558;
4236 -> 1559;
4236 -> 4221;
4236 -> 1566;
4236 -> 1563;
4237 -> 1683;
4238 -> 4237;
4238 -> 1578;
4239 -> 4238;
4239 -> 1580;
4239 -> 1578;
4240 -> 1576;
4240 -> 1610;
4240 -> 1679;
4240 -> 4239;
4240 -> 1688;
4240 -> 1604;
4240 -> 1605;
4240 -> 4225;
4240 -> 1612;
4240 -> 1609;
4241 -> 1624;
4242 -> 4241;
4242 -> 1445;
4243 -> 4242;
4243 -> 1447;
4243 -> 1445;
4244 -> 1643;
4245 -> 4244;
4245 -> 1483;
4246 -> 4245;
4246 -> 1485;
4246 -> 1483;
4247 -> 1481;
4247 -> 1513;
4247 -> 1639;
4247 -> 4246;
4247 -> 1648;
4247 -> 1509;
4247 -> 1510;
4247 -> 4232;
4247 -> 1520;
4247 -> 1512;
4248 -> 1663;
4249 -> 4248;
4249 -> 1532;
4250 -> 4249;
4250 -> 1534;
4250 -> 1532;
4251 -> 1530;
4251 -> 1564;
4251 -> 1659;
4251 -> 4250;
4251 -> 1668;
4251 -> 1558;
4251 -> 1559;
4251 -> 4236;
4251 -> 1566;
4251 -> 1563;
4252 -> 1683;
4253 -> 4252;
4253 -> 1578;
4254 -> 4253;
4254 -> 1580;
4254 -> 1578;
4255 -> 1576;
4255 -> 1610;
4255 -> 1679;
4255 -> 4254;
4255 -> 1688;
4255 -> 1604;
4255 -> 1605;
4255 -> 4240;
4255 -> 1612;
4255 -> 1609;
4256 -> 1624;
4257 -> 4256;
4257 -> 1445;
4258 -> 4257;
4258 -> 1447;
4258 -> 1445;
4259 -> 1643;
4260 -> 4259;
4260 -> 1483;
4261 -> 4260;
4261 -> 1485;
4261 -> 1483;
4262 -> 1481;
4262 -> 1513;
4262 -> 1639;
4262 -> 4261;
4262 -> 1648;
4262 -> 1509;
4262 -> 1510;
4262 -> 4247;
4262 -> 1520;
4262 -> 1512;
4263 -> 1663;
4264 -> 4263;
4264 -> 1532;
4265 -> 4264;
4265 -> 1534;
4265 -> 1532;
4266 -> 1530;
4266 -> 1564;
4266 -> 1659;
4266 -> 4265;
4266 -> 1668;
4266 -> 1558;
4266 -> 1559;
4266 -> 4251;
4266 -> 1566;
4266 -> 1563;
4267 -> 1683;
4268 -> 4267;
4268 -> 1578;
4269 -> 4268;
4269 -> 1580;
4269 -> 1578;
4270 -> 1576;
4270 -> 1610;
4270 -> 1679;
4270 -> 4269;
4270 -> 1688;
4270 -> 1604;
4270 -> 1605;
4270 -> 4255;
4270 -> 1612;
4270 -> 1609;
4271 -> 1624;
4272 -> 4271;
4272 -> 1445;
4273 -> 4272;
4273 -> 1447;
4273 -> 1445;
4274 -> 1643;
4275 -> 4274;
4275 -> 1483;
4276 -> 4275;
4276 -> 1485;
4276 -> 1483;
4277 -> 1481;
4277 -> 1513;
4277 -> 1639;
4277 -> 4276;
4277 -> 1648;
4277 -> 1509;
4277 -> 1510;
4277 -> 4262;
4277 -> 1520;
4277 -> 1512;
4278 -> 1663;
4279 -> 4278;
4279 -> 1532;
4280 -> 4279;
4280 -> 1534;
4280 -> 1532;
4281 -> 1530;
4281 -> 1564;
4281 -> 1659;
4281 -> 4280;
4281 -> 1668;
4281 -> 1558;
4281 -> 1559;
4281 -> 4266;
4281 -> 1566;
4281 -> 1563;
4282 -> 1683;
4283 -> 4282;
4283 -> 1578;
4284 -> 4283;
4284 -> 1580;
4284 -> 1578;
4285 -> 1576;
4285 -> 1610;
4285 -> 1679;
4285 -> 4284;
4285 -> 1688;
4285 -> 1604;
4285 -> 1605;
4285 -> 4270;
4285 -> 1612;
4285 -> 1609;
4286 -> 1624;
4287 -> 4286;
4287 -> 1445;
4288 -> 4287;
4288 -> 1447;
4288 -> 1445;
4289 -> 1643;
4290 -> 4289;
4290 -> 1483;
4291 -> 4290;
4291 -> 1485;
4291 -> 1483;
4292 -> 1481;
4292 -> 1513;
4292 -> 1639;
4292 -> 4291;
4292 -> 1648;
4292 -> 1509;
4292 -> 1510;
4292 -> 4277;
4292 -> 1520;
4292 -> 1512;
4293 -> 1663;
4294 -> 4293;
4294 -> 1532;
4295 -> 4294;
4295 -> 1534;
4295 -> 1532;
4296 -> 1530;
4296 -> 1564;
4296 -> 1659;
4296 -> 4295;
4296 -> 1668;
4296 -> 1558;
4296 -> 1559;
4296 -> 4281;
4296 -> 1566;
4296 -> 1563;
4297 -> 1683;
4298 -> 4297;
4298 -> 1578;
4299 -> 4298;
4299 -> 1580;
4299 -> 1578;
4300 -> 1576;
4300 -> 1610;
4300 -> 1679;
4300 -> 4299;
4300 -> 1688;
4300 -> 1604;
4300 -> 1605;
4300 -> 4285;
4300 -> 1612;
4300 -> 1609;
4301 -> 1624;
4302 -> 4301;
4302 -> 1445;
4303 -> 4302;
4303 -> 1447;
4303 -> 1445;
4304 -> 1643;
4305 -> 4304;
4305 -> 1483;
4306 -> 4305;
4306 -> 1485;
4306 -> 1483;
4307 -> 1481;
4307 -> 1513;
4307 -> 1639;
4307 -> 4306;
4307 -> 1648;
4307 -> 1509;
4307 -> 1510;
4307 -> 4292;
4307 -> 1520;
4307 -> 1512;
4308 -> 1663;
4309 -> 4308;
4309 -> 1532;
4310 -> 4309;
4310 -> 1534;
4310 -> 1532;
4311 -> 1530;
4311 -> 1564;
4311 -> 1659;
4311 -> 4310;
4311 -> 1668;
4311 -> 1558;
4311 -> 1559;
4311 -> 4296;
4311 -> 1566;
4311 -> 1563;
4312 -> 1683;
4313 -> 4312;
4313 -> 1578;
4314 -> 4313;
4314 -> 1580;
4314 -> 1578;
4315 -> 1576;
4315 -> 1610;
4315 -> 1679;
4315 -> 4314;
4315 -> 1688;
4315 -> 1604;
4315 -> 1605;
4315 -> 4300;
4315 -> 1612;
4315 -> 1609;
4316 -> 1624;
4317 -> 4316;
4317 -> 1445;
4318 -> 4317;
4318 -> 1447;
4318 -> 1445;
4319 -> 1643;
4320 -> 4319;
4320 -> 1483;
4321 -> 4320;
4321 -> 1485;
4321 -> 1483;
4322 -> 1481;
4322 -> 1513;
4322 -> 1639;
4322 -> 4321;
4322 -> 1648;
4322 -> 1509;
4322 -> 1510;
4322 -> 4307;
4322 -> 1520;
4322 -> 1512;
4323 -> 1663;
4324 -> 4323;
4324 -> 1532;
4325 -> 4324;
4325 -> 1534;
4325 -> 1532;
4326 -> 1530;
4326 -> 1564;
4326 -> 1659;
4326 -> 4325;
4326 -> 1668;
4326 -> 1558;
4326 -> 1559;
4326 -> 4311;
4326 -> 1566;
4326 -> 1563;
4327 -> 1683;
4328 -> 4327;
4328 -> 1578;
4329 -> 4328;
4329 -> 1580;
4329 -> 1578;
4330 -> 1576;
4330 -> 1610;
4330 -> 1679;
4330 -> 4329;
4330 -> 1688;
4330 -> 1604;
4330 -> 1605;
4330 -> 4315;
4330 -> 1612;
4330 -> 1609;
4331 -> 1624;
4332 -> 4331;
4332 -> 1445;
4333 -> 4332;
4333 -> 1447;
4333 -> 1445;
4334 -> 1643;
4335 -> 4334;
4335 -> 1483;
4336 -> 4335;
4336 -> 1485;
4336 -> 1483;
4337 -> 1481;
4337 -> 1513;
4337 -> 1639;
4337 -> 4336;
4337 -> 1648;
4337 -> 1509;
4337 -> 1510;
4337 -> 4322;
4337 -> 1520;
4337 -> 1512;
4338 -> 1663;
4339 -> 4338;
4339 -> 1532;
4340 -> 4339;
4340 -> 1534;
4340 -> 1532;
4341 -> 1530;
4341 -> 1564;
4341 -> 1659;
4341 -> 4340;
4341 -> 1668;
4341 -> 1558;
4341 -> 1559;
4341 -> 4326;
4341 -> 1566;
4341 -> 1563;
4342 -> 1683;
4343 -> 4342;
4343 -> 1578;
4344 -> 4343;
4344 -> 1580;
4344 -> 1578;
4345 -> 1576;
4345 -> 1610;
4345 -> 1679;
4345 -> 4344;
4345 -> 1688;
4345 -> 1604;
4345 -> 1605;
4345 -> 4330;
4345 -> 1612;
4345 -> 1609;
4346 -> 1624;
4347 -> 4346;
4347 -> 1445;
4348 -> 4347;
4348 -> 1447;
4348 -> 1445;
4349 -> 1643;
4350 -> 4349;
4350 -> 1483;
4351 -> 4350;
4351 -> 1485;
4351 -> 1483;
4352 -> 1481;
4352 -> 1513;
4352 -> 1639;
4352 -> 4351;
4352 -> 1648;
4352 -> 1509;
4352 -> 1510;
4352 -> 4337;
4352 -> 1520;
4352 -> 1512;
4353 -> 1663;
4354 -> 4353;
4354 -> 1532;
4355 -> 4354;
4355 -> 1534;
4355 -> 1532;
4356 -> 1530;
4356 -> 1564;
4356 -> 1659;
4356 -> 4355;
4356 -> 1668;
4356 -> 1558;
4356 -> 1559;
4356 -> 4341;
4356 -> 1566;
4356 -> 1563;
4357 -> 1683;
4358 -> 4357;
4358 -> 1578;
4359 -> 4358;
4359 -> 1580;
4359 -> 1578;
4360 -> 1576;
4360 -> 1610;
4360 -> 1679;
4360 -> 4359;
4360 -> 1688;
4360 -> 1604;
4360 -> 1605;
4360 -> 4345;
4360 -> 1612;
4360 -> 1609;
4361 -> 1624;
4362 -> 4361;
4362 -> 1445;
4363 -> 4362;
4363 -> 1447;
4363 -> 1445;
4364 -> 1643;
4365 -> 4364;
4365 -> 1483;
4366 -> 4365;
4366 -> 1485;
4366 -> 1483;
4367 -> 1481;
4367 -> 1513;
4367 -> 1639;
4367 -> 4366;
4367 -> 1648;
4367 -> 1509;
4367 -> 1510;
4367 -> 4352;
4367 -> 1520;
4367 -> 1512;
4368 -> 1663;
4369 -> 4368;
4369 -> 1532;
4370 -> 4369;
4370 -> 1534;
4370 -> 1532;
4371 -> 1530;
4371 -> 1564;
4371 -> 1659;
4371 -> 4370;
4371 -> 1668;
4371 -> 1558;
4371 -> 1559;
4371 -> 4356;
4371 -> 1566;
4371 -> 1563;
4372 -> 1683;
4373 -> 4372;
4373 -> 1578;
4374 -> 4373;
4374 -> 1580;
4374 -> 1578;
4375 -> 1576;
4375 -> 1610;
4375 -> 1679;
4375 -> 4374;
4375 -> 1688;
4375 -> 1604;
4375 -> 1605;
4375 -> 4360;
4375 -> 1612;
4375 -> 1609;
4376 -> 1624;
4377 -> 4376;
4377 -> 1445;
4378 -> 4377;
4378 -> 1447;
4378 -> 1445;
4379 -> 1643;
4380 -> 4379;
4380 -> 1483;
4381 -> 4380;
4381 -> 1485;
4381 -> 1483;
4382 -> 1481;
4382 -> 1513;
4382 -> 1639;
4382 -> 4381;
4382 -> 1648;
4382 -> 1509;
4382 -> 1510;
4382 -> 4367;
4382 -> 1520;
4382 -> 1512;
4383 -> 1663;
4384 -> 4383;
4384 -> 1532;
4385 -> 4384;
4385 -> 1534;
4385 -> 1532;
4386 -> 1530;
4386 -> 1564;
4386 -> 1659;
4386 -> 4385;
4386 -> 1668;
4386 -> 1558;
4386 -> 1559;
4386 -> 4371;
4386 -> 1566;
4386 -> 1563;
4387 -> 1683;
4388 -> 4387;
4388 -> 1578;
4389 -> 4388;
4389 -> 1580;
4389 -> 1578;
4390 -> 1576;
4390 -> 1610;
4390 -> 1679;
4390 -> 4389;
4390 -> 1688;
4390 -> 1604;
4390 -> 1605;
4390 -> 4375;
4390 -> 1612;
4390 -> 1609;
4391 -> 1624;
4392 -> 4391;
4392 -> 1445;
4393 -> 4392;
4393 -> 1447;
4393 -> 1445;
4394 -> 1643;
4395 -> 4394;
4395 -> 1483;
4396 -> 4395;
4396 -> 1485;
4396 -> 1483;
4397 -> 1481;
4397 -> 1513;
4397 -> 1639;
4397 -> 4396;
4397 -> 1648;
4397 -> 1509;
4397 -> 1510;
4397 -> 4382;
4397 -> 1520;
4397 -> 1512;
4398 -> 1663;
4399 -> 4398;
4399 -> 1532;
4400 -> 4399;
4400 -> 1534;
4400 -> 1532;
4401 -> 1530;
4401 -> 1564;
4401 -> 1659;
4401 -> 4400;
4401 -> 1668;
4401 -> 1558;
4401 -> 1559;
4401 -> 4386;
4401 -> 1566;
4401 -> 1563;
4402 -> 1683;
4403 -> 4402;
4403 -> 1578;
4404 -> 4403;
4404 -> 1580;
4404 -> 1578;
4405 -> 1576;
4405 -> 1610;
4405 -> 1679;
4405 -> 4404;
4405 -> 1688;
4405 -> 1604;
4405 -> 1605;
4405 -> 4390;
4405 -> 1612;
4405 -> 1609;
4406 -> 1624;
4407 -> 4406;
4407 -> 1445;
4408 -> 4407;
4408 -> 1447;
4408 -> 1445;
4409 -> 1643;
4410 -> 4409;
4410 -> 1483;
4411 -> 4410;
4411 -> 1485;
4411 -> 1483;
4412 -> 1481;
4412 -> 1513;
4412 -> 1639;
4412 -> 4411;
4412 -> 1648;
4412 -> 1509;
4412 -> 1510;
4412 -> 4397;
4412 -> 1520;
4412 -> 1512;
4413 -> 1663;
4414 -> 4413;
4414 -> 1532;
4415 -> 4414;
4415 -> 1534;
4415 -> 1532;
4416 -> 1530;
4416 -> 1564;
4416 -> 1659;
4416 -> 4415;
4416 -> 1668;
4416 -> 1558;
4416 -> 1559;
4416 -> 4401;
4416 -> 1566;
4416 -> 1563;
4417 -> 1683;
4418 -> 4417;
4418 -> 1578;
4419 -> 4418;
4419 -> 1580;
4419 -> 1578;
4420 -> 1576;
4420 -> 1610;
4420 -> 1679;
4420 -> 4419;
4420 -> 1688;
4420 -> 1604;
4420 -> 1605;
4420 -> 4405;
4420 -> 1612;
4420 -> 1609;
4421 -> 1624;
4422 -> 4421;
4422 -> 1445;
4423 -> 4422;
4423 -> 1447;
4423 -> 1445;
4424 -> 1643;
4425 -> 4424;
4425 -> 1483;
4426 -> 4425;
4426 -> 1485;
4426 -> 1483;
4427 -> 1481;
4427 -> 1513;
4427 -> 1639;
4427 -> 4426;
4427 -> 1648;
4427 -> 1509;
4427 -> 1510;
4427 -> 4412;
4427 -> 1520;
4427 -> 1512;
4428 -> 1663;
4429 -> 4428;
4429 -> 1532;
4430 -> 4429;
4430 -> 1534;
4430 -> 1532;
4431 -> 1530;
4431 -> 1564;
4431 -> 1659;
4431 -> 4430;
4431 -> 1668;
4431 -> 1558;
4431 -> 1559;
4431 -> 4416;
4431 -> 1566;
4431 -> 1563;
4432 -> 1683;
4433 -> 4432;
4433 -> 1578;
4434 -> 4433;
4434 -> 1580;
4434 -> 1578;
4435 -> 1576;
4435 -> 1610;
4435 -> 1679;
4435 -> 4434;
4435 -> 1688;
4435 -> 1604;
4435 -> 1605;
4435 -> 4420;
4435 -> 1612;
4435 -> 1609;
4436 -> 1624;
4437 -> 4436;
4437 -> 1445;
4438 -> 4437;
4438 -> 1447;
4438 -> 1445;
4439 -> 1643;
4440 -> 4439;
4440 -> 1483;
4441 -> 4440;
4441 -> 1485;
4441 -> 1483;
4442 -> 1481;
4442 -> 1513;
4442 -> 1639;
4442 -> 4441;
4442 -> 1648;
4442 -> 1509;
4442 -> 1510;
4442 -> 4427;
4442 -> 1520;
4442 -> 1512;
4443 -> 1663;
4444 -> 4443;
4444 -> 1532;
4445 -> 4444;
4445 -> 1534;
4445 -> 1532;
4446 -> 1530;
4446 -> 1564;
4446 -> 1659;
4446 -> 4445;
4446 -> 1668;
4446 -> 1558;
4446 -> 1559;
4446 -> 4431;
4446 -> 1566;
4446 -> 1563;
4447 -> 1683;
4448 -> 4447;
4448 -> 1578;
4449 -> 4448;
4449 -> 1580;
4449 -> 1578;
4450 -> 1576;
4450 -> 1610;
4450 -> 1679;
4450 -> 4449;
4450 -> 1688;
4450 -> 1604;
4450 -> 1605;
4450 -> 4435;
4450 -> 1612;
4450 -> 1609;
4451 -> 1624;
4452 -> 4451;
4452 -> 1445;
4453 -> 4452;
4453 -> 1447;
4453 -> 1445;
4454 -> 1643;
4455 -> 4454;
4455 -> 1483;
4456 -> 4455;
4456 -> 1485;
4456 -> 1483;
4457 -> 1481;
4457 -> 1513;
4457 -> 1639;
4457 -> 4456;
4457 -> 1648;
4457 -> 1509;
4457 -> 1510;
4457 -> 4442;
4457 -> 1520;
4457 -> 1512;
4458 -> 1663;
4459 -> 4458;
4459 -> 1532;
4460 -> 4459;
4460 -> 1534;
4460 -> 1532;
4461 -> 1530;
4461 -> 1564;
4461 -> 1659;
4461 -> 4460;
4461 -> 1668;
4461 -> 1558;
4461 -> 1559;
4461 -> 4446;
4461 -> 1566;
4461 -> 1563;
4462 -> 1683;
4463 -> 4462;
4463 -> 1578;
4464 -> 4463;
4464 -> 1580;
4464 -> 1578;
4465 -> 1576;
4465 -> 1610;
4465 -> 1679;
4465 -> 4464;
4465 -> 1688;
4465 -> 1604;
4465 -> 1605;
4465 -> 4450;
4465 -> 1612;
4465 -> 1609;
4466 -> 1624;
4467 -> 4466;
4467 -> 1445;
4468 -> 4467;
4468 -> 1447;
4468 -> 1445;
4469 -> 1643;
4470 -> 4469;
4470 -> 1483;
4471 -> 4470;
4471 -> 1485;
4471 -> 1483;
4472 -> 1481;
4472 -> 1513;
4472 -> 1639;
4472 -> 4471;
4472 -> 1648;
4472 -> 1509;
4472 -> 1510;
4472 -> 4457;
4472 -> 1520;
4472 -> 1512;
4473 -> 1663;
4474 -> 4473;
4474 -> 1532;
4475 -> 4474;
4475 -> 1534;
4475 -> 1532;
4476 -> 1530;
4476 -> 1564;
4476 -> 1659;
4476 -> 4475;
4476 -> 1668;
4476 -> 1558;
4476 -> 1559;
4476 -> 4461;
4476 -> 1566;
4476 -> 1563;
4477 -> 1683;
4478 -> 4477;
4478 -> 1578;
4479 -> 4478;
4479 -> 1580;
4479 -> 1578;
4480 -> 1576;
4480 -> 1610;
4480 -> 1679;
4480 -> 4479;
4480 -> 1688;
4480 -> 1604;
4480 -> 1605;
4480 -> 4465;
4480 -> 1612;
4480 -> 1609;
4481 -> 1624;
4482 -> 4481;
4482 -> 1445;
4483 -> 4482;
4483 -> 1447;
4483 -> 1445;
4484 -> 1643;
4485 -> 4484;
4485 -> 1483;
4486 -> 4485;
4486 -> 1485;
4486 -> 1483;
4487 -> 1481;
4487 -> 1513;
4487 -> 1639;
4487 -> 4486;
4487 -> 1648;
4487 -> 1509;
4487 -> 1510;
4487 -> 4472;
4487 -> 1520;
4487 -> 1512;
4488 -> 1663;
4489 -> 4488;
4489 -> 1532;
4490 -> 4489;
4490 -> 1534;
4490 -> 1532;
4491 -> 1530;
4491 -> 1564;
4491 -> 1659;
4491 -> 4490;
4491 -> 1668;
4491 -> 1558;
4491 -> 1559;
4491 -> 4476;
4491 -> 1566;
4491 -> 1563;
4492 -> 1683;
4493 -> 4492;
4493 -> 1578;
4494 -> 4493;
4494 -> 1580;
4494 -> 1578;
4495 -> 1576;
4495 -> 1610;
4495 -> 1679;
4495 -> 4494;
4495 -> 1688;
4495 -> 1604;
4495 -> 1605;
4495 -> 4480;
4495 -> 1612;
4495 -> 1609;
4496 -> 1624;
4497 -> 4496;
4497 -> 1445;
4498 -> 4497;
4498 -> 1447;
4498 -> 1445;
4499 -> 1643;
4500 -> 4499;
4500 -> 1483;
4501 -> 4500;
4501 -> 1485;
4501 -> 1483;
4502 -> 1481;
4502 -> 1513;
4502 -> 1639;
4502 -> 4501;
4502 -> 1648;
4502 -> 1509;
4502 -> 1510;
4502 -> 4487;
4502 -> 1520;
4502 -> 1512;
4503 -> 1663;
4504 -> 4503;
4504 -> 1532;
4505 -> 4504;
4505 -> 1534;
4505 -> 1532;
4506 -> 1530;
4506 -> 1564;
4506 -> 1659;
4506 -> 4505;
4506 -> 1668;
4506 -> 1558;
4506 -> 1559;
4506 -> 4491;
4506 -> 1566;
4506 -> 1563;
4507 -> 1683;
4508 -> 4507;
4508 -> 1578;
4509 -> 4508;
4509 -> 1580;
4509 -> 1578;
4510 -> 1576;
4510 -> 1610;
4510 -> 1679;
4510 -> 4509;
4510 -> 1688;
4510 -> 1604;
4510 -> 1605;
4510 -> 4495;
4510 -> 1612;
4510 -> 1609;
4511 -> 1624;
4512 -> 4511;
4512 -> 1445;
4513 -> 4512;
4513 -> 1447;
4513 -> 1445;
4514 -> 1643;
4515 -> 4514;
4515 -> 1483;
4516 -> 4515;
4516 -> 1485;
4516 -> 1483;
4517 -> 1481;
4517 -> 1513;
4517 -> 1639;
4517 -> 4516;
4517 -> 1648;
4517 -> 1509;
4517 -> 1510;
4517 -> 4502;
4517 -> 1520;
4517 -> 1512;
4518 -> 1663;
4519 -> 4518;
4519 -> 1532;
4520 -> 4519;
4520 -> 1534;
4520 -> 1532;
4521 -> 1530;
4521 -> 1564;
4521 -> 1659;
4521 -> 4520;
4521 -> 1668;
4521 -> 1558;
4521 -> 1559;
4521 -> 4506;
4521 -> 1566;
4521 -> 1563;
4522 -> 1683;
4523 -> 4522;
4523 -> 1578;
4524 -> 4523;
4524 -> 1580;
4524 -> 1578;
4525 -> 1576;
4525 -> 1610;
4525 -> 1679;
4525 -> 4524;
4525 -> 1688;
4525 -> 1604;
4525 -> 1605;
4525 -> 4510;
4525 -> 1612;
4525 -> 1609;
4526 -> 1624;
4527 -> 4526;
4527 -> 1445;
4528 -> 4527;
4528 -> 1447;
4528 -> 1445;
4529 -> 1643;
4530 -> 4529;
4530 -> 1483;
4531 -> 4530;
4531 -> 1485;
4531 -> 1483;
4532 -> 1481;
4532 -> 1513;
4532 -> 1639;
4532 -> 4531;
4532 -> 1648;
4532 -> 1509;
4532 -> 1510;
4532 -> 4517;
4532 -> 1520;
4532 -> 1512;
4533 -> 1663;
4534 -> 4533;
4534 -> 1532;
4535 -> 4534;
4535 -> 1534;
4535 -> 1532;
4536 -> 1530;
4536 -> 1564;
4536 -> 1659;
4536 -> 4535;
4536 -> 1668;
4536 -> 1558;
4536 -> 1559;
4536 -> 4521;
4536 -> 1566;
4536 -> 1563;
4537 -> 1683;
4538 -> 4537;
4538 -> 1578;
4539 -> 4538;
4539 -> 1580;
4539 -> 1578;
4540 -> 1576;
4540 -> 1610;
4540 -> 1679;
4540 -> 4539;
4540 -> 1688;
4540 -> 1604;
4540 -> 1605;
4540 -> 4525;
4540 -> 1612;
4540 -> 1609;
4541 -> 1624;
4542 -> 4541;
4542 -> 1445;
4543 -> 4542;
4543 -> 1447;
4543 -> 1445;
4544 -> 1643;
4545 -> 4544;
4545 -> 1483;
4546 -> 4545;
4546 -> 1485;
4546 -> 1483;
4547 -> 1481;
4547 -> 1513;
4547 -> 1639;
4547 -> 4546;
4547 -> 1648;
4547 -> 1509;
4547 -> 1510;
4547 -> 4532;
4547 -> 1520;
4547 -> 1512;
4548 -> 1663;
4549 -> 4548;
4549 -> 1532;
4550 -> 4549;
4550 -> 1534;
4550 -> 1532;
4551 -> 1530;
4551 -> 1564;
4551 -> 1659;
4551 -> 4550;
4551 -> 1668;
4551 -> 1558;
4551 -> 1559;
4551 -> 4536;
4551 -> 1566;
4551 -> 1563;
4552 -> 1683;
4553 -> 4552;
4553 -> 1578;
4554 -> 4553;
4554 -> 1580;
4554 -> 1578;
4555 -> 1576;
4555 -> 1610;
4555 -> 1679;
4555 -> 4554;
4555 -> 1688;
4555 -> 1604;
4555 -> 1605;
4555 -> 4540;
4555 -> 1612;
4555 -> 1609;
4556 -> 1624;
4557 -> 4556;
4557 -> 1445;
4558 -> 4557;
4558 -> 1447;
4558 -> 1445;
4559 -> 1643;
4560 -> 4559;
4560 -> 1483;
4561 -> 4560;
4561 -> 1485;
4561 -> 1483;
4562 -> 1481;
4562 -> 1513;
4562 -> 1639;
4562 -> 4561;
4562 -> 1648;
4562 -> 1509;
4562 -> 1510;
4562 -> 4547;
4562 -> 1520;
4562 -> 1512;
4563 -> 1663;
4564 -> 4563;
4564 -> 1532;
4565 -> 4564;
4565 -> 1534;
4565 -> 1532;
4566 -> 1530;
4566 -> 1564;
4566 -> 1659;
4566 -> 4565;
4566 -> 1668;
4566 -> 1558;
4566 -> 1559;
4566 -> 4551;
4566 -> 1566;
4566 -> 1563;
4567 -> 1683;
4568 -> 4567;
4568 -> 1578;
4569 -> 4568;
4569 -> 1580;
4569 -> 1578;
4570 -> 1576;
4570 -> 1610;
4570 -> 1679;
4570 -> 4569;
4570 -> 1688;
4570 -> 1604;
4570 -> 1605;
4570 -> 4555;
4570 -> 1612;
4570 -> 1609;
4571 -> 1624;
4572 -> 4571;
4572 -> 1445;
4573 -> 4572;
4573 -> 1447;
4573 -> 1445;
4574 -> 1643;
4575 -> 4574;
4575 -> 1483;
4576 -> 4575;
4576 -> 1485;
4576 -> 1483;
4577 -> 1481;
4577 -> 1513;
4577 -> 1639;
4577 -> 4576;
4577 -> 1648;
4577 -> 1509;
4577 -> 1510;
4577 -> 4562;
4577 -> 1520;
4577 -> 1512;
4578 -> 1663;
4579 -> 4578;
4579 -> 1532;
4580 -> 4579;
4580 -> 1534;
4580 -> 1532;
4581 -> 1530;
4581 -> 1564;
4581 -> 1659;
4581 -> 4580;
4581 -> 1668;
4581 -> 1558;
4581 -> 1559;
4581 -> 4566;
4581 -> 1566;
4581 -> 1563;
4582 -> 1683;
4583 -> 4582;
4583 -> 1578;
4584 -> 4583;
4584 -> 1580;
4584 -> 1578;
4585 -> 1576;
4585 -> 1610;
4585 -> 1679;
4585 -> 4584;
4585 -> 1688;
4585 -> 1604;
4585 -> 1605;
4585 -> 4570;
4585 -> 1612;
4585 -> 1609;
4586 -> 1624;
4587 -> 4586;
4587 -> 1445;
4588 -> 4587;
4588 -> 1447;
4588 -> 1445;
4589 -> 1643;
4590 -> 4589;
4590 -> 1483;
4591 -> 4590;
4591 -> 1485;
4591 -> 1483;
4592 -> 1481;
4592 -> 1513;
4592 -> 1639;
4592 -> 4591;
4592 -> 1648;
4592 -> 1509;
4592 -> 1510;
4592 -> 4577;
4592 -> 1520;
4592 -> 1512;
4593 -> 1663;
4594 -> 4593;
4594 -> 1532;
4595 -> 4594;
4595 -> 1534;
4595 -> 1532;
4596 -> 1530;
4596 -> 1564;
4596 -> 1659;
4596 -> 4595;
4596 -> 1668;
4596 -> 1558;
4596 -> 1559;
4596 -> 4581;
4596 -> 1566;
4596 -> 1563;
4597 -> 1683;
4598 -> 4597;
4598 -> 1578;
4599 -> 4598;
4599 -> 1580;
4599 -> 1578;
4600 -> 1576;
4600 -> 1610;
4600 -> 1679;
4600 -> 4599;
4600 -> 1688;
4600 -> 1604;
4600 -> 1605;
4600 -> 4585;
4600 -> 1612;
4600 -> 1609;
4601 -> 1624;
4602 -> 4601;
4602 -> 1445;
4603 -> 4602;
4603 -> 1447;
4603 -> 1445;
4604 -> 1643;
4605 -> 4604;
4605 -> 1483;
4606 -> 4605;
4606 -> 1485;
4606 -> 1483;
4607 -> 1481;
4607 -> 1513;
4607 -> 1639;
4607 -> 4606;
4607 -> 1648;
4607 -> 1509;
4607 -> 1510;
4607 -> 4592;
4607 -> 1520;
4607 -> 1512;
4608 -> 1663;
4609 -> 4608;
4609 -> 1532;
4610 -> 4609;
4610 -> 1534;
4610 -> 1532;
4611 -> 1530;
4611 -> 1564;
4611 -> 1659;
4611 -> 4610;
4611 -> 1668;
4611 -> 1558;
4611 -> 1559;
4611 -> 4596;
4611 -> 1566;
4611 -> 1563;
4612 -> 1683;
4613 -> 4612;
4613 -> 1578;
4614 -> 4613;
4614 -> 1580;
4614 -> 1578;
4615 -> 1576;
4615 -> 1610;
4615 -> 1679;
4615 -> 4614;
4615 -> 1688;
4615 -> 1604;
4615 -> 1605;
4615 -> 4600;
4615 -> 1612;
4615 -> 1609;
4616 -> 1624;
4617 -> 4616;
4617 -> 1445;
4618 -> 4617;
4618 -> 1447;
4618 -> 1445;
4619 -> 1643;
4620 -> 4619;
4620 -> 1483;
4621 -> 4620;
4621 -> 1485;
4621 -> 1483;
4622 -> 1481;
4622 -> 1513;
4622 -> 1639;
4622 -> 4621;
4622 -> 1648;
4622 -> 1509;
4622 -> 1510;
4622 -> 4607;
4622 -> 1520;
4622 -> 1512;
4623 -> 1663;
4624 -> 4623;
4624 -> 1532;
4625 -> 4624;
4625 -> 1534;
4625 -> 1532;
4626 -> 1530;
4626 -> 1564;
4626 -> 1659;
4626 -> 4625;
4626 -> 1668;
4626 -> 1558;
4626 -> 1559;
4626 -> 4611;
4626 -> 1566;
4626 -> 1563;
4627 -> 1683;
4628 -> 4627;
4628 -> 1578;
4629 -> 4628;
4629 -> 1580;
4629 -> 1578;
4630 -> 1576;
4630 -> 1610;
4630 -> 1679;
4630 -> 4629;
4630 -> 1688;
4630 -> 1604;
4630 -> 1605;
4630 -> 4615;
4630 -> 1612;
4630 -> 1609;
4631 -> 1624;
4632 -> 4631;
4632 -> 1445;
4633 -> 4632;
4633 -> 1447;
4633 -> 1445;
4634 -> 1643;
4635 -> 4634;
4635 -> 1483;
4636 -> 4635;
4636 -> 1485;
4636 -> 1483;
4637 -> 1481;
4637 -> 1513;
4637 -> 1639;
4637 -> 4636;
4637 -> 1648;
4637 -> 1509;
4637 -> 1510;
4637 -> 4622;
4637 -> 1520;
4637 -> 1512;
4638 -> 1663;
4639 -> 4638;
4639 -> 1532;
4640 -> 4639;
4640 -> 1534;
4640 -> 1532;
4641 -> 1530;
4641 -> 1564;
4641 -> 1659;
4641 -> 4640;
4641 -> 1668;
4641 -> 1558;
4641 -> 1559;
4641 -> 4626;
4641 -> 1566;
4641 -> 1563;
4642 -> 1683;
4643 -> 4642;
4643 -> 1578;
4644 -> 4643;
4644 -> 1580;
4644 -> 1578;
4645 -> 1576;
4645 -> 1610;
4645 -> 1679;
4645 -> 4644;
4645 -> 1688;
4645 -> 1604;
4645 -> 1605;
4645 -> 4630;
4645 -> 1612;
4645 -> 1609;
4646 -> 1624;
4647 -> 4646;
4647 -> 1445;
4648 -> 4647;
4648 -> 1447;
4648 -> 1445;
4649 -> 1643;
4650 -> 4649;
4650 -> 1483;
4651 -> 4650;
4651 -> 1485;
4651 -> 1483;
4652 -> 1481;
4652 -> 1513;
4652 -> 1639;
4652 -> 4651;
4652 -> 1648;
4652 -> 1509;
4652 -> 1510;
4652 -> 4637;
4652 -> 1520;
4652 -> 1512;
4653 -> 1663;
4654 -> 4653;
4654 -> 1532;
4655 -> 4654;
4655 -> 1534;
4655 -> 1532;
4656 -> 1530;
4656 -> 1564;
4656 -> 1659;
4656 -> 4655;
4656 -> 1668;
4656 -> 1558;
4656 -> 1559;
4656 -> 4641;
4656 -> 1566;
4656 -> 1563;
4657 -> 1683;
4658 -> 4657;
4658 -> 1578;
4659 -> 4658;
4659 -> 1580;
4659 -> 1578;
4660 -> 1576;
4660 -> 1610;
4660 -> 1679;
4660 -> 4659;
4660 -> 1688;
4660 -> 1604;
4660 -> 1605;
4660 -> 4645;
4660 -> 1612;
4660 -> 1609;
4661 -> 1624;
4662 -> 4661;
4662 -> 1445;
4663 -> 4662;
4663 -> 1447;
4663 -> 1445;
4664 -> 1643;
4665 -> 4664;
4665 -> 1483;
4666 -> 4665;
4666 -> 1485;
4666 -> 1483;
4667 -> 1481;
4667 -> 1513;
4667 -> 1639;
4667 -> 4666;
4667 -> 1648;
4667 -> 1509;
4667 -> 1510;
4667 -> 4652;
4667 -> 1520;
4667 -> 1512;
4668 -> 1663;
4669 -> 4668;
4669 -> 1532;
4670 -> 4669;
4670 -> 1534;
4670 -> 1532;
4671 -> 1530;
4671 -> 1564;
4671 -> 1659;
4671 -> 4670;
4671 -> 1668;
4671 -> 1558;
4671 -> 1559;
4671 -> 4656;
4671 -> 1566;
4671 -> 1563;
4672 -> 1683;
4673 -> 4672;
4673 -> 1578;
4674 -> 4673;
4674 -> 1580;
4674 -> 1578;
4675 -> 1576;
4675 -> 1610;
4675 -> 1679;
4675 -> 4674;
4675 -> 1688;
4675 -> 1604;
4675 -> 1605;
4675 -> 4660;
4675 -> 1612;
4675 -> 1609;
4676 -> 1624;
4677 -> 4676;
4677 -> 1445;
4678 -> 4677;
4678 -> 1447;
4678 -> 1445;
4679 -> 1643;
4680 -> 4679;
4680 -> 1483;
4681 -> 4680;
4681 -> 1485;
4681 -> 1483;
4682 -> 1481;
4682 -> 1513;
4682 -> 1639;
4682 -> 4681;
4682 -> 1648;
4682 -> 1509;
4682 -> 1510;
4682 -> 4667;
4682 -> 1520;
4682 -> 1512;
4683 -> 1663;
4684 -> 4683;
4684 -> 1532;
4685 -> 4684;
4685 -> 1534;
4685 -> 1532;
4686 -> 1530;
4686 -> 1564;
4686 -> 1659;
4686 -> 4685;
4686 -> 1668;
4686 -> 1558;
4686 -> 1559;
4686 -> 4671;
4686 -> 1566;
4686 -> 1563;
4687 -> 1683;
4688 -> 4687;
4688 -> 1578;
4689 -> 4688;
4689 -> 1580;
4689 -> 1578;
4690 -> 1576;
4690 -> 1610;
4690 -> 1679;
4690 -> 4689;
4690 -> 1688;
4690 -> 1604;
4690 -> 1605;
4690 -> 4675;
4690 -> 1612;
4690 -> 1609;
4691 -> 1624;
4692 -> 4691;
4692 -> 1445;
4693 -> 4692;
4693 -> 1447;
4693 -> 1445;
4694 -> 1643;
4695 -> 4694;
4695 -> 1483;
4696 -> 4695;
4696 -> 1485;
4696 -> 1483;
4697 -> 1481;
4697 -> 1513;
4697 -> 1639;
4697 -> 4696;
4697 -> 1648;
4697 -> 1509;
4697 -> 1510;
4697 -> 4682;
4697 -> 1520;
4697 -> 1512;
4698 -> 1663;
4699 -> 4698;
4699 -> 1532;
4700 -> 4699;
4700 -> 1534;
4700 -> 1532;
4701 -> 1530;
4701 -> 1564;
4701 -> 1659;
4701 -> 4700;
4701 -> 1668;
4701 -> 1558;
4701 -> 1559;
4701 -> 4686;
4701 -> 1566;
4701 -> 1563;
4702 -> 1683;
4703 -> 4702;
4703 -> 1578;
4704 -> 4703;
4704 -> 1580;
4704 -> 1578;
4705 -> 1576;
4705 -> 1610;
4705 -> 1679;
4705 -> 4704;
4705 -> 1688;
4705 -> 1604;
4705 -> 1605;
4705 -> 4690;
4705 -> 1612;
4705 -> 1609;
4706 -> 1624;
4707 -> 4706;
4707 -> 1445;
4708 -> 4707;
4708 -> 1447;
4708 -> 1445;
4709 -> 1643;
4710 -> 4709;
4710 -> 1483;
4711 -> 4710;
4711 -> 1485;
4711 -> 1483;
4712 -> 1481;
4712 -> 1513;
4712 -> 1639;
4712 -> 4711;
4712 -> 1648;
4712 -> 1509;
4712 -> 1510;
4712 -> 4697;
4712 -> 1520;
4712 -> 1512;
4713 -> 1663;
4714 -> 4713;
4714 -> 1532;
4715 -> 4714;
4715 -> 1534;
4715 -> 1532;
4716 -> 1530;
4716 -> 1564;
4716 -> 1659;
4716 -> 4715;
4716 -> 1668;
4716 -> 1558;
4716 -> 1559;
4716 -> 4701;
4716 -> 1566;
4716 -> 1563;
4717 -> 1683;
4718 -> 4717;
4718 -> 1578;
4719 -> 4718;
4719 -> 1580;
4719 -> 1578;
4720 -> 1576;
4720 -> 1610;
4720 -> 1679;
4720 -> 4719;
4720 -> 1688;
4720 -> 1604;
4720 -> 1605;
4720 -> 4705;
4720 -> 1612;
4720 -> 1609;
4721 -> 1624;
4722 -> 4721;
4722 -> 1445;
4723 -> 4722;
4723 -> 1447;
4723 -> 1445;
4724 -> 1643;
4725 -> 4724;
4725 -> 1483;
4726 -> 4725;
4726 -> 1485;
4726 -> 1483;
4727 -> 1481;
4727 -> 1513;
4727 -> 1639;
4727 -> 4726;
4727 -> 1648;
4727 -> 1509;
4727 -> 1510;
4727 -> 4712;
4727 -> 1520;
4727 -> 1512;
4728 -> 1663;
4729 -> 4728;
4729 -> 1532;
4730 -> 4729;
4730 -> 1534;
4730 -> 1532;
4731 -> 1530;
4731 -> 1564;
4731 -> 1659;
4731 -> 4730;
4731 -> 1668;
4731 -> 1558;
4731 -> 1559;
4731 -> 4716;
4731 -> 1566;
4731 -> 1563;
4732 -> 1683;
4733 -> 4732;
4733 -> 1578;
4734 -> 4733;
4734 -> 1580;
4734 -> 1578;
4735 -> 1576;
4735 -> 1610;
4735 -> 1679;
4735 -> 4734;
4735 -> 1688;
4735 -> 1604;
4735 -> 1605;
4735 -> 4720;
4735 -> 1612;
4735 -> 1609;
4736 -> 1624;
4737 -> 4736;
4737 -> 1445;
4738 -> 4737;
4738 -> 1447;
4738 -> 1445;
4739 -> 1643;
4740 -> 4739;
4740 -> 1483;
4741 -> 4740;
4741 -> 1485;
4741 -> 1483;
4742 -> 1481;
4742 -> 1513;
4742 -> 1639;
4742 -> 4741;
4742 -> 1648;
4742 -> 1509;
4742 -> 1510;
4742 -> 4727;
4742 -> 1520;
4742 -> 1512;
4743 -> 1663;
4744 -> 4743;
4744 -> 1532;
4745 -> 4744;
4745 -> 1534;
4745 -> 1532;
4746 -> 1530;
4746 -> 1564;
4746 -> 1659;
4746 -> 4745;
4746 -> 1668;
4746 -> 1558;
4746 -> 1559;
4746 -> 4731;
4746 -> 1566;
4746 -> 1563;
4747 -> 1683;
4748 -> 4747;
4748 -> 1578;
4749 -> 4748;
4749 -> 1580;
4749 -> 1578;
4750 -> 1576;
4750 -> 1610;
4750 -> 1679;
4750 -> 4749;
4750 -> 1688;
4750 -> 1604;
4750 -> 1605;
4750 -> 4735;
4750 -> 1612;
4750 -> 1609;
4751 -> 1624;
4752 -> 4751;
4752 -> 1445;
4753 -> 4752;
4753 -> 1447;
4753 -> 1445;
4754 -> 1643;
4755 -> 4754;
4755 -> 1483;
4756 -> 4755;
4756 -> 1485;
4756 -> 1483;
4757 -> 1481;
4757 -> 1513;
4757 -> 1639;
4757 -> 4756;
4757 -> 1648;
4757 -> 1509;
4757 -> 1510;
4757 -> 4742;
4757 -> 1520;
4757 -> 1512;
4758 -> 1663;
4759 -> 4758;
4759 -> 1532;
4760 -> 4759;
4760 -> 1534;
4760 -> 1532;
4761 -> 1530;
4761 -> 1564;
4761 -> 1659;
4761 -> 4760;
4761 -> 1668;
4761 -> 1558;
4761 -> 1559;
4761 -> 4746;
4761 -> 1566;
4761 -> 1563;
4762 -> 1683;
4763 -> 4762;
4763 -> 1578;
4764 -> 4763;
4764 -> 1580;
4764 -> 1578;
4765 -> 1576;
4765 -> 1610;
4765 -> 1679;
4765 -> 4764;
4765 -> 1688;
4765 -> 1604;
4765 -> 1605;
4765 -> 4750;
4765 -> 1612;
4765 -> 1609;
4766 -> 1624;
4767 -> 4766;
4767 -> 1445;
4768 -> 4767;
4768 -> 1447;
4768 -> 1445;
4769 -> 1643;
4770 -> 4769;
4770 -> 1483;
4771 -> 4770;
4771 -> 1485;
4771 -> 1483;
4772 -> 1481;
4772 -> 1513;
4772 -> 1639;
4772 -> 4771;
4772 -> 1648;
4772 -> 1509;
4772 -> 1510;
4772 -> 4757;
4772 -> 1520;
4772 -> 1512;
4773 -> 1663;
4774 -> 4773;
4774 -> 1532;
4775 -> 4774;
4775 -> 1534;
4775 -> 1532;
4776 -> 1530;
4776 -> 1564;
4776 -> 1659;
4776 -> 4775;
4776 -> 1668;
4776 -> 1558;
4776 -> 1559;
4776 -> 4761;
4776 -> 1566;
4776 -> 1563;
4777 -> 1683;
4778 -> 4777;
4778 -> 1578;
4779 -> 4778;
4779 -> 1580;
4779 -> 1578;
4780 -> 1576;
4780 -> 1610;
4780 -> 1679;
4780 -> 4779;
4780 -> 1688;
4780 -> 1604;
4780 -> 1605;
4780 -> 4765;
4780 -> 1612;
4780 -> 1609;
4781 -> 1624;
4782 -> 4781;
4782 -> 1445;
4783 -> 4782;
4783 -> 1447;
4783 -> 1445;
4784 -> 1643;
4785 -> 4784;
4785 -> 1483;
4786 -> 4785;
4786 -> 1485;
4786 -> 1483;
4787 -> 1481;
4787 -> 1513;
4787 -> 1639;
4787 -> 4786;
4787 -> 1648;
4787 -> 1509;
4787 -> 1510;
4787 -> 4772;
4787 -> 1520;
4787 -> 1512;
4788 -> 1663;
4789 -> 4788;
4789 -> 1532;
4790 -> 4789;
4790 -> 1534;
4790 -> 1532;
4791 -> 1530;
4791 -> 1564;
4791 -> 1659;
4791 -> 4790;
4791 -> 1668;
4791 -> 1558;
4791 -> 1559;
4791 -> 4776;
4791 -> 1566;
4791 -> 1563;
4792 -> 1683;
4793 -> 4792;
4793 -> 1578;
4794 -> 4793;
4794 -> 1580;
4794 -> 1578;
4795 -> 1576;
4795 -> 1610;
4795 -> 1679;
4795 -> 4794;
4795 -> 1688;
4795 -> 1604;
4795 -> 1605;
4795 -> 4780;
4795 -> 1612;
4795 -> 1609;
4796 -> 1624;
4797 -> 4796;
4797 -> 1445;
4798 -> 4797;
4798 -> 1447;
4798 -> 1445;
4799 -> 1643;
4800 -> 4799;
4800 -> 1483;
4801 -> 4800;
4801 -> 1485;
4801 -> 1483;
4802 -> 1481;
4802 -> 1513;
4802 -> 1639;
4802 -> 4801;
4802 -> 1648;
4802 -> 1509;
4802 -> 1510;
4802 -> 4787;
4802 -> 1520;
4802 -> 1512;
4803 -> 1663;
4804 -> 4803;
4804 -> 1532;
4805 -> 4804;
4805 -> 1534;
4805 -> 1532;
4806 -> 1530;
4806 -> 1564;
4806 -> 1659;
4806 -> 4805;
4806 -> 1668;
4806 -> 1558;
4806 -> 1559;
4806 -> 4791;
4806 -> 1566;
4806 -> 1563;
4807 -> 1683;
4808 -> 4807;
4808 -> 1578;
4809 -> 4808;
4809 -> 1580;
4809 -> 1578;
4810 -> 1576;
4810 -> 1610;
4810 -> 1679;
4810 -> 4809;
4810 -> 1688;
4810 -> 1604;
4810 -> 1605;
4810 -> 4795;
4810 -> 1612;
4810 -> 1609;
4811 -> 1624;
4812 -> 4811;
4812 -> 1445;
4813 -> 4812;
4813 -> 1447;
4813 -> 1445;
4814 -> 1643;
4815 -> 4814;
4815 -> 1483;
4816 -> 4815;
4816 -> 1485;
4816 -> 1483;
4817 -> 1481;
4817 -> 1513;
4817 -> 1639;
4817 -> 4816;
4817 -> 1648;
4817 -> 1509;
4817 -> 1510;
4817 -> 4802;
4817 -> 1520;
4817 -> 1512;
4818 -> 1663;
4819 -> 4818;
4819 -> 1532;
4820 -> 4819;
4820 -> 1534;
4820 -> 1532;
4821 -> 1530;
4821 -> 1564;
4821 -> 1659;
4821 -> 4820;
4821 -> 1668;
4821 -> 1558;
4821 -> 1559;
4821 -> 4806;
4821 -> 1566;
4821 -> 1563;
4822 -> 1683;
4823 -> 4822;
4823 -> 1578;
4824 -> 4823;
4824 -> 1580;
4824 -> 1578;
4825 -> 1576;
4825 -> 1610;
4825 -> 1679;
4825 -> 4824;
4825 -> 1688;
4825 -> 1604;
4825 -> 1605;
4825 -> 4810;
4825 -> 1612;
4825 -> 1609;
4826 -> 1624;
4827 -> 4826;
4827 -> 1445;
4828 -> 4827;
4828 -> 1447;
4828 -> 1445;
4829 -> 1643;
4830 -> 4829;
4830 -> 1483;
4831 -> 4830;
4831 -> 1485;
4831 -> 1483;
4832 -> 1481;
4832 -> 1513;
4832 -> 1639;
4832 -> 4831;
4832 -> 1648;
4832 -> 1509;
4832 -> 1510;
4832 -> 4817;
4832 -> 1520;
4832 -> 1512;
4833 -> 1663;
4834 -> 4833;
4834 -> 1532;
4835 -> 4834;
4835 -> 1534;
4835 -> 1532;
4836 -> 1530;
4836 -> 1564;
4836 -> 1659;
4836 -> 4835;
4836 -> 1668;
4836 -> 1558;
4836 -> 1559;
4836 -> 4821;
4836 -> 1566;
4836 -> 1563;
4837 -> 1683;
4838 -> 4837;
4838 -> 1578;
4839 -> 4838;
4839 -> 1580;
4839 -> 1578;
4840 -> 1576;
4840 -> 1610;
4840 -> 1679;
4840 -> 4839;
4840 -> 1688;
4840 -> 1604;
4840 -> 1605;
4840 -> 4825;
4840 -> 1612;
4840 -> 1609;
4841 -> 1416;
4841 -> 1415;
4842 -> 1417;
4842 -> 1415;
4843 -> 1418;
4843 -> 1415;
4844 -> 1419;
4844 -> 1415;
4845 -> 1420;
4845 -> 1415;
4846 -> 1415;
4847 -> 4841;
4847 -> 4846;
4848 -> 4842;
4848 -> 4846;
4849 -> 4843;
4849 -> 4846;
4850 -> 4844;
4850 -> 4846;
4851 -> 4845;
4851 -> 4846;
4852 -> 4847;
4852 -> 0;
4852 -> 4846;
4854 -> 4847;
4854 -> 4846;
4855 -> 4849;
4855 -> 4846;
4856 -> 4850;
4856 -> 4846;
4857 -> 4848;
4857 -> 4846;
4858 -> 4851;
4858 -> 4846;
4859 -> 4846;
4860 -> 4846;
4861 -> 4854;
4861 -> 4860;
4862 -> 4855;
4862 -> 4860;
4863 -> 4856;
4863 -> 4860;
4864 -> 4857;
4864 -> 4860;
4865 -> 4858;
4865 -> 4860;
4866 -> 4859;
4866 -> 4860;
4868 -> 4861;
4868 -> 4860;
4869 -> 4862;
4869 -> 4860;
4870 -> 4863;
4870 -> 4860;
4871 -> 4860;
4872 -> 4868;
4872 -> 4871;
4873 -> 4869;
4873 -> 4871;
4874 -> 4870;
4874 -> 4871;
4875 -> 4866;
4875 -> 4871;
4877 -> 4873;
4877 -> 4871;
4878 -> 4871;
4879 -> 4877;
4879 -> 4878;
4880 -> 4875;
4880 -> 4878;
4881 -> 0;
4881 -> 4878;
4882 -> 4879;
4882 -> 4878;
4883 -> 4878;
4884 -> 4881;
4884 -> 4883;
4885 -> 4882;
4885 -> 4883;
4886 -> 4880;
4886 -> 4883;
4887 -> 4884;
4887 -> 4883;
4888 -> 4885;
4888 -> 4883;
4889 -> 4883;
4890 -> 4887;
4890 -> 4889;
4891 -> 4888;
4891 -> 4889;
4892 -> 4886;
4892 -> 4889;
4893 -> 4890;
4893 -> 4889;
4894 -> 4891;
4894 -> 4889;
4895 -> 4889;
4896 -> 4895;
4896 -> 4893;
4896 -> 4894;
4896 -> 4889;
4897 -> 4895;
4897 -> 4889;
4898 -> 4897;
4898 -> 4896;
4898 -> 4889;
4899 -> 4886;
4899 -> 4898;
4899 -> 0;
4899 -> 4883;
4900 -> 4899;
4900 -> 4886;
4900 -> 4883;
4901 -> 4880;
4901 -> 4878;
4902 -> 4879;
4902 -> 4880;
4902 -> 4878;
4903 -> 4875;
4903 -> 4871;
4904 -> 4875;
4904 -> 4871;
4905 -> 4872;
4905 -> 4875;
4905 -> 4871;
4906 -> 4874;
4906 -> 4875;
4906 -> 4871;
4907 -> 4866;
4907 -> 4860;
4908 -> 4866;
4908 -> 4860;
4909 -> 4860;
4910 -> 4864;
4910 -> 4909;
4910 -> 4860;
4911 -> 4860;
4912 -> 4865;
4912 -> 4911;
4912 -> 4860;
4913 -> 4865;
4913 -> 4912;
4914 -> 4866;
4914 -> 4913;
4914 -> 4898;
4914 -> 4900;
4914 -> 4901;
4914 -> 4902;
4914 -> 4903;
4914 -> 4905;
4914 -> 4904;
4914 -> 4906;
4914 -> 4907;
4914 -> 4908;
4914 -> 1408;
4914 -> 4912;
4915 -> 4865;
4915 -> 4866;
4915 -> 4912;
4916 -> 4859;
4916 -> 1415;
4917 -> 4916;
4917 -> 1411;
4918 -> 1398;
4919 -> 1402;
4919 -> 4918;
4919 -> 1398;
4920 -> 4917;
4920 -> 1398;
4921 -> 4920;
4921 -> 1159;
4922 -> 1159;
4923 -> 4921;
4923 -> 4922;
4924 -> 1148;
4924 -> 4922;
4925 -> 4922;
4926 -> 4923;
4926 -> 4925;
4926 -> 4922;
4927 -> 4924;
4927 -> 1119;
4927 -> 1155;
4927 -> 1154;
4927 -> 4922;
4928 -> 4924;
4928 -> 1155;
4928 -> 1154;
4928 -> 1119;
4928 -> 4922;
4929 -> 4923;
4929 -> 4928;
4929 -> 4922;
4930 -> 4924;
4930 -> 1119;
4930 -> 4922;
4931 -> 1159;
4932 -> 1159;
4933 -> 4920;
4933 -> 4932;
4934 -> 4933;
4934 -> 4914;
4934 -> 4932;
4935 -> 4934;
4935 -> 1159;
4936 -> 1163;
4936 -> 4914;
4936 -> 4915;
4936 -> 1165;
4937 -> 4914;
4938 -> 4936;
4938 -> 4914;
4939 -> 4938;
4939 -> 4936;
4939 -> 4914;
4940 -> 4936;
4940 -> 4914;
4941 -> 4936;
4941 -> 4914;
4942 -> 4936;
4942 -> 4914;
4943 -> 4936;
4943 -> 4914;
4944 -> 4936;
4944 -> 4914;
4945 -> 4936;
4945 -> 4914;
4946 -> 4940;
4946 -> 4914;
4947 -> 4941;
4947 -> 4914;
4948 -> 4942;
4948 -> 4914;
4949 -> 4943;
4949 -> 4914;
4950 -> 4945;
4950 -> 4939;
4950 -> 4946;
4950 -> 4947;
4950 -> 4948;
4950 -> 4949;
4950 -> 4914;
4951 -> 4914;
4952 -> 4950;
4952 -> 4951;
4952 -> 4914;
4953 -> 4944;
4953 -> 4950;
4953 -> 4952;
4954 -> 4952;
4955 -> 4953;
4955 -> 4954;
4956 -> 4954;
4957 -> 4955;
4957 -> 4953;
4957 -> 4956;
4958 -> 4957;
4958 -> 4954;
4959 -> 4954;
4960 -> 4955;
4960 -> 4953;
4960 -> 4959;
4961 -> 4960;
4961 -> 4954;
4962 -> 4954;
4963 -> 4961;
4963 -> 4962;
4964 -> 4955;
4964 -> 4953;
4964 -> 4962;
4965 -> 4954;
4966 -> 4954;
4967 -> 4955;
4967 -> 4966;
4968 -> 4967;
4968 -> 4953;
4968 -> 4963;
4968 -> 4966;
4969 -> 4966;
4970 -> 4967;
4970 -> 4968;
4970 -> 4969;
4971 -> 4970;
4971 -> 4966;
4972 -> 4966;
4973 -> 4972;
4973 -> 4966;
4974 -> 4966;
4975 -> 4966;
4976 -> 4968;
4976 -> 4966;
4977 -> 4968;
4978 -> 4968;
4978 -> 4966;
4979 -> 4972;
4979 -> 4978;
4980 -> 4979;
4981 -> 4967;
4981 -> 4980;
4982 -> 4980;
4983 -> 4981;
4983 -> 4968;
4983 -> 4982;
4984 -> 4983;
4984 -> 4980;
4985 -> 4980;
4986 -> 4981;
4986 -> 4968;
4986 -> 4985;
4987 -> 4986;
4987 -> 4980;
4988 -> 4980;
4989 -> 4984;
4989 -> 4988;
4989 -> 4980;
4990 -> 4987;
4990 -> 4989;
4990 -> 4968;
4990 -> 4967;
4990 -> 4980;
4991 -> 4980;
4992 -> 4990;
4992 -> 4991;
4993 -> 4991;
4994 -> 4992;
4994 -> 4993;
4994 -> 4991;
4995 -> 4980;
4996 -> 4995;
4996 -> 4979;
4997 -> 4978;
4998 -> 4966;
4999 -> 4990;
4999 -> 4966;
5000 -> 4990;
5000 -> 4966;
5001 -> 4966;
5002 -> 5000;
5002 -> 5001;
5003 -> 5001;
5004 -> 5001;
5005 -> 5002;
5005 -> 5004;
5005 -> 5001;
5006 -> 5005;
5007 -> 5003;
5007 -> 5001;
5008 -> 5007;
5008 -> 4966;
5009 -> 4966;
5010 -> 5008;
5010 -> 5009;
5011 -> 4967;
5011 -> 5009;
5012 -> 5009;
5013 -> 5011;
5013 -> 4990;
5013 -> 5012;
5013 -> 5009;
5014 -> 5013;
5015 -> 5014;
5015 -> 4966;
5016 -> 4966;
5017 -> 4990;
5018 -> 4967;
5018 -> 4990;
5019 -> 4990;
5020 -> 5018;
5020 -> 5019;
5021 -> 5019;
5022 -> 5020;
5022 -> 4990;
5022 -> 5021;
5022 -> 5019;
5023 -> 5022;
5023 -> 4990;
5024 -> 4990;
5025 -> 4990;
5026 -> 4990;
5027 -> 5015;
5027 -> 4966;
5028 -> 4967;
5028 -> 4966;
5029 -> 4990;
5029 -> 0;
5029 -> 4966;
5030 -> 4966;
5031 -> 4990;
5032 -> 4990;
5033 -> 5031;
5033 -> 5032;
5034 -> 5033;
5034 -> 0;
5034 -> 5032;
5035 -> 4990;
5036 -> 4990;
5037 -> 5035;
5037 -> 5036;
5038 -> 5035;
5038 -> 5036;
5039 -> 5035;
5039 -> 5036;
5040 -> 5038;
5040 -> 5036;
5041 -> 5037;
5041 -> 5036;
5042 -> 5039;
5042 -> 5036;
5043 -> 5036;
5044 -> 5040;
5044 -> 5043;
5045 -> 5041;
5045 -> 5043;
5046 -> 5042;
5046 -> 5043;
5047 -> 5044;
5047 -> 1422;
5047 -> 5043;
5048 -> 5043;
5049 -> 5045;
5049 -> 5048;
5049 -> 5043;
5050 -> 5049;
5051 -> 5046;
5051 -> 5050;
5051 -> 5049;
5052 -> 5046;
5052 -> 413;
5052 -> 5051;
5053 -> 1434;
5053 -> 1433;
5053 -> 5044;
5053 -> 5052;
5054 -> 4966;
5055 -> 5027;
5055 -> 5054;
5055 -> 4966;
5056 -> 5053;
5056 -> 4966;
5057 -> 5056;
5057 -> 4954;
5058 -> 4958;
5058 -> 5057;
5058 -> 4954;
5059 -> 5057;
5059 -> 4954;
5060 -> 4940;
5060 -> 4952;
5061 -> 4941;
5061 -> 4952;
5062 -> 4942;
5062 -> 4952;
5063 -> 4943;
5063 -> 4952;
5064 -> 5059;
5064 -> 4952;
5065 -> 5059;
5065 -> 4914;
5066 -> 4936;
5066 -> 5065;
5066 -> 5064;
5066 -> 4914;
5067 -> 5066;
5067 -> 1159;
5068 -> 5067;
5068 -> 4922;
5069 -> 5068;
5069 -> 4925;
5069 -> 4922;
5070 -> 4924;
5070 -> 4930;
5070 -> 1155;
5070 -> 1154;
5070 -> 4922;
5071 -> 4924;
5071 -> 1155;
5071 -> 1154;
5071 -> 4930;
5071 -> 4922;
5072 -> 5068;
5072 -> 5071;
5072 -> 4922;
5073 -> 5066;
5073 -> 4932;
5074 -> 5073;
5074 -> 5066;
5074 -> 4932;
5075 -> 5074;
5075 -> 1159;
5076 -> 5066;
5077 -> 5066;
5078 -> 5077;
5078 -> 5066;
5079 -> 5066;
5080 -> 5079;
5080 -> 5066;
5081 -> 5079;
5081 -> 5066;
5082 -> 5066;
5083 -> 5066;
5084 -> 5066;
5085 -> 5066;
5086 -> 5066;
5087 -> 5079;
5088 -> 5079;
5089 -> 5079;
5089 -> 1059;
5090 -> 0;
5090 -> 5079;
5091 -> 5090;
5092 -> 5079;
5092 -> 5090;
5092 -> 0;
5093 -> 5079;
5093 -> 5066;
5094 -> 5066;
5095 -> 5093;
5095 -> 5094;
5096 -> 5094;
5097 -> 5094;
5098 -> 5095;
5098 -> 5097;
5098 -> 5094;
5099 -> 5098;
5100 -> 5099;
5100 -> 5095;
5100 -> 5090;
5100 -> 5098;
5101 -> 5096;
5101 -> 5094;
5102 -> 5101;
5102 -> 5066;
5103 -> 5066;
5104 -> 5102;
5104 -> 5103;
5105 -> 5066;
5105 -> 5103;
5106 -> 5103;
5107 -> 5105;
5107 -> 5090;
5107 -> 5106;
5107 -> 5103;
5108 -> 5107;
5109 -> 5108;
5109 -> 5066;
5110 -> 5066;
5111 -> 5090;
5111 -> 5066;
5112 -> 5090;
5113 -> 5066;
5113 -> 5090;
5114 -> 5090;
5115 -> 5113;
5115 -> 5114;
5116 -> 5114;
5117 -> 5115;
5117 -> 5090;
5117 -> 5116;
5117 -> 5114;
5118 -> 5117;
5118 -> 5090;
5119 -> 5090;
5120 -> 5090;
5121 -> 5090;
5122 -> 5109;
5122 -> 5066;
5123 -> 5066;
5124 -> 5090;
5124 -> 0;
5124 -> 5066;
5125 -> 5066;
5126 -> 5090;
5127 -> 5090;
5128 -> 5126;
5128 -> 5127;
5129 -> 5128;
5129 -> 0;
5129 -> 5127;
5130 -> 5090;
5130 -> 1422;
5131 -> 5066;
5132 -> 5122;
5132 -> 5131;
5132 -> 5066;
5133 -> 5078;
5133 -> 5090;
5133 -> 5066;
5134 -> 5090;
5134 -> 1159;
5135 -> 5134;
5135 -> 4922;
5136 -> 5135;
5136 -> 4925;
5136 -> 4922;
5137 -> 5135;
5137 -> 5071;
5137 -> 4922;
5138 -> 5090;
5138 -> 4932;
5139 -> 5138;
5139 -> 5090;
5139 -> 4932;
5140 -> 5139;
5140 -> 1159;
5141 -> 5090;
5142 -> 5090;
5143 -> 5142;
5143 -> 5090;
5144 -> 5090;
5145 -> 5090;
5146 -> 5090;
5147 -> 5090;
5148 -> 5090;
5149 -> 5090;
5150 -> 5148;
5150 -> 5149;
5151 -> 5149;
5152 -> 5149;
5153 -> 5150;
5153 -> 5152;
5153 -> 5149;
5154 -> 5153;
5155 -> 5151;
5155 -> 5149;
5156 -> 5155;
5156 -> 5090;
5157 -> 5090;
5158 -> 5156;
5158 -> 5157;
5159 -> 5090;
5159 -> 5157;
5160 -> 5157;
5161 -> 5159;
5161 -> 5090;
5161 -> 5160;
5161 -> 5157;
5162 -> 5161;
5163 -> 5162;
5163 -> 5090;
5164 -> 5163;
5164 -> 5090;
5165 -> 5090;
5166 -> 5090;
5166 -> 0;
5167 -> 5090;
5168 -> 1426;
5168 -> 1425;
5168 -> 5090;
5169 -> 5090;
5170 -> 5164;
5170 -> 5169;
5170 -> 5090;
5171 -> 5143;
5171 -> 5168;
5171 -> 5090;
5172 -> 5168;
5172 -> 1159;
5173 -> 5172;
5173 -> 4922;
5174 -> 5173;
5174 -> 4925;
5174 -> 4922;
5175 -> 5173;
5175 -> 5071;
5175 -> 4922;
5176 -> 5168;
5176 -> 4932;
5177 -> 5176;
5177 -> 5168;
5177 -> 4932;
5178 -> 5177;
5178 -> 1159;
5179 -> 5168;
5180 -> 5168;
5181 -> 5180;
5181 -> 5168;
5182 -> 5168;
5183 -> 5168;
5184 -> 5168;
5185 -> 5168;
5186 -> 5168;
5187 -> 5168;
5188 -> 5168;
5189 -> 5168;
5190 -> 5168;
5190 -> 1059;
5191 -> 0;
5191 -> 5168;
5192 -> 5191;
5193 -> 5168;
5193 -> 5191;
5193 -> 0;
5194 -> 5168;
5195 -> 5168;
5196 -> 5194;
5196 -> 5195;
5197 -> 5195;
5198 -> 5195;
5199 -> 5196;
5199 -> 5198;
5199 -> 5195;
5200 -> 5199;
5201 -> 5200;
5201 -> 5196;
5201 -> 5191;
5201 -> 5199;
5202 -> 5197;
5202 -> 5195;
5203 -> 5202;
5203 -> 5168;
5204 -> 5168;
5205 -> 5203;
5205 -> 5204;
5206 -> 5168;
5206 -> 5204;
5207 -> 5204;
5208 -> 5206;
5208 -> 5191;
5208 -> 5207;
5208 -> 5204;
5209 -> 5208;
5210 -> 5209;
5210 -> 5168;
5211 -> 5191;
5211 -> 5168;
5212 -> 5191;
5213 -> 5191;
5214 -> 5210;
5214 -> 5168;
5215 -> 5168;
5216 -> 5191;
5216 -> 0;
5216 -> 5168;
5217 -> 5168;
5218 -> 5191;
5219 -> 5191;
5220 -> 5218;
5220 -> 5219;
5221 -> 5220;
5221 -> 0;
5221 -> 5219;
5222 -> 5191;
5222 -> 1422;
5223 -> 5168;
5224 -> 5214;
5224 -> 5223;
5224 -> 5168;
5225 -> 5181;
5225 -> 5191;
5225 -> 5168;
5226 -> 5191;
5226 -> 1159;
5227 -> 5226;
5227 -> 4922;
5228 -> 5227;
5228 -> 4925;
5228 -> 4922;
5229 -> 5227;
5229 -> 5071;
5229 -> 4922;
5230 -> 5191;
5230 -> 4932;
5231 -> 5230;
5231 -> 5191;
5231 -> 4932;
5232 -> 5231;
5232 -> 1159;
5233 -> 5191;
5234 -> 5191;
5235 -> 5234;
5235 -> 5191;
5236 -> 5191;
5237 -> 5191;
5238 -> 5191;
5239 -> 5191;
5240 -> 5191;
5241 -> 5191;
5242 -> 5191;
5243 -> 5241;
5243 -> 5242;
5244 -> 5242;
5245 -> 5242;
5246 -> 5243;
5246 -> 5245;
5246 -> 5242;
5247 -> 5246;
5248 -> 5244;
5248 -> 5242;
5249 -> 5248;
5249 -> 5191;
5250 -> 5191;
5251 -> 5249;
5251 -> 5250;
5252 -> 5191;
5252 -> 5250;
5253 -> 5250;
5254 -> 5252;
5254 -> 5191;
5254 -> 5253;
5254 -> 5250;
5255 -> 5254;
5256 -> 5255;
5256 -> 5191;
5257 -> 5191;
5258 -> 5191;
5259 -> 5257;
5259 -> 5258;
5260 -> 5258;
5261 -> 5259;
5261 -> 5234;
5261 -> 5260;
5261 -> 5258;
5262 -> 5261;
5262 -> 5191;
5263 -> 5191;
5264 -> 5234;
5264 -> 5263;
5264 -> 5191;
5265 -> 5234;
5265 -> 5191;
5266 -> 5234;
5267 -> 5234;
5268 -> 5256;
5268 -> 5191;
5269 -> 5191;
5270 -> 5191;
5270 -> 0;
5271 -> 5191;
5272 -> 5234;
5272 -> 1422;
5272 -> 5191;
5273 -> 5191;
5274 -> 5268;
5274 -> 5273;
5274 -> 5191;
5275 -> 5235;
5275 -> 5234;
5275 -> 5191;
5276 -> 5234;
5276 -> 1159;
5277 -> 5276;
5277 -> 4922;
5278 -> 5277;
5278 -> 4925;
5278 -> 4922;
5279 -> 5277;
5279 -> 5071;
5279 -> 4922;
5280 -> 5234;
5280 -> 4932;
5281 -> 5280;
5281 -> 5234;
5281 -> 4932;
5282 -> 5281;
5282 -> 1159;
5283 -> 5234;
5284 -> 5234;
5285 -> 5234;
5286 -> 5234;
5287 -> 5234;
5288 -> 5234;
5289 -> 5234;
5290 -> 5234;
5291 -> 5234;
5292 -> 5290;
5292 -> 5291;
5293 -> 5291;
5294 -> 5291;
5295 -> 5292;
5295 -> 5294;
5295 -> 5291;
5296 -> 5295;
5297 -> 5293;
5297 -> 5291;
5298 -> 5297;
5298 -> 5234;
5299 -> 5234;
5300 -> 5298;
5300 -> 5299;
5301 -> 5234;
5301 -> 5299;
5302 -> 5299;
5303 -> 5301;
5303 -> 5234;
5303 -> 5302;
5303 -> 5299;
5304 -> 5303;
5305 -> 5304;
5305 -> 5234;
5306 -> 5305;
5306 -> 5234;
5307 -> 5234;
5308 -> 5234;
5308 -> 0;
5309 -> 5234;
5310 -> 5234;
5311 -> 5234;
5312 -> 5310;
5312 -> 5311;
5313 -> 5312;
5313 -> 0;
5313 -> 5311;
5314 -> 5234;
5314 -> 1422;
5315 -> 5234;
5316 -> 5306;
5316 -> 5315;
5316 -> 5234;
5317 -> 5284;
5317 -> 5234;
5318 -> 5234;
5319 -> 5234;
5320 -> 5318;
5320 -> 5319;
5321 -> 5319;
5322 -> 5320;
5322 -> 5234;
5322 -> 5321;
5322 -> 5319;
5323 -> 5322;
5323 -> 5234;
5324 -> 5234;
5325 -> 5234;
5326 -> 5325;
5326 -> 5234;
5327 -> 5326;
5328 -> 5327;
5328 -> 5234;
5329 -> 997;
5329 -> 5328;
5330 -> 5329;
5331 -> 5329;
5331 -> 5330;
5332 -> 5330;
5333 -> 5331;
5333 -> 5332;
5334 -> 5332;
5335 -> 5333;
5335 -> 5334;
5335 -> 5332;
5336 -> 5333;
5336 -> 5332;
5337 -> 5329;
5337 -> 5335;
5338 -> 5335;
5339 -> 5337;
5339 -> 5338;
5340 -> 5338;
5341 -> 5339;
5341 -> 5340;
5341 -> 5338;
5342 -> 5329;
5343 -> 5280;
5343 -> 4932;
5344 -> 5343;
5344 -> 1159;
5345 -> 5325;
5345 -> 5234;
5346 -> 5325;
5346 -> 5234;
5347 -> 5325;
5348 -> 5325;
5349 -> 5348;
5350 -> 5349;
5350 -> 5325;
5351 -> 997;
5351 -> 5350;
5352 -> 5325;
5353 -> 5352;
5353 -> 5351;
5353 -> 5325;
5354 -> 5325;
5355 -> 5352;
5355 -> 5354;
5356 -> 5355;
5356 -> 5351;
5356 -> 5354;
5357 -> 5356;
5357 -> 5325;
5358 -> 0;
5360 -> 5358;
5360 -> 5359;
5361 -> 5359;
5362 -> 5360;
5362 -> 5361;
5362 -> 5359;
5363 -> 5359;
5366 -> 5364;
5366 -> 5365;
5367 -> 5365;
5368 -> 5366;
5368 -> 5367;
5368 -> 5365;
5369 -> 5365;
5370 -> 5325;
5371 -> 5370;
5371 -> 5357;
5371 -> 5325;
5372 -> 5325;
5373 -> 5371;
5373 -> 5372;
5374 -> 5373;
5374 -> 5372;
5375 -> 5372;
5376 -> 5374;
5376 -> 5375;
5376 -> 5372;
5377 -> 5374;
5377 -> 5372;
5378 -> 5325;
5379 -> 5377;
5379 -> 5378;
5379 -> 5325;
5380 -> 5325;
5381 -> 5380;
5381 -> 5379;
5381 -> 5325;
5382 -> 5325;
5383 -> 5381;
5383 -> 5382;
5384 -> 5382;
5385 -> 5383;
5385 -> 5384;
5385 -> 5382;
5386 -> 5325;
5387 -> 5383;
5387 -> 5386;
5387 -> 5325;
5388 -> 5325;
5388 -> 5234;
5389 -> 5388;
5389 -> 5291;
5390 -> 5389;
5390 -> 5294;
5390 -> 5291;
5391 -> 5390;
5392 -> 5391;
5392 -> 5389;
5392 -> 5387;
5392 -> 5390;
5393 -> 5301;
5393 -> 5387;
5393 -> 5302;
5393 -> 5299;
5394 -> 5393;
5395 -> 5394;
5395 -> 5234;
5396 -> 5387;
5397 -> 5387;
5397 -> 5396;
5398 -> 5396;
5399 -> 5397;
5399 -> 5398;
5400 -> 5398;
5401 -> 5399;
5401 -> 5400;
5401 -> 5398;
5402 -> 5399;
5402 -> 5398;
5403 -> 5387;
5403 -> 5401;
5404 -> 5401;
5405 -> 5403;
5405 -> 5404;
5406 -> 5404;
5407 -> 5405;
5407 -> 5406;
5407 -> 5404;
5408 -> 5387;
5409 -> 5395;
5409 -> 5234;
5410 -> 5387;
5410 -> 0;
5410 -> 5234;
5411 -> 5387;
5412 -> 5387;
5413 -> 5411;
5413 -> 5412;
5414 -> 5411;
5414 -> 5412;
5415 -> 5411;
5415 -> 5412;
5416 -> 5414;
5416 -> 1422;
5416 -> 5412;
5417 -> 5409;
5417 -> 5315;
5417 -> 5234;
5418 -> 5414;
5418 -> 1159;
5419 -> 5418;
5419 -> 4922;
5420 -> 5419;
5420 -> 4925;
5420 -> 4922;
5421 -> 5419;
5421 -> 5071;
5421 -> 4922;
5422 -> 5414;
5422 -> 4932;
5423 -> 5422;
5423 -> 4932;
5424 -> 5423;
5424 -> 1159;
5425 -> 1146;
5426 -> 1083;
5427 -> 5426;
5427 -> 1089;
5427 -> 1083;
5428 -> 1089;
5428 -> 1083;
5429 -> 1089;
5429 -> 1083;
5430 -> 1089;
5430 -> 1083;
5431 -> 1089;
5431 -> 1083;
5432 -> 1089;
5432 -> 1083;
5433 -> 1089;
5433 -> 1083;
5434 -> 1083;
5435 -> 5434;
5435 -> 1089;
5435 -> 1083;
5436 -> 1089;
5436 -> 5435;
5436 -> 1083;
5437 -> 1083;
5438 -> 5437;
5438 -> 1089;
5438 -> 1083;
5439 -> 1082;
5439 -> 894;
5440 -> 894;
5441 -> 5439;
5441 -> 5440;
5442 -> 5441;
5442 -> 5440;
5443 -> 0;
5443 -> 5440;
5444 -> 5440;
5445 -> 5442;
5445 -> 5444;
5446 -> 5443;
5446 -> 5444;
5447 -> 5441;
5447 -> 5444;
5448 -> 5444;
5449 -> 5447;
5449 -> 5430;
5449 -> 5448;
5449 -> 5444;
5450 -> 5445;
5450 -> 5442;
5450 -> 1123;
5450 -> 1131;
5450 -> 1125;
5450 -> 1124;
5450 -> 1114;
5450 -> 1155;
5450 -> 1116;
5450 -> 1117;
5450 -> 1118;
5450 -> 4930;
5450 -> 1120;
5450 -> 1121;
5450 -> 1122;
5450 -> 1126;
5450 -> 1128;
5450 -> 1138;
5450 -> 5427;
5450 -> 5435;
5450 -> 5438;
5450 -> 5430;
5450 -> 5431;
5450 -> 5432;
5450 -> 5433;
5450 -> 5387;
5450 -> 1082;
5450 -> 1127;
5450 -> 1137;
5450 -> 1154;
5450 -> 5426;
5450 -> 5436;
5450 -> 5444;
5451 -> 5444;
5452 -> 5450;
5452 -> 5451;
5453 -> 5451;
5454 -> 5452;
5454 -> 5453;
5455 -> 5454;
5455 -> 5450;
5455 -> 5453;
5456 -> 5454;
5456 -> 5455;
5456 -> 5453;
5457 -> 5454;
5457 -> 5455;
5457 -> 0;
5457 -> 5453;
5458 -> 5457;
5458 -> 5454;
5458 -> 5453;
5459 -> 5453;
5460 -> 5454;
5460 -> 5459;
5461 -> 5459;
5462 -> 5460;
5462 -> 5461;
5463 -> 5461;
5464 -> 5462;
5464 -> 5463;
5465 -> 5464;
5465 -> 5455;
5465 -> 5463;
5466 -> 5463;
5467 -> 5464;
5467 -> 5455;
5467 -> 5466;
5467 -> 5463;
5468 -> 5464;
5468 -> 5455;
5468 -> 5458;
5468 -> 5467;
5469 -> 5468;
5469 -> 5461;
5470 -> 5469;
5470 -> 5462;
5470 -> 5461;
5471 -> 5470;
5471 -> 5459;
5472 -> 5459;
5473 -> 5471;
5473 -> 5472;
5474 -> 5473;
5474 -> 5455;
5474 -> 5472;
5475 -> 5474;
5475 -> 5453;
5476 -> 5456;
5476 -> 5454;
5476 -> 5453;
5477 -> 5455;
5477 -> 5458;
5477 -> 5476;
5477 -> 5470;
5477 -> 5453;
5478 -> 5455;
5478 -> 5453;
5479 -> 5454;
5479 -> 5477;
5479 -> 5478;
5479 -> 5453;
5480 -> 5451;
5481 -> 5480;
5481 -> 5451;
5482 -> 5451;
5483 -> 5477;
5483 -> 5482;
5484 -> 5481;
5484 -> 5482;
5485 -> 5452;
5485 -> 5482;
5486 -> 5483;
5486 -> 5482;
5487 -> 5484;
5487 -> 5482;
5488 -> 5482;
5489 -> 5486;
5489 -> 5488;
5490 -> 5487;
5490 -> 5488;
5491 -> 5485;
5491 -> 5488;
5492 -> 5488;
5493 -> 5491;
5493 -> 5492;
5494 -> 5492;
5495 -> 5493;
5495 -> 5494;
5496 -> 5495;
5496 -> 5479;
5496 -> 5494;
5497 -> 5496;
5497 -> 5492;
5498 -> 5497;
5499 -> 5498;
5499 -> 5488;
5500 -> 5499;
5500 -> 5482;
5501 -> 5482;
5502 -> 5485;
5502 -> 5501;
5503 -> 5501;
5504 -> 5502;
5504 -> 5503;
5505 -> 5503;
5506 -> 5504;
5506 -> 5505;
5507 -> 5506;
5507 -> 5479;
5507 -> 5505;
5508 -> 5507;
5508 -> 5503;
5509 -> 5503;
5510 -> 5504;
5510 -> 5479;
5510 -> 5509;
5510 -> 5503;
5511 -> 5508;
5511 -> 5504;
5511 -> 5510;
5512 -> 5504;
5512 -> 5479;
5512 -> 5503;
5513 -> 5504;
5513 -> 5479;
5513 -> 5512;
5513 -> 5503;
5514 -> 5504;
5514 -> 5479;
5514 -> 5503;
5515 -> 5508;
5515 -> 5503;
5516 -> 5513;
5516 -> 5514;
5516 -> 5515;
5516 -> 5479;
5516 -> 5511;
5516 -> 5512;
5516 -> 5503;
5517 -> 5516;
5517 -> 5501;
5518 -> 5502;
5518 -> 5516;
5518 -> 5501;
5519 -> 5501;
5520 -> 5501;
5521 -> 5517;
5521 -> 5520;
5522 -> 5518;
5522 -> 5520;
5523 -> 5518;
5523 -> 5520;
5524 -> 5518;
5524 -> 5520;
5525 -> 5518;
5525 -> 5520;
5526 -> 5519;
5526 -> 5520;
5527 -> 5521;
5527 -> 5526;
5527 -> 5520;
5528 -> 5522;
5528 -> 5526;
5528 -> 5520;
5529 -> 5523;
5529 -> 5526;
5529 -> 5520;
5530 -> 5524;
5530 -> 5526;
5530 -> 5520;
5531 -> 5525;
5531 -> 5526;
5531 -> 5520;
5532 -> 5519;
5532 -> 5482;
5533 -> 5485;
5533 -> 5516;
5533 -> 5482;
5534 -> 5485;
5534 -> 5516;
5534 -> 5533;
5534 -> 5482;
5535 -> 5482;
5536 -> 5482;
5537 -> 5485;
5537 -> 5536;
5538 -> 5537;
5538 -> 5516;
5538 -> 5536;
5539 -> 5538;
5539 -> 5482;
5540 -> 5482;
5541 -> 5539;
5541 -> 5540;
5542 -> 5541;
5542 -> 5516;
5542 -> 5540;
5543 -> 5483;
5543 -> 5542;
5544 -> 5484;
5544 -> 5542;
5545 -> 5542;
5546 -> 5543;
5546 -> 5545;
5547 -> 5544;
5547 -> 5545;
5548 -> 5485;
5548 -> 5545;
5549 -> 5545;
5550 -> 5548;
5550 -> 5549;
5551 -> 5550;
5551 -> 5545;
5552 -> 5545;
5553 -> 5551;
5553 -> 5552;
5554 -> 5553;
5554 -> 5516;
5554 -> 5552;
5555 -> 5554;
5556 -> 5548;
5556 -> 5555;
5557 -> 5555;
5558 -> 5556;
5558 -> 5557;
5559 -> 5555;
5560 -> 5558;
5560 -> 5559;
5561 -> 5560;
5561 -> 0;
5561 -> 5555;
5562 -> 5561;
5562 -> 5555;
5563 -> 5562;
5563 -> 5554;
5564 -> 5563;
5565 -> 5548;
5565 -> 5564;
5566 -> 5564;
5567 -> 5564;
5568 -> 5566;
5568 -> 5567;
5569 -> 5565;
5569 -> 5567;
5570 -> 5567;
5571 -> 5568;
5571 -> 5570;
5571 -> 5567;
5572 -> 5569;
5572 -> 5516;
5572 -> 5568;
5572 -> 5567;
5573 -> 5567;
5574 -> 5569;
5574 -> 5516;
5574 -> 5573;
5574 -> 5567;
5575 -> 5569;
5575 -> 5516;
5575 -> 5568;
5575 -> 5574;
5576 -> 5569;
5576 -> 5516;
5576 -> 5533;
5576 -> 5575;
5576 -> 5574;
5577 -> 5564;
5578 -> 5576;
5578 -> 5577;
5579 -> 5578;
5579 -> 5563;
5580 -> 5579;
5581 -> 5548;
5581 -> 5580;
5582 -> 5580;
5583 -> 5581;
5583 -> 5582;
5584 -> 5583;
5584 -> 5580;
5585 -> 5580;
5586 -> 5584;
5586 -> 5585;
5587 -> 5586;
5587 -> 5579;
5588 -> 5587;
5589 -> 5548;
5589 -> 5588;
5590 -> 5588;
5591 -> 5589;
5591 -> 5590;
5592 -> 5590;
5593 -> 5591;
5593 -> 5592;
5594 -> 5592;
5595 -> 5593;
5595 -> 5516;
5595 -> 5594;
5596 -> 5595;
5596 -> 5516;
5596 -> 5594;
5597 -> 5596;
5597 -> 5592;
5598 -> 5597;
5598 -> 5590;
5599 -> 5598;
5599 -> 5588;
5600 -> 5588;
5601 -> 5589;
5601 -> 5600;
5602 -> 5601;
5602 -> 5516;
5602 -> 5533;
5602 -> 5600;
5603 -> 5602;
5603 -> 5588;
5604 -> 5599;
5604 -> 5603;
5604 -> 5588;
5605 -> 5604;
5605 -> 5587;
5606 -> 5605;
5607 -> 5547;
5607 -> 5605;
5608 -> 5605;
5609 -> 5606;
5609 -> 5608;
5610 -> 5607;
5610 -> 5608;
5611 -> 5548;
5611 -> 5608;
5612 -> 5608;
5613 -> 5611;
5613 -> 5612;
5614 -> 5613;
5614 -> 5608;
5615 -> 5608;
5616 -> 5614;
5616 -> 5615;
5617 -> 5608;
5618 -> 5617;
5618 -> 5605;
5619 -> 5545;
5620 -> 5619;
5620 -> 5542;
5621 -> 5542;
5622 -> 5620;
5622 -> 5621;
5622 -> 5542;
5623 -> 5483;
5623 -> 5482;
5624 -> 5484;
5624 -> 5482;
5625 -> 5532;
5625 -> 5482;
5626 -> 5482;
5627 -> 5623;
5627 -> 5626;
5628 -> 5624;
5628 -> 5626;
5629 -> 5625;
5629 -> 5626;
5630 -> 5485;
5630 -> 5626;
5631 -> 5628;
5631 -> 5626;
5632 -> 5631;
5632 -> 5626;
5633 -> 5626;
5634 -> 5632;
5634 -> 5633;
5635 -> 5630;
5635 -> 5633;
5636 -> 5633;
5637 -> 5635;
5637 -> 5636;
5638 -> 5637;
5638 -> 5516;
5638 -> 5636;
5639 -> 5638;
5639 -> 5633;
5640 -> 5633;
5641 -> 5639;
5641 -> 5640;
5642 -> 5641;
5642 -> 5516;
5642 -> 5640;
5643 -> 5642;
5643 -> 0;
5643 -> 5633;
5644 -> 5642;
5644 -> 5633;
5645 -> 5633;
5646 -> 5644;
5646 -> 5645;
5647 -> 5646;
5647 -> 5645;
5648 -> 5647;
5649 -> 5633;
5650 -> 5644;
5650 -> 5649;
5651 -> 5650;
5651 -> 5649;
5652 -> 5651;
5653 -> 5648;
5653 -> 5652;
5653 -> 5633;
5654 -> 5642;
5654 -> 0;
5654 -> 5633;
5655 -> 5633;
5656 -> 5635;
5656 -> 5655;
5657 -> 5655;
5658 -> 5656;
5658 -> 5657;
5659 -> 5658;
5659 -> 5516;
5659 -> 5657;
5660 -> 5655;
5661 -> 5659;
5661 -> 5660;
5662 -> 5661;
5662 -> 5516;
5662 -> 5660;
5663 -> 5662;
5663 -> 0;
5663 -> 5655;
5664 -> 5663;
5664 -> 5655;
5665 -> 5664;
5665 -> 5633;
5666 -> 5633;
5667 -> 5635;
5667 -> 5666;
5668 -> 5667;
5668 -> 5516;
5668 -> 5666;
5669 -> 5668;
5669 -> 5633;
5670 -> 5633;
5671 -> 5669;
5671 -> 5670;
5672 -> 5671;
5672 -> 5516;
5672 -> 5670;
5673 -> 5672;
5673 -> 5633;
5674 -> 5633;
5675 -> 5673;
5675 -> 5674;
5676 -> 5675;
5676 -> 5674;
5677 -> 5676;
5678 -> 5672;
5678 -> 0;
5678 -> 5633;
5679 -> 5677;
5679 -> 5633;
5680 -> 5634;
5680 -> 5633;
5681 -> 5633;
5682 -> 5680;
5682 -> 5681;
5683 -> 5635;
5683 -> 5681;
5684 -> 5681;
5685 -> 5683;
5685 -> 5684;
5686 -> 5685;
5686 -> 5516;
5686 -> 5684;
5687 -> 5686;
5687 -> 5681;
5688 -> 5681;
5689 -> 5681;
5690 -> 5688;
5690 -> 5689;
5691 -> 5683;
5691 -> 5689;
5692 -> 5689;
5693 -> 5690;
5693 -> 5692;
5693 -> 5689;
5694 -> 5691;
5694 -> 5516;
5694 -> 5690;
5694 -> 5689;
5695 -> 5689;
5696 -> 5691;
5696 -> 5516;
5696 -> 5695;
5696 -> 5689;
5697 -> 5691;
5697 -> 5516;
5697 -> 5690;
5697 -> 5696;
5698 -> 5691;
5698 -> 5516;
5698 -> 5533;
5698 -> 5697;
5698 -> 5696;
5699 -> 5681;
5700 -> 5687;
5700 -> 5699;
5701 -> 5698;
5701 -> 5699;
5702 -> 5688;
5702 -> 5699;
5703 -> 5683;
5703 -> 5699;
5704 -> 5700;
5704 -> 5699;
5705 -> 5699;
5706 -> 5704;
5706 -> 5705;
5707 -> 5703;
5707 -> 5705;
5708 -> 5705;
5709 -> 5706;
5709 -> 5708;
5710 -> 5709;
5710 -> 5516;
5710 -> 5708;
5711 -> 5710;
5711 -> 5705;
5712 -> 5705;
5713 -> 5707;
5713 -> 5712;
5714 -> 5713;
5714 -> 5516;
5714 -> 5533;
5714 -> 5712;
5715 -> 5714;
5715 -> 5705;
5716 -> 5711;
5716 -> 5715;
5716 -> 5705;
5717 -> 5716;
5718 -> 5701;
5718 -> 5717;
5719 -> 5718;
5719 -> 5716;
5720 -> 5719;
5721 -> 5681;
5722 -> 5720;
5722 -> 5721;
5722 -> 5681;
5723 -> 5720;
5723 -> 5722;
5724 -> 5723;
5724 -> 5633;
5725 -> 5724;
5725 -> 5626;
5726 -> 5627;
5726 -> 5725;
5727 -> 5725;
5728 -> 5726;
5728 -> 5727;
5729 -> 5630;
5729 -> 5727;
5730 -> 5728;
5730 -> 5727;
5731 -> 5727;
5732 -> 5729;
5732 -> 5731;
5733 -> 0;
5733 -> 5731;
5734 -> 5731;
5735 -> 5733;
5735 -> 5734;
5736 -> 5732;
5736 -> 5734;
5737 -> 5736;
5737 -> 5516;
5737 -> 5533;
5737 -> 5734;
5738 -> 5736;
5738 -> 5516;
5738 -> 5533;
5738 -> 5737;
5738 -> 5734;
5739 -> 5735;
5739 -> 5734;
5740 -> 5734;
5741 -> 5739;
5741 -> 5740;
5742 -> 5736;
5742 -> 5740;
5743 -> 5740;
5744 -> 5740;
5745 -> 5740;
5746 -> 5742;
5746 -> 5745;
5747 -> 5746;
5747 -> 5740;
5748 -> 5740;
5749 -> 5747;
5749 -> 5748;
5750 -> 5749;
5750 -> 5740;
5751 -> 5740;
5752 -> 5750;
5752 -> 5751;
5753 -> 5752;
5753 -> 5751;
5754 -> 5753;
5755 -> 5749;
5755 -> 5740;
5756 -> 5740;
5757 -> 5755;
5757 -> 5756;
5758 -> 5757;
5758 -> 5756;
5759 -> 5756;
5760 -> 5758;
5760 -> 5759;
5761 -> 5760;
5761 -> 5759;
5762 -> 5759;
5763 -> 5761;
5763 -> 5762;
5764 -> 5763;
5764 -> 5762;
5765 -> 0;
5765 -> 5764;
5766 -> 5749;
5766 -> 0;
5766 -> 5765;
5767 -> 5766;
5768 -> 5742;
5768 -> 5767;
5769 -> 5767;
5770 -> 5768;
5770 -> 5769;
5771 -> 5770;
5771 -> 5767;
5772 -> 5767;
5773 -> 5771;
5773 -> 5772;
5774 -> 5773;
5774 -> 5516;
5774 -> 5772;
5775 -> 5767;
5776 -> 5775;
5776 -> 5766;
5777 -> 5776;
5778 -> 5776;
5779 -> 5777;
5779 -> 5778;
5780 -> 5777;
5780 -> 5778;
5781 -> 5742;
5781 -> 5778;
5782 -> 5778;
5783 -> 5781;
5783 -> 5782;
5784 -> 5783;
5784 -> 5778;
5785 -> 5778;
5786 -> 5784;
5786 -> 5785;
5787 -> 5786;
5787 -> 5516;
5787 -> 5785;
5788 -> 5778;
5789 -> 5788;
5789 -> 5776;
5790 -> 5789;
5791 -> 5790;
5791 -> 5789;
5792 -> 5789;
5793 -> 5791;
5793 -> 5792;
5794 -> 5793;
5794 -> 5516;
5794 -> 5792;
5795 -> 5749;
5795 -> 0;
5795 -> 5794;
5796 -> 5741;
5796 -> 5795;
5797 -> 5795;
5798 -> 5796;
5798 -> 5797;
5799 -> 5742;
5799 -> 5797;
5800 -> 5798;
5800 -> 0;
5800 -> 5797;
5801 -> 5797;
5802 -> 5799;
5802 -> 5801;
5803 -> 5802;
5803 -> 5797;
5804 -> 5797;
5805 -> 5803;
5805 -> 5804;
5806 -> 5804;
5807 -> 5805;
5807 -> 5806;
5808 -> 5807;
5808 -> 5804;
5809 -> 5797;
5810 -> 5799;
5810 -> 5809;
5811 -> 5810;
5811 -> 5797;
5812 -> 5797;
5813 -> 5811;
5813 -> 5812;
5814 -> 5797;
5815 -> 5813;
5815 -> 5814;
5816 -> 5815;
5816 -> 5814;
5817 -> 5814;
5818 -> 5816;
5818 -> 5817;
5819 -> 5818;
5819 -> 5817;
5820 -> 5819;
5821 -> 5808;
5821 -> 5820;
5821 -> 5797;
5822 -> 5800;
5822 -> 5821;
5822 -> 5797;
5823 -> 5822;
5824 -> 5741;
5824 -> 5823;
5825 -> 5823;
5826 -> 5824;
5826 -> 5825;
5827 -> 5742;
5827 -> 5825;
5828 -> 5826;
5828 -> 5825;
5829 -> 5825;
5830 -> 5828;
5830 -> 5829;
5831 -> 5827;
5831 -> 5829;
5832 -> 5829;
5833 -> 5831;
5833 -> 5832;
5834 -> 5833;
5834 -> 5829;
5835 -> 5829;
5836 -> 5834;
5836 -> 5835;
5837 -> 5836;
5837 -> 5829;
5838 -> 5837;
5839 -> 5831;
5839 -> 5838;
5840 -> 5838;
5841 -> 5839;
5841 -> 5840;
5842 -> 5841;
5842 -> 5838;
5843 -> 5838;
5844 -> 5842;
5844 -> 5843;
5845 -> 5844;
5846 -> 5839;
5846 -> 5845;
5847 -> 5845;
5848 -> 5846;
5848 -> 5847;
5849 -> 5848;
5849 -> 5845;
5850 -> 5845;
5851 -> 5849;
5851 -> 5850;
5852 -> 5845;
5853 -> 5852;
5853 -> 5844;
5854 -> 5844;
5855 -> 5839;
5855 -> 5854;
5856 -> 5854;
5857 -> 5855;
5857 -> 5856;
5858 -> 5857;
5858 -> 5516;
5858 -> 5533;
5858 -> 5737;
5858 -> 5856;
5859 -> 5858;
5859 -> 5854;
5860 -> 5859;
5860 -> 5844;
5861 -> 5853;
5861 -> 5860;
5861 -> 5844;
5862 -> 5844;
5863 -> 5839;
5863 -> 5862;
5864 -> 5862;
5865 -> 5863;
5865 -> 5864;
5866 -> 5865;
5866 -> 5862;
5867 -> 5862;
5868 -> 5866;
5868 -> 5867;
5869 -> 5868;
5869 -> 5844;
5870 -> 5861;
5870 -> 5869;
5870 -> 5844;
5871 -> 5870;
5872 -> 5871;
5872 -> 5837;
5873 -> 5872;
5874 -> 5831;
5874 -> 5873;
5875 -> 5873;
5876 -> 5875;
5876 -> 5873;
5877 -> 5873;
5878 -> 5876;
5878 -> 5877;
5879 -> 5874;
5879 -> 5877;
5880 -> 5877;
5881 -> 5878;
5881 -> 5880;
5881 -> 5877;
5882 -> 5879;
5882 -> 5516;
5882 -> 5878;
5882 -> 5877;
5883 -> 5879;
5883 -> 5516;
5883 -> 5878;
5884 -> 5873;
5885 -> 5883;
5885 -> 5884;
5886 -> 5873;
5887 -> 5876;
5887 -> 5886;
5888 -> 5874;
5888 -> 5886;
5889 -> 5886;
5890 -> 5887;
5890 -> 5889;
5890 -> 5886;
5891 -> 5888;
5891 -> 5516;
5891 -> 5887;
5891 -> 5886;
5892 -> 5888;
5892 -> 5516;
5892 -> 5887;
5893 -> 5873;
5894 -> 5892;
5894 -> 5893;
5895 -> 5885;
5895 -> 5894;
5895 -> 5873;
5896 -> 5875;
5896 -> 5873;
5897 -> 5873;
5898 -> 5896;
5898 -> 5897;
5899 -> 5874;
5899 -> 5897;
5900 -> 5897;
5901 -> 5898;
5901 -> 5900;
5901 -> 5897;
5902 -> 5899;
5902 -> 5516;
5902 -> 5898;
5902 -> 5897;
5903 -> 5899;
5903 -> 5516;
5903 -> 5898;
5904 -> 5873;
5905 -> 5903;
5905 -> 5904;
5906 -> 5905;
5906 -> 5872;
5907 -> 5830;
5907 -> 5906;
5908 -> 5906;
5909 -> 5907;
5909 -> 5908;
5910 -> 5831;
5910 -> 5908;
5911 -> 5908;
5912 -> 5910;
5912 -> 5911;
5913 -> 5912;
5913 -> 5908;
5914 -> 5908;
5915 -> 5913;
5915 -> 5914;
5916 -> 5908;
5917 -> 5910;
5917 -> 5916;
5918 -> 5917;
5918 -> 5908;
5919 -> 5908;
5920 -> 5918;
5920 -> 5919;
5921 -> 5910;
5921 -> 5919;
5922 -> 5915;
5922 -> 5920;
5922 -> 5908;
5923 -> 5909;
5923 -> 0;
5923 -> 5908;
5924 -> 5908;
5925 -> 5908;
5926 -> 5908;
5927 -> 5910;
5927 -> 5926;
5928 -> 5927;
5928 -> 5908;
5929 -> 5908;
5930 -> 5928;
5930 -> 5929;
5931 -> 5930;
5932 -> 5931;
5932 -> 5930;
5933 -> 5930;
5934 -> 5932;
5934 -> 5933;
5935 -> 5934;
5936 -> 5934;
5937 -> 5935;
5937 -> 5908;
5938 -> 5908;
5939 -> 5937;
5939 -> 5938;
5940 -> 5910;
5940 -> 5938;
5941 -> 5938;
5942 -> 5939;
5942 -> 5941;
5942 -> 5938;
5943 -> 5940;
5943 -> 5516;
5943 -> 5939;
5943 -> 5938;
5944 -> 5908;
5945 -> 5939;
5945 -> 5944;
5946 -> 5935;
5946 -> 5908;
5947 -> 5908;
5948 -> 5946;
5948 -> 5947;
5949 -> 5910;
5949 -> 5947;
5950 -> 5947;
5951 -> 5948;
5951 -> 5950;
5951 -> 5947;
5952 -> 5949;
5952 -> 5516;
5952 -> 5948;
5952 -> 5947;
5953 -> 5908;
5954 -> 5948;
5954 -> 5953;
5955 -> 5908;
5956 -> 5935;
5956 -> 5955;
5956 -> 5908;
5957 -> 5908;
5958 -> 5956;
5958 -> 5957;
5959 -> 5910;
5959 -> 5957;
5960 -> 5957;
5961 -> 5958;
5961 -> 5960;
5961 -> 5957;
5962 -> 5959;
5962 -> 5516;
5962 -> 5958;
5962 -> 5957;
5963 -> 5908;
5964 -> 5958;
5964 -> 5963;
5965 -> 5954;
5965 -> 5964;
5965 -> 5908;
5966 -> 5935;
5966 -> 5908;
5967 -> 5908;
5968 -> 5966;
5968 -> 5967;
5969 -> 5910;
5969 -> 5967;
5970 -> 5967;
5971 -> 5968;
5971 -> 5970;
5971 -> 5967;
5972 -> 5969;
5972 -> 5516;
5972 -> 5968;
5972 -> 5967;
5973 -> 5908;
5974 -> 5968;
5974 -> 5973;
5975 -> 5935;
5975 -> 5908;
5976 -> 5908;
5977 -> 5975;
5977 -> 5976;
5978 -> 5910;
5978 -> 5976;
5979 -> 5976;
5980 -> 5977;
5980 -> 5979;
5980 -> 5976;
5981 -> 5978;
5981 -> 5516;
5981 -> 5977;
5981 -> 5976;
5982 -> 5908;
5983 -> 5977;
5983 -> 5982;
5984 -> 5983;
5985 -> 5984;
5985 -> 5906;
5986 -> 5830;
5986 -> 5985;
5987 -> 5985;
5988 -> 5986;
5988 -> 5987;
5989 -> 0;
5989 -> 5988;
5990 -> 5988;
5991 -> 5989;
5991 -> 5990;
5992 -> 5831;
5992 -> 5990;
5993 -> 5991;
5993 -> 5990;
5994 -> 5990;
5995 -> 5993;
5995 -> 5994;
5996 -> 5992;
5996 -> 5994;
5997 -> 5994;
5998 -> 5994;
5999 -> 5997;
5999 -> 5998;
6000 -> 5996;
6000 -> 5998;
6001 -> 5998;
6002 -> 6000;
6002 -> 6001;
6003 -> 6001;
6004 -> 6002;
6004 -> 6003;
6005 -> 6004;
6005 -> 6001;
6006 -> 6005;
6007 -> 6006;
6007 -> 5998;
6008 -> 5999;
6008 -> 5998;
6009 -> 5998;
6010 -> 6008;
6010 -> 6009;
6011 -> 6000;
6011 -> 6009;
6012 -> 6009;
6013 -> 6011;
6013 -> 6012;
6014 -> 6013;
6014 -> 6009;
6015 -> 6009;
6016 -> 6014;
6016 -> 6015;
6017 -> 6016;
6017 -> 0;
6017 -> 6009;
6018 -> 6017;
6019 -> 6011;
6019 -> 6018;
6020 -> 6018;
6021 -> 6019;
6021 -> 6020;
6022 -> 6021;
6022 -> 6018;
6023 -> 6018;
6024 -> 6022;
6024 -> 6023;
6025 -> 6018;
6025 -> 6017;
6026 -> 6017;
6027 -> 6026;
6027 -> 6017;
6028 -> 6025;
6028 -> 6027;
6028 -> 6017;
6029 -> 6017;
6030 -> 6011;
6030 -> 6029;
6031 -> 6029;
6032 -> 6030;
6032 -> 6031;
6033 -> 6032;
6033 -> 6029;
6034 -> 6029;
6035 -> 6030;
6035 -> 6034;
6036 -> 6034;
6037 -> 6035;
6037 -> 5516;
6037 -> 6036;
6038 -> 6037;
6038 -> 5516;
6038 -> 6036;
6039 -> 6038;
6039 -> 6034;
6040 -> 6039;
6040 -> 6035;
6040 -> 6034;
6041 -> 6034;
6042 -> 6041;
6042 -> 6035;
6042 -> 6034;
6043 -> 6034;
6044 -> 6035;
6044 -> 5516;
6044 -> 6043;
6044 -> 6034;
6045 -> 6035;
6045 -> 5516;
6045 -> 6034;
6046 -> 6029;
6047 -> 6033;
6047 -> 6029;
6048 -> 6047;
6048 -> 6017;
6049 -> 6017;
6050 -> 6011;
6050 -> 6049;
6051 -> 6050;
6051 -> 5516;
6051 -> 5533;
6051 -> 5737;
6051 -> 6040;
6051 -> 6042;
6051 -> 6045;
6051 -> 6049;
6052 -> 6051;
6052 -> 6017;
6053 -> 6048;
6053 -> 6017;
6054 -> 6053;
6054 -> 5998;
6055 -> 6054;
6055 -> 5998;
6056 -> 6055;
6056 -> 5516;
6056 -> 5533;
6056 -> 5737;
6056 -> 6040;
6056 -> 6042;
6056 -> 6045;
6056 -> 5998;
6057 -> 5998;
6058 -> 6056;
6058 -> 6057;
6059 -> 6056;
6059 -> 6057;
6060 -> 6058;
6060 -> 6057;
6061 -> 6057;
6062 -> 6061;
6062 -> 6060;
6062 -> 6057;
6063 -> 6061;
6063 -> 6057;
6064 -> 6063;
6064 -> 6062;
6064 -> 6057;
6065 -> 6064;
6065 -> 5994;
6066 -> 6065;
6066 -> 6064;
6066 -> 5994;
6067 -> 6065;
6067 -> 5994;
6068 -> 5994;
6069 -> 5996;
6069 -> 6068;
6070 -> 6069;
6070 -> 6064;
6070 -> 6068;
6071 -> 6069;
6071 -> 6064;
6071 -> 6068;
6072 -> 6071;
6072 -> 5994;
6073 -> 5994;
6074 -> 6072;
6074 -> 6073;
6075 -> 6067;
6075 -> 5994;
6076 -> 6075;
6076 -> 5990;
6077 -> 5990;
6078 -> 5992;
6078 -> 6077;
6079 -> 6078;
6079 -> 6064;
6079 -> 6071;
6079 -> 6077;
6080 -> 6079;
6080 -> 5990;
6081 -> 5990;
6082 -> 6080;
6082 -> 6081;
6083 -> 6076;
6083 -> 5990;
6084 -> 6083;
6084 -> 5988;
6085 -> 6084;
6085 -> 5827;
6085 -> 6064;
6085 -> 6071;
6085 -> 5825;
6086 -> 5825;
6087 -> 6085;
6087 -> 5740;
6088 -> 5741;
6088 -> 5740;
6089 -> 5740;
6090 -> 6087;
6090 -> 6089;
6091 -> 6088;
6091 -> 6089;
6092 -> 5742;
6092 -> 6089;
6093 -> 6089;
6094 -> 6093;
6095 -> 6092;
6095 -> 6094;
6096 -> 6095;
6096 -> 6085;
6096 -> 6094;
6097 -> 6096;
6097 -> 6093;
6098 -> 6093;
6099 -> 6097;
6099 -> 6098;
6100 -> 6098;
6101 -> 6099;
6101 -> 6100;
6102 -> 6101;
6102 -> 6098;
6103 -> 6093;
6104 -> 6093;
6105 -> 6102;
6105 -> 6093;
6106 -> 6093;
6107 -> 6105;
6107 -> 6106;
6108 -> 6107;
6108 -> 6106;
6109 -> 6106;
6110 -> 6108;
6110 -> 6109;
6111 -> 6110;
6111 -> 6109;
6112 -> 6109;
6113 -> 6111;
6113 -> 6112;
6114 -> 6113;
6114 -> 6112;
6115 -> 0;
6115 -> 6114;
6116 -> 6102;
6116 -> 6115;
6117 -> 6115;
6118 -> 6116;
6118 -> 6117;
6119 -> 6118;
6119 -> 6117;
6120 -> 6117;
6121 -> 6119;
6121 -> 6120;
6122 -> 6121;
6122 -> 6120;
6123 -> 6122;
6124 -> 6102;
6124 -> 6123;
6125 -> 6123;
6126 -> 6124;
6126 -> 6125;
6127 -> 6126;
6127 -> 6125;
6128 -> 0;
6128 -> 6127;
6129 -> 6123;
6130 -> 6128;
6130 -> 6093;
6131 -> 6093;
6132 -> 6130;
6132 -> 6131;
6133 -> 6132;
6133 -> 6131;
6134 -> 0;
6134 -> 6133;
6135 -> 6093;
6136 -> 6102;
6136 -> 0;
6136 -> 6093;
6137 -> 6134;
6137 -> 6091;
6137 -> 6093;
6138 -> 6134;
6138 -> 6091;
6138 -> 6093;
6139 -> 6128;
6139 -> 6093;
6140 -> 6093;
6141 -> 6139;
6141 -> 6140;
6142 -> 6141;
6142 -> 6140;
6143 -> 6142;
6144 -> 6138;
6144 -> 6143;
6144 -> 6093;
6145 -> 6102;
6145 -> 6093;
6146 -> 6093;
6147 -> 6093;
6148 -> 6145;
6148 -> 6147;
6149 -> 6146;
6149 -> 6147;
6150 -> 6092;
6150 -> 6147;
6151 -> 6148;
6151 -> 6147;
6152 -> 6147;
6153 -> 6151;
6153 -> 6152;
6154 -> 6153;
6154 -> 0;
6154 -> 6152;
6155 -> 6154;
6156 -> 6147;
6157 -> 6150;
6157 -> 6156;
6158 -> 6157;
6158 -> 6085;
6158 -> 6156;
6159 -> 6158;
6159 -> 6147;
6160 -> 6147;
6161 -> 6159;
6161 -> 6160;
6162 -> 6160;
6163 -> 6161;
6163 -> 6162;
6164 -> 6163;
6164 -> 6160;
6165 -> 6164;
6165 -> 6148;
6165 -> 6147;
6166 -> 6165;
6167 -> 6166;
6167 -> 6085;
6168 -> 6167;
6168 -> 6085;
6168 -> 6166;
6169 -> 6166;
6170 -> 6166;
6171 -> 6166;
6171 -> 6165;
6172 -> 6165;
6173 -> 6171;
6173 -> 6172;
6174 -> 6172;
6175 -> 6173;
6175 -> 6174;
6176 -> 6175;
6176 -> 6172;
6177 -> 6172;
6178 -> 6173;
6178 -> 6177;
6179 -> 6178;
6179 -> 6172;
6180 -> 6176;
6180 -> 6179;
6180 -> 6172;
6181 -> 6173;
6181 -> 6172;
6182 -> 6093;
6183 -> 6090;
6183 -> 6182;
6184 -> 6183;
6184 -> 6093;
6185 -> 6093;
6186 -> 6184;
6186 -> 6185;
6187 -> 6186;
6187 -> 6185;
6188 -> 0;
6188 -> 6187;
6189 -> 6134;
6189 -> 6188;
6189 -> 6093;
6190 -> 6135;
6190 -> 6093;
6191 -> 6128;
6191 -> 0;
6191 -> 6093;
6192 -> 6128;
6192 -> 0;
6192 -> 6191;
6193 -> 6129;
6193 -> 6192;
6194 -> 6128;
6194 -> 0;
6194 -> 6193;
6195 -> 6193;
6196 -> 6195;
6196 -> 6085;
6196 -> 6166;
6197 -> 6195;
6197 -> 6085;
6197 -> 6168;
6197 -> 6166;
6198 -> 6197;
6198 -> 6193;
6199 -> 6193;
6200 -> 6198;
6200 -> 6199;
6201 -> 6200;
6201 -> 6193;
6202 -> 6134;
6202 -> 6201;
6203 -> 6201;
6204 -> 6202;
6204 -> 6203;
6205 -> 6203;
6205 -> 6085;
6206 -> 6203;
6207 -> 6203;
6208 -> 6203;
6209 -> 6203;
6210 -> 6208;
6210 -> 6209;
6211 -> 6210;
6211 -> 6209;
6212 -> 6211;
6213 -> 6203;
6214 -> 6203;
6215 -> 6213;
6215 -> 6214;
6216 -> 6215;
6216 -> 6203;
6217 -> 6203;
6218 -> 6216;
6218 -> 6217;
6219 -> 6203;
6220 -> 6203;
6221 -> 6203;
6222 -> 6203;
6223 -> 6221;
6223 -> 6222;
6224 -> 6223;
6224 -> 6203;
6225 -> 6203;
6226 -> 6224;
6226 -> 6225;
6227 -> 6204;
6227 -> 6217;
6228 -> 6227;
6229 -> 6227;
6229 -> 6228;
6230 -> 6228;
6231 -> 6229;
6231 -> 6230;
6232 -> 6231;
6232 -> 6228;
6233 -> 6228;
6234 -> 6232;
6234 -> 6233;
6235 -> 6228;
6236 -> 6229;
6236 -> 6235;
6237 -> 6235;
6238 -> 6236;
6238 -> 6237;
6239 -> 6238;
6239 -> 6235;
6240 -> 6235;
6241 -> 6239;
6241 -> 6240;
6242 -> 6235;
6243 -> 6235;
6244 -> 6242;
6244 -> 6243;
6245 -> 6236;
6245 -> 6243;
6246 -> 6243;
6247 -> 6244;
6247 -> 6246;
6247 -> 6243;
6248 -> 6245;
6248 -> 6085;
6248 -> 6166;
6248 -> 6244;
6248 -> 6243;
6249 -> 6245;
6249 -> 6085;
6249 -> 6166;
6249 -> 6244;
6250 -> 6235;
6251 -> 6249;
6251 -> 6250;
6252 -> 6241;
6252 -> 6251;
6252 -> 6235;
6253 -> 6252;
6253 -> 6228;
6254 -> 6253;
6255 -> 6229;
6255 -> 6254;
6256 -> 6254;
6257 -> 6255;
6257 -> 6256;
6258 -> 6257;
6258 -> 6254;
6259 -> 6254;
6260 -> 6258;
6260 -> 6259;
6261 -> 6254;
6262 -> 6254;
6263 -> 6261;
6263 -> 6262;
6264 -> 6255;
6264 -> 6262;
6265 -> 6262;
6266 -> 6263;
6266 -> 6265;
6266 -> 6262;
6267 -> 6264;
6267 -> 6085;
6267 -> 6166;
6267 -> 6263;
6267 -> 6262;
6268 -> 6264;
6268 -> 6085;
6268 -> 6166;
6268 -> 6263;
6269 -> 6254;
6270 -> 6268;
6270 -> 6269;
6271 -> 6270;
6271 -> 6253;
6272 -> 6271;
6273 -> 6229;
6273 -> 6272;
6274 -> 0;
6274 -> 6272;
6275 -> 6272;
6276 -> 6274;
6276 -> 6275;
6277 -> 6273;
6277 -> 6275;
6278 -> 6276;
6278 -> 6275;
6279 -> 6275;
6280 -> 6278;
6280 -> 6279;
6281 -> 6280;
6281 -> 0;
6281 -> 6279;
6282 -> 6281;
6283 -> 6275;
6284 -> 6277;
6284 -> 6283;
6285 -> 6284;
6285 -> 6275;
6286 -> 6275;
6287 -> 6285;
6287 -> 6286;
6288 -> 6287;
6288 -> 6275;
6289 -> 6288;
6289 -> 6276;
6289 -> 6275;
6290 -> 6289;
6291 -> 6290;
6292 -> 6289;
6293 -> 6285;
6293 -> 6289;
6294 -> 6272;
6295 -> 6272;
6296 -> 6272;
6297 -> 6273;
6297 -> 6296;
6298 -> 6296;
6299 -> 6297;
6299 -> 6298;
6300 -> 6299;
6300 -> 6085;
6300 -> 6166;
6300 -> 6290;
6300 -> 6298;
6301 -> 6299;
6301 -> 6085;
6301 -> 6168;
6301 -> 6290;
6301 -> 6166;
6301 -> 6197;
6301 -> 6203;
6302 -> 6301;
6302 -> 6296;
6303 -> 6296;
6304 -> 6302;
6304 -> 6303;
6305 -> 6296;
6306 -> 6297;
6306 -> 6305;
6307 -> 6306;
6307 -> 6085;
6307 -> 6166;
6307 -> 6290;
6307 -> 6305;
6308 -> 6306;
6308 -> 6085;
6308 -> 6168;
6308 -> 6290;
6308 -> 6305;
6309 -> 6306;
6309 -> 6307;
6309 -> 6308;
6309 -> 6085;
6309 -> 6168;
6309 -> 6290;
6309 -> 6166;
6309 -> 6197;
6309 -> 6301;
6309 -> 6203;
6309 -> 6305;
6310 -> 6309;
6310 -> 6305;
6311 -> 6306;
6311 -> 6309;
6311 -> 6305;
6312 -> 6305;
6313 -> 6305;
6314 -> 6310;
6314 -> 6313;
6315 -> 6311;
6315 -> 6313;
6316 -> 6311;
6316 -> 6313;
6317 -> 6311;
6317 -> 6313;
6318 -> 6311;
6318 -> 6313;
6319 -> 6312;
6319 -> 6313;
6320 -> 6314;
6320 -> 6319;
6320 -> 6313;
6321 -> 6315;
6321 -> 6319;
6321 -> 6313;
6322 -> 6316;
6322 -> 6319;
6322 -> 6313;
6323 -> 6317;
6323 -> 6319;
6323 -> 6313;
6324 -> 6318;
6324 -> 6319;
6324 -> 6313;
6325 -> 6312;
6325 -> 6296;
6326 -> 6296;
6327 -> 6297;
6327 -> 6326;
6328 -> 6327;
6328 -> 6309;
6328 -> 6326;
6329 -> 6327;
6329 -> 6309;
6329 -> 6326;
6330 -> 6326;
6331 -> 6330;
6331 -> 6327;
6331 -> 6326;
6332 -> 6326;
6333 -> 6327;
6333 -> 6309;
6333 -> 6332;
6333 -> 6326;
6334 -> 6327;
6334 -> 6309;
6334 -> 6326;
6335 -> 6326;
6336 -> 6328;
6336 -> 6296;
6337 -> 6296;
6338 -> 6296;
6339 -> 6337;
6339 -> 6338;
6340 -> 6297;
6340 -> 6338;
6341 -> 6339;
6341 -> 6338;
6342 -> 6338;
6343 -> 6338;
6344 -> 6341;
6344 -> 6343;
6345 -> 6342;
6345 -> 6343;
6346 -> 6340;
6346 -> 6343;
6347 -> 6345;
6347 -> 6343;
6348 -> 0;
6348 -> 6347;
6349 -> 6344;
6349 -> 6343;
6350 -> 6348;
6350 -> 6349;
6350 -> 6346;
6350 -> 6309;
6350 -> 6331;
6350 -> 6327;
6350 -> 6334;
6350 -> 6343;
6351 -> 6343;
6352 -> 6350;
6352 -> 6351;
6353 -> 6350;
6354 -> 6350;
6354 -> 6353;
6354 -> 6351;
6355 -> 6351;
6356 -> 6351;
6357 -> 6350;
6357 -> 6353;
6357 -> 6356;
6357 -> 6351;
6358 -> 6351;
6359 -> 6350;
6359 -> 6351;
6360 -> 6350;
6360 -> 6351;
6361 -> 6350;
6361 -> 6351;
6362 -> 6351;
6363 -> 6361;
6363 -> 6362;
6364 -> 6363;
6364 -> 6353;
6364 -> 6362;
6365 -> 6364;
6365 -> 6351;
6366 -> 6365;
6366 -> 6359;
6366 -> 6351;
6367 -> 6365;
6367 -> 6366;
6368 -> 6366;
6369 -> 6367;
6369 -> 6368;
6369 -> 6343;
6370 -> 6367;
6370 -> 6351;
6371 -> 6346;
6371 -> 6348;
6371 -> 6349;
6371 -> 6350;
6371 -> 6353;
6371 -> 6368;
6371 -> 6367;
6371 -> 6343;
6372 -> 6371;
6372 -> 0;
6372 -> 6338;
6373 -> 6372;
6374 -> 6373;
6375 -> 6374;
6375 -> 6372;
6376 -> 6372;
6377 -> 6376;
6377 -> 6372;
6378 -> 6372;
6379 -> 6377;
6379 -> 6378;
6380 -> 6338;
6381 -> 6340;
6381 -> 6380;
6382 -> 6381;
6382 -> 6371;
6382 -> 6380;
6383 -> 6381;
6383 -> 6371;
6383 -> 6380;
6384 -> 6380;
6385 -> 6381;
6385 -> 6371;
6385 -> 6384;
6385 -> 6380;
6386 -> 6381;
6386 -> 6371;
6386 -> 6380;
6387 -> 6380;
6388 -> 6382;
6388 -> 6338;
6389 -> 6388;
6389 -> 6338;
6390 -> 6338;
6391 -> 6338;
6392 -> 6389;
6392 -> 6391;
6393 -> 6390;
6393 -> 6391;
6394 -> 6340;
6394 -> 6391;
6395 -> 6393;
6395 -> 6391;
6396 -> 6348;
6396 -> 6395;
6397 -> 6391;
6398 -> 6392;
6398 -> 6397;
6399 -> 6392;
6399 -> 6397;
6400 -> 6397;
6401 -> 6397;
6402 -> 6392;
6402 -> 6401;
6402 -> 6397;
6403 -> 6397;
6404 -> 6392;
6404 -> 6397;
6405 -> 6397;
6406 -> 6392;
6406 -> 0;
6406 -> 6338;
6407 -> 6338;
6408 -> 6340;
6408 -> 6407;
6409 -> 6408;
6409 -> 6392;
6409 -> 6407;
6410 -> 6407;
6411 -> 6410;
6411 -> 6338;
6412 -> 6379;
6413 -> 6412;
6413 -> 6392;
6414 -> 6413;
6414 -> 6379;
6415 -> 6379;
6416 -> 6414;
6416 -> 6415;
6417 -> 6379;
6418 -> 6417;
6418 -> 6392;
6419 -> 6418;
6419 -> 6379;
6420 -> 6379;
6421 -> 6419;
6421 -> 6420;
6422 -> 6421;
6423 -> 6422;
6423 -> 6392;
6424 -> 6422;
6425 -> 6422;
6426 -> 6422;
6426 -> 6421;
6427 -> 0;
6427 -> 6421;
6428 -> 6427;
6428 -> 0;
6428 -> 6296;
6429 -> 6428;
6430 -> 6429;
6430 -> 6392;
6430 -> 6422;
6431 -> 6429;
6431 -> 6392;
6431 -> 6422;
6432 -> 6431;
6432 -> 6428;
6433 -> 6428;
6434 -> 6432;
6434 -> 6433;
6435 -> 6434;
6436 -> 6325;
6436 -> 6434;
6437 -> 6434;
6438 -> 6436;
6438 -> 6437;
6439 -> 6297;
6439 -> 6437;
6440 -> 6438;
6440 -> 6321;
6440 -> 6439;
6440 -> 6437;
6441 -> 6438;
6441 -> 6322;
6441 -> 6439;
6441 -> 6437;
6442 -> 6438;
6442 -> 6323;
6442 -> 6439;
6442 -> 6392;
6442 -> 6437;
6443 -> 6438;
6443 -> 6324;
6443 -> 6439;
6443 -> 6392;
6443 -> 6437;
6444 -> 6438;
6444 -> 6320;
6444 -> 6437;
6445 -> 6437;
6446 -> 6444;
6446 -> 6445;
6447 -> 6439;
6447 -> 6445;
6448 -> 6446;
6448 -> 6309;
6448 -> 6447;
6448 -> 6392;
6448 -> 6445;
6449 -> 6445;
6450 -> 6448;
6450 -> 6449;
6450 -> 6445;
6451 -> 6448;
6451 -> 6447;
6451 -> 6392;
6451 -> 6445;
6452 -> 6446;
6452 -> 6309;
6452 -> 6447;
6452 -> 6445;
6453 -> 6445;
6454 -> 6448;
6454 -> 6453;
6454 -> 6445;
6455 -> 6448;
6455 -> 6447;
6455 -> 6392;
6455 -> 6445;
6456 -> 6448;
6456 -> 6447;
6456 -> 6445;
6457 -> 6445;
6458 -> 6457;
6458 -> 6447;
6458 -> 6445;
6459 -> 6445;
6460 -> 6459;
6460 -> 6447;
6460 -> 6445;
6461 -> 6446;
6461 -> 6309;
6461 -> 6447;
6461 -> 6445;
6462 -> 6445;
6463 -> 6447;
6463 -> 6392;
6463 -> 6462;
6463 -> 6445;
6464 -> 6437;
6465 -> 6434;
6466 -> 6438;
6466 -> 6434;
6467 -> 6434;
6468 -> 6466;
6468 -> 6467;
6469 -> 6297;
6469 -> 6467;
6470 -> 6468;
6470 -> 6446;
6470 -> 6467;
6471 -> 6467;
6472 -> 6470;
6472 -> 6471;
6473 -> 6469;
6473 -> 6471;
6474 -> 6473;
6474 -> 6392;
6474 -> 6472;
6474 -> 6309;
6474 -> 6471;
6475 -> 6473;
6475 -> 6392;
6475 -> 6471;
6476 -> 6471;
6477 -> 6473;
6477 -> 6392;
6477 -> 6475;
6477 -> 6476;
6477 -> 6471;
6478 -> 6467;
6479 -> 6434;
6480 -> 6435;
6480 -> 6272;
6481 -> 0;
6481 -> 6480;
6482 -> 6480;
6483 -> 6481;
6483 -> 6482;
6484 -> 6273;
6484 -> 6482;
6485 -> 6482;
6486 -> 6484;
6486 -> 6485;
6487 -> 6486;
6487 -> 6392;
6487 -> 6422;
6487 -> 6456;
6487 -> 6485;
6488 -> 6486;
6488 -> 6392;
6488 -> 6422;
6488 -> 6461;
6488 -> 6431;
6488 -> 6458;
6488 -> 6456;
6488 -> 6440;
6488 -> 6441;
6488 -> 6442;
6488 -> 6443;
6488 -> 6452;
6488 -> 6460;
6488 -> 6475;
6489 -> 6488;
6489 -> 6482;
6490 -> 6482;
6491 -> 6489;
6491 -> 6490;
6492 -> 6483;
6492 -> 6482;
6493 -> 6492;
6493 -> 6484;
6493 -> 6392;
6493 -> 6422;
6493 -> 6461;
6493 -> 6431;
6493 -> 6458;
6493 -> 6488;
6493 -> 6456;
6493 -> 6440;
6493 -> 6441;
6493 -> 6442;
6493 -> 6443;
6493 -> 6452;
6493 -> 6460;
6493 -> 6475;
6493 -> 6459;
6493 -> 6482;
6494 -> 6482;
6495 -> 6493;
6495 -> 6494;
6496 -> 6493;
6496 -> 6494;
6497 -> 6493;
6497 -> 6494;
6498 -> 6494;
6499 -> 6497;
6499 -> 6498;
6500 -> 6499;
6500 -> 6494;
6501 -> 6494;
6502 -> 6500;
6502 -> 6501;
6503 -> 6494;
6504 -> 6502;
6504 -> 6503;
6505 -> 6494;
6506 -> 6497;
6506 -> 6505;
6507 -> 6505;
6508 -> 6507;
6508 -> 6494;
6509 -> 6494;
6510 -> 6497;
6510 -> 6509;
6511 -> 6510;
6511 -> 6494;
6512 -> 6494;
6513 -> 6511;
6513 -> 6512;
6514 -> 6508;
6514 -> 6513;
6514 -> 6494;
6515 -> 6494;
6516 -> 6497;
6516 -> 6515;
6517 -> 6516;
6517 -> 6494;
6518 -> 6494;
6519 -> 6517;
6519 -> 6518;
6520 -> 6519;
6521 -> 6497;
6521 -> 6520;
6522 -> 0;
6522 -> 6520;
6523 -> 6520;
6524 -> 6522;
6524 -> 6523;
6525 -> 6521;
6525 -> 6523;
6526 -> 6524;
6526 -> 6523;
6527 -> 6523;
6528 -> 6526;
6528 -> 6527;
6529 -> 6528;
6529 -> 0;
6529 -> 6527;
6530 -> 6529;
6531 -> 6525;
6531 -> 6524;
6531 -> 6523;
6532 -> 6531;
6532 -> 6493;
6533 -> 6531;
6534 -> 6531;
6535 -> 6525;
6535 -> 6531;
6536 -> 6521;
6536 -> 6493;
6536 -> 6531;
6536 -> 6520;
6537 -> 6520;
6538 -> 6521;
6538 -> 6537;
6539 -> 6538;
6539 -> 6536;
6539 -> 6537;
6540 -> 6538;
6540 -> 6536;
6540 -> 6537;
6541 -> 6540;
6541 -> 6520;
6542 -> 6520;
6543 -> 6541;
6543 -> 6542;
6544 -> 6543;
6545 -> 6521;
6545 -> 6544;
6546 -> 6544;
6547 -> 6544;
6548 -> 6546;
6548 -> 6547;
6549 -> 6545;
6549 -> 6547;
6550 -> 6549;
6550 -> 6547;
6551 -> 6547;
6552 -> 6550;
6552 -> 6551;
6553 -> 6548;
6553 -> 6549;
6553 -> 6536;
6553 -> 6540;
6553 -> 6547;
6554 -> 6553;
6554 -> 6547;
6555 -> 6553;
6555 -> 6547;
6556 -> 6547;
6557 -> 6553;
6557 -> 6556;
6558 -> 6557;
6558 -> 6547;
6559 -> 6547;
6560 -> 6558;
6560 -> 6559;
6561 -> 6547;
6562 -> 6560;
6562 -> 6561;
6563 -> 6562;
6564 -> 6563;
6564 -> 6553;
6565 -> 6563;
6566 -> 6563;
6567 -> 6563;
6567 -> 6562;
6568 -> 6562;
6569 -> 6567;
6569 -> 6568;
6570 -> 6569;
6570 -> 6562;
6571 -> 6567;
6571 -> 6562;
6572 -> 6562;
6573 -> 6571;
6573 -> 6572;
6574 -> 6571;
6574 -> 6572;
6575 -> 6571;
6575 -> 6572;
6576 -> 6571;
6576 -> 6572;
6577 -> 6573;
6577 -> 6572;
6578 -> 6574;
6578 -> 6572;
6579 -> 6575;
6579 -> 6572;
6580 -> 6572;
6581 -> 6579;
6581 -> 6580;
6582 -> 6580;
6583 -> 6581;
6583 -> 6571;
6583 -> 6580;
6584 -> 6581;
6584 -> 6571;
6584 -> 6580;
6585 -> 6582;
6585 -> 6580;
6586 -> 6585;
6586 -> 6572;
6587 -> 6576;
6587 -> 6572;
6588 -> 6577;
6588 -> 6578;
6588 -> 6586;
6588 -> 6587;
6588 -> 6571;
6588 -> 6572;
6589 -> 6588;
6589 -> 6572;
6590 -> 6588;
6590 -> 6572;
6591 -> 6589;
6591 -> 6572;
6592 -> 6589;
6592 -> 6572;
6593 -> 6553;
6593 -> 6547;
6594 -> 6588;
6594 -> 6547;
6595 -> 6544;
6596 -> 6544;
6597 -> 6545;
6597 -> 6596;
6598 -> 6597;
6598 -> 6588;
6598 -> 6596;
6599 -> 6596;
6600 -> 6599;
6600 -> 6544;
6601 -> 6588;
6601 -> 6544;
6602 -> 6595;
6602 -> 6544;
6603 -> 6601;
6603 -> 6602;
6603 -> 6545;
6603 -> 6588;
6603 -> 6544;
6604 -> 6544;
6605 -> 6603;
6605 -> 6604;
6606 -> 6603;
6606 -> 6604;
6607 -> 6603;
6607 -> 6604;
6608 -> 6603;
6608 -> 6604;
6609 -> 6603;
6609 -> 6604;
6610 -> 6605;
6610 -> 6604;
6611 -> 6606;
6611 -> 6604;
6612 -> 6607;
6612 -> 6604;
6613 -> 6608;
6613 -> 6604;
6614 -> 6604;
6615 -> 6613;
6615 -> 6614;
6616 -> 6614;
6617 -> 6615;
6617 -> 6603;
6617 -> 6614;
6618 -> 6615;
6618 -> 6603;
6618 -> 6614;
6619 -> 6616;
6619 -> 6614;
6620 -> 6619;
6620 -> 6604;
6621 -> 6609;
6621 -> 6604;
6622 -> 6610;
6622 -> 6611;
6622 -> 6612;
6622 -> 6620;
6622 -> 6621;
6622 -> 6603;
6622 -> 6604;
6623 -> 6622;
6623 -> 6604;
6624 -> 6622;
6624 -> 6604;
6625 -> 6623;
6625 -> 6604;
6626 -> 6623;
6626 -> 6604;
6627 -> 6622;
6627 -> 6543;
6628 -> 6627;
6628 -> 6543;
6629 -> 6543;
6630 -> 6629;
6630 -> 6628;
6631 -> 6630;
6631 -> 6543;
6632 -> 6543;
6633 -> 6631;
6633 -> 6632;
6634 -> 0;
6634 -> 6633;
6635 -> 6633;
6636 -> 6634;
6636 -> 6635;
6637 -> 6636;
6637 -> 6635;
6638 -> 6635;
6639 -> 6637;
6639 -> 6638;
6640 -> 6639;
6640 -> 0;
6640 -> 6638;
6641 -> 6640;
6642 -> 6636;
6643 -> 6636;
6644 -> 6635;
6644 -> 6636;
6645 -> 6644;
6645 -> 6633;
6646 -> 6633;
6647 -> 6646;
6647 -> 6645;
6648 -> 6646;
6648 -> 6645;
6649 -> 6648;
6649 -> 6646;
6650 -> 6646;
6651 -> 6649;
6651 -> 6650;
6652 -> 6648;
6652 -> 6646;
6653 -> 6648;
6653 -> 6646;
6654 -> 6648;
6655 -> 6648;
6656 -> 6648;
6657 -> 6648;
6658 -> 6657;
6658 -> 6648;
6659 -> 6648;
6659 -> 6657;
6660 -> 6659;
6660 -> 6657;
6661 -> 6660;
6661 -> 6657;
6662 -> 6660;
6662 -> 6657;
6663 -> 6648;
6663 -> 6646;
6664 -> 6657;
6664 -> 6646;
6665 -> 6646;
6666 -> 6665;
6666 -> 6657;
6667 -> 6665;
6668 -> 6667;
6668 -> 6646;
6669 -> 6657;
6669 -> 6646;
6670 -> 6669;
6670 -> 6646;
6671 -> 6670;
6671 -> 6657;
6671 -> 6646;
6672 -> 6670;
6672 -> 6657;
6672 -> 6646;
6673 -> 6669;
6673 -> 6633;
6674 -> 6673;
6674 -> 6633;
6675 -> 6520;
6676 -> 6536;
6676 -> 6674;
6676 -> 6675;
6676 -> 6520;
6677 -> 0;
6677 -> 6520;
6678 -> 6520;
6679 -> 6677;
6679 -> 6678;
6680 -> 6521;
6680 -> 6678;
6681 -> 6679;
6681 -> 6678;
6682 -> 6678;
6683 -> 6681;
6683 -> 6682;
6684 -> 6683;
6684 -> 0;
6684 -> 6682;
6685 -> 6684;
6686 -> 6680;
6686 -> 6674;
6686 -> 6678;
6687 -> 6686;
6687 -> 6679;
6687 -> 6678;
6688 -> 6687;
6688 -> 6674;
6689 -> 6687;
6690 -> 6687;
6691 -> 6535;
6691 -> 6520;
6692 -> 6536;
6692 -> 6520;
6693 -> 6687;
6693 -> 6520;
6694 -> 6520;
6695 -> 6693;
6695 -> 6694;
6696 -> 6694;
6697 -> 6693;
6697 -> 6696;
6697 -> 6520;
6698 -> 6693;
6698 -> 6694;
6699 -> 6693;
6699 -> 6694;
6700 -> 6693;
6700 -> 6694;
6701 -> 6693;
6701 -> 6694;
6702 -> 6693;
6702 -> 6694;
6703 -> 6693;
6703 -> 6694;
6704 -> 6698;
6704 -> 6694;
6705 -> 6699;
6705 -> 6694;
6706 -> 6700;
6706 -> 6694;
6707 -> 6701;
6707 -> 6694;
6708 -> 6702;
6708 -> 6694;
6709 -> 6694;
6710 -> 6708;
6710 -> 6709;
6711 -> 6709;
6712 -> 6710;
6712 -> 6697;
6712 -> 6709;
6713 -> 6710;
6713 -> 6697;
6713 -> 6709;
6714 -> 6711;
6714 -> 6709;
6715 -> 6714;
6715 -> 6694;
6716 -> 6703;
6716 -> 6694;
6717 -> 6704;
6717 -> 6705;
6717 -> 6706;
6717 -> 6707;
6717 -> 6715;
6717 -> 6716;
6717 -> 6697;
6717 -> 6694;
6718 -> 6717;
6718 -> 6694;
6719 -> 6717;
6719 -> 6694;
6720 -> 6718;
6720 -> 6694;
6721 -> 6718;
6721 -> 6694;
6722 -> 6717;
6722 -> 6520;
6723 -> 0;
6723 -> 6520;
6724 -> 6520;
6725 -> 6520;
6726 -> 6722;
6726 -> 6725;
6727 -> 6723;
6727 -> 6725;
6728 -> 6724;
6728 -> 6725;
6729 -> 6521;
6729 -> 6725;
6730 -> 6725;
6731 -> 6729;
6731 -> 6730;
6732 -> 6730;
6733 -> 6731;
6733 -> 6717;
6733 -> 6732;
6734 -> 6733;
6734 -> 6717;
6734 -> 6732;
6735 -> 6734;
6735 -> 6730;
6736 -> 6735;
6736 -> 6725;
6737 -> 6727;
6737 -> 6725;
6738 -> 6725;
6739 -> 6737;
6739 -> 6738;
6740 -> 6739;
6740 -> 6738;
6741 -> 6738;
6742 -> 6740;
6742 -> 6741;
6743 -> 6742;
6743 -> 6741;
6744 -> 6743;
6745 -> 6738;
6746 -> 6739;
6746 -> 6738;
6747 -> 0;
6747 -> 6746;
6748 -> 6727;
6748 -> 6725;
6749 -> 6727;
6749 -> 6725;
6750 -> 6725;
6751 -> 6729;
6751 -> 6750;
6752 -> 6750;
6753 -> 6751;
6753 -> 6717;
6753 -> 6752;
6754 -> 6753;
6754 -> 6717;
6754 -> 6752;
6755 -> 6754;
6755 -> 6750;
6756 -> 6755;
6756 -> 6725;
6757 -> 6725;
6758 -> 6749;
6758 -> 6757;
6759 -> 6756;
6759 -> 6757;
6760 -> 6758;
6760 -> 6757;
6761 -> 6757;
6762 -> 6760;
6762 -> 6761;
6763 -> 6759;
6763 -> 6761;
6764 -> 6762;
6764 -> 6761;
6765 -> 6761;
6766 -> 6764;
6766 -> 6765;
6767 -> 6766;
6767 -> 6765;
6768 -> 6767;
6769 -> 6761;
6770 -> 6768;
6770 -> 6769;
6770 -> 6761;
6771 -> 6763;
6771 -> 6717;
6771 -> 6761;
6772 -> 6762;
6772 -> 6761;
6773 -> 6761;
6774 -> 6772;
6774 -> 6773;
6775 -> 6774;
6775 -> 6773;
6776 -> 6773;
6777 -> 6775;
6777 -> 6776;
6778 -> 6777;
6778 -> 6776;
6779 -> 6778;
6780 -> 6773;
6781 -> 6774;
6781 -> 6773;
6782 -> 0;
6782 -> 6781;
6783 -> 6771;
6783 -> 6782;
6783 -> 6761;
6784 -> 6783;
6785 -> 6784;
6785 -> 6757;
6786 -> 6725;
6787 -> 6785;
6787 -> 6786;
6787 -> 6725;
6788 -> 6726;
6788 -> 6725;
6789 -> 6788;
6789 -> 6520;
6790 -> 6536;
6790 -> 6520;
6791 -> 6521;
6791 -> 6717;
6791 -> 6790;
6791 -> 6520;
6792 -> 6789;
6792 -> 6519;
6793 -> 6493;
6793 -> 6792;
6793 -> 6791;
6793 -> 6482;
6794 -> 6493;
6794 -> 6494;
6795 -> 6793;
6795 -> 6494;
6796 -> 6494;
6797 -> 6793;
6797 -> 6796;
6797 -> 6494;
6798 -> 6793;
6798 -> 6494;
6799 -> 6793;
6799 -> 6494;
6800 -> 6793;
6800 -> 6494;
6801 -> 6494;
6802 -> 6800;
6802 -> 6801;
6803 -> 6802;
6803 -> 6494;
6804 -> 6494;
6805 -> 6803;
6805 -> 6804;
6806 -> 6494;
6807 -> 6800;
6807 -> 6806;
6808 -> 6806;
6809 -> 6806;
6810 -> 6808;
6810 -> 6809;
6811 -> 6808;
6811 -> 6494;
6812 -> 6494;
6813 -> 6800;
6813 -> 6812;
6814 -> 6812;
6815 -> 6813;
6815 -> 6814;
6815 -> 6812;
6816 -> 6812;
6817 -> 6813;
6817 -> 6494;
6818 -> 6799;
6818 -> 6494;
6819 -> 6494;
6820 -> 6818;
6820 -> 6819;
6821 -> 6800;
6821 -> 6819;
6822 -> 6820;
6822 -> 6819;
6823 -> 6822;
6824 -> 6821;
6824 -> 6823;
6825 -> 6824;
6825 -> 6823;
6826 -> 6824;
6826 -> 6822;
6827 -> 6822;
6828 -> 6826;
6828 -> 6827;
6829 -> 6822;
6830 -> 6821;
6830 -> 6829;
6831 -> 6830;
6831 -> 6822;
6832 -> 6822;
6833 -> 6831;
6833 -> 6832;
6834 -> 6828;
6834 -> 6833;
6834 -> 6822;
6835 -> 6822;
6836 -> 6821;
6836 -> 6835;
6837 -> 6836;
6837 -> 6822;
6838 -> 6822;
6839 -> 6837;
6839 -> 6838;
6840 -> 6834;
6840 -> 6839;
6840 -> 6822;
6841 -> 6817;
6841 -> 6494;
6842 -> 0;
6842 -> 6494;
6843 -> 6494;
6844 -> 6494;
6845 -> 6841;
6845 -> 6844;
6846 -> 6842;
6846 -> 6844;
6847 -> 6843;
6847 -> 6844;
6848 -> 6800;
6848 -> 6844;
6849 -> 6844;
6850 -> 6848;
6850 -> 6849;
6851 -> 6849;
6852 -> 6850;
6852 -> 6851;
6853 -> 6852;
6853 -> 6851;
6854 -> 6853;
6854 -> 6849;
6855 -> 6854;
6855 -> 6844;
6856 -> 6846;
6856 -> 6844;
6857 -> 6844;
6858 -> 6856;
6858 -> 6857;
6859 -> 6858;
6859 -> 6857;
6860 -> 6857;
6861 -> 6859;
6861 -> 6860;
6862 -> 6861;
6862 -> 6860;
6863 -> 6862;
6864 -> 6857;
6865 -> 6858;
6865 -> 6857;
6866 -> 0;
6866 -> 6865;
6867 -> 6846;
6867 -> 6844;
6868 -> 6846;
6868 -> 6844;
6869 -> 6844;
6870 -> 6848;
6870 -> 6869;
6871 -> 6869;
6872 -> 6870;
6872 -> 6871;
6873 -> 6872;
6873 -> 6871;
6874 -> 6873;
6874 -> 6869;
6875 -> 6874;
6875 -> 6844;
6876 -> 6844;
6877 -> 6868;
6877 -> 6876;
6878 -> 6875;
6878 -> 6876;
6879 -> 6877;
6879 -> 6876;
6880 -> 6876;
6881 -> 6879;
6881 -> 6880;
6882 -> 6878;
6882 -> 6880;
6883 -> 6881;
6883 -> 6880;
6884 -> 6880;
6885 -> 6883;
6885 -> 6884;
6886 -> 6885;
6886 -> 6884;
6887 -> 6886;
6888 -> 6880;
6889 -> 6887;
6889 -> 6888;
6889 -> 6880;
6890 -> 6882;
6890 -> 6880;
6891 -> 6881;
6891 -> 6880;
6892 -> 6880;
6893 -> 6891;
6893 -> 6892;
6894 -> 6893;
6894 -> 6892;
6895 -> 6892;
6896 -> 6894;
6896 -> 6895;
6897 -> 6896;
6897 -> 6895;
6898 -> 6897;
6899 -> 6892;
6900 -> 6893;
6900 -> 6892;
6901 -> 0;
6901 -> 6900;
6902 -> 6890;
6902 -> 6901;
6902 -> 6880;
6903 -> 6902;
6904 -> 6903;
6904 -> 6876;
6905 -> 6844;
6906 -> 6904;
6906 -> 6905;
6906 -> 6844;
6907 -> 6811;
6907 -> 6494;
6908 -> 6494;
6909 -> 6907;
6909 -> 6908;
6910 -> 6800;
6910 -> 6908;
6911 -> 6909;
6911 -> 6807;
6911 -> 6908;
6912 -> 6908;
6913 -> 6911;
6913 -> 6912;
6914 -> 6910;
6914 -> 6913;
6914 -> 6807;
6914 -> 6912;
6915 -> 6912;
6916 -> 6910;
6916 -> 6915;
6916 -> 6912;
6917 -> 6908;
6918 -> 6494;
6919 -> 6494;
6920 -> 6793;
6920 -> 6919;
6921 -> 6919;
6922 -> 6920;
6922 -> 6919;
6923 -> 6920;
6923 -> 6919;
6924 -> 6921;
6924 -> 6919;
6925 -> 6924;
6925 -> 6494;
6926 -> 6793;
6926 -> 6494;
6927 -> 6793;
6927 -> 6494;
6928 -> 6926;
6928 -> 6494;
6929 -> 6926;
6929 -> 6494;
6930 -> 6793;
6930 -> 6494;
6931 -> 6480;
6932 -> 6845;
6932 -> 6931;
6933 -> 6932;
6933 -> 6480;
6934 -> 6272;
6935 -> 6272;
6936 -> 6273;
6936 -> 6935;
6937 -> 6936;
6937 -> 6845;
6937 -> 6935;
6938 -> 6937;
6938 -> 6272;
6939 -> 6272;
6940 -> 6938;
6940 -> 6939;
6941 -> 6272;
6942 -> 6273;
6942 -> 6941;
6943 -> 6942;
6943 -> 6845;
6943 -> 6941;
6944 -> 6943;
6944 -> 6272;
6945 -> 6272;
6946 -> 6944;
6946 -> 6945;
6947 -> 6946;
6948 -> 6273;
6948 -> 6947;
6949 -> 0;
6949 -> 6947;
6950 -> 6947;
6951 -> 6949;
6951 -> 6950;
6952 -> 6948;
6952 -> 6950;
6953 -> 6951;
6953 -> 6950;
6954 -> 6950;
6955 -> 6953;
6955 -> 6954;
6956 -> 6955;
6956 -> 0;
6956 -> 6954;
6957 -> 6956;
6958 -> 6952;
6958 -> 6951;
6958 -> 6950;
6959 -> 6958;
6959 -> 6845;
6960 -> 6958;
6961 -> 6958;
6962 -> 6948;
6962 -> 6845;
6962 -> 6958;
6962 -> 6947;
6963 -> 6947;
6964 -> 6958;
6964 -> 6947;
6965 -> 6962;
6965 -> 6947;
6966 -> 6963;
6966 -> 6947;
6967 -> 6964;
6967 -> 6965;
6967 -> 6966;
6967 -> 6948;
6967 -> 6962;
6967 -> 6947;
6968 -> 6947;
6969 -> 6967;
6969 -> 6968;
6970 -> 6947;
6971 -> 6962;
6971 -> 6970;
6971 -> 6947;
6972 -> 6971;
6972 -> 6967;
6972 -> 6947;
6973 -> 6967;
6973 -> 6947;
6974 -> 6967;
6974 -> 6947;
6975 -> 0;
6975 -> 6974;
6976 -> 6947;
6977 -> 6947;
6978 -> 6973;
6978 -> 6977;
6979 -> 6975;
6979 -> 6977;
6980 -> 6976;
6980 -> 6977;
6981 -> 6948;
6981 -> 6977;
6982 -> 6977;
6983 -> 6981;
6983 -> 6982;
6984 -> 6982;
6985 -> 6983;
6985 -> 6967;
6985 -> 6984;
6986 -> 6985;
6986 -> 6967;
6986 -> 6984;
6987 -> 6986;
6987 -> 6982;
6988 -> 6987;
6988 -> 6977;
6989 -> 6979;
6989 -> 6977;
6990 -> 6977;
6991 -> 6989;
6991 -> 6990;
6992 -> 6991;
6992 -> 6990;
6993 -> 6990;
6994 -> 6992;
6994 -> 6993;
6995 -> 6994;
6995 -> 6993;
6996 -> 6995;
6997 -> 6990;
6998 -> 6991;
6998 -> 6990;
6999 -> 0;
6999 -> 6998;
7000 -> 6979;
7000 -> 6977;
7001 -> 6979;
7001 -> 6977;
7002 -> 6977;
7003 -> 6981;
7003 -> 7002;
7004 -> 7002;
7005 -> 7003;
7005 -> 6967;
7005 -> 7004;
7006 -> 7005;
7006 -> 6967;
7006 -> 7004;
7007 -> 7006;
7007 -> 7002;
7008 -> 7007;
7008 -> 6977;
7009 -> 6977;
7010 -> 7001;
7010 -> 7009;
7011 -> 7008;
7011 -> 7009;
7012 -> 7010;
7012 -> 7009;
7013 -> 7009;
7014 -> 7012;
7014 -> 7013;
7015 -> 7011;
7015 -> 7013;
7016 -> 7014;
7016 -> 7013;
7017 -> 7013;
7018 -> 7016;
7018 -> 7017;
7019 -> 7018;
7019 -> 7017;
7020 -> 7019;
7021 -> 7013;
7022 -> 7020;
7022 -> 7021;
7022 -> 7013;
7023 -> 7015;
7023 -> 6967;
7023 -> 7013;
7024 -> 7014;
7024 -> 7013;
7025 -> 7013;
7026 -> 7024;
7026 -> 7025;
7027 -> 7026;
7027 -> 7025;
7028 -> 7025;
7029 -> 7027;
7029 -> 7028;
7030 -> 7029;
7030 -> 7028;
7031 -> 7030;
7032 -> 7025;
7033 -> 7026;
7033 -> 7025;
7034 -> 0;
7034 -> 7033;
7035 -> 7023;
7035 -> 7034;
7035 -> 7013;
7036 -> 7035;
7037 -> 7036;
7037 -> 7009;
7038 -> 6977;
7039 -> 7037;
7039 -> 7038;
7039 -> 6977;
7040 -> 0;
7040 -> 6947;
7041 -> 6947;
7042 -> 7040;
7042 -> 7041;
7043 -> 6948;
7043 -> 7041;
7044 -> 7042;
7044 -> 7041;
7045 -> 7041;
7046 -> 7044;
7046 -> 7045;
7047 -> 7046;
7047 -> 0;
7047 -> 7045;
7048 -> 7047;
7049 -> 7043;
7049 -> 6967;
7049 -> 7041;
7050 -> 7049;
7050 -> 7042;
7050 -> 7041;
7051 -> 7050;
7051 -> 6967;
7052 -> 7050;
7053 -> 7050;
7054 -> 6967;
7054 -> 6947;
7055 -> 0;
7055 -> 7054;
7056 -> 6978;
7056 -> 6947;
7057 -> 6962;
7057 -> 6947;
7058 -> 7050;
7058 -> 6947;
7059 -> 7055;
7059 -> 7056;
7059 -> 7057;
7059 -> 7058;
7059 -> 6948;
7059 -> 6967;
7059 -> 7050;
7059 -> 6962;
7059 -> 6947;
7060 -> 6947;
7061 -> 7059;
7061 -> 7060;
7062 -> 7061;
7062 -> 7060;
7063 -> 7062;
7063 -> 7059;
7063 -> 7060;
7064 -> 7062;
7064 -> 7059;
7064 -> 7060;
7065 -> 7061;
7065 -> 7060;
7066 -> 7061;
7066 -> 7060;
7067 -> 7065;
7067 -> 7060;
7068 -> 7065;
7068 -> 7060;
7069 -> 6962;
7069 -> 6947;
7070 -> 6948;
7070 -> 7061;
7070 -> 7069;
7070 -> 6962;
7070 -> 6947;
7071 -> 7061;
7071 -> 6946;
7072 -> 6272;
7073 -> 6934;
7073 -> 7072;
7073 -> 6272;
7074 -> 7071;
7074 -> 7072;
7074 -> 6272;
7075 -> 7073;
7075 -> 7074;
7075 -> 6272;
7076 -> 6845;
7076 -> 6272;
7077 -> 7076;
7077 -> 6272;
7078 -> 6934;
7078 -> 7077;
7079 -> 7071;
7079 -> 7077;
7080 -> 7077;
7080 -> 7078;
7080 -> 7079;
7080 -> 6273;
7080 -> 7070;
7081 -> 7080;
7081 -> 7077;
7082 -> 7080;
7082 -> 7077;
7083 -> 7081;
7083 -> 7080;
7083 -> 7077;
7084 -> 7081;
7084 -> 7080;
7084 -> 7077;
7085 -> 7080;
7085 -> 6271;
7086 -> 7085;
7086 -> 6227;
7087 -> 7086;
7087 -> 6227;
7088 -> 7086;
7088 -> 6203;
7089 -> 6204;
7089 -> 6203;
7090 -> 7088;
7090 -> 6203;
7091 -> 7089;
7091 -> 6203;
7092 -> 6203;
7093 -> 6203;
7094 -> 7086;
7095 -> 7086;
7095 -> 0;
7095 -> 7094;
7096 -> 7086;
7096 -> 0;
7096 -> 7095;
7097 -> 7086;
7097 -> 0;
7097 -> 7096;
7098 -> 6203;
7099 -> 7098;
7099 -> 7086;
7100 -> 7099;
7100 -> 6203;
7101 -> 6203;
7102 -> 7100;
7102 -> 7101;
7103 -> 7090;
7103 -> 6203;
7104 -> 6203;
7105 -> 6203;
7106 -> 7103;
7106 -> 7105;
7107 -> 7106;
7107 -> 6203;
7108 -> 6203;
7109 -> 7107;
7109 -> 7108;
7110 -> 0;
7110 -> 7109;
7111 -> 6203;
7111 -> 7086;
7112 -> 7103;
7112 -> 6203;
7113 -> 6128;
7113 -> 0;
7113 -> 6193;
7114 -> 6128;
7114 -> 6193;
7115 -> 6090;
7115 -> 6193;
7116 -> 6181;
7116 -> 6193;
7117 -> 7112;
7117 -> 6193;
7118 -> 7114;
7118 -> 7115;
7118 -> 7116;
7118 -> 7117;
7118 -> 6092;
7118 -> 7086;
7118 -> 7111;
7118 -> 6193;
7119 -> 6193;
7120 -> 7119;
7121 -> 7118;
7121 -> 7120;
7122 -> 7120;
7123 -> 7121;
7123 -> 7118;
7123 -> 7120;
7124 -> 7121;
7124 -> 7118;
7124 -> 7120;
7125 -> 7122;
7125 -> 7120;
7126 -> 7125;
7126 -> 7119;
7127 -> 7118;
7127 -> 7119;
7128 -> 7118;
7128 -> 7119;
7129 -> 7127;
7129 -> 7119;
7130 -> 7127;
7130 -> 7119;
7131 -> 7118;
7132 -> 7118;
7132 -> 0;
7132 -> 7131;
7133 -> 7118;
7133 -> 0;
7133 -> 7132;
7134 -> 7118;
7134 -> 0;
7134 -> 7133;
7135 -> 6089;
7136 -> 6092;
7136 -> 7135;
7137 -> 7136;
7137 -> 7118;
7137 -> 7135;
7138 -> 7137;
7138 -> 6089;
7139 -> 6089;
7140 -> 7138;
7140 -> 7139;
7141 -> 5734;
7142 -> 5734;
7143 -> 7118;
7143 -> 7142;
7144 -> 7143;
7144 -> 5734;
7145 -> 5734;
7146 -> 7144;
7146 -> 7145;
7147 -> 7118;
7147 -> 5727;
7148 -> 5727;
7149 -> 5730;
7149 -> 7148;
7150 -> 7147;
7150 -> 7148;
7151 -> 5729;
7151 -> 7148;
7152 -> 7148;
7153 -> 7148;
7154 -> 7151;
7154 -> 7153;
7155 -> 7153;
7156 -> 7154;
7156 -> 7155;
7157 -> 7155;
7158 -> 7156;
7158 -> 7118;
7158 -> 7157;
7159 -> 7158;
7159 -> 7118;
7159 -> 7157;
7160 -> 7159;
7160 -> 7155;
7161 -> 7160;
7161 -> 7153;
7162 -> 7161;
7162 -> 7148;
7163 -> 0;
7163 -> 7162;
7164 -> 7162;
7165 -> 7163;
7165 -> 7164;
7166 -> 7165;
7166 -> 7164;
7167 -> 7164;
7168 -> 7166;
7168 -> 7167;
7169 -> 7168;
7169 -> 0;
7169 -> 7167;
7170 -> 7169;
7171 -> 7165;
7171 -> 7118;
7172 -> 7165;
7173 -> 7165;
7174 -> 7149;
7174 -> 7148;
7175 -> 7150;
7175 -> 7148;
7176 -> 7165;
7176 -> 7148;
7177 -> 7174;
7177 -> 7175;
7177 -> 7176;
7177 -> 7151;
7177 -> 7118;
7177 -> 5477;
7177 -> 7165;
7177 -> 7148;
7178 -> 7148;
7179 -> 7178;
7180 -> 7177;
7180 -> 7179;
7181 -> 7179;
7182 -> 7180;
7182 -> 7177;
7182 -> 7179;
7183 -> 7180;
7183 -> 7177;
7183 -> 7179;
7184 -> 7181;
7184 -> 7179;
7185 -> 7184;
7185 -> 7178;
7186 -> 7178;
7187 -> 7186;
7187 -> 7178;
7188 -> 7177;
7188 -> 7178;
7189 -> 7177;
7189 -> 7178;
7190 -> 7188;
7190 -> 7178;
7191 -> 7188;
7191 -> 7178;
7192 -> 5485;
7192 -> 7177;
7192 -> 5482;
7193 -> 5629;
7193 -> 5482;
7194 -> 5482;
7195 -> 7193;
7195 -> 7194;
7196 -> 5485;
7196 -> 7194;
7197 -> 7195;
7197 -> 5527;
7197 -> 7194;
7198 -> 7194;
7199 -> 7197;
7199 -> 7198;
7200 -> 7196;
7200 -> 7198;
7201 -> 7200;
7201 -> 7177;
7201 -> 7199;
7201 -> 5516;
7201 -> 7198;
7202 -> 7200;
7202 -> 7177;
7202 -> 7198;
7203 -> 7198;
7204 -> 7200;
7204 -> 7177;
7204 -> 7202;
7204 -> 7203;
7204 -> 7198;
7205 -> 7204;
7206 -> 7205;
7206 -> 7200;
7206 -> 7204;
7207 -> 7194;
7208 -> 5482;
7209 -> 5450;
7209 -> 7177;
7209 -> 7192;
7209 -> 7202;
7209 -> 7206;
7209 -> 5444;
7210 -> 7209;
7210 -> 894;
7211 -> 898;
7211 -> 894;
7212 -> 7210;
7212 -> 7211;
7213 -> 7211;
7214 -> 7212;
7214 -> 7213;
7215 -> 5439;
7215 -> 7213;
7216 -> 7213;
7217 -> 7215;
7217 -> 7216;
7218 -> 7216;
7219 -> 7217;
7219 -> 7218;
7220 -> 7219;
7220 -> 7209;
7220 -> 7218;
7221 -> 7218;
7222 -> 7219;
7222 -> 7209;
7222 -> 7221;
7222 -> 7218;
7223 -> 7222;
7223 -> 7213;
7224 -> 7213;
7225 -> 7223;
7225 -> 7224;
7226 -> 7214;
7226 -> 7225;
7227 -> 7226;
7227 -> 894;
7228 -> 7226;
7228 -> 7209;
7228 -> 7222;
7228 -> 894;
7229 -> 894;
7230 -> 7228;
7230 -> 7229;
7231 -> 7228;
7231 -> 7229;
7232 -> 7228;
7232 -> 7229;
7233 -> 7227;
7233 -> 7229;
7234 -> 7230;
7234 -> 7229;
7235 -> 7231;
7235 -> 7229;
7236 -> 7232;
7236 -> 7229;
7237 -> 7229;
7238 -> 7237;
7238 -> 7234;
7238 -> 7235;
7238 -> 7236;
7238 -> 7228;
7238 -> 7229;
7239 -> 215;
7239 -> 214;
7240 -> 7238;
7240 -> 214;
7241 -> 214;
7242 -> 7240;
7242 -> 7241;
7243 -> 7241;
7244 -> 7240;
7244 -> 7241;
7245 -> 7240;
7245 -> 7241;
7246 -> 7240;
7246 -> 7241;
7247 -> 7240;
7247 -> 7241;
7248 -> 7245;
7248 -> 7241;
7249 -> 7248;
7250 -> 7247;
7250 -> 7249;
7251 -> 7250;
7251 -> 7240;
7251 -> 7249;
7252 -> 7251;
7252 -> 7248;
7253 -> 7248;
7254 -> 7252;
7254 -> 7253;
7254 -> 7248;
7255 -> 7241;
7256 -> 7247;
7256 -> 7255;
7257 -> 7256;
7257 -> 7240;
7257 -> 7255;
7258 -> 7257;
7258 -> 7241;
7259 -> 7244;
7259 -> 7258;
7259 -> 7240;
7259 -> 7241;
7260 -> 7246;
7260 -> 7241;
7261 -> 7260;
7262 -> 7247;
7262 -> 7261;
7263 -> 7262;
7263 -> 7259;
7263 -> 7261;
7264 -> 7263;
7264 -> 7260;
7265 -> 7260;
7266 -> 7264;
7266 -> 7265;
7266 -> 7260;
7267 -> 7244;
7267 -> 7266;
7268 -> 7266;
7269 -> 7267;
7269 -> 7268;
7270 -> 7268;
7271 -> 7267;
7271 -> 7268;
7272 -> 7267;
7272 -> 7268;
7273 -> 7272;
7273 -> 7270;
7273 -> 7268;
7274 -> 7271;
7274 -> 7273;
7274 -> 7270;
7274 -> 7268;
7275 -> 7247;
7275 -> 7249;
7276 -> 7275;
7276 -> 7274;
7276 -> 7249;
7277 -> 7276;
7277 -> 7248;
7278 -> 7277;
7278 -> 7253;
7278 -> 7248;
7279 -> 7247;
7279 -> 7255;
7280 -> 7255;
7281 -> 7279;
7281 -> 7280;
7282 -> 7281;
7282 -> 7274;
7282 -> 7280;
7283 -> 7282;
7283 -> 7255;
7284 -> 7255;
7285 -> 7283;
7285 -> 7284;
7286 -> 7285;
7286 -> 7284;
7287 -> 7286;
7288 -> 7247;
7288 -> 7261;
7289 -> 7287;
7290 -> 7275;
7290 -> 7287;
7290 -> 7249;
7291 -> 7290;
7291 -> 7248;
7292 -> 7291;
7292 -> 7253;
7292 -> 7248;
7293 -> 7287;
7294 -> 7293;
7295 -> 7247;
7295 -> 7249;
7296 -> 7249;
7297 -> 7296;
7297 -> 7248;
7298 -> 7297;
7298 -> 7253;
7298 -> 7248;
7299 -> 7293;
7300 -> 7247;
7300 -> 7261;
7301 -> 7261;
7301 -> 7260;
7302 -> 7301;
7302 -> 7265;
7302 -> 7260;
7303 -> 7299;
7304 -> 7275;
7304 -> 7303;
7304 -> 7249;
7305 -> 7304;
7305 -> 7248;
7306 -> 7305;
7306 -> 7253;
7306 -> 7248;
7307 -> 7303;
7308 -> 7307;
7309 -> 7307;
7310 -> 7275;
7310 -> 7309;
7310 -> 7249;
7311 -> 7310;
7311 -> 7248;
7312 -> 7311;
7312 -> 7253;
7312 -> 7248;
7313 -> 7309;
7314 -> 7313;
7315 -> 7313;
7316 -> 7315;
7317 -> 7316;
7318 -> 214;
7319 -> 7238;
7319 -> 7318;
7320 -> 7318;
7321 -> 7319;
7321 -> 7320;
7322 -> 7321;
7322 -> 7320;
7323 -> 7320;
7324 -> 7322;
7324 -> 7323;
7325 -> 7323;
7326 -> 7323;
7327 -> 7323;
7328 -> 7324;
7328 -> 7317;
7328 -> 7327;
7329 -> 7327;
7330 -> 7328;
7330 -> 7329;
7330 -> 7327;
7331 -> 7327;
7332 -> 7324;
7332 -> 7331;
7333 -> 7332;
7333 -> 7317;
7333 -> 7331;
7334 -> 7333;
7334 -> 7327;
7335 -> 7327;
7336 -> 7334;
7336 -> 7335;
7336 -> 7327;
7338 -> 7337;
7339 -> 7338;
7340 -> 7339;
7340 -> 7338;
7341 -> 7339;
7341 -> 7338;
7342 -> 7339;
7342 -> 7338;
7343 -> 7339;
7343 -> 7338;
7344 -> 0;
7344 -> 7339;
7344 -> 7338;
7345 -> 7338;
7345 -> 7337;
7346 -> 0;
7346 -> 7337;
7347 -> 7337;
7348 -> 7337;
7349 -> 7346;
7349 -> 7348;
7350 -> 7347;
7350 -> 7348;
7351 -> 7347;
7351 -> 7348;
7352 -> 7349;
7352 -> 7348;
7353 -> 7350;
7353 -> 7348;
7354 -> 7351;
7354 -> 7348;
7355 -> 7348;
7356 -> 7352;
7356 -> 7355;
7357 -> 7353;
7357 -> 7355;
7358 -> 7354;
7358 -> 7355;
7359 -> 7356;
7359 -> 7355;
7360 -> 7357;
7360 -> 7355;
7361 -> 7355;
7362 -> 7359;
7362 -> 7361;
7363 -> 7360;
7363 -> 7361;
7364 -> 7362;
7364 -> 7361;
7365 -> 0;
7365 -> 7361;
7366 -> 7361;
7367 -> 7364;
7367 -> 7365;
7367 -> 7366;
7367 -> 7317;
7367 -> 7361;
7368 -> 7363;
7368 -> 7361;
7369 -> 7367;
7369 -> 7368;
7369 -> 7361;
7370 -> 952;
7370 -> 7355;
7371 -> 7370;
7371 -> 7358;
7371 -> 7355;
7372 -> 7355;
7373 -> 7355;
7374 -> 7371;
7374 -> 7373;
7375 -> 7372;
7375 -> 7373;
7376 -> 7372;
7376 -> 7373;
7377 -> 7372;
7377 -> 7373;
7378 -> 7373;
7379 -> 7377;
7379 -> 7378;
7380 -> 7379;
7380 -> 7378;
7381 -> 7379;
7381 -> 7378;
7382 -> 7378;
7383 -> 7378;
7384 -> 7382;
7384 -> 7383;
7385 -> 7384;
7385 -> 7383;
7386 -> 7384;
7386 -> 7383;
7387 -> 7384;
7387 -> 7383;
7388 -> 7384;
7388 -> 7383;
7389 -> 7384;
7389 -> 7383;
7390 -> 7384;
7390 -> 7383;
7391 -> 7384;
7391 -> 7383;
7392 -> 7384;
7392 -> 7383;
7393 -> 7383;
7394 -> 7393;
7394 -> 7384;
7394 -> 7383;
7395 -> 7383;
7396 -> 7395;
7396 -> 7384;
7396 -> 7383;
7397 -> 7383;
7398 -> 7397;
7398 -> 7384;
7398 -> 7383;
7399 -> 7383;
7400 -> 7399;
7400 -> 7384;
7400 -> 7383;
7401 -> 7382;
7401 -> 7379;
7401 -> 7378;
7402 -> 7377;
7402 -> 7373;
7403 -> 7377;
7403 -> 7373;
7404 -> 7377;
7404 -> 7373;
7405 -> 7377;
7405 -> 7373;
7406 -> 7377;
7406 -> 7373;
7407 -> 7377;
7407 -> 7373;
7408 -> 7377;
7408 -> 7373;
7409 -> 7377;
7409 -> 7373;
7410 -> 7377;
7410 -> 7373;
7411 -> 7377;
7411 -> 7373;
7412 -> 7373;
7413 -> 7412;
7413 -> 7373;
7414 -> 7413;
7414 -> 7377;
7414 -> 7373;
7415 -> 7373;
7416 -> 7415;
7416 -> 7373;
7417 -> 7416;
7417 -> 7377;
7417 -> 7373;
7418 -> 7377;
7418 -> 7373;
7419 -> 7377;
7419 -> 7373;
7420 -> 7373;
7421 -> 7374;
7421 -> 7420;
7421 -> 7373;
7422 -> 7374;
7422 -> 7377;
7422 -> 7373;
7423 -> 7373;
7424 -> 7423;
7424 -> 7377;
7424 -> 7373;
7425 -> 7373;
7426 -> 7425;
7426 -> 7377;
7426 -> 7373;
7427 -> 7373;
7428 -> 7373;
7429 -> 7427;
7429 -> 7428;
7430 -> 7429;
7430 -> 7428;
7431 -> 7429;
7431 -> 7428;
7432 -> 7429;
7432 -> 7428;
7433 -> 7428;
7434 -> 7433;
7434 -> 7429;
7434 -> 7428;
7435 -> 7428;
7436 -> 7435;
7436 -> 7429;
7436 -> 7428;
7437 -> 7427;
7437 -> 7377;
7437 -> 7373;
7438 -> 7377;
7438 -> 7373;
7439 -> 7375;
7439 -> 7377;
7439 -> 7373;
7440 -> 7376;
7440 -> 7377;
7440 -> 7373;
7441 -> 7372;
7441 -> 7348;
7442 -> 7441;
7442 -> 7348;
7443 -> 7348;
7444 -> 7442;
7444 -> 7443;
7445 -> 7444;
7445 -> 7443;
7446 -> 7443;
7447 -> 7443;
7448 -> 7445;
7448 -> 7447;
7449 -> 7446;
7449 -> 7447;
7450 -> 7446;
7450 -> 7447;
7451 -> 7446;
7451 -> 7447;
7452 -> 7446;
7452 -> 7447;
7453 -> 7446;
7453 -> 7447;
7454 -> 7448;
7454 -> 7447;
7455 -> 7451;
7455 -> 7447;
7456 -> 7449;
7456 -> 7447;
7457 -> 7450;
7457 -> 7447;
7458 -> 7447;
7459 -> 7447;
7460 -> 7452;
7460 -> 7447;
7461 -> 7447;
7462 -> 7454;
7462 -> 7461;
7463 -> 7455;
7463 -> 7461;
7464 -> 7456;
7464 -> 7461;
7465 -> 7457;
7465 -> 7461;
7466 -> 7458;
7466 -> 7461;
7467 -> 7459;
7467 -> 7461;
7468 -> 7460;
7468 -> 7461;
7469 -> 7453;
7469 -> 7461;
7470 -> 7469;
7470 -> 7461;
7471 -> 7469;
7471 -> 7461;
7472 -> 7469;
7472 -> 7461;
7473 -> 7469;
7473 -> 7461;
7474 -> 7469;
7474 -> 7461;
7475 -> 7469;
7475 -> 7461;
7476 -> 7469;
7476 -> 7461;
7477 -> 7469;
7477 -> 7461;
7478 -> 7469;
7478 -> 7461;
7479 -> 7469;
7479 -> 7461;
7480 -> 7469;
7480 -> 7461;
7481 -> 7469;
7481 -> 7461;
7482 -> 7469;
7482 -> 7461;
7483 -> 7462;
7483 -> 7469;
7483 -> 7461;
7484 -> 7463;
7484 -> 7469;
7484 -> 7461;
7485 -> 7466;
7485 -> 7469;
7485 -> 7461;
7486 -> 7468;
7486 -> 7469;
7486 -> 7461;
7487 -> 7461;
7488 -> 7487;
7488 -> 7469;
7488 -> 7461;
7489 -> 7461;
7490 -> 7464;
7490 -> 7489;
7490 -> 7461;
7491 -> 7490;
7491 -> 7469;
7491 -> 7461;
7492 -> 7461;
7493 -> 7469;
7493 -> 7492;
7494 -> 7493;
7494 -> 7491;
7494 -> 7492;
7495 -> 7494;
7495 -> 7461;
7496 -> 7495;
7496 -> 7466;
7496 -> 7461;
7497 -> 7496;
7498 -> 7497;
7498 -> 7469;
7498 -> 7496;
7499 -> 7496;
7500 -> 7499;
7500 -> 7469;
7500 -> 7496;
7501 -> 7461;
7502 -> 7469;
7502 -> 7501;
7503 -> 7502;
7503 -> 7491;
7503 -> 7501;
7504 -> 7503;
7504 -> 7461;
7505 -> 7467;
7505 -> 7504;
7505 -> 7461;
7506 -> 7505;
7506 -> 7468;
7506 -> 7446;
7506 -> 7461;
7507 -> 7506;
7508 -> 7469;
7508 -> 7507;
7509 -> 7507;
7510 -> 7507;
7511 -> 7508;
7511 -> 7483;
7511 -> 7401;
7511 -> 7510;
7512 -> 7511;
7512 -> 7369;
7512 -> 7510;
7513 -> 7508;
7513 -> 7483;
7513 -> 7507;
7514 -> 7508;
7514 -> 7484;
7514 -> 7507;
7515 -> 7507;
7516 -> 1164;
7516 -> 7512;
7517 -> 7512;
7517 -> 7401;
7517 -> 7381;
7517 -> 7422;
7517 -> 7424;
7517 -> 7426;
7517 -> 7406;
7517 -> 7437;
7517 -> 7439;
7517 -> 7440;
7517 -> 7410;
7517 -> 7411;
7517 -> 7414;
7517 -> 7417;
7517 -> 7418;
7517 -> 7438;
7517 -> 7369;
7517 -> 7394;
7517 -> 7396;
7517 -> 7390;
7517 -> 7400;
7517 -> 7398;
7517 -> 7397;
7517 -> 7413;
7517 -> 7416;
7517 -> 7423;
7517 -> 7425;
7517 -> 7434;
7517 -> 7436;
7517 -> 7433;
7517 -> 7435;
7518 -> 7512;
7519 -> 7517;
7519 -> 7512;
7520 -> 7512;
7521 -> 7512;
7522 -> 7517;
7523 -> 7517;
7523 -> 7522;
7524 -> 7522;
7525 -> 7523;
7525 -> 7524;
7526 -> 7524;
7527 -> 7525;
7527 -> 7526;
7527 -> 7524;
7528 -> 7525;
7528 -> 7524;
7529 -> 7517;
7529 -> 7527;
7530 -> 7527;
7531 -> 7529;
7531 -> 7530;
7532 -> 7530;
7533 -> 7531;
7533 -> 7532;
7533 -> 7530;
7534 -> 7517;
7535 -> 7512;
7536 -> 7512;
7537 -> 7517;
7537 -> 7536;
7537 -> 7512;
7538 -> 7517;
7538 -> 7512;
7539 -> 7512;
7540 -> 7538;
7540 -> 7539;
7541 -> 7539;
7542 -> 7539;
7543 -> 7540;
7543 -> 7542;
7543 -> 7539;
7544 -> 7543;
7545 -> 7541;
7545 -> 7539;
7546 -> 7545;
7546 -> 7512;
7547 -> 7512;
7548 -> 7546;
7548 -> 7547;
7549 -> 7512;
7549 -> 7547;
7550 -> 7547;
7551 -> 7549;
7551 -> 7517;
7551 -> 7550;
7551 -> 7547;
7552 -> 7551;
7553 -> 7552;
7553 -> 7512;
7554 -> 7512;
7555 -> 7553;
7555 -> 7512;
7556 -> 7512;
7557 -> 7517;
7557 -> 0;
7557 -> 7512;
7558 -> 7512;
7559 -> 7517;
7560 -> 7517;
7561 -> 7559;
7561 -> 7560;
7562 -> 7559;
7562 -> 7560;
7563 -> 7559;
7563 -> 7560;
7564 -> 7562;
7564 -> 1422;
7564 -> 7560;
7565 -> 7512;
7566 -> 7555;
7566 -> 7565;
7566 -> 7512;
7567 -> 7562;
7567 -> 7512;
7568 -> 7567;
7568 -> 7512;
7569 -> 7512;
7570 -> 7568;
7570 -> 7569;
7570 -> 7512;
7571 -> 7512;
7571 -> 7479;
7572 -> 7512;
7572 -> 7479;
7573 -> 7568;
7573 -> 7572;
7573 -> 7512;
7574 -> 7512;
7575 -> 7512;
7576 -> 7562;
7576 -> 7575;
7577 -> 7576;
7577 -> 7512;
7578 -> 7506;
7579 -> 7447;
7580 -> 7579;
7580 -> 7453;
7580 -> 7447;
7581 -> 7453;
7581 -> 7447;
7582 -> 7453;
7582 -> 7447;
7583 -> 7453;
7583 -> 7447;
7584 -> 7453;
7584 -> 7447;
7585 -> 7453;
7585 -> 7447;
7586 -> 7453;
7586 -> 7447;
7587 -> 7447;
7588 -> 7587;
7588 -> 7453;
7588 -> 7447;
7589 -> 7453;
7589 -> 7588;
7589 -> 7447;
7590 -> 7447;
7591 -> 7590;
7591 -> 7453;
7591 -> 7447;
7592 -> 7446;
7592 -> 7348;
7593 -> 7348;
7594 -> 7592;
7594 -> 7593;
7595 -> 7594;
7595 -> 7593;
7596 -> 0;
7596 -> 7593;
7597 -> 7593;
7598 -> 7595;
7598 -> 7597;
7599 -> 7596;
7599 -> 7597;
7600 -> 7594;
7600 -> 7597;
7601 -> 7597;
7602 -> 7600;
7602 -> 7583;
7602 -> 7601;
7602 -> 7597;
7603 -> 7598;
7603 -> 7597;
7604 -> 7597;
7605 -> 7603;
7605 -> 7604;
7606 -> 7604;
7607 -> 7604;
7608 -> 7605;
7608 -> 7603;
7608 -> 7604;
7609 -> 7604;
7610 -> 7604;
7611 -> 7608;
7611 -> 7610;
7612 -> 7609;
7612 -> 7610;
7613 -> 7611;
7613 -> 7603;
7613 -> 7610;
7614 -> 7613;
7614 -> 7612;
7614 -> 7610;
7615 -> 7611;
7615 -> 7613;
7615 -> 7610;
7616 -> 7615;
7616 -> 7612;
7616 -> 7610;
7617 -> 7611;
7617 -> 7615;
7617 -> 7610;
7618 -> 7617;
7618 -> 7612;
7618 -> 7610;
7619 -> 7611;
7619 -> 7617;
7619 -> 7610;
7620 -> 7619;
7620 -> 7612;
7620 -> 7610;
7621 -> 7606;
7621 -> 7604;
7622 -> 7609;
7622 -> 7604;
7623 -> 7607;
7623 -> 7604;
7624 -> 0;
7624 -> 7604;
7625 -> 7621;
7625 -> 7622;
7625 -> 7623;
7625 -> 7624;
7625 -> 7605;
7625 -> 7619;
7625 -> 7613;
7625 -> 7615;
7625 -> 7617;
7625 -> 7614;
7625 -> 7616;
7625 -> 7618;
7625 -> 7620;
7625 -> 7604;
7626 -> 7604;
7627 -> 7625;
7627 -> 7626;
7628 -> 7627;
7628 -> 7625;
7628 -> 7626;
7629 -> 7625;
7629 -> 7626;
7630 -> 7626;
7631 -> 7629;
7631 -> 7630;
7632 -> 7631;
7632 -> 7628;
7632 -> 7630;
7633 -> 7630;
7634 -> 7631;
7634 -> 7628;
7634 -> 7633;
7634 -> 7630;
7635 -> 7631;
7635 -> 7628;
7635 -> 7634;
7636 -> 7635;
7636 -> 7626;
7637 -> 7636;
7637 -> 7629;
7637 -> 7626;
7638 -> 7625;
7638 -> 7626;
7639 -> 7638;
7639 -> 7637;
7639 -> 7626;
7640 -> 7625;
7640 -> 7626;
7641 -> 7625;
7641 -> 7626;
7642 -> 7626;
7643 -> 7640;
7643 -> 7639;
7643 -> 7642;
7643 -> 7626;
7644 -> 0;
7644 -> 7604;
7645 -> 7604;
7646 -> 7644;
7646 -> 7645;
7647 -> 7605;
7647 -> 7645;
7648 -> 7646;
7648 -> 7645;
7649 -> 7645;
7650 -> 7648;
7650 -> 7649;
7651 -> 7650;
7651 -> 0;
7651 -> 7649;
7652 -> 7651;
7653 -> 7645;
7654 -> 7647;
7654 -> 7653;
7655 -> 7654;
7655 -> 7639;
7655 -> 7653;
7656 -> 7655;
7656 -> 7645;
7657 -> 7645;
7658 -> 7656;
7658 -> 7657;
7659 -> 7658;
7659 -> 7645;
7660 -> 7659;
7660 -> 7646;
7660 -> 7645;
7661 -> 7660;
7662 -> 7647;
7662 -> 7661;
7663 -> 7661;
7664 -> 7662;
7664 -> 7639;
7664 -> 7663;
7665 -> 7663;
7666 -> 7665;
7666 -> 7661;
7667 -> 7666;
7667 -> 7662;
7667 -> 7661;
7668 -> 7661;
7669 -> 7668;
7669 -> 7662;
7669 -> 7661;
7670 -> 7661;
7671 -> 7662;
7671 -> 7639;
7671 -> 7670;
7671 -> 7661;
7672 -> 7662;
7672 -> 7639;
7672 -> 7661;
7673 -> 7660;
7674 -> 7656;
7674 -> 7660;
7675 -> 7639;
7675 -> 7604;
7676 -> 7674;
7676 -> 7604;
7677 -> 7675;
7677 -> 7676;
7677 -> 7605;
7677 -> 7639;
7677 -> 7667;
7677 -> 7669;
7677 -> 7672;
7677 -> 7604;
7678 -> 7604;
7679 -> 7677;
7679 -> 7678;
7680 -> 7677;
7680 -> 7678;
7681 -> 7679;
7681 -> 7678;
7682 -> 7678;
7683 -> 7682;
7683 -> 7681;
7683 -> 7678;
7684 -> 7682;
7684 -> 7678;
7685 -> 7684;
7685 -> 7683;
7685 -> 7678;
7686 -> 7677;
7686 -> 7678;
7687 -> 7677;
7687 -> 7678;
7688 -> 7686;
7688 -> 7685;
7688 -> 7678;
7689 -> 7686;
7689 -> 7685;
7689 -> 7678;
7690 -> 7604;
7691 -> 7639;
7691 -> 7690;
7691 -> 7604;
7692 -> 7685;
7692 -> 7604;
7693 -> 7605;
7693 -> 7685;
7693 -> 7604;
7694 -> 7604;
7695 -> 7693;
7695 -> 7694;
7696 -> 7639;
7696 -> 7694;
7697 -> 7696;
7697 -> 7639;
7697 -> 7694;
7698 -> 7695;
7698 -> 7697;
7698 -> 7685;
7698 -> 7639;
7698 -> 7694;
7699 -> 7696;
7699 -> 7639;
7699 -> 7694;
7700 -> 7695;
7700 -> 7699;
7700 -> 7698;
7700 -> 7639;
7700 -> 7694;
7701 -> 7696;
7701 -> 7639;
7701 -> 7694;
7702 -> 7695;
7702 -> 7701;
7702 -> 7700;
7702 -> 7639;
7702 -> 7694;
7703 -> 7696;
7703 -> 7639;
7703 -> 7694;
7704 -> 7695;
7704 -> 7703;
7704 -> 7702;
7704 -> 7639;
7704 -> 7694;
7705 -> 7604;
7706 -> 7603;
7706 -> 7692;
7706 -> 7704;
7706 -> 7597;
7707 -> 7706;
7707 -> 7348;
7708 -> 7707;
7708 -> 7348;
7709 -> 7707;
7709 -> 7706;
7709 -> 7348;
7710 -> 7348;
7711 -> 7709;
7711 -> 7710;
7712 -> 7709;
7712 -> 7710;
7713 -> 7709;
7713 -> 7710;
7714 -> 7708;
7714 -> 7710;
7715 -> 7711;
7715 -> 7710;
7716 -> 7712;
7716 -> 7710;
7717 -> 7713;
7717 -> 7710;
7718 -> 7710;
7719 -> 7718;
7719 -> 7715;
7719 -> 7716;
7719 -> 7717;
7719 -> 7709;
7719 -> 7710;
7720 -> 7719;
7720 -> 7337;
7721 -> 7337;
7722 -> 7720;
7722 -> 7721;
7723 -> 7338;
7723 -> 7721;
7724 -> 7722;
7724 -> 7721;
7725 -> 7723;
7725 -> 7721;
7726 -> 7724;
7726 -> 7725;
7726 -> 7721;
7727 -> 7724;
7727 -> 7725;
7727 -> 7719;
7727 -> 7339;
7727 -> 7340;
7727 -> 7341;
7727 -> 7342;
7727 -> 7343;
7727 -> 7344;
7727 -> 7345;
7727 -> 7721;
7728 -> 7721;
7729 -> 7728;
7730 -> 7727;
7730 -> 7338;
7730 -> 7337;
7731 -> 7337;
7732 -> 7324;
7732 -> 7517;
7732 -> 7336;
7733 -> 7324;
7733 -> 7336;
7734 -> 7336;
7735 -> 7733;
7735 -> 7734;
7736 -> 7734;
7737 -> 7735;
7737 -> 7736;
7737 -> 7734;
7738 -> 7734;
7739 -> 0;
7739 -> 7734;
7740 -> 952;
7740 -> 7734;
7741 -> 7735;
7741 -> 7734;
7742 -> 5363;
7742 -> 7734;
7743 -> 7734;
7744 -> 7738;
7744 -> 7743;
7745 -> 7738;
7745 -> 7743;
7746 -> 7739;
7746 -> 7743;
7747 -> 7738;
7747 -> 7743;
7748 -> 7740;
7748 -> 7743;
7749 -> 7741;
7749 -> 7743;
7750 -> 7742;
7750 -> 7743;
7751 -> 7738;
7751 -> 7743;
7752 -> 7738;
7752 -> 7743;
7753 -> 7738;
7753 -> 7743;
7754 -> 7743;
7755 -> 7753;
7755 -> 7754;
7756 -> 7754;
7757 -> 7756;
7757 -> 7754;
7758 -> 7756;
7758 -> 7754;
7759 -> 7756;
7759 -> 7754;
7760 -> 7756;
7760 -> 7754;
7761 -> 0;
7761 -> 7756;
7761 -> 7754;
7762 -> 7753;
7762 -> 7743;
7763 -> 7753;
7763 -> 7743;
7764 -> 7753;
7764 -> 7743;
7765 -> 7753;
7765 -> 7743;
7766 -> 7753;
7766 -> 7743;
7767 -> 7753;
7767 -> 7743;
7768 -> 7753;
7768 -> 7743;
7769 -> 7753;
7769 -> 7743;
7770 -> 7743;
7771 -> 7749;
7771 -> 7770;
7771 -> 7743;
7772 -> 7743;
7773 -> 7748;
7773 -> 7772;
7773 -> 7743;
7774 -> 7743;
7775 -> 7744;
7775 -> 7774;
7775 -> 7743;
7776 -> 7744;
7776 -> 7753;
7776 -> 7743;
7777 -> 7744;
7777 -> 7743;
7778 -> 7777;
7778 -> 7745;
7778 -> 7743;
7779 -> 7778;
7779 -> 7753;
7779 -> 7743;
7780 -> 7746;
7780 -> 7753;
7780 -> 7743;
7781 -> 7748;
7781 -> 7753;
7781 -> 7743;
7782 -> 7747;
7782 -> 7743;
7783 -> 7782;
7783 -> 7753;
7783 -> 7743;
7784 -> 7752;
7784 -> 7743;
7785 -> 7749;
7785 -> 7784;
7786 -> 7785;
7786 -> 7753;
7786 -> 7743;
7787 -> 7743;
7788 -> 7785;
7788 -> 7787;
7789 -> 7788;
7789 -> 7517;
7789 -> 7787;
7790 -> 7789;
7790 -> 7743;
7791 -> 7790;
7791 -> 7753;
7791 -> 7743;
7792 -> 0;
7792 -> 7743;
7793 -> 7792;
7793 -> 7751;
7793 -> 7743;
7794 -> 7793;
7794 -> 7753;
7794 -> 7743;
7795 -> 7750;
7795 -> 7743;
7796 -> 7743;
7797 -> 7795;
7797 -> 7796;
7798 -> 7753;
7798 -> 7796;
7799 -> 7797;
7799 -> 7798;
7799 -> 7796;
7800 -> 7796;
7801 -> 7800;
7801 -> 7798;
7801 -> 7796;
7802 -> 7743;
7803 -> 7738;
7803 -> 7336;
7804 -> 7336;
7805 -> 7732;
7805 -> 7803;
7805 -> 7804;
7805 -> 7756;
7805 -> 7757;
7805 -> 7801;
7805 -> 7758;
7805 -> 7759;
7805 -> 7760;
7805 -> 7761;
7805 -> 7762;
7805 -> 7781;
7805 -> 7763;
7805 -> 7783;
7805 -> 7764;
7805 -> 7786;
7805 -> 7765;
7805 -> 7791;
7805 -> 7766;
7805 -> 7779;
7805 -> 7767;
7805 -> 7780;
7805 -> 7768;
7805 -> 7794;
7805 -> 7769;
7805 -> 7776;
7805 -> 7799;
7805 -> 7517;
7805 -> 0;
7805 -> 5362;
7805 -> 7336;
7806 -> 7324;
7806 -> 7805;
7806 -> 7336;
7807 -> 7323;
7808 -> 7325;
7808 -> 7807;
7808 -> 7323;
7809 -> 7806;
7809 -> 7323;
7810 -> 7320;
7811 -> 7809;
7811 -> 7810;
7811 -> 7320;
7812 -> 7809;
7812 -> 7320;
7813 -> 7812;
7813 -> 7318;
7814 -> 7319;
7814 -> 7318;
7815 -> 7318;
7816 -> 7814;
7816 -> 7815;
7817 -> 7813;
7817 -> 7815;
7818 -> 7815;
7819 -> 7816;
7819 -> 7818;
7819 -> 7815;
7820 -> 7816;
7820 -> 7805;
7820 -> 7815;
7821 -> 7815;
7822 -> 7820;
7822 -> 7821;
7823 -> 7820;
7823 -> 7821;
7824 -> 7817;
7824 -> 7821;
7825 -> 7821;
7826 -> 7822;
7826 -> 7825;
7826 -> 7821;
7827 -> 7822;
7827 -> 7805;
7827 -> 7821;
7828 -> 7821;
7829 -> 7828;
7829 -> 7815;
7830 -> 7829;
7830 -> 7318;
7831 -> 7830;
7831 -> 214;
7832 -> 7831;
7832 -> 214;
7833 -> 217;
7833 -> 214;
7834 -> 214;
7835 -> 7832;
7835 -> 7834;
7836 -> 7833;
7836 -> 7834;
7837 -> 7835;
7837 -> 7834;
7838 -> 7836;
7838 -> 7834;
7839 -> 7834;
7840 -> 7834;
7841 -> 7837;
7841 -> 7840;
7842 -> 7838;
7842 -> 7840;
7843 -> 7839;
7843 -> 7840;
7844 -> 7840;
7845 -> 7842;
7845 -> 7844;
7845 -> 7840;
7846 -> 7842;
7846 -> 7840;
7847 -> 7842;
7847 -> 7840;
7848 -> 7841;
7848 -> 7840;
7849 -> 7843;
7849 -> 7846;
7849 -> 7847;
7849 -> 7840;
7850 -> 7848;
7850 -> 7849;
7850 -> 7840;
7851 -> 7842;
7851 -> 7840;
7852 -> 7840;
7853 -> 7850;
7853 -> 7852;
7853 -> 7840;
7854 -> 7840;
7856 -> 7855;
7858 -> 7857;
7859 -> 7842;
7859 -> 7840;
7860 -> 7841;
7860 -> 7840;
7861 -> 7840;
7862 -> 7859;
7862 -> 7861;
7863 -> 7860;
7863 -> 7861;
7864 -> 7861;
7865 -> 7861;
7866 -> 7863;
7866 -> 7861;
7867 -> 7866;
7867 -> 7850;
7867 -> 7861;
7868 -> 7867;
7868 -> 7861;
7869 -> 7865;
7869 -> 7868;
7870 -> 7869;
7870 -> 7864;
7870 -> 7861;
7871 -> 7869;
7871 -> 7864;
7871 -> 7861;
7872 -> 7871;
7872 -> 7861;
7873 -> 7862;
7873 -> 7861;
7874 -> 7862;
7874 -> 7861;
7875 -> 7862;
7875 -> 7861;
7876 -> 7861;
7877 -> 7875;
7877 -> 7876;
7879 -> 7878;
7880 -> 7878;
7881 -> 7880;
7881 -> 7876;
7882 -> 7876;
7883 -> 7877;
7883 -> 7876;
7884 -> 7876;
7885 -> 7884;
7885 -> 7861;
7886 -> 7863;
7886 -> 7885;
7887 -> 7885;
7888 -> 7886;
7888 -> 7887;
7889 -> 7888;
7889 -> 7887;
7890 -> 7887;
7891 -> 7880;
7891 -> 7887;
7892 -> 7889;
7892 -> 7890;
7892 -> 7891;
7892 -> 7850;
7892 -> 7887;
7893 -> 7861;
7894 -> 7893;
7894 -> 7861;
7895 -> 7861;
7896 -> 7861;
7897 -> 7893;
7897 -> 7896;
7897 -> 7894;
7897 -> 7861;
7898 -> 7861;
7899 -> 7862;
7899 -> 7861;
7900 -> 7893;
7900 -> 7861;
7901 -> 7898;
7901 -> 7861;
7902 -> 7861;
7903 -> 7900;
7903 -> 7902;
7904 -> 7901;
7904 -> 7902;
7905 -> 7904;
7905 -> 7898;
7905 -> 7902;
7906 -> 7902;
7907 -> 7906;
7907 -> 7905;
7907 -> 7902;
7908 -> 7861;
7909 -> 7861;
7910 -> 7893;
7910 -> 7909;
7910 -> 7897;
7910 -> 7861;
7911 -> 7861;
7912 -> 7892;
7912 -> 7861;
7913 -> 7861;
7914 -> 7912;
7914 -> 7861;
7915 -> 7861;
7916 -> 7913;
7916 -> 7915;
7916 -> 7861;
7917 -> 7861;
7918 -> 7893;
7918 -> 7917;
7918 -> 7910;
7918 -> 7861;
7919 -> 7898;
7919 -> 7861;
7920 -> 7911;
7920 -> 7861;
7924 -> 7922;
7924 -> 7921;
7925 -> 7923;
7925 -> 7921;
7926 -> 7921;
7927 -> 0;
7927 -> 7861;
7928 -> 7861;
7929 -> 7861;
7930 -> 7919;
7930 -> 7929;
7931 -> 7920;
7931 -> 7929;
7932 -> 7927;
7932 -> 7929;
7933 -> 7928;
7933 -> 7929;
7934 -> 7928;
7934 -> 7929;
7935 -> 7929;
7936 -> 7933;
7936 -> 7935;
7936 -> 7929;
7937 -> 7936;
7937 -> 7929;
7938 -> 0;
7940 -> 7938;
7940 -> 7939;
7941 -> 7939;
7943 -> 7942;
7945 -> 7944;
7947 -> 7946;
7948 -> 7941;
7949 -> 7941;
7949 -> 7939;
7950 -> 7940;
7950 -> 7941;
7950 -> 7939;
7951 -> 7939;
7952 -> 7929;
7953 -> 7952;
7953 -> 7934;
7953 -> 7929;
7954 -> 7930;
7954 -> 7929;
7955 -> 7931;
7955 -> 7929;
7956 -> 7932;
7956 -> 7929;
7957 -> 7954;
7957 -> 7929;
7958 -> 7955;
7958 -> 7929;
7959 -> 7953;
7959 -> 7929;
7960 -> 7929;
7961 -> 7957;
7961 -> 7960;
7962 -> 7958;
7962 -> 7960;
7963 -> 7959;
7963 -> 7960;
7964 -> 7937;
7964 -> 7960;
7965 -> 7961;
7965 -> 7960;
7966 -> 7961;
7966 -> 7954;
7966 -> 7960;
7967 -> 7962;
7967 -> 7960;
7968 -> 7962;
7968 -> 7955;
7968 -> 7960;
7969 -> 7960;
7970 -> 7965;
7970 -> 7969;
7971 -> 7966;
7971 -> 7969;
7972 -> 7967;
7972 -> 7969;
7973 -> 7968;
7973 -> 7969;
7974 -> 7964;
7974 -> 7969;
7975 -> 7970;
7975 -> 7969;
7976 -> 7971;
7976 -> 7969;
7977 -> 7972;
7977 -> 7969;
7978 -> 7973;
7978 -> 7969;
7979 -> 7969;
7980 -> 7975;
7980 -> 7979;
7981 -> 7976;
7981 -> 7979;
7982 -> 7977;
7982 -> 7979;
7983 -> 7978;
7983 -> 7979;
7984 -> 7974;
7984 -> 7979;
7985 -> 7979;
7986 -> 7981;
7986 -> 7985;
7986 -> 7979;
7987 -> 7979;
7988 -> 7983;
7988 -> 7987;
7988 -> 7979;
7989 -> 7986;
7989 -> 7988;
7989 -> 7979;
7990 -> 7979;
7991 -> 7990;
7991 -> 7989;
7991 -> 7979;
7992 -> 7979;
7993 -> 7992;
7993 -> 7981;
7993 -> 7979;
7994 -> 7979;
7995 -> 7994;
7995 -> 7983;
7995 -> 7979;
7996 -> 7979;
7997 -> 7996;
7997 -> 7981;
7997 -> 7979;
7998 -> 7989;
7998 -> 7979;
7999 -> 7971;
7999 -> 7969;
8000 -> 7973;
8000 -> 7969;
8001 -> 7969;
8002 -> 7999;
8002 -> 8001;
8002 -> 7969;
8003 -> 7969;
8004 -> 7999;
8004 -> 8003;
8004 -> 7969;
8005 -> 7969;
8006 -> 8000;
8006 -> 8005;
8006 -> 7969;
8007 -> 7969;
8008 -> 8007;
8008 -> 7960;
8009 -> 7960;
8010 -> 8009;
8010 -> 7929;
8011 -> 7956;
8011 -> 8010;
8011 -> 7929;
8012 -> 7893;
8012 -> 8011;
8012 -> 7918;
8012 -> 7861;
8013 -> 7911;
8013 -> 7861;
8014 -> 7898;
8014 -> 7861;
8015 -> 7893;
8015 -> 8012;
8015 -> 7861;
8016 -> 8015;
8016 -> 7840;
8017 -> 214;
8018 -> 7238;
8018 -> 214;
8019 -> 214;
8020 -> 8018;
8020 -> 8019;
8021 -> 218;
8021 -> 8019;
8022 -> 8019;
8023 -> 8021;
8023 -> 8022;
8024 -> 8022;
8025 -> 8023;
8025 -> 204;
8025 -> 8024;
8025 -> 8022;
8026 -> 8019;
8027 -> 8020;
8027 -> 8021;
8027 -> 8019;
8028 -> 8020;
8028 -> 8019;
8029 -> 8019;
8030 -> 8019;
8031 -> 8028;
8031 -> 8030;
8032 -> 8029;
8032 -> 8030;
8033 -> 8021;
8033 -> 8030;
8034 -> 8031;
8034 -> 8030;
8035 -> 8032;
8035 -> 8030;
8036 -> 8033;
8036 -> 8034;
8036 -> 8035;
8036 -> 204;
8036 -> 8027;
8036 -> 7805;
8036 -> 8030;
8037 -> 8030;
8038 -> 8031;
8038 -> 8030;
8039 -> 8030;
8040 -> 8031;
8040 -> 8036;
8040 -> 8030;
8041 -> 8039;
8041 -> 8040;
8041 -> 8030;
8042 -> 8032;
8042 -> 8030;
8043 -> 8030;
8044 -> 8042;
8044 -> 8043;
8045 -> 8033;
8045 -> 8043;
8046 -> 8044;
8046 -> 8043;
8047 -> 8030;
8048 -> 8030;
8049 -> 8039;
8049 -> 8041;
8049 -> 8048;
8049 -> 8030;
8050 -> 8039;
8050 -> 8041;
8050 -> 8049;
8051 -> 8050;
8051 -> 8049;
8052 -> 8050;
8052 -> 8051;
8052 -> 8049;
8053 -> 8049;
8054 -> 8052;
8054 -> 8053;
8055 -> 8052;
8055 -> 8053;
8056 -> 8052;
8056 -> 8053;
8057 -> 8052;
8057 -> 8053;
8058 -> 8050;
8058 -> 8049;
8059 -> 8039;
8059 -> 8058;
8059 -> 8054;
8059 -> 8049;
8060 -> 8054;
8060 -> 8049;
8061 -> 8032;
8061 -> 8049;
8062 -> 8033;
8062 -> 8060;
8062 -> 8061;
8062 -> 8059;
8062 -> 8054;
8062 -> 8049;
8063 -> 8054;
8063 -> 8049;
8064 -> 8054;
8064 -> 8049;
8065 -> 8054;
8065 -> 8062;
8065 -> 8064;
8066 -> 8032;
8066 -> 8064;
8067 -> 8064;
8068 -> 8066;
8068 -> 8067;
8069 -> 8033;
8069 -> 8067;
8070 -> 8068;
8070 -> 8067;
8071 -> 8064;
8072 -> 8065;
8073 -> 8032;
8073 -> 8065;
8074 -> 8065;
8075 -> 8073;
8075 -> 8074;
8076 -> 8033;
8076 -> 8074;
8077 -> 8075;
8077 -> 8074;
8078 -> 8065;
8079 -> 8065;
8080 -> 8032;
8080 -> 8065;
8081 -> 8065;
8082 -> 8080;
8082 -> 8081;
8083 -> 8033;
8083 -> 8081;
8084 -> 8082;
8084 -> 8081;
8085 -> 8065;
8086 -> 8032;
8086 -> 8065;
8087 -> 8065;
8088 -> 8086;
8088 -> 8087;
8089 -> 8033;
8089 -> 8087;
8090 -> 8088;
8090 -> 8087;
8091 -> 8065;
8092 -> 8037;
8092 -> 8019;
8093 -> 8092;
8093 -> 8037;
8093 -> 8038;
8093 -> 8063;
8093 -> 8072;
8093 -> 8065;
8093 -> 8019;
8094 -> 8093;
8094 -> 8021;
8094 -> 8019;
8095 -> 214;
8096 -> 0;
8096 -> 1;
8097 -> 1;
8098 -> 1;
8099 -> 8096;
8099 -> 8098;
8100 -> 8097;
8100 -> 8098;
8101 -> 205;
8101 -> 8098;
8102 -> 8101;
8102 -> 8093;
8102 -> 8094;
8102 -> 8098;
8103 -> 8099;
8103 -> 8098;
8104 -> 8101;
8104 -> 8102;
8104 -> 8098;
8105 -> 8098;
8106 -> 8104;
8106 -> 8105;
8107 -> 8106;
8107 -> 8104;
8107 -> 8105;
8108 -> 8107;
8108 -> 8105;
8109 -> 8105;
8110 -> 8108;
8110 -> 8109;
8111 -> 8109;
8112 -> 0;
8112 -> 8109;
8113 -> 8110;
8113 -> 8111;
8113 -> 8109;
8114 -> 8109;
8115 -> 8112;
8115 -> 8114;
8115 -> 8109;
8116 -> 8115;
8116 -> 8111;
8116 -> 8109;
8117 -> 8113;
8117 -> 8116;
8117 -> 8109;
8118 -> 8103;
8118 -> 8117;
8118 -> 8098;
8119 -> 8101;
8119 -> 8117;
8119 -> 8098;
8120 -> 8098;
8121 -> 8100;
8121 -> 8120;
8121 -> 8098;
8122 -> 8101;
8122 -> 8117;
8122 -> 8098;
8123 -> 8122;
8123 -> 1;
8124 -> 0;
8124 -> 1;
8125 -> 1;
8126 -> 1;
8127 -> 8124;
8127 -> 8126;
8128 -> 8125;
8128 -> 8126;
8129 -> 205;
8129 -> 8126;
8130 -> 8129;
8130 -> 8117;
8130 -> 8126;
8131 -> 8127;
8131 -> 8126;
8132 -> 8126;
8133 -> 8132;
8134 -> 8133;
8135 -> 0;
8135 -> 8133;
8136 -> 8133;
8137 -> 8135;
8137 -> 8136;
8137 -> 8133;
8138 -> 8137;
8138 -> 8134;
8138 -> 8133;
8139 -> 8131;
8139 -> 8130;
8139 -> 8126;
8140 -> 8129;
8140 -> 8130;
8140 -> 8126;
8141 -> 8126;
8142 -> 8128;
8142 -> 8141;
8142 -> 8126;
8143 -> 8129;
8143 -> 8130;
8143 -> 8126;
8144 -> 8143;
8144 -> 1;
8145 -> 0;
8145 -> 1;
8146 -> 1;
8147 -> 1;
8148 -> 8145;
8148 -> 8147;
8149 -> 8146;
8149 -> 8147;
8150 -> 205;
8150 -> 8147;
8151 -> 8150;
8151 -> 8130;
8151 -> 8147;
8152 -> 8148;
8152 -> 8147;
8153 -> 8147;
8154 -> 8153;
8155 -> 8154;
8156 -> 0;
8156 -> 8154;
8157 -> 8154;
8158 -> 8156;
8158 -> 8157;
8158 -> 8154;
8159 -> 8158;
8159 -> 8155;
8159 -> 8154;
8160 -> 8152;
8160 -> 8151;
8160 -> 8147;
8161 -> 8150;
8161 -> 8151;
8161 -> 8147;
8162 -> 8147;
8163 -> 8149;
8163 -> 8162;
8163 -> 8147;
8164 -> 8150;
8164 -> 8151;
8164 -> 8147;
8165 -> 8164;
8165 -> 1;
8166 -> 0;
8166 -> 1;
8167 -> 1;
8168 -> 1;
8169 -> 8166;
8169 -> 8168;
8170 -> 8167;
8170 -> 8168;
8171 -> 205;
8171 -> 8168;
8172 -> 8171;
8172 -> 8151;
8172 -> 8168;
8173 -> 8169;
8173 -> 8168;
8174 -> 8168;
8175 -> 8174;
8176 -> 8175;
8177 -> 0;
8177 -> 8175;
8178 -> 8175;
8179 -> 8177;
8179 -> 8178;
8179 -> 8175;
8180 -> 8179;
8180 -> 8176;
8180 -> 8175;
8181 -> 8173;
8181 -> 8172;
8181 -> 8168;
8182 -> 8171;
8182 -> 8172;
8182 -> 8168;
8183 -> 8168;
8184 -> 8170;
8184 -> 8183;
8184 -> 8168;
8185 -> 8184;
8186 -> 8171;
8186 -> 8172;
8186 -> 8185;
8187 -> 8185;
8188 -> 8186;
8188 -> 8187;
8189 -> 8188;
8189 -> 8185;
8190 -> 8189;
8190 -> 8184;
8191 -> 8170;
8191 -> 8184;
8192 -> 8171;
8192 -> 8190;
8192 -> 8168;
8193 -> 0;
8193 -> 1;
8194 -> 1;
8195 -> 1;
8196 -> 8193;
8196 -> 8195;
8197 -> 8194;
8197 -> 8195;
8198 -> 205;
8198 -> 8195;
8199 -> 8198;
8199 -> 8190;
8199 -> 8195;
8200 -> 8196;
8200 -> 8195;
8201 -> 8195;
8202 -> 8201;
8203 -> 8202;
8204 -> 0;
8204 -> 8202;
8205 -> 8202;
8206 -> 8204;
8206 -> 8205;
8206 -> 8202;
8207 -> 8206;
8207 -> 8203;
8207 -> 8202;
8208 -> 8200;
8208 -> 8199;
8208 -> 8195;
8209 -> 8198;
8209 -> 8199;
8209 -> 8195;
8210 -> 8195;
8211 -> 8197;
8211 -> 8210;
8211 -> 8195;
8212 -> 8198;
8212 -> 8199;
8212 -> 8195;
8213 -> 8212;
8213 -> 1;
8214 -> 0;
8214 -> 1;
8215 -> 1;
8216 -> 1;
8217 -> 8214;
8217 -> 8216;
8218 -> 8215;
8218 -> 8216;
8219 -> 205;
8219 -> 8216;
8220 -> 8219;
8220 -> 8199;
8220 -> 8216;
8221 -> 8217;
8221 -> 8216;
8222 -> 8216;
8223 -> 8222;
8224 -> 8223;
8225 -> 0;
8225 -> 8223;
8226 -> 8223;
8227 -> 8225;
8227 -> 8226;
8227 -> 8223;
8228 -> 8227;
8228 -> 8224;
8228 -> 8223;
8229 -> 8221;
8229 -> 8220;
8229 -> 8216;
8230 -> 8219;
8230 -> 8220;
8230 -> 8216;
8231 -> 8216;
8232 -> 8218;
8232 -> 8231;
8232 -> 8216;
8233 -> 8219;
8233 -> 8220;
8233 -> 8216;
8234 -> 8233;
8234 -> 1;
8235 -> 0;
8235 -> 1;
8236 -> 1;
8237 -> 1;
8238 -> 8235;
8238 -> 8237;
8239 -> 8236;
8239 -> 8237;
8240 -> 205;
8240 -> 8237;
8241 -> 8240;
8241 -> 8220;
8241 -> 8237;
8242 -> 8238;
8242 -> 8237;
8243 -> 8237;
8244 -> 8243;
8245 -> 8244;
8246 -> 0;
8246 -> 8244;
8247 -> 8244;
8248 -> 8246;
8248 -> 8247;
8248 -> 8244;
8249 -> 8248;
8249 -> 8245;
8249 -> 8244;
8250 -> 8242;
8250 -> 8241;
8250 -> 8237;
8251 -> 8240;
8251 -> 8241;
8251 -> 8237;
8252 -> 8237;
8253 -> 8239;
8253 -> 8252;
8253 -> 8237;
8254 -> 8240;
8254 -> 8241;
8254 -> 8237;
8255 -> 8254;
8255 -> 1;
8256 -> 0;
8256 -> 1;
8257 -> 1;
8258 -> 1;
8259 -> 8256;
8259 -> 8258;
8260 -> 8257;
8260 -> 8258;
8261 -> 205;
8261 -> 8258;
8262 -> 8261;
8262 -> 8241;
8262 -> 8258;
8263 -> 8259;
8263 -> 8258;
8264 -> 8258;
8265 -> 8264;
8266 -> 8265;
8267 -> 0;
8267 -> 8265;
8268 -> 8265;
8269 -> 8267;
8269 -> 8268;
8269 -> 8265;
8270 -> 8269;
8270 -> 8266;
8270 -> 8265;
8271 -> 8263;
8271 -> 8262;
8271 -> 8258;
8272 -> 8261;
8272 -> 8262;
8272 -> 8258;
8273 -> 8258;
8274 -> 8260;
8274 -> 8273;
8274 -> 8258;
8275 -> 8261;
8275 -> 8262;
8275 -> 8258;
8276 -> 8275;
8276 -> 1;
8277 -> 0;
8277 -> 1;
8278 -> 1;
8279 -> 1;
8280 -> 8277;
8280 -> 8279;
8281 -> 8278;
8281 -> 8279;
8282 -> 205;
8282 -> 8279;
8283 -> 8282;
8283 -> 8262;
8283 -> 8279;
8284 -> 8280;
8284 -> 8279;
8285 -> 8279;
8286 -> 8285;
8287 -> 8286;
8288 -> 0;
8288 -> 8286;
8289 -> 8286;
8290 -> 8288;
8290 -> 8289;
8290 -> 8286;
8291 -> 8290;
8291 -> 8287;
8291 -> 8286;
8292 -> 8284;
8292 -> 8283;
8292 -> 8279;
8293 -> 8282;
8293 -> 8283;
8293 -> 8279;
8294 -> 8279;
8295 -> 8281;
8295 -> 8294;
8295 -> 8279;
8296 -> 8282;
8296 -> 8283;
8296 -> 8279;
8297 -> 8296;
8297 -> 1;
8298 -> 0;
8298 -> 1;
8299 -> 1;
8300 -> 1;
8301 -> 8298;
8301 -> 8300;
8302 -> 8299;
8302 -> 8300;
8303 -> 205;
8303 -> 8300;
8304 -> 8303;
8304 -> 8283;
8304 -> 8300;
8305 -> 8301;
8305 -> 8300;
8306 -> 8300;
8307 -> 8306;
8308 -> 8307;
8309 -> 0;
8309 -> 8307;
8310 -> 8307;
8311 -> 8309;
8311 -> 8310;
8311 -> 8307;
8312 -> 8311;
8312 -> 8308;
8312 -> 8307;
8313 -> 8305;
8313 -> 8304;
8313 -> 8300;
8314 -> 8303;
8314 -> 8304;
8314 -> 8300;
8315 -> 8300;
8316 -> 8302;
8316 -> 8315;
8316 -> 8300;
8317 -> 8303;
8317 -> 8304;
8317 -> 8300;
8318 -> 8317;
8318 -> 1;
8319 -> 0;
8319 -> 1;
8320 -> 1;
8321 -> 1;
8322 -> 8319;
8322 -> 8321;
8323 -> 8320;
8323 -> 8321;
8324 -> 205;
8324 -> 8321;
8325 -> 8324;
8325 -> 8304;
8325 -> 8321;
8326 -> 8322;
8326 -> 8321;
8327 -> 8321;
8328 -> 8327;
8329 -> 8328;
8330 -> 0;
8330 -> 8328;
8331 -> 8328;
8332 -> 8330;
8332 -> 8331;
8332 -> 8328;
8333 -> 8332;
8333 -> 8329;
8333 -> 8328;
8334 -> 8326;
8334 -> 8325;
8334 -> 8321;
8335 -> 8324;
8335 -> 8325;
8335 -> 8321;
8336 -> 8321;
8337 -> 8323;
8337 -> 8336;
8337 -> 8321;
8338 -> 8324;
8338 -> 8325;
8338 -> 8321;
8339 -> 8338;
8339 -> 1;
8340 -> 0;
8340 -> 1;
8341 -> 1;
8342 -> 1;
8343 -> 8340;
8343 -> 8342;
8344 -> 8341;
8344 -> 8342;
8345 -> 205;
8345 -> 8342;
8346 -> 8345;
8346 -> 8325;
8346 -> 8342;
8347 -> 8343;
8347 -> 8342;
8348 -> 8342;
8349 -> 8348;
8350 -> 8349;
8351 -> 0;
8351 -> 8349;
8352 -> 8349;
8353 -> 8351;
8353 -> 8352;
8353 -> 8349;
8354 -> 8353;
8354 -> 8350;
8354 -> 8349;
8355 -> 8347;
8355 -> 8346;
8355 -> 8342;
8356 -> 8345;
8356 -> 8346;
8356 -> 8342;
8357 -> 8342;
8358 -> 8344;
8358 -> 8357;
8358 -> 8342;
8359 -> 8345;
8359 -> 8346;
8359 -> 8342;
8360 -> 8359;
8360 -> 1;
8361 -> 0;
8361 -> 1;
8362 -> 1;
8363 -> 1;
8364 -> 8361;
8364 -> 8363;
8365 -> 8362;
8365 -> 8363;
8366 -> 205;
8366 -> 8363;
8367 -> 8366;
8367 -> 8346;
8367 -> 8363;
8368 -> 8364;
8368 -> 8363;
8369 -> 8363;
8370 -> 8369;
8371 -> 8370;
8372 -> 0;
8372 -> 8370;
8373 -> 8370;
8374 -> 8372;
8374 -> 8373;
8374 -> 8370;
8375 -> 8374;
8375 -> 8371;
8375 -> 8370;
8376 -> 8368;
8376 -> 8367;
8376 -> 8363;
8377 -> 8366;
8377 -> 8367;
8377 -> 8363;
8378 -> 8363;
8379 -> 8365;
8379 -> 8378;
8379 -> 8363;
8380 -> 8366;
8380 -> 8367;
8380 -> 8363;
8381 -> 8380;
8381 -> 1;
8382 -> 0;
8382 -> 1;
8383 -> 1;
8384 -> 1;
8385 -> 8382;
8385 -> 8384;
8386 -> 8383;
8386 -> 8384;
8387 -> 205;
8387 -> 8384;
8388 -> 8387;
8388 -> 8367;
8388 -> 8384;
8389 -> 8385;
8389 -> 8384;
8390 -> 8384;
8391 -> 8390;
8392 -> 8391;
8393 -> 0;
8393 -> 8391;
8394 -> 8391;
8395 -> 8393;
8395 -> 8394;
8395 -> 8391;
8396 -> 8395;
8396 -> 8392;
8396 -> 8391;
8397 -> 8389;
8397 -> 8388;
8397 -> 8384;
8398 -> 8387;
8398 -> 8388;
8398 -> 8384;
8399 -> 8384;
8400 -> 8386;
8400 -> 8399;
8400 -> 8384;
8401 -> 8387;
8401 -> 8388;
8401 -> 8384;
8402 -> 8401;
8402 -> 1;
8403 -> 0;
8403 -> 1;
8404 -> 1;
8405 -> 1;
8406 -> 8403;
8406 -> 8405;
8407 -> 8404;
8407 -> 8405;
8408 -> 205;
8408 -> 8405;
8409 -> 8408;
8409 -> 8388;
8409 -> 8405;
8410 -> 8406;
8410 -> 8405;
8411 -> 8405;
8412 -> 8411;
8413 -> 8412;
8414 -> 0;
8414 -> 8412;
8415 -> 8412;
8416 -> 8414;
8416 -> 8415;
8416 -> 8412;
8417 -> 8416;
8417 -> 8413;
8417 -> 8412;
8418 -> 8410;
8418 -> 8409;
8418 -> 8405;
8419 -> 8408;
8419 -> 8409;
8419 -> 8405;
8420 -> 8405;
8421 -> 8407;
8421 -> 8420;
8421 -> 8405;
8422 -> 8408;
8422 -> 8409;
8422 -> 8405;
8423 -> 8422;
8423 -> 1;
8424 -> 0;
8424 -> 1;
8425 -> 1;
8426 -> 1;
8427 -> 8424;
8427 -> 8426;
8428 -> 8425;
8428 -> 8426;
8429 -> 205;
8429 -> 8426;
8430 -> 8429;
8430 -> 8409;
8430 -> 8426;
8431 -> 8427;
8431 -> 8426;
8432 -> 8426;
8433 -> 8432;
8434 -> 8433;
8435 -> 0;
8435 -> 8433;
8436 -> 8433;
8437 -> 8435;
8437 -> 8436;
8437 -> 8433;
8438 -> 8437;
8438 -> 8434;
8438 -> 8433;
8439 -> 8431;
8439 -> 8430;
8439 -> 8426;
8440 -> 8429;
8440 -> 8430;
8440 -> 8426;
8441 -> 8426;
8442 -> 8428;
8442 -> 8441;
8442 -> 8426;
8443 -> 8429;
8443 -> 8430;
8443 -> 8426;
8444 -> 8443;
8444 -> 1;
8445 -> 0;
8445 -> 1;
8446 -> 1;
8447 -> 1;
8448 -> 8445;
8448 -> 8447;
8449 -> 8446;
8449 -> 8447;
8450 -> 205;
8450 -> 8447;
8451 -> 8450;
8451 -> 8430;
8451 -> 8447;
8452 -> 8448;
8452 -> 8447;
8453 -> 8447;
8454 -> 8453;
8455 -> 8454;
8456 -> 0;
8456 -> 8454;
8457 -> 8454;
8458 -> 8456;
8458 -> 8457;
8458 -> 8454;
8459 -> 8458;
8459 -> 8455;
8459 -> 8454;
8460 -> 8452;
8460 -> 8451;
8460 -> 8447;
8461 -> 8450;
8461 -> 8451;
8461 -> 8447;
8462 -> 8447;
8463 -> 8449;
8463 -> 8462;
8463 -> 8447;
8464 -> 8450;
8464 -> 8451;
8464 -> 8447;
8465 -> 8464;
8465 -> 1;
8466 -> 0;
8466 -> 1;
8467 -> 1;
8468 -> 1;
8469 -> 8466;
8469 -> 8468;
8470 -> 8467;
8470 -> 8468;
8471 -> 205;
8471 -> 8468;
8472 -> 8471;
8472 -> 8451;
8472 -> 8468;
8473 -> 8469;
8473 -> 8468;
8474 -> 8468;
8475 -> 8474;
8476 -> 8475;
8477 -> 0;
8477 -> 8475;
8478 -> 8475;
8479 -> 8477;
8479 -> 8478;
8479 -> 8475;
8480 -> 8479;
8480 -> 8476;
8480 -> 8475;
8481 -> 8473;
8481 -> 8472;
8481 -> 8468;
8482 -> 8471;
8482 -> 8472;
8482 -> 8468;
8483 -> 8468;
8484 -> 8470;
8484 -> 8483;
8484 -> 8468;
8485 -> 8471;
8485 -> 8472;
8485 -> 8468;
8486 -> 8485;
8486 -> 1;
8487 -> 0;
8487 -> 1;
8488 -> 1;
8489 -> 1;
8490 -> 8487;
8490 -> 8489;
8491 -> 8488;
8491 -> 8489;
8492 -> 205;
8492 -> 8489;
8493 -> 8492;
8493 -> 8472;
8493 -> 8489;
8494 -> 8490;
8494 -> 8489;
8495 -> 8489;
8496 -> 8495;
8497 -> 8496;
8498 -> 0;
8498 -> 8496;
8499 -> 8496;
8500 -> 8498;
8500 -> 8499;
8500 -> 8496;
8501 -> 8500;
8501 -> 8497;
8501 -> 8496;
8502 -> 8494;
8502 -> 8493;
8502 -> 8489;
8503 -> 8492;
8503 -> 8493;
8503 -> 8489;
8504 -> 8489;
8505 -> 8491;
8505 -> 8504;
8505 -> 8489;
8506 -> 8492;
8506 -> 8493;
8506 -> 8489;
8507 -> 8506;
8507 -> 1;
8508 -> 7055;
8508 -> 1;
8509 -> 1;
8510 -> 1;
8511 -> 8508;
8511 -> 8510;
8512 -> 8509;
8512 -> 8510;
8513 -> 205;
8513 -> 8510;
8514 -> 8513;
8514 -> 8493;
8514 -> 8510;
8515 -> 8511;
8515 -> 8510;
8516 -> 8510;
8517 -> 8516;
8518 -> 8517;
8519 -> 0;
8519 -> 8517;
8520 -> 8517;
8521 -> 8519;
8521 -> 8520;
8521 -> 8517;
8522 -> 8521;
8522 -> 8518;
8522 -> 8517;
8523 -> 8515;
8523 -> 8514;
8523 -> 8510;
8524 -> 8513;
8524 -> 8514;
8524 -> 8510;
8525 -> 8510;
8526 -> 8512;
8526 -> 8525;
8526 -> 8510;
8527 -> 8513;
8527 -> 8514;
8527 -> 8510;
8528 -> 8527;
8528 -> 1;
8529 -> 0;
8529 -> 1;
8530 -> 1;
8531 -> 1;
8532 -> 8529;
8532 -> 8531;
8533 -> 8530;
8533 -> 8531;
8534 -> 205;
8534 -> 8531;
8535 -> 8534;
8535 -> 8514;
8535 -> 8531;
8536 -> 8532;
8536 -> 8531;
8537 -> 8531;
8538 -> 8537;
8539 -> 8538;
8540 -> 0;
8540 -> 8538;
8541 -> 8538;
8542 -> 8540;
8542 -> 8541;
8542 -> 8538;
8543 -> 8542;
8543 -> 8539;
8543 -> 8538;
8544 -> 8536;
8544 -> 8535;
8544 -> 8531;
8545 -> 8534;
8545 -> 8535;
8545 -> 8531;
8546 -> 8531;
8547 -> 8533;
8547 -> 8546;
8547 -> 8531;
8548 -> 8534;
8548 -> 8535;
8548 -> 8531;
8549 -> 8548;
8549 -> 1;
8550 -> 0;
8550 -> 1;
8551 -> 1;
8552 -> 1;
8553 -> 8550;
8553 -> 8552;
8554 -> 8551;
8554 -> 8552;
8555 -> 205;
8555 -> 8552;
8556 -> 8555;
8556 -> 8535;
8556 -> 8552;
8557 -> 8553;
8557 -> 8552;
8558 -> 8552;
8559 -> 8558;
8560 -> 8559;
8561 -> 0;
8561 -> 8559;
8562 -> 8559;
8563 -> 8561;
8563 -> 8562;
8563 -> 8559;
8564 -> 8563;
8564 -> 8560;
8564 -> 8559;
8565 -> 8557;
8565 -> 8556;
8565 -> 8552;
8566 -> 8555;
8566 -> 8556;
8566 -> 8552;
8567 -> 8552;
8568 -> 8554;
8568 -> 8567;
8568 -> 8552;
8569 -> 8555;
8569 -> 8556;
8569 -> 8552;
8570 -> 8569;
8570 -> 1;
8571 -> 0;
8571 -> 1;
8572 -> 1;
8573 -> 1;
8574 -> 8571;
8574 -> 8573;
8575 -> 8572;
8575 -> 8573;
8576 -> 205;
8576 -> 8573;
8577 -> 8576;
8577 -> 8556;
8577 -> 8573;
8578 -> 8574;
8578 -> 8573;
8579 -> 8573;
8580 -> 8579;
8581 -> 8580;
8582 -> 0;
8582 -> 8580;
8583 -> 8580;
8584 -> 8582;
8584 -> 8583;
8584 -> 8580;
8585 -> 8584;
8585 -> 8581;
8585 -> 8580;
8586 -> 8578;
8586 -> 8577;
8586 -> 8573;
8587 -> 8576;
8587 -> 8577;
8587 -> 8573;
8588 -> 8573;
8589 -> 8575;
8589 -> 8588;
8589 -> 8573;
8590 -> 8576;
8590 -> 8577;
8590 -> 8573;
8591 -> 8590;
8591 -> 1;
8592 -> 1;
8593 -> 205;
8593 -> 8592;
8594 -> 8593;
8594 -> 8577;
8594 -> 8592;
8595 -> 1;
}