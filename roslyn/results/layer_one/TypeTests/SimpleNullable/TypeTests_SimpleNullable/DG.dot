digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 657293"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 657294"];
3 [label="param TypeTests(this) 657295"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 657296"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 657297"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 657298"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 657299"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 657300"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 657301"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 657302"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 657303"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 657304"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 657305"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 657306"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 657307"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 657308"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 657309"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 657310"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 657311"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 657312"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 657313"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 657314"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 657315"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 657316"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 657317"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 657318"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 657319"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 657320"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 657321"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 657322"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 657323"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 657324"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 657325"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 657326"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 657327"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 657328"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 657329"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 657330"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 657331"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 657332"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 657333"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 657334"];
43 [label="LazyThreadSafetyMode.PublicationOnly 657335"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 657336"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 657337"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 657338"];
47 [label="LazyThreadSafetyMode.PublicationOnly 657339"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 657340"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 657341"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 657342"];
51 [label="'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 657343"];
52 [label="new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 657344"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 657345"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 657346"];
55 [label="LazyThreadSafetyMode.PublicationOnly 657347"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 657348"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 657349"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 657350"];
59 [label="LazyThreadSafetyMode.PublicationOnly 657351"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 657352"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 657353"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 657354"];
63 [label="LazyThreadSafetyMode.PublicationOnly 657355"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 657356"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 657357"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 657358"];
67 [label="LazyThreadSafetyMode.PublicationOnly 657359"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657360"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657361"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 657362"];
71 [label="LazyThreadSafetyMode.PublicationOnly 657363"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657364"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657365"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 657366"];
75 [label="LazyThreadSafetyMode.PublicationOnly 657367"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657368"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657369"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 657370"];
79 [label="LazyThreadSafetyMode.PublicationOnly 657371"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657372"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657373"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 657374"];
83 [label="LazyThreadSafetyMode.PublicationOnly 657375"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657376"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657377"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 657378"];
87 [label="LazyThreadSafetyMode.PublicationOnly 657379"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657380"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657381"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 657382"];
91 [label="LazyThreadSafetyMode.PublicationOnly 657383"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657384"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657385"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 657386"];
95 [label="LazyThreadSafetyMode.PublicationOnly 657387"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 657388"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 657389"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 657390"];
99 [label="LazyThreadSafetyMode.PublicationOnly 657391"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 657392"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 657393"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 657394"];
103 [label="LazyThreadSafetyMode.PublicationOnly 657395"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657396"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657397"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 657398"];
107 [label="LazyThreadSafetyMode.PublicationOnly 657399"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657400"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657401"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 657402"];
111 [label="LazyThreadSafetyMode.PublicationOnly 657403"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657404"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657405"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 657406"];
115 [label="LazyThreadSafetyMode.PublicationOnly 657407"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657408"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657409"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 657410"];
119 [label="LazyThreadSafetyMode.PublicationOnly 657411"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 657412"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 657413"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 657414"];
123 [label="LazyThreadSafetyMode.PublicationOnly 657415"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657416"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657417"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 657418"];
127 [label="LazyThreadSafetyMode.PublicationOnly 657419"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657420"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657421"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 657422"];
131 [label="LazyThreadSafetyMode.PublicationOnly 657423"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657424"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657425"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 657426"];
135 [label="LazyThreadSafetyMode.PublicationOnly 657427"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657428"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657429"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 657430"];
139 [label="LazyThreadSafetyMode.PublicationOnly 657431"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657432"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657433"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 657434"];
143 [label="LazyThreadSafetyMode.PublicationOnly 657435"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657436"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657437"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 657438"];
147 [label="LazyThreadSafetyMode.PublicationOnly 657439"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657440"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657441"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 657442"];
151 [label="LazyThreadSafetyMode.PublicationOnly 657443"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657444"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657445"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 657446"];
155 [label="LazyThreadSafetyMode.PublicationOnly 657447"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657448"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657449"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 657450"];
159 [label="LazyThreadSafetyMode.PublicationOnly 657451"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657452"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657453"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 657454"];
163 [label="LazyThreadSafetyMode.PublicationOnly 657455"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657456"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657457"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 657458"];
167 [label="LazyThreadSafetyMode.PublicationOnly 657459"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657460"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657461"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 657462"];
171 [label="LazyThreadSafetyMode.PublicationOnly 657463"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657464"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 657465"];
174 [label="@'R:\\Invalid.dll' 657466"];
175 [label="fullPath: @'R:\\Invalid.dll' 657467"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 657468"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 657469"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 657470"];
179 [label="MscorlibRef_v4_0_30316_17626 657471"];
180 [label="Net451.mscorlib 657472"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 657473"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 657474"];
183 [label="'/*<bind>*/' 657475"];
184 [label="StartString = '/*<bind>*/' 657476"];
185 [label="'/*</bind>*/' 657477"];
186 [label="EndString = '/*</bind>*/' 657478"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 657479"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 657480"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 657481"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 657482"];
191 [label="param CSharpTestBase(this) 657483"];
192 [label="param CommonTestBase(this) 657484"];
193 [label="param TestBase(this) 657485"];
194 [label="_temp 657486"];
195 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 657487"];
196 [label="param SimpleNullable(this) 657488"];
197 [label="var text =\n@'namespace NS\n{\n    public class A \n    {\n        int? x = null;\n    }\n}'; 657489"];
198 [label="var comp = CreateCompilation(text); 657490"];
199 [label="text 657491"];
200 [label="param operator(string source) 657492"];
201 [label="source 657493"];
202 [label="new CSharpTestSource(source) 657494"];
203 [label="param CSharpTestSource(object value) 657495"];
204 [label="param CSharpTestSource(this) 657496"];
205 [label="Value 657497"];
206 [label="var comp = CreateCompilation(text); 657498"];
207 [label="var comp = CreateCompilation(text); 657499"];
208 [label="CreateCompilation(text) 657500"];
209 [label="param CreateCompilation(CSharpTestSource source) 657501"];
210 [label="param CreateCompilation(IEnumerable<MetadataReference> references = null) 657502"];
211 [label="param CreateCompilation(CSharpCompilationOptions options = null) 657503"];
212 [label="param CreateCompilation(CSharpParseOptions parseOptions = null) 657504"];
213 [label="param CreateCompilation(TargetFramework targetFramework = TargetFramework.Standard) 657505"];
214 [label="param CreateCompilation(string assemblyName = '') 657506"];
215 [label="param CreateCompilation(string sourceFileName = '') 657507"];
216 [label="param CreateCompilation(bool skipUsesIsNullable = false) 657508"];
217 [label="source 657509"];
218 [label="targetFramework 657510"];
219 [label="references 657511"];
220 [label="TargetFrameworkUtil.GetReferences(targetFramework, references) 657512"];
221 [label="param GetReferences(TargetFramework tf) 657513"];
222 [label="param GetReferences(IEnumerable<MetadataReference> additionalReferences) 657514"];
223 [label="var references = GetReferences(tf); 657515"];
224 [label="GetReferences(tf) 657516"];
225 [label="param GetReferences(TargetFramework targetFramework) 657517"];
226 [label="targetFramework switch\n        {\n            TargetFramework.Empty => ImmutableArray<MetadataReference>.Empty,\n            TargetFramework.Mscorlib40 => Mscorlib40References,\n            TargetFramework.Mscorlib40Extended => Mscorlib40ExtendedReferences,\n            TargetFramework.Mscorlib40AndSystemCore => Mscorlib40andSystemCoreReferences,\n            TargetFramework.Mscorlib40AndVBRuntime => Mscorlib40andVBRuntimeReferences,\n            TargetFramework.Mscorlib45 => Mscorlib45References,\n            TargetFramework.Mscorlib45Extended => Mscorlib45ExtendedReferences,\n            TargetFramework.Mscorlib45AndCSharp => Mscorlib45AndCSharpReferences,\n            TargetFramework.Mscorlib45AndVBRuntime => Mscorlib45AndVBRuntimeReferences,\n            TargetFramework.Mscorlib46 => Mscorlib46References,\n            TargetFramework.Mscorlib46Extended => Mscorlib46ExtendedReferences,\n            TargetFramework.Mscorlib461 => Mscorlib46References,\n            TargetFramework.Mscorlib461Extended => Mscorlib461ExtendedReferences,\n            TargetFramework.NetStandard20 => NetStandard20References,\n            TargetFramework.NetCoreApp => NetCoreAppReferences,\n            TargetFramework.WinRT => WinRTReferences,\n            TargetFramework.Standard => StandardReferences,\n            TargetFramework.StandardLatest => StandardLatestReferences,\n            TargetFramework.StandardAndCSharp => StandardAndCSharpReferences,\n            TargetFramework.StandardAndVBRuntime => StandardAndVBRuntimeReferences,\n            TargetFramework.StandardCompat => StandardCompatReferences,\n            TargetFramework.DefaultVb => DefaultVbReferences,\n            TargetFramework.Minimal => MinimalReferences,\n            TargetFramework.MinimalAsync => MinimalAsyncReferences,\n            _ => throw new InvalidOperationException($'Unexpected target framework {targetFramework}'),\n        } 657518"];
227 [label="StandardReferences 657519"];
228 [label="RuntimeUtilities.IsCoreClrRuntime 657520"];
229 [label="Mscorlib46ExtendedReferences 657521"];
230 [label="ImmutableArray.Create<MetadataReference>(Net461.mscorlib, Net461.System, TestMetadata.Net461.SystemCore, TestBase.ValueTupleRef, Net461.SystemRuntime) 657522"];
231 [label="TestBase.ValueTupleRef 657523"];
232 [label="TestReferences.NetFx.ValueTuple.tuplelib 657524"];
233 [label="ImmutableArray.Create<MetadataReference>(Net461.mscorlib, Net461.System, TestMetadata.Net461.SystemCore, TestBase.ValueTupleRef, Net461.SystemRuntime) 657525"];
234 [label="RuntimeUtilities.IsCoreClrRuntime ? NetStandard20References : Mscorlib46ExtendedReferences 657526"];
235 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 657527"];
236 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 657528"];
237 [label="return references; 657529"];
238 [label="options 657530"];
239 [label="parseOptions 657531"];
240 [label="assemblyName 657532"];
241 [label="sourceFileName 657533"];
242 [label="skipUsesIsNullable 657534"];
243 [label="CreateEmptyCompilation(source, TargetFrameworkUtil.GetReferences(targetFramework, references), options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable) 657535"];
244 [label="param CreateEmptyCompilation(CSharpTestSource source) 657536"];
245 [label="param CreateEmptyCompilation(IEnumerable<MetadataReference> references = null) 657537"];
246 [label="param CreateEmptyCompilation(CSharpCompilationOptions options = null) 657538"];
247 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 657539"];
248 [label="param CreateEmptyCompilation(string assemblyName = '') 657540"];
249 [label="param CreateEmptyCompilation(string sourceFileName = '') 657541"];
250 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 657542"];
251 [label="source 657543"];
252 [label="references 657544"];
253 [label="options 657545"];
254 [label="parseOptions 657546"];
255 [label="assemblyName 657547"];
256 [label="sourceFileName 657548"];
257 [label="skipUsesIsNullable 657549"];
258 [label="null 657550"];
259 [label="experimentalFeature: null 657551"];
260 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 657552"];
261 [label="param CreateCompilationCore(CSharpTestSource source) 657553"];
262 [label="param CreateCompilationCore(IEnumerable<MetadataReference> references) 657554"];
263 [label="param CreateCompilationCore(CSharpCompilationOptions options) 657555"];
264 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 657556"];
265 [label="param CreateCompilationCore(string assemblyName) 657557"];
266 [label="param CreateCompilationCore(string sourceFileName) 657558"];
267 [label="param CreateCompilationCore(bool skipUsesIsNullable) 657559"];
268 [label="param CreateCompilationCore(MessageID? experimentalFeature) 657560"];
269 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 657561"];
270 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 657562"];
271 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 657563"];
272 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 657564"];
273 [label="param GetSyntaxTrees(string sourceFileName = '') 657565"];
274 [label="param GetSyntaxTrees(this) 657566"];
275 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 657567"];
276 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 657568"];
277 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 657569"];
278 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 657570"];
279 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 657571"];
280 [label="param Parse(string text) 657572"];
281 [label="param Parse(string filename = '') 657573"];
282 [label="param Parse(CSharpParseOptions options = null) 657574"];
283 [label="param Parse(Encoding encoding = null) 657575"];
284 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 657576"];
285 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 657577"];
286 [label="kind: SourceCodeKind.Regular 657578"];
287 [label="documentationMode: DocumentationMode.Parse 657579"];
288 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 657580"];
289 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 657581"];
290 [label="Regular = new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 657582"];
291 [label="SourceCodeKind.Script 657583"];
292 [label="Regular.WithKind(SourceCodeKind.Script) 657584"];
293 [label="Script = Regular.WithKind(SourceCodeKind.Script) 657585"];
294 [label="LanguageVersion.CSharp6 657586"];
295 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp6) 657587"];
296 [label="Regular6 = Regular.WithLanguageVersion(LanguageVersion.CSharp6) 657588"];
297 [label="LanguageVersion.CSharp7 657589"];
298 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7) 657590"];
299 [label="Regular7 = Regular.WithLanguageVersion(LanguageVersion.CSharp7) 657591"];
300 [label="LanguageVersion.CSharp7_1 657592"];
301 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 657593"];
302 [label="Regular7_1 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 657594"];
303 [label="LanguageVersion.CSharp7_2 657595"];
304 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 657596"];
305 [label="Regular7_2 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 657597"];
306 [label="LanguageVersion.CSharp7_3 657598"];
307 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 657599"];
308 [label="Regular7_3 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 657600"];
309 [label="LanguageVersion.Default 657601"];
310 [label="Regular.WithLanguageVersion(LanguageVersion.Default) 657602"];
311 [label="RegularDefault = Regular.WithLanguageVersion(LanguageVersion.Default) 657603"];
312 [label="LanguageVersion.Preview 657604"];
313 [label="Regular.WithLanguageVersion(LanguageVersion.Preview) 657605"];
314 [label="RegularPreview = Regular.WithLanguageVersion(LanguageVersion.Preview) 657606"];
315 [label="LanguageVersion.CSharp8 657607"];
316 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 657608"];
317 [label="Regular8 = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 657609"];
318 [label="LanguageVersion.CSharp9 657610"];
319 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp9) 657611"];
320 [label="Regular9 = Regular.WithLanguageVersion(LanguageVersion.CSharp9) 657612"];
321 [label="DocumentationMode.Diagnose 657613"];
322 [label="Regular.WithDocumentationMode(DocumentationMode.Diagnose) 657614"];
323 [label="RegularWithDocumentationComments = Regular.WithDocumentationMode(DocumentationMode.Diagnose) 657615"];
324 [label="Regular 657616"];
325 [label="'UseLegacyStrongNameProvider' 657617"];
326 [label="Regular.WithFeature('UseLegacyStrongNameProvider') 657618"];
327 [label="param WithFeature(this CSharpParseOptions options) 657619"];
328 [label="param WithFeature(string feature) 657620"];
329 [label="param WithFeature(string value = 'true') 657621"];
330 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 657622"];
331 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 657623"];
332 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 657624"];
333 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 657625"];
334 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 657626"];
335 [label="new[] { new KeyValuePair<string, string>(feature, value) } 657627"];
336 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 657628"];
337 [label="RegularWithLegacyStrongName = Regular.WithFeature('UseLegacyStrongNameProvider') 657629"];
338 [label="MessageID.IDS_FeatureImprovedOverloadCandidates 657630"];
339 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() 657631"];
340 [label="1 657632"];
341 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1 657633"];
342 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 657634"];
343 [label="WithoutImprovedOverloadCandidates = Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 657635"];
344 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides 657636"];
345 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion() 657637"];
346 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 657638"];
347 [label="WithCovariantReturns = Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 657639"];
348 [label="LanguageVersion.CSharp8 657640"];
349 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 657641"];
350 [label="WithoutCovariantReturns = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 657642"];
351 [label="RegularWithExtendedPartialMethods = RegularPreview 657643"];
352 [label="new SmallDictionary<string, string> { } 657644"];
353 [label="s_experimentalFeatures = new SmallDictionary<string, string> { } 657645"];
354 [label="kind: SourceCodeKind.Regular 657646"];
355 [label="documentationMode: DocumentationMode.None 657647"];
356 [label="languageVersion: LanguageVersion.Preview 657648"];
357 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 657649"];
358 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 657650"];
359 [label="s_experimentalFeatures 657651"];
360 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 657652"];
361 [label="ExperimentalParseOptions =\n            new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 657653"];
362 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 657654"];
363 [label="'testV7SwitchBinder' 657655"];
364 [label="'true' 657656"];
365 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 657657"];
366 [label="Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 657658"];
367 [label="Regular6WithV7SwitchBinder = Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 657659"];
368 [label="RegularWithoutRecursivePatterns = Regular7_3 657660"];
369 [label="RegularWithRecursivePatterns = Regular8 657661"];
370 [label="RegularWithoutPatternCombinators = Regular8 657662"];
371 [label="RegularWithPatternCombinators = RegularPreview 657663"];
372 [label="OutputKind.DynamicallyLinkedLibrary 657664"];
373 [label="OptimizationLevel.Release 657665"];
374 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 657666"];
375 [label="param CreateTestOptions(OutputKind outputKind) 657667"];
376 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 657668"];
377 [label="param CreateTestOptions(bool allowUnsafe = false) 657669"];
378 [label="outputKind 657670"];
379 [label="optimizationLevel: optimizationLevel 657671"];
380 [label="warningLevel: Diagnostic.MaxWarningLevel 657672"];
381 [label="allowUnsafe: allowUnsafe 657673"];
382 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657674"];
383 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657675"];
384 [label="ReleaseDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 657676"];
385 [label="OutputKind.ConsoleApplication 657677"];
386 [label="OptimizationLevel.Release 657678"];
387 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 657679"];
388 [label="param CreateTestOptions(OutputKind outputKind) 657680"];
389 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 657681"];
390 [label="param CreateTestOptions(bool allowUnsafe = false) 657682"];
391 [label="outputKind 657683"];
392 [label="optimizationLevel: optimizationLevel 657684"];
393 [label="warningLevel: Diagnostic.MaxWarningLevel 657685"];
394 [label="allowUnsafe: allowUnsafe 657686"];
395 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657687"];
396 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657688"];
397 [label="ReleaseExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 657689"];
398 [label="true 657690"];
399 [label="ReleaseDll.WithDebugPlusMode(true) 657691"];
400 [label="ReleaseDebugDll = ReleaseDll.WithDebugPlusMode(true) 657692"];
401 [label="true 657693"];
402 [label="ReleaseExe.WithDebugPlusMode(true) 657694"];
403 [label="ReleaseDebugExe = ReleaseExe.WithDebugPlusMode(true) 657695"];
404 [label="OutputKind.DynamicallyLinkedLibrary 657696"];
405 [label="OptimizationLevel.Debug 657697"];
406 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 657698"];
407 [label="param CreateTestOptions(OutputKind outputKind) 657699"];
408 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 657700"];
409 [label="param CreateTestOptions(bool allowUnsafe = false) 657701"];
410 [label="outputKind 657702"];
411 [label="optimizationLevel: optimizationLevel 657703"];
412 [label="warningLevel: Diagnostic.MaxWarningLevel 657704"];
413 [label="allowUnsafe: allowUnsafe 657705"];
414 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657706"];
415 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657707"];
416 [label="DebugDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 657708"];
417 [label="OutputKind.ConsoleApplication 657709"];
418 [label="OptimizationLevel.Debug 657710"];
419 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 657711"];
420 [label="param CreateTestOptions(OutputKind outputKind) 657712"];
421 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 657713"];
422 [label="param CreateTestOptions(bool allowUnsafe = false) 657714"];
423 [label="outputKind 657715"];
424 [label="optimizationLevel: optimizationLevel 657716"];
425 [label="warningLevel: Diagnostic.MaxWarningLevel 657717"];
426 [label="allowUnsafe: allowUnsafe 657718"];
427 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657719"];
428 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657720"];
429 [label="DebugExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 657721"];
430 [label="OutputKind.WindowsRuntimeMetadata 657722"];
431 [label="OptimizationLevel.Release 657723"];
432 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 657724"];
433 [label="param CreateTestOptions(OutputKind outputKind) 657725"];
434 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 657726"];
435 [label="param CreateTestOptions(bool allowUnsafe = false) 657727"];
436 [label="outputKind 657728"];
437 [label="optimizationLevel: optimizationLevel 657729"];
438 [label="warningLevel: Diagnostic.MaxWarningLevel 657730"];
439 [label="allowUnsafe: allowUnsafe 657731"];
440 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657732"];
441 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657733"];
442 [label="ReleaseWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 657734"];
443 [label="OutputKind.WindowsRuntimeMetadata 657735"];
444 [label="OptimizationLevel.Debug 657736"];
445 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 657737"];
446 [label="param CreateTestOptions(OutputKind outputKind) 657738"];
447 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 657739"];
448 [label="param CreateTestOptions(bool allowUnsafe = false) 657740"];
449 [label="outputKind 657741"];
450 [label="optimizationLevel: optimizationLevel 657742"];
451 [label="warningLevel: Diagnostic.MaxWarningLevel 657743"];
452 [label="allowUnsafe: allowUnsafe 657744"];
453 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657745"];
454 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657746"];
455 [label="DebugWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 657747"];
456 [label="OutputKind.NetModule 657748"];
457 [label="OptimizationLevel.Release 657749"];
458 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 657750"];
459 [label="param CreateTestOptions(OutputKind outputKind) 657751"];
460 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 657752"];
461 [label="param CreateTestOptions(bool allowUnsafe = false) 657753"];
462 [label="outputKind 657754"];
463 [label="optimizationLevel: optimizationLevel 657755"];
464 [label="warningLevel: Diagnostic.MaxWarningLevel 657756"];
465 [label="allowUnsafe: allowUnsafe 657757"];
466 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657758"];
467 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657759"];
468 [label="ReleaseModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 657760"];
469 [label="OutputKind.NetModule 657761"];
470 [label="OptimizationLevel.Debug 657762"];
471 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 657763"];
472 [label="param CreateTestOptions(OutputKind outputKind) 657764"];
473 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 657765"];
474 [label="param CreateTestOptions(bool allowUnsafe = false) 657766"];
475 [label="outputKind 657767"];
476 [label="optimizationLevel: optimizationLevel 657768"];
477 [label="warningLevel: Diagnostic.MaxWarningLevel 657769"];
478 [label="allowUnsafe: allowUnsafe 657770"];
479 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657771"];
480 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 657772"];
481 [label="DebugModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 657773"];
482 [label="true 657774"];
483 [label="ReleaseDll.WithAllowUnsafe(true) 657775"];
484 [label="UnsafeReleaseDll = ReleaseDll.WithAllowUnsafe(true) 657776"];
485 [label="true 657777"];
486 [label="ReleaseExe.WithAllowUnsafe(true) 657778"];
487 [label="UnsafeReleaseExe = ReleaseExe.WithAllowUnsafe(true) 657779"];
488 [label="true 657780"];
489 [label="DebugDll.WithAllowUnsafe(true) 657781"];
490 [label="UnsafeDebugDll = DebugDll.WithAllowUnsafe(true) 657782"];
491 [label="true 657783"];
492 [label="DebugExe.WithAllowUnsafe(true) 657784"];
493 [label="UnsafeDebugExe = DebugExe.WithAllowUnsafe(true) 657785"];
494 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 657786"];
495 [label="ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 657787"];
496 [label="SigningReleaseDll = ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 657788"];
497 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 657789"];
498 [label="ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 657790"];
499 [label="SigningReleaseExe = ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 657791"];
500 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 657792"];
501 [label="ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 657793"];
502 [label="SigningReleaseModule = ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 657794"];
503 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 657795"];
504 [label="DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 657796"];
505 [label="SigningDebugDll = DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 657797"];
506 [label="DebugInformationFormat.Pdb 657798"];
507 [label="EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 657799"];
508 [label="NativePdbEmit = EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 657800"];
509 [label="options = TestOptions.Regular; 657801"];
510 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 657802"];
511 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 657803"];
512 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 657804"];
513 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 657805"];
514 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 657806"];
515 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 657807"];
516 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 657808"];
517 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 657809"];
518 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 657810"];
519 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 657811"];
520 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 657812"];
521 [label="param CheckSerializable(SyntaxTree tree) 657813"];
522 [label="var stream = new MemoryStream(); 657814"];
523 [label="var root = tree.GetRoot(); 657815"];
524 [label="var root = tree.GetRoot(); 657816"];
525 [label="root.SerializeTo(stream); 657817"];
526 [label="root.SerializeTo(stream); 657818"];
527 [label="root.SerializeTo(stream); 657819"];
528 [label="stream.Position = 0; 657820"];
529 [label="stream.Position 657821"];
530 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 657822"];
531 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 657823"];
532 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 657824"];
533 [label="return tree; 657825"];
534 [label="new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) } 657826"];
535 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 657827"];
536 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 657828"];
537 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 657829"];
538 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 657830"];
539 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 657831"];
540 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 657832"];
541 [label="hasTopLevelStatements 657833"];
542 [label="options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll; 657834"];
543 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 657835"];
544 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 657836"];
545 [label="Func<CSharpCompilation> createCompilationLambda = () => CSharpCompilation.Create(\n                assemblyName == '' ? GetUniqueName() : assemblyName,\n                syntaxTrees,\n                references,\n                options); 657837"];
546 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 657838"];
547 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 657839"];
548 [label="param ValidateIOperations(Func<Compilation> createCompilation) 657840"];
549 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 657841"];
550 [label="return; 657842"];
551 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 657843"];
552 [label="var compilation = createCompilationLambda(); 657844"];
553 [label="var compilation = createCompilationLambda(); 657845"];
554 [label="return Guid.NewGuid().ToString('D'); 657846"];
555 [label="var compilation = createCompilationLambda(); 657847"];
556 [label="OutputKind.ConsoleApplication 657848"];
557 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 657849"];
558 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 657850"];
559 [label="s_defaultOptions = new CSharpCompilationOptions(OutputKind.ConsoleApplication) 657851"];
560 [label="OutputKind.DynamicallyLinkedLibrary 657852"];
561 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 657853"];
562 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 657854"];
563 [label="true 657855"];
564 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 657856"];
565 [label="s_defaultSubmissionOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 657857"];
566 [label="param Create(string? assemblyName) 657858"];
567 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees = null) 657859"];
568 [label="param Create(IEnumerable<MetadataReference>? references = null) 657860"];
569 [label="param Create(CSharpCompilationOptions? options = null) 657861"];
570 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 657862"];
571 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 657863"];
572 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 657864"];
573 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 657865"];
574 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 657866"];
575 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 657867"];
576 [label="param Create(string? assemblyName) 657868"];
577 [label="param Create(CSharpCompilationOptions options) 657869"];
578 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees) 657870"];
579 [label="param Create(IEnumerable<MetadataReference>? references) 657871"];
580 [label="param Create(CSharpCompilation? previousSubmission) 657872"];
581 [label="param Create(Type? returnType) 657873"];
582 [label="param Create(Type? hostObjectType) 657874"];
583 [label="param Create(bool isSubmission) 657875"];
584 [label="RoslynDebug.Assert(options != null); 657876"];
585 [label="RoslynDebug.Assert(options != null); 657877"];
586 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 657878"];
587 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 657879"];
588 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 657880"];
589 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 657881"];
590 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 657882"];
591 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 657883"];
592 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 657884"];
593 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 657885"];
594 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 657886"];
595 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 657887"];
596 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 657888"];
597 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 657889"];
598 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 657890"];
599 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 657891"];
600 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 657892"];
601 [label="param CSharpCompilation(string? assemblyName) 657893"];
602 [label="param CSharpCompilation(CSharpCompilationOptions options) 657894"];
603 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 657895"];
604 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 657896"];
605 [label="param CSharpCompilation(Type? submissionReturnType) 657897"];
606 [label="param CSharpCompilation(Type? hostObjectType) 657898"];
607 [label="param CSharpCompilation(bool isSubmission) 657899"];
608 [label="param CSharpCompilation(ReferenceManager? referenceManager) 657900"];
609 [label="param CSharpCompilation(bool reuseReferenceManager) 657901"];
610 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 657902"];
611 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 657903"];
612 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 657904"];
613 [label="param CSharpCompilation(this) 657905"];
614 [label="assemblyName 657906"];
615 [label="options 657907"];
616 [label="references 657908"];
617 [label="previousSubmission 657909"];
618 [label="submissionReturnType 657910"];
619 [label="hostObjectType 657911"];
620 [label="isSubmission 657912"];
621 [label="referenceManager 657913"];
622 [label="reuseReferenceManager 657914"];
623 [label="syntaxAndDeclarations 657915"];
624 [label="syntaxAndDeclarations.ExternalSyntaxTrees 657916"];
625 [label="SyntaxTreeCommonFeatures(syntaxAndDeclarations.ExternalSyntaxTrees) 657917"];
626 [label="semanticModelProvider 657918"];
627 [label="eventQueue 657919"];
628 [label="param CSharpCompilation(this) 657920"];
629 [label="param CSharpCompilation(string? assemblyName) 657921"];
630 [label="param CSharpCompilation(CSharpCompilationOptions options) 657922"];
631 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 657923"];
632 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 657924"];
633 [label="param CSharpCompilation(Type? submissionReturnType) 657925"];
634 [label="param CSharpCompilation(Type? hostObjectType) 657926"];
635 [label="param CSharpCompilation(bool isSubmission) 657927"];
636 [label="param CSharpCompilation(ReferenceManager? referenceManager) 657928"];
637 [label="param CSharpCompilation(bool reuseReferenceManager) 657929"];
638 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 657930"];
639 [label="param CSharpCompilation(IReadOnlyDictionary<string, string> features) 657931"];
640 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 657932"];
641 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 657933"];
642 [label="param CSharpCompilation(this) 657934"];
643 [label="assemblyName 657935"];
644 [label="references 657936"];
645 [label="features 657937"];
646 [label="isSubmission 657938"];
647 [label="semanticModelProvider 657939"];
648 [label="eventQueue 657940"];
649 [label="param CSharpCompilation(this) 657941"];
650 [label="param CSharpCompilation(this) 657942"];
651 [label="_options 657943"];
652 [label="_globalImports 657944"];
653 [label="_previousSubmissionImports 657945"];
654 [label="_globalNamespaceAlias 657946"];
655 [label="_scriptClass 657947"];
656 [label="_lazyHostObjectTypeSymbol 657948"];
657 [label="_lazyImportInfos 657949"];
658 [label="_conversions 657950"];
659 [label="_anonymousTypeManager 657951"];
660 [label="_lazyGlobalNamespace 657952"];
661 [label="builtInOperators 657953"];
662 [label="_lazyAssemblySymbol 657954"];
663 [label="_referenceManager 657955"];
664 [label="_syntaxAndDeclarations 657956"];
665 [label="_lazyEntryPoint 657957"];
666 [label="_lazyEmitNullablePublicOnly 657958"];
667 [label="_lazyCompilationUnitCompletedTrees 657959"];
668 [label="NullableAnalysisData 657960"];
669 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 657961"];
670 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 657962"];
671 [label="_externAliasTargets 657963"];
672 [label="_moduleInitializerMethods 657964"];
673 [label="_binderFactories 657965"];
674 [label="_ignoreAccessibilityBinderFactories 657966"];
675 [label="_lazyDeclarationDiagnostics 657967"];
676 [label="_declarationDiagnosticsFrozen 657968"];
677 [label="new DiagnosticBag() 657969"];
678 [label="_additionalCodegenWarnings = new DiagnosticBag() 657970"];
679 [label="WellKnownMemberSignatureComparer 657971"];
680 [label="_lazyWellKnownTypes 657972"];
681 [label="_lazyWellKnownTypeMembers 657973"];
682 [label="_usesNullableAttributes 657974"];
683 [label="_needsGeneratedAttributes 657975"];
684 [label="_needsGeneratedAttributes_IsFrozen 657976"];
685 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 657977"];
686 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 657978"];
687 [label="new WellKnownMembersSignatureComparer(this) 657979"];
688 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 657980"];
689 [label="param WellKnownMembersSignatureComparer(this) 657981"];
690 [label="new SpecialMembersSignatureComparer() 657982"];
691 [label="param SpecialMembersSignatureComparer(this) 657983"];
692 [label="Instance = new SpecialMembersSignatureComparer() 657984"];
693 [label="param WellKnownMembersSignatureComparer(this) 657985"];
694 [label="param SpecialMembersSignatureComparer(this) 657986"];
695 [label="param SpecialMembersSignatureComparer(this) 657987"];
696 [label="_compilation 657988"];
697 [label="_compilation 657989"];
698 [label="WellKnownMemberSignatureComparer 657990"];
699 [label="_options 657991"];
700 [label="this.builtInOperators = new BuiltInOperators(this); 657992"];
701 [label="this.builtInOperators = new BuiltInOperators(this); 657993"];
702 [label="this.builtInOperators 657994"];
703 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 657995"];
704 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 657996"];
705 [label="_scriptClass 657997"];
706 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 657998"];
707 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 657999"];
708 [label="_globalImports 658000"];
709 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 658001"];
710 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 658002"];
711 [label="_previousSubmissionImports 658003"];
712 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 658004"];
713 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 658005"];
714 [label="_globalNamespaceAlias 658006"];
715 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 658007"];
716 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 658008"];
717 [label="new AnonymousTypeManager(this) 658009"];
718 [label="param AnonymousTypeManager(CSharpCompilation compilation) 658010"];
719 [label="param AnonymousTypeManager(this) 658011"];
720 [label="param AnonymousTypeManager(this) 658012"];
721 [label="public CSharpCompilation Compilation { get; } 658013"];
722 [label="_lazyAnonymousTypeTemplates 658014"];
723 [label="_lazySynthesizedDelegates 658015"];
724 [label="new ConcurrentDictionary<Location, bool>() 658016"];
725 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 658017"];
726 [label="Debug.Assert(compilation != null); 658018"];
727 [label="Debug.Assert(compilation != null); 658019"];
728 [label="this.Compilation 658020"];
729 [label="_anonymousTypeManager 658021"];
730 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 658022"];
731 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 658023"];
732 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 658024"];
733 [label="LanguageVersion? result = null; 658025"];
734 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 658026"];
735 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 658027"];
736 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 658028"];
737 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 658029"];
738 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 658030"];
739 [label="this.LanguageVersion 658031"];
740 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 658032"];
741 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 658033"];
742 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 658034"];
743 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 658035"];
744 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 658036"];
745 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 658037"];
746 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 658038"];
747 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 658039"];
748 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 658040"];
749 [label="this.Options 658041"];
750 [label="get\n            {\n                return _options;\n            } 658042"];
751 [label="return _options; 658043"];
752 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 658044"];
753 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 658045"];
754 [label="new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata) 658046"];
755 [label="param ReferenceManager(string simpleAssemblyName) 658047"];
756 [label="param ReferenceManager(AssemblyIdentityComparer identityComparer) 658048"];
757 [label="param ReferenceManager(Dictionary<MetadataReference, MetadataOrDiagnostic>? observedMetadata) 658049"];
758 [label="param ReferenceManager(this) 658050"];
759 [label="simpleAssemblyName 658051"];
760 [label="identityComparer 658052"];
761 [label="observedMetadata 658053"];
762 [label="param ReferenceManager(this) 658054"];
763 [label="param ReferenceManager(this) 658055"];
764 [label="_referenceManager 658056"];
765 [label="_syntaxAndDeclarations 658057"];
766 [label="Debug.Assert(_lazyAssemblySymbol is null); 658058"];
767 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 658059"];
768 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 658060"];
769 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 658061"];
770 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 658062"];
771 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 658063"];
772 [label="compilation.AddSyntaxTrees(syntaxTrees) 658064"];
773 [label="param AddSyntaxTrees(IEnumerable<SyntaxTree> trees) 658065"];
774 [label="param AddSyntaxTrees(this) 658066"];
775 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 658067"];
776 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 658068"];
777 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 658069"];
778 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 658070"];
779 [label="var externalSyntaxTrees = PooledHashSet<SyntaxTree>.GetInstance(); 658071"];
780 [label="var syntaxAndDeclarations = _syntaxAndDeclarations; 658072"];
781 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 658073"];
782 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 658074"];
783 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 658075"];
784 [label="bool reuseReferenceManager = true; 658076"];
785 [label="int i = 0; 658077"];
786 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 658078"];
787 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 658079"];
788 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 658080"];
789 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 658081"];
790 [label="if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                } 658082"];
791 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 658083"];
792 [label="externalSyntaxTrees.Add(tree); 658084"];
793 [label="externalSyntaxTrees.Add(tree); 658085"];
794 [label="reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives; 658086"];
795 [label="i++; 658087"];
796 [label="externalSyntaxTrees.Free(); 658088"];
797 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 658089"];
798 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 658090"];
799 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 658091"];
800 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 658092"];
801 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 658093"];
802 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 658094"];
803 [label="Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations) 658095"];
804 [label="param Update(ReferenceManager referenceManager) 658096"];
805 [label="param Update(bool reuseReferenceManager) 658097"];
806 [label="param Update(SyntaxAndDeclarationManager syntaxAndDeclarations) 658098"];
807 [label="param Update(this) 658099"];
808 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 658100"];
809 [label="this.PreviousSubmission 658101"];
810 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 658102"];
811 [label="ScriptCompilationInfo 658103"];
812 [label="ScriptCompilationInfo?.PreviousScriptCompilation 658104"];
813 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 658105"];
814 [label="this.SubmissionReturnType 658106"];
815 [label="=> ScriptCompilationInfo 658107"];
816 [label="ScriptCompilationInfo 658108"];
817 [label="this.HostObjectType 658109"];
818 [label="=> ScriptCompilationInfo 658110"];
819 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 658111"];
820 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 658112"];
821 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 658113"];
822 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 658114"];
823 [label="new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider) 658115"];
824 [label="param CSharpCompilation(string? assemblyName) 658116"];
825 [label="param CSharpCompilation(CSharpCompilationOptions options) 658117"];
826 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 658118"];
827 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 658119"];
828 [label="param CSharpCompilation(Type? submissionReturnType) 658120"];
829 [label="param CSharpCompilation(Type? hostObjectType) 658121"];
830 [label="param CSharpCompilation(bool isSubmission) 658122"];
831 [label="param CSharpCompilation(ReferenceManager? referenceManager) 658123"];
832 [label="param CSharpCompilation(bool reuseReferenceManager) 658124"];
833 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 658125"];
834 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 658126"];
835 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 658127"];
836 [label="param CSharpCompilation(this) 658128"];
837 [label="previousSubmission 658129"];
838 [label="submissionReturnType 658130"];
839 [label="hostObjectType 658131"];
840 [label="syntaxAndDeclarations.ExternalSyntaxTrees 658132"];
841 [label="eventQueue 658133"];
842 [label="param CSharpCompilation(this) 658134"];
843 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 658135"];
844 [label="param CSharpCompilation(Type? submissionReturnType) 658136"];
845 [label="param CSharpCompilation(Type? hostObjectType) 658137"];
846 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 658138"];
847 [label="param CSharpCompilation(this) 658139"];
848 [label="eventQueue 658140"];
849 [label="param CSharpCompilation(this) 658141"];
850 [label="_options 658142"];
851 [label="_globalImports 658143"];
852 [label="_previousSubmissionImports 658144"];
853 [label="_globalNamespaceAlias 658145"];
854 [label="_scriptClass 658146"];
855 [label="_lazyHostObjectTypeSymbol 658147"];
856 [label="_lazyImportInfos 658148"];
857 [label="_conversions 658149"];
858 [label="_anonymousTypeManager 658150"];
859 [label="_lazyGlobalNamespace 658151"];
860 [label="builtInOperators 658152"];
861 [label="_lazyAssemblySymbol 658153"];
862 [label="_referenceManager 658154"];
863 [label="_syntaxAndDeclarations 658155"];
864 [label="_lazyEntryPoint 658156"];
865 [label="_lazyEmitNullablePublicOnly 658157"];
866 [label="_lazyCompilationUnitCompletedTrees 658158"];
867 [label="NullableAnalysisData 658159"];
868 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 658160"];
869 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 658161"];
870 [label="_externAliasTargets 658162"];
871 [label="_moduleInitializerMethods 658163"];
872 [label="_binderFactories 658164"];
873 [label="_ignoreAccessibilityBinderFactories 658165"];
874 [label="_lazyDeclarationDiagnostics 658166"];
875 [label="_declarationDiagnosticsFrozen 658167"];
876 [label="new DiagnosticBag() 658168"];
877 [label="_additionalCodegenWarnings = new DiagnosticBag() 658169"];
878 [label="WellKnownMemberSignatureComparer 658170"];
879 [label="_lazyWellKnownTypes 658171"];
880 [label="_lazyWellKnownTypeMembers 658172"];
881 [label="_usesNullableAttributes 658173"];
882 [label="_needsGeneratedAttributes 658174"];
883 [label="_needsGeneratedAttributes_IsFrozen 658175"];
884 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 658176"];
885 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 658177"];
886 [label="new WellKnownMembersSignatureComparer(this) 658178"];
887 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 658179"];
888 [label="param WellKnownMembersSignatureComparer(this) 658180"];
889 [label="param WellKnownMembersSignatureComparer(this) 658181"];
890 [label="param SpecialMembersSignatureComparer(this) 658182"];
891 [label="param SpecialMembersSignatureComparer(this) 658183"];
892 [label="_compilation 658184"];
893 [label="_compilation 658185"];
894 [label="WellKnownMemberSignatureComparer 658186"];
895 [label="this.builtInOperators = new BuiltInOperators(this); 658187"];
896 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 658188"];
897 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 658189"];
898 [label="new AnonymousTypeManager(this) 658190"];
899 [label="param AnonymousTypeManager(CSharpCompilation compilation) 658191"];
900 [label="param AnonymousTypeManager(this) 658192"];
901 [label="param AnonymousTypeManager(this) 658193"];
902 [label="public CSharpCompilation Compilation { get; } 658194"];
903 [label="_lazyAnonymousTypeTemplates 658195"];
904 [label="_lazySynthesizedDelegates 658196"];
905 [label="new ConcurrentDictionary<Location, bool>() 658197"];
906 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 658198"];
907 [label="Debug.Assert(compilation != null); 658199"];
908 [label="Debug.Assert(compilation != null); 658200"];
909 [label="this.Compilation 658201"];
910 [label="_anonymousTypeManager 658202"];
911 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 658203"];
912 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 658204"];
913 [label="LanguageVersion? result = null; 658205"];
914 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 658206"];
915 [label="var version = ((CSharpParseOptions)tree.Options).LanguageVersion; 658207"];
916 [label="if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                } 658208"];
917 [label="result = version; 658209"];
918 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 658210"];
919 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 658211"];
920 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 658212"];
921 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 658213"];
922 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 658214"];
923 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 658215"];
924 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 658216"];
925 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 658217"];
926 [label="referenceManager.AssertCanReuseForCompilation(this); 658218"];
927 [label="referenceManager.AssertCanReuseForCompilation(this); 658219"];
928 [label="_referenceManager 658220"];
929 [label="Debug.Assert(_lazyAssemblySymbol is null); 658221"];
930 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 658222"];
931 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 658223"];
932 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 658224"];
933 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 658225"];
934 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 658226"];
935 [label="return compilation; 658227"];
936 [label="var compilation = createCompilationLambda(); 658228"];
937 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 658229"];
938 [label="IsNullableEnabled(compilation) 658230"];
939 [label="param IsNullableEnabled(CSharpCompilation compilation) 658231"];
940 [label="compilation.SyntaxTrees 658232"];
941 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 658233"];
942 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 658234"];
943 [label="var trees = compilation.SyntaxTrees; 658235"];
944 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 658236"];
945 [label="var options = (CSharpParseOptions)trees[0].Options; 658237"];
946 [label="var options = (CSharpParseOptions)trees[0].Options; 658238"];
947 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 658239"];
948 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 658240"];
949 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 658241"];
950 [label="return compilation; 658242"];
951 [label="comp.GlobalNamespace 658243"];
952 [label="get\n            {\n                if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                }\n\n                return _lazyGlobalNamespace;\n            } 658244"];
953 [label="if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                } 658245"];
954 [label="var modules = ArrayBuilder<ModuleSymbol>.GetInstance(); 658246"];
955 [label="GetAllUnaliasedModules(modules); 658247"];
956 [label="GetAllUnaliasedModules(modules) 658248"];
957 [label="param GetAllUnaliasedModules(ArrayBuilder<ModuleSymbol> modules) 658249"];
958 [label="param GetAllUnaliasedModules(this) 658250"];
959 [label="Assembly 658251"];
960 [label="get\n            {\n                return SourceAssembly;\n            } 658252"];
961 [label="SourceAssembly 658253"];
962 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 658254"];
963 [label="GetBoundReferenceManager() 658255"];
964 [label="param GetBoundReferenceManager(this) 658256"];
965 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 658257"];
966 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 658258"];
967 [label="_referenceManager.CreateSourceAssemblyForCompilation(this) 658259"];
968 [label="param CreateSourceAssemblyForCompilation(CSharpCompilation compilation) 658260"];
969 [label="param CreateSourceAssemblyForCompilation(this) 658261"];
970 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 658262"];
971 [label="CreateAndSetSourceAssemblyFullBind(compilation) 658263"];
972 [label="param CreateAndSetSourceAssemblyFullBind(CSharpCompilation compilation) 658264"];
973 [label="param CreateAndSetSourceAssemblyFullBind(this) 658265"];
974 [label="var resolutionDiagnostics = DiagnosticBag.GetInstance(); 658266"];
975 [label="var assemblyReferencesBySimpleName = PooledDictionary<string, List<ReferencedAssemblyIdentity>>.GetInstance(); 658267"];
976 [label="compilation.Options 658268"];
977 [label="get\n            {\n                return _options;\n            } 658269"];
978 [label="bool supersedeLowerVersions = compilation.Options.ReferencesSupersedeLowerVersions; 658270"];
979 [label="IDictionary<(string, string), MetadataReference>? boundReferenceDirectiveMap; 658271"];
980 [label="ImmutableArray<MetadataReference> boundReferenceDirectives; 658272"];
981 [label="boundReferenceDirectives 658273"];
982 [label="ImmutableArray<AssemblyData> referencedAssemblies; 658274"];
983 [label="referencedAssemblies 658275"];
984 [label="ImmutableArray<PEModule> modules; 658276"];
985 [label="modules 658277"];
986 [label="ImmutableArray<MetadataReference> explicitReferences; 658278"];
987 [label="explicitReferences 658279"];
988 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 658280"];
989 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 658281"];
990 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 658282"];
991 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 658283"];
992 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 658284"];
993 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 658285"];
994 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 658286"];
995 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 658287"];
996 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 658288"];
997 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 658289"];
998 [label="get { return this.Declarations.ReferenceDirectives; } 658290"];
999 [label="this.Declarations 658291"];
1000 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 658292"];
1001 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 658293"];
1002 [label="return this.Declarations.ReferenceDirectives; 658294"];
1003 [label="SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 658295"];
1004 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 658296"];
1005 [label="SymbolDisplayCompilerInternalOptions.None 658297"];
1006 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 658298"];
1007 [label="s_debuggerDisplayFormat =\n            SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 658299"];
1008 [label="this.Declarations.ReferenceDirectives 658300"];
1009 [label="param ReportErrorIfHasConstraints(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) 658301"];
1010 [label="param ReportErrorIfHasConstraints(DiagnosticBag diagnostics) 658302"];
1011 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 658303"];
1012 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 658304"];
1013 [label="param ToDeclarationModifiers(this SyntaxTokenList modifiers) 658305"];
1014 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 658306"];
1015 [label="var result = DeclarationModifiers.None; 658307"];
1016 [label="bool seenNoDuplicates = true; 658308"];
1017 [label="bool seenNoAccessibilityDuplicates = true; 658309"];
1018 [label="foreach (var modifier in modifiers)\n            {\n                DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind());\n\n                ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics);\n\n                result |= one;\n            } 658310"];
1019 [label="DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind()); 658311"];
1020 [label="ToDeclarationModifier(modifier.ContextualKind()) 658312"];
1021 [label="param ToDeclarationModifier(SyntaxKind kind) 658313"];
1022 [label="switch (kind)\n            {\n                case SyntaxKind.AbstractKeyword:\n                    return DeclarationModifiers.Abstract;\n                case SyntaxKind.AsyncKeyword:\n                    return DeclarationModifiers.Async;\n                case SyntaxKind.SealedKeyword:\n                    return DeclarationModifiers.Sealed;\n                case SyntaxKind.StaticKeyword:\n                    return DeclarationModifiers.Static;\n                case SyntaxKind.NewKeyword:\n                    return DeclarationModifiers.New;\n                case SyntaxKind.PublicKeyword:\n                    return DeclarationModifiers.Public;\n                case SyntaxKind.ProtectedKeyword:\n                    return DeclarationModifiers.Protected;\n                case SyntaxKind.InternalKeyword:\n                    return DeclarationModifiers.Internal;\n                case SyntaxKind.PrivateKeyword:\n                    return DeclarationModifiers.Private;\n                case SyntaxKind.ExternKeyword:\n                    return DeclarationModifiers.Extern;\n                case SyntaxKind.ReadOnlyKeyword:\n                    return DeclarationModifiers.ReadOnly;\n                case SyntaxKind.PartialKeyword:\n                    return DeclarationModifiers.Partial;\n                case SyntaxKind.UnsafeKeyword:\n                    return DeclarationModifiers.Unsafe;\n                case SyntaxKind.VirtualKeyword:\n                    return DeclarationModifiers.Virtual;\n                case SyntaxKind.OverrideKeyword:\n                    return DeclarationModifiers.Override;\n                case SyntaxKind.ConstKeyword:\n                    return DeclarationModifiers.Const;\n                case SyntaxKind.FixedKeyword:\n                    return DeclarationModifiers.Fixed;\n                case SyntaxKind.VolatileKeyword:\n                    return DeclarationModifiers.Volatile;\n                case SyntaxKind.RefKeyword:\n                    return DeclarationModifiers.Ref;\n                case SyntaxKind.DataKeyword:\n                    return DeclarationModifiers.Data;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 658314"];
1023 [label="return DeclarationModifiers.Public; 658315"];
1024 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 658316"];
1025 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 658317"];
1026 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 658318"];
1027 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 658319"];
1028 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 658320"];
1029 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 658321"];
1030 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics) 658322"];
1031 [label="param ReportDuplicateModifiers(SyntaxToken modifierToken) 658323"];
1032 [label="param ReportDuplicateModifiers(DeclarationModifiers modifierKind) 658324"];
1033 [label="param ReportDuplicateModifiers(DeclarationModifiers allModifiers) 658325"];
1034 [label="param ReportDuplicateModifiers(ref bool seenNoDuplicates) 658326"];
1035 [label="param ReportDuplicateModifiers(ref bool seenNoAccessibilityDuplicates) 658327"];
1036 [label="param ReportDuplicateModifiers(DiagnosticBag diagnostics) 658328"];
1037 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 658329"];
1038 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 658330"];
1039 [label="result |= one; 658331"];
1040 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 658332"];
1041 [label="return result; 658333"];
1042 [label="get { return _options; } 658334"];
1043 [label="return _options; 658335"];
1044 [label="get { return CSharp.MessageProvider.Instance; } 658336"];
1045 [label="return CSharp.MessageProvider.Instance; 658337"];
1046 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 658338"];
1047 [label="param CreateAssemblyDataForFile(PEAssembly assembly) 658339"];
1048 [label="param CreateAssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 658340"];
1049 [label="param CreateAssemblyDataForFile(DocumentationProvider documentationProvider) 658341"];
1050 [label="param CreateAssemblyDataForFile(string sourceAssemblySimpleName) 658342"];
1051 [label="param CreateAssemblyDataForFile(MetadataImportOptions importOptions) 658343"];
1052 [label="param CreateAssemblyDataForFile(bool embedInteropTypes) 658344"];
1053 [label="param CreateAssemblyDataForFile(this) 658345"];
1054 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 658346"];
1055 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 658347"];
1056 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 658348"];
1057 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 658349"];
1058 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 658350"];
1059 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 658351"];
1060 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 658352"];
1061 [label="new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions) 658353"];
1062 [label="param AssemblyDataForFile(PEAssembly assembly) 658354"];
1063 [label="param AssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 658355"];
1064 [label="param AssemblyDataForFile(bool embedInteropTypes) 658356"];
1065 [label="param AssemblyDataForFile(DocumentationProvider documentationProvider) 658357"];
1066 [label="param AssemblyDataForFile(string sourceAssemblySimpleName) 658358"];
1067 [label="param AssemblyDataForFile(MetadataImportOptions compilationImportOptions) 658359"];
1068 [label="param AssemblyDataForFile(this) 658360"];
1069 [label="assembly.Identity 658361"];
1070 [label="assembly.AssemblyReferences 658362"];
1071 [label="embedInteropTypes 658363"];
1072 [label="param AssemblyDataForFile(this) 658364"];
1073 [label="param AssemblyDataForMetadataOrCompilation(AssemblyIdentity identity) 658365"];
1074 [label="param AssemblyDataForMetadataOrCompilation(ImmutableArray<AssemblyIdentity> referencedAssemblies) 658366"];
1075 [label="param AssemblyDataForMetadataOrCompilation(bool embedInteropTypes) 658367"];
1076 [label="param AssemblyDataForMetadataOrCompilation(this) 658368"];
1077 [label="param AssemblyDataForMetadataOrCompilation(this) 658369"];
1078 [label="_assemblies 658370"];
1079 [label="_identity 658371"];
1080 [label="_embedInteropTypes 658372"];
1081 [label="RoslynDebug.Assert(identity != null); 658373"];
1082 [label="RoslynDebug.Assert(identity != null); 658374"];
1083 [label="Debug.Assert(!referencedAssemblies.IsDefault); 658375"];
1084 [label="_embedInteropTypes 658376"];
1085 [label="_identity 658377"];
1086 [label="_referencedAssemblies 658378"];
1087 [label="Assembly 658379"];
1088 [label="CachedSymbols 658380"];
1089 [label="DocumentationProvider 658381"];
1090 [label="_compilationImportOptions 658382"];
1091 [label="_sourceAssemblySimpleName 658383"];
1092 [label="_internalsVisibleComputed 658384"];
1093 [label="_internalsPotentiallyVisibleToCompilation 658385"];
1094 [label="RoslynDebug.Assert(documentationProvider != null); 658386"];
1095 [label="RoslynDebug.Assert(documentationProvider != null); 658387"];
1096 [label="RoslynDebug.Assert(cachedSymbols != null); 658388"];
1097 [label="RoslynDebug.Assert(cachedSymbols != null); 658389"];
1098 [label="CachedSymbols 658390"];
1099 [label="Assembly 658391"];
1100 [label="DocumentationProvider 658392"];
1101 [label="_compilationImportOptions 658393"];
1102 [label="_sourceAssemblySimpleName 658394"];
1103 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 658395"];
1104 [label="RoslynDebug.Assert(identity != null); 658396"];
1105 [label="Debug.Assert(!referencedAssemblies.IsDefault); 658397"];
1106 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 658398"];
1107 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 658399"];
1108 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 658400"];
1109 [label="get\n                    {\n                        return _identity;\n                    } 658401"];
1110 [label="return _identity; 658402"];
1111 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 658403"];
1112 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 658404"];
1113 [label="bool hasCircularReference; 658405"];
1114 [label="int corLibraryIndex; 658406"];
1115 [label="ImmutableArray<MetadataReference> implicitlyResolvedReferences; 658407"];
1116 [label="implicitlyResolvedReferences 658408"];
1117 [label="ImmutableArray<ResolvedReference> implicitlyResolvedReferenceMap; 658409"];
1118 [label="implicitlyResolvedReferenceMap 658410"];
1119 [label="ImmutableArray<AssemblyData> allAssemblyData; 658411"];
1120 [label="allAssemblyData 658412"];
1121 [label="var temp1 = compilation.ScriptCompilationInfo; 658413"];
1122 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 658414"];
1123 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 658415"];
1124 [label="temp1 != null 658416"];
1125 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 658417"];
1126 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 658418"];
1127 [label="temp2 != null 658419"];
1128 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 658420"];
1129 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 658421"];
1130 [label="temp3 != null 658422"];
1131 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 658423"];
1132 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 658424"];
1133 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658425"];
1134 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658426"];
1135 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658427"];
1136 [label="compilation.Options 658428"];
1137 [label="get\n            {\n                return _options;\n            } 658429"];
1138 [label="return _options; 658430"];
1139 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658431"];
1140 [label="compilation.Options 658432"];
1141 [label="get\n            {\n                return _options;\n            } 658433"];
1142 [label="return _options; 658434"];
1143 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658435"];
1144 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658436"];
1145 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658437"];
1146 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658438"];
1147 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658439"];
1148 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658440"];
1149 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658441"];
1150 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658442"];
1151 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658443"];
1152 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658444"];
1153 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658445"];
1154 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 658446"];
1155 [label="param BindAssemblyReferences(ImmutableArray<AssemblyData> assemblies) 658447"];
1156 [label="param BindAssemblyReferences(AssemblyIdentityComparer assemblyIdentityComparer) 658448"];
1157 [label="param BindAssemblyReferences(this) 658449"];
1158 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 658450"];
1159 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 658451"];
1160 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 658452"];
1161 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 658453"];
1162 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 658454"];
1163 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 658455"];
1164 [label="return _embedInteropTypes; 658456"];
1165 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 658457"];
1166 [label="return _referencedAssemblies; 658458"];
1167 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 658459"];
1168 [label="return Assembly.ContainsNoPiaLocalTypes(); 658460"];
1169 [label="get\n                    {\n                        return Assembly.DeclaresTheObjectClass;\n                    } 658461"];
1170 [label="return Assembly.DeclaresTheObjectClass; 658462"];
1171 [label="get\n                    {\n                        if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        }\n\n                        return _assemblies;\n                    } 658463"];
1172 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 658464"];
1173 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 658465"];
1174 [label="_assemblies = new List<AssemblySymbol>(); 658466"];
1175 [label="_assemblies 658467"];
1176 [label="AddAvailableSymbols(_assemblies); 658468"];
1177 [label="AddAvailableSymbols(_assemblies) 658469"];
1178 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 658470"];
1179 [label="param AddAvailableSymbols(this) 658471"];
1180 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 658472"];
1181 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 658473"];
1182 [label="AddAvailableSymbols(_assemblies); 658474"];
1183 [label="return _assemblies; 658475"];
1184 [label="AddAvailableSymbols(_assemblies); 658476"];
1185 [label="AddAvailableSymbols(_assemblies) 658477"];
1186 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 658478"];
1187 [label="param AddAvailableSymbols(this) 658479"];
1188 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 658480"];
1189 [label="AddAvailableSymbols(_assemblies); 658481"];
1190 [label="Debug.Assert(bindingResult.Length == allAssemblyData.Length); 658482"];
1191 [label="var references = explicitReferences.AddRange(implicitlyResolvedReferences); 658483"];
1192 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 658484"];
1193 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 658485"];
1194 [label="Dictionary<MetadataReference, int> referencedAssembliesMap, referencedModulesMap; 658486"];
1195 [label="ImmutableArray<ImmutableArray<string>> aliasesOfReferencedAssemblies; 658487"];
1196 [label="aliasesOfReferencedAssemblies 658488"];
1197 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 658489"];
1198 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 658490"];
1199 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 658491"];
1200 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 658492"];
1201 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 658493"];
1202 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 658494"];
1203 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 658495"];
1204 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 658496"];
1205 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 658497"];
1206 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 658498"];
1207 [label="var newSymbols = new List<int>(); 658499"];
1208 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 658500"];
1209 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 658501"];
1210 [label="ref BoundInputAssembly bound = ref bindingResult[i]; 658502"];
1211 [label="if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        } 658503"];
1212 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 658504"];
1213 [label="((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol() 658505"];
1214 [label="param CreateAssemblySymbol(this) 658506"];
1215 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 658507"];
1216 [label="this.IsLinked 658508"];
1217 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 658509"];
1218 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 658510"];
1219 [label="this.EffectiveImportOptions 658511"];
1220 [label="get\n                    {\n                        // We need to import internal members if they might be visible to the compilation being compiled:\n                        if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        }\n\n                        return _compilationImportOptions;\n                    } 658512"];
1221 [label="InternalsMayBeVisibleToCompilation 658513"];
1222 [label="get\n                    {\n                        if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        }\n\n                        return _internalsPotentiallyVisibleToCompilation;\n                    } 658514"];
1223 [label="if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        } 658515"];
1224 [label="_internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly); 658516"];
1225 [label="_internalsPotentiallyVisibleToCompilation 658517"];
1226 [label="_internalsVisibleComputed = true; 658518"];
1227 [label="_internalsVisibleComputed 658519"];
1228 [label="return _internalsPotentiallyVisibleToCompilation; 658520"];
1229 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 658521"];
1230 [label="return _compilationImportOptions; 658522"];
1231 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 658523"];
1232 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 658524"];
1233 [label="new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions) 658525"];
1234 [label="param PEAssemblySymbol(PEAssembly assembly) 658526"];
1235 [label="param PEAssemblySymbol(DocumentationProvider documentationProvider) 658527"];
1236 [label="param PEAssemblySymbol(bool isLinked) 658528"];
1237 [label="param PEAssemblySymbol(MetadataImportOptions importOptions) 658529"];
1238 [label="param PEAssemblySymbol(this) 658530"];
1239 [label="param PEAssemblySymbol(this) 658531"];
1240 [label="param MetadataOrSourceAssemblySymbol(this) 658532"];
1241 [label="param MetadataOrSourceAssemblySymbol(this) 658533"];
1242 [label="param NonMissingAssemblySymbol(this) 658534"];
1243 [label="new char[] { '+' } 658535"];
1244 [label="'+' 658536"];
1245 [label="new char[] { '+' } 658537"];
1246 [label="s_nestedTypeNameSeparators = new char[] { '+' } 658538"];
1247 [label="param NonMissingAssemblySymbol(this) 658539"];
1248 [label="param AssemblySymbol(this) 658540"];
1249 [label="param AssemblySymbol(this) 658541"];
1250 [label="param Symbol(this) 658542"];
1251 [label="_lazyISymbol 658543"];
1252 [label="_corLibrary 658544"];
1253 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 658545"];
1254 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 658546"];
1255 [label="_globalNamespace 658547"];
1256 [label="_lazySpecialTypes 658548"];
1257 [label="_cachedSpecialTypes 658549"];
1258 [label="_lazyNativeIntegerTypes 658550"];
1259 [label="_lazyTypeNames 658551"];
1260 [label="_lazyNamespaceNames 658552"];
1261 [label="_lazySpecialTypeMembers 658553"];
1262 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 658554"];
1263 [label="_assembly 658555"];
1264 [label="_documentationProvider 658556"];
1265 [label="_isLinked 658557"];
1266 [label="Debug.Assert(assembly != null); 658558"];
1267 [label="Debug.Assert(assembly != null); 658559"];
1268 [label="Debug.Assert(documentationProvider != null); 658560"];
1269 [label="Debug.Assert(documentationProvider != null); 658561"];
1270 [label="_assembly 658562"];
1271 [label="_documentationProvider 658563"];
1272 [label="var modules = new ModuleSymbol[assembly.Modules.Length]; 658564"];
1273 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 658565"];
1274 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 658566"];
1275 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 658567"];
1276 [label="31 658568"];
1277 [label="DefaultTypeMapCapacity = 31 658569"];
1278 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 658570"];
1279 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 658571"];
1280 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 658572"];
1281 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 658573"];
1282 [label="new PEModuleSymbol(this, assembly.Modules[i], importOptions, i) 658574"];
1283 [label="param PEModuleSymbol(PEAssemblySymbol assemblySymbol) 658575"];
1284 [label="param PEModuleSymbol(PEModule module) 658576"];
1285 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 658577"];
1286 [label="param PEModuleSymbol(int ordinal) 658578"];
1287 [label="param PEModuleSymbol(this) 658579"];
1288 [label="assemblySymbol 658580"];
1289 [label="module 658581"];
1290 [label="importOptions 658582"];
1291 [label="ordinal 658583"];
1292 [label="param PEModuleSymbol(this) 658584"];
1293 [label="param PEModuleSymbol(AssemblySymbol assemblySymbol) 658585"];
1294 [label="param PEModuleSymbol(PEModule module) 658586"];
1295 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 658587"];
1296 [label="param PEModuleSymbol(int ordinal) 658588"];
1297 [label="param PEModuleSymbol(this) 658589"];
1298 [label="param PEModuleSymbol(this) 658590"];
1299 [label="param NonMissingModuleSymbol(this) 658591"];
1300 [label="param NonMissingModuleSymbol(this) 658592"];
1301 [label="param ModuleSymbol(this) 658593"];
1302 [label="param ModuleSymbol(this) 658594"];
1303 [label="param Symbol(this) 658595"];
1304 [label="_lazyISymbol 658596"];
1305 [label="_moduleReferences 658597"];
1306 [label="_assemblySymbol 658598"];
1307 [label="_ordinal 658599"];
1308 [label="_module 658600"];
1309 [label="_globalNamespace 658601"];
1310 [label="_lazySystemTypeSymbol 658602"];
1311 [label="_lazyEventRegistrationTokenSymbol 658603"];
1312 [label="_lazyEventRegistrationTokenTableSymbol 658604"];
1313 [label="2 658605"];
1314 [label="concurrencyLevel: 2 658606"];
1315 [label="capacity: DefaultTypeMapCapacity 658607"];
1316 [label="new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 658608"];
1317 [label="TypeHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 658609"];
1318 [label="2 658610"];
1319 [label="concurrencyLevel: 2 658611"];
1320 [label="capacity: DefaultTypeMapCapacity 658612"];
1321 [label="new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 658613"];
1322 [label="TypeRefHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 658614"];
1323 [label="ImportOptions 658615"];
1324 [label="_lazyTypeNames 658616"];
1325 [label="_lazyNamespaceNames 658617"];
1326 [label="_lazyNullableMemberMetadata 658618"];
1327 [label="Debug.Assert((object)assemblySymbol != null); 658619"];
1328 [label="Debug.Assert((object)assemblySymbol != null); 658620"];
1329 [label="Debug.Assert(module != null); 658621"];
1330 [label="Debug.Assert(module != null); 658622"];
1331 [label="_assemblySymbol 658623"];
1332 [label="_ordinal 658624"];
1333 [label="_module 658625"];
1334 [label="this.ImportOptions 658626"];
1335 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 658627"];
1336 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 658628"];
1337 [label="new PEGlobalNamespaceSymbol(this) 658629"];
1338 [label="param PEGlobalNamespaceSymbol(PEModuleSymbol moduleSymbol) 658630"];
1339 [label="param PEGlobalNamespaceSymbol(this) 658631"];
1340 [label="param PEGlobalNamespaceSymbol(this) 658632"];
1341 [label="param PENamespaceSymbol(this) 658633"];
1342 [label="param PENamespaceSymbol(this) 658634"];
1343 [label="param NamespaceSymbol(this) 658635"];
1344 [label="param NamespaceSymbol(this) 658636"];
1345 [label="param NamespaceOrTypeSymbol(this) 658637"];
1346 [label="param NamespaceOrTypeSymbol(this) 658638"];
1347 [label="param Symbol(this) 658639"];
1348 [label="_lazyISymbol 658640"];
1349 [label="_lazyAdapter 658641"];
1350 [label="_lazyQualifiedName 658642"];
1351 [label="lazyNamespaces 658643"];
1352 [label="lazyTypes 658644"];
1353 [label="_lazyNoPiaLocalTypes 658645"];
1354 [label="_moduleSymbol 658646"];
1355 [label="Debug.Assert((object)moduleSymbol != null); 658647"];
1356 [label="Debug.Assert((object)moduleSymbol != null); 658648"];
1357 [label="_moduleSymbol 658649"];
1358 [label="_globalNamespace 658650"];
1359 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 658651"];
1360 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 658652"];
1361 [label="this.MetadataLocation 658653"];
1362 [label="Debug.Assert(ordinal >= 0); 658654"];
1363 [label="Debug.Assert(ordinal >= 0); 658655"];
1364 [label="modules[i] 658656"];
1365 [label="_modules = modules.AsImmutableOrNull(); 658657"];
1366 [label="_modules = modules.AsImmutableOrNull(); 658658"];
1367 [label="_modules 658659"];
1368 [label="_isLinked 658660"];
1369 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 658661"];
1370 [label="bound.AssemblySymbol 658662"];
1371 [label="newSymbols.Add(i); 658663"];
1372 [label="newSymbols.Add(i); 658664"];
1373 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 658665"];
1374 [label="allAssemblyData[i].IsLinked 658666"];
1375 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 658667"];
1376 [label="bound.AssemblySymbol.IsLinked 658668"];
1377 [label="get\n            {\n                return _isLinked;\n            } 658669"];
1378 [label="return _isLinked; 658670"];
1379 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 658671"];
1380 [label="return _internalsPotentiallyVisibleToCompilation; 658672"];
1381 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 658673"];
1382 [label="_assembly 658674"];
1383 [label="_documentationProvider 658675"];
1384 [label="Debug.Assert(assembly != null); 658676"];
1385 [label="Debug.Assert(documentationProvider != null); 658677"];
1386 [label="_assemblySymbol 658678"];
1387 [label="_ordinal 658679"];
1388 [label="_module 658680"];
1389 [label="_globalNamespace 658681"];
1390 [label="ImportOptions 658682"];
1391 [label="Debug.Assert((object)assemblySymbol != null); 658683"];
1392 [label="Debug.Assert(module != null); 658684"];
1393 [label="_moduleSymbol 658685"];
1394 [label="Debug.Assert((object)moduleSymbol != null); 658686"];
1395 [label="Debug.Assert(ordinal >= 0); 658687"];
1396 [label="bound.AssemblySymbol 658688"];
1397 [label="newSymbols.Add(i); 658689"];
1398 [label="newSymbols.Add(i); 658690"];
1399 [label="allAssemblyData[i].IsLinked 658691"];
1400 [label="bound.AssemblySymbol.IsLinked 658692"];
1401 [label="get\n            {\n                return _isLinked;\n            } 658693"];
1402 [label="return _isLinked; 658694"];
1403 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 658695"];
1404 [label="_assembly 658696"];
1405 [label="_documentationProvider 658697"];
1406 [label="_assemblySymbol 658698"];
1407 [label="_ordinal 658699"];
1408 [label="_module 658700"];
1409 [label="_globalNamespace 658701"];
1410 [label="ImportOptions 658702"];
1411 [label="Debug.Assert((object)assemblySymbol != null); 658703"];
1412 [label="Debug.Assert(module != null); 658704"];
1413 [label="_moduleSymbol 658705"];
1414 [label="Debug.Assert((object)moduleSymbol != null); 658706"];
1415 [label="Debug.Assert(ordinal >= 0); 658707"];
1416 [label="bound.AssemblySymbol 658708"];
1417 [label="newSymbols.Add(i); 658709"];
1418 [label="get\n            {\n                return _isLinked;\n            } 658710"];
1419 [label="return _isLinked; 658711"];
1420 [label="return _internalsPotentiallyVisibleToCompilation; 658712"];
1421 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 658713"];
1422 [label="_assembly 658714"];
1423 [label="_documentationProvider 658715"];
1424 [label="Debug.Assert(assembly != null); 658716"];
1425 [label="Debug.Assert(documentationProvider != null); 658717"];
1426 [label="Debug.Assert(ordinal >= 0); 658718"];
1427 [label="bound.AssemblySymbol 658719"];
1428 [label="newSymbols.Add(i); 658720"];
1429 [label="newSymbols.Add(i); 658721"];
1430 [label="bound.AssemblySymbol.IsLinked 658722"];
1431 [label="get\n            {\n                return _isLinked;\n            } 658723"];
1432 [label="return _isLinked; 658724"];
1433 [label="newSymbols.Add(i); 658725"];
1434 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 658726"];
1435 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 658727"];
1436 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 658728"];
1437 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 658729"];
1438 [label="t_assemblyForWhichCurrentThreadIsComputingKeys 658730"];
1439 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 658731"];
1440 [label="new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules) 658732"];
1441 [label="param SourceAssemblySymbol(CSharpCompilation compilation) 658733"];
1442 [label="param SourceAssemblySymbol(string assemblySimpleName) 658734"];
1443 [label="param SourceAssemblySymbol(string moduleName) 658735"];
1444 [label="param SourceAssemblySymbol(ImmutableArray<PEModule> netModules) 658736"];
1445 [label="param SourceAssemblySymbol(this) 658737"];
1446 [label="param SourceAssemblySymbol(this) 658738"];
1447 [label="param MetadataOrSourceAssemblySymbol(this) 658739"];
1448 [label="param MetadataOrSourceAssemblySymbol(this) 658740"];
1449 [label="param NonMissingAssemblySymbol(this) 658741"];
1450 [label="param NonMissingAssemblySymbol(this) 658742"];
1451 [label="param AssemblySymbol(this) 658743"];
1452 [label="param AssemblySymbol(this) 658744"];
1453 [label="param Symbol(this) 658745"];
1454 [label="_lazyISymbol 658746"];
1455 [label="_corLibrary 658747"];
1456 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 658748"];
1457 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 658749"];
1458 [label="_globalNamespace 658750"];
1459 [label="_lazySpecialTypes 658751"];
1460 [label="_cachedSpecialTypes 658752"];
1461 [label="_lazyNativeIntegerTypes 658753"];
1462 [label="_lazyTypeNames 658754"];
1463 [label="_lazyNamespaceNames 658755"];
1464 [label="_lazySpecialTypeMembers 658756"];
1465 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 658757"];
1466 [label="_compilation 658758"];
1467 [label="lazyAssemblyIdentity 658759"];
1468 [label="_assemblySimpleName 658760"];
1469 [label="_lazyStrongNameKeys 658761"];
1470 [label="_lazySourceAttributesBag 658762"];
1471 [label="_lazyNetModuleAttributesBag 658763"];
1472 [label="_lazyForwardedTypesFromSource 658764"];
1473 [label="_lazyOmittedAttributeIndices 658765"];
1474 [label="_lazyContainsExtensionMethods 658766"];
1475 [label="new ConcurrentDictionary<FieldSymbol, bool>() 658767"];
1476 [label="_unassignedFieldsMap = new ConcurrentDictionary<FieldSymbol, bool>() 658768"];
1477 [label="new ConcurrentSet<FieldSymbol>() 658769"];
1478 [label="_unreadFields = new ConcurrentSet<FieldSymbol>() 658770"];
1479 [label="new ConcurrentSet<TypeSymbol>() 658771"];
1480 [label="TypesReferencedInExternalMethods = new ConcurrentSet<TypeSymbol>() 658772"];
1481 [label="_optimisticallyGrantedInternalsAccess 658773"];
1482 [label="_lazyInternalsVisibleToMap 658774"];
1483 [label="Debug.Assert(compilation != null); 658775"];
1484 [label="Debug.Assert(compilation != null); 658776"];
1485 [label="Debug.Assert(assemblySimpleName != null); 658777"];
1486 [label="Debug.Assert(assemblySimpleName != null); 658778"];
1487 [label="Debug.Assert(!String.IsNullOrWhiteSpace(moduleName)); 658779"];
1488 [label="Debug.Assert(!netModules.IsDefault); 658780"];
1489 [label="_compilation 658781"];
1490 [label="_assemblySimpleName 658782"];
1491 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 658783"];
1492 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 658784"];
1493 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 658785"];
1494 [label="compilation.Declarations 658786"];
1495 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 658787"];
1496 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 658788"];
1497 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 658789"];
1498 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 658790"];
1499 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 658791"];
1500 [label="new SourceModuleSymbol(this, compilation.Declarations, moduleName) 658792"];
1501 [label="param SourceModuleSymbol(SourceAssemblySymbol assemblySymbol) 658793"];
1502 [label="param SourceModuleSymbol(DeclarationTable declarations) 658794"];
1503 [label="param SourceModuleSymbol(string moduleName) 658795"];
1504 [label="param SourceModuleSymbol(this) 658796"];
1505 [label="param SourceModuleSymbol(this) 658797"];
1506 [label="param NonMissingModuleSymbol(this) 658798"];
1507 [label="param NonMissingModuleSymbol(this) 658799"];
1508 [label="param ModuleSymbol(this) 658800"];
1509 [label="param ModuleSymbol(this) 658801"];
1510 [label="param Symbol(this) 658802"];
1511 [label="_lazyISymbol 658803"];
1512 [label="_moduleReferences 658804"];
1513 [label="_assemblySymbol 658805"];
1514 [label="_lazyContainsExplicitDefinitionOfNoPiaLocalTypes = ThreeState.Unknown 658806"];
1515 [label="_sources 658807"];
1516 [label="_lazyCustomAttributesBag 658808"];
1517 [label="_globalNamespace 658809"];
1518 [label="_hasBadAttributes 658810"];
1519 [label="_name 658811"];
1520 [label="Debug.Assert((object)assemblySymbol != null); 658812"];
1521 [label="Debug.Assert((object)assemblySymbol != null); 658813"];
1522 [label="_assemblySymbol 658814"];
1523 [label="_sources 658815"];
1524 [label="_name 658816"];
1525 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 658817"];
1526 [label="compilation.Options 658818"];
1527 [label="get\n            {\n                return _options;\n            } 658819"];
1528 [label="return _options; 658820"];
1529 [label="var importOptions = (compilation.Options.MetadataImportOptions == MetadataImportOptions.All) ?\n                MetadataImportOptions.All : MetadataImportOptions.Internal; 658821"];
1530 [label="(compilation.Options.MetadataImportOptions == MetadataImportOptions.All) 658822"];
1531 [label="foreach (PEModule netModule in netModules)\n            {\n                moduleBuilder.Add(new PEModuleSymbol(this, netModule, importOptions, moduleBuilder.Count));\n                // SetReferences will be called later by the ReferenceManager (in CreateSourceAssemblyFullBind for \n                // a fresh manager, in CreateSourceAssemblyReuseData for a reused one).\n            } 658823"];
1532 [label="_modules = moduleBuilder.ToImmutableAndFree(); 658824"];
1533 [label="_modules 658825"];
1534 [label="compilation.Options 658826"];
1535 [label="get\n            {\n                return _options;\n            } 658827"];
1536 [label="return _options; 658828"];
1537 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 658829"];
1538 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 658830"];
1539 [label="AssemblySymbol? corLibrary; 658831"];
1540 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 658832"];
1541 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 658833"];
1542 [label="if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 658834"];
1543 [label="corLibrary = bindingResult[corLibraryIndex].AssemblySymbol; 658835"];
1544 [label="assemblySymbol.SetCorLibrary(corLibrary); 658836"];
1545 [label="assemblySymbol.SetCorLibrary(corLibrary) 658837"];
1546 [label="param SetCorLibrary(AssemblySymbol corLibrary) 658838"];
1547 [label="param SetCorLibrary(this) 658839"];
1548 [label="Debug.Assert((object)_corLibrary == null); 658840"];
1549 [label="Debug.Assert((object)_corLibrary == null); 658841"];
1550 [label="_corLibrary 658842"];
1551 [label="assemblySymbol.SetCorLibrary(corLibrary); 658843"];
1552 [label="Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies = null; 658844"];
1553 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 658845"];
1554 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 658846"];
1555 [label="ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences; 658847"];
1556 [label="moduleReferences 658848"];
1557 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 658849"];
1558 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 658850"];
1559 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 658851"];
1560 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 658852"];
1561 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 658853"];
1562 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 658854"];
1563 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences) 658855"];
1564 [label="param SetupReferencesForSourceAssembly(SourceAssemblySymbol sourceAssembly) 658856"];
1565 [label="param SetupReferencesForSourceAssembly(ImmutableArray<PEModule> modules) 658857"];
1566 [label="param SetupReferencesForSourceAssembly(int totalReferencedAssemblyCount) 658858"];
1567 [label="param SetupReferencesForSourceAssembly(BoundInputAssembly[] bindingResult) 658859"];
1568 [label="param SetupReferencesForSourceAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 658860"];
1569 [label="param SetupReferencesForSourceAssembly(out ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences) 658861"];
1570 [label="sourceAssembly.Modules 658862"];
1571 [label="get\n            {\n                return _modules;\n            } 658863"];
1572 [label="return _modules; 658864"];
1573 [label="var moduleSymbols = sourceAssembly.Modules; 658865"];
1574 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 658866"];
1575 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 658867"];
1576 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 658868"];
1577 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 658869"];
1578 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 658870"];
1579 [label="(moduleSymbols.Length > 1) 658871"];
1580 [label="int refsUsed = 0; 658872"];
1581 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 658873"];
1582 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 658874"];
1583 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 658875"];
1584 [label="(moduleIndex == 0) 658876"];
1585 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 658877"];
1586 [label="var identities = new AssemblyIdentity[refsCount]; 658878"];
1587 [label="var symbols = new AssemblySymbol[refsCount]; 658879"];
1588 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 658880"];
1589 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 658881"];
1590 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 658882"];
1591 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 658883"];
1592 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 658884"];
1593 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 658885"];
1594 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 658886"];
1595 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 658887"];
1596 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 658888"];
1597 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 658889"];
1598 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 658890"];
1599 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 658891"];
1600 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 658892"];
1601 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 658893"];
1602 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 658894"];
1603 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 658895"];
1604 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 658896"];
1605 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 658897"];
1606 [label="Debug.Assert(referenceBinding.IsBound); 658898"];
1607 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 658899"];
1608 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 658900"];
1609 [label="Debug.Assert(assembly is object); 658901"];
1610 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 658902"];
1611 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 658903"];
1612 [label="return assembly; 658904"];
1613 [label="symbols[k] 658905"];
1614 [label="identities[k] 658906"];
1615 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 658907"];
1616 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 658908"];
1617 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 658909"];
1618 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 658910"];
1619 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 658911"];
1620 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 658912"];
1621 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 658913"];
1622 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 658914"];
1623 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 658915"];
1624 [label="Debug.Assert(referenceBinding.IsBound); 658916"];
1625 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 658917"];
1626 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 658918"];
1627 [label="Debug.Assert(assembly is object); 658919"];
1628 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 658920"];
1629 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 658921"];
1630 [label="return assembly; 658922"];
1631 [label="symbols[k] 658923"];
1632 [label="identities[k] 658924"];
1633 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 658925"];
1634 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 658926"];
1635 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 658927"];
1636 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 658928"];
1637 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 658929"];
1638 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 658930"];
1639 [label="if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    } 658931"];
1640 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 658932"];
1641 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 658933"];
1642 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 658934"];
1643 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly) 658935"];
1644 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 658936"];
1645 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 658937"];
1646 [label="param SetReferences(this) 658938"];
1647 [label="Debug.Assert(moduleReferences != null); 658939"];
1648 [label="Debug.Assert(moduleReferences != null); 658940"];
1649 [label="AssertReferencesUninitialized() 658941"];
1650 [label="param AssertReferencesUninitialized(this) 658942"];
1651 [label="Debug.Assert(_moduleReferences == null); 658943"];
1652 [label="Debug.Assert(_moduleReferences == null); 658944"];
1653 [label="AssertReferencesUninitialized(); 658945"];
1654 [label="_moduleReferences 658946"];
1655 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 658947"];
1656 [label="refsUsed += refsCount; 658948"];
1657 [label="moduleReferences = moduleReferencesBuilder.ToImmutableOrEmptyAndFree(); 658949"];
1658 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 658950"];
1659 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 658951"];
1660 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 658952"];
1661 [label="if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        } 658953"];
1662 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 658954"];
1663 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 658955"];
1664 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 658956"];
1665 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 658957"];
1666 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies) 658958"];
1667 [label="param InitializeNewSymbols(List<int> newSymbols) 658959"];
1668 [label="param InitializeNewSymbols(SourceAssemblySymbol sourceAssembly) 658960"];
1669 [label="param InitializeNewSymbols(ImmutableArray<AssemblyData> assemblies) 658961"];
1670 [label="param InitializeNewSymbols(BoundInputAssembly[] bindingResult) 658962"];
1671 [label="param InitializeNewSymbols(Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 658963"];
1672 [label="Debug.Assert(newSymbols.Count > 0); 658964"];
1673 [label="Debug.Assert(newSymbols.Count > 0); 658965"];
1674 [label="sourceAssembly.CorLibrary 658966"];
1675 [label="get\n            {\n                return _corLibrary;\n            } 658967"];
1676 [label="return _corLibrary; 658968"];
1677 [label="var corLibrary = sourceAssembly.CorLibrary; 658969"];
1678 [label="RoslynDebug.Assert((object)corLibrary != null); 658970"];
1679 [label="RoslynDebug.Assert((object)corLibrary != null); 658971"];
1680 [label="foreach (int i in newSymbols)\n                {\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n\n                    if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                } 658972"];
1681 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 658973"];
1682 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 658974"];
1683 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 658975"];
1684 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 658976"];
1685 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 658977"];
1686 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 658978"];
1687 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 658979"];
1688 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 658980"];
1689 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 658981"];
1690 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly) 658982"];
1691 [label="param SetupReferencesForFileAssembly(AssemblyDataForFile fileData) 658983"];
1692 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 658984"];
1693 [label="param SetupReferencesForFileAssembly(ref BoundInputAssembly currentBindingResult) 658985"];
1694 [label="param SetupReferencesForFileAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 658986"];
1695 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 658987"];
1696 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 658988"];
1697 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 658989"];
1698 [label="var portableExecutableAssemblySymbol = (PEAssemblySymbol)currentBindingResult.AssemblySymbol; 658990"];
1699 [label="portableExecutableAssemblySymbol.Modules 658991"];
1700 [label="get\n            {\n                return _modules;\n            } 658992"];
1701 [label="return _modules; 658993"];
1702 [label="ImmutableArray<ModuleSymbol> modules = portableExecutableAssemblySymbol.Modules; 658994"];
1703 [label="int moduleCount = modules.Length; 658995"];
1704 [label="int refsUsed = 0; 658996"];
1705 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 658997"];
1706 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 658998"];
1707 [label="int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j]; 658999"];
1708 [label="var identities = new AssemblyIdentity[moduleReferenceCount]; 659000"];
1709 [label="var symbols = new AssemblySymbol[moduleReferenceCount]; 659001"];
1710 [label="fileData.AssemblyReferences 659002"];
1711 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 659003"];
1712 [label="return _referencedAssemblies; 659004"];
1713 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 659005"];
1714 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 659006"];
1715 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 659007"];
1716 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 659008"];
1717 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 659009"];
1718 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 659010"];
1719 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 659011"];
1720 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 659012"];
1721 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 659013"];
1722 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 659014"];
1723 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 659015"];
1724 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 659016"];
1725 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 659017"];
1726 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 659018"];
1727 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 659019"];
1728 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 659020"];
1729 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 659021"];
1730 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly) 659022"];
1731 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 659023"];
1732 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 659024"];
1733 [label="param SetReferences(this) 659025"];
1734 [label="Debug.Assert(moduleReferences != null); 659026"];
1735 [label="Debug.Assert(moduleReferences != null); 659027"];
1736 [label="AssertReferencesUninitialized() 659028"];
1737 [label="param AssertReferencesUninitialized(this) 659029"];
1738 [label="Debug.Assert(_moduleReferences == null); 659030"];
1739 [label="Debug.Assert(_moduleReferences == null); 659031"];
1740 [label="AssertReferencesUninitialized(); 659032"];
1741 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 659033"];
1742 [label="refsUsed += moduleReferenceCount; 659034"];
1743 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 659035"];
1744 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 659036"];
1745 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 659037"];
1746 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 659038"];
1747 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 659039"];
1748 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 659040"];
1749 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 659041"];
1750 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 659042"];
1751 [label="var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k]; 659043"];
1752 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        } 659044"];
1753 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 659045"];
1754 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 659046"];
1755 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 659047"];
1756 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 659048"];
1757 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 659049"];
1758 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 659050"];
1759 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 659051"];
1760 [label="Debug.Assert(referenceBinding.IsBound); 659052"];
1761 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 659053"];
1762 [label="Debug.Assert(assembly is object); 659054"];
1763 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 659055"];
1764 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 659056"];
1765 [label="symbols[k] 659057"];
1766 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 659058"];
1767 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 659059"];
1768 [label="GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies) 659060"];
1769 [label="param GetOrAddMissingAssemblySymbol(AssemblyIdentity assemblyIdentity) 659061"];
1770 [label="param GetOrAddMissingAssemblySymbol(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 659062"];
1771 [label="MissingAssemblySymbol? missingAssembly; 659063"];
1772 [label="if (missingAssemblies == null)\n                {\n                    missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>();\n                }\n                else if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 659064"];
1773 [label="if (missingAssemblies == null)\n                {\n                    missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>();\n                }\n                else if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 659065"];
1774 [label="missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>(); 659066"];
1775 [label="missingAssembly = new MissingAssemblySymbol(assemblyIdentity); 659067"];
1776 [label="missingAssembly = new MissingAssemblySymbol(assemblyIdentity); 659068"];
1777 [label="new MissingAssemblySymbol(assemblyIdentity) 659069"];
1778 [label="param MissingAssemblySymbol(AssemblyIdentity identity) 659070"];
1779 [label="param MissingAssemblySymbol(this) 659071"];
1780 [label="param MissingAssemblySymbol(this) 659072"];
1781 [label="identity 659073"];
1782 [label="moduleSymbol 659074"];
1783 [label="Debug.Assert(identity != null); 659075"];
1784 [label="Debug.Assert(identity != null); 659076"];
1785 [label="this.identity 659077"];
1786 [label="moduleSymbol = new MissingModuleSymbol(this, 0); 659078"];
1787 [label="moduleSymbol = new MissingModuleSymbol(this, 0); 659079"];
1788 [label="new MissingModuleSymbol(this, 0) 659080"];
1789 [label="param MissingModuleSymbol(AssemblySymbol assembly) 659081"];
1790 [label="param MissingModuleSymbol(int ordinal) 659082"];
1791 [label="param MissingModuleSymbol(this) 659083"];
1792 [label="param MissingModuleSymbol(this) 659084"];
1793 [label="assembly 659085"];
1794 [label="ordinal 659086"];
1795 [label="globalNamespace 659087"];
1796 [label="Debug.Assert((object)assembly != null); 659088"];
1797 [label="Debug.Assert((object)assembly != null); 659089"];
1798 [label="Debug.Assert(ordinal >= -1); 659090"];
1799 [label="Debug.Assert(ordinal >= -1); 659091"];
1800 [label="this.assembly 659092"];
1801 [label="this.ordinal 659093"];
1802 [label="globalNamespace = new MissingNamespaceSymbol(this); 659094"];
1803 [label="globalNamespace = new MissingNamespaceSymbol(this); 659095"];
1804 [label="new MissingNamespaceSymbol(this) 659096"];
1805 [label="param MissingNamespaceSymbol(MissingModuleSymbol containingModule) 659097"];
1806 [label="param MissingNamespaceSymbol(this) 659098"];
1807 [label="param MissingNamespaceSymbol(this) 659099"];
1808 [label="_name 659100"];
1809 [label="_containingSymbol 659101"];
1810 [label="Debug.Assert((object)containingModule != null); 659102"];
1811 [label="Debug.Assert((object)containingModule != null); 659103"];
1812 [label="_containingSymbol 659104"];
1813 [label="_name 659105"];
1814 [label="globalNamespace 659106"];
1815 [label="moduleSymbol 659107"];
1816 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 659108"];
1817 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 659109"];
1818 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 659110"];
1819 [label="return missingAssembly; 659111"];
1820 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 659112"];
1821 [label="symbols[k] 659113"];
1822 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 659114"];
1823 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 659115"];
1824 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 659116"];
1825 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 659117"];
1826 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 659118"];
1827 [label="Debug.Assert(moduleReferences != null); 659119"];
1828 [label="Debug.Assert(moduleReferences != null); 659120"];
1829 [label="AssertReferencesUninitialized() 659121"];
1830 [label="param AssertReferencesUninitialized(this) 659122"];
1831 [label="Debug.Assert(_moduleReferences == null); 659123"];
1832 [label="Debug.Assert(_moduleReferences == null); 659124"];
1833 [label="AssertReferencesUninitialized(); 659125"];
1834 [label="refsUsed += moduleReferenceCount; 659126"];
1835 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 659127"];
1836 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 659128"];
1837 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 659129"];
1838 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 659130"];
1839 [label="Debug.Assert(referenceBinding.IsBound); 659131"];
1840 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 659132"];
1841 [label="Debug.Assert(assembly is object); 659133"];
1842 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 659134"];
1843 [label="return missingAssembly; 659135"];
1844 [label="identity 659136"];
1845 [label="moduleSymbol 659137"];
1846 [label="Debug.Assert(identity != null); 659138"];
1847 [label="Debug.Assert(identity != null); 659139"];
1848 [label="assembly 659140"];
1849 [label="ordinal 659141"];
1850 [label="globalNamespace 659142"];
1851 [label="Debug.Assert((object)assembly != null); 659143"];
1852 [label="Debug.Assert((object)assembly != null); 659144"];
1853 [label="Debug.Assert(ordinal >= -1); 659145"];
1854 [label="Debug.Assert(ordinal >= -1); 659146"];
1855 [label="_name 659147"];
1856 [label="_containingSymbol 659148"];
1857 [label="Debug.Assert((object)containingModule != null); 659149"];
1858 [label="Debug.Assert((object)containingModule != null); 659150"];
1859 [label="identity 659151"];
1860 [label="moduleSymbol 659152"];
1861 [label="Debug.Assert(identity != null); 659153"];
1862 [label="assembly 659154"];
1863 [label="ordinal 659155"];
1864 [label="globalNamespace 659156"];
1865 [label="Debug.Assert((object)assembly != null); 659157"];
1866 [label="Debug.Assert(ordinal >= -1); 659158"];
1867 [label="_name 659159"];
1868 [label="_containingSymbol 659160"];
1869 [label="Debug.Assert((object)containingModule != null); 659161"];
1870 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 659162"];
1871 [label="Debug.Assert(moduleReferences != null); 659163"];
1872 [label="Debug.Assert(moduleReferences != null); 659164"];
1873 [label="AssertReferencesUninitialized() 659165"];
1874 [label="param AssertReferencesUninitialized(this) 659166"];
1875 [label="Debug.Assert(_moduleReferences == null); 659167"];
1876 [label="Debug.Assert(_moduleReferences == null); 659168"];
1877 [label="AssertReferencesUninitialized(); 659169"];
1878 [label="refsUsed += moduleReferenceCount; 659170"];
1879 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 659171"];
1880 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 659172"];
1881 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 659173"];
1882 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 659174"];
1883 [label="Debug.Assert(referenceBinding.IsBound); 659175"];
1884 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 659176"];
1885 [label="Debug.Assert(assembly is object); 659177"];
1886 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 659178"];
1887 [label="if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    } 659179"];
1888 [label="unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>(); 659180"];
1889 [label="unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity)); 659181"];
1890 [label="unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity)); 659182"];
1891 [label="identity 659183"];
1892 [label="moduleSymbol 659184"];
1893 [label="Debug.Assert(identity != null); 659185"];
1894 [label="assembly 659186"];
1895 [label="ordinal 659187"];
1896 [label="globalNamespace 659188"];
1897 [label="Debug.Assert((object)assembly != null); 659189"];
1898 [label="Debug.Assert(ordinal >= -1); 659190"];
1899 [label="_name 659191"];
1900 [label="_containingSymbol 659192"];
1901 [label="Debug.Assert((object)containingModule != null); 659193"];
1902 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 659194"];
1903 [label="Debug.Assert(moduleReferences != null); 659195"];
1904 [label="Debug.Assert(moduleReferences != null); 659196"];
1905 [label="AssertReferencesUninitialized() 659197"];
1906 [label="param AssertReferencesUninitialized(this) 659198"];
1907 [label="Debug.Assert(_moduleReferences == null); 659199"];
1908 [label="Debug.Assert(_moduleReferences == null); 659200"];
1909 [label="AssertReferencesUninitialized(); 659201"];
1910 [label="refsUsed += moduleReferenceCount; 659202"];
1911 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 659203"];
1912 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 659204"];
1913 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 659205"];
1914 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 659206"];
1915 [label="Debug.Assert(referenceBinding.IsBound); 659207"];
1916 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 659208"];
1917 [label="Debug.Assert(assembly is object); 659209"];
1918 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 659210"];
1919 [label="Debug.Assert(moduleReferences != null); 659211"];
1920 [label="AssertReferencesUninitialized() 659212"];
1921 [label="param AssertReferencesUninitialized(this) 659213"];
1922 [label="Debug.Assert(_moduleReferences == null); 659214"];
1923 [label="Debug.Assert(_moduleReferences == null); 659215"];
1924 [label="AssertReferencesUninitialized(); 659216"];
1925 [label="refsUsed += moduleReferenceCount; 659217"];
1926 [label="var linkedReferencedAssembliesBuilder = ArrayBuilder<AssemblySymbol>.GetInstance(); 659218"];
1927 [label="sourceAssembly.Modules 659219"];
1928 [label="get\n            {\n                return _modules;\n            } 659220"];
1929 [label="return _modules; 659221"];
1930 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 659222"];
1931 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 659223"];
1932 [label="sourceAssembly.Modules[0].GetReferencedAssemblySymbols() 659224"];
1933 [label="param GetReferencedAssemblySymbols(this) 659225"];
1934 [label="AssertReferencesInitialized() 659226"];
1935 [label="param AssertReferencesInitialized(this) 659227"];
1936 [label="Debug.Assert(_moduleReferences != null); 659228"];
1937 [label="Debug.Assert(_moduleReferences != null); 659229"];
1938 [label="AssertReferencesInitialized(); 659230"];
1939 [label="return _moduleReferences.Symbols; 659231"];
1940 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly currentBindingResult = ref bindingResult[i];\n                    Debug.Assert(currentBindingResult.AssemblySymbol is object);\n                    Debug.Assert(currentBindingResult.ReferenceBinding is object);\n\n                    if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    }\n\n                    // Setup linked referenced assemblies.\n                    linkedReferencedAssembliesBuilder.Clear();\n\n                    if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    }\n\n                    foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    }\n\n                    if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    }\n\n                    currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary);\n                } 659232"];
1941 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 659233"];
1942 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 659234"];
1943 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 659235"];
1944 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 659236"];
1945 [label="assemblies[i].ContainsNoPiaLocalTypes 659237"];
1946 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 659238"];
1947 [label="linkedReferencedAssembliesBuilder.Clear(); 659239"];
1948 [label="if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    } 659240"];
1949 [label="assemblies[i].IsLinked 659241"];
1950 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 659242"];
1951 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 659243"];
1952 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 659244"];
1953 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 659245"];
1954 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 659246"];
1955 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 659247"];
1956 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary) 659248"];
1957 [label="param SetCorLibrary(AssemblySymbol corLibrary) 659249"];
1958 [label="param SetCorLibrary(this) 659250"];
1959 [label="Debug.Assert((object)_corLibrary == null); 659251"];
1960 [label="Debug.Assert((object)_corLibrary == null); 659252"];
1961 [label="_corLibrary 659253"];
1962 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 659254"];
1963 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 659255"];
1964 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 659256"];
1965 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 659257"];
1966 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 659258"];
1967 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 659259"];
1968 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 659260"];
1969 [label="if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        } 659261"];
1970 [label="assemblies[referenceBinding.DefinitionIndex].IsLinked 659262"];
1971 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 659263"];
1972 [label="Debug.Assert((object)_corLibrary == null); 659264"];
1973 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 659265"];
1974 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 659266"];
1975 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 659267"];
1976 [label="assemblies[referenceBinding.DefinitionIndex].IsLinked 659268"];
1977 [label="Debug.Assert((object)_corLibrary == null); 659269"];
1978 [label="linkedReferencedAssembliesBuilder.Free(); 659270"];
1979 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 659271"];
1980 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 659272"];
1981 [label="foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    } 659273"];
1982 [label="missingAssembly.SetCorLibrary(corLibrary); 659274"];
1983 [label="missingAssembly.SetCorLibrary(corLibrary) 659275"];
1984 [label="param SetCorLibrary(AssemblySymbol corLibrary) 659276"];
1985 [label="Debug.Assert((object)_corLibrary == null); 659277"];
1986 [label="missingAssembly.SetCorLibrary(corLibrary); 659278"];
1987 [label="Debug.Assert((object)_corLibrary == null); 659279"];
1988 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 659280"];
1989 [label="if (compilation._lazyAssemblySymbol is null)\n                    {\n                        lock (SymbolCacheAndReferenceManagerStateGuard)\n                        {\n                            if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            }\n                        }\n                    } 659281"];
1990 [label="if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            } 659282"];
1991 [label="if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                } 659283"];
1992 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 659284"];
1993 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 659285"];
1994 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult) 659286"];
1995 [label="param UpdateSymbolCacheNoLock(List<int> newSymbols) 659287"];
1996 [label="param UpdateSymbolCacheNoLock(ImmutableArray<AssemblyData> assemblies) 659288"];
1997 [label="param UpdateSymbolCacheNoLock(BoundInputAssembly[] bindingResult) 659289"];
1998 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly current = ref bindingResult[i];\n                    Debug.Assert(current.AssemblySymbol is object);\n\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n                    if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    }\n                } 659290"];
1999 [label="ref BoundInputAssembly current = ref bindingResult[i]; 659291"];
2000 [label="Debug.Assert(current.AssemblySymbol is object); 659292"];
2001 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 659293"];
2002 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 659294"];
2003 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 659295"];
2004 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 659296"];
2005 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 659297"];
2006 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 659298"];
2007 [label="Debug.Assert(current.AssemblySymbol is object); 659299"];
2008 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 659300"];
2009 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 659301"];
2010 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 659302"];
2011 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 659303"];
2012 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 659304"];
2013 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 659305"];
2014 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 659306"];
2015 [label="ReferenceEquals(corLibrary, assemblySymbol) 659307"];
2016 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 659308"];
2017 [label="assemblySymbol.SourceModule 659309"];
2018 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 659310"];
2019 [label="this.Modules 659311"];
2020 [label="get\n            {\n                return _modules;\n            } 659312"];
2021 [label="return _modules; 659313"];
2022 [label="return (SourceModuleSymbol)this.Modules[0]; 659314"];
2023 [label="return (SourceModuleSymbol)this.Modules[0]; 659315"];
2024 [label="assemblySymbol.SourceModule.GetReferencedAssemblySymbols() 659316"];
2025 [label="param GetReferencedAssemblySymbols(this) 659317"];
2026 [label="AssertReferencesInitialized() 659318"];
2027 [label="param AssertReferencesInitialized(this) 659319"];
2028 [label="Debug.Assert(_moduleReferences != null); 659320"];
2029 [label="Debug.Assert(_moduleReferences != null); 659321"];
2030 [label="AssertReferencesInitialized(); 659322"];
2031 [label="return _moduleReferences.Symbols; 659323"];
2032 [label="assemblySymbol.SourceModule 659324"];
2033 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 659325"];
2034 [label="this.Modules 659326"];
2035 [label="get\n            {\n                return _modules;\n            } 659327"];
2036 [label="return _modules; 659328"];
2037 [label="return (SourceModuleSymbol)this.Modules[0]; 659329"];
2038 [label="assemblySymbol.SourceModule.GetUnifiedAssemblies() 659330"];
2039 [label="param GetUnifiedAssemblies(this) 659331"];
2040 [label="AssertReferencesInitialized() 659332"];
2041 [label="param AssertReferencesInitialized(this) 659333"];
2042 [label="Debug.Assert(_moduleReferences != null); 659334"];
2043 [label="Debug.Assert(_moduleReferences != null); 659335"];
2044 [label="AssertReferencesInitialized(); 659336"];
2045 [label="return _moduleReferences.UnifiedAssemblies; 659337"];
2046 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 659338"];
2047 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 659339"];
2048 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 659340"];
2049 [label="compilation._referenceManager 659341"];
2050 [label="compilation._lazyAssemblySymbol 659342"];
2051 [label="return true; 659343"];
2052 [label="resolutionDiagnostics.Free(); 659344"];
2053 [label="assemblyReferencesBySimpleName.Free(); 659345"];
2054 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 659346"];
2055 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 659347"];
2056 [label="AssertBound(); 659348"];
2057 [label="Debug.Assert(compilation._lazyAssemblySymbol is object); 659349"];
2058 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 659350"];
2059 [label="Debug.Assert(_lazyAssemblySymbol is object); 659351"];
2060 [label="return _referenceManager; 659352"];
2061 [label="GetBoundReferenceManager(); 659353"];
2062 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 659354"];
2063 [label="return _lazyAssemblySymbol; 659355"];
2064 [label="return SourceAssembly; 659356"];
2065 [label="modules.AddRange(Assembly.Modules); 659357"];
2066 [label="Assembly.Modules 659358"];
2067 [label="get\n            {\n                return _modules;\n            } 659359"];
2068 [label="modules.AddRange(Assembly.Modules); 659360"];
2069 [label="GetBoundReferenceManager() 659361"];
2070 [label="param GetBoundReferenceManager(this) 659362"];
2071 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 659363"];
2072 [label="return _referenceManager; 659364"];
2073 [label="var referenceManager = GetBoundReferenceManager(); 659365"];
2074 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 659366"];
2075 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 659367"];
2076 [label="if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                } 659368"];
2077 [label="modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules); 659369"];
2078 [label="referenceManager.ReferencedAssemblies[i].Modules 659370"];
2079 [label="get\n            {\n                return _modules;\n            } 659371"];
2080 [label="GetAllUnaliasedModules(modules); 659372"];
2081 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 659373"];
2082 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 659374"];
2083 [label="new NamespaceExtent(this) 659375"];
2084 [label="param NamespaceExtent(CSharpCompilation compilation) 659376"];
2085 [label="param NamespaceExtent(this) 659377"];
2086 [label="_kind 659378"];
2087 [label="_symbolOrCompilation 659379"];
2088 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 659380"];
2089 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 659381"];
2090 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 659382"];
2091 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 659383"];
2092 [label="var diagnostics = DiagnosticBag.GetInstance(); 659384"];
2093 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 659385"];
2094 [label="DeclaringCompilation 659386"];
2095 [label="get\n            {\n                return _assemblySymbol.DeclaringCompilation;\n            } 659387"];
2096 [label="_assemblySymbol.DeclaringCompilation 659388"];
2097 [label="get\n            {\n                return _compilation;\n            } 659389"];
2098 [label="return _compilation; 659390"];
2099 [label="return _assemblySymbol.DeclaringCompilation; 659391"];
2100 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 659392"];
2101 [label="DeclaringCompilation.MergedRootDeclaration 659393"];
2102 [label="get\n            {\n                return Declarations.GetMergedRoot(this);\n            } 659394"];
2103 [label="Declarations 659395"];
2104 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 659396"];
2105 [label="return Declarations.GetMergedRoot(this); 659397"];
2106 [label="return Declarations.GetMergedRoot(this); 659398"];
2107 [label="return Declarations.GetMergedRoot(this); 659399"];
2108 [label="0x1 659400"];
2109 [label="LazyAllMembersIsSorted = 0x1 659401"];
2110 [label="d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 659402"];
2111 [label="s_declaringSyntaxReferencesSelector = d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 659403"];
2112 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 659404"];
2113 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 659405"];
2114 [label="new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics) 659406"];
2115 [label="param SourceNamespaceSymbol(SourceModuleSymbol module) 659407"];
2116 [label="param SourceNamespaceSymbol(Symbol container) 659408"];
2117 [label="param SourceNamespaceSymbol(MergedNamespaceDeclaration mergedDeclaration) 659409"];
2118 [label="param SourceNamespaceSymbol(DiagnosticBag diagnostics) 659410"];
2119 [label="param SourceNamespaceSymbol(this) 659411"];
2120 [label="param SourceNamespaceSymbol(this) 659412"];
2121 [label="_module 659413"];
2122 [label="_container 659414"];
2123 [label="_mergedDeclaration 659415"];
2124 [label="_nameToMembersMap 659416"];
2125 [label="_nameToTypeMembersMap 659417"];
2126 [label="_flags 659418"];
2127 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 659419"];
2128 [label="1 659420"];
2129 [label="_treeOrdinal 659421"];
2130 [label="0 659422"];
2131 [label="_position 659423"];
2132 [label="NotInSource = new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 659424"];
2133 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 659425"];
2134 [label="1 659426"];
2135 [label="_treeOrdinal 659427"];
2136 [label="1 659428"];
2137 [label="_position 659429"];
2138 [label="NotInitialized = new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 659430"];
2139 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 659431"];
2140 [label="_treeOrdinal 659432"];
2141 [label="1 659433"];
2142 [label="int.MaxValue - 1 659434"];
2143 [label="_position 659435"];
2144 [label="SynthesizedCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 659436"];
2145 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 659437"];
2146 [label="_treeOrdinal 659438"];
2147 [label="_position 659439"];
2148 [label="SynthesizedCCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 659440"];
2149 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 659441"];
2150 [label="Debug.Assert(mergedDeclaration != null); 659442"];
2151 [label="Debug.Assert(mergedDeclaration != null); 659443"];
2152 [label="_module 659444"];
2153 [label="_container 659445"];
2154 [label="_mergedDeclaration 659446"];
2155 [label="foreach (var singleDeclaration in mergedDeclaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 659447"];
2156 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 659448"];
2157 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 659449"];
2158 [label="Debug.Assert(diagnostics.IsEmptyWithoutResolution); 659450"];
2159 [label="diagnostics.Free(); 659451"];
2160 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 659452"];
2161 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 659453"];
2162 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 659454"];
2163 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 659455"];
2164 [label="return _globalNamespace; 659456"];
2165 [label="param GetHashCode(this) 659457"];
2166 [label="return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(this); 659458"];
2167 [label="return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(this); 659459"];
2168 [label="get { return _globalNamespace; } 659460"];
2169 [label="return _globalNamespace; 659461"];
2170 [label="MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)) 659462"];
2171 [label="param Create(NamespaceExtent extent) 659463"];
2172 [label="param Create(NamespaceSymbol containingNamespace) 659464"];
2173 [label="param Create(ImmutableArray<NamespaceSymbol> namespacesToMerge) 659465"];
2174 [label="param Create(string nameOpt = null) 659466"];
2175 [label="Debug.Assert(namespacesToMerge.Length != 0); 659467"];
2176 [label="Debug.Assert(namespacesToMerge.Length != 0); 659468"];
2177 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 659469"];
2178 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 659470"];
2179 [label="(namespacesToMerge.Length == 1 && nameOpt == null) 659471"];
2180 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 659472"];
2181 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 659473"];
2182 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 659474"];
2183 [label="new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt) 659475"];
2184 [label="param MergedNamespaceSymbol(NamespaceExtent extent) 659476"];
2185 [label="param MergedNamespaceSymbol(NamespaceSymbol containingNamespace) 659477"];
2186 [label="param MergedNamespaceSymbol(ImmutableArray<NamespaceSymbol> namespacesToMerge) 659478"];
2187 [label="param MergedNamespaceSymbol(string nameOpt) 659479"];
2188 [label="param MergedNamespaceSymbol(this) 659480"];
2189 [label="param MergedNamespaceSymbol(this) 659481"];
2190 [label="_containingNamespace 659482"];
2191 [label="_nameOpt 659483"];
2192 [label="_cachedLookup 659484"];
2193 [label="_extent 659485"];
2194 [label="_namespacesToMerge 659486"];
2195 [label="_containingNamespace 659487"];
2196 [label="_cachedLookup = new CachingDictionary<string, Symbol>(SlowGetChildrenOfName, SlowGetChildNames, EqualityComparer<string>.Default); 659488"];
2197 [label="_cachedLookup = new CachingDictionary<string, Symbol>(SlowGetChildrenOfName, SlowGetChildNames, EqualityComparer<string>.Default); 659489"];
2198 [label="_cachedLookup 659490"];
2199 [label="_nameOpt 659491"];
2200 [label="foreach (NamespaceSymbol ns in namespacesToMerge)\n            {\n                Debug.Assert(ns.ConstituentNamespaces.Length == 1);\n            } 659492"];
2201 [label="ns.ConstituentNamespaces 659493"];
2202 [label="get\n            {\n                return ImmutableArray.Create(this);\n            } 659494"];
2203 [label="return ImmutableArray.Create(this); 659495"];
2204 [label="Debug.Assert(ns.ConstituentNamespaces.Length == 1); 659496"];
2205 [label="Debug.Assert(ns.ConstituentNamespaces.Length == 1); 659497"];
2206 [label="modules.Free(); 659498"];
2207 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 659499"];
2208 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 659500"];
2209 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 659501"];
2210 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 659502"];
2211 [label="return _lazyGlobalNamespace; 659503"];
2212 [label="var namespaceNS = comp.GlobalNamespace.GetMembers('NS').First() as NamespaceOrTypeSymbol; 659504"];
2213 [label="var namespaceNS = comp.GlobalNamespace.GetMembers('NS').First() as NamespaceOrTypeSymbol; 659505"];
2214 [label="comp.GlobalNamespace.GetMembers('NS') 659506"];
2215 [label="param GetMembers(string name) 659507"];
2216 [label="param GetMembers(this) 659508"];
2217 [label="return _cachedLookup[name]; 659509"];
2218 [label="_cachedLookup 659510"];
2219 [label="param SlowGetChildrenOfName(string name) 659511"];
2220 [label="param SlowGetChildrenOfName(this) 659512"];
2221 [label="ArrayBuilder<NamespaceSymbol> namespaceSymbols = null; 659513"];
2222 [label="var otherSymbols = ArrayBuilder<Symbol>.GetInstance(); 659514"];
2223 [label="foreach (NamespaceSymbol namespaceSymbol in _namespacesToMerge)\n            {\n                foreach (Symbol childSymbol in namespaceSymbol.GetMembers(name))\n                {\n                    if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    }\n                }\n            } 659515"];
2224 [label="foreach (Symbol childSymbol in namespaceSymbol.GetMembers(name))\n                {\n                    if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    }\n                } 659516"];
2225 [label="namespaceSymbol.GetMembers(name) 659517"];
2226 [label="param GetMembers(string name) 659518"];
2227 [label="param GetMembers(this) 659519"];
2228 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 659520"];
2229 [label="members 659521"];
2230 [label="this.GetNameToMembersMap() 659522"];
2231 [label="param GetNameToMembersMap(this) 659523"];
2232 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 659524"];
2233 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 659525"];
2234 [label="var diagnostics = DiagnosticBag.GetInstance(); 659526"];
2235 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 659527"];
2236 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 659528"];
2237 [label="MakeNameToMembersMap(diagnostics) 659529"];
2238 [label="param MakeNameToMembersMap(DiagnosticBag diagnostics) 659530"];
2239 [label="param MakeNameToMembersMap(this) 659531"];
2240 [label="var builder = new NameToSymbolMapBuilder(_mergedDeclaration.Children.Length); 659532"];
2241 [label="_mergedDeclaration.Children 659533"];
2242 [label="param NameToSymbolMapBuilder(int capacity) 659534"];
2243 [label="param NameToSymbolMapBuilder(this) 659535"];
2244 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 659536"];
2245 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 659537"];
2246 [label="_dictionary 659538"];
2247 [label="foreach (var declaration in _mergedDeclaration.Children)\n            {\n                builder.Add(BuildSymbol(declaration, diagnostics));\n            } 659539"];
2248 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 659540"];
2249 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 659541"];
2250 [label="BuildSymbol(declaration, diagnostics) 659542"];
2251 [label="param BuildSymbol(MergedNamespaceOrTypeDeclaration declaration) 659543"];
2252 [label="param BuildSymbol(DiagnosticBag diagnostics) 659544"];
2253 [label="param BuildSymbol(this) 659545"];
2254 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Namespace:\n                    return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Script:\n                case DeclarationKind.Submission:\n                case DeclarationKind.ImplicitClass:\n                    return new ImplicitNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.SimpleProgram:\n                    return new SimpleProgramNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(declaration.Kind);\n            } 659546"];
2255 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 659547"];
2256 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 659548"];
2257 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 659549"];
2258 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 659550"];
2259 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 659551"];
2260 [label="new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics) 659552"];
2261 [label="param SourceNamespaceSymbol(SourceModuleSymbol module) 659553"];
2262 [label="param SourceNamespaceSymbol(Symbol container) 659554"];
2263 [label="param SourceNamespaceSymbol(MergedNamespaceDeclaration mergedDeclaration) 659555"];
2264 [label="param SourceNamespaceSymbol(DiagnosticBag diagnostics) 659556"];
2265 [label="param SourceNamespaceSymbol(this) 659557"];
2266 [label="_module 659558"];
2267 [label="_container 659559"];
2268 [label="_mergedDeclaration 659560"];
2269 [label="Debug.Assert(mergedDeclaration != null); 659561"];
2270 [label="Debug.Assert(mergedDeclaration != null); 659562"];
2271 [label="builder.Add(BuildSymbol(declaration, diagnostics)) 659563"];
2272 [label="param Add(NamespaceOrTypeSymbol symbol) 659564"];
2273 [label="param Add(this) 659565"];
2274 [label="symbol.Name 659566"];
2275 [label="=> _mergedDeclaration.Name 659567"];
2276 [label="_mergedDeclaration.Name 659568"];
2277 [label="string name = symbol.Name; 659569"];
2278 [label="object item; 659570"];
2279 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 659571"];
2280 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 659572"];
2281 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 659573"];
2282 [label="_dictionary 659574"];
2283 [label="builder.CreateMap() 659575"];
2284 [label="param CreateMap(this) 659576"];
2285 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 659577"];
2286 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 659578"];
2287 [label="foreach (var kvp in _dictionary)\n                {\n                    object value = kvp.Value;\n                    ImmutableArray<NamespaceOrTypeSymbol> members;\n\n                    var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    }\n\n                    result.Add(kvp.Key, members);\n                } 659579"];
2288 [label="object value = kvp.Value; 659580"];
2289 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 659581"];
2290 [label="members 659582"];
2291 [label="var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>; 659583"];
2292 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 659584"];
2293 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 659585"];
2294 [label="NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value; 659586"];
2295 [label="symbol.Kind 659587"];
2296 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 659588"];
2297 [label="return SymbolKind.Namespace; 659589"];
2298 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 659590"];
2299 [label="symbol.Kind == SymbolKind.Namespace 659591"];
2300 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 659592"];
2301 [label="result.Add(kvp.Key, members); 659593"];
2302 [label="result.Add(kvp.Key, members); 659594"];
2303 [label="result.Add(kvp.Key, members); 659595"];
2304 [label="return result; 659596"];
2305 [label="var result = builder.CreateMap(); 659597"];
2306 [label="CheckMembers(this, result, diagnostics); 659598"];
2307 [label="CheckMembers(this, result, diagnostics); 659599"];
2308 [label="CheckMembers(this, result, diagnostics); 659600"];
2309 [label="CheckMembers(this, result, diagnostics) 659601"];
2310 [label="param CheckMembers(NamespaceSymbol @namespace) 659602"];
2311 [label="param CheckMembers(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> result) 659603"];
2312 [label="param CheckMembers(DiagnosticBag diagnostics) 659604"];
2313 [label="var memberOfArity = new Symbol[10]; 659605"];
2314 [label="MergedNamespaceSymbol mergedAssemblyNamespace = null; 659606"];
2315 [label="@namespace.ContainingAssembly 659607"];
2316 [label="=> _module.ContainingAssembly 659608"];
2317 [label="_module.ContainingAssembly 659609"];
2318 [label="get\n            {\n                return _assemblySymbol;\n            } 659610"];
2319 [label="return _assemblySymbol; 659611"];
2320 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 659612"];
2321 [label="@namespace.ContainingAssembly.Modules 659613"];
2322 [label="get\n            {\n                return _modules;\n            } 659614"];
2323 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 659615"];
2324 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 659616"];
2325 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 659617"];
2326 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 659618"];
2327 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 659619"];
2328 [label="foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                } 659620"];
2329 [label="var nts = symbol as NamedTypeSymbol; 659621"];
2330 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 659622"];
2331 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 659623"];
2332 [label="((object)nts != null) 659624"];
2333 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 659625"];
2334 [label="var other = memberOfArity[arity]; 659626"];
2335 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 659627"];
2336 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 659628"];
2337 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 659629"];
2338 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 659630"];
2339 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 659631"];
2340 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 659632"];
2341 [label="memberOfArity[arity] 659633"];
2342 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 659634"];
2343 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 659635"];
2344 [label="CheckMembers(this, result, diagnostics); 659636"];
2345 [label="return result; 659637"];
2346 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 659638"];
2347 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 659639"];
2348 [label="this.DeclaringCompilation 659640"];
2349 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 659641"];
2350 [label="this.Kind 659642"];
2351 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 659643"];
2352 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 659644"];
2353 [label="this.ContainingModule 659645"];
2354 [label="get\n            {\n                return _module;\n            } 659646"];
2355 [label="return _module; 659647"];
2356 [label="var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol; 659648"];
2357 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 659649"];
2358 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 659650"];
2359 [label="(object)sourceModuleSymbol == null 659651"];
2360 [label="sourceModuleSymbol.DeclaringCompilation 659652"];
2361 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 659653"];
2362 [label="this.DeclaringCompilation.DeclarationDiagnostics 659654"];
2363 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 659655"];
2364 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 659656"];
2365 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 659657"];
2366 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 659658"];
2367 [label="var diagnostics = new DiagnosticBag(); 659659"];
2368 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 659660"];
2369 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 659661"];
2370 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 659662"];
2371 [label="return _lazyDeclarationDiagnostics; 659663"];
2372 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 659664"];
2373 [label="RegisterDeclaredCorTypes() 659665"];
2374 [label="param RegisterDeclaredCorTypes(this) 659666"];
2375 [label="ContainingAssembly 659667"];
2376 [label="=> _module.ContainingAssembly 659668"];
2377 [label="_module.ContainingAssembly 659669"];
2378 [label="get\n            {\n                return _assemblySymbol;\n            } 659670"];
2379 [label="return _assemblySymbol; 659671"];
2380 [label="AssemblySymbol containingAssembly = ContainingAssembly; 659672"];
2381 [label="containingAssembly.KeepLookingForDeclaredSpecialTypes 659673"];
2382 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 659674"];
2383 [label="this.CorLibrary 659675"];
2384 [label="get\n            {\n                return _corLibrary;\n            } 659676"];
2385 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 659677"];
2386 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 659678"];
2387 [label="if (containingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                // Register newly declared COR types\n                foreach (var array in _nameToMembersMap.Values)\n                {\n                    foreach (var member in array)\n                    {\n                        var type = member as NamedTypeSymbol;\n\n                        if ((object)type != null && type.SpecialType != SpecialType.None)\n                        {\n                            containingAssembly.RegisterDeclaredSpecialType(type);\n\n                            if (!containingAssembly.KeepLookingForDeclaredSpecialTypes)\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n            } 659679"];
2388 [label="RegisterDeclaredCorTypes(); 659680"];
2389 [label="DeclaringCompilation 659681"];
2390 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 659682"];
2391 [label="this.Kind 659683"];
2392 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 659684"];
2393 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 659685"];
2394 [label="this.ContainingModule 659686"];
2395 [label="get\n            {\n                return _module;\n            } 659687"];
2396 [label="return _module; 659688"];
2397 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 659689"];
2398 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 659690"];
2399 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 659691"];
2400 [label="DeclaringCompilation.SymbolDeclaredEvent(this) 659692"];
2401 [label="param SymbolDeclaredEvent(Symbol symbol) 659693"];
2402 [label="param SymbolDeclaredEvent(this) 659694"];
2403 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 659695"];
2404 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 659696"];
2405 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 659697"];
2406 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 659698"];
2407 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 659699"];
2408 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 659700"];
2409 [label="var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap); 659701"];
2410 [label="_state.NotePartComplete(CompletionPart.NameToMembersMap) 659702"];
2411 [label="param NotePartComplete(CompletionPart part) 659703"];
2412 [label="param NotePartComplete(this) 659704"];
2413 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 659705"];
2414 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 659706"];
2415 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 659707"];
2416 [label="Debug.Assert(wasSetThisThread); 659708"];
2417 [label="diagnostics.Free(); 659709"];
2418 [label="return _nameToMembersMap; 659710"];
2419 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 659711"];
2420 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 659712"];
2421 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 659713"];
2422 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 659714"];
2423 [label="this.GetNameToMembersMap().TryGetValue(name, out members) 659715"];
2424 [label="childSymbol.Kind 659716"];
2425 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 659717"];
2426 [label="if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    } 659718"];
2427 [label="namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance(); 659719"];
2428 [label="namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance(); 659720"];
2429 [label="namespaceSymbols.Add((NamespaceSymbol)childSymbol); 659721"];
2430 [label="namespaceSymbols.Add((NamespaceSymbol)childSymbol); 659722"];
2431 [label="param GetMembers(string name) 659723"];
2432 [label="param GetMembers(this) 659724"];
2433 [label="EnsureAllMembersLoaded() 659725"];
2434 [label="param EnsureAllMembersLoaded(this) 659726"];
2435 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 659727"];
2436 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 659728"];
2437 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 659729"];
2438 [label="_moduleSymbol.Module 659730"];
2439 [label="get\n            {\n                return _module;\n            } 659731"];
2440 [label="return _module; 659732"];
2441 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 659733"];
2442 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 659734"];
2443 [label="LoadAllMembers(groups); 659735"];
2444 [label="LoadAllMembers(groups) 659736"];
2445 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 659737"];
2446 [label="param LoadAllMembers(this) 659738"];
2447 [label="Debug.Assert(typesByNS != null); 659739"];
2448 [label="Debug.Assert(typesByNS != null); 659740"];
2449 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> nestedTypes = null; 659741"];
2450 [label="IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> nestedNamespaces = null; 659742"];
2451 [label="this.IsGlobalNamespace 659743"];
2452 [label="get\n            {\n                return true;\n            } 659744"];
2453 [label="return true; 659745"];
2454 [label="bool isGlobalNamespace = this.IsGlobalNamespace; 659746"];
2455 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 659747"];
2456 [label="isGlobalNamespace 659748"];
2457 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 659749"];
2458 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 659750"];
2459 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 659751"];
2460 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 659752"];
2461 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 659753"];
2462 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 659754"];
2463 [label="LazyInitializeNamespaces(nestedNamespaces); 659755"];
2464 [label="LazyInitializeNamespaces(nestedNamespaces) 659756"];
2465 [label="param LazyInitializeNamespaces(IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> childNamespaces) 659757"];
2466 [label="param LazyInitializeNamespaces(this) 659758"];
2467 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 659759"];
2468 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 659760"];
2469 [label="var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance); 659761"];
2470 [label="foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                } 659762"];
2471 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 659763"];
2472 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 659764"];
2473 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 659765"];
2474 [label="new PENestedNamespaceSymbol(child.Key, this, child.Value) 659766"];
2475 [label="param PENestedNamespaceSymbol(string name) 659767"];
2476 [label="param PENestedNamespaceSymbol(PENamespaceSymbol containingNamespace) 659768"];
2477 [label="param PENestedNamespaceSymbol(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 659769"];
2478 [label="param PENestedNamespaceSymbol(this) 659770"];
2479 [label="param PENestedNamespaceSymbol(this) 659771"];
2480 [label="_containingNamespaceSymbol 659772"];
2481 [label="_name 659773"];
2482 [label="_typesByNS 659774"];
2483 [label="Debug.Assert(name != null); 659775"];
2484 [label="Debug.Assert(name != null); 659776"];
2485 [label="Debug.Assert((object)containingNamespace != null); 659777"];
2486 [label="Debug.Assert((object)containingNamespace != null); 659778"];
2487 [label="Debug.Assert(typesByNS != null); 659779"];
2488 [label="Debug.Assert(typesByNS != null); 659780"];
2489 [label="_containingNamespaceSymbol 659781"];
2490 [label="_name 659782"];
2491 [label="_typesByNS 659783"];
2492 [label="c.Name 659784"];
2493 [label="get\n            {\n                return _name;\n            } 659785"];
2494 [label="return _name; 659786"];
2495 [label="namespaces.Add(c.Name, c); 659787"];
2496 [label="namespaces.Add(c.Name, c); 659788"];
2497 [label="namespaces.Add(c.Name, c); 659789"];
2498 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 659790"];
2499 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 659791"];
2500 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 659792"];
2501 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 659793"];
2502 [label="LazyInitializeNamespaces(nestedNamespaces); 659794"];
2503 [label="LazyInitializeTypes(nestedTypes); 659795"];
2504 [label="LazyInitializeTypes(nestedTypes) 659796"];
2505 [label="param LazyInitializeTypes(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typeGroups) 659797"];
2506 [label="param LazyInitializeTypes(this) 659798"];
2507 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 659799"];
2508 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 659800"];
2509 [label="ContainingPEModule 659801"];
2510 [label="get\n            {\n                return _moduleSymbol;\n            } 659802"];
2511 [label="return _moduleSymbol; 659803"];
2512 [label="var moduleSymbol = ContainingPEModule; 659804"];
2513 [label="var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance(); 659805"];
2514 [label="moduleSymbol.Module 659806"];
2515 [label="get\n            {\n                return _module;\n            } 659807"];
2516 [label="var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes(); 659808"];
2517 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 659809"];
2518 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 659810"];
2519 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 659811"];
2520 [label="foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    } 659812"];
2521 [label="if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        } 659813"];
2522 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 659814"];
2523 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 659815"];
2524 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 659816"];
2525 [label="EmptyComparer.Instance 659817"];
2526 [label="new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 659818"];
2527 [label="s_emptyNestedTypes = new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 659819"];
2528 [label="new UncommonProperties() 659820"];
2529 [label="param UncommonProperties(this) 659821"];
2530 [label="lazyEnumUnderlyingType 659822"];
2531 [label="lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 659823"];
2532 [label="lazyAttributeUsageInfo = AttributeUsageInfo.Null 659824"];
2533 [label="lazyContainsExtensionMethods 659825"];
2534 [label="lazyIsByRefLike 659826"];
2535 [label="lazyIsReadOnly 659827"];
2536 [label="lazyDefaultMemberName 659828"];
2537 [label="new UnsupportedMetadataTypeSymbol() 659829"];
2538 [label="param UnsupportedMetadataTypeSymbol(BadImageFormatException? mrEx = null) 659830"];
2539 [label="param UnsupportedMetadataTypeSymbol(this) 659831"];
2540 [label="param ErrorTypeSymbol(this) 659832"];
2541 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 659833"];
2542 [label="symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 659834"];
2543 [label="IsInstanceFieldOrEvent = symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 659835"];
2544 [label="type => !type.HasType 659836"];
2545 [label="TypeWithAnnotationsIsNullFunction = type => !type.HasType 659837"];
2546 [label="type => type.HasType && type.Type.IsErrorType() 659838"];
2547 [label="TypeWithAnnotationsIsErrorType = type => type.HasType && type.Type.IsErrorType() 659839"];
2548 [label="8 659840"];
2549 [label="ValueTupleRestPosition = 8 659841"];
2550 [label="1 659842"];
2551 [label="ValueTupleRestPosition - 1 659843"];
2552 [label="ValueTupleRestIndex = ValueTupleRestPosition - 1 659844"];
2553 [label="'ValueTuple' 659845"];
2554 [label="ValueTupleTypeName = 'ValueTuple' 659846"];
2555 [label="'Rest' 659847"];
2556 [label="ValueTupleRestFieldName = 'Rest' 659848"];
2557 [label="{\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 659849"];
2558 [label="tupleTypes = {\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 659850"];
2559 [label="{\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 659851"];
2560 [label="tupleCtors = {\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 659852"];
2561 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 659853"];
2562 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 } 659854"];
2563 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 } 659855"];
2564 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 } 659856"];
2565 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 } 659857"];
2566 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 } 659858"];
2567 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 } 659859"];
2568 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 } 659860"];
2569 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest } 659861"];
2570 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 659862"];
2571 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 659863"];
2572 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 659864"];
2573 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 659865"];
2574 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 659866"];
2575 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 659867"];
2576 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 659868"];
2577 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 659869"];
2578 [label="tupleMembers = new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 659870"];
2579 [label="tupleData 659871"];
2580 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 659872"];
2581 [label="param NamedTypeSymbol(this) 659873"];
2582 [label="'<invalid-global-code>' 659874"];
2583 [label="ImplicitTypeName = '<invalid-global-code>' 659875"];
2584 [label="0 659876"];
2585 [label="TypeCompareKind.ConsiderEverything 659877"];
2586 [label="new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 659878"];
2587 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 659879"];
2588 [label="param SymbolEqualityComparer(this) 659880"];
2589 [label="_comparison 659881"];
2590 [label="_comparison 659882"];
2591 [label="ConsiderEverything = new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 659883"];
2592 [label="TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 659884"];
2593 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 659885"];
2594 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 659886"];
2595 [label="param SymbolEqualityComparer(this) 659887"];
2596 [label="_comparison 659888"];
2597 [label="_comparison 659889"];
2598 [label="IgnoringTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 659890"];
2599 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 659891"];
2600 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 659892"];
2601 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 659893"];
2602 [label="param SymbolEqualityComparer(this) 659894"];
2603 [label="_comparison 659895"];
2604 [label="_comparison 659896"];
2605 [label="IgnoringDynamicTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 659897"];
2606 [label="TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 659898"];
2607 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 659899"];
2608 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 659900"];
2609 [label="param SymbolEqualityComparer(this) 659901"];
2610 [label="_comparison 659902"];
2611 [label="_comparison 659903"];
2612 [label="IgnoringNullable = new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 659904"];
2613 [label="TypeCompareKind.ObliviousNullableModifierMatchesAny 659905"];
2614 [label="new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 659906"];
2615 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 659907"];
2616 [label="param SymbolEqualityComparer(this) 659908"];
2617 [label="_comparison 659909"];
2618 [label="_comparison 659910"];
2619 [label="ObliviousNullableModifierMatchesAny = new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 659911"];
2620 [label="TypeCompareKind.AllIgnoreOptions 659912"];
2621 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 659913"];
2622 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 659914"];
2623 [label="param SymbolEqualityComparer(this) 659915"];
2624 [label="_comparison 659916"];
2625 [label="_comparison 659917"];
2626 [label="AllIgnoreOptions = new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 659918"];
2627 [label="TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 659919"];
2628 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 659920"];
2629 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 659921"];
2630 [label="param SymbolEqualityComparer(this) 659922"];
2631 [label="_comparison 659923"];
2632 [label="_comparison 659924"];
2633 [label="AllIgnoreOptionsPlusNullableWithUnknownMatchesAny =\n                                                                  new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 659925"];
2634 [label="TypeCompareKind.CLRSignatureCompareOptions 659926"];
2635 [label="new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 659927"];
2636 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 659928"];
2637 [label="param SymbolEqualityComparer(this) 659929"];
2638 [label="_comparison 659930"];
2639 [label="_comparison 659931"];
2640 [label="CLRSignature = new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 659932"];
2641 [label="SymbolEqualityComparer.CLRSignature 659933"];
2642 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 659934"];
2643 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 659935"];
2644 [label="EmptyInterfacesAndTheirBaseInterfaces =\n                                                new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 659936"];
2645 [label="new InterfaceInfo() 659937"];
2646 [label="param InterfaceInfo(this) 659938"];
2647 [label="interfacesAndTheirBaseInterfaces 659939"];
2648 [label="_implementationForInterfaceMemberMap 659940"];
2649 [label="explicitInterfaceImplementationMap 659941"];
2650 [label="s_noInterfaces = new InterfaceInfo() 659942"];
2651 [label="(type) => type.SetUnknownNullabilityForReferenceTypes() 659943"];
2652 [label="s_setUnknownNullability =\n            (type) => type.SetUnknownNullabilityForReferenceTypes() 659944"];
2653 [label="param TypeSymbol(this) 659945"];
2654 [label="param NamespaceOrTypeSymbol(this) 659946"];
2655 [label="param Symbol(this) 659947"];
2656 [label="_lazyISymbol 659948"];
2657 [label="_lazyAbstractMembers 659949"];
2658 [label="_lazyInterfaceInfo 659950"];
2659 [label="_lazyAdapter 659951"];
2660 [label="_hasNoBaseCycles 659952"];
2661 [label="_lazyTupleData 659953"];
2662 [label="_lazyTupleData 659954"];
2663 [label="_mrEx 659955"];
2664 [label="_mrEx 659956"];
2665 [label="UnknownResultType = new UnsupportedMetadataTypeSymbol() 659957"];
2666 [label="lazyComImportCoClassType = ErrorTypeSymbol.UnknownResultType 659958"];
2667 [label="lazyHasEmbeddedAttribute = ThreeState.Unknown 659959"];
2668 [label="s_noUncommonProperties = new UncommonProperties() 659960"];
2669 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 659961"];
2670 [label="PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key) 659962"];
2671 [label="param Create(PEModuleSymbol moduleSymbol) 659963"];
2672 [label="param Create(PENamespaceSymbol containingNamespace) 659964"];
2673 [label="param Create(TypeDefinitionHandle handle) 659965"];
2674 [label="param Create(string emittedNamespaceName) 659966"];
2675 [label="GenericParameterHandleCollection genericParameterHandles; 659967"];
2676 [label="genericParameterHandles 659968"];
2677 [label="ushort arity; 659969"];
2678 [label="BadImageFormatException mrEx = null; 659970"];
2679 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 659971"];
2680 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 659972"];
2681 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 659973"];
2682 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 659974"];
2683 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 659975"];
2684 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx) 659976"];
2685 [label="param GetGenericInfo(PEModuleSymbol moduleSymbol) 659977"];
2686 [label="param GetGenericInfo(TypeDefinitionHandle handle) 659978"];
2687 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 659979"];
2688 [label="param GetGenericInfo(out ushort arity) 659980"];
2689 [label="param GetGenericInfo(out BadImageFormatException mrEx) 659981"];
2690 [label="moduleSymbol.Module 659982"];
2691 [label="get\n            {\n                return _module;\n            } 659983"];
2692 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 659984"];
2693 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 659985"];
2694 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 659986"];
2695 [label="arity = (ushort)genericParameterHandles.Count; 659987"];
2696 [label="mrEx = null; 659988"];
2697 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 659989"];
2698 [label="bool mangleName; 659990"];
2699 [label="PENamedTypeSymbol result; 659991"];
2700 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 659992"];
2701 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 659993"];
2702 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 659994"];
2703 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 659995"];
2704 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 659996"];
2705 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 659997"];
2706 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 659998"];
2707 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 659999"];
2708 [label="new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName) 660000"];
2709 [label="param PENamedTypeSymbolNonGeneric(PEModuleSymbol moduleSymbol) 660001"];
2710 [label="param PENamedTypeSymbolNonGeneric(NamespaceOrTypeSymbol container) 660002"];
2711 [label="param PENamedTypeSymbolNonGeneric(TypeDefinitionHandle handle) 660003"];
2712 [label="param PENamedTypeSymbolNonGeneric(string emittedNamespaceName) 660004"];
2713 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 660005"];
2714 [label="param PENamedTypeSymbolNonGeneric(this) 660006"];
2715 [label="moduleSymbol 660007"];
2716 [label="container 660008"];
2717 [label="handle 660009"];
2718 [label="emittedNamespaceName 660010"];
2719 [label="0 660011"];
2720 [label="mangleName 660012"];
2721 [label="param PENamedTypeSymbolNonGeneric(this) 660013"];
2722 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 660014"];
2723 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 660015"];
2724 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 660016"];
2725 [label="param PENamedTypeSymbol(string emittedNamespaceName) 660017"];
2726 [label="param PENamedTypeSymbol(ushort arity) 660018"];
2727 [label="param PENamedTypeSymbol(out bool mangleName) 660019"];
2728 [label="param PENamedTypeSymbol(this) 660020"];
2729 [label="param PENamedTypeSymbol(this) 660021"];
2730 [label="param NamedTypeSymbol(this) 660022"];
2731 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 660023"];
2732 [label="param NamedTypeSymbol(this) 660024"];
2733 [label="param TypeSymbol(this) 660025"];
2734 [label="param TypeSymbol(this) 660026"];
2735 [label="_lazyAbstractMembers 660027"];
2736 [label="_lazyInterfaceInfo 660028"];
2737 [label="_lazyAdapter 660029"];
2738 [label="_hasNoBaseCycles 660030"];
2739 [label="_lazyTupleData 660031"];
2740 [label="_lazyTupleData 660032"];
2741 [label="_container 660033"];
2742 [label="_name 660034"];
2743 [label="_flags 660035"];
2744 [label="_corTypeId 660036"];
2745 [label="_lazyMemberNames 660037"];
2746 [label="_lazyMembersByName 660038"];
2747 [label="_lazyNestedTypes 660039"];
2748 [label="_lazyKind 660040"];
2749 [label="_lazyNullableContextValue 660041"];
2750 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 660042"];
2751 [label="default(ImmutableArray<NamedTypeSymbol>) 660043"];
2752 [label="_lazyInterfaces = default(ImmutableArray<NamedTypeSymbol>) 660044"];
2753 [label="_lazyDeclaredBaseType = ErrorTypeSymbol.UnknownResultType 660045"];
2754 [label="default(ImmutableArray<NamedTypeSymbol>) 660046"];
2755 [label="_lazyDeclaredInterfaces = default(ImmutableArray<NamedTypeSymbol>) 660047"];
2756 [label="_lazyDocComment 660048"];
2757 [label="_lazyUseSiteDiagnostic = CSDiagnosticInfo.EmptyErrorInfo 660049"];
2758 [label="_lazyUncommonProperties 660050"];
2759 [label="public IEnumerable<object> fieldDefs { get; set; } 660051"];
2760 [label="Debug.Assert(!handle.IsNil); 660052"];
2761 [label="Debug.Assert((object)container != null); 660053"];
2762 [label="Debug.Assert((object)container != null); 660054"];
2763 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 660055"];
2764 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 660056"];
2765 [label="string metadataName; 660057"];
2766 [label="bool makeBad = false; 660058"];
2767 [label="moduleSymbol.Module 660059"];
2768 [label="get\n            {\n                return _module;\n            } 660060"];
2769 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 660061"];
2770 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 660062"];
2771 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 660063"];
2772 [label="_handle 660064"];
2773 [label="_container 660065"];
2774 [label="moduleSymbol.Module 660066"];
2775 [label="get\n            {\n                return _module;\n            } 660067"];
2776 [label="return _module; 660068"];
2777 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 660069"];
2778 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 660070"];
2779 [label="_flags 660071"];
2780 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 660072"];
2781 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 660073"];
2782 [label="_name 660074"];
2783 [label="mangleName = false; 660075"];
2784 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 660076"];
2785 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 660077"];
2786 [label="moduleSymbol.ContainingAssembly 660078"];
2787 [label="get\n            {\n                return _assemblySymbol;\n            } 660079"];
2788 [label="return _assemblySymbol; 660080"];
2789 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 660081"];
2790 [label="moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 660082"];
2791 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 660083"];
2792 [label="this.CorLibrary 660084"];
2793 [label="get\n            {\n                return _corLibrary;\n            } 660085"];
2794 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 660086"];
2795 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 660087"];
2796 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 660088"];
2797 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 660089"];
2798 [label="this.DeclaredAccessibility 660090"];
2799 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 660091"];
2800 [label="Accessibility access = Accessibility.Private; 660092"];
2801 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 660093"];
2802 [label="access = Accessibility.Internal; 660094"];
2803 [label="return access; 660095"];
2804 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 660096"];
2805 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 660097"];
2806 [label="_corTypeId 660098"];
2807 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 660099"];
2808 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660100"];
2809 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660101"];
2810 [label="return result; 660102"];
2811 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 660103"];
2812 [label="GenericParameterHandleCollection genericParameterHandles; 660104"];
2813 [label="genericParameterHandles 660105"];
2814 [label="ushort arity; 660106"];
2815 [label="BadImageFormatException mrEx = null; 660107"];
2816 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 660108"];
2817 [label="param GetGenericInfo(out ushort arity) 660109"];
2818 [label="param GetGenericInfo(out BadImageFormatException mrEx) 660110"];
2819 [label="mrEx = null; 660111"];
2820 [label="bool mangleName; 660112"];
2821 [label="PENamedTypeSymbol result; 660113"];
2822 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 660114"];
2823 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 660115"];
2824 [label="new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName) 660116"];
2825 [label="param PENamedTypeSymbolGeneric(PEModuleSymbol moduleSymbol) 660117"];
2826 [label="param PENamedTypeSymbolGeneric(NamespaceOrTypeSymbol container) 660118"];
2827 [label="param PENamedTypeSymbolGeneric(TypeDefinitionHandle handle) 660119"];
2828 [label="param PENamedTypeSymbolGeneric(string emittedNamespaceName) 660120"];
2829 [label="param PENamedTypeSymbolGeneric(GenericParameterHandleCollection genericParameterHandles) 660121"];
2830 [label="param PENamedTypeSymbolGeneric(ushort arity) 660122"];
2831 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 660123"];
2832 [label="param PENamedTypeSymbolGeneric(this) 660124"];
2833 [label="moduleSymbol 660125"];
2834 [label="container 660126"];
2835 [label="handle 660127"];
2836 [label="emittedNamespaceName 660128"];
2837 [label="arity 660129"];
2838 [label="mangleName 660130"];
2839 [label="param PENamedTypeSymbolGeneric(this) 660131"];
2840 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 660132"];
2841 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 660133"];
2842 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 660134"];
2843 [label="param PENamedTypeSymbol(string emittedNamespaceName) 660135"];
2844 [label="param PENamedTypeSymbol(ushort arity) 660136"];
2845 [label="param PENamedTypeSymbol(out bool mangleName) 660137"];
2846 [label="_lazyTupleData 660138"];
2847 [label="_container 660139"];
2848 [label="_name 660140"];
2849 [label="_flags 660141"];
2850 [label="_corTypeId 660142"];
2851 [label="Debug.Assert(!handle.IsNil); 660143"];
2852 [label="Debug.Assert((object)container != null); 660144"];
2853 [label="Debug.Assert((object)container != null); 660145"];
2854 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 660146"];
2855 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 660147"];
2856 [label="string metadataName; 660148"];
2857 [label="bool makeBad = false; 660149"];
2858 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 660150"];
2859 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 660151"];
2860 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 660152"];
2861 [label="_name 660153"];
2862 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 660154"];
2863 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 660155"];
2864 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 660156"];
2865 [label="mangleName = !ReferenceEquals(_name, metadataName); 660157"];
2866 [label="mangleName = !ReferenceEquals(_name, metadataName); 660158"];
2867 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 660159"];
2868 [label="Accessibility access = Accessibility.Private; 660160"];
2869 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 660161"];
2870 [label="_arity 660162"];
2871 [label="_mangleName 660163"];
2872 [label="Debug.Assert(genericParameterHandles.Count > 0); 660164"];
2873 [label="Debug.Assert(genericParameterHandles.Count > 0); 660165"];
2874 [label="_arity 660166"];
2875 [label="_genericParameterHandles 660167"];
2876 [label="_mangleName 660168"];
2877 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660169"];
2878 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660170"];
2879 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 660171"];
2880 [label="GenericParameterHandleCollection genericParameterHandles; 660172"];
2881 [label="genericParameterHandles 660173"];
2882 [label="ushort arity; 660174"];
2883 [label="BadImageFormatException mrEx = null; 660175"];
2884 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 660176"];
2885 [label="param GetGenericInfo(out ushort arity) 660177"];
2886 [label="param GetGenericInfo(out BadImageFormatException mrEx) 660178"];
2887 [label="mrEx = null; 660179"];
2888 [label="bool mangleName; 660180"];
2889 [label="PENamedTypeSymbol result; 660181"];
2890 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 660182"];
2891 [label="mangleName 660183"];
2892 [label="param PENamedTypeSymbol(out bool mangleName) 660184"];
2893 [label="_lazyTupleData 660185"];
2894 [label="_container 660186"];
2895 [label="_name 660187"];
2896 [label="_flags 660188"];
2897 [label="_corTypeId 660189"];
2898 [label="Debug.Assert(!handle.IsNil); 660190"];
2899 [label="Debug.Assert((object)container != null); 660191"];
2900 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 660192"];
2901 [label="string metadataName; 660193"];
2902 [label="bool makeBad = false; 660194"];
2903 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 660195"];
2904 [label="Accessibility access = Accessibility.Private; 660196"];
2905 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 660197"];
2906 [label="_arity 660198"];
2907 [label="_mangleName 660199"];
2908 [label="Debug.Assert(genericParameterHandles.Count > 0); 660200"];
2909 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660201"];
2910 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660202"];
2911 [label="GenericParameterHandleCollection genericParameterHandles; 660203"];
2912 [label="genericParameterHandles 660204"];
2913 [label="ushort arity; 660205"];
2914 [label="BadImageFormatException mrEx = null; 660206"];
2915 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 660207"];
2916 [label="param GetGenericInfo(out ushort arity) 660208"];
2917 [label="param GetGenericInfo(out BadImageFormatException mrEx) 660209"];
2918 [label="mrEx = null; 660210"];
2919 [label="PENamedTypeSymbol result; 660211"];
2920 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 660212"];
2921 [label="mangleName 660213"];
2922 [label="param PENamedTypeSymbol(out bool mangleName) 660214"];
2923 [label="Debug.Assert(!handle.IsNil); 660215"];
2924 [label="mangleName = false; 660216"];
2925 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660217"];
2926 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660218"];
2927 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 660219"];
2928 [label="mangleName 660220"];
2929 [label="param PENamedTypeSymbol(out bool mangleName) 660221"];
2930 [label="_lazyTupleData 660222"];
2931 [label="_container 660223"];
2932 [label="_name 660224"];
2933 [label="_flags 660225"];
2934 [label="_corTypeId 660226"];
2935 [label="Debug.Assert(!handle.IsNil); 660227"];
2936 [label="Debug.Assert((object)container != null); 660228"];
2937 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 660229"];
2938 [label="string metadataName; 660230"];
2939 [label="bool makeBad = false; 660231"];
2940 [label="mangleName = false; 660232"];
2941 [label="Accessibility access = Accessibility.Private; 660233"];
2942 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 660234"];
2943 [label="genericParameterHandles 660235"];
2944 [label="ushort arity; 660236"];
2945 [label="BadImageFormatException mrEx = null; 660237"];
2946 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 660238"];
2947 [label="param GetGenericInfo(out ushort arity) 660239"];
2948 [label="param GetGenericInfo(out BadImageFormatException mrEx) 660240"];
2949 [label="mrEx = null; 660241"];
2950 [label="PENamedTypeSymbol result; 660242"];
2951 [label="Debug.Assert(!handle.IsNil); 660243"];
2952 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660244"];
2953 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660245"];
2954 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 660246"];
2955 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 660247"];
2956 [label="mangleName 660248"];
2957 [label="param PENamedTypeSymbol(out bool mangleName) 660249"];
2958 [label="_lazyTupleData 660250"];
2959 [label="_container 660251"];
2960 [label="_name 660252"];
2961 [label="_flags 660253"];
2962 [label="_corTypeId 660254"];
2963 [label="Debug.Assert(!handle.IsNil); 660255"];
2964 [label="Debug.Assert((object)container != null); 660256"];
2965 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 660257"];
2966 [label="string metadataName; 660258"];
2967 [label="bool makeBad = false; 660259"];
2968 [label="mangleName = false; 660260"];
2969 [label="Accessibility access = Accessibility.Private; 660261"];
2970 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 660262"];
2971 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 660263"];
2972 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 660264"];
2973 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 660265"];
2974 [label="get\n            {\n                return _name;\n            } 660266"];
2975 [label="return _name; 660267"];
2976 [label="children.Free(); 660268"];
2977 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 660269"];
2978 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 660270"];
2979 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 660271"];
2980 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 660272"];
2981 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 660273"];
2982 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 660274"];
2983 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 660275"];
2984 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 660276"];
2985 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict) 660277"];
2986 [label="param OnNewTypeDeclarationsLoaded(Dictionary<string, ImmutableArray<PENamedTypeSymbol>> typesDict) 660278"];
2987 [label="param OnNewTypeDeclarationsLoaded(this) 660279"];
2988 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 660280"];
2989 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 660281"];
2990 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 660282"];
2991 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 660283"];
2992 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 660284"];
2993 [label="foreach (var types in typesDict.Values)\n            {\n                foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                }\n            } 660285"];
2994 [label="foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                } 660286"];
2995 [label="bool added; 660287"];
2996 [label="type.Handle 660288"];
2997 [label="get\n            {\n                return _handle;\n            } 660289"];
2998 [label="return _handle; 660290"];
2999 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 660291"];
3000 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 660292"];
3001 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 660293"];
3002 [label="Debug.Assert(added); 660294"];
3003 [label="type.SpecialType 660295"];
3004 [label="get\n            {\n                return _corTypeId;\n            } 660296"];
3005 [label="return _corTypeId; 660297"];
3006 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 660298"];
3007 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 660299"];
3008 [label="bool added; 660300"];
3009 [label="Debug.Assert(added); 660301"];
3010 [label="type.SpecialType 660302"];
3011 [label="get\n            {\n                return _corTypeId;\n            } 660303"];
3012 [label="return _corTypeId; 660304"];
3013 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 660305"];
3014 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 660306"];
3015 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 660307"];
3016 [label="LazyInitializeTypes(nestedTypes); 660308"];
3017 [label="LoadAllMembers(groups); 660309"];
3018 [label="EnsureAllMembersLoaded(); 660310"];
3019 [label="PENestedNamespaceSymbol ns = null; 660311"];
3020 [label="ImmutableArray<PENamedTypeSymbol> t; 660312"];
3021 [label="t 660313"];
3022 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 660314"];
3023 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 660315"];
3024 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 660316"];
3025 [label="if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 660317"];
3026 [label="if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 660318"];
3027 [label="if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 660319"];
3028 [label="return ImmutableArray<Symbol>.Empty; 660320"];
3029 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 660321"];
3030 [label="Debug.Assert(typesByNS != null); 660322"];
3031 [label="get\n            {\n                return true;\n            } 660323"];
3032 [label="_containingNamespaceSymbol 660324"];
3033 [label="_name 660325"];
3034 [label="_typesByNS 660326"];
3035 [label="Debug.Assert(name != null); 660327"];
3036 [label="Debug.Assert((object)containingNamespace != null); 660328"];
3037 [label="Debug.Assert(typesByNS != null); 660329"];
3038 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 660330"];
3039 [label="genericParameterHandles 660331"];
3040 [label="BadImageFormatException mrEx = null; 660332"];
3041 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 660333"];
3042 [label="param GetGenericInfo(out ushort arity) 660334"];
3043 [label="param GetGenericInfo(out BadImageFormatException mrEx) 660335"];
3044 [label="mrEx = null; 660336"];
3045 [label="PENamedTypeSymbol result; 660337"];
3046 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 660338"];
3047 [label="mangleName 660339"];
3048 [label="param PENamedTypeSymbol(out bool mangleName) 660340"];
3049 [label="_lazyTupleData 660341"];
3050 [label="_container 660342"];
3051 [label="_name 660343"];
3052 [label="_flags 660344"];
3053 [label="_corTypeId 660345"];
3054 [label="Debug.Assert(!handle.IsNil); 660346"];
3055 [label="Debug.Assert((object)container != null); 660347"];
3056 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 660348"];
3057 [label="string metadataName; 660349"];
3058 [label="bool makeBad = false; 660350"];
3059 [label="mangleName = false; 660351"];
3060 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 660352"];
3061 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660353"];
3062 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660354"];
3063 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 660355"];
3064 [label="param GetGenericInfo(out ushort arity) 660356"];
3065 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 660357"];
3066 [label="mangleName 660358"];
3067 [label="param PENamedTypeSymbol(out bool mangleName) 660359"];
3068 [label="_lazyTupleData 660360"];
3069 [label="_container 660361"];
3070 [label="_name 660362"];
3071 [label="_flags 660363"];
3072 [label="_corTypeId 660364"];
3073 [label="Debug.Assert(!handle.IsNil); 660365"];
3074 [label="Debug.Assert((object)container != null); 660366"];
3075 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 660367"];
3076 [label="string metadataName; 660368"];
3077 [label="bool makeBad = false; 660369"];
3078 [label="mangleName = false; 660370"];
3079 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 660371"];
3080 [label="genericParameterHandles 660372"];
3081 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 660373"];
3082 [label="param GetGenericInfo(out ushort arity) 660374"];
3083 [label="param GetGenericInfo(out BadImageFormatException mrEx) 660375"];
3084 [label="mrEx = null; 660376"];
3085 [label="PENamedTypeSymbol result; 660377"];
3086 [label="Debug.Assert(!handle.IsNil); 660378"];
3087 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660379"];
3088 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660380"];
3089 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 660381"];
3090 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 660382"];
3091 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 660383"];
3092 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 660384"];
3093 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 660385"];
3094 [label="bool added; 660386"];
3095 [label="Debug.Assert(added); 660387"];
3096 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 660388"];
3097 [label="EnsureAllMembersLoaded(); 660389"];
3098 [label="return ImmutableArray<Symbol>.Empty; 660390"];
3099 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 660391"];
3100 [label="Debug.Assert(typesByNS != null); 660392"];
3101 [label="get\n            {\n                return true;\n            } 660393"];
3102 [label="_containingNamespaceSymbol 660394"];
3103 [label="_name 660395"];
3104 [label="_typesByNS 660396"];
3105 [label="Debug.Assert(name != null); 660397"];
3106 [label="Debug.Assert((object)containingNamespace != null); 660398"];
3107 [label="Debug.Assert(typesByNS != null); 660399"];
3108 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 660400"];
3109 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 660401"];
3110 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 660402"];
3111 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 660403"];
3112 [label="bool added; 660404"];
3113 [label="Debug.Assert(added); 660405"];
3114 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 660406"];
3115 [label="EnsureAllMembersLoaded(); 660407"];
3116 [label="return ImmutableArray<Symbol>.Empty; 660408"];
3117 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 660409"];
3118 [label="Debug.Assert(typesByNS != null); 660410"];
3119 [label="get\n            {\n                return true;\n            } 660411"];
3120 [label="_containingNamespaceSymbol 660412"];
3121 [label="_name 660413"];
3122 [label="_typesByNS 660414"];
3123 [label="Debug.Assert(name != null); 660415"];
3124 [label="Debug.Assert((object)containingNamespace != null); 660416"];
3125 [label="Debug.Assert(typesByNS != null); 660417"];
3126 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 660418"];
3127 [label="genericParameterHandles 660419"];
3128 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 660420"];
3129 [label="param GetGenericInfo(out ushort arity) 660421"];
3130 [label="param GetGenericInfo(out BadImageFormatException mrEx) 660422"];
3131 [label="mrEx = null; 660423"];
3132 [label="PENamedTypeSymbol result; 660424"];
3133 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 660425"];
3134 [label="mangleName 660426"];
3135 [label="param PENamedTypeSymbol(out bool mangleName) 660427"];
3136 [label="_lazyTupleData 660428"];
3137 [label="_container 660429"];
3138 [label="_name 660430"];
3139 [label="_flags 660431"];
3140 [label="_corTypeId 660432"];
3141 [label="Debug.Assert(!handle.IsNil); 660433"];
3142 [label="Debug.Assert((object)container != null); 660434"];
3143 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 660435"];
3144 [label="string metadataName; 660436"];
3145 [label="bool makeBad = false; 660437"];
3146 [label="mangleName = false; 660438"];
3147 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 660439"];
3148 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660440"];
3149 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 660441"];
3150 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 660442"];
3151 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 660443"];
3152 [label="EnsureAllMembersLoaded(); 660444"];
3153 [label="return ImmutableArray<Symbol>.Empty; 660445"];
3154 [label="if (namespaceSymbols != null)\n            {\n                otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()));\n            } 660446"];
3155 [label="if (namespaceSymbols != null)\n            {\n                otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()));\n            } 660447"];
3156 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 660448"];
3157 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 660449"];
3158 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 660450"];
3159 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 660451"];
3160 [label="MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()) 660452"];
3161 [label="param Create(NamespaceExtent extent) 660453"];
3162 [label="param Create(NamespaceSymbol containingNamespace) 660454"];
3163 [label="param Create(ImmutableArray<NamespaceSymbol> namespacesToMerge) 660455"];
3164 [label="param Create(string nameOpt = null) 660456"];
3165 [label="Debug.Assert(namespacesToMerge.Length != 0); 660457"];
3166 [label="Debug.Assert(namespacesToMerge.Length != 0); 660458"];
3167 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 660459"];
3168 [label="return otherSymbols.ToImmutableAndFree(); 660460"];
3169 [label="var classA = namespaceNS.GetTypeMembers('A').First(); 660461"];
3170 [label="namespaceNS.GetTypeMembers('A') 660462"];
3171 [label="param GetTypeMembers(string name) 660463"];
3172 [label="param GetTypeMembers(this) 660464"];
3173 [label="ImmutableArray<NamedTypeSymbol> members; 660465"];
3174 [label="members 660466"];
3175 [label="this.GetNameToTypeMembersMap() 660467"];
3176 [label="param GetNameToTypeMembersMap(this) 660468"];
3177 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 660469"];
3178 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 660470"];
3179 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 660471"];
3180 [label="GetNameToMembersMap() 660472"];
3181 [label="param BuildSymbol(this) 660473"];
3182 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 660474"];
3183 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 660475"];
3184 [label="new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics) 660476"];
3185 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 660477"];
3186 [label="param SourceNamedTypeSymbol(MergedTypeDeclaration declaration) 660478"];
3187 [label="param SourceNamedTypeSymbol(DiagnosticBag diagnostics) 660479"];
3188 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 660480"];
3189 [label="param SourceNamedTypeSymbol(this) 660481"];
3190 [label="false 660482"];
3191 [label="considerName: false 660483"];
3192 [label="false 660484"];
3193 [label="considerExplicitlyImplementedInterfaces: false 660485"];
3194 [label="true 660486"];
3195 [label="considerReturnType: true 660487"];
3196 [label="false 660488"];
3197 [label="considerTypeConstraints: false 660489"];
3198 [label="true 660490"];
3199 [label="considerRefKindDifferences: true 660491"];
3200 [label="true 660492"];
3201 [label="considerCallingConvention: true 660493"];
3202 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 660494"];
3203 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660495"];
3204 [label="param MemberSignatureComparer(bool considerName) 660496"];
3205 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 660497"];
3206 [label="param MemberSignatureComparer(bool considerReturnType) 660498"];
3207 [label="param MemberSignatureComparer(bool considerTypeConstraints) 660499"];
3208 [label="param MemberSignatureComparer(bool considerCallingConvention) 660500"];
3209 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 660501"];
3210 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 660502"];
3211 [label="param MemberSignatureComparer(this) 660503"];
3212 [label="_considerName 660504"];
3213 [label="_considerExplicitlyImplementedInterfaces 660505"];
3214 [label="_considerReturnType 660506"];
3215 [label="_considerTypeConstraints 660507"];
3216 [label="_considerCallingConvention 660508"];
3217 [label="_considerRefKindDifferences 660509"];
3218 [label="_typeComparison 660510"];
3219 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660511"];
3220 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660512"];
3221 [label="_considerName 660513"];
3222 [label="_considerExplicitlyImplementedInterfaces 660514"];
3223 [label="_considerReturnType 660515"];
3224 [label="_considerTypeConstraints 660516"];
3225 [label="_considerCallingConvention 660517"];
3226 [label="_considerRefKindDifferences 660518"];
3227 [label="_typeComparison 660519"];
3228 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660520"];
3229 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660521"];
3230 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 660522"];
3231 [label="ExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660523"];
3232 [label="true 660524"];
3233 [label="considerName: true 660525"];
3234 [label="true 660526"];
3235 [label="considerExplicitlyImplementedInterfaces: true 660527"];
3236 [label="true 660528"];
3237 [label="considerReturnType: true 660529"];
3238 [label="false 660530"];
3239 [label="considerTypeConstraints: false 660531"];
3240 [label="true 660532"];
3241 [label="considerCallingConvention: true 660533"];
3242 [label="true 660534"];
3243 [label="considerRefKindDifferences: true 660535"];
3244 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 660536"];
3245 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660537"];
3246 [label="param MemberSignatureComparer(bool considerName) 660538"];
3247 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 660539"];
3248 [label="param MemberSignatureComparer(bool considerReturnType) 660540"];
3249 [label="param MemberSignatureComparer(bool considerTypeConstraints) 660541"];
3250 [label="param MemberSignatureComparer(bool considerCallingConvention) 660542"];
3251 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 660543"];
3252 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 660544"];
3253 [label="param MemberSignatureComparer(this) 660545"];
3254 [label="_considerName 660546"];
3255 [label="_considerExplicitlyImplementedInterfaces 660547"];
3256 [label="_considerReturnType 660548"];
3257 [label="_considerTypeConstraints 660549"];
3258 [label="_considerCallingConvention 660550"];
3259 [label="_considerRefKindDifferences 660551"];
3260 [label="_typeComparison 660552"];
3261 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660553"];
3262 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660554"];
3263 [label="_considerName 660555"];
3264 [label="_considerExplicitlyImplementedInterfaces 660556"];
3265 [label="_considerReturnType 660557"];
3266 [label="_considerTypeConstraints 660558"];
3267 [label="_considerCallingConvention 660559"];
3268 [label="_considerRefKindDifferences 660560"];
3269 [label="_typeComparison 660561"];
3270 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660562"];
3271 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660563"];
3272 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 660564"];
3273 [label="CSharpImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660565"];
3274 [label="true 660566"];
3275 [label="considerName: true 660567"];
3276 [label="true 660568"];
3277 [label="considerExplicitlyImplementedInterfaces: true 660569"];
3278 [label="false 660570"];
3279 [label="considerReturnType: false 660571"];
3280 [label="false 660572"];
3281 [label="considerTypeConstraints: false 660573"];
3282 [label="false 660574"];
3283 [label="considerCallingConvention: false 660575"];
3284 [label="true 660576"];
3285 [label="considerRefKindDifferences: true 660577"];
3286 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 660578"];
3287 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660579"];
3288 [label="param MemberSignatureComparer(bool considerName) 660580"];
3289 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 660581"];
3290 [label="param MemberSignatureComparer(bool considerReturnType) 660582"];
3291 [label="param MemberSignatureComparer(bool considerTypeConstraints) 660583"];
3292 [label="param MemberSignatureComparer(bool considerCallingConvention) 660584"];
3293 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 660585"];
3294 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 660586"];
3295 [label="param MemberSignatureComparer(this) 660587"];
3296 [label="_considerName 660588"];
3297 [label="_considerExplicitlyImplementedInterfaces 660589"];
3298 [label="_considerReturnType 660590"];
3299 [label="_considerTypeConstraints 660591"];
3300 [label="_considerCallingConvention 660592"];
3301 [label="_considerRefKindDifferences 660593"];
3302 [label="_typeComparison 660594"];
3303 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660595"];
3304 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660596"];
3305 [label="_considerName 660597"];
3306 [label="_considerExplicitlyImplementedInterfaces 660598"];
3307 [label="_considerReturnType 660599"];
3308 [label="_considerTypeConstraints 660600"];
3309 [label="_considerCallingConvention 660601"];
3310 [label="_considerRefKindDifferences 660602"];
3311 [label="_typeComparison 660603"];
3312 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660604"];
3313 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660605"];
3314 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 660606"];
3315 [label="CSharpCloseImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660607"];
3316 [label="true 660608"];
3317 [label="considerName: true 660609"];
3318 [label="true 660610"];
3319 [label="considerExplicitlyImplementedInterfaces: true 660611"];
3320 [label="false 660612"];
3321 [label="considerReturnType: false 660613"];
3322 [label="false 660614"];
3323 [label="considerTypeConstraints: false 660615"];
3324 [label="false 660616"];
3325 [label="considerCallingConvention: false 660617"];
3326 [label="false 660618"];
3327 [label="considerRefKindDifferences: false 660619"];
3328 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 660620"];
3329 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660621"];
3330 [label="param MemberSignatureComparer(bool considerName) 660622"];
3331 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 660623"];
3332 [label="param MemberSignatureComparer(bool considerReturnType) 660624"];
3333 [label="param MemberSignatureComparer(bool considerTypeConstraints) 660625"];
3334 [label="param MemberSignatureComparer(bool considerCallingConvention) 660626"];
3335 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 660627"];
3336 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 660628"];
3337 [label="param MemberSignatureComparer(this) 660629"];
3338 [label="_considerName 660630"];
3339 [label="_considerExplicitlyImplementedInterfaces 660631"];
3340 [label="_considerReturnType 660632"];
3341 [label="_considerTypeConstraints 660633"];
3342 [label="_considerCallingConvention 660634"];
3343 [label="_considerRefKindDifferences 660635"];
3344 [label="_typeComparison 660636"];
3345 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660637"];
3346 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660638"];
3347 [label="_considerName 660639"];
3348 [label="_considerExplicitlyImplementedInterfaces 660640"];
3349 [label="_considerReturnType 660641"];
3350 [label="_considerTypeConstraints 660642"];
3351 [label="_considerCallingConvention 660643"];
3352 [label="_considerRefKindDifferences 660644"];
3353 [label="_typeComparison 660645"];
3354 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660646"];
3355 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660647"];
3356 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 660648"];
3357 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 660649"];
3358 [label="_typeComparison 660650"];
3359 [label="DuplicateSourceComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660651"];
3360 [label="true 660652"];
3361 [label="considerName: true 660653"];
3362 [label="true 660654"];
3363 [label="considerExplicitlyImplementedInterfaces: true 660655"];
3364 [label="false 660656"];
3365 [label="considerReturnType: false 660657"];
3366 [label="false 660658"];
3367 [label="considerTypeConstraints: false 660659"];
3368 [label="false 660660"];
3369 [label="considerCallingConvention: false 660661"];
3370 [label="true 660662"];
3371 [label="considerRefKindDifferences: true 660663"];
3372 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 660664"];
3373 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660665"];
3374 [label="param MemberSignatureComparer(bool considerName) 660666"];
3375 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 660667"];
3376 [label="param MemberSignatureComparer(bool considerReturnType) 660668"];
3377 [label="param MemberSignatureComparer(bool considerTypeConstraints) 660669"];
3378 [label="param MemberSignatureComparer(bool considerCallingConvention) 660670"];
3379 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 660671"];
3380 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 660672"];
3381 [label="param MemberSignatureComparer(this) 660673"];
3382 [label="_considerName 660674"];
3383 [label="_considerExplicitlyImplementedInterfaces 660675"];
3384 [label="_considerReturnType 660676"];
3385 [label="_considerTypeConstraints 660677"];
3386 [label="_considerCallingConvention 660678"];
3387 [label="_considerRefKindDifferences 660679"];
3388 [label="_typeComparison 660680"];
3389 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660681"];
3390 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660682"];
3391 [label="_considerName 660683"];
3392 [label="_considerExplicitlyImplementedInterfaces 660684"];
3393 [label="_considerReturnType 660685"];
3394 [label="_considerTypeConstraints 660686"];
3395 [label="_considerCallingConvention 660687"];
3396 [label="_considerRefKindDifferences 660688"];
3397 [label="_typeComparison 660689"];
3398 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660690"];
3399 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660691"];
3400 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 660692"];
3401 [label="RecordAPISignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660693"];
3402 [label="true 660694"];
3403 [label="considerName: true 660695"];
3404 [label="true 660696"];
3405 [label="considerExplicitlyImplementedInterfaces: true 660697"];
3406 [label="false 660698"];
3407 [label="considerReturnType: false 660699"];
3408 [label="false 660700"];
3409 [label="considerTypeConstraints: false 660701"];
3410 [label="false 660702"];
3411 [label="considerCallingConvention: false 660703"];
3412 [label="true 660704"];
3413 [label="considerRefKindDifferences: true 660705"];
3414 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 660706"];
3415 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660707"];
3416 [label="param MemberSignatureComparer(bool considerName) 660708"];
3417 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 660709"];
3418 [label="param MemberSignatureComparer(bool considerReturnType) 660710"];
3419 [label="param MemberSignatureComparer(bool considerTypeConstraints) 660711"];
3420 [label="param MemberSignatureComparer(bool considerCallingConvention) 660712"];
3421 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 660713"];
3422 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 660714"];
3423 [label="param MemberSignatureComparer(this) 660715"];
3424 [label="_considerName 660716"];
3425 [label="_considerExplicitlyImplementedInterfaces 660717"];
3426 [label="_considerReturnType 660718"];
3427 [label="_considerTypeConstraints 660719"];
3428 [label="_considerCallingConvention 660720"];
3429 [label="_considerRefKindDifferences 660721"];
3430 [label="_typeComparison 660722"];
3431 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660723"];
3432 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660724"];
3433 [label="_considerName 660725"];
3434 [label="_considerExplicitlyImplementedInterfaces 660726"];
3435 [label="_considerReturnType 660727"];
3436 [label="_considerTypeConstraints 660728"];
3437 [label="_considerCallingConvention 660729"];
3438 [label="_considerRefKindDifferences 660730"];
3439 [label="_typeComparison 660731"];
3440 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660732"];
3441 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660733"];
3442 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 660734"];
3443 [label="PartialMethodsComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660735"];
3444 [label="true 660736"];
3445 [label="considerName: true 660737"];
3446 [label="false 660738"];
3447 [label="considerExplicitlyImplementedInterfaces: false 660739"];
3448 [label="false 660740"];
3449 [label="considerReturnType: false 660741"];
3450 [label="false 660742"];
3451 [label="considerTypeConstraints: false 660743"];
3452 [label="false 660744"];
3453 [label="considerCallingConvention: false 660745"];
3454 [label="true 660746"];
3455 [label="considerRefKindDifferences: true 660747"];
3456 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 660748"];
3457 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660749"];
3458 [label="param MemberSignatureComparer(bool considerName) 660750"];
3459 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 660751"];
3460 [label="param MemberSignatureComparer(bool considerReturnType) 660752"];
3461 [label="param MemberSignatureComparer(bool considerTypeConstraints) 660753"];
3462 [label="param MemberSignatureComparer(bool considerCallingConvention) 660754"];
3463 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 660755"];
3464 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 660756"];
3465 [label="param MemberSignatureComparer(this) 660757"];
3466 [label="_considerName 660758"];
3467 [label="_considerExplicitlyImplementedInterfaces 660759"];
3468 [label="_considerReturnType 660760"];
3469 [label="_considerTypeConstraints 660761"];
3470 [label="_considerCallingConvention 660762"];
3471 [label="_considerRefKindDifferences 660763"];
3472 [label="_typeComparison 660764"];
3473 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660765"];
3474 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660766"];
3475 [label="_considerName 660767"];
3476 [label="_considerExplicitlyImplementedInterfaces 660768"];
3477 [label="_considerReturnType 660769"];
3478 [label="_considerTypeConstraints 660770"];
3479 [label="_considerCallingConvention 660771"];
3480 [label="_considerRefKindDifferences 660772"];
3481 [label="_typeComparison 660773"];
3482 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660774"];
3483 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660775"];
3484 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 660776"];
3485 [label="CSharpOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660777"];
3486 [label="true 660778"];
3487 [label="considerName: true 660779"];
3488 [label="false 660780"];
3489 [label="considerExplicitlyImplementedInterfaces: false 660781"];
3490 [label="true 660782"];
3491 [label="considerReturnType: true 660783"];
3492 [label="false 660784"];
3493 [label="considerTypeConstraints: false 660785"];
3494 [label="false 660786"];
3495 [label="considerCallingConvention: false 660787"];
3496 [label="false 660788"];
3497 [label="considerRefKindDifferences: false 660789"];
3498 [label="TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 660790"];
3499 [label="typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 660791"];
3500 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 660792"];
3501 [label="param MemberSignatureComparer(bool considerName) 660793"];
3502 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 660794"];
3503 [label="param MemberSignatureComparer(bool considerReturnType) 660795"];
3504 [label="param MemberSignatureComparer(bool considerTypeConstraints) 660796"];
3505 [label="param MemberSignatureComparer(bool considerCallingConvention) 660797"];
3506 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 660798"];
3507 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 660799"];
3508 [label="param MemberSignatureComparer(this) 660800"];
3509 [label="_considerName 660801"];
3510 [label="_considerExplicitlyImplementedInterfaces 660802"];
3511 [label="_considerReturnType 660803"];
3512 [label="_considerTypeConstraints 660804"];
3513 [label="_considerCallingConvention 660805"];
3514 [label="_considerRefKindDifferences 660806"];
3515 [label="_typeComparison 660807"];
3516 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660808"];
3517 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660809"];
3518 [label="_considerName 660810"];
3519 [label="_considerExplicitlyImplementedInterfaces 660811"];
3520 [label="_considerReturnType 660812"];
3521 [label="_considerTypeConstraints 660813"];
3522 [label="_considerCallingConvention 660814"];
3523 [label="_considerRefKindDifferences 660815"];
3524 [label="_typeComparison 660816"];
3525 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660817"];
3526 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660818"];
3527 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 660819"];
3528 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 660820"];
3529 [label="_typeComparison 660821"];
3530 [label="CSharpWithTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 660822"];
3531 [label="true 660823"];
3532 [label="considerName: true 660824"];
3533 [label="false 660825"];
3534 [label="considerExplicitlyImplementedInterfaces: false 660826"];
3535 [label="true 660827"];
3536 [label="considerReturnType: true 660828"];
3537 [label="false 660829"];
3538 [label="considerTypeConstraints: false 660830"];
3539 [label="false 660831"];
3540 [label="considerCallingConvention: false 660832"];
3541 [label="false 660833"];
3542 [label="considerRefKindDifferences: false 660834"];
3543 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 660835"];
3544 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660836"];
3545 [label="param MemberSignatureComparer(bool considerName) 660837"];
3546 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 660838"];
3547 [label="param MemberSignatureComparer(bool considerReturnType) 660839"];
3548 [label="param MemberSignatureComparer(bool considerTypeConstraints) 660840"];
3549 [label="param MemberSignatureComparer(bool considerCallingConvention) 660841"];
3550 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 660842"];
3551 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 660843"];
3552 [label="param MemberSignatureComparer(this) 660844"];
3553 [label="_considerName 660845"];
3554 [label="_considerExplicitlyImplementedInterfaces 660846"];
3555 [label="_considerReturnType 660847"];
3556 [label="_considerTypeConstraints 660848"];
3557 [label="_considerCallingConvention 660849"];
3558 [label="_considerRefKindDifferences 660850"];
3559 [label="_typeComparison 660851"];
3560 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660852"];
3561 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660853"];
3562 [label="_considerName 660854"];
3563 [label="_considerExplicitlyImplementedInterfaces 660855"];
3564 [label="_considerReturnType 660856"];
3565 [label="_considerTypeConstraints 660857"];
3566 [label="_considerCallingConvention 660858"];
3567 [label="_considerRefKindDifferences 660859"];
3568 [label="_typeComparison 660860"];
3569 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660861"];
3570 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660862"];
3571 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 660863"];
3572 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 660864"];
3573 [label="_typeComparison 660865"];
3574 [label="CSharpWithoutTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660866"];
3575 [label="false 660867"];
3576 [label="considerName: false 660868"];
3577 [label="false 660869"];
3578 [label="considerExplicitlyImplementedInterfaces: false 660870"];
3579 [label="false 660871"];
3580 [label="considerReturnType: false 660872"];
3581 [label="false 660873"];
3582 [label="considerTypeConstraints: false 660874"];
3583 [label="false 660875"];
3584 [label="considerCallingConvention: false 660876"];
3585 [label="true 660877"];
3586 [label="considerRefKindDifferences: true 660878"];
3587 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 660879"];
3588 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660880"];
3589 [label="param MemberSignatureComparer(bool considerName) 660881"];
3590 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 660882"];
3591 [label="param MemberSignatureComparer(bool considerReturnType) 660883"];
3592 [label="param MemberSignatureComparer(bool considerTypeConstraints) 660884"];
3593 [label="param MemberSignatureComparer(bool considerCallingConvention) 660885"];
3594 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 660886"];
3595 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 660887"];
3596 [label="param MemberSignatureComparer(this) 660888"];
3597 [label="_considerName 660889"];
3598 [label="_considerExplicitlyImplementedInterfaces 660890"];
3599 [label="_considerReturnType 660891"];
3600 [label="_considerTypeConstraints 660892"];
3601 [label="_considerCallingConvention 660893"];
3602 [label="_considerRefKindDifferences 660894"];
3603 [label="_typeComparison 660895"];
3604 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660896"];
3605 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660897"];
3606 [label="_considerName 660898"];
3607 [label="_considerExplicitlyImplementedInterfaces 660899"];
3608 [label="_considerReturnType 660900"];
3609 [label="_considerTypeConstraints 660901"];
3610 [label="_considerCallingConvention 660902"];
3611 [label="_considerRefKindDifferences 660903"];
3612 [label="_typeComparison 660904"];
3613 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660905"];
3614 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660906"];
3615 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 660907"];
3616 [label="CSharpAccessorOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 660908"];
3617 [label="true 660909"];
3618 [label="considerName: true 660910"];
3619 [label="false 660911"];
3620 [label="considerExplicitlyImplementedInterfaces: false 660912"];
3621 [label="true 660913"];
3622 [label="considerReturnType: true 660914"];
3623 [label="false 660915"];
3624 [label="considerTypeConstraints: false 660916"];
3625 [label="false 660917"];
3626 [label="considerCallingConvention: false 660918"];
3627 [label="true 660919"];
3628 [label="considerRefKindDifferences: true 660920"];
3629 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 660921"];
3630 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 660922"];
3631 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 660923"];
3632 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 660924"];
3633 [label="param MemberSignatureComparer(bool considerName) 660925"];
3634 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 660926"];
3635 [label="param MemberSignatureComparer(bool considerReturnType) 660927"];
3636 [label="param MemberSignatureComparer(bool considerTypeConstraints) 660928"];
3637 [label="param MemberSignatureComparer(bool considerCallingConvention) 660929"];
3638 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 660930"];
3639 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 660931"];
3640 [label="param MemberSignatureComparer(this) 660932"];
3641 [label="_considerName 660933"];
3642 [label="_considerExplicitlyImplementedInterfaces 660934"];
3643 [label="_considerReturnType 660935"];
3644 [label="_considerTypeConstraints 660936"];
3645 [label="_considerCallingConvention 660937"];
3646 [label="_considerRefKindDifferences 660938"];
3647 [label="_typeComparison 660939"];
3648 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660940"];
3649 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660941"];
3650 [label="_considerName 660942"];
3651 [label="_considerExplicitlyImplementedInterfaces 660943"];
3652 [label="_considerReturnType 660944"];
3653 [label="_considerTypeConstraints 660945"];
3654 [label="_considerCallingConvention 660946"];
3655 [label="_considerRefKindDifferences 660947"];
3656 [label="_typeComparison 660948"];
3657 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660949"];
3658 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660950"];
3659 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 660951"];
3660 [label="CSharpCustomModifierOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 660952"];
3661 [label="false 660953"];
3662 [label="considerName: false 660954"];
3663 [label="false 660955"];
3664 [label="considerExplicitlyImplementedInterfaces: false 660956"];
3665 [label="false 660957"];
3666 [label="considerReturnType: false 660958"];
3667 [label="false 660959"];
3668 [label="considerTypeConstraints: false 660960"];
3669 [label="false 660961"];
3670 [label="considerCallingConvention: false 660962"];
3671 [label="false 660963"];
3672 [label="considerRefKindDifferences: false 660964"];
3673 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 660965"];
3674 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 660966"];
3675 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 660967"];
3676 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 660968"];
3677 [label="param MemberSignatureComparer(bool considerName) 660969"];
3678 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 660970"];
3679 [label="param MemberSignatureComparer(bool considerReturnType) 660971"];
3680 [label="param MemberSignatureComparer(bool considerTypeConstraints) 660972"];
3681 [label="param MemberSignatureComparer(bool considerCallingConvention) 660973"];
3682 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 660974"];
3683 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 660975"];
3684 [label="param MemberSignatureComparer(this) 660976"];
3685 [label="_considerName 660977"];
3686 [label="_considerExplicitlyImplementedInterfaces 660978"];
3687 [label="_considerReturnType 660979"];
3688 [label="_considerTypeConstraints 660980"];
3689 [label="_considerCallingConvention 660981"];
3690 [label="_considerRefKindDifferences 660982"];
3691 [label="_typeComparison 660983"];
3692 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660984"];
3693 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 660985"];
3694 [label="_considerName 660986"];
3695 [label="_considerExplicitlyImplementedInterfaces 660987"];
3696 [label="_considerReturnType 660988"];
3697 [label="_considerTypeConstraints 660989"];
3698 [label="_considerCallingConvention 660990"];
3699 [label="_considerRefKindDifferences 660991"];
3700 [label="_typeComparison 660992"];
3701 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660993"];
3702 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 660994"];
3703 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 660995"];
3704 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 660996"];
3705 [label="_typeComparison 660997"];
3706 [label="SloppyOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 660998"];
3707 [label="true 660999"];
3708 [label="considerName: true 661000"];
3709 [label="false 661001"];
3710 [label="considerExplicitlyImplementedInterfaces: false 661002"];
3711 [label="true 661003"];
3712 [label="considerReturnType: true 661004"];
3713 [label="false 661005"];
3714 [label="considerTypeConstraints: false 661006"];
3715 [label="true 661007"];
3716 [label="considerCallingConvention: true 661008"];
3717 [label="false 661009"];
3718 [label="considerRefKindDifferences: false 661010"];
3719 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 661011"];
3720 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 661012"];
3721 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 661013"];
3722 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 661014"];
3723 [label="param MemberSignatureComparer(bool considerName) 661015"];
3724 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 661016"];
3725 [label="param MemberSignatureComparer(bool considerReturnType) 661017"];
3726 [label="param MemberSignatureComparer(bool considerTypeConstraints) 661018"];
3727 [label="param MemberSignatureComparer(bool considerCallingConvention) 661019"];
3728 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 661020"];
3729 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 661021"];
3730 [label="param MemberSignatureComparer(this) 661022"];
3731 [label="_considerName 661023"];
3732 [label="_considerExplicitlyImplementedInterfaces 661024"];
3733 [label="_considerReturnType 661025"];
3734 [label="_considerTypeConstraints 661026"];
3735 [label="_considerCallingConvention 661027"];
3736 [label="_considerRefKindDifferences 661028"];
3737 [label="_typeComparison 661029"];
3738 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 661030"];
3739 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 661031"];
3740 [label="_considerName 661032"];
3741 [label="_considerExplicitlyImplementedInterfaces 661033"];
3742 [label="_considerReturnType 661034"];
3743 [label="_considerTypeConstraints 661035"];
3744 [label="_considerCallingConvention 661036"];
3745 [label="_considerRefKindDifferences 661037"];
3746 [label="_typeComparison 661038"];
3747 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 661039"];
3748 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 661040"];
3749 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 661041"];
3750 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 661042"];
3751 [label="_typeComparison 661043"];
3752 [label="RuntimeSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 661044"];
3753 [label="true 661045"];
3754 [label="considerName: true 661046"];
3755 [label="false 661047"];
3756 [label="considerExplicitlyImplementedInterfaces: false 661048"];
3757 [label="true 661049"];
3758 [label="considerReturnType: true 661050"];
3759 [label="false 661051"];
3760 [label="considerTypeConstraints: false 661052"];
3761 [label="true 661053"];
3762 [label="considerCallingConvention: true 661054"];
3763 [label="true 661055"];
3764 [label="considerRefKindDifferences: true 661056"];
3765 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 661057"];
3766 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 661058"];
3767 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 661059"];
3768 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 661060"];
3769 [label="param MemberSignatureComparer(bool considerName) 661061"];
3770 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 661062"];
3771 [label="param MemberSignatureComparer(bool considerReturnType) 661063"];
3772 [label="param MemberSignatureComparer(bool considerTypeConstraints) 661064"];
3773 [label="param MemberSignatureComparer(bool considerCallingConvention) 661065"];
3774 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 661066"];
3775 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 661067"];
3776 [label="param MemberSignatureComparer(this) 661068"];
3777 [label="_considerName 661069"];
3778 [label="_considerExplicitlyImplementedInterfaces 661070"];
3779 [label="_considerReturnType 661071"];
3780 [label="_considerTypeConstraints 661072"];
3781 [label="_considerCallingConvention 661073"];
3782 [label="_considerRefKindDifferences 661074"];
3783 [label="_typeComparison 661075"];
3784 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 661076"];
3785 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 661077"];
3786 [label="_considerName 661078"];
3787 [label="_considerExplicitlyImplementedInterfaces 661079"];
3788 [label="_considerReturnType 661080"];
3789 [label="_considerTypeConstraints 661081"];
3790 [label="_considerCallingConvention 661082"];
3791 [label="_considerRefKindDifferences 661083"];
3792 [label="_typeComparison 661084"];
3793 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 661085"];
3794 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 661086"];
3795 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 661087"];
3796 [label="RuntimePlusRefOutSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 661088"];
3797 [label="true 661089"];
3798 [label="considerName: true 661090"];
3799 [label="true 661091"];
3800 [label="considerExplicitlyImplementedInterfaces: true 661092"];
3801 [label="true 661093"];
3802 [label="considerReturnType: true 661094"];
3803 [label="false 661095"];
3804 [label="considerTypeConstraints: false 661096"];
3805 [label="true 661097"];
3806 [label="considerCallingConvention: true 661098"];
3807 [label="false 661099"];
3808 [label="considerRefKindDifferences: false 661100"];
3809 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 661101"];
3810 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 661102"];
3811 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 661103"];
3812 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 661104"];
3813 [label="param MemberSignatureComparer(bool considerName) 661105"];
3814 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 661106"];
3815 [label="param MemberSignatureComparer(bool considerReturnType) 661107"];
3816 [label="param MemberSignatureComparer(bool considerTypeConstraints) 661108"];
3817 [label="param MemberSignatureComparer(bool considerCallingConvention) 661109"];
3818 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 661110"];
3819 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 661111"];
3820 [label="param MemberSignatureComparer(this) 661112"];
3821 [label="_considerName 661113"];
3822 [label="_considerExplicitlyImplementedInterfaces 661114"];
3823 [label="_considerReturnType 661115"];
3824 [label="_considerTypeConstraints 661116"];
3825 [label="_considerCallingConvention 661117"];
3826 [label="_considerRefKindDifferences 661118"];
3827 [label="_typeComparison 661119"];
3828 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 661120"];
3829 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 661121"];
3830 [label="_considerName 661122"];
3831 [label="_considerExplicitlyImplementedInterfaces 661123"];
3832 [label="_considerReturnType 661124"];
3833 [label="_considerTypeConstraints 661125"];
3834 [label="_considerCallingConvention 661126"];
3835 [label="_considerRefKindDifferences 661127"];
3836 [label="_typeComparison 661128"];
3837 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 661129"];
3838 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 661130"];
3839 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 661131"];
3840 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 661132"];
3841 [label="_typeComparison 661133"];
3842 [label="RuntimeImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 661134"];
3843 [label="true 661135"];
3844 [label="considerName: true 661136"];
3845 [label="true 661137"];
3846 [label="considerExplicitlyImplementedInterfaces: true 661138"];
3847 [label="true 661139"];
3848 [label="considerReturnType: true 661140"];
3849 [label="true 661141"];
3850 [label="considerTypeConstraints: true 661142"];
3851 [label="true 661143"];
3852 [label="considerCallingConvention: true 661144"];
3853 [label="true 661145"];
3854 [label="considerRefKindDifferences: true 661146"];
3855 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 661147"];
3856 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 661148"];
3857 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 661149"];
3858 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 661150"];
3859 [label="param MemberSignatureComparer(bool considerName) 661151"];
3860 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 661152"];
3861 [label="param MemberSignatureComparer(bool considerReturnType) 661153"];
3862 [label="param MemberSignatureComparer(bool considerTypeConstraints) 661154"];
3863 [label="param MemberSignatureComparer(bool considerCallingConvention) 661155"];
3864 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 661156"];
3865 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 661157"];
3866 [label="param MemberSignatureComparer(this) 661158"];
3867 [label="_considerName 661159"];
3868 [label="_considerExplicitlyImplementedInterfaces 661160"];
3869 [label="_considerReturnType 661161"];
3870 [label="_considerTypeConstraints 661162"];
3871 [label="_considerCallingConvention 661163"];
3872 [label="_considerRefKindDifferences 661164"];
3873 [label="_typeComparison 661165"];
3874 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 661166"];
3875 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 661167"];
3876 [label="_considerName 661168"];
3877 [label="_considerExplicitlyImplementedInterfaces 661169"];
3878 [label="_considerReturnType 661170"];
3879 [label="_considerTypeConstraints 661171"];
3880 [label="_considerCallingConvention 661172"];
3881 [label="_considerRefKindDifferences 661173"];
3882 [label="_typeComparison 661174"];
3883 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 661175"];
3884 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 661176"];
3885 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 661177"];
3886 [label="CSharpSignatureAndConstraintsAndReturnTypeComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 661178"];
3887 [label="true 661179"];
3888 [label="considerName: true 661180"];
3889 [label="false 661181"];
3890 [label="considerExplicitlyImplementedInterfaces: false 661182"];
3891 [label="true 661183"];
3892 [label="considerReturnType: true 661184"];
3893 [label="false 661185"];
3894 [label="considerTypeConstraints: false 661186"];
3895 [label="true 661187"];
3896 [label="considerCallingConvention: true 661188"];
3897 [label="true 661189"];
3898 [label="considerRefKindDifferences: true 661190"];
3899 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 661191"];
3900 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 661192"];
3901 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 661193"];
3902 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 661194"];
3903 [label="param MemberSignatureComparer(bool considerName) 661195"];
3904 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 661196"];
3905 [label="param MemberSignatureComparer(bool considerReturnType) 661197"];
3906 [label="param MemberSignatureComparer(bool considerTypeConstraints) 661198"];
3907 [label="param MemberSignatureComparer(bool considerCallingConvention) 661199"];
3908 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 661200"];
3909 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 661201"];
3910 [label="param MemberSignatureComparer(this) 661202"];
3911 [label="_considerName 661203"];
3912 [label="_considerExplicitlyImplementedInterfaces 661204"];
3913 [label="_considerReturnType 661205"];
3914 [label="_considerTypeConstraints 661206"];
3915 [label="_considerCallingConvention 661207"];
3916 [label="_considerRefKindDifferences 661208"];
3917 [label="_typeComparison 661209"];
3918 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 661210"];
3919 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 661211"];
3920 [label="_considerName 661212"];
3921 [label="_considerExplicitlyImplementedInterfaces 661213"];
3922 [label="_considerReturnType 661214"];
3923 [label="_considerTypeConstraints 661215"];
3924 [label="_considerCallingConvention 661216"];
3925 [label="_considerRefKindDifferences 661217"];
3926 [label="_typeComparison 661218"];
3927 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 661219"];
3928 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 661220"];
3929 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 661221"];
3930 [label="RetargetedExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 661222"];
3931 [label="false 661223"];
3932 [label="considerName: false 661224"];
3933 [label="false 661225"];
3934 [label="considerExplicitlyImplementedInterfaces: false 661226"];
3935 [label="false 661227"];
3936 [label="considerReturnType: false 661228"];
3937 [label="false 661229"];
3938 [label="considerTypeConstraints: false 661230"];
3939 [label="false 661231"];
3940 [label="considerCallingConvention: false 661232"];
3941 [label="true 661233"];
3942 [label="considerRefKindDifferences: true 661234"];
3943 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 661235"];
3944 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 661236"];
3945 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 661237"];
3946 [label="new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 661238"];
3947 [label="param MemberSignatureComparer(bool considerName) 661239"];
3948 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 661240"];
3949 [label="param MemberSignatureComparer(bool considerReturnType) 661241"];
3950 [label="param MemberSignatureComparer(bool considerTypeConstraints) 661242"];
3951 [label="param MemberSignatureComparer(bool considerCallingConvention) 661243"];
3952 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 661244"];
3953 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 661245"];
3954 [label="param MemberSignatureComparer(this) 661246"];
3955 [label="_considerName 661247"];
3956 [label="_considerExplicitlyImplementedInterfaces 661248"];
3957 [label="_considerReturnType 661249"];
3958 [label="_considerTypeConstraints 661250"];
3959 [label="_considerCallingConvention 661251"];
3960 [label="_considerRefKindDifferences 661252"];
3961 [label="_typeComparison 661253"];
3962 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 661254"];
3963 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 661255"];
3964 [label="_considerName 661256"];
3965 [label="_considerExplicitlyImplementedInterfaces 661257"];
3966 [label="_considerReturnType 661258"];
3967 [label="_considerTypeConstraints 661259"];
3968 [label="_considerCallingConvention 661260"];
3969 [label="_considerRefKindDifferences 661261"];
3970 [label="_typeComparison 661262"];
3971 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 661263"];
3972 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 661264"];
3973 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 661265"];
3974 [label="CrefComparer = new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 661266"];
3975 [label="MemberSignatureComparer.RecordAPISignatureComparer 661267"];
3976 [label="PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 661268"];
3977 [label="s_duplicateRecordMemberSignatureDictionary =\n            PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 661269"];
3978 [label="EmptyComparer.Instance 661270"];
3979 [label="new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 661271"];
3980 [label="s_emptyTypeMembers = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 661272"];
3981 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 661273"];
3982 [label="ReportBadReturn =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 661274"];
3983 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 661275"];
3984 [label="ReportBadParameter =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 661276"];
3985 [label="containingSymbol 661277"];
3986 [label="declaration 661278"];
3987 [label="diagnostics 661279"];
3988 [label="tupleData 661280"];
3989 [label="param SourceNamedTypeSymbol(this) 661281"];
3990 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 661282"];
3991 [label="param SourceMemberContainerTypeSymbol(MergedTypeDeclaration declaration) 661283"];
3992 [label="param SourceMemberContainerTypeSymbol(DiagnosticBag diagnostics) 661284"];
3993 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 661285"];
3994 [label="param SourceMemberContainerTypeSymbol(this) 661286"];
3995 [label="tupleData 661287"];
3996 [label="param SourceMemberContainerTypeSymbol(this) 661288"];
3997 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 661289"];
3998 [label="_lazyTupleData 661290"];
3999 [label="_declModifiers 661291"];
4000 [label="_containingSymbol 661292"];
4001 [label="declaration 661293"];
4002 [label="new DeclaredMembersAndInitializers() 661294"];
4003 [label="param DeclaredMembersAndInitializers(this) 661295"];
4004 [label="HaveIndexers 661296"];
4005 [label="RecordDeclarationWithParameters 661297"];
4006 [label="RecordPrimaryConstructor 661298"];
4007 [label="InstanceInitializersIndexForRecordDeclarationWithParameters 661299"];
4008 [label="IsNullableEnabledForInstanceConstructorsAndFields 661300"];
4009 [label="IsNullableEnabledForStaticConstructorsAndFields 661301"];
4010 [label="UninitializedSentinel = new DeclaredMembersAndInitializers() 661302"];
4011 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 661303"];
4012 [label="_lazyMembersAndInitializers 661304"];
4013 [label="_lazyMembersDictionary 661305"];
4014 [label="_lazyEarlyAttributeDecodingMembersDictionary 661306"];
4015 [label="_lazyTypeMembers 661307"];
4016 [label="_lazyKnownCircularStruct 661308"];
4017 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 661309"];
4018 [label="_lazyContainsExtensionMethods 661310"];
4019 [label="_lazyAnyMemberHasAttributes 661311"];
4020 [label="_containingSymbol 661312"];
4021 [label="this.declaration 661313"];
4022 [label="TypeKind typeKind = declaration.Kind.ToTypeKind(); 661314"];
4023 [label="declaration.Kind.ToTypeKind() 661315"];
4024 [label="param ToTypeKind(this DeclarationKind kind) 661316"];
4025 [label="switch (kind)\n            {\n                case DeclarationKind.Class:\n                case DeclarationKind.Script:\n                case DeclarationKind.ImplicitClass:\n                case DeclarationKind.SimpleProgram:\n                case DeclarationKind.Record:\n                    return TypeKind.Class;\n\n                case DeclarationKind.Submission:\n                    return TypeKind.Submission;\n\n                case DeclarationKind.Delegate:\n                    return TypeKind.Delegate;\n\n                case DeclarationKind.Enum:\n                    return TypeKind.Enum;\n\n                case DeclarationKind.Interface:\n                    return TypeKind.Interface;\n\n                case DeclarationKind.Struct:\n                    return TypeKind.Struct;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 661317"];
4026 [label="return TypeKind.Class; 661318"];
4027 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 661319"];
4028 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 661320"];
4029 [label="MakeModifiers(typeKind, diagnostics) 661321"];
4030 [label="param MakeModifiers(TypeKind typeKind) 661322"];
4031 [label="param MakeModifiers(DiagnosticBag diagnostics) 661323"];
4032 [label="param MakeModifiers(this) 661324"];
4033 [label="this.ContainingSymbol 661325"];
4034 [label="get\n            {\n                return _containingSymbol;\n            } 661326"];
4035 [label="return _containingSymbol; 661327"];
4036 [label="Symbol containingSymbol = this.ContainingSymbol; 661328"];
4037 [label="DeclarationModifiers defaultAccess; 661329"];
4038 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 661330"];
4039 [label="containingSymbol.Kind 661331"];
4040 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 661332"];
4041 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 661333"];
4042 [label="defaultAccess = DeclarationModifiers.Internal; 661334"];
4043 [label="switch (typeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Submission:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe;\n\n                    if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    }\n\n                    break;\n                case TypeKind.Struct:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Ref | DeclarationModifiers.ReadOnly | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Interface:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Delegate:\n                    allowedModifiers |= DeclarationModifiers.Unsafe;\n                    break;\n            } 661335"];
4044 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 661336"];
4045 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 661337"];
4046 [label="this.IsRecord 661338"];
4047 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.Record;\n            } 661339"];
4048 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 661340"];
4049 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 661341"];
4050 [label="if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    } 661342"];
4051 [label="allowedModifiers |= DeclarationModifiers.Static; 661343"];
4052 [label="bool modifierErrors; 661344"];
4053 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 661345"];
4054 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 661346"];
4055 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 661347"];
4056 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 661348"];
4057 [label="MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors) 661349"];
4058 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 661350"];
4059 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 661351"];
4060 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 661352"];
4061 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 661353"];
4062 [label="param MakeAndCheckTypeModifiers(this) 661354"];
4063 [label="modifierErrors = false; 661355"];
4064 [label="var result = DeclarationModifiers.Unset; 661356"];
4065 [label="var partCount = declaration.Declarations.Length; 661357"];
4066 [label="var missingPartial = false; 661358"];
4067 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 661359"];
4068 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 661360"];
4069 [label="var decl = declaration.Declarations[i]; 661361"];
4070 [label="var mods = decl.Modifiers; 661362"];
4071 [label="if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                } 661363"];
4072 [label="if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                } 661364"];
4073 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 661365"];
4074 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 661366"];
4075 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 661367"];
4076 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 661368"];
4077 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 661369"];
4078 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 661370"];
4079 [label="ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors) 661371"];
4080 [label="param CheckModifiers(DeclarationModifiers modifiers) 661372"];
4081 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 661373"];
4082 [label="param CheckModifiers(Location errorLocation) 661374"];
4083 [label="param CheckModifiers(DiagnosticBag diagnostics) 661375"];
4084 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 661376"];
4085 [label="param CheckModifiers(out bool modifierErrors) 661377"];
4086 [label="modifierErrors = false; 661378"];
4087 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 661379"];
4088 [label="DeclarationModifiers result = modifiers & allowedModifiers; 661380"];
4089 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 661381"];
4090 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 661382"];
4091 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 661383"];
4092 [label="return result; 661384"];
4093 [label="if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    } 661385"];
4094 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 661386"];
4095 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 661387"];
4096 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 661388"];
4097 [label="ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false) 661389"];
4098 [label="param CheckAccessibility(DeclarationModifiers modifiers) 661390"];
4099 [label="param CheckAccessibility(Symbol symbol) 661391"];
4100 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 661392"];
4101 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 661393"];
4102 [label="IsValidAccessibility(modifiers) 661394"];
4103 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 661395"];
4104 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 661396"];
4105 [label="return true; 661397"];
4106 [label="symbol.Kind 661398"];
4107 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 661399"];
4108 [label="return SymbolKind.NamedType; 661400"];
4109 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 661401"];
4110 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 661402"];
4111 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 661403"];
4112 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 661404"];
4113 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 661405"];
4114 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 661406"];
4115 [label="return null; 661407"];
4116 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 661408"];
4117 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 661409"];
4118 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 661410"];
4119 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 661411"];
4120 [label="result = mods; 661412"];
4121 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 661413"];
4122 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 661414"];
4123 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 661415"];
4124 [label="this.Name 661416"];
4125 [label="get\n            {\n                return declaration.Name;\n            } 661417"];
4126 [label="return declaration.Name; 661418"];
4127 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 661419"];
4128 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 661420"];
4129 [label="return result; 661421"];
4130 [label="(type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 661422"];
4131 [label="s_hasInvalidTypeParameterFunc =\n            (type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 661423"];
4132 [label="this.CheckUnsafeModifier(mods, diagnostics); 661424"];
4133 [label="this.CheckUnsafeModifier(mods, diagnostics); 661425"];
4134 [label="this.CheckUnsafeModifier(mods, diagnostics); 661426"];
4135 [label="this.CheckUnsafeModifier(mods, diagnostics) 661427"];
4136 [label="param CheckUnsafeModifier(this Symbol symbol) 661428"];
4137 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 661429"];
4138 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 661430"];
4139 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 661431"];
4140 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 661432"];
4141 [label="symbol.Locations 661433"];
4142 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 661434"];
4143 [label="return declaration.NameLocations.Cast<SourceLocation, Location>(); 661435"];
4144 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 661436"];
4145 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 661437"];
4146 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 661438"];
4147 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 661439"];
4148 [label="param CheckUnsafeModifier(this Symbol symbol) 661440"];
4149 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 661441"];
4150 [label="param CheckUnsafeModifier(Location errorLocation) 661442"];
4151 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 661443"];
4152 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 661444"];
4153 [label="this.CheckUnsafeModifier(mods, diagnostics); 661445"];
4154 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 661446"];
4155 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 661447"];
4156 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 661448"];
4157 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 661449"];
4158 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 661450"];
4159 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 661451"];
4160 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 661452"];
4161 [label="return mods; 661453"];
4162 [label="foreach (var singleDeclaration in declaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 661454"];
4163 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 661455"];
4164 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 661456"];
4165 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 661457"];
4166 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 661458"];
4167 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 661459"];
4168 [label="_declModifiers 661460"];
4169 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 661461"];
4170 [label="access == (int)DeclarationModifiers.Public 661462"];
4171 [label="MakeSpecialType() 661463"];
4172 [label="param MakeSpecialType(this) 661464"];
4173 [label="ContainingSymbol 661465"];
4174 [label="get\n            {\n                return _containingSymbol;\n            } 661466"];
4175 [label="return _containingSymbol; 661467"];
4176 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 661468"];
4177 [label="ContainingSymbol.Kind 661469"];
4178 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 661470"];
4179 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 661471"];
4180 [label="ContainingSymbol 661472"];
4181 [label="get\n            {\n                return _containingSymbol;\n            } 661473"];
4182 [label="return _containingSymbol; 661474"];
4183 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 661475"];
4184 [label="ContainingSymbol.ContainingAssembly 661476"];
4185 [label="=> _module.ContainingAssembly 661477"];
4186 [label="_module.ContainingAssembly 661478"];
4187 [label="get\n            {\n                return _assemblySymbol;\n            } 661479"];
4188 [label="return _assemblySymbol; 661480"];
4189 [label="ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 661481"];
4190 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 661482"];
4191 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 661483"];
4192 [label="return SpecialType.None; 661484"];
4193 [label="0 661485"];
4194 [label="SpecialTypeOffset = 0 661486"];
4195 [label="6 661487"];
4196 [label="SpecialTypeSize = 6 661488"];
4197 [label="SpecialTypeOffset + SpecialTypeSize 661489"];
4198 [label="ManagedKindOffset = SpecialTypeOffset + SpecialTypeSize 661490"];
4199 [label="2 661491"];
4200 [label="ManagedKindSize = 2 661492"];
4201 [label="ManagedKindOffset + ManagedKindSize 661493"];
4202 [label="FieldDefinitionsNotedOffset = ManagedKindOffset + ManagedKindSize 661494"];
4203 [label="1 661495"];
4204 [label="FieldDefinitionsNotedSize = 1 661496"];
4205 [label="FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 661497"];
4206 [label="FlattenedMembersIsSortedOffset = FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 661498"];
4207 [label="1 661499"];
4208 [label="FlattenedMembersIsSortedSize = 1 661500"];
4209 [label="FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 661501"];
4210 [label="TypeKindOffset = FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 661502"];
4211 [label="4 661503"];
4212 [label="TypeKindSize = 4 661504"];
4213 [label="TypeKindOffset + TypeKindSize 661505"];
4214 [label="NullableContextOffset = TypeKindOffset + TypeKindSize 661506"];
4215 [label="3 661507"];
4216 [label="NullableContextSize = 3 661508"];
4217 [label="1 661509"];
4218 [label="1 << SpecialTypeSize 661510"];
4219 [label="1 661511"];
4220 [label="(1 << SpecialTypeSize) - 1 661512"];
4221 [label="SpecialTypeMask = (1 << SpecialTypeSize) - 1 661513"];
4222 [label="1 661514"];
4223 [label="1 << ManagedKindSize 661515"];
4224 [label="1 661516"];
4225 [label="(1 << ManagedKindSize) - 1 661517"];
4226 [label="ManagedKindMask = (1 << ManagedKindSize) - 1 661518"];
4227 [label="1 661519"];
4228 [label="1 << TypeKindSize 661520"];
4229 [label="1 661521"];
4230 [label="(1 << TypeKindSize) - 1 661522"];
4231 [label="TypeKindMask = (1 << TypeKindSize) - 1 661523"];
4232 [label="1 661524"];
4233 [label="1 << NullableContextSize 661525"];
4234 [label="1 661526"];
4235 [label="(1 << NullableContextSize) - 1 661527"];
4236 [label="NullableContextMask = (1 << NullableContextSize) - 1 661528"];
4237 [label="1 661529"];
4238 [label="1 << FieldDefinitionsNotedOffset 661530"];
4239 [label="FieldDefinitionsNotedBit = 1 << FieldDefinitionsNotedOffset 661531"];
4240 [label="1 661532"];
4241 [label="1 << FlattenedMembersIsSortedOffset 661533"];
4242 [label="FlattenedMembersIsSortedBit = 1 << FlattenedMembersIsSortedOffset 661534"];
4243 [label="Debug.Assert(EnumUtilities.ContainsAllValues<SpecialType>(SpecialTypeMask)); 661535"];
4244 [label="Debug.Assert(EnumUtilities.ContainsAllValues<NullableContextKind>(NullableContextMask)); 661536"];
4245 [label="_flags = new Flags(specialType, typeKind); 661537"];
4246 [label="_flags = new Flags(specialType, typeKind); 661538"];
4247 [label="_flags = new Flags(specialType, typeKind); 661539"];
4248 [label="new Flags(specialType, typeKind) 661540"];
4249 [label="param Flags(SpecialType specialType) 661541"];
4250 [label="param Flags(TypeKind typeKind) 661542"];
4251 [label="param Flags(this) 661543"];
4252 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 661544"];
4253 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 661545"];
4254 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 661546"];
4255 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 661547"];
4256 [label="_flags = specialTypeInt | typeKindInt; 661548"];
4257 [label="_flags 661549"];
4258 [label="_flags 661550"];
4259 [label="this.ContainingType 661551"];
4260 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 661552"];
4261 [label="return _containingSymbol as NamedTypeSymbol; 661553"];
4262 [label="var containingType = this.ContainingType; 661554"];
4263 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 661555"];
4264 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 661556"];
4265 [label="state.NotePartComplete(CompletionPart.TypeArguments); 661557"];
4266 [label="state.NotePartComplete(CompletionPart.TypeArguments) 661558"];
4267 [label="param NotePartComplete(CompletionPart part) 661559"];
4268 [label="param NotePartComplete(this) 661560"];
4269 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 661561"];
4270 [label="_lazyCustomAttributesBag 661562"];
4271 [label="_lazyDocComment 661563"];
4272 [label="_lazyExpandedDocComment 661564"];
4273 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 661565"];
4274 [label="_lazyDeclaredBases 661566"];
4275 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 661567"];
4276 [label="_lazyEnumValueField 661568"];
4277 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 661569"];
4278 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 661570"];
4279 [label="containingSymbol.Kind 661571"];
4280 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 661572"];
4281 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 661573"];
4282 [label="get\n            {\n                return declaration.Name;\n            } 661574"];
4283 [label="return declaration.Name; 661575"];
4284 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 661576"];
4285 [label="members 661577"];
4286 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 661578"];
4287 [label="return SymbolKind.NamedType; 661579"];
4288 [label="param CheckMembers(NamespaceSymbol @namespace) 661580"];
4289 [label="param CheckMembers(DiagnosticBag diagnostics) 661581"];
4290 [label="var memberOfArity = new Symbol[10]; 661582"];
4291 [label="MergedNamespaceSymbol mergedAssemblyNamespace = null; 661583"];
4292 [label="@namespace.ContainingAssembly 661584"];
4293 [label="=> _module.ContainingAssembly 661585"];
4294 [label="_module.ContainingAssembly 661586"];
4295 [label="get\n            {\n                return _assemblySymbol;\n            } 661587"];
4296 [label="return _assemblySymbol; 661588"];
4297 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 661589"];
4298 [label="@namespace.ContainingAssembly.Modules 661590"];
4299 [label="get\n            {\n                return _modules;\n            } 661591"];
4300 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 661592"];
4301 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 661593"];
4302 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 661594"];
4303 [label="var nts = symbol as NamedTypeSymbol; 661595"];
4304 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 661596"];
4305 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 661597"];
4306 [label="((object)nts != null) 661598"];
4307 [label="nts.Arity 661599"];
4308 [label="get\n            {\n                return declaration.Arity;\n            } 661600"];
4309 [label="return declaration.Arity; 661601"];
4310 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 661602"];
4311 [label="var other = memberOfArity[arity]; 661603"];
4312 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 661604"];
4313 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 661605"];
4314 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 661606"];
4315 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 661607"];
4316 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 661608"];
4317 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 661609"];
4318 [label="memberOfArity[arity] 661610"];
4319 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 661611"];
4320 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 661612"];
4321 [label="nts.DeclaredAccessibility 661613"];
4322 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 661614"];
4323 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 661615"];
4324 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 661616"];
4325 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 661617"];
4326 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 661618"];
4327 [label="return Accessibility.Public; 661619"];
4328 [label="Accessibility declaredAccessibility = nts.DeclaredAccessibility; 661620"];
4329 [label="if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        } 661621"];
4330 [label="this.Kind 661622"];
4331 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 661623"];
4332 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 661624"];
4333 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 661625"];
4334 [label="RegisterDeclaredCorTypes() 661626"];
4335 [label="param RegisterDeclaredCorTypes(this) 661627"];
4336 [label="ContainingAssembly 661628"];
4337 [label="=> _module.ContainingAssembly 661629"];
4338 [label="_module.ContainingAssembly 661630"];
4339 [label="get\n            {\n                return _assemblySymbol;\n            } 661631"];
4340 [label="return _assemblySymbol; 661632"];
4341 [label="AssemblySymbol containingAssembly = ContainingAssembly; 661633"];
4342 [label="containingAssembly.KeepLookingForDeclaredSpecialTypes 661634"];
4343 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 661635"];
4344 [label="if (containingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                // Register newly declared COR types\n                foreach (var array in _nameToMembersMap.Values)\n                {\n                    foreach (var member in array)\n                    {\n                        var type = member as NamedTypeSymbol;\n\n                        if ((object)type != null && type.SpecialType != SpecialType.None)\n                        {\n                            containingAssembly.RegisterDeclaredSpecialType(type);\n\n                            if (!containingAssembly.KeepLookingForDeclaredSpecialTypes)\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n            } 661636"];
4345 [label="RegisterDeclaredCorTypes(); 661637"];
4346 [label="Debug.Assert(wasSetThisThread); 661638"];
4347 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 661639"];
4348 [label="GetTypesFromMemberMap(GetNameToMembersMap()) 661640"];
4349 [label="param GetTypesFromMemberMap(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> map) 661641"];
4350 [label="var dictionary = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(StringOrdinalComparer.Instance); 661642"];
4351 [label="foreach (var kvp in map)\n            {\n                ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value;\n\n                bool hasType = false;\n                bool hasNamespace = false;\n\n                foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                }\n            } 661643"];
4352 [label="ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value; 661644"];
4353 [label="bool hasType = false; 661645"];
4354 [label="bool hasNamespace = false; 661646"];
4355 [label="foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                } 661647"];
4356 [label="symbol.Kind 661648"];
4357 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 661649"];
4358 [label="if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    } 661650"];
4359 [label="hasType = true; 661651"];
4360 [label="if (hasNamespace)\n                        {\n                            break;\n                        } 661652"];
4361 [label="if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                } 661653"];
4362 [label="if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    } 661654"];
4363 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 661655"];
4364 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 661656"];
4365 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 661657"];
4366 [label="return dictionary; 661658"];
4367 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 661659"];
4368 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 661660"];
4369 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 661661"];
4370 [label="return _nameToTypeMembersMap; 661662"];
4371 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 661663"];
4372 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 661664"];
4373 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 661665"];
4374 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 661666"];
4375 [label="this.GetNameToTypeMembersMap().TryGetValue(name, out members) 661667"];
4376 [label="var varX = classA.GetMembers('x').First() as FieldSymbol; 661668"];
4377 [label="classA.GetMembers('x') 661669"];
4378 [label="param GetMembers(string name) 661670"];
4379 [label="param GetMembers(this) 661671"];
4380 [label="ImmutableArray<Symbol> members; 661672"];
4381 [label="members 661673"];
4382 [label="GetMembersByName() 661674"];
4383 [label="param GetMembersByName(this) 661675"];
4384 [label="if (this.state.HasComplete(CompletionPart.Members))\n            {\n                return _lazyMembersDictionary!;\n            } 661676"];
4385 [label="this.state.HasComplete(CompletionPart.Members) 661677"];
4386 [label="param HasComplete(CompletionPart part) 661678"];
4387 [label="param HasComplete(this) 661679"];
4388 [label="return (_completeParts & (int)part) == (int)part; 661680"];
4389 [label="GetMembersByNameSlow() 661681"];
4390 [label="param GetMembersByNameSlow(this) 661682"];
4391 [label="if (_lazyMembersDictionary == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                var membersDictionary = MakeAllMembers(diagnostics);\n\n                if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                }\n\n                diagnostics.Free();\n            } 661683"];
4392 [label="if (_lazyMembersDictionary == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                var membersDictionary = MakeAllMembers(diagnostics);\n\n                if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                }\n\n                diagnostics.Free();\n            } 661684"];
4393 [label="var diagnostics = DiagnosticBag.GetInstance(); 661685"];
4394 [label="var membersDictionary = MakeAllMembers(diagnostics); 661686"];
4395 [label="MakeAllMembers(diagnostics) 661687"];
4396 [label="param MakeAllMembers(DiagnosticBag diagnostics) 661688"];
4397 [label="param MakeAllMembers(this) 661689"];
4398 [label="Dictionary<string, ImmutableArray<Symbol>> membersByName; 661690"];
4399 [label="GetMembersAndInitializers() 661691"];
4400 [label="param GetMembersAndInitializers(this) 661692"];
4401 [label="var membersAndInitializers = _lazyMembersAndInitializers; 661693"];
4402 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 661694"];
4403 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 661695"];
4404 [label="var diagnostics = DiagnosticBag.GetInstance(); 661696"];
4405 [label="membersAndInitializers = BuildMembersAndInitializers(diagnostics); 661697"];
4406 [label="BuildMembersAndInitializers(diagnostics) 661698"];
4407 [label="param BuildMembersAndInitializers(DiagnosticBag diagnostics) 661699"];
4408 [label="param BuildMembersAndInitializers(this) 661700"];
4409 [label="getDeclaredMembersAndInitializers() 661701"];
4410 [label="DeclaredMembersAndInitializers? getDeclaredMembersAndInitializers()\n            {\n                var declaredMembersAndInitializers = _lazyDeclaredMembersAndInitializers;\n                if (declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    return declaredMembersAndInitializers;\n                }\n\n                if (Volatile.Read(ref _lazyMembersAndInitializers) is not null)\n                {\n                    // We're previously computed declared members and already cleared them out\n                    // No need to compute them again\n                    return null;\n                }\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics);\n\n                var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel);\n                if (alreadyKnown != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    diagnostics.Free();\n                    return alreadyKnown;\n                }\n\n                AddDeclarationDiagnostics(diagnostics);\n                diagnostics.Free();\n\n                return declaredMembersAndInitializers!;\n            } 661702"];
4411 [label="var declaredMembersAndInitializers = _lazyDeclaredMembersAndInitializers; 661703"];
4412 [label="if (declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    return declaredMembersAndInitializers;\n                } 661704"];
4413 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) is not null)\n                {\n                    // We're previously computed declared members and already cleared them out\n                    // No need to compute them again\n                    return null;\n                } 661705"];
4414 [label="var diagnostics = DiagnosticBag.GetInstance(); 661706"];
4415 [label="declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics); 661707"];
4416 [label="buildDeclaredMembersAndInitializers(diagnostics) 661708"];
4417 [label="DeclaredMembersAndInitializers? buildDeclaredMembersAndInitializers(DiagnosticBag diagnostics)\n            {\n                var builder = new DeclaredMembersAndInitializersBuilder();\n                AddDeclaredNontypeMembers(builder, diagnostics);\n\n                switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                }\n\n                if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                }\n\n                if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                }\n\n                return builder.ToReadOnlyAndFree();\n            } 661709"];
4418 [label="DeclaredMembersAndInitializers? buildDeclaredMembersAndInitializers(DiagnosticBag diagnostics)\n            {\n                var builder = new DeclaredMembersAndInitializersBuilder();\n                AddDeclaredNontypeMembers(builder, diagnostics);\n\n                switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                }\n\n                if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                }\n\n                if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                }\n\n                return builder.ToReadOnlyAndFree();\n            } 661710"];
4419 [label="var builder = new DeclaredMembersAndInitializersBuilder(); 661711"];
4420 [label="new DeclaredMembersAndInitializersBuilder() 661712"];
4421 [label="param DeclaredMembersAndInitializersBuilder(this) 661713"];
4422 [label="ArrayBuilder<Symbol>.GetInstance() 661714"];
4423 [label="NonTypeMembers = ArrayBuilder<Symbol>.GetInstance() 661715"];
4424 [label="ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 661716"];
4425 [label="StaticInitializers = ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 661717"];
4426 [label="ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 661718"];
4427 [label="InstanceInitializers = ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 661719"];
4428 [label="HaveIndexers 661720"];
4429 [label="RecordDeclarationWithParameters 661721"];
4430 [label="RecordPrimaryConstructor 661722"];
4431 [label="1 661723"];
4432 [label="InstanceInitializersIndexForRecordDeclarationWithParameters = -1 661724"];
4433 [label="IsNullableEnabledForInstanceConstructorsAndFields 661725"];
4434 [label="IsNullableEnabledForStaticConstructorsAndFields 661726"];
4435 [label="AddDeclaredNontypeMembers(builder, diagnostics); 661727"];
4436 [label="AddDeclaredNontypeMembers(builder, diagnostics); 661728"];
4437 [label="AddDeclaredNontypeMembers(builder, diagnostics) 661729"];
4438 [label="param AddDeclaredNontypeMembers(DeclaredMembersAndInitializersBuilder builder) 661730"];
4439 [label="param AddDeclaredNontypeMembers(DiagnosticBag diagnostics) 661731"];
4440 [label="param AddDeclaredNontypeMembers(this) 661732"];
4441 [label="foreach (var decl in this.declaration.Declarations)\n            {\n                if (!decl.HasAnyNontypeMembers)\n                {\n                    continue;\n                }\n\n                if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                }\n\n                var syntax = decl.SyntaxReference.GetSyntax();\n\n                switch (syntax.Kind())\n                {\n                    case SyntaxKind.EnumDeclaration:\n                        AddEnumMembers(builder, (EnumDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.DelegateDeclaration:\n                        SourceDelegateMethodSymbol.AddDelegateMembers(this, builder.NonTypeMembers, (DelegateDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.NamespaceDeclaration:\n                        // The members of a global anonymous type is in a syntax tree of a namespace declaration or a compilation unit.\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((NamespaceDeclarationSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.CompilationUnit:\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((CompilationUnitSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                        var typeDecl = (TypeDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.RecordDeclaration:\n                        var recordDecl = (RecordDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder,\n                            instanceInitializers: noteRecordParameters(recordDecl, builder, diagnostics),\n                            recordDecl.Members,\n                            diagnostics);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(syntax.Kind());\n                }\n            } 661733"];
4442 [label="if (!decl.HasAnyNontypeMembers)\n                {\n                    continue;\n                } 661734"];
4443 [label="if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                } 661735"];
4444 [label="var syntax = decl.SyntaxReference.GetSyntax(); 661736"];
4445 [label="switch (syntax.Kind())\n                {\n                    case SyntaxKind.EnumDeclaration:\n                        AddEnumMembers(builder, (EnumDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.DelegateDeclaration:\n                        SourceDelegateMethodSymbol.AddDelegateMembers(this, builder.NonTypeMembers, (DelegateDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.NamespaceDeclaration:\n                        // The members of a global anonymous type is in a syntax tree of a namespace declaration or a compilation unit.\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((NamespaceDeclarationSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.CompilationUnit:\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((CompilationUnitSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                        var typeDecl = (TypeDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.RecordDeclaration:\n                        var recordDecl = (RecordDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder,\n                            instanceInitializers: noteRecordParameters(recordDecl, builder, diagnostics),\n                            recordDecl.Members,\n                            diagnostics);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(syntax.Kind());\n                } 661737"];
4446 [label="var typeDecl = (TypeDeclarationSyntax)syntax; 661738"];
4447 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics); 661739"];
4448 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics); 661740"];
4449 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics); 661741"];
4450 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics); 661742"];
4451 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics) 661743"];
4452 [label="param AddNonTypeMembers(DeclaredMembersAndInitializersBuilder builder) 661744"];
4453 [label="param AddNonTypeMembers(ArrayBuilder<FieldOrPropertyInitializer>? instanceInitializers) 661745"];
4454 [label="param AddNonTypeMembers(SyntaxList<MemberDeclarationSyntax> members) 661746"];
4455 [label="param AddNonTypeMembers(DiagnosticBag diagnostics) 661747"];
4456 [label="param AddNonTypeMembers(this) 661748"];
4457 [label="if (members.Count == 0)\n            {\n                AddInitializers(builder.InstanceInitializers, instanceInitializers);\n                return;\n            } 661749"];
4458 [label="if (members.Count == 0)\n            {\n                AddInitializers(builder.InstanceInitializers, instanceInitializers);\n                return;\n            } 661750"];
4459 [label="var firstMember = members[0]; 661751"];
4460 [label="var firstMember = members[0]; 661752"];
4461 [label="var bodyBinder = this.GetBinder(firstMember); 661753"];
4462 [label="this.GetBinder(firstMember) 661754"];
4463 [label="param GetBinder(CSharpSyntaxNode syntaxNode) 661755"];
4464 [label="param GetBinder(this) 661756"];
4465 [label="this.DeclaringCompilation 661757"];
4466 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 661758"];
4467 [label="this.Kind 661759"];
4468 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 661760"];
4469 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 661761"];
4470 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 661762"];
4471 [label="this.ContainingSymbol 661763"];
4472 [label="get\n            {\n                return _containingSymbol;\n            } 661764"];
4473 [label="return _containingSymbol; 661765"];
4474 [label="var container = this.ContainingSymbol; 661766"];
4475 [label="return (object)container != null ? container.ContainingModule : null; 661767"];
4476 [label="return (object)container != null ? container.ContainingModule : null; 661768"];
4477 [label="(object)container != null 661769"];
4478 [label="container.ContainingModule 661770"];
4479 [label="return this.DeclaringCompilation.GetBinder(syntaxNode); 661771"];
4480 [label="return this.DeclaringCompilation.GetBinder(syntaxNode); 661772"];
4481 [label="this.DeclaringCompilation.GetBinder(syntaxNode) 661773"];
4482 [label="param GetBinder(CSharpSyntaxNode syntax) 661774"];
4483 [label="param GetBinder(this) 661775"];
4484 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 661776"];
4485 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 661777"];
4486 [label="GetBinderFactory(syntax.SyntaxTree) 661778"];
4487 [label="param GetBinderFactory(SyntaxTree syntaxTree) 661779"];
4488 [label="param GetBinderFactory(bool ignoreAccessibility = false) 661780"];
4489 [label="param GetBinderFactory(this) 661781"];
4490 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 661782"];
4491 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 661783"];
4492 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 661784"];
4493 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 661785"];
4494 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 661786"];
4495 [label="param GetBinderFactory(SyntaxTree syntaxTree) 661787"];
4496 [label="param GetBinderFactory(bool ignoreAccessibility) 661788"];
4497 [label="param GetBinderFactory(ref WeakReference<BinderFactory>[]? cachedBinderFactories) 661789"];
4498 [label="param GetBinderFactory(this) 661790"];
4499 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 661791"];
4500 [label="ignoreAccessibility 661792"];
4501 [label="_binderFactories 661793"];
4502 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 661794"];
4503 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 661795"];
4504 [label="var treeNum = GetSyntaxTreeOrdinal(syntaxTree); 661796"];
4505 [label="GetSyntaxTreeOrdinal(syntaxTree) 661797"];
4506 [label="param GetSyntaxTreeOrdinal(SyntaxTree tree) 661798"];
4507 [label="param GetSyntaxTreeOrdinal(this) 661799"];
4508 [label="Debug.Assert(this.ContainsSyntaxTree(tree)); 661800"];
4509 [label="this.ContainsSyntaxTree(tree) 661801"];
4510 [label="param ContainsSyntaxTree(SyntaxTree? syntaxTree) 661802"];
4511 [label="param ContainsSyntaxTree(this) 661803"];
4512 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 661804"];
4513 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 661805"];
4514 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 661806"];
4515 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 661807"];
4516 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 661808"];
4517 [label="return _syntaxAndDeclarations.GetLazyState().OrdinalMap[tree]; 661809"];
4518 [label="WeakReference<BinderFactory>[]? binderFactories = cachedBinderFactories; 661810"];
4519 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 661811"];
4520 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 661812"];
4521 [label="this.SyntaxTrees 661813"];
4522 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 661814"];
4523 [label="binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length]; 661815"];
4524 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 661816"];
4525 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 661817"];
4526 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 661818"];
4527 [label="BinderFactory? previousFactory; 661819"];
4528 [label="var previousWeakReference = binderFactories[treeNum]; 661820"];
4529 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 661821"];
4530 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 661822"];
4531 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 661823"];
4532 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 661824"];
4533 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 661825"];
4534 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 661826"];
4535 [label="param AddNewFactory(SyntaxTree syntaxTree) 661827"];
4536 [label="param AddNewFactory(bool ignoreAccessibility) 661828"];
4537 [label="param AddNewFactory([NotNull] ref WeakReference<BinderFactory>? slot) 661829"];
4538 [label="param AddNewFactory(this) 661830"];
4539 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 661831"];
4540 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 661832"];
4541 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 661833"];
4542 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 661834"];
4543 [label="new BinderFactory(this, syntaxTree, ignoreAccessibility) 661835"];
4544 [label="param BinderFactory(CSharpCompilation compilation) 661836"];
4545 [label="param BinderFactory(SyntaxTree syntaxTree) 661837"];
4546 [label="param BinderFactory(bool ignoreAccessibility) 661838"];
4547 [label="param BinderFactory(this) 661839"];
4548 [label="_binderCache 661840"];
4549 [label="_compilation 661841"];
4550 [label="_syntaxTree 661842"];
4551 [label="_buckStopsHereBinder 661843"];
4552 [label="_ignoreAccessibility 661844"];
4553 [label="_binderFactoryVisitorPool 661845"];
4554 [label="_compilation 661846"];
4555 [label="_syntaxTree 661847"];
4556 [label="_ignoreAccessibility 661848"];
4557 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 661849"];
4558 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 661850"];
4559 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 661851"];
4560 [label="_binderFactoryVisitorPool 661852"];
4561 [label="_binderCache = new ConcurrentCache<BinderCacheKey, Binder>(50); 661853"];
4562 [label="_binderCache 661854"];
4563 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 661855"];
4564 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 661856"];
4565 [label="new BuckStopsHereBinder(compilation) 661857"];
4566 [label="param BuckStopsHereBinder(CSharpCompilation compilation) 661858"];
4567 [label="param BuckStopsHereBinder(this) 661859"];
4568 [label="0 661860"];
4569 [label="ExternalScope = 0 661861"];
4570 [label="1 661862"];
4571 [label="TopLevelScope = 1 661863"];
4572 [label="2 661864"];
4573 [label="ValueKindInsignificantBits = 2 661865"];
4574 [label="ValueKindSignificantBitsMask = unchecked((BindValueKind)~((1 << ValueKindInsignificantBits) - 1)) 661866"];
4575 [label="property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 661867"];
4576 [label="s_isIndexedPropertyWithNonOptionalArguments = property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 661868"];
4577 [label="globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted 661869"];
4578 [label="memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType 661870"];
4579 [label="SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 661871"];
4580 [label="miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 661872"];
4581 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 661873"];
4582 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 661874"];
4583 [label="s_propertyGroupFormat =\n            new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 661875"];
4584 [label="10 661876"];
4585 [label="MaxParameterListsForErrorRecovery = 10 661877"];
4586 [label="'<>h__TransparentIdentifier' 661878"];
4587 [label="transparentIdentifierPrefix = '<>h__TransparentIdentifier' 661879"];
4588 [label="s => (MethodSymbol)s 661880"];
4589 [label="s_toMethodSymbolFunc = s => (MethodSymbol)s 661881"];
4590 [label="s => (PropertySymbol)s 661882"];
4591 [label="s_toPropertySymbolFunc = s => (PropertySymbol)s 661883"];
4592 [label="compilation 661884"];
4593 [label="param BuckStopsHereBinder(this) 661885"];
4594 [label="param Binder(CSharpCompilation compilation) 661886"];
4595 [label="param Binder(this) 661887"];
4596 [label="internal CSharpCompilation Compilation { get; } 661888"];
4597 [label="Flags 661889"];
4598 [label="protected internal Binder? Next { get; } 661890"];
4599 [label="_lazyConversions 661891"];
4600 [label="_lazyOverloadResolution 661892"];
4601 [label="RoslynDebug.Assert(compilation != null); 661893"];
4602 [label="RoslynDebug.Assert(compilation != null); 661894"];
4603 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 661895"];
4604 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 661896"];
4605 [label="compilation.Options 661897"];
4606 [label="get\n            {\n                return _options;\n            } 661898"];
4607 [label="return _options; 661899"];
4608 [label="this.Flags = compilation.Options.TopLevelBinderFlags; 661900"];
4609 [label="this.Flags 661901"];
4610 [label="this.Compilation 661902"];
4611 [label="_buckStopsHereBinder 661903"];
4612 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 661904"];
4613 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 661905"];
4614 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 661906"];
4615 [label="BinderFactory? previousFactory; 661907"];
4616 [label="WeakReference<BinderFactory>? previousWeakReference = slot; 661908"];
4617 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 661909"];
4618 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 661910"];
4619 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 661911"];
4620 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 661912"];
4621 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 661913"];
4622 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 661914"];
4623 [label="return newFactory; 661915"];
4624 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 661916"];
4625 [label="GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax) 661917"];
4626 [label="param GetBinder(SyntaxNode node) 661918"];
4627 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 661919"];
4628 [label="param GetBinder(Symbol memberOpt = null) 661920"];
4629 [label="param GetBinder(this) 661921"];
4630 [label="int position = node.SpanStart; 661922"];
4631 [label="InScript 661923"];
4632 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 661924"];
4633 [label="return _syntaxTree.Options.Kind == SourceCodeKind.Script; 661925"];
4634 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 661926"];
4635 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 661927"];
4636 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 661928"];
4637 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 661929"];
4638 [label="node = node.Parent; 661930"];
4639 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 661931"];
4640 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 661932"];
4641 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 661933"];
4642 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 661934"];
4643 [label="GetBinder(node, position, memberDeclarationOpt, memberOpt) 661935"];
4644 [label="param GetBinder(SyntaxNode node) 661936"];
4645 [label="param GetBinder(int position) 661937"];
4646 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 661938"];
4647 [label="param GetBinder(Symbol memberOpt = null) 661939"];
4648 [label="param GetBinder(this) 661940"];
4649 [label="Debug.Assert(node != null); 661941"];
4650 [label="Debug.Assert(node != null); 661942"];
4651 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 661943"];
4652 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 661944"];
4653 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 661945"];
4654 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 661946"];
4655 [label="param BinderFactoryVisitor(BinderFactory factory) 661947"];
4656 [label="param BinderFactoryVisitor(this) 661948"];
4657 [label="param BinderFactoryVisitor(this) 661949"];
4658 [label="_position 661950"];
4659 [label="_memberDeclarationOpt 661951"];
4660 [label="_memberOpt 661952"];
4661 [label="_factory 661953"];
4662 [label="_factory 661954"];
4663 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 661955"];
4664 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 661956"];
4665 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 661957"];
4666 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 661958"];
4667 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt) 661959"];
4668 [label="param Initialize(int position) 661960"];
4669 [label="param Initialize(CSharpSyntaxNode memberDeclarationOpt) 661961"];
4670 [label="param Initialize(Symbol memberOpt) 661962"];
4671 [label="param Initialize(this) 661963"];
4672 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 661964"];
4673 [label="memberDeclarationOpt == null 661965"];
4674 [label="param ==(Symbol left) 661966"];
4675 [label="param ==(Symbol right) 661967"];
4676 [label="if (right is null)\n            {\n                return left is null;\n            } 661968"];
4677 [label="return left is null; 661969"];
4678 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 661970"];
4679 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 661971"];
4680 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 661972"];
4681 [label="_position 661973"];
4682 [label="_memberDeclarationOpt 661974"];
4683 [label="_memberOpt 661975"];
4684 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 661976"];
4685 [label="Binder result = visitor.Visit(node); 661977"];
4686 [label="visitor.Visit(node) 661978"];
4687 [label="param Visit(SyntaxNode node) 661979"];
4688 [label="param Visit(this) 661980"];
4689 [label="return VisitCore(node); 661981"];
4690 [label="VisitCore(node) 661982"];
4691 [label="param VisitCore(SyntaxNode node) 661983"];
4692 [label="param VisitCore(this) 661984"];
4693 [label="return ((CSharpSyntaxNode)node).Accept(this); 661985"];
4694 [label="return ((CSharpSyntaxNode)node).Accept(this); 661986"];
4695 [label="return ((CSharpSyntaxNode)node).Accept(this); 661987"];
4696 [label="param VisitClassDeclaration(ClassDeclarationSyntax node) 661988"];
4697 [label="param VisitClassDeclaration(this) 661989"];
4698 [label="return VisitTypeDeclarationCore(node); 661990"];
4699 [label="VisitTypeDeclarationCore(node) 661991"];
4700 [label="param VisitTypeDeclarationCore(TypeDeclarationSyntax parent) 661992"];
4701 [label="param VisitTypeDeclarationCore(this) 661993"];
4702 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 661994"];
4703 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 661995"];
4704 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 661996"];
4705 [label="NodeUsage extraInfo = NodeUsage.Normal; 661997"];
4706 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 661998"];
4707 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 661999"];
4708 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 662000"];
4709 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 662001"];
4710 [label="extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters; 662002"];
4711 [label="return VisitTypeDeclarationCore(parent, extraInfo); 662003"];
4712 [label="return VisitTypeDeclarationCore(parent, extraInfo); 662004"];
4713 [label="VisitTypeDeclarationCore(parent, extraInfo) 662005"];
4714 [label="param VisitTypeDeclarationCore(TypeDeclarationSyntax parent) 662006"];
4715 [label="param VisitTypeDeclarationCore(NodeUsage extraInfo) 662007"];
4716 [label="param VisitTypeDeclarationCore(this) 662008"];
4717 [label="var key = CreateBinderCacheKey(parent, extraInfo); 662009"];
4718 [label="var key = CreateBinderCacheKey(parent, extraInfo); 662010"];
4719 [label="CreateBinderCacheKey(parent, extraInfo) 662011"];
4720 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 662012"];
4721 [label="param CreateBinderCacheKey(NodeUsage usage) 662013"];
4722 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 662014"];
4723 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 662015"];
4724 [label="return new BinderCacheKey(node, usage); 662016"];
4725 [label="return new BinderCacheKey(node, usage); 662017"];
4726 [label="return new BinderCacheKey(node, usage); 662018"];
4727 [label="new BinderCacheKey(node, usage) 662019"];
4728 [label="param BinderCacheKey(CSharpSyntaxNode syntaxNode) 662020"];
4729 [label="param BinderCacheKey(NodeUsage usage) 662021"];
4730 [label="param BinderCacheKey(this) 662022"];
4731 [label="this.syntaxNode 662023"];
4732 [label="this.usage 662024"];
4733 [label="var key = CreateBinderCacheKey(parent, extraInfo); 662025"];
4734 [label="Binder resultBinder; 662026"];
4735 [label="binderCache 662027"];
4736 [label="get\n                {\n                    return _factory._binderCache;\n                } 662028"];
4737 [label="return _factory._binderCache; 662029"];
4738 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 662030"];
4739 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 662031"];
4740 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 662032"];
4741 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 662033"];
4742 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 662034"];
4743 [label="param GetHashCode(this) 662035"];
4744 [label="return Hash.Combine(syntaxNode.GetHashCode(), (int)usage); 662036"];
4745 [label="resultBinder = VisitCore(parent.Parent); 662037"];
4746 [label="VisitCore(parent.Parent) 662038"];
4747 [label="param VisitCore(SyntaxNode node) 662039"];
4748 [label="param VisitNamespaceDeclaration(NamespaceDeclarationSyntax parent) 662040"];
4749 [label="param VisitNamespaceDeclaration(this) 662041"];
4750 [label="if (!LookupPosition.IsInNamespaceDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 662042"];
4751 [label="if (!LookupPosition.IsInNamespaceDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 662043"];
4752 [label="if (!LookupPosition.IsInNamespaceDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 662044"];
4753 [label="bool inBody = LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken); 662045"];
4754 [label="bool inBody = LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken); 662046"];
4755 [label="bool inUsing = IsInUsing(parent); 662047"];
4756 [label="IsInUsing(parent) 662048"];
4757 [label="param IsInUsing(CSharpSyntaxNode containingNode) 662049"];
4758 [label="param IsInUsing(this) 662050"];
4759 [label="TextSpan containingSpan = containingNode.Span; 662051"];
4760 [label="SyntaxToken token; 662052"];
4761 [label="token 662053"];
4762 [label="if (containingNode.Kind() != SyntaxKind.CompilationUnit && _position == containingSpan.End)\n                {\n                    // This occurs at EOF\n                    token = containingNode.GetLastToken();\n                    Debug.Assert(token == this.syntaxTree.GetRoot().GetLastToken());\n                }\n                else if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 662054"];
4763 [label="if (containingNode.Kind() != SyntaxKind.CompilationUnit && _position == containingSpan.End)\n                {\n                    // This occurs at EOF\n                    token = containingNode.GetLastToken();\n                    Debug.Assert(token == this.syntaxTree.GetRoot().GetLastToken());\n                }\n                else if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 662055"];
4764 [label="if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 662056"];
4765 [label="token = containingNode.FindToken(_position); 662057"];
4766 [label="token = containingNode.FindToken(_position); 662058"];
4767 [label="var node = token.Parent; 662059"];
4768 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 662060"];
4769 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 662061"];
4770 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 662062"];
4771 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 662063"];
4772 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 662064"];
4773 [label="node = node.Parent; 662065"];
4774 [label="return false; 662066"];
4775 [label="bool inUsing = IsInUsing(parent); 662067"];
4776 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 662068"];
4777 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 662069"];
4778 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 662070"];
4779 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 662071"];
4780 [label="VisitNamespaceDeclaration(parent, _position, inBody, inUsing) 662072"];
4781 [label="param VisitNamespaceDeclaration(NamespaceDeclarationSyntax parent) 662073"];
4782 [label="param VisitNamespaceDeclaration(int position) 662074"];
4783 [label="param VisitNamespaceDeclaration(bool inBody) 662075"];
4784 [label="param VisitNamespaceDeclaration(bool inUsing) 662076"];
4785 [label="param VisitNamespaceDeclaration(this) 662077"];
4786 [label="Debug.Assert(!inUsing || inBody, 'inUsing => inBody'); 662078"];
4787 [label="Debug.Assert(!inUsing || inBody, 'inUsing => inBody'); 662079"];
4788 [label="inUsing 662080"];
4789 [label="inBody 662081"];
4790 [label="var extraInfo = inUsing ? NodeUsage.NamespaceUsings : (inBody ? NodeUsage.NamespaceBody : NodeUsage.Normal); 662082"];
4791 [label="var key = CreateBinderCacheKey(parent, extraInfo); 662083"];
4792 [label="var key = CreateBinderCacheKey(parent, extraInfo); 662084"];
4793 [label="CreateBinderCacheKey(parent, extraInfo) 662085"];
4794 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 662086"];
4795 [label="param CreateBinderCacheKey(NodeUsage usage) 662087"];
4796 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 662088"];
4797 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 662089"];
4798 [label="var key = CreateBinderCacheKey(parent, extraInfo); 662090"];
4799 [label="Binder result; 662091"];
4800 [label="binderCache 662092"];
4801 [label="get\n                {\n                    return _factory._binderCache;\n                } 662093"];
4802 [label="return _factory._binderCache; 662094"];
4803 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 662095"];
4804 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 662096"];
4805 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 662097"];
4806 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 662098"];
4807 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 662099"];
4808 [label="Binder outer; 662100"];
4809 [label="var container = parent.Parent; 662101"];
4810 [label="InScript 662102"];
4811 [label="get\n                {\n                    return _factory.InScript;\n                } 662103"];
4812 [label="_factory.InScript 662104"];
4813 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 662105"];
4814 [label="return _factory.InScript; 662106"];
4815 [label="if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    } 662107"];
4816 [label="outer = _factory.GetBinder(parent.Parent, position); 662108"];
4817 [label="outer = _factory.GetBinder(parent.Parent, position); 662109"];
4818 [label="outer = _factory.GetBinder(parent.Parent, position); 662110"];
4819 [label="_factory.GetBinder(parent.Parent, position) 662111"];
4820 [label="param GetBinder(SyntaxNode node) 662112"];
4821 [label="param GetBinder(int position) 662113"];
4822 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 662114"];
4823 [label="param GetBinder(Symbol memberOpt = null) 662115"];
4824 [label="Debug.Assert(node != null); 662116"];
4825 [label="Debug.Assert(node != null); 662117"];
4826 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 662118"];
4827 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 662119"];
4828 [label="memberDeclarationOpt == null 662120"];
4829 [label="param ==(Symbol left) 662121"];
4830 [label="param ==(Symbol right) 662122"];
4831 [label="if (right is null)\n            {\n                return left is null;\n            } 662123"];
4832 [label="return left is null; 662124"];
4833 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 662125"];
4834 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 662126"];
4835 [label="param VisitCompilationUnit(CompilationUnitSyntax parent) 662127"];
4836 [label="param VisitCompilationUnit(this) 662128"];
4837 [label="return VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript); 662129"];
4838 [label="IsInUsing(parent) 662130"];
4839 [label="param IsInUsing(CSharpSyntaxNode containingNode) 662131"];
4840 [label="param IsInUsing(this) 662132"];
4841 [label="SyntaxToken token; 662133"];
4842 [label="token 662134"];
4843 [label="if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 662135"];
4844 [label="return VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript); 662136"];
4845 [label="InScript 662137"];
4846 [label="get\n                {\n                    return _factory.InScript;\n                } 662138"];
4847 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 662139"];
4848 [label="VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript) 662140"];
4849 [label="param VisitCompilationUnit(CompilationUnitSyntax compilationUnit) 662141"];
4850 [label="param VisitCompilationUnit(bool inUsing) 662142"];
4851 [label="param VisitCompilationUnit(bool inScript) 662143"];
4852 [label="param VisitCompilationUnit(this) 662144"];
4853 [label="syntaxTree 662145"];
4854 [label="get\n                {\n                    return _factory._syntaxTree;\n                } 662146"];
4855 [label="return _factory._syntaxTree; 662147"];
4856 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 662148"];
4857 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 662149"];
4858 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 662150"];
4859 [label="inUsing 662151"];
4860 [label="inScript 662152"];
4861 [label="var extraInfo = inUsing\n                    ? (inScript ? NodeUsage.CompilationUnitScriptUsings : NodeUsage.CompilationUnitUsings)\n                    : (inScript ? NodeUsage.CompilationUnitScript : NodeUsage.Normal); 662153"];
4862 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 662154"];
4863 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 662155"];
4864 [label="CreateBinderCacheKey(compilationUnit, extraInfo) 662156"];
4865 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 662157"];
4866 [label="param CreateBinderCacheKey(NodeUsage usage) 662158"];
4867 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 662159"];
4868 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 662160"];
4869 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 662161"];
4870 [label="Binder result; 662162"];
4871 [label="binderCache 662163"];
4872 [label="get\n                {\n                    return _factory._binderCache;\n                } 662164"];
4873 [label="return _factory._binderCache; 662165"];
4874 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 662166"];
4875 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 662167"];
4876 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 662168"];
4877 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 662169"];
4878 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 662170"];
4879 [label="this.buckStopsHereBinder 662171"];
4880 [label="get\n                {\n                    return _factory._buckStopsHereBinder;\n                } 662172"];
4881 [label="return _factory._buckStopsHereBinder; 662173"];
4882 [label="result = this.buckStopsHereBinder; 662174"];
4883 [label="if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    } 662175"];
4884 [label="compilation 662176"];
4885 [label="get\n                {\n                    return _factory._compilation;\n                } 662177"];
4886 [label="return _factory._compilation; 662178"];
4887 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 662179"];
4888 [label="compilation.GlobalNamespace 662180"];
4889 [label="get\n            {\n                if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                }\n\n                return _lazyGlobalNamespace;\n            } 662181"];
4890 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 662182"];
4891 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 662183"];
4892 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 662184"];
4893 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 662185"];
4894 [label="new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing) 662186"];
4895 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 662187"];
4896 [label="param InContainerBinder(Binder next) 662188"];
4897 [label="param InContainerBinder(CSharpSyntaxNode declarationSyntax) 662189"];
4898 [label="param InContainerBinder(bool inUsing) 662190"];
4899 [label="param InContainerBinder(this) 662191"];
4900 [label="next 662192"];
4901 [label="param InContainerBinder(this) 662193"];
4902 [label="param Binder(Binder next) 662194"];
4903 [label="param Binder(this) 662195"];
4904 [label="param Binder(Conversions? conversions = null) 662196"];
4905 [label="RoslynDebug.Assert(next != null); 662197"];
4906 [label="RoslynDebug.Assert(next != null); 662198"];
4907 [label="Next 662199"];
4908 [label="this.Flags 662200"];
4909 [label="this.Compilation 662201"];
4910 [label="_lazyConversions 662202"];
4911 [label="_container 662203"];
4912 [label="_computeImports 662204"];
4913 [label="_lazyImports 662205"];
4914 [label="_lazyImportChain 662206"];
4915 [label="_lazyQuickAttributeChecker 662207"];
4916 [label="Debug.Assert((object)container != null); 662208"];
4917 [label="Debug.Assert((object)container != null); 662209"];
4918 [label="Debug.Assert(declarationSyntax != null); 662210"];
4919 [label="Debug.Assert(declarationSyntax != null); 662211"];
4920 [label="_container 662212"];
4921 [label="_computeImports = basesBeingResolved => Imports.FromSyntax(declarationSyntax, this, basesBeingResolved, inUsing); 662213"];
4922 [label="_computeImports 662214"];
4923 [label="if (!inUsing)\n            {\n                if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                }\n            } 662215"];
4924 [label="if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                } 662216"];
4925 [label="var compilationUnit = (CompilationUnitSyntax)declarationSyntax; 662217"];
4926 [label="_usingsSyntax 662218"];
4927 [label="compilation 662219"];
4928 [label="get\n                {\n                    return _factory._compilation;\n                } 662220"];
4929 [label="return _factory._compilation; 662221"];
4930 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 662222"];
4931 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 662223"];
4932 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 662224"];
4933 [label="SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) 662225"];
4934 [label="param GetSimpleProgramEntryPoint(CSharpCompilation compilation) 662226"];
4935 [label="param GetSimpleProgramEntryPoint(CompilationUnitSyntax compilationUnit) 662227"];
4936 [label="param GetSimpleProgramEntryPoint(bool fallbackToMainEntryPoint) 662228"];
4937 [label="var type = GetSimpleProgramNamedTypeSymbol(compilation); 662229"];
4938 [label="GetSimpleProgramNamedTypeSymbol(compilation) 662230"];
4939 [label="param GetSimpleProgramNamedTypeSymbol(CSharpCompilation compilation) 662231"];
4940 [label="compilation.SourceModule 662232"];
4941 [label="get\n            {\n                return Assembly.Modules[0];\n            } 662233"];
4942 [label="Assembly 662234"];
4943 [label="get\n            {\n                return SourceAssembly;\n            } 662235"];
4944 [label="GetBoundReferenceManager(); 662236"];
4945 [label="return Assembly.Modules[0]; 662237"];
4946 [label="Assembly.Modules 662238"];
4947 [label="get\n            {\n                return _modules;\n            } 662239"];
4948 [label="return Assembly.Modules[0]; 662240"];
4949 [label="return compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName).OfType<SimpleProgramNamedTypeSymbol>().SingleOrDefault(); 662241"];
4950 [label="compilation.SourceModule.GlobalNamespace 662242"];
4951 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 662243"];
4952 [label="return compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName).OfType<SimpleProgramNamedTypeSymbol>().SingleOrDefault(); 662244"];
4953 [label="compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName) 662245"];
4954 [label="param GetTypeMembers(string name) 662246"];
4955 [label="param GetTypeMembers(this) 662247"];
4956 [label="bool hasType = false; 662248"];
4957 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 662249"];
4958 [label="symbol.Kind 662250"];
4959 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 662251"];
4960 [label="Debug.Assert(symbol.Kind == SymbolKind.Namespace); 662252"];
4961 [label="hasNamespace = true; 662253"];
4962 [label="if (hasType)\n                        {\n                            break;\n                        } 662254"];
4963 [label="if (type is null)\n            {\n                return null;\n            } 662255"];
4964 [label="return null; 662256"];
4965 [label="binderCache 662257"];
4966 [label="return _factory._binderCache; 662258"];
4967 [label="binderCache.TryAdd(key, result); 662259"];
4968 [label="binderCache.TryAdd(key, result); 662260"];
4969 [label="binderCache.TryAdd(key, result); 662261"];
4970 [label="binderCache.TryAdd(key, result); 662262"];
4971 [label="binderCache.TryAdd(key, result); 662263"];
4972 [label="return result; 662264"];
4973 [label="return ((CSharpSyntaxNode)node).Accept(this); 662265"];
4974 [label="_binderFactoryVisitorPool.Free(visitor); 662266"];
4975 [label="_binderFactoryVisitorPool.Free(visitor); 662267"];
4976 [label="return result; 662268"];
4977 [label="if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    } 662269"];
4978 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 662270"];
4979 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 662271"];
4980 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 662272"];
4981 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 662273"];
4982 [label="MakeNamespaceBinder(parent, parent.Name, outer, inUsing) 662274"];
4983 [label="param MakeNamespaceBinder(CSharpSyntaxNode node) 662275"];
4984 [label="param MakeNamespaceBinder(NameSyntax name) 662276"];
4985 [label="param MakeNamespaceBinder(Binder outer) 662277"];
4986 [label="param MakeNamespaceBinder(bool inUsing) 662278"];
4987 [label="param MakeNamespaceBinder(this) 662279"];
4988 [label="QualifiedNameSyntax dotted; 662280"];
4989 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 662281"];
4990 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 662282"];
4991 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 662283"];
4992 [label="NamespaceOrTypeSymbol container; 662284"];
4993 [label="if (outer is InContainerBinder inContainerBinder)\n                {\n                    container = inContainerBinder.Container;\n                }\n                else\n                {\n                    Debug.Assert(outer is SimpleProgramUnitBinder);\n                    container = outer.Compilation.GlobalNamespace;\n                } 662285"];
4994 [label="inContainerBinder.Container 662286"];
4995 [label="get\n            {\n                return _container;\n            } 662287"];
4996 [label="return _container; 662288"];
4997 [label="container = inContainerBinder.Container; 662289"];
4998 [label="NamespaceSymbol ns = ((NamespaceSymbol)container).GetNestedNamespace(name); 662290"];
4999 [label="((NamespaceSymbol)container).GetNestedNamespace(name) 662291"];
5000 [label="param GetNestedNamespace(NameSyntax name) 662292"];
5001 [label="param GetNestedNamespace(this) 662293"];
5002 [label="switch (name.Kind())\n            {\n                case SyntaxKind.GenericName: // DeclarationTreeBuilder.VisitNamespace uses the PlainName, even for generic names\n                case SyntaxKind.IdentifierName:\n                    return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText);\n\n                case SyntaxKind.QualifiedName:\n                    var qn = (QualifiedNameSyntax)name;\n                    var leftNs = this.GetNestedNamespace(qn.Left);\n                    if ((object)leftNs != null)\n                    {\n                        return leftNs.GetNestedNamespace(qn.Right);\n                    }\n\n                    break;\n\n                case SyntaxKind.AliasQualifiedName:\n                    // This is an error scenario, but we should still handle it.\n                    // We recover in the same way as DeclarationTreeBuilder.VisitNamespaceDeclaration.\n                    return this.GetNestedNamespace(name.GetUnqualifiedName().Identifier.ValueText);\n            } 662294"];
5003 [label="return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText); 662295"];
5004 [label="((SimpleNameSyntax)name).Identifier 662296"];
5005 [label="param GetNestedNamespace(string name) 662297"];
5006 [label="param GetNestedNamespace(this) 662298"];
5007 [label="foreach (var sym in this.GetMembers(name))\n            {\n                if (sym.Kind == SymbolKind.Namespace)\n                {\n                    return (NamespaceSymbol)sym;\n                }\n            } 662299"];
5008 [label="this.GetMembers(name) 662300"];
5009 [label="param GetMembers(string name) 662301"];
5010 [label="param GetMembers(this) 662302"];
5011 [label="return _cachedLookup[name]; 662303"];
5012 [label="sym.Kind 662304"];
5013 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 662305"];
5014 [label="if (sym.Kind == SymbolKind.Namespace)\n                {\n                    return (NamespaceSymbol)sym;\n                } 662306"];
5015 [label="return (NamespaceSymbol)sym; 662307"];
5016 [label="return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText); 662308"];
5017 [label="if ((object)ns == null) return outer; 662309"];
5018 [label="if ((object)ns == null) return outer; 662310"];
5019 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 662311"];
5020 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 662312"];
5021 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 662313"];
5022 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 662314"];
5023 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 662315"];
5024 [label="new InContainerBinder(ns, outer, node, inUsing: inUsing) 662316"];
5025 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 662317"];
5026 [label="param InContainerBinder(Binder next) 662318"];
5027 [label="param InContainerBinder(CSharpSyntaxNode declarationSyntax) 662319"];
5028 [label="param InContainerBinder(bool inUsing) 662320"];
5029 [label="param InContainerBinder(this) 662321"];
5030 [label="param InContainerBinder(this) 662322"];
5031 [label="param Binder(this) 662323"];
5032 [label="param Binder(Conversions? conversions = null) 662324"];
5033 [label="RoslynDebug.Assert(next != null); 662325"];
5034 [label="RoslynDebug.Assert(next != null); 662326"];
5035 [label="this.Flags 662327"];
5036 [label="this.Compilation 662328"];
5037 [label="_lazyConversions 662329"];
5038 [label="_container 662330"];
5039 [label="_computeImports 662331"];
5040 [label="_lazyImports 662332"];
5041 [label="_lazyImportChain 662333"];
5042 [label="_lazyQuickAttributeChecker 662334"];
5043 [label="Debug.Assert((object)container != null); 662335"];
5044 [label="Debug.Assert((object)container != null); 662336"];
5045 [label="Debug.Assert(declarationSyntax != null); 662337"];
5046 [label="Debug.Assert(declarationSyntax != null); 662338"];
5047 [label="_computeImports = basesBeingResolved => Imports.FromSyntax(declarationSyntax, this, basesBeingResolved, inUsing); 662339"];
5048 [label="_computeImports 662340"];
5049 [label="if (!inUsing)\n            {\n                if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                }\n            } 662341"];
5050 [label="if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                } 662342"];
5051 [label="if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                } 662343"];
5052 [label="var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax; 662344"];
5053 [label="_usingsSyntax 662345"];
5054 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 662346"];
5055 [label="binderCache 662347"];
5056 [label="return _factory._binderCache; 662348"];
5057 [label="binderCache.TryAdd(key, result); 662349"];
5058 [label="binderCache.TryAdd(key, result); 662350"];
5059 [label="binderCache.TryAdd(key, result); 662351"];
5060 [label="binderCache.TryAdd(key, result); 662352"];
5061 [label="binderCache.TryAdd(key, result); 662353"];
5062 [label="return result; 662354"];
5063 [label="return ((CSharpSyntaxNode)node).Accept(this); 662355"];
5064 [label="if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    } 662356"];
5065 [label="resultBinder.ContainingMemberOrLambda 662357"];
5066 [label="get\n            {\n                var merged = _container as MergedNamespaceSymbol;\n                return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container;\n            } 662358"];
5067 [label="var merged = _container as MergedNamespaceSymbol; 662359"];
5068 [label="return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container; 662360"];
5069 [label="return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container; 662361"];
5070 [label="((object)merged != null) 662362"];
5071 [label="_container 662363"];
5072 [label="var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent); 662364"];
5073 [label="var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent); 662365"];
5074 [label="((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent) 662366"];
5075 [label="param GetSourceTypeMember(TypeDeclarationSyntax syntax) 662367"];
5076 [label="param GetSourceTypeMember(this) 662368"];
5077 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 662369"];
5078 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 662370"];
5079 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 662371"];
5080 [label="GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax) 662372"];
5081 [label="param GetSourceTypeMember(string name) 662373"];
5082 [label="param GetSourceTypeMember(int arity) 662374"];
5083 [label="param GetSourceTypeMember(SyntaxKind kind) 662375"];
5084 [label="param GetSourceTypeMember(CSharpSyntaxNode syntax) 662376"];
5085 [label="param GetSourceTypeMember(this) 662377"];
5086 [label="TypeKind typeKind = kind.ToDeclarationKind().ToTypeKind(); 662378"];
5087 [label="kind.ToDeclarationKind().ToTypeKind() 662379"];
5088 [label="param ToTypeKind(this DeclarationKind kind) 662380"];
5089 [label="foreach (var member in GetTypeMembers(name, arity))\n            {\n                var memberT = member as SourceNamedTypeSymbol;\n                if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                }\n            } 662381"];
5090 [label="foreach (var member in GetTypeMembers(name, arity))\n            {\n                var memberT = member as SourceNamedTypeSymbol;\n                if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                }\n            } 662382"];
5091 [label="GetTypeMembers(name, arity) 662383"];
5092 [label="param GetTypeMembers(string name) 662384"];
5093 [label="param GetTypeMembers(int arity) 662385"];
5094 [label="param GetTypeMembers(this) 662386"];
5095 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 662387"];
5096 [label="GetTypeMembers(name) 662388"];
5097 [label="param GetTypeMembers(string name) 662389"];
5098 [label="param GetTypeMembers(this) 662390"];
5099 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 662391"];
5100 [label="return _nameToTypeMembersMap; 662392"];
5101 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 662393"];
5102 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 662394"];
5103 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 662395"];
5104 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 662396"];
5105 [label="get\n            {\n                return declaration.Arity;\n            } 662397"];
5106 [label="return declaration.Arity; 662398"];
5107 [label="var memberT = member as SourceNamedTypeSymbol; 662399"];
5108 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 662400"];
5109 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 662401"];
5110 [label="memberT.TypeKind 662402"];
5111 [label="get\n            {\n                return _flags.TypeKind;\n            } 662403"];
5112 [label="_flags.TypeKind 662404"];
5113 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 662405"];
5114 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 662406"];
5115 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 662407"];
5116 [label="return _flags.TypeKind; 662408"];
5117 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 662409"];
5118 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 662410"];
5119 [label="if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    } 662411"];
5120 [label="if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    } 662412"];
5121 [label="memberT.Locations 662413"];
5122 [label="foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        } 662414"];
5123 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 662415"];
5124 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 662416"];
5125 [label="return memberT; 662417"];
5126 [label="if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        } 662418"];
5127 [label="resultBinder = new InContainerBinder(typeSymbol, resultBinder); 662419"];
5128 [label="resultBinder = new InContainerBinder(typeSymbol, resultBinder); 662420"];
5129 [label="resultBinder = new InContainerBinder(typeSymbol, resultBinder); 662421"];
5130 [label="new InContainerBinder(typeSymbol, resultBinder) 662422"];
5131 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 662423"];
5132 [label="param InContainerBinder(Binder next) 662424"];
5133 [label="param InContainerBinder(Imports imports = null) 662425"];
5134 [label="param InContainerBinder(this) 662426"];
5135 [label="next 662427"];
5136 [label="param InContainerBinder(this) 662428"];
5137 [label="param Binder(Binder next) 662429"];
5138 [label="param Binder(this) 662430"];
5139 [label="param Binder(Conversions? conversions = null) 662431"];
5140 [label="RoslynDebug.Assert(next != null); 662432"];
5141 [label="RoslynDebug.Assert(next != null); 662433"];
5142 [label="this.Flags 662434"];
5143 [label="this.Compilation 662435"];
5144 [label="_lazyConversions 662436"];
5145 [label="_container 662437"];
5146 [label="_computeImports 662438"];
5147 [label="_lazyImports 662439"];
5148 [label="_lazyImportChain 662440"];
5149 [label="_lazyQuickAttributeChecker 662441"];
5150 [label="Debug.Assert((object)container != null || imports != null); 662442"];
5151 [label="Debug.Assert((object)container != null || imports != null); 662443"];
5152 [label="_container 662444"];
5153 [label="null 662445"];
5154 [label="ImmutableDictionary<string, AliasAndUsingDirective>.Empty 662446"];
5155 [label="ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty 662447"];
5156 [label="ImmutableArray<AliasAndExternAliasDirective>.Empty 662448"];
5157 [label="null 662449"];
5158 [label="new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 662450"];
5159 [label="param Imports(CSharpCompilation compilation) 662451"];
5160 [label="param Imports(ImmutableDictionary<string, AliasAndUsingDirective> usingAliases) 662452"];
5161 [label="param Imports(ImmutableArray<NamespaceOrTypeAndUsingDirective> usings) 662453"];
5162 [label="param Imports(ImmutableArray<AliasAndExternAliasDirective> externs) 662454"];
5163 [label="param Imports(DiagnosticBag diagnostics) 662455"];
5164 [label="param Imports(this) 662456"];
5165 [label="_compilation 662457"];
5166 [label="_diagnostics 662458"];
5167 [label="UsingAliases 662459"];
5168 [label="Debug.Assert(usingAliases != null); 662460"];
5169 [label="Debug.Assert(usingAliases != null); 662461"];
5170 [label="Debug.Assert(!usings.IsDefault); 662462"];
5171 [label="Debug.Assert(!externs.IsDefault); 662463"];
5172 [label="_compilation 662464"];
5173 [label="this.UsingAliases 662465"];
5174 [label="this.Usings 662466"];
5175 [label="_diagnostics 662467"];
5176 [label="this.ExternAliases 662468"];
5177 [label="Empty = new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 662469"];
5178 [label="_lazyImports = imports ?? Imports.Empty; 662470"];
5179 [label="_lazyImports = imports ?? Imports.Empty; 662471"];
5180 [label="_lazyImports 662472"];
5181 [label="if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            } 662473"];
5182 [label="if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            } 662474"];
5183 [label="resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers); 662475"];
5184 [label="resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers) 662476"];
5185 [label="param WithUnsafeRegionIfNecessary(SyntaxTokenList modifiers) 662477"];
5186 [label="param WithUnsafeRegionIfNecessary(this) 662478"];
5187 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 662479"];
5188 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 662480"];
5189 [label="this.Flags.Includes(BinderFlags.UnsafeRegion) 662481"];
5190 [label="param Includes(this BinderFlags self) 662482"];
5191 [label="param Includes(BinderFlags other) 662483"];
5192 [label="return (self & other) == other; 662484"];
5193 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 662485"];
5194 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 662486"];
5195 [label="(this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword)) 662487"];
5196 [label="binderCache 662488"];
5197 [label="return _factory._binderCache; 662489"];
5198 [label="binderCache.TryAdd(key, resultBinder); 662490"];
5199 [label="binderCache.TryAdd(key, resultBinder); 662491"];
5200 [label="binderCache.TryAdd(key, resultBinder); 662492"];
5201 [label="binderCache.TryAdd(key, resultBinder); 662493"];
5202 [label="binderCache.TryAdd(key, resultBinder); 662494"];
5203 [label="return resultBinder; 662495"];
5204 [label="return ((CSharpSyntaxNode)node).Accept(this); 662496"];
5205 [label="_binderFactoryVisitorPool.Free(visitor); 662497"];
5206 [label="ArrayBuilder<FieldOrPropertyInitializer>? staticInitializers = null; 662498"];
5207 [label="DeclaringCompilation 662499"];
5208 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 662500"];
5209 [label="this.Kind 662501"];
5210 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 662502"];
5211 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 662503"];
5212 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 662504"];
5213 [label="this.ContainingSymbol 662505"];
5214 [label="get\n            {\n                return _containingSymbol;\n            } 662506"];
5215 [label="return _containingSymbol; 662507"];
5216 [label="return (object)container != null ? container.ContainingModule : null; 662508"];
5217 [label="var compilation = DeclaringCompilation; 662509"];
5218 [label="foreach (var m in members)\n            {\n                if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                }\n\n                bool reportMisplacedGlobalCode = !m.HasErrors;\n\n                switch (m.Kind())\n                {\n                    case SyntaxKind.FieldDeclaration:\n                        {\n                            var fieldSyntax = (FieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            bool modifierErrors;\n                            var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors);\n                            foreach (var variable in fieldSyntax.Declaration.Variables)\n                            {\n                                var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics);\n                                builder.NonTypeMembers.Add(fieldSymbol);\n                                // All fields are included in the nullable context for constructors and initializers, even fields without\n                                // initializers, to ensure warnings are reported for uninitialized non-nullable fields in NullableWalker.\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable);\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                }\n\n                                if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.MethodDeclaration:\n                        {\n                            var methodSyntax = (MethodDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(methodSyntax.Identifier));\n                            }\n\n                            var method = SourceOrdinaryMethodSymbol.CreateMethodSymbol(this, bodyBinder, methodSyntax, compilation.IsNullableAnalysisEnabledIn(methodSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.ConstructorDeclaration:\n                        {\n                            var constructorSyntax = (ConstructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(constructorSyntax.Identifier));\n                            }\n\n                            bool isNullableEnabled = compilation.IsNullableAnalysisEnabledIn(constructorSyntax);\n                            var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics);\n                            builder.NonTypeMembers.Add(constructor);\n                            if (constructorSyntax.Initializer?.Kind() != SyntaxKind.ThisConstructorInitializer)\n                            {\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.DestructorDeclaration:\n                        {\n                            var destructorSyntax = (DestructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(destructorSyntax.Identifier));\n                            }\n\n                            // CONSIDER: if this doesn't (directly or indirectly) override object.Finalize, the\n                            // runtime won't consider it a finalizer and it will not be marked as a destructor\n                            // when it is loaded from metadata.  Perhaps we should just treat it as an Ordinary\n                            // method in such cases?\n                            var destructor = new SourceDestructorSymbol(this, destructorSyntax, compilation.IsNullableAnalysisEnabledIn(destructorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(destructor);\n                        }\n                        break;\n\n                    case SyntaxKind.PropertyDeclaration:\n                        {\n                            var propertySyntax = (PropertyDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(propertySyntax.Identifier));\n                            }\n\n                            var property = SourcePropertySymbol.Create(this, bodyBinder, propertySyntax, diagnostics);\n                            builder.NonTypeMembers.Add(property);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.SetMethod);\n                            FieldSymbol backingField = property.BackingField;\n\n                            // TODO: can we leave this out of the member list?\n                            // From the 10/12/11 design notes:\n                            //   In addition, we will change autoproperties to behavior in\n                            //   a similar manner and make the autoproperty fields private.\n                            if ((object)backingField != null)\n                            {\n                                builder.NonTypeMembers.Add(backingField);\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: backingField.IsStatic, compilation, propertySyntax);\n\n                                var initializer = propertySyntax.Initializer;\n                                if (initializer != null)\n                                {\n                                    if (IsScriptClass)\n                                    {\n                                        // also gather expression-declared variables from the initializer\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                                                      initializer,\n                                                                                      this,\n                                                                                      DeclarationModifiers.Private | (property.IsStatic ? DeclarationModifiers.Static : 0),\n                                                                                      backingField);\n                                    }\n\n                                    if (property.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, backingField, initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, backingField, initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventFieldDeclaration:\n                        {\n                            var eventFieldSyntax = (EventFieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(\n                                    ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventFieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            foreach (VariableDeclaratorSyntax declarator in eventFieldSyntax.Declaration.Variables)\n                            {\n                                SourceFieldLikeEventSymbol @event = new SourceFieldLikeEventSymbol(this, bodyBinder, eventFieldSyntax.Modifiers, declarator, diagnostics);\n                                builder.NonTypeMembers.Add(@event);\n\n                                FieldSymbol? associatedField = @event.AssociatedField;\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, declarator, this,\n                                                            DeclarationModifiers.Private | (@event.IsStatic ? DeclarationModifiers.Static : 0),\n                                                            associatedField);\n                                }\n\n                                if ((object?)associatedField != null)\n                                {\n                                    // NOTE: specifically don't add the associated field to the members list\n                                    // (regard it as an implementation detail).\n\n                                    builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: associatedField.IsStatic, compilation, declarator);\n\n                                    if (declarator.Initializer != null)\n                                    {\n                                        if (associatedField.IsStatic)\n                                        {\n                                            AddInitializer(ref staticInitializers, associatedField, declarator.Initializer);\n                                        }\n                                        else\n                                        {\n                                            AddInitializer(ref instanceInitializers, associatedField, declarator.Initializer);\n                                        }\n                                    }\n                                }\n\n                                Debug.Assert((object)@event.AddMethod != null);\n                                Debug.Assert((object)@event.RemoveMethod != null);\n\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventDeclaration:\n                        {\n                            var eventSyntax = (EventDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventSyntax.Identifier));\n                            }\n\n                            var @event = new SourceCustomEventSymbol(this, bodyBinder, eventSyntax, diagnostics);\n\n                            builder.NonTypeMembers.Add(@event);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n\n                            Debug.Assert(@event.AssociatedField is null);\n                        }\n                        break;\n\n                    case SyntaxKind.IndexerDeclaration:\n                        {\n                            var indexerSyntax = (IndexerDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(indexerSyntax.ThisKeyword));\n                            }\n\n                            var indexer = SourcePropertySymbol.Create(this, bodyBinder, indexerSyntax, diagnostics);\n                            builder.HaveIndexers = true;\n                            builder.NonTypeMembers.Add(indexer);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.SetMethod);\n                        }\n                        break;\n\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        {\n                            var conversionOperatorSyntax = (ConversionOperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(conversionOperatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedConversionSymbol.CreateUserDefinedConversionSymbol(\n                                this, conversionOperatorSyntax, compilation.IsNullableAnalysisEnabledIn(conversionOperatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.OperatorDeclaration:\n                        {\n                            var operatorSyntax = (OperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(operatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedOperatorSymbol.CreateUserDefinedOperatorSymbol(\n                                this, operatorSyntax, compilation.IsNullableAnalysisEnabledIn(operatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.GlobalStatement:\n                        {\n                            var globalStatement = ((GlobalStatementSyntax)m).Statement;\n\n                            if (IsScriptClass)\n                            {\n                                var innerStatement = globalStatement;\n\n                                // drill into any LabeledStatements\n                                while (innerStatement.Kind() == SyntaxKind.LabeledStatement)\n                                {\n                                    innerStatement = ((LabeledStatementSyntax)innerStatement).Statement;\n                                }\n\n                                switch (innerStatement.Kind())\n                                {\n                                    case SyntaxKind.LocalDeclarationStatement:\n                                        // We shouldn't reach this place, but field declarations preceded with a label end up here.\n                                        // This is tracked by https://github.com/dotnet/roslyn/issues/13712. Let's do our best for now.\n                                        var decl = (LocalDeclarationStatementSyntax)innerStatement;\n                                        foreach (var vdecl in decl.Declaration.Variables)\n                                        {\n                                            // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                            ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, vdecl, this, DeclarationModifiers.Private,\n                                                                                          containingFieldOpt: null);\n                                        }\n                                        break;\n\n                                    case SyntaxKind.ExpressionStatement:\n                                    case SyntaxKind.IfStatement:\n                                    case SyntaxKind.YieldReturnStatement:\n                                    case SyntaxKind.ReturnStatement:\n                                    case SyntaxKind.ThrowStatement:\n                                    case SyntaxKind.SwitchStatement:\n                                    case SyntaxKind.LockStatement:\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                  innerStatement,\n                                                  this,\n                                                  DeclarationModifiers.Private,\n                                                  containingFieldOpt: null);\n                                        break;\n\n                                    default:\n                                        // no other statement introduces variables into the enclosing scope\n                                        break;\n                                }\n\n                                AddInitializer(ref instanceInitializers, null, globalStatement);\n                            }\n                            else if (reportMisplacedGlobalCode && !SyntaxFacts.IsSimpleProgramTopLevelStatement((GlobalStatementSyntax)m))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_GlobalStatement, new SourceLocation(globalStatement));\n                            }\n                        }\n                        break;\n\n                    default:\n                        Debug.Assert(\n                            SyntaxFacts.IsTypeDeclaration(m.Kind()) ||\n                            m.Kind() == SyntaxKind.NamespaceDeclaration ||\n                            m.Kind() == SyntaxKind.IncompleteMember);\n                        break;\n                }\n            } 662510"];
5219 [label="foreach (var m in members)\n            {\n                if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                }\n\n                bool reportMisplacedGlobalCode = !m.HasErrors;\n\n                switch (m.Kind())\n                {\n                    case SyntaxKind.FieldDeclaration:\n                        {\n                            var fieldSyntax = (FieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            bool modifierErrors;\n                            var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors);\n                            foreach (var variable in fieldSyntax.Declaration.Variables)\n                            {\n                                var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics);\n                                builder.NonTypeMembers.Add(fieldSymbol);\n                                // All fields are included in the nullable context for constructors and initializers, even fields without\n                                // initializers, to ensure warnings are reported for uninitialized non-nullable fields in NullableWalker.\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable);\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                }\n\n                                if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.MethodDeclaration:\n                        {\n                            var methodSyntax = (MethodDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(methodSyntax.Identifier));\n                            }\n\n                            var method = SourceOrdinaryMethodSymbol.CreateMethodSymbol(this, bodyBinder, methodSyntax, compilation.IsNullableAnalysisEnabledIn(methodSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.ConstructorDeclaration:\n                        {\n                            var constructorSyntax = (ConstructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(constructorSyntax.Identifier));\n                            }\n\n                            bool isNullableEnabled = compilation.IsNullableAnalysisEnabledIn(constructorSyntax);\n                            var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics);\n                            builder.NonTypeMembers.Add(constructor);\n                            if (constructorSyntax.Initializer?.Kind() != SyntaxKind.ThisConstructorInitializer)\n                            {\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.DestructorDeclaration:\n                        {\n                            var destructorSyntax = (DestructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(destructorSyntax.Identifier));\n                            }\n\n                            // CONSIDER: if this doesn't (directly or indirectly) override object.Finalize, the\n                            // runtime won't consider it a finalizer and it will not be marked as a destructor\n                            // when it is loaded from metadata.  Perhaps we should just treat it as an Ordinary\n                            // method in such cases?\n                            var destructor = new SourceDestructorSymbol(this, destructorSyntax, compilation.IsNullableAnalysisEnabledIn(destructorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(destructor);\n                        }\n                        break;\n\n                    case SyntaxKind.PropertyDeclaration:\n                        {\n                            var propertySyntax = (PropertyDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(propertySyntax.Identifier));\n                            }\n\n                            var property = SourcePropertySymbol.Create(this, bodyBinder, propertySyntax, diagnostics);\n                            builder.NonTypeMembers.Add(property);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.SetMethod);\n                            FieldSymbol backingField = property.BackingField;\n\n                            // TODO: can we leave this out of the member list?\n                            // From the 10/12/11 design notes:\n                            //   In addition, we will change autoproperties to behavior in\n                            //   a similar manner and make the autoproperty fields private.\n                            if ((object)backingField != null)\n                            {\n                                builder.NonTypeMembers.Add(backingField);\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: backingField.IsStatic, compilation, propertySyntax);\n\n                                var initializer = propertySyntax.Initializer;\n                                if (initializer != null)\n                                {\n                                    if (IsScriptClass)\n                                    {\n                                        // also gather expression-declared variables from the initializer\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                                                      initializer,\n                                                                                      this,\n                                                                                      DeclarationModifiers.Private | (property.IsStatic ? DeclarationModifiers.Static : 0),\n                                                                                      backingField);\n                                    }\n\n                                    if (property.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, backingField, initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, backingField, initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventFieldDeclaration:\n                        {\n                            var eventFieldSyntax = (EventFieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(\n                                    ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventFieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            foreach (VariableDeclaratorSyntax declarator in eventFieldSyntax.Declaration.Variables)\n                            {\n                                SourceFieldLikeEventSymbol @event = new SourceFieldLikeEventSymbol(this, bodyBinder, eventFieldSyntax.Modifiers, declarator, diagnostics);\n                                builder.NonTypeMembers.Add(@event);\n\n                                FieldSymbol? associatedField = @event.AssociatedField;\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, declarator, this,\n                                                            DeclarationModifiers.Private | (@event.IsStatic ? DeclarationModifiers.Static : 0),\n                                                            associatedField);\n                                }\n\n                                if ((object?)associatedField != null)\n                                {\n                                    // NOTE: specifically don't add the associated field to the members list\n                                    // (regard it as an implementation detail).\n\n                                    builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: associatedField.IsStatic, compilation, declarator);\n\n                                    if (declarator.Initializer != null)\n                                    {\n                                        if (associatedField.IsStatic)\n                                        {\n                                            AddInitializer(ref staticInitializers, associatedField, declarator.Initializer);\n                                        }\n                                        else\n                                        {\n                                            AddInitializer(ref instanceInitializers, associatedField, declarator.Initializer);\n                                        }\n                                    }\n                                }\n\n                                Debug.Assert((object)@event.AddMethod != null);\n                                Debug.Assert((object)@event.RemoveMethod != null);\n\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventDeclaration:\n                        {\n                            var eventSyntax = (EventDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventSyntax.Identifier));\n                            }\n\n                            var @event = new SourceCustomEventSymbol(this, bodyBinder, eventSyntax, diagnostics);\n\n                            builder.NonTypeMembers.Add(@event);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n\n                            Debug.Assert(@event.AssociatedField is null);\n                        }\n                        break;\n\n                    case SyntaxKind.IndexerDeclaration:\n                        {\n                            var indexerSyntax = (IndexerDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(indexerSyntax.ThisKeyword));\n                            }\n\n                            var indexer = SourcePropertySymbol.Create(this, bodyBinder, indexerSyntax, diagnostics);\n                            builder.HaveIndexers = true;\n                            builder.NonTypeMembers.Add(indexer);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.SetMethod);\n                        }\n                        break;\n\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        {\n                            var conversionOperatorSyntax = (ConversionOperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(conversionOperatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedConversionSymbol.CreateUserDefinedConversionSymbol(\n                                this, conversionOperatorSyntax, compilation.IsNullableAnalysisEnabledIn(conversionOperatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.OperatorDeclaration:\n                        {\n                            var operatorSyntax = (OperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(operatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedOperatorSymbol.CreateUserDefinedOperatorSymbol(\n                                this, operatorSyntax, compilation.IsNullableAnalysisEnabledIn(operatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.GlobalStatement:\n                        {\n                            var globalStatement = ((GlobalStatementSyntax)m).Statement;\n\n                            if (IsScriptClass)\n                            {\n                                var innerStatement = globalStatement;\n\n                                // drill into any LabeledStatements\n                                while (innerStatement.Kind() == SyntaxKind.LabeledStatement)\n                                {\n                                    innerStatement = ((LabeledStatementSyntax)innerStatement).Statement;\n                                }\n\n                                switch (innerStatement.Kind())\n                                {\n                                    case SyntaxKind.LocalDeclarationStatement:\n                                        // We shouldn't reach this place, but field declarations preceded with a label end up here.\n                                        // This is tracked by https://github.com/dotnet/roslyn/issues/13712. Let's do our best for now.\n                                        var decl = (LocalDeclarationStatementSyntax)innerStatement;\n                                        foreach (var vdecl in decl.Declaration.Variables)\n                                        {\n                                            // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                            ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, vdecl, this, DeclarationModifiers.Private,\n                                                                                          containingFieldOpt: null);\n                                        }\n                                        break;\n\n                                    case SyntaxKind.ExpressionStatement:\n                                    case SyntaxKind.IfStatement:\n                                    case SyntaxKind.YieldReturnStatement:\n                                    case SyntaxKind.ReturnStatement:\n                                    case SyntaxKind.ThrowStatement:\n                                    case SyntaxKind.SwitchStatement:\n                                    case SyntaxKind.LockStatement:\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                  innerStatement,\n                                                  this,\n                                                  DeclarationModifiers.Private,\n                                                  containingFieldOpt: null);\n                                        break;\n\n                                    default:\n                                        // no other statement introduces variables into the enclosing scope\n                                        break;\n                                }\n\n                                AddInitializer(ref instanceInitializers, null, globalStatement);\n                            }\n                            else if (reportMisplacedGlobalCode && !SyntaxFacts.IsSimpleProgramTopLevelStatement((GlobalStatementSyntax)m))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_GlobalStatement, new SourceLocation(globalStatement));\n                            }\n                        }\n                        break;\n\n                    default:\n                        Debug.Assert(\n                            SyntaxFacts.IsTypeDeclaration(m.Kind()) ||\n                            m.Kind() == SyntaxKind.NamespaceDeclaration ||\n                            m.Kind() == SyntaxKind.IncompleteMember);\n                        break;\n                }\n            } 662511"];
5220 [label="if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                } 662512"];
5221 [label="bool reportMisplacedGlobalCode = !m.HasErrors; 662513"];
5222 [label="switch (m.Kind())\n                {\n                    case SyntaxKind.FieldDeclaration:\n                        {\n                            var fieldSyntax = (FieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            bool modifierErrors;\n                            var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors);\n                            foreach (var variable in fieldSyntax.Declaration.Variables)\n                            {\n                                var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics);\n                                builder.NonTypeMembers.Add(fieldSymbol);\n                                // All fields are included in the nullable context for constructors and initializers, even fields without\n                                // initializers, to ensure warnings are reported for uninitialized non-nullable fields in NullableWalker.\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable);\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                }\n\n                                if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.MethodDeclaration:\n                        {\n                            var methodSyntax = (MethodDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(methodSyntax.Identifier));\n                            }\n\n                            var method = SourceOrdinaryMethodSymbol.CreateMethodSymbol(this, bodyBinder, methodSyntax, compilation.IsNullableAnalysisEnabledIn(methodSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.ConstructorDeclaration:\n                        {\n                            var constructorSyntax = (ConstructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(constructorSyntax.Identifier));\n                            }\n\n                            bool isNullableEnabled = compilation.IsNullableAnalysisEnabledIn(constructorSyntax);\n                            var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics);\n                            builder.NonTypeMembers.Add(constructor);\n                            if (constructorSyntax.Initializer?.Kind() != SyntaxKind.ThisConstructorInitializer)\n                            {\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.DestructorDeclaration:\n                        {\n                            var destructorSyntax = (DestructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(destructorSyntax.Identifier));\n                            }\n\n                            // CONSIDER: if this doesn't (directly or indirectly) override object.Finalize, the\n                            // runtime won't consider it a finalizer and it will not be marked as a destructor\n                            // when it is loaded from metadata.  Perhaps we should just treat it as an Ordinary\n                            // method in such cases?\n                            var destructor = new SourceDestructorSymbol(this, destructorSyntax, compilation.IsNullableAnalysisEnabledIn(destructorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(destructor);\n                        }\n                        break;\n\n                    case SyntaxKind.PropertyDeclaration:\n                        {\n                            var propertySyntax = (PropertyDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(propertySyntax.Identifier));\n                            }\n\n                            var property = SourcePropertySymbol.Create(this, bodyBinder, propertySyntax, diagnostics);\n                            builder.NonTypeMembers.Add(property);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.SetMethod);\n                            FieldSymbol backingField = property.BackingField;\n\n                            // TODO: can we leave this out of the member list?\n                            // From the 10/12/11 design notes:\n                            //   In addition, we will change autoproperties to behavior in\n                            //   a similar manner and make the autoproperty fields private.\n                            if ((object)backingField != null)\n                            {\n                                builder.NonTypeMembers.Add(backingField);\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: backingField.IsStatic, compilation, propertySyntax);\n\n                                var initializer = propertySyntax.Initializer;\n                                if (initializer != null)\n                                {\n                                    if (IsScriptClass)\n                                    {\n                                        // also gather expression-declared variables from the initializer\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                                                      initializer,\n                                                                                      this,\n                                                                                      DeclarationModifiers.Private | (property.IsStatic ? DeclarationModifiers.Static : 0),\n                                                                                      backingField);\n                                    }\n\n                                    if (property.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, backingField, initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, backingField, initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventFieldDeclaration:\n                        {\n                            var eventFieldSyntax = (EventFieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(\n                                    ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventFieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            foreach (VariableDeclaratorSyntax declarator in eventFieldSyntax.Declaration.Variables)\n                            {\n                                SourceFieldLikeEventSymbol @event = new SourceFieldLikeEventSymbol(this, bodyBinder, eventFieldSyntax.Modifiers, declarator, diagnostics);\n                                builder.NonTypeMembers.Add(@event);\n\n                                FieldSymbol? associatedField = @event.AssociatedField;\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, declarator, this,\n                                                            DeclarationModifiers.Private | (@event.IsStatic ? DeclarationModifiers.Static : 0),\n                                                            associatedField);\n                                }\n\n                                if ((object?)associatedField != null)\n                                {\n                                    // NOTE: specifically don't add the associated field to the members list\n                                    // (regard it as an implementation detail).\n\n                                    builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: associatedField.IsStatic, compilation, declarator);\n\n                                    if (declarator.Initializer != null)\n                                    {\n                                        if (associatedField.IsStatic)\n                                        {\n                                            AddInitializer(ref staticInitializers, associatedField, declarator.Initializer);\n                                        }\n                                        else\n                                        {\n                                            AddInitializer(ref instanceInitializers, associatedField, declarator.Initializer);\n                                        }\n                                    }\n                                }\n\n                                Debug.Assert((object)@event.AddMethod != null);\n                                Debug.Assert((object)@event.RemoveMethod != null);\n\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventDeclaration:\n                        {\n                            var eventSyntax = (EventDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventSyntax.Identifier));\n                            }\n\n                            var @event = new SourceCustomEventSymbol(this, bodyBinder, eventSyntax, diagnostics);\n\n                            builder.NonTypeMembers.Add(@event);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n\n                            Debug.Assert(@event.AssociatedField is null);\n                        }\n                        break;\n\n                    case SyntaxKind.IndexerDeclaration:\n                        {\n                            var indexerSyntax = (IndexerDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(indexerSyntax.ThisKeyword));\n                            }\n\n                            var indexer = SourcePropertySymbol.Create(this, bodyBinder, indexerSyntax, diagnostics);\n                            builder.HaveIndexers = true;\n                            builder.NonTypeMembers.Add(indexer);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.SetMethod);\n                        }\n                        break;\n\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        {\n                            var conversionOperatorSyntax = (ConversionOperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(conversionOperatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedConversionSymbol.CreateUserDefinedConversionSymbol(\n                                this, conversionOperatorSyntax, compilation.IsNullableAnalysisEnabledIn(conversionOperatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.OperatorDeclaration:\n                        {\n                            var operatorSyntax = (OperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(operatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedOperatorSymbol.CreateUserDefinedOperatorSymbol(\n                                this, operatorSyntax, compilation.IsNullableAnalysisEnabledIn(operatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.GlobalStatement:\n                        {\n                            var globalStatement = ((GlobalStatementSyntax)m).Statement;\n\n                            if (IsScriptClass)\n                            {\n                                var innerStatement = globalStatement;\n\n                                // drill into any LabeledStatements\n                                while (innerStatement.Kind() == SyntaxKind.LabeledStatement)\n                                {\n                                    innerStatement = ((LabeledStatementSyntax)innerStatement).Statement;\n                                }\n\n                                switch (innerStatement.Kind())\n                                {\n                                    case SyntaxKind.LocalDeclarationStatement:\n                                        // We shouldn't reach this place, but field declarations preceded with a label end up here.\n                                        // This is tracked by https://github.com/dotnet/roslyn/issues/13712. Let's do our best for now.\n                                        var decl = (LocalDeclarationStatementSyntax)innerStatement;\n                                        foreach (var vdecl in decl.Declaration.Variables)\n                                        {\n                                            // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                            ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, vdecl, this, DeclarationModifiers.Private,\n                                                                                          containingFieldOpt: null);\n                                        }\n                                        break;\n\n                                    case SyntaxKind.ExpressionStatement:\n                                    case SyntaxKind.IfStatement:\n                                    case SyntaxKind.YieldReturnStatement:\n                                    case SyntaxKind.ReturnStatement:\n                                    case SyntaxKind.ThrowStatement:\n                                    case SyntaxKind.SwitchStatement:\n                                    case SyntaxKind.LockStatement:\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                  innerStatement,\n                                                  this,\n                                                  DeclarationModifiers.Private,\n                                                  containingFieldOpt: null);\n                                        break;\n\n                                    default:\n                                        // no other statement introduces variables into the enclosing scope\n                                        break;\n                                }\n\n                                AddInitializer(ref instanceInitializers, null, globalStatement);\n                            }\n                            else if (reportMisplacedGlobalCode && !SyntaxFacts.IsSimpleProgramTopLevelStatement((GlobalStatementSyntax)m))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_GlobalStatement, new SourceLocation(globalStatement));\n                            }\n                        }\n                        break;\n\n                    default:\n                        Debug.Assert(\n                            SyntaxFacts.IsTypeDeclaration(m.Kind()) ||\n                            m.Kind() == SyntaxKind.NamespaceDeclaration ||\n                            m.Kind() == SyntaxKind.IncompleteMember);\n                        break;\n                } 662514"];
5223 [label="var fieldSyntax = (FieldDeclarationSyntax)m; 662515"];
5224 [label="IsImplicitClass 662516"];
5225 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.ImplicitClass;\n            } 662517"];
5226 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.ImplicitClass; 662518"];
5227 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.ImplicitClass; 662519"];
5228 [label="if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            } 662520"];
5229 [label="bool modifierErrors; 662521"];
5230 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 662522"];
5231 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 662523"];
5232 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 662524"];
5233 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 662525"];
5234 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 662526"];
5235 [label="SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors) 662527"];
5236 [label="param MakeModifiers(NamedTypeSymbol containingType) 662528"];
5237 [label="param MakeModifiers(SyntaxToken firstIdentifier) 662529"];
5238 [label="param MakeModifiers(SyntaxTokenList modifiers) 662530"];
5239 [label="param MakeModifiers(DiagnosticBag diagnostics) 662531"];
5240 [label="param MakeModifiers(out bool modifierErrors) 662532"];
5241 [label="containingType.IsInterface 662533"];
5242 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 662534"];
5243 [label="this.TypeKind 662535"];
5244 [label="get\n            {\n                return _flags.TypeKind;\n            } 662536"];
5245 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 662537"];
5246 [label="return this.TypeKind == TypeKind.Interface; 662538"];
5247 [label="DeclarationModifiers defaultAccess =\n                (containingType.IsInterface) ? DeclarationModifiers.Public : DeclarationModifiers.Private; 662539"];
5248 [label="(containingType.IsInterface) 662540"];
5249 [label="DeclarationModifiers allowedModifiers =\n                DeclarationModifiers.AccessibilityMask |\n                DeclarationModifiers.Const |\n                DeclarationModifiers.New |\n                DeclarationModifiers.ReadOnly |\n                DeclarationModifiers.Static |\n                DeclarationModifiers.Volatile |\n                DeclarationModifiers.Fixed |\n                DeclarationModifiers.Unsafe |\n                DeclarationModifiers.Abstract; 662541"];
5250 [label="var errorLocation = new SourceLocation(firstIdentifier); 662542"];
5251 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 662543"];
5252 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 662544"];
5253 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 662545"];
5254 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 662546"];
5255 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 662547"];
5256 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 662548"];
5257 [label="ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors) 662549"];
5258 [label="param MakeAndCheckNontypeMemberModifiers(SyntaxTokenList modifiers) 662550"];
5259 [label="param MakeAndCheckNontypeMemberModifiers(DeclarationModifiers defaultAccess) 662551"];
5260 [label="param MakeAndCheckNontypeMemberModifiers(DeclarationModifiers allowedModifiers) 662552"];
5261 [label="param MakeAndCheckNontypeMemberModifiers(Location errorLocation) 662553"];
5262 [label="param MakeAndCheckNontypeMemberModifiers(DiagnosticBag diagnostics) 662554"];
5263 [label="param MakeAndCheckNontypeMemberModifiers(out bool modifierErrors) 662555"];
5264 [label="var result = modifiers.ToDeclarationModifiers(diagnostics); 662556"];
5265 [label="var result = modifiers.ToDeclarationModifiers(diagnostics); 662557"];
5266 [label="modifiers.ToDeclarationModifiers(diagnostics) 662558"];
5267 [label="param ToDeclarationModifiers(this SyntaxTokenList modifiers) 662559"];
5268 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 662560"];
5269 [label="bool seenNoDuplicates = true; 662561"];
5270 [label="bool seenNoAccessibilityDuplicates = true; 662562"];
5271 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 662563"];
5272 [label="var result = modifiers.ToDeclarationModifiers(diagnostics); 662564"];
5273 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 662565"];
5274 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 662566"];
5275 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 662567"];
5276 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 662568"];
5277 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 662569"];
5278 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 662570"];
5279 [label="CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors) 662571"];
5280 [label="param CheckModifiers(DeclarationModifiers modifiers) 662572"];
5281 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 662573"];
5282 [label="param CheckModifiers(Location errorLocation) 662574"];
5283 [label="param CheckModifiers(DiagnosticBag diagnostics) 662575"];
5284 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 662576"];
5285 [label="param CheckModifiers(out bool modifierErrors) 662577"];
5286 [label="modifierErrors = false; 662578"];
5287 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 662579"];
5288 [label="DeclarationModifiers result = modifiers & allowedModifiers; 662580"];
5289 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 662581"];
5290 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 662582"];
5291 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 662583"];
5292 [label="return result; 662584"];
5293 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 662585"];
5294 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 662586"];
5295 [label="result |= defaultAccess; 662587"];
5296 [label="return result; 662588"];
5297 [label="if ((result & DeclarationModifiers.Abstract) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractField, errorLocation);\n                result &= ~DeclarationModifiers.Abstract;\n            } 662589"];
5298 [label="if ((result & DeclarationModifiers.Abstract) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractField, errorLocation);\n                result &= ~DeclarationModifiers.Abstract;\n            } 662590"];
5299 [label="if ((result & DeclarationModifiers.Fixed) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The modifier 'static' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.StaticKeyword));\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Const) != 0)\n                {\n                    // The modifier 'const' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ConstKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                result &= ~(DeclarationModifiers.Static | DeclarationModifiers.ReadOnly | DeclarationModifiers.Const | DeclarationModifiers.Volatile);\n                Debug.Assert((result & ~(DeclarationModifiers.AccessibilityMask | DeclarationModifiers.Fixed | DeclarationModifiers.Unsafe | DeclarationModifiers.New)) == 0);\n            } 662591"];
5300 [label="if ((result & DeclarationModifiers.Fixed) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The modifier 'static' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.StaticKeyword));\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Const) != 0)\n                {\n                    // The modifier 'const' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ConstKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                result &= ~(DeclarationModifiers.Static | DeclarationModifiers.ReadOnly | DeclarationModifiers.Const | DeclarationModifiers.Volatile);\n                Debug.Assert((result & ~(DeclarationModifiers.AccessibilityMask | DeclarationModifiers.Fixed | DeclarationModifiers.Unsafe | DeclarationModifiers.New)) == 0);\n            } 662592"];
5301 [label="if ((result & DeclarationModifiers.Const) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The constant '{0}' cannot be marked static\n                    diagnostics.Add(ErrorCode.ERR_StaticConstant, errorLocation, firstIdentifier.ValueText);\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Unsafe) != 0)\n                {\n                    // The modifier 'unsafe' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.UnsafeKeyword));\n                }\n\n                result |= DeclarationModifiers.Static; // 'constants are considered static members'\n            }\n            else\n            {\n                // NOTE: always cascading on a const, so suppress.\n                // NOTE: we're being a bit sneaky here - we're using the containingType rather than this symbol\n                // to determine whether or not unsafe is allowed.  Since this symbol and the containing type are\n                // in the same compilation, it won't make a difference.  We do, however, have to pass the error\n                // location explicitly.\n                containingType.CheckUnsafeModifier(result, errorLocation, diagnostics);\n            } 662593"];
5302 [label="if ((result & DeclarationModifiers.Const) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The constant '{0}' cannot be marked static\n                    diagnostics.Add(ErrorCode.ERR_StaticConstant, errorLocation, firstIdentifier.ValueText);\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Unsafe) != 0)\n                {\n                    // The modifier 'unsafe' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.UnsafeKeyword));\n                }\n\n                result |= DeclarationModifiers.Static; // 'constants are considered static members'\n            }\n            else\n            {\n                // NOTE: always cascading on a const, so suppress.\n                // NOTE: we're being a bit sneaky here - we're using the containingType rather than this symbol\n                // to determine whether or not unsafe is allowed.  Since this symbol and the containing type are\n                // in the same compilation, it won't make a difference.  We do, however, have to pass the error\n                // location explicitly.\n                containingType.CheckUnsafeModifier(result, errorLocation, diagnostics);\n            } 662594"];
5303 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 662595"];
5304 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 662596"];
5305 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 662597"];
5306 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 662598"];
5307 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics) 662599"];
5308 [label="param CheckUnsafeModifier(this Symbol symbol) 662600"];
5309 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 662601"];
5310 [label="param CheckUnsafeModifier(Location errorLocation) 662602"];
5311 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 662603"];
5312 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 662604"];
5313 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 662605"];
5314 [label="return result; 662606"];
5315 [label="foreach (var variable in fieldSyntax.Declaration.Variables)\n                            {\n                                var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics);\n                                builder.NonTypeMembers.Add(fieldSymbol);\n                                // All fields are included in the nullable context for constructors and initializers, even fields without\n                                // initializers, to ensure warnings are reported for uninitialized non-nullable fields in NullableWalker.\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable);\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                }\n\n                                if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                }\n                            } 662607"];
5316 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 662608"];
5317 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 662609"];
5318 [label="(modifiers & DeclarationModifiers.Fixed) == 0 662610"];
5319 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 662611"];
5320 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 662612"];
5321 [label="new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics) 662613"];
5322 [label="param SourceMemberFieldSymbolFromDeclarator(SourceMemberContainerTypeSymbol containingType) 662614"];
5323 [label="param SourceMemberFieldSymbolFromDeclarator(VariableDeclaratorSyntax declarator) 662615"];
5324 [label="param SourceMemberFieldSymbolFromDeclarator(DeclarationModifiers modifiers) 662616"];
5325 [label="param SourceMemberFieldSymbolFromDeclarator(bool modifierErrors) 662617"];
5326 [label="param SourceMemberFieldSymbolFromDeclarator(DiagnosticBag diagnostics) 662618"];
5327 [label="param SourceMemberFieldSymbolFromDeclarator(this) 662619"];
5328 [label="containingType 662620"];
5329 [label="modifiers 662621"];
5330 [label="declarator.Identifier.ValueText 662622"];
5331 [label="declarator.GetReference() 662623"];
5332 [label="declarator.Identifier 662624"];
5333 [label="declarator.Identifier 662625"];
5334 [label="param SourceMemberFieldSymbol(SourceMemberContainerTypeSymbol containingType) 662626"];
5335 [label="param SourceMemberFieldSymbol(DeclarationModifiers modifiers) 662627"];
5336 [label="param SourceMemberFieldSymbol(string name) 662628"];
5337 [label="param SourceMemberFieldSymbol(SyntaxReference syntax) 662629"];
5338 [label="param SourceMemberFieldSymbol(Location location) 662630"];
5339 [label="param SourceMemberFieldSymbol(this) 662631"];
5340 [label="containingType 662632"];
5341 [label="name 662633"];
5342 [label="syntax 662634"];
5343 [label="location 662635"];
5344 [label="param SourceMemberFieldSymbol(this) 662636"];
5345 [label="param SourceFieldSymbolWithSyntaxReference(SourceMemberContainerTypeSymbol containingType) 662637"];
5346 [label="param SourceFieldSymbolWithSyntaxReference(string name) 662638"];
5347 [label="param SourceFieldSymbolWithSyntaxReference(SyntaxReference syntax) 662639"];
5348 [label="param SourceFieldSymbolWithSyntaxReference(Location location) 662640"];
5349 [label="param SourceFieldSymbolWithSyntaxReference(this) 662641"];
5350 [label="containingType 662642"];
5351 [label="param SourceFieldSymbolWithSyntaxReference(this) 662643"];
5352 [label="param SourceFieldSymbol(SourceMemberContainerTypeSymbol containingType) 662644"];
5353 [label="param SourceFieldSymbol(this) 662645"];
5354 [label="param SourceFieldSymbol(this) 662646"];
5355 [label="param FieldSymbolWithAttributesAndModifiers(this) 662647"];
5356 [label="param FieldSymbolWithAttributesAndModifiers(this) 662648"];
5357 [label="param FieldSymbol(this) 662649"];
5358 [label="param FieldSymbol(this) 662650"];
5359 [label="_lazyAdapter 662651"];
5360 [label="_lazyCustomAttributesBag 662652"];
5361 [label="containingType 662653"];
5362 [label="Debug.Assert((object)containingType != null); 662654"];
5363 [label="Debug.Assert((object)containingType != null); 662655"];
5364 [label="this.containingType 662656"];
5365 [label="_name 662657"];
5366 [label="_location 662658"];
5367 [label="_syntaxReference 662659"];
5368 [label="_lazyDocComment 662660"];
5369 [label="_lazyExpandedDocComment 662661"];
5370 [label="_lazyConstantEarlyDecodingValue = Microsoft.CodeAnalysis.ConstantValue.Unset 662662"];
5371 [label="_lazyConstantValue = Microsoft.CodeAnalysis.ConstantValue.Unset 662663"];
5372 [label="Debug.Assert(name != null); 662664"];
5373 [label="Debug.Assert(name != null); 662665"];
5374 [label="Debug.Assert(syntax != null); 662666"];
5375 [label="Debug.Assert(syntax != null); 662667"];
5376 [label="Debug.Assert(location != null); 662668"];
5377 [label="Debug.Assert(location != null); 662669"];
5378 [label="_name 662670"];
5379 [label="_syntaxReference 662671"];
5380 [label="_location 662672"];
5381 [label="_modifiers 662673"];
5382 [label="_modifiers 662674"];
5383 [label="declarator.Identifier 662675"];
5384 [label="declarator.Identifier.GetLocation() 662676"];
5385 [label="param SourceMemberFieldSymbolFromDeclarator(this) 662677"];
5386 [label="param SourceMemberFieldSymbolFromDeclarator(this) 662678"];
5387 [label="_hasInitializer 662679"];
5388 [label="_lazyType 662680"];
5389 [label="_lazyFieldTypeInferred 662681"];
5390 [label="_hasInitializer = declarator.Initializer != null; 662682"];
5391 [label="_hasInitializer = declarator.Initializer != null; 662683"];
5392 [label="_hasInitializer 662684"];
5393 [label="this.CheckAccessibility(diagnostics); 662685"];
5394 [label="this.CheckAccessibility(diagnostics) 662686"];
5395 [label="param CheckAccessibility(DiagnosticBag diagnostics) 662687"];
5396 [label="param CheckAccessibility(this) 662688"];
5397 [label="Modifiers 662689"];
5398 [label="get\n            {\n                return _modifiers;\n            } 662690"];
5399 [label="return _modifiers; 662691"];
5400 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 662692"];
5401 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 662693"];
5402 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 662694"];
5403 [label="ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false) 662695"];
5404 [label="param CheckAccessibility(DeclarationModifiers modifiers) 662696"];
5405 [label="param CheckAccessibility(Symbol symbol) 662697"];
5406 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 662698"];
5407 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 662699"];
5408 [label="IsValidAccessibility(modifiers) 662700"];
5409 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 662701"];
5410 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 662702"];
5411 [label="return true; 662703"];
5412 [label="symbol.Kind 662704"];
5413 [label="get\n            {\n                return SymbolKind.Field;\n            } 662705"];
5414 [label="return SymbolKind.Field; 662706"];
5415 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 662707"];
5416 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 662708"];
5417 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 662709"];
5418 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 662710"];
5419 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 662711"];
5420 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 662712"];
5421 [label="return null; 662713"];
5422 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 662714"];
5423 [label="if (info != null)\n            {\n                diagnostics.Add(new CSDiagnostic(info, this.ErrorLocation));\n            } 662715"];
5424 [label="if (info != null)\n            {\n                diagnostics.Add(new CSDiagnostic(info, this.ErrorLocation));\n            } 662716"];
5425 [label="this.CheckAccessibility(diagnostics); 662717"];
5426 [label="if (!modifierErrors)\n            {\n                this.ReportModifiersDiagnostics(diagnostics);\n            } 662718"];
5427 [label="this.ReportModifiersDiagnostics(diagnostics); 662719"];
5428 [label="this.ReportModifiersDiagnostics(diagnostics) 662720"];
5429 [label="param ReportModifiersDiagnostics(DiagnosticBag diagnostics) 662721"];
5430 [label="param ReportModifiersDiagnostics(this) 662722"];
5431 [label="ContainingType 662723"];
5432 [label="get\n            {\n                return this.containingType;\n            } 662724"];
5433 [label="return this.containingType; 662725"];
5434 [label="if (ContainingType.IsSealed && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(containingType), ErrorLocation, this);\n            }\n            else if (IsVolatile && IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_VolatileAndReadonly, ErrorLocation, this);\n            }\n            else if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 662726"];
5435 [label="ContainingType.IsSealed 662727"];
5436 [label="=> HasFlag(DeclarationModifiers.Sealed) 662728"];
5437 [label="DeclarationModifiers.Sealed 662729"];
5438 [label="HasFlag(DeclarationModifiers.Sealed) 662730"];
5439 [label="param HasFlag(DeclarationModifiers flag) 662731"];
5440 [label="=> (_declModifiers & flag) != 0 662732"];
5441 [label="_declModifiers & flag 662733"];
5442 [label="0 662734"];
5443 [label="(_declModifiers & flag) != 0 662735"];
5444 [label="IsVolatile 662736"];
5445 [label="=> (Modifiers & DeclarationModifiers.Volatile) != 0 662737"];
5446 [label="Modifiers 662738"];
5447 [label="get\n            {\n                return _modifiers;\n            } 662739"];
5448 [label="return _modifiers; 662740"];
5449 [label="Modifiers & DeclarationModifiers.Volatile 662741"];
5450 [label="0 662742"];
5451 [label="(Modifiers & DeclarationModifiers.Volatile) != 0 662743"];
5452 [label="if (IsVolatile && IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_VolatileAndReadonly, ErrorLocation, this);\n            }\n            else if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 662744"];
5453 [label="containingType.IsStatic 662745"];
5454 [label="=> HasFlag(DeclarationModifiers.Static) 662746"];
5455 [label="DeclarationModifiers.Static 662747"];
5456 [label="HasFlag(DeclarationModifiers.Static) 662748"];
5457 [label="param HasFlag(DeclarationModifiers flag) 662749"];
5458 [label="=> (_declModifiers & flag) != 0 662750"];
5459 [label="_declModifiers & flag 662751"];
5460 [label="if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 662752"];
5461 [label="IsStatic 662753"];
5462 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 662754"];
5463 [label="Modifiers 662755"];
5464 [label="get\n            {\n                return _modifiers;\n            } 662756"];
5465 [label="Modifiers & DeclarationModifiers.Static 662757"];
5466 [label="0 662758"];
5467 [label="(Modifiers & DeclarationModifiers.Static) != 0 662759"];
5468 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 662760"];
5469 [label="IsReadOnly 662761"];
5470 [label="=> (Modifiers & DeclarationModifiers.ReadOnly) != 0 662762"];
5471 [label="Modifiers 662763"];
5472 [label="get\n            {\n                return _modifiers;\n            } 662764"];
5473 [label="Modifiers & DeclarationModifiers.ReadOnly 662765"];
5474 [label="0 662766"];
5475 [label="(Modifiers & DeclarationModifiers.ReadOnly) != 0 662767"];
5476 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 662768"];
5477 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 662769"];
5478 [label="containingType.IsReadOnly 662770"];
5479 [label="=> HasFlag(DeclarationModifiers.ReadOnly) 662771"];
5480 [label="DeclarationModifiers.ReadOnly 662772"];
5481 [label="HasFlag(DeclarationModifiers.ReadOnly) 662773"];
5482 [label="param HasFlag(DeclarationModifiers flag) 662774"];
5483 [label="=> (_declModifiers & flag) != 0 662775"];
5484 [label="_declModifiers & flag 662776"];
5485 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 662777"];
5486 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 662778"];
5487 [label="this.ReportModifiersDiagnostics(diagnostics); 662779"];
5488 [label="containingType.IsInterface 662780"];
5489 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 662781"];
5490 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 662782"];
5491 [label="if (containingType.IsInterface)\n            {\n                if (this.IsStatic)\n                {\n                    Binder.CheckFeatureAvailability(declarator, MessageID.IDS_DefaultInterfaceImplementation, diagnostics, ErrorLocation);\n\n                    if (!ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation, ErrorLocation);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(ErrorCode.ERR_InterfacesCantContainFields, ErrorLocation);\n                }\n            } 662783"];
5492 [label="builder.NonTypeMembers.Add(fieldSymbol); 662784"];
5493 [label="builder.NonTypeMembers.Add(fieldSymbol); 662785"];
5494 [label="fieldSymbol.IsStatic 662786"];
5495 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 662787"];
5496 [label="Modifiers 662788"];
5497 [label="get\n            {\n                return _modifiers;\n            } 662789"];
5498 [label="return _modifiers; 662790"];
5499 [label="Modifiers & DeclarationModifiers.Static 662791"];
5500 [label="0 662792"];
5501 [label="(Modifiers & DeclarationModifiers.Static) != 0 662793"];
5502 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable); 662794"];
5503 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable); 662795"];
5504 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable); 662796"];
5505 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable) 662797"];
5506 [label="param UpdateIsNullableEnabledForConstructorsAndFields(bool useStatic) 662798"];
5507 [label="param UpdateIsNullableEnabledForConstructorsAndFields(CSharpCompilation compilation) 662799"];
5508 [label="param UpdateIsNullableEnabledForConstructorsAndFields(CSharpSyntaxNode syntax) 662800"];
5509 [label="param UpdateIsNullableEnabledForConstructorsAndFields(this) 662801"];
5510 [label="ref bool isNullableEnabled = ref GetIsNullableEnabledForConstructorsAndFields(useStatic); 662802"];
5511 [label="GetIsNullableEnabledForConstructorsAndFields(useStatic) 662803"];
5512 [label="param GetIsNullableEnabledForConstructorsAndFields(bool useStatic) 662804"];
5513 [label="param GetIsNullableEnabledForConstructorsAndFields(this) 662805"];
5514 [label="useStatic 662806"];
5515 [label="IsNullableEnabledForInstanceConstructorsAndFields 662807"];
5516 [label="return ref useStatic ? ref IsNullableEnabledForStaticConstructorsAndFields : ref IsNullableEnabledForInstanceConstructorsAndFields; 662808"];
5517 [label="isNullableEnabled = isNullableEnabled || compilation.IsNullableAnalysisEnabledIn(syntax); 662809"];
5518 [label="compilation.IsNullableAnalysisEnabledIn(syntax) 662810"];
5519 [label="param IsNullableAnalysisEnabledIn(SyntaxNode syntax) 662811"];
5520 [label="param IsNullableAnalysisEnabledIn(this) 662812"];
5521 [label="return IsNullableAnalysisEnabledIn((CSharpSyntaxTree)syntax.SyntaxTree, syntax.Span); 662813"];
5522 [label="IsNullableAnalysisEnabledIn((CSharpSyntaxTree)syntax.SyntaxTree, syntax.Span) 662814"];
5523 [label="param IsNullableAnalysisEnabledIn(CSharpSyntaxTree tree) 662815"];
5524 [label="param IsNullableAnalysisEnabledIn(TextSpan span) 662816"];
5525 [label="param IsNullableAnalysisEnabledIn(this) 662817"];
5526 [label="GetNullableAnalysisValue() 662818"];
5527 [label="param GetNullableAnalysisValue(this) 662819"];
5528 [label="return Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            }; 662820"];
5529 [label="return Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            }; 662821"];
5530 [label="Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            } 662822"];
5531 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 662823"];
5532 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 662824"];
5533 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 662825"];
5534 [label="Options 662826"];
5535 [label="get\n            {\n                return _options;\n            } 662827"];
5536 [label="return _options; 662828"];
5537 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 662829"];
5538 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 662830"];
5539 [label="isNullableEnabled = isNullableEnabled || compilation.IsNullableAnalysisEnabledIn(syntax); 662831"];
5540 [label="IsScriptClass 662832"];
5541 [label="get\n            {\n                var kind = this.declaration.Declarations[0].Kind;\n                return kind == DeclarationKind.Script || kind == DeclarationKind.Submission;\n            } 662833"];
5542 [label="var kind = this.declaration.Declarations[0].Kind; 662834"];
5543 [label="var kind = this.declaration.Declarations[0].Kind; 662835"];
5544 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 662836"];
5545 [label="if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                } 662837"];
5546 [label="if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                } 662838"];
5547 [label="if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                } 662839"];
5548 [label="fieldSymbol.IsStatic 662840"];
5549 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 662841"];
5550 [label="Modifiers 662842"];
5551 [label="get\n            {\n                return _modifiers;\n            } 662843"];
5552 [label="return _modifiers; 662844"];
5553 [label="Modifiers & DeclarationModifiers.Static 662845"];
5554 [label="0 662846"];
5555 [label="(Modifiers & DeclarationModifiers.Static) != 0 662847"];
5556 [label="if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    } 662848"];
5557 [label="AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer); 662849"];
5558 [label="AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer); 662850"];
5559 [label="AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer); 662851"];
5560 [label="AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer) 662852"];
5561 [label="param AddInitializer(ref ArrayBuilder<FieldOrPropertyInitializer>? initializers) 662853"];
5562 [label="param AddInitializer(FieldSymbol? fieldOpt) 662854"];
5563 [label="param AddInitializer(CSharpSyntaxNode node) 662855"];
5564 [label="if (initializers == null)\n            {\n                initializers = ArrayBuilder<FieldOrPropertyInitializer>.GetInstance();\n            }\n            else if (initializers.Count != 0)\n            {\n                // initializers should be added in syntax order:\n                Debug.Assert(node.SyntaxTree == initializers.Last().Syntax.SyntaxTree);\n                Debug.Assert(node.SpanStart > initializers.Last().Syntax.Span.Start);\n            } 662856"];
5565 [label="if (initializers == null)\n            {\n                initializers = ArrayBuilder<FieldOrPropertyInitializer>.GetInstance();\n            }\n            else if (initializers.Count != 0)\n            {\n                // initializers should be added in syntax order:\n                Debug.Assert(node.SyntaxTree == initializers.Last().Syntax.SyntaxTree);\n                Debug.Assert(node.SpanStart > initializers.Last().Syntax.Span.Start);\n            } 662857"];
5566 [label="initializers = ArrayBuilder<FieldOrPropertyInitializer>.GetInstance(); 662858"];
5567 [label="initializers.Add(new FieldOrPropertyInitializer(fieldOpt, node)); 662859"];
5568 [label="initializers.Add(new FieldOrPropertyInitializer(fieldOpt, node)); 662860"];
5569 [label="initializers.Add(new FieldOrPropertyInitializer(fieldOpt, node)); 662861"];
5570 [label="new FieldOrPropertyInitializer(fieldOpt, node) 662862"];
5571 [label="param FieldOrPropertyInitializer(FieldSymbol fieldOpt) 662863"];
5572 [label="param FieldOrPropertyInitializer(SyntaxNode syntax) 662864"];
5573 [label="param FieldOrPropertyInitializer(this) 662865"];
5574 [label="var a1 = syntax.IsKind(SyntaxKind.EqualsValueClause); 662866"];
5575 [label="var a1 = syntax.IsKind(SyntaxKind.EqualsValueClause); 662867"];
5576 [label="var a2 = syntax.IsKind(SyntaxKind.Parameter); 662868"];
5577 [label="var a2 = syntax.IsKind(SyntaxKind.Parameter); 662869"];
5578 [label="var a2 = syntax.IsKind(SyntaxKind.Parameter); 662870"];
5579 [label="var a3 = fieldOpt != null; 662871"];
5580 [label="fieldOpt != null 662872"];
5581 [label="param !=(Symbol left) 662873"];
5582 [label="param !=(Symbol right) 662874"];
5583 [label="if (right is null)\n            {\n                return left is object;\n            } 662875"];
5584 [label="return left is object; 662876"];
5585 [label="var a3 = fieldOpt != null; 662877"];
5586 [label="var a4 = syntax is StatementSyntax; 662878"];
5587 [label="Debug.Assert(((a1 || a2) && a3) || a4); 662879"];
5588 [label="Debug.Assert(((a1 || a2) && a3) || a4); 662880"];
5589 [label="FieldOpt 662881"];
5590 [label="Syntax = syntax.GetReference(); 662882"];
5591 [label="Syntax 662883"];
5592 [label="initializers.Add(new FieldOrPropertyInitializer(fieldOpt, node)); 662884"];
5593 [label="AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer); 662885"];
5594 [label="AddInitializers(builder.InstanceInitializers, instanceInitializers); 662886"];
5595 [label="AddInitializers(builder.InstanceInitializers, instanceInitializers); 662887"];
5596 [label="AddInitializers(builder.InstanceInitializers, instanceInitializers) 662888"];
5597 [label="param AddInitializers(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> allInitializers) 662889"];
5598 [label="param AddInitializers(ArrayBuilder<FieldOrPropertyInitializer>? siblingsOpt) 662890"];
5599 [label="if (siblingsOpt != null)\n            {\n                allInitializers.Add(siblingsOpt);\n            } 662891"];
5600 [label="if (siblingsOpt != null)\n            {\n                allInitializers.Add(siblingsOpt);\n            } 662892"];
5601 [label="allInitializers.Add(siblingsOpt); 662893"];
5602 [label="allInitializers.Add(siblingsOpt); 662894"];
5603 [label="AddInitializers(builder.InstanceInitializers, instanceInitializers); 662895"];
5604 [label="AddInitializers(builder.StaticInitializers, staticInitializers); 662896"];
5605 [label="AddInitializers(builder.StaticInitializers, staticInitializers); 662897"];
5606 [label="AddInitializers(builder.StaticInitializers, staticInitializers) 662898"];
5607 [label="param AddInitializers(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> allInitializers) 662899"];
5608 [label="param AddInitializers(ArrayBuilder<FieldOrPropertyInitializer>? siblingsOpt) 662900"];
5609 [label="if (siblingsOpt != null)\n            {\n                allInitializers.Add(siblingsOpt);\n            } 662901"];
5610 [label="if (siblingsOpt != null)\n            {\n                allInitializers.Add(siblingsOpt);\n            } 662902"];
5611 [label="AddInitializers(builder.StaticInitializers, staticInitializers); 662903"];
5612 [label="AddDeclaredNontypeMembers(builder, diagnostics); 662904"];
5613 [label="TypeKind 662905"];
5614 [label="get\n            {\n                return _flags.TypeKind;\n            } 662906"];
5615 [label="_flags.TypeKind 662907"];
5616 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 662908"];
5617 [label="switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                } 662909"];
5618 [label="IsTupleType 662910"];
5619 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 662911"];
5620 [label="_ 662912"];
5621 [label="tupleCardinality: out _ 662913"];
5622 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 662914"];
5623 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 662915"];
5624 [label="param IsTupleTypeOfCardinality(this) 662916"];
5625 [label="IsUnboundGenericType 662917"];
5626 [label="get\n            {\n                return false;\n            } 662918"];
5627 [label="return false; 662919"];
5628 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 662920"];
5629 [label="ContainingSymbol 662921"];
5630 [label="get\n            {\n                return _containingSymbol;\n            } 662922"];
5631 [label="return _containingSymbol; 662923"];
5632 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 662924"];
5633 [label=".Kind 662925"];
5634 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 662926"];
5635 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 662927"];
5636 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 662928"];
5637 [label="ContainingNamespace 662929"];
5638 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 662930"];
5639 [label="this.ContainingSymbol 662931"];
5640 [label="get\n            {\n                return _containingSymbol;\n            } 662932"];
5641 [label="return _containingSymbol; 662933"];
5642 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 662934"];
5643 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 662935"];
5644 [label="var ns = container as NamespaceSymbol; 662936"];
5645 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 662937"];
5646 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 662938"];
5647 [label="return ns; 662939"];
5648 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 662940"];
5649 [label="ContainingNamespace.ContainingNamespace 662941"];
5650 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 662942"];
5651 [label="this.ContainingSymbol 662943"];
5652 [label="=> _container 662944"];
5653 [label="_container 662945"];
5654 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 662946"];
5655 [label=".IsGlobalNamespace 662947"];
5656 [label="get\n            {\n                return (object)ContainingNamespace == null;\n            } 662948"];
5657 [label="ContainingNamespace 662949"];
5658 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 662950"];
5659 [label="this.ContainingSymbol 662951"];
5660 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 662952"];
5661 [label="container.ContainingSymbol 662953"];
5662 [label="get\n            {\n                return _assemblySymbol;\n            } 662954"];
5663 [label="return _assemblySymbol; 662955"];
5664 [label="get\n            {\n                return null;\n            } 662956"];
5665 [label="return null; 662957"];
5666 [label="return null; 662958"];
5667 [label="return (object)ContainingNamespace == null; 662959"];
5668 [label="return (object)ContainingNamespace == null; 662960"];
5669 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 662961"];
5670 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 662962"];
5671 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 662963"];
5672 [label="Name 662964"];
5673 [label="get\n            {\n                return declaration.Name;\n            } 662965"];
5674 [label="return declaration.Name; 662966"];
5675 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 662967"];
5676 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 662968"];
5677 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 662969"];
5678 [label="tupleCardinality = 0; 662970"];
5679 [label="return false; 662971"];
5680 [label="if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                } 662972"];
5681 [label="if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                } 662973"];
5682 [label="if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                } 662974"];
5683 [label="builder.ToReadOnlyAndFree() 662975"];
5684 [label="param ToReadOnlyAndFree(this) 662976"];
5685 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 662977"];
5686 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 662978"];
5687 [label="MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers) 662979"];
5688 [label="param ToReadOnlyAndFree(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> initializers) 662980"];
5689 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 662981"];
5690 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 662982"];
5691 [label="initializers.Free(); 662983"];
5692 [label="return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty; 662984"];
5693 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 662985"];
5694 [label="MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers) 662986"];
5695 [label="param ToReadOnlyAndFree(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> initializers) 662987"];
5696 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 662988"];
5697 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 662989"];
5698 [label="var builder = ArrayBuilder<ImmutableArray<FieldOrPropertyInitializer>>.GetInstance(initializers.Count); 662990"];
5699 [label="foreach (ArrayBuilder<FieldOrPropertyInitializer> group in initializers)\n                {\n                    builder.Add(group.ToImmutableAndFree());\n                } 662991"];
5700 [label="foreach (ArrayBuilder<FieldOrPropertyInitializer> group in initializers)\n                {\n                    builder.Add(group.ToImmutableAndFree());\n                } 662992"];
5701 [label="builder.Add(group.ToImmutableAndFree()); 662993"];
5702 [label="builder.Add(group.ToImmutableAndFree()); 662994"];
5703 [label="initializers.Free(); 662995"];
5704 [label="return builder.ToImmutableAndFree(); 662996"];
5705 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 662997"];
5706 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 662998"];
5707 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 662999"];
5708 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 663000"];
5709 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 663001"];
5710 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 663002"];
5711 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 663003"];
5712 [label="new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields) 663004"];
5713 [label="param DeclaredMembersAndInitializers(ImmutableArray<Symbol> nonTypeMembers) 663005"];
5714 [label="param DeclaredMembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> staticInitializers) 663006"];
5715 [label="param DeclaredMembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> instanceInitializers) 663007"];
5716 [label="param DeclaredMembersAndInitializers(bool haveIndexers) 663008"];
5717 [label="param DeclaredMembersAndInitializers(RecordDeclarationSyntax? recordDeclarationWithParameters) 663009"];
5718 [label="param DeclaredMembersAndInitializers(SynthesizedRecordConstructor? recordPrimaryConstructor) 663010"];
5719 [label="param DeclaredMembersAndInitializers(int instanceInitializersIndexForRecordDeclarationWithParameters) 663011"];
5720 [label="param DeclaredMembersAndInitializers(bool isNullableEnabledForInstanceConstructorsAndFields) 663012"];
5721 [label="param DeclaredMembersAndInitializers(bool isNullableEnabledForStaticConstructorsAndFields) 663013"];
5722 [label="param DeclaredMembersAndInitializers(this) 663014"];
5723 [label="HaveIndexers 663015"];
5724 [label="RecordDeclarationWithParameters 663016"];
5725 [label="RecordPrimaryConstructor 663017"];
5726 [label="InstanceInitializersIndexForRecordDeclarationWithParameters 663018"];
5727 [label="IsNullableEnabledForInstanceConstructorsAndFields 663019"];
5728 [label="IsNullableEnabledForStaticConstructorsAndFields 663020"];
5729 [label="Debug.Assert(!nonTypeMembers.IsDefault); 663021"];
5730 [label="Debug.Assert(!staticInitializers.IsDefault); 663022"];
5731 [label="Debug.Assert(!instanceInitializers.IsDefault); 663023"];
5732 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 663024"];
5733 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 663025"];
5734 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 663026"];
5735 [label="Debug.Assert(recordDeclarationWithParameters is object == recordPrimaryConstructor is object); 663027"];
5736 [label="this.NonTypeMembers 663028"];
5737 [label="this.StaticInitializers 663029"];
5738 [label="this.InstanceInitializers 663030"];
5739 [label="this.HaveIndexers 663031"];
5740 [label="this.RecordDeclarationWithParameters 663032"];
5741 [label="this.RecordPrimaryConstructor 663033"];
5742 [label="this.InstanceInitializersIndexForRecordDeclarationWithParameters 663034"];
5743 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 663035"];
5744 [label="this.IsNullableEnabledForStaticConstructorsAndFields 663036"];
5745 [label="return builder.ToReadOnlyAndFree(); 663037"];
5746 [label="declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics); 663038"];
5747 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 663039"];
5748 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 663040"];
5749 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 663041"];
5750 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 663042"];
5751 [label="if (alreadyKnown != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    diagnostics.Free();\n                    return alreadyKnown;\n                } 663043"];
5752 [label="AddDeclarationDiagnostics(diagnostics); 663044"];
5753 [label="AddDeclarationDiagnostics(diagnostics) 663045"];
5754 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 663046"];
5755 [label="param AddDeclarationDiagnostics(this) 663047"];
5756 [label="ContainingSymbol 663048"];
5757 [label="get\n            {\n                return _containingSymbol;\n            } 663049"];
5758 [label="return _containingSymbol; 663050"];
5759 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 663051"];
5760 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 663052"];
5761 [label="AddDeclarationDiagnostics(diagnostics); 663053"];
5762 [label="diagnostics.Free(); 663054"];
5763 [label="return declaredMembersAndInitializers!; 663055"];
5764 [label="var declaredMembersAndInitializers = getDeclaredMembersAndInitializers(); 663056"];
5765 [label="if (declaredMembersAndInitializers is null)\n            {\n                // Another thread completed the work before this one\n                return null;\n            } 663057"];
5766 [label="var membersAndInitializersBuilder = new MembersAndInitializersBuilder(declaredMembersAndInitializers); 663058"];
5767 [label="var membersAndInitializersBuilder = new MembersAndInitializersBuilder(declaredMembersAndInitializers); 663059"];
5768 [label="new MembersAndInitializersBuilder(declaredMembersAndInitializers) 663060"];
5769 [label="param MembersAndInitializersBuilder(DeclaredMembersAndInitializers declaredMembersAndInitializers) 663061"];
5770 [label="param MembersAndInitializersBuilder(this) 663062"];
5771 [label="NonTypeMembers 663063"];
5772 [label="InstanceInitializersForPositionalMembers 663064"];
5773 [label="IsNullableEnabledForInstanceConstructorsAndFields 663065"];
5774 [label="IsNullableEnabledForStaticConstructorsAndFields 663066"];
5775 [label="Debug.Assert(declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel); 663067"];
5776 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 663068"];
5777 [label="this.IsNullableEnabledForStaticConstructorsAndFields 663069"];
5778 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 663070"];
5779 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 663071"];
5780 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 663072"];
5781 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics) 663073"];
5782 [label="param AddSynthesizedMembers(MembersAndInitializersBuilder builder) 663074"];
5783 [label="param AddSynthesizedMembers(DeclaredMembersAndInitializers declaredMembersAndInitializers) 663075"];
5784 [label="param AddSynthesizedMembers(DiagnosticBag diagnostics) 663076"];
5785 [label="param AddSynthesizedMembers(this) 663077"];
5786 [label="TypeKind 663078"];
5787 [label="get\n            {\n                return _flags.TypeKind;\n            } 663079"];
5788 [label="_flags.TypeKind 663080"];
5789 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 663081"];
5790 [label="switch (TypeKind)\n            {\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                case TypeKind.Class:\n                case TypeKind.Interface:\n                case TypeKind.Submission:\n                    AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics);\n                    AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics);\n                    break;\n\n                default:\n                    break;\n            } 663082"];
5791 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 663083"];
5792 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 663084"];
5793 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 663085"];
5794 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics) 663086"];
5795 [label="param AddSynthesizedRecordMembersIfNecessary(MembersAndInitializersBuilder builder) 663087"];
5796 [label="param AddSynthesizedRecordMembersIfNecessary(DeclaredMembersAndInitializers declaredMembersAndInitializers) 663088"];
5797 [label="param AddSynthesizedRecordMembersIfNecessary(DiagnosticBag diagnostics) 663089"];
5798 [label="param AddSynthesizedRecordMembersIfNecessary(this) 663090"];
5799 [label="if (declaration.Kind != DeclarationKind.Record)\n            {\n                return;\n            } 663091"];
5800 [label="return; 663092"];
5801 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 663093"];
5802 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 663094"];
5803 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 663095"];
5804 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 663096"];
5805 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics) 663097"];
5806 [label="param AddSynthesizedConstructorsIfNecessary(MembersAndInitializersBuilder builder) 663098"];
5807 [label="param AddSynthesizedConstructorsIfNecessary(DeclaredMembersAndInitializers declaredMembersAndInitializers) 663099"];
5808 [label="param AddSynthesizedConstructorsIfNecessary(DiagnosticBag diagnostics) 663100"];
5809 [label="param AddSynthesizedConstructorsIfNecessary(this) 663101"];
5810 [label="var hasInstanceConstructor = false; 663102"];
5811 [label="var hasParameterlessInstanceConstructor = false; 663103"];
5812 [label="var hasStaticConstructor = false; 663104"];
5813 [label="var membersSoFar = builder.GetNonTypeMembers(declaredMembersAndInitializers); 663105"];
5814 [label="builder.GetNonTypeMembers(declaredMembersAndInitializers) 663106"];
5815 [label="param GetNonTypeMembers(DeclaredMembersAndInitializers declaredMembers) 663107"];
5816 [label="param GetNonTypeMembers(this) 663108"];
5817 [label="return NonTypeMembers ?? (IReadOnlyCollection<Symbol>)declaredMembers.NonTypeMembers; 663109"];
5818 [label="return NonTypeMembers ?? (IReadOnlyCollection<Symbol>)declaredMembers.NonTypeMembers; 663110"];
5819 [label="foreach (var member in membersSoFar)\n            {\n                if (member.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)member;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Constructor:\n                            // Ignore the record copy constructor\n                            if (!IsRecord ||\n                                !(SynthesizedRecordCopyCtor.HasCopyConstructorSignature(method) && method is not SynthesizedRecordConstructor))\n                            {\n                                hasInstanceConstructor = true;\n                                hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0;\n                            }\n                            break;\n\n                        case MethodKind.StaticConstructor:\n                            hasStaticConstructor = true;\n                            break;\n                    }\n                }\n\n                //kick out early if we've seen everything we're looking for\n                if (hasInstanceConstructor && hasStaticConstructor)\n                {\n                    break;\n                }\n            } 663111"];
5820 [label="member.Kind 663112"];
5821 [label="get\n            {\n                return SymbolKind.Field;\n            } 663113"];
5822 [label="return SymbolKind.Field; 663114"];
5823 [label="if (member.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)member;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Constructor:\n                            // Ignore the record copy constructor\n                            if (!IsRecord ||\n                                !(SynthesizedRecordCopyCtor.HasCopyConstructorSignature(method) && method is not SynthesizedRecordConstructor))\n                            {\n                                hasInstanceConstructor = true;\n                                hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0;\n                            }\n                            break;\n\n                        case MethodKind.StaticConstructor:\n                            hasStaticConstructor = true;\n                            break;\n                    }\n                } 663115"];
5824 [label="if (hasInstanceConstructor && hasStaticConstructor)\n                {\n                    break;\n                } 663116"];
5825 [label="'Expressions' 663117"];
5826 [label="'Linq' 663118"];
5827 [label="'' 663119"];
5828 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 663120"];
5829 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 663121"];
5830 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 663122"];
5831 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 663123"];
5832 [label="s_expressionsNamespaceName = { 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 663124"];
5833 [label="(type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 663125"];
5834 [label="s_containsTypeParameterPredicate =\n            (type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 663126"];
5835 [label="(type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 663127"];
5836 [label="s_isTypeParameterWithSpecificContainerPredicate =\n             (type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 663128"];
5837 [label="(type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 663129"];
5838 [label="s_containsTypeParametersPredicate =\n            (type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 663130"];
5839 [label="(type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 663131"];
5840 [label="s_containsDynamicPredicate = (type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 663132"];
5841 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 663133"];
5842 [label="this.IsStructType() 663134"];
5843 [label="param IsStructType(this TypeSymbol type) 663135"];
5844 [label="RoslynDebug.Assert((object)type != null); 663136"];
5845 [label="RoslynDebug.Assert((object)type != null); 663137"];
5846 [label="type.TypeKind 663138"];
5847 [label="get\n            {\n                return _flags.TypeKind;\n            } 663139"];
5848 [label="return type.TypeKind == TypeKind.Struct; 663140"];
5849 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 663141"];
5850 [label="this.IsStatic 663142"];
5851 [label="=> HasFlag(DeclarationModifiers.Static) 663143"];
5852 [label="DeclarationModifiers.Static 663144"];
5853 [label="HasFlag(DeclarationModifiers.Static) 663145"];
5854 [label="param HasFlag(DeclarationModifiers flag) 663146"];
5855 [label="=> (_declModifiers & flag) != 0 663147"];
5856 [label="_declModifiers & flag 663148"];
5857 [label="0 663149"];
5858 [label="(_declModifiers & flag) != 0 663150"];
5859 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 663151"];
5860 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 663152"];
5861 [label="this.IsInterface 663153"];
5862 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 663154"];
5863 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 663155"];
5864 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 663156"];
5865 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 663157"];
5866 [label="this.TypeKind 663158"];
5867 [label="builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers); 663159"];
5868 [label="(this.TypeKind == TypeKind.Submission) 663160"];
5869 [label="new SynthesizedInstanceConstructor(this) 663161"];
5870 [label="param SynthesizedInstanceConstructor(NamedTypeSymbol containingType) 663162"];
5871 [label="param SynthesizedInstanceConstructor(this) 663163"];
5872 [label="param SynthesizedInstanceConstructor(this) 663164"];
5873 [label="param SynthesizedInstanceMethodSymbol(this) 663165"];
5874 [label="null 663166"];
5875 [label="None = null 663167"];
5876 [label="param SynthesizedInstanceMethodSymbol(this) 663168"];
5877 [label="param MethodSymbol(this) 663169"];
5878 [label="param MethodSymbol(this) 663170"];
5879 [label="_lazyAdapter 663171"];
5880 [label="_lazyParameterSignature 663172"];
5881 [label="_lazyThisParameter 663173"];
5882 [label="_containingType 663174"];
5883 [label="Debug.Assert((object)containingType != null); 663175"];
5884 [label="Debug.Assert((object)containingType != null); 663176"];
5885 [label="_containingType 663177"];
5886 [label="builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers); 663178"];
5887 [label="builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers) 663179"];
5888 [label="param AddNonTypeMember(Symbol member) 663180"];
5889 [label="param AddNonTypeMember(DeclaredMembersAndInitializers declaredMembers) 663181"];
5890 [label="param AddNonTypeMember(this) 663182"];
5891 [label="if (NonTypeMembers is null)\n                {\n                    NonTypeMembers = ArrayBuilder<Symbol>.GetInstance(declaredMembers.NonTypeMembers.Length + 1);\n                    NonTypeMembers.AddRange(declaredMembers.NonTypeMembers);\n                } 663183"];
5892 [label="NonTypeMembers = ArrayBuilder<Symbol>.GetInstance(declaredMembers.NonTypeMembers.Length + 1); 663184"];
5893 [label="NonTypeMembers = ArrayBuilder<Symbol>.GetInstance(declaredMembers.NonTypeMembers.Length + 1); 663185"];
5894 [label="NonTypeMembers 663186"];
5895 [label="NonTypeMembers.AddRange(declaredMembers.NonTypeMembers); 663187"];
5896 [label="NonTypeMembers.AddRange(declaredMembers.NonTypeMembers); 663188"];
5897 [label="NonTypeMembers.Add(member); 663189"];
5898 [label="NonTypeMembers.Add(member); 663190"];
5899 [label="builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers); 663191"];
5900 [label="if (!hasStaticConstructor && hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers))\n            {\n                // Note: we don't have to put anything in the method - the binder will\n                // do that when processing field initializers.\n                builder.AddNonTypeMember(new SynthesizedStaticConstructor(this), declaredMembersAndInitializers);\n            } 663192"];
5901 [label="hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers) 663193"];
5902 [label="static bool hasNonConstantInitializer(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> initializers)\n            {\n                return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst));\n            } 663194"];
5903 [label="return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst)); 663195"];
5904 [label="return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst)); 663196"];
5905 [label="if (!hasStaticConstructor && hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers))\n            {\n                // Note: we don't have to put anything in the method - the binder will\n                // do that when processing field initializers.\n                builder.AddNonTypeMember(new SynthesizedStaticConstructor(this), declaredMembersAndInitializers);\n            } 663197"];
5906 [label="this.IsScriptClass 663198"];
5907 [label="get\n            {\n                var kind = this.declaration.Declarations[0].Kind;\n                return kind == DeclarationKind.Script || kind == DeclarationKind.Submission;\n            } 663199"];
5908 [label="var kind = this.declaration.Declarations[0].Kind; 663200"];
5909 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 663201"];
5910 [label="if (this.IsScriptClass)\n            {\n                var scriptInitializer = new SynthesizedInteractiveInitializerMethod(this, diagnostics);\n                builder.AddNonTypeMember(scriptInitializer, declaredMembersAndInitializers);\n                var scriptEntryPoint = SynthesizedEntryPointSymbol.Create(scriptInitializer, diagnostics);\n                builder.AddNonTypeMember(scriptEntryPoint, declaredMembersAndInitializers);\n            } 663202"];
5911 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 663203"];
5912 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 663204"];
5913 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) != null)\n            {\n                // Another thread completed the work before this one\n                membersAndInitializersBuilder.Free();\n                return null;\n            } 663205"];
5914 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) != null)\n            {\n                // Another thread completed the work before this one\n                membersAndInitializersBuilder.Free();\n                return null;\n            } 663206"];
5915 [label="return membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers); 663207"];
5916 [label="membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers) 663208"];
5917 [label="param ToReadOnlyAndFree(DeclaredMembersAndInitializers declaredMembers) 663209"];
5918 [label="param ToReadOnlyAndFree(this) 663210"];
5919 [label="var nonTypeMembers = NonTypeMembers?.ToImmutableAndFree() ?? declaredMembers.NonTypeMembers; 663211"];
5920 [label="var instanceInitializers = InstanceInitializersForPositionalMembers is null\n                    ? declaredMembers.InstanceInitializers\n                    : mergeInitializers(); 663212"];
5921 [label="InstanceInitializersForPositionalMembers is null 663213"];
5922 [label="declaredMembers.InstanceInitializers 663214"];
5923 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 663215"];
5924 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 663216"];
5925 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 663217"];
5926 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 663218"];
5927 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 663219"];
5928 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 663220"];
5929 [label="new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields) 663221"];
5930 [label="param MembersAndInitializers(ImmutableArray<Symbol> nonTypeMembers) 663222"];
5931 [label="param MembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> staticInitializers) 663223"];
5932 [label="param MembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> instanceInitializers) 663224"];
5933 [label="param MembersAndInitializers(bool haveIndexers) 663225"];
5934 [label="param MembersAndInitializers(bool isNullableEnabledForInstanceConstructorsAndFields) 663226"];
5935 [label="param MembersAndInitializers(bool isNullableEnabledForStaticConstructorsAndFields) 663227"];
5936 [label="param MembersAndInitializers(this) 663228"];
5937 [label="HaveIndexers 663229"];
5938 [label="IsNullableEnabledForInstanceConstructorsAndFields 663230"];
5939 [label="IsNullableEnabledForStaticConstructorsAndFields 663231"];
5940 [label="Debug.Assert(!nonTypeMembers.IsDefault); 663232"];
5941 [label="Debug.Assert(!staticInitializers.IsDefault); 663233"];
5942 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 663234"];
5943 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 663235"];
5944 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 663236"];
5945 [label="Debug.Assert(!instanceInitializers.IsDefault); 663237"];
5946 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 663238"];
5947 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 663239"];
5948 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 663240"];
5949 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 663241"];
5950 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 663242"];
5951 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 663243"];
5952 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 663244"];
5953 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 663245"];
5954 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 663246"];
5955 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 663247"];
5956 [label="param IsIndexer(this Symbol symbol) 663248"];
5957 [label="symbol.Kind 663249"];
5958 [label="get\n            {\n                return SymbolKind.Field;\n            } 663250"];
5959 [label="return SymbolKind.Field; 663251"];
5960 [label="return symbol.Kind == SymbolKind.Property && ((PropertySymbol)symbol).IsIndexer; 663252"];
5961 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 663253"];
5962 [label="get\n            {\n                return SymbolKind.Method;\n            } 663254"];
5963 [label="return SymbolKind.Method; 663255"];
5964 [label="return symbol.Kind == SymbolKind.Property && ((PropertySymbol)symbol).IsIndexer; 663256"];
5965 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 663257"];
5966 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 663258"];
5967 [label="this.NonTypeMembers 663259"];
5968 [label="this.StaticInitializers 663260"];
5969 [label="this.InstanceInitializers 663261"];
5970 [label="this.HaveIndexers 663262"];
5971 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 663263"];
5972 [label="this.IsNullableEnabledForStaticConstructorsAndFields 663264"];
5973 [label="return membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers); 663265"];
5974 [label="membersAndInitializers = BuildMembersAndInitializers(diagnostics); 663266"];
5975 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 663267"];
5976 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 663268"];
5977 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 663269"];
5978 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 663270"];
5979 [label="if (alreadyKnown != null)\n            {\n                diagnostics.Free();\n                return alreadyKnown;\n            } 663271"];
5980 [label="if (alreadyKnown != null)\n            {\n                diagnostics.Free();\n                return alreadyKnown;\n            } 663272"];
5981 [label="AddDeclarationDiagnostics(diagnostics); 663273"];
5982 [label="AddDeclarationDiagnostics(diagnostics) 663274"];
5983 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 663275"];
5984 [label="param AddDeclarationDiagnostics(this) 663276"];
5985 [label="ContainingSymbol 663277"];
5986 [label="get\n            {\n                return _containingSymbol;\n            } 663278"];
5987 [label="return _containingSymbol; 663279"];
5988 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 663280"];
5989 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 663281"];
5990 [label="AddDeclarationDiagnostics(diagnostics); 663282"];
5991 [label="diagnostics.Free(); 663283"];
5992 [label="_lazyDeclaredMembersAndInitializers = null; 663284"];
5993 [label="_lazyDeclaredMembersAndInitializers 663285"];
5994 [label="return membersAndInitializers!; 663286"];
5995 [label="var membersAndInitializers = GetMembersAndInitializers(); 663287"];
5996 [label="this.IsTupleType 663288"];
5997 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 663289"];
5998 [label="_ 663290"];
5999 [label="tupleCardinality: out _ 663291"];
6000 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 663292"];
6001 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 663293"];
6002 [label="param IsTupleTypeOfCardinality(this) 663294"];
6003 [label="IsUnboundGenericType 663295"];
6004 [label="get\n            {\n                return false;\n            } 663296"];
6005 [label="return false; 663297"];
6006 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 663298"];
6007 [label="ContainingSymbol 663299"];
6008 [label="get\n            {\n                return _containingSymbol;\n            } 663300"];
6009 [label="return _containingSymbol; 663301"];
6010 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 663302"];
6011 [label=".Kind 663303"];
6012 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 663304"];
6013 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 663305"];
6014 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 663306"];
6015 [label="ContainingNamespace 663307"];
6016 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 663308"];
6017 [label="this.ContainingSymbol 663309"];
6018 [label="get\n            {\n                return _containingSymbol;\n            } 663310"];
6019 [label="return _containingSymbol; 663311"];
6020 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 663312"];
6021 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 663313"];
6022 [label="var ns = container as NamespaceSymbol; 663314"];
6023 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 663315"];
6024 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 663316"];
6025 [label="return ns; 663317"];
6026 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 663318"];
6027 [label="ContainingNamespace.ContainingNamespace 663319"];
6028 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 663320"];
6029 [label="this.ContainingSymbol 663321"];
6030 [label="=> _container 663322"];
6031 [label="_container 663323"];
6032 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 663324"];
6033 [label=".IsGlobalNamespace 663325"];
6034 [label="get\n            {\n                return (object)ContainingNamespace == null;\n            } 663326"];
6035 [label="ContainingNamespace 663327"];
6036 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 663328"];
6037 [label="this.ContainingSymbol 663329"];
6038 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 663330"];
6039 [label="container.ContainingSymbol 663331"];
6040 [label="get\n            {\n                return _assemblySymbol;\n            } 663332"];
6041 [label="return _assemblySymbol; 663333"];
6042 [label="get\n            {\n                return null;\n            } 663334"];
6043 [label="return null; 663335"];
6044 [label="return null; 663336"];
6045 [label="return (object)ContainingNamespace == null; 663337"];
6046 [label="return (object)ContainingNamespace == null; 663338"];
6047 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 663339"];
6048 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 663340"];
6049 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 663341"];
6050 [label="Name 663342"];
6051 [label="get\n            {\n                return declaration.Name;\n            } 663343"];
6052 [label="return declaration.Name; 663344"];
6053 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 663345"];
6054 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 663346"];
6055 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 663347"];
6056 [label="tupleCardinality = 0; 663348"];
6057 [label="return false; 663349"];
6058 [label="if (!membersAndInitializers.HaveIndexers && !this.IsTupleType && _lazyEarlyAttributeDecodingMembersDictionary is object)\n            {\n                membersByName = _lazyEarlyAttributeDecodingMembersDictionary;\n            }\n            else\n            {\n                membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance);\n\n                // Merge types into the member dictionary\n                AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary());\n            } 663350"];
6059 [label="if (!membersAndInitializers.HaveIndexers && !this.IsTupleType && _lazyEarlyAttributeDecodingMembersDictionary is object)\n            {\n                membersByName = _lazyEarlyAttributeDecodingMembersDictionary;\n            }\n            else\n            {\n                membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance);\n\n                // Merge types into the member dictionary\n                AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary());\n            } 663351"];
6060 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 663352"];
6061 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 663353"];
6062 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 663354"];
6063 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 663355"];
6064 [label="get\n            {\n                return _name;\n            } 663356"];
6065 [label="return _name; 663357"];
6066 [label="get { return WellKnownMemberNames.InstanceConstructorName; } 663358"];
6067 [label="return WellKnownMemberNames.InstanceConstructorName; 663359"];
6068 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 663360"];
6069 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 663361"];
6070 [label="GetTypeMembersDictionary() 663362"];
6071 [label="param GetTypeMembersDictionary(this) 663363"];
6072 [label="if (_lazyTypeMembers == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                }\n\n                diagnostics.Free();\n            } 663364"];
6073 [label="if (_lazyTypeMembers == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                }\n\n                diagnostics.Free();\n            } 663365"];
6074 [label="var diagnostics = DiagnosticBag.GetInstance(); 663366"];
6075 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 663367"];
6076 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 663368"];
6077 [label="MakeTypeMembers(diagnostics) 663369"];
6078 [label="param MakeTypeMembers(DiagnosticBag diagnostics) 663370"];
6079 [label="param MakeTypeMembers(this) 663371"];
6080 [label="var symbols = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 663372"];
6081 [label="var conflictDict = new Dictionary<(string, int), SourceNamedTypeSymbol>(); 663373"];
6082 [label="foreach (var childDeclaration in declaration.Children)\n                {\n                    var t = new SourceNamedTypeSymbol(this, childDeclaration, diagnostics);\n                    this.CheckMemberNameDistinctFromType(t, diagnostics);\n\n                    var key = (t.Name, t.Arity);\n                    SourceNamedTypeSymbol? other;\n                    if (conflictDict.TryGetValue(key, out other))\n                    {\n                        if (Locations.Length == 1 || IsPartial)\n                        {\n                            if (t.IsPartial && other.IsPartial)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, t.Locations[0], t);\n                            }\n                            else\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, t.Locations[0], this, t.Name);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        conflictDict.Add(key, t);\n                    }\n\n                    symbols.Add(t);\n                } 663374"];
6083 [label="IsInterface 663375"];
6084 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 663376"];
6085 [label="if (IsInterface)\n                {\n                    foreach (var t in symbols)\n                    {\n                        Binder.CheckFeatureAvailability(t.DeclaringSyntaxReferences[0].GetSyntax(), MessageID.IDS_DefaultInterfaceImplementation, diagnostics, t.Locations[0]);\n                    }\n                } 663377"];
6086 [label="Debug.Assert(s_emptyTypeMembers.Count == 0); 663378"];
6087 [label="Debug.Assert(s_emptyTypeMembers.Count == 0); 663379"];
6088 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 663380"];
6089 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 663381"];
6090 [label="symbols.Count > 0 663382"];
6091 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 663383"];
6092 [label="symbols.Free(); 663384"];
6093 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 663385"];
6094 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 663386"];
6095 [label="AddDeclarationDiagnostics(diagnostics); 663387"];
6096 [label="AddDeclarationDiagnostics(diagnostics) 663388"];
6097 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 663389"];
6098 [label="param AddDeclarationDiagnostics(this) 663390"];
6099 [label="ContainingSymbol 663391"];
6100 [label="get\n            {\n                return _containingSymbol;\n            } 663392"];
6101 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 663393"];
6102 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 663394"];
6103 [label="AddDeclarationDiagnostics(diagnostics); 663395"];
6104 [label="state.NotePartComplete(CompletionPart.TypeMembers); 663396"];
6105 [label="state.NotePartComplete(CompletionPart.TypeMembers) 663397"];
6106 [label="param NotePartComplete(CompletionPart part) 663398"];
6107 [label="diagnostics.Free(); 663399"];
6108 [label="return _lazyTypeMembers; 663400"];
6109 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 663401"];
6110 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()) 663402"];
6111 [label="param AddNestedTypesToDictionary(Dictionary<string, ImmutableArray<Symbol>> membersByName) 663403"];
6112 [label="param AddNestedTypesToDictionary(Dictionary<string, ImmutableArray<NamedTypeSymbol>> typesByName) 663404"];
6113 [label="foreach (var pair in typesByName)\n            {\n                string name = pair.Key;\n                ImmutableArray<NamedTypeSymbol> types = pair.Value;\n                ImmutableArray<Symbol> typesAsSymbols = StaticCast<Symbol>.From(types);\n\n                ImmutableArray<Symbol> membersForName;\n                if (membersByName.TryGetValue(name, out membersForName))\n                {\n                    membersByName[name] = membersForName.Concat(typesAsSymbols);\n                }\n                else\n                {\n                    membersByName.Add(name, typesAsSymbols);\n                }\n            } 663405"];
6114 [label="foreach (var pair in typesByName)\n            {\n                string name = pair.Key;\n                ImmutableArray<NamedTypeSymbol> types = pair.Value;\n                ImmutableArray<Symbol> typesAsSymbols = StaticCast<Symbol>.From(types);\n\n                ImmutableArray<Symbol> membersForName;\n                if (membersByName.TryGetValue(name, out membersForName))\n                {\n                    membersByName[name] = membersForName.Concat(typesAsSymbols);\n                }\n                else\n                {\n                    membersByName.Add(name, typesAsSymbols);\n                }\n            } 663406"];
6115 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 663407"];
6116 [label="MergePartialMembers(ref membersByName, diagnostics); 663408"];
6117 [label="MergePartialMembers(ref membersByName, diagnostics); 663409"];
6118 [label="MergePartialMembers(ref membersByName, diagnostics) 663410"];
6119 [label="param MergePartialMembers(ref Dictionary<string, ImmutableArray<Symbol>> membersByName) 663411"];
6120 [label="param MergePartialMembers(DiagnosticBag diagnostics) 663412"];
6121 [label="param MergePartialMembers(this) 663413"];
6122 [label="var memberNames = ArrayBuilder<string>.GetInstance(membersByName.Count); 663414"];
6123 [label="memberNames.AddRange(membersByName.Keys); 663415"];
6124 [label="memberNames.AddRange(membersByName.Keys); 663416"];
6125 [label="var methodsBySignature = new Dictionary<MethodSymbol, SourceMemberMethodSymbol>(MemberSignatureComparer.PartialMethodsComparer); 663417"];
6126 [label="foreach (var name in memberNames)\n            {\n                methodsBySignature.Clear();\n                foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                }\n\n                foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                }\n            } 663418"];
6127 [label="foreach (var name in memberNames)\n            {\n                methodsBySignature.Clear();\n                foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                }\n\n                foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                }\n            } 663419"];
6128 [label="methodsBySignature.Clear(); 663420"];
6129 [label="foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                } 663421"];
6130 [label="var method = symbol as SourceMemberMethodSymbol; 663422"];
6131 [label="if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    } 663423"];
6132 [label="foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                } 663424"];
6133 [label="methodsBySignature.Clear(); 663425"];
6134 [label="foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                } 663426"];
6135 [label="memberNames.Free(); 663427"];
6136 [label="MergePartialMembers(ref membersByName, diagnostics); 663428"];
6137 [label="return membersByName; 663429"];
6138 [label="var membersDictionary = MakeAllMembers(diagnostics); 663430"];
6139 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 663431"];
6140 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 663432"];
6141 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 663433"];
6142 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 663434"];
6143 [label="AddDeclarationDiagnostics(diagnostics); 663435"];
6144 [label="AddDeclarationDiagnostics(diagnostics) 663436"];
6145 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 663437"];
6146 [label="param AddDeclarationDiagnostics(this) 663438"];
6147 [label="ContainingSymbol 663439"];
6148 [label="get\n            {\n                return _containingSymbol;\n            } 663440"];
6149 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 663441"];
6150 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 663442"];
6151 [label="AddDeclarationDiagnostics(diagnostics); 663443"];
6152 [label="state.NotePartComplete(CompletionPart.Members); 663444"];
6153 [label="state.NotePartComplete(CompletionPart.Members) 663445"];
6154 [label="param NotePartComplete(CompletionPart part) 663446"];
6155 [label="diagnostics.Free(); 663447"];
6156 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)); 663448"];
6157 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)); 663449"];
6158 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)) 663450"];
6159 [label="param SpinWaitComplete(CompletionPart part) 663451"];
6160 [label="param SpinWaitComplete(CancellationToken cancellationToken) 663452"];
6161 [label="param SpinWaitComplete(this) 663453"];
6162 [label="if (HasComplete(part))\n            {\n                return;\n            } 663454"];
6163 [label="HasComplete(part) 663455"];
6164 [label="param HasComplete(CompletionPart part) 663456"];
6165 [label="param HasComplete(this) 663457"];
6166 [label="return (_completeParts & (int)part) == (int)part; 663458"];
6167 [label="return; 663459"];
6168 [label="return _lazyMembersDictionary; 663460"];
6169 [label="return GetMembersByNameSlow(); 663461"];
6170 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 663462"];
6171 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 663463"];
6172 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 663464"];
6173 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 663465"];
6174 [label="return members; 663466"];
6175 [label="CustomAssert.Equal(SymbolKind.Field, varX.Kind); 663467"];
6176 [label="varX.Kind 663468"];
6177 [label="get\n            {\n                return SymbolKind.Field;\n            } 663469"];
6178 [label="return SymbolKind.Field; 663470"];
6179 [label="CustomAssert.Equal(SymbolKind.Field, varX.Kind); 663471"];
6180 [label="CustomAssert.Same(comp.GetSpecialType(SpecialType.System_Nullable_T), varX.Type.OriginalDefinition); 663472"];
6181 [label="comp.GetSpecialType(SpecialType.System_Nullable_T) 663473"];
6182 [label="param GetSpecialType(SpecialType specialType) 663474"];
6183 [label="param GetSpecialType(this) 663475"];
6184 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 663476"];
6185 [label="NamedTypeSymbol result; 663477"];
6186 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 663478"];
6187 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 663479"];
6188 [label="Assembly 663480"];
6189 [label="GetBoundReferenceManager(); 663481"];
6190 [label="result = Assembly.GetSpecialType(specialType); 663482"];
6191 [label="result = Assembly.GetSpecialType(specialType); 663483"];
6192 [label="Assembly.GetSpecialType(specialType) 663484"];
6193 [label="param GetSpecialType(SpecialType type) 663485"];
6194 [label="param GetSpecialType(this) 663486"];
6195 [label="CorLibrary 663487"];
6196 [label="get\n            {\n                return _corLibrary;\n            } 663488"];
6197 [label="return CorLibrary.GetDeclaredSpecialType(type); 663489"];
6198 [label="return CorLibrary.GetDeclaredSpecialType(type); 663490"];
6199 [label="CorLibrary.GetDeclaredSpecialType(type) 663491"];
6200 [label="param GetDeclaredSpecialType(SpecialType type) 663492"];
6201 [label="param GetDeclaredSpecialType(this) 663493"];
6202 [label="this.Modules 663494"];
6203 [label="get\n            {\n                return _modules;\n            } 663495"];
6204 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 663496"];
6205 [label="module.GetReferencedAssemblies() 663497"];
6206 [label="param GetReferencedAssemblies(this) 663498"];
6207 [label="AssertReferencesInitialized() 663499"];
6208 [label="param AssertReferencesInitialized(this) 663500"];
6209 [label="Debug.Assert(_moduleReferences != null); 663501"];
6210 [label="Debug.Assert(_moduleReferences != null); 663502"];
6211 [label="AssertReferencesInitialized(); 663503"];
6212 [label="return _moduleReferences.Identities; 663504"];
6213 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 663505"];
6214 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 663506"];
6215 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 663507"];
6216 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 663508"];
6217 [label="MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true); 663509"];
6218 [label="MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true); 663510"];
6219 [label="this.Modules 663511"];
6220 [label="ModuleSymbol module = this.Modules[0]; 663512"];
6221 [label="ModuleSymbol module = this.Modules[0]; 663513"];
6222 [label="NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName); 663514"];
6223 [label="module.LookupTopLevelMetadataType(ref emittedName) 663515"];
6224 [label="param LookupTopLevelMetadataType(ref MetadataTypeName emittedName) 663516"];
6225 [label="param LookupTopLevelMetadataType(this) 663517"];
6226 [label="NamedTypeSymbol result; 663518"];
6227 [label="this.GlobalNamespace 663519"];
6228 [label="get { return _globalNamespace; } 663520"];
6229 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 663521"];
6230 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 663522"];
6231 [label="this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments) 663523"];
6232 [label="param LookupNestedNamespace(ImmutableArray<string> names) 663524"];
6233 [label="param LookupNestedNamespace(this) 663525"];
6234 [label="NamespaceSymbol scope = this; 663526"];
6235 [label="foreach (string name in names)\n            {\n                NamespaceSymbol nextScope = null;\n\n                foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                }\n\n                scope = nextScope;\n\n                if ((object)scope == null)\n                {\n                    break;\n                }\n            } 663527"];
6236 [label="NamespaceSymbol nextScope = null; 663528"];
6237 [label="foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                } 663529"];
6238 [label="scope.GetMembers(name) 663530"];
6239 [label="param GetMembers(string name) 663531"];
6240 [label="param GetMembers(this) 663532"];
6241 [label="EnsureAllMembersLoaded(); 663533"];
6242 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 663534"];
6243 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 663535"];
6244 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 663536"];
6245 [label="return ImmutableArray.Create<Symbol>(ns); 663537"];
6246 [label="var ns = symbol as NamespaceSymbol; 663538"];
6247 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 663539"];
6248 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 663540"];
6249 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 663541"];
6250 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 663542"];
6251 [label="nextScope = ns; 663543"];
6252 [label="scope = nextScope; 663544"];
6253 [label="if ((object)scope == null)\n                {\n                    break;\n                } 663545"];
6254 [label="if ((object)scope == null)\n                {\n                    break;\n                } 663546"];
6255 [label="return scope; 663547"];
6256 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 663548"];
6257 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 663549"];
6258 [label="result = scope.LookupMetadataType(ref emittedName); 663550"];
6259 [label="scope.LookupMetadataType(ref emittedName) 663551"];
6260 [label="param LookupMetadataType(ref MetadataTypeName emittedTypeName) 663552"];
6261 [label="param LookupMetadataType(this) 663553"];
6262 [label="Debug.Assert(!emittedTypeName.IsNull); 663554"];
6263 [label="NamespaceOrTypeSymbol scope = this; 663555"];
6264 [label="scope.Kind 663556"];
6265 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 663557"];
6266 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 663558"];
6267 [label="NamedTypeSymbol? namedType = null; 663559"];
6268 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 663560"];
6269 [label="namespaceOrTypeMembers 663561"];
6270 [label="scope.IsNamespace 663562"];
6271 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 663563"];
6272 [label="Kind 663564"];
6273 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 663565"];
6274 [label="return Kind == SymbolKind.Namespace; 663566"];
6275 [label="bool isTopLevel = scope.IsNamespace; 663567"];
6276 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 663568"];
6277 [label="scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) 663569"];
6278 [label="param ToDisplayString(SymbolDisplayFormat format = null) 663570"];
6279 [label="param ToDisplayString(this) 663571"];
6280 [label="ISymbol 663572"];
6281 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 663573"];
6282 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 663574"];
6283 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 663575"];
6284 [label="CreateISymbol() 663576"];
6285 [label="param CreateISymbol(this) 663577"];
6286 [label="return new PublicModel.NamespaceSymbol(this); 663578"];
6287 [label="return new PublicModel.NamespaceSymbol(this); 663579"];
6288 [label="new PublicModel.NamespaceSymbol(this) 663580"];
6289 [label="param NamespaceSymbol(Symbols.NamespaceSymbol underlying) 663581"];
6290 [label="param NamespaceSymbol(this) 663582"];
6291 [label="param NamespaceSymbol(this) 663583"];
6292 [label="param NamespaceOrTypeSymbol(this) 663584"];
6293 [label="param NamespaceOrTypeSymbol(this) 663585"];
6294 [label="param Symbol(this) 663586"];
6295 [label="_underlying 663587"];
6296 [label="Debug.Assert(underlying is object); 663588"];
6297 [label="_underlying 663589"];
6298 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 663590"];
6299 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 663591"];
6300 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 663592"];
6301 [label="return _lazyISymbol; 663593"];
6302 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 663594"];
6303 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 663595"];
6304 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 663596"];
6305 [label="param ToDisplayString(ISymbol symbol) 663597"];
6306 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 663598"];
6307 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 663599"];
6308 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 663600"];
6309 [label="ToDisplayParts(symbol, format) 663601"];
6310 [label="param ToDisplayParts(ISymbol symbol) 663602"];
6311 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 663603"];
6312 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 663604"];
6313 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 663605"];
6314 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 663606"];
6315 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 663607"];
6316 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 663608"];
6317 [label="param ToDisplayParts(ISymbol symbol) 663609"];
6318 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 663610"];
6319 [label="param ToDisplayParts(int positionOpt) 663611"];
6320 [label="param ToDisplayParts(SymbolDisplayFormat format) 663612"];
6321 [label="param ToDisplayParts(bool minimal) 663613"];
6322 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 663614"];
6323 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 663615"];
6324 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 663616"];
6325 [label="Debug.Assert(semanticModelOpt == null); 663617"];
6326 [label="Debug.Assert(semanticModelOpt == null); 663618"];
6327 [label="Debug.Assert(positionOpt < 0); 663619"];
6328 [label="Debug.Assert(positionOpt < 0); 663620"];
6329 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 663621"];
6330 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 663622"];
6331 [label="'modopt' 663623"];
6332 [label="IL_KEYWORD_MODOPT = 'modopt' 663624"];
6333 [label="'modreq' 663625"];
6334 [label="IL_KEYWORD_MODREQ = 'modreq' 663626"];
6335 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 663627"];
6336 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 663628"];
6337 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 663629"];
6338 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 663630"];
6339 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 663631"];
6340 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 663632"];
6341 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 663633"];
6342 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 663634"];
6343 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 663635"];
6344 [label="param SymbolDisplayVisitor(int positionOpt) 663636"];
6345 [label="param SymbolDisplayVisitor(this) 663637"];
6346 [label="builder 663638"];
6347 [label="format 663639"];
6348 [label="true 663640"];
6349 [label="semanticModelOpt 663641"];
6350 [label="positionOpt 663642"];
6351 [label="param SymbolDisplayVisitor(this) 663643"];
6352 [label="param SymbolDisplayVisitor(this) 663644"];
6353 [label="_escapeKeywordIdentifiers 663645"];
6354 [label="_lazyAliasMap 663646"];
6355 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 663647"];
6356 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 663648"];
6357 [label="_escapeKeywordIdentifiers 663649"];
6358 [label="symbol.Accept(visitor); 663650"];
6359 [label="symbol.Accept(visitor) 663651"];
6360 [label="param Accept(SymbolVisitor visitor) 663652"];
6361 [label="param Accept(this) 663653"];
6362 [label="Accept(visitor); 663654"];
6363 [label="Accept(visitor) 663655"];
6364 [label="param Accept(SymbolVisitor visitor) 663656"];
6365 [label="param Accept(this) 663657"];
6366 [label="visitor.VisitNamespace(this); 663658"];
6367 [label="visitor.VisitNamespace(this) 663659"];
6368 [label="param VisitNamespace(INamespaceSymbol symbol) 663660"];
6369 [label="param VisitNamespace(this) 663661"];
6370 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 663662"];
6371 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 663663"];
6372 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 663664"];
6373 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                var containingNamespace = symbol.ContainingNamespace;\n                if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 663665"];
6374 [label="symbol.ContainingNamespace 663666"];
6375 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 663667"];
6376 [label="UnderlyingSymbol 663668"];
6377 [label="=> _underlying 663669"];
6378 [label="_underlying 663670"];
6379 [label="UnderlyingSymbol.ContainingNamespace 663671"];
6380 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 663672"];
6381 [label="this.ContainingSymbol 663673"];
6382 [label="get { return _containingNamespaceSymbol; } 663674"];
6383 [label="return _containingNamespaceSymbol; 663675"];
6384 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 663676"];
6385 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 663677"];
6386 [label="var ns = container as NamespaceSymbol; 663678"];
6387 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 663679"];
6388 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 663680"];
6389 [label="return ns; 663681"];
6390 [label="UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 663682"];
6391 [label="param GetPublicSymbol(this NamespaceSymbol? symbol) 663683"];
6392 [label="return symbol.GetPublicSymbol<INamespaceSymbol>(); 663684"];
6393 [label="symbol.GetPublicSymbol<INamespaceSymbol>() 663685"];
6394 [label="param GetPublicSymbol(this Symbol? symbol) 663686"];
6395 [label=".ISymbol 663687"];
6396 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 663688"];
6397 [label="param NamespaceOrTypeSymbol(this) 663689"];
6398 [label="param Symbol(this) 663690"];
6399 [label="_underlying 663691"];
6400 [label="Debug.Assert(underlying is object); 663692"];
6401 [label="return (TISymbol?)symbol?.ISymbol; 663693"];
6402 [label="var containingNamespace = symbol.ContainingNamespace; 663694"];
6403 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 663695"];
6404 [label="ShouldVisitNamespace(containingNamespace) 663696"];
6405 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 663697"];
6406 [label="param ShouldVisitNamespace(this) 663698"];
6407 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 663699"];
6408 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 663700"];
6409 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 663701"];
6410 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 663702"];
6411 [label="namespaceSymbol.IsGlobalNamespace 663703"];
6412 [label="=> _underlying.IsGlobalNamespace 663704"];
6413 [label="_underlying.IsGlobalNamespace 663705"];
6414 [label="get\n            {\n                return true;\n            } 663706"];
6415 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 663707"];
6416 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 663708"];
6417 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 663709"];
6418 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 663710"];
6419 [label="symbol.IsGlobalNamespace 663711"];
6420 [label="=> _underlying.IsGlobalNamespace 663712"];
6421 [label="_underlying.IsGlobalNamespace 663713"];
6422 [label="get\n            {\n                return false;\n            } 663714"];
6423 [label="return false; 663715"];
6424 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 663716"];
6425 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 663717"];
6426 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 663718"];
6427 [label="symbol.Name 663719"];
6428 [label="=> UnderlyingSymbol.Name 663720"];
6429 [label="UnderlyingSymbol 663721"];
6430 [label="=> _underlying 663722"];
6431 [label="_underlying 663723"];
6432 [label="UnderlyingSymbol.Name 663724"];
6433 [label="get\n            {\n                return _name;\n            } 663725"];
6434 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 663726"];
6435 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 663727"];
6436 [label="param CreatePart(SymbolDisplayPartKind kind) 663728"];
6437 [label="param CreatePart(ISymbol symbol) 663729"];
6438 [label="param CreatePart(string text) 663730"];
6439 [label="param CreatePart(this) 663731"];
6440 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 663732"];
6441 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 663733"];
6442 [label="(text == null) 663734"];
6443 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 663735"];
6444 [label="(_escapeKeywordIdentifiers && IsEscapable(kind)) 663736"];
6445 [label="return new SymbolDisplayPart(kind, symbol, text); 663737"];
6446 [label="return new SymbolDisplayPart(kind, symbol, text); 663738"];
6447 [label="return new SymbolDisplayPart(kind, symbol, text); 663739"];
6448 [label="return new SymbolDisplayPart(kind, symbol, text); 663740"];
6449 [label="visitor.VisitNamespace(this); 663741"];
6450 [label="Accept(visitor); 663742"];
6451 [label="symbol.Accept(visitor); 663743"];
6452 [label="return builder.ToImmutableAndFree(); 663744"];
6453 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 663745"];
6454 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 663746"];
6455 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 663747"];
6456 [label="Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0); 663748"];
6457 [label="Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0); 663749"];
6458 [label="if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                } 663750"];
6459 [label="namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName); 663751"];
6460 [label="scope.GetTypeMembers(emittedTypeName.UnmangledTypeName) 663752"];
6461 [label="param GetTypeMembers(string name) 663753"];
6462 [label="param GetTypeMembers(this) 663754"];
6463 [label="EnsureAllMembersLoaded() 663755"];
6464 [label="param EnsureAllMembersLoaded(this) 663756"];
6465 [label="var typesByNS = _typesByNS; 663757"];
6466 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 663758"];
6467 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 663759"];
6468 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 663760"];
6469 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 663761"];
6470 [label="LoadAllMembers(typesByNS); 663762"];
6471 [label="LoadAllMembers(typesByNS) 663763"];
6472 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 663764"];
6473 [label="Debug.Assert(typesByNS != null); 663765"];
6474 [label="Debug.Assert(typesByNS != null); 663766"];
6475 [label="get\n            {\n                return false;\n            } 663767"];
6476 [label="GetQualifiedNameLength() 663768"];
6477 [label="param GetQualifiedNameLength(this) 663769"];
6478 [label="this.Name 663770"];
6479 [label="get\n            {\n                return _name;\n            } 663771"];
6480 [label="int length = this.Name.Length; 663772"];
6481 [label="ContainingNamespace 663773"];
6482 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 663774"];
6483 [label="var parent = ContainingNamespace; 663775"];
6484 [label=".IsGlobalNamespace 663776"];
6485 [label="get\n            {\n                return true;\n            } 663777"];
6486 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 663778"];
6487 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 663779"];
6488 [label="return length; 663780"];
6489 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 663781"];
6490 [label="_containingNamespaceSymbol 663782"];
6491 [label="_name 663783"];
6492 [label="_typesByNS 663784"];
6493 [label="Debug.Assert(name != null); 663785"];
6494 [label="Debug.Assert((object)containingNamespace != null); 663786"];
6495 [label="Debug.Assert(typesByNS != null); 663787"];
6496 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 663788"];
6497 [label="_containingNamespaceSymbol.ContainingPEModule 663789"];
6498 [label="get\n            {\n                return _moduleSymbol;\n            } 663790"];
6499 [label="return _containingNamespaceSymbol.ContainingPEModule; 663791"];
6500 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 663792"];
6501 [label="genericParameterHandles 663793"];
6502 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 663794"];
6503 [label="param GetGenericInfo(out ushort arity) 663795"];
6504 [label="param GetGenericInfo(out BadImageFormatException mrEx) 663796"];
6505 [label="mrEx = null; 663797"];
6506 [label="PENamedTypeSymbol result; 663798"];
6507 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 663799"];
6508 [label="mangleName 663800"];
6509 [label="param PENamedTypeSymbol(out bool mangleName) 663801"];
6510 [label="_lazyTupleData 663802"];
6511 [label="_container 663803"];
6512 [label="_name 663804"];
6513 [label="_flags 663805"];
6514 [label="_corTypeId 663806"];
6515 [label="Debug.Assert(!handle.IsNil); 663807"];
6516 [label="Debug.Assert((object)container != null); 663808"];
6517 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 663809"];
6518 [label="string metadataName; 663810"];
6519 [label="bool makeBad = false; 663811"];
6520 [label="mangleName = false; 663812"];
6521 [label="Accessibility access = Accessibility.Private; 663813"];
6522 [label="access = Accessibility.Public; 663814"];
6523 [label="_corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName)); 663815"];
6524 [label="_corTypeId 663816"];
6525 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 663817"];
6526 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 663818"];
6527 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 663819"];
6528 [label="genericParameterHandles 663820"];
6529 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 663821"];
6530 [label="param GetGenericInfo(out ushort arity) 663822"];
6531 [label="param GetGenericInfo(out BadImageFormatException mrEx) 663823"];
6532 [label="mrEx = null; 663824"];
6533 [label="PENamedTypeSymbol result; 663825"];
6534 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 663826"];
6535 [label="mangleName 663827"];
6536 [label="param PENamedTypeSymbol(out bool mangleName) 663828"];
6537 [label="_lazyTupleData 663829"];
6538 [label="_container 663830"];
6539 [label="_name 663831"];
6540 [label="_flags 663832"];
6541 [label="_corTypeId 663833"];
6542 [label="Debug.Assert(!handle.IsNil); 663834"];
6543 [label="Debug.Assert((object)container != null); 663835"];
6544 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 663836"];
6545 [label="string metadataName; 663837"];
6546 [label="bool makeBad = false; 663838"];
6547 [label="mangleName = false; 663839"];
6548 [label="Accessibility access = Accessibility.Private; 663840"];
6549 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 663841"];
6550 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 663842"];
6551 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 663843"];
6552 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 663844"];
6553 [label="mangleName 663845"];
6554 [label="param PENamedTypeSymbol(out bool mangleName) 663846"];
6555 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 663847"];
6556 [label="_arity 663848"];
6557 [label="_mangleName 663849"];
6558 [label="Debug.Assert(genericParameterHandles.Count > 0); 663850"];
6559 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 663851"];
6560 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 663852"];
6561 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 663853"];
6562 [label="bool added; 663854"];
6563 [label="Debug.Assert(added); 663855"];
6564 [label="type.SpecialType 663856"];
6565 [label="get\n            {\n                return _corTypeId;\n            } 663857"];
6566 [label="return _corTypeId; 663858"];
6567 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 663859"];
6568 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 663860"];
6569 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 663861"];
6570 [label="_assemblySymbol.RegisterDeclaredSpecialType(type) 663862"];
6571 [label="param RegisterDeclaredSpecialType(NamedTypeSymbol corType) 663863"];
6572 [label="param RegisterDeclaredSpecialType(this) 663864"];
6573 [label="corType.SpecialType 663865"];
6574 [label="get\n            {\n                return _corTypeId;\n            } 663866"];
6575 [label="SpecialType typeId = corType.SpecialType; 663867"];
6576 [label="Debug.Assert(typeId != SpecialType.None); 663868"];
6577 [label="corType.ContainingAssembly 663869"];
6578 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 663870"];
6579 [label="this.ContainingSymbol 663871"];
6580 [label="get\n            {\n                return _container;\n            } 663872"];
6581 [label="return _container; 663873"];
6582 [label="var container = this.ContainingSymbol; 663874"];
6583 [label="return (object)container != null ? container.ContainingAssembly : null; 663875"];
6584 [label="return (object)container != null ? container.ContainingAssembly : null; 663876"];
6585 [label="(object)container != null 663877"];
6586 [label="container.ContainingAssembly 663878"];
6587 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 663879"];
6588 [label="ContainingPEModule 663880"];
6589 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 663881"];
6590 [label="return ContainingPEModule.ContainingAssembly; 663882"];
6591 [label="ContainingPEModule.ContainingAssembly 663883"];
6592 [label="get\n            {\n                return _assemblySymbol;\n            } 663884"];
6593 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 663885"];
6594 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 663886"];
6595 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 663887"];
6596 [label="corType.ContainingModule 663888"];
6597 [label="get\n            {\n                return ContainingPEModule;\n            } 663889"];
6598 [label="ContainingPEModule 663890"];
6599 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 663891"];
6600 [label="Symbol s = _container; 663892"];
6601 [label="s.Kind 663893"];
6602 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 663894"];
6603 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 663895"];
6604 [label="((PENamespaceSymbol)s).ContainingPEModule 663896"];
6605 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 663897"];
6606 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 663898"];
6607 [label="return ContainingPEModule; 663899"];
6608 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 663900"];
6609 [label="corType.ContainingModule.Ordinal 663901"];
6610 [label="get\n            {\n                return _ordinal;\n            } 663902"];
6611 [label="return _ordinal; 663903"];
6612 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 663904"];
6613 [label="this.CorLibrary 663905"];
6614 [label="get\n            {\n                return _corLibrary;\n            } 663906"];
6615 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 663907"];
6616 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 663908"];
6617 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 663909"];
6618 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 663910"];
6619 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 663911"];
6620 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 663912"];
6621 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 663913"];
6622 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 663914"];
6623 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 663915"];
6624 [label="Interlocked.Increment(ref _cachedSpecialTypes); 663916"];
6625 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 663917"];
6626 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 663918"];
6627 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 663919"];
6628 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 663920"];
6629 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 663921"];
6630 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 663922"];
6631 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 663923"];
6632 [label="keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes; 663924"];
6633 [label="bool added; 663925"];
6634 [label="Debug.Assert(added); 663926"];
6635 [label="Debug.Assert(typeId != SpecialType.None); 663927"];
6636 [label="corType.ContainingAssembly 663928"];
6637 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 663929"];
6638 [label="this.ContainingSymbol 663930"];
6639 [label="get\n            {\n                return _container;\n            } 663931"];
6640 [label="return _container; 663932"];
6641 [label="var container = this.ContainingSymbol; 663933"];
6642 [label="return (object)container != null ? container.ContainingAssembly : null; 663934"];
6643 [label="return (object)container != null ? container.ContainingAssembly : null; 663935"];
6644 [label="(object)container != null 663936"];
6645 [label="container.ContainingAssembly 663937"];
6646 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 663938"];
6647 [label="ContainingPEModule 663939"];
6648 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 663940"];
6649 [label="return ContainingPEModule.ContainingAssembly; 663941"];
6650 [label="ContainingPEModule.ContainingAssembly 663942"];
6651 [label="get\n            {\n                return _assemblySymbol;\n            } 663943"];
6652 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 663944"];
6653 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 663945"];
6654 [label="corType.ContainingModule 663946"];
6655 [label="get\n            {\n                return ContainingPEModule;\n            } 663947"];
6656 [label="ContainingPEModule 663948"];
6657 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 663949"];
6658 [label="Symbol s = _container; 663950"];
6659 [label="s.Kind 663951"];
6660 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 663952"];
6661 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 663953"];
6662 [label="((PENamespaceSymbol)s).ContainingPEModule 663954"];
6663 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 663955"];
6664 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 663956"];
6665 [label="return ContainingPEModule; 663957"];
6666 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 663958"];
6667 [label="corType.ContainingModule.Ordinal 663959"];
6668 [label="get\n            {\n                return _ordinal;\n            } 663960"];
6669 [label="return _ordinal; 663961"];
6670 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 663962"];
6671 [label="this.CorLibrary 663963"];
6672 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 663964"];
6673 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 663965"];
6674 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 663966"];
6675 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 663967"];
6676 [label="bool added; 663968"];
6677 [label="Debug.Assert(added); 663969"];
6678 [label="Debug.Assert(typeId != SpecialType.None); 663970"];
6679 [label="corType.ContainingAssembly 663971"];
6680 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 663972"];
6681 [label="this.ContainingSymbol 663973"];
6682 [label="get\n            {\n                return _container;\n            } 663974"];
6683 [label="return _container; 663975"];
6684 [label="var container = this.ContainingSymbol; 663976"];
6685 [label="return (object)container != null ? container.ContainingAssembly : null; 663977"];
6686 [label="return (object)container != null ? container.ContainingAssembly : null; 663978"];
6687 [label="(object)container != null 663979"];
6688 [label="container.ContainingAssembly 663980"];
6689 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 663981"];
6690 [label="ContainingPEModule 663982"];
6691 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 663983"];
6692 [label="return ContainingPEModule.ContainingAssembly; 663984"];
6693 [label="ContainingPEModule.ContainingAssembly 663985"];
6694 [label="get\n            {\n                return _assemblySymbol;\n            } 663986"];
6695 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 663987"];
6696 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 663988"];
6697 [label="corType.ContainingModule 663989"];
6698 [label="get\n            {\n                return ContainingPEModule;\n            } 663990"];
6699 [label="ContainingPEModule 663991"];
6700 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 663992"];
6701 [label="Symbol s = _container; 663993"];
6702 [label="s.Kind 663994"];
6703 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 663995"];
6704 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 663996"];
6705 [label="((PENamespaceSymbol)s).ContainingPEModule 663997"];
6706 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 663998"];
6707 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 663999"];
6708 [label="return ContainingPEModule; 664000"];
6709 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 664001"];
6710 [label="corType.ContainingModule.Ordinal 664002"];
6711 [label="get\n            {\n                return _ordinal;\n            } 664003"];
6712 [label="return _ordinal; 664004"];
6713 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 664005"];
6714 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 664006"];
6715 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 664007"];
6716 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 664008"];
6717 [label="bool added; 664009"];
6718 [label="Debug.Assert(added); 664010"];
6719 [label="return _container; 664011"];
6720 [label="var container = this.ContainingSymbol; 664012"];
6721 [label="return (object)container != null ? container.ContainingAssembly : null; 664013"];
6722 [label="(object)container != null 664014"];
6723 [label="container.ContainingAssembly 664015"];
6724 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 664016"];
6725 [label="ContainingPEModule 664017"];
6726 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 664018"];
6727 [label="return ContainingPEModule.ContainingAssembly; 664019"];
6728 [label="ContainingPEModule.ContainingAssembly 664020"];
6729 [label="get\n            {\n                return _assemblySymbol;\n            } 664021"];
6730 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 664022"];
6731 [label="Symbol s = _container; 664023"];
6732 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 664024"];
6733 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 664025"];
6734 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 664026"];
6735 [label="return ContainingPEModule; 664027"];
6736 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 664028"];
6737 [label="get\n            {\n                return _ordinal;\n            } 664029"];
6738 [label="return _ordinal; 664030"];
6739 [label="LoadAllMembers(typesByNS); 664031"];
6740 [label="Interlocked.Exchange(ref _typesByNS, null); 664032"];
6741 [label="Interlocked.Exchange(ref _typesByNS, null); 664033"];
6742 [label="EnsureAllMembersLoaded(); 664034"];
6743 [label="ImmutableArray<PENamedTypeSymbol> t; 664035"];
6744 [label="t 664036"];
6745 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 664037"];
6746 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 664038"];
6747 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 664039"];
6748 [label="lazyTypes.TryGetValue(name, out t) 664040"];
6749 [label="foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    } 664041"];
6750 [label="named.Arity 664042"];
6751 [label="get\n                {\n                    return _arity;\n                } 664043"];
6752 [label="return _arity; 664044"];
6753 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 664045"];
6754 [label="named.MangleName 664046"];
6755 [label="get\n                {\n                    return _mangleName;\n                } 664047"];
6756 [label="return _mangleName; 664048"];
6757 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 664049"];
6758 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 664050"];
6759 [label="if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            } 664051"];
6760 [label="if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            } 664052"];
6761 [label="namedType = named; 664053"];
6762 [label="get\n                {\n                    return 0;\n                } 664054"];
6763 [label="return 0; 664055"];
6764 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 664056"];
6765 [label="int forcedArity = emittedTypeName.ForcedArity; 664057"];
6766 [label="if (emittedTypeName.UseCLSCompliantNameArityEncoding)\n            {\n                // Only types with arity 0 are acceptable, we already examined types with mangled names.\n                if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                }\n            } 664058"];
6767 [label="if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 664059"];
6768 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 664060"];
6769 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 664061"];
6770 [label="return namedType; 664062"];
6771 [label="Debug.Assert((object)result != null); 664063"];
6772 [label="Debug.Assert((object)result != null); 664064"];
6773 [label="return result; 664065"];
6774 [label="result.Kind 664066"];
6775 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 664067"];
6776 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 664068"];
6777 [label="result.DeclaredAccessibility 664069"];
6778 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 664070"];
6779 [label="Accessibility access = Accessibility.Private; 664071"];
6780 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 664072"];
6781 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 664073"];
6782 [label="RegisterDeclaredSpecialType(result); 664074"];
6783 [label="RegisterDeclaredSpecialType(result) 664075"];
6784 [label="param RegisterDeclaredSpecialType(NamedTypeSymbol corType) 664076"];
6785 [label="param RegisterDeclaredSpecialType(this) 664077"];
6786 [label="corType.SpecialType 664078"];
6787 [label="Debug.Assert(typeId != SpecialType.None); 664079"];
6788 [label="corType.ContainingAssembly 664080"];
6789 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 664081"];
6790 [label="this.ContainingSymbol 664082"];
6791 [label="get\n            {\n                return _container;\n            } 664083"];
6792 [label="return _container; 664084"];
6793 [label="var container = this.ContainingSymbol; 664085"];
6794 [label="return (object)container != null ? container.ContainingAssembly : null; 664086"];
6795 [label="return (object)container != null ? container.ContainingAssembly : null; 664087"];
6796 [label="(object)container != null 664088"];
6797 [label="container.ContainingAssembly 664089"];
6798 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 664090"];
6799 [label="ContainingPEModule 664091"];
6800 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 664092"];
6801 [label="return ContainingPEModule.ContainingAssembly; 664093"];
6802 [label="ContainingPEModule.ContainingAssembly 664094"];
6803 [label="get\n            {\n                return _assemblySymbol;\n            } 664095"];
6804 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 664096"];
6805 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 664097"];
6806 [label="corType.ContainingModule 664098"];
6807 [label="get\n            {\n                return ContainingPEModule;\n            } 664099"];
6808 [label="ContainingPEModule 664100"];
6809 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 664101"];
6810 [label="Symbol s = _container; 664102"];
6811 [label="s.Kind 664103"];
6812 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 664104"];
6813 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 664105"];
6814 [label="((PENamespaceSymbol)s).ContainingPEModule 664106"];
6815 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 664107"];
6816 [label="_containingNamespaceSymbol.ContainingPEModule 664108"];
6817 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 664109"];
6818 [label="return ContainingPEModule; 664110"];
6819 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 664111"];
6820 [label="corType.ContainingModule.Ordinal 664112"];
6821 [label="get\n            {\n                return _ordinal;\n            } 664113"];
6822 [label="return _ordinal; 664114"];
6823 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 664115"];
6824 [label="this.CorLibrary 664116"];
6825 [label="get\n            {\n                return _corLibrary;\n            } 664117"];
6826 [label="return _corLibrary; 664118"];
6827 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 664119"];
6828 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 664120"];
6829 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 664121"];
6830 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 664122"];
6831 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 664123"];
6832 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 664124"];
6833 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 664125"];
6834 [label="RegisterDeclaredSpecialType(result); 664126"];
6835 [label="return _lazySpecialTypes[(int)type]; 664127"];
6836 [label="result.SpecialType 664128"];
6837 [label="get\n            {\n                return _corTypeId;\n            } 664129"];
6838 [label="Debug.Assert(result.SpecialType == specialType); 664130"];
6839 [label="return result; 664131"];
6840 [label="varX.Type 664132"];
6841 [label="=> TypeWithAnnotations.Type 664133"];
6842 [label="TypeWithAnnotations 664134"];
6843 [label="get\n            {\n                return GetFieldType(ConsList<FieldSymbol>.Empty);\n            } 664135"];
6844 [label="return GetFieldType(ConsList<FieldSymbol>.Empty); 664136"];
6845 [label="GetFieldType(ConsList<FieldSymbol>.Empty) 664137"];
6846 [label="param GetFieldType(ConsList<FieldSymbol> fieldsBeingBound) 664138"];
6847 [label="param GetFieldType(this) 664139"];
6848 [label="Debug.Assert(fieldsBeingBound != null); 664140"];
6849 [label="Debug.Assert(fieldsBeingBound != null); 664141"];
6850 [label="if (_lazyType != null)\n            {\n                return _lazyType.Value;\n            } 664142"];
6851 [label="if (_lazyType != null)\n            {\n                return _lazyType.Value;\n            } 664143"];
6852 [label="VariableDeclaratorNode 664144"];
6853 [label="get\n            {\n                return (VariableDeclaratorSyntax)this.SyntaxNode;\n            } 664145"];
6854 [label="this.SyntaxNode 664146"];
6855 [label="get\n            {\n                return (CSharpSyntaxNode)_syntaxReference.GetSyntax();\n            } 664147"];
6856 [label="return (CSharpSyntaxNode)_syntaxReference.GetSyntax(); 664148"];
6857 [label="return (CSharpSyntaxNode)_syntaxReference.GetSyntax(); 664149"];
6858 [label="return (VariableDeclaratorSyntax)this.SyntaxNode; 664150"];
6859 [label="var declarator = VariableDeclaratorNode; 664151"];
6860 [label="var fieldSyntax = GetFieldDeclaration(declarator); 664152"];
6861 [label="GetFieldDeclaration(declarator) 664153"];
6862 [label="param GetFieldDeclaration(CSharpSyntaxNode declarator) 664154"];
6863 [label="return (BaseFieldDeclarationSyntax)declarator.Parent.Parent; 664155"];
6864 [label="var typeSyntax = fieldSyntax.Declaration.Type; 664156"];
6865 [label="this.DeclaringCompilation 664157"];
6866 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 664158"];
6867 [label="this.Kind 664159"];
6868 [label="get\n            {\n                return SymbolKind.Field;\n            } 664160"];
6869 [label="return SymbolKind.Field; 664161"];
6870 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 664162"];
6871 [label="this.ContainingModule 664163"];
6872 [label="this.ContainingSymbol 664164"];
6873 [label="get\n            {\n                return containingType;\n            } 664165"];
6874 [label="return containingType; 664166"];
6875 [label="return (object)container != null ? container.ContainingModule : null; 664167"];
6876 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 664168"];
6877 [label="var compilation = this.DeclaringCompilation; 664169"];
6878 [label="var diagnostics = DiagnosticBag.GetInstance(); 664170"];
6879 [label="TypeWithAnnotations type; 664171"];
6880 [label="type 664172"];
6881 [label="DiagnosticBag diagnosticsForFirstDeclarator = DiagnosticBag.GetInstance(); 664173"];
6882 [label="this.AssociatedSymbol 664174"];
6883 [label="get\n            {\n                return null;\n            } 664175"];
6884 [label="return null; 664176"];
6885 [label="Symbol associatedPropertyOrEvent = this.AssociatedSymbol; 664177"];
6886 [label="if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n            {\n                EventSymbol @event = (EventSymbol)associatedPropertyOrEvent;\n                if (@event.IsWindowsRuntimeEvent)\n                {\n                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T);\n                    Binder.ReportUseSiteDiagnostics(tokenTableType, diagnosticsForFirstDeclarator, this.ErrorLocation);\n\n                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T>\n                    // type that has additional generic constraints?\n                    type = TypeWithAnnotations.Create(tokenTableType.Construct(ImmutableArray.Create(@event.TypeWithAnnotations)));\n                }\n                else\n                {\n                    type = @event.TypeWithAnnotations;\n                }\n            }\n            else\n            {\n                var binderFactory = compilation.GetBinderFactory(SyntaxTree);\n                var binder = binderFactory.GetBinder(typeSyntax);\n\n                binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n                if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                }\n\n                if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                }\n            } 664178"];
6887 [label="if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n            {\n                EventSymbol @event = (EventSymbol)associatedPropertyOrEvent;\n                if (@event.IsWindowsRuntimeEvent)\n                {\n                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T);\n                    Binder.ReportUseSiteDiagnostics(tokenTableType, diagnosticsForFirstDeclarator, this.ErrorLocation);\n\n                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T>\n                    // type that has additional generic constraints?\n                    type = TypeWithAnnotations.Create(tokenTableType.Construct(ImmutableArray.Create(@event.TypeWithAnnotations)));\n                }\n                else\n                {\n                    type = @event.TypeWithAnnotations;\n                }\n            }\n            else\n            {\n                var binderFactory = compilation.GetBinderFactory(SyntaxTree);\n                var binder = binderFactory.GetBinder(typeSyntax);\n\n                binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n                if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                }\n\n                if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                }\n            } 664179"];
6888 [label="SyntaxTree 664180"];
6889 [label="get\n            {\n                return _syntaxReference.SyntaxTree;\n            } 664181"];
6890 [label="return _syntaxReference.SyntaxTree; 664182"];
6891 [label="var binderFactory = compilation.GetBinderFactory(SyntaxTree); 664183"];
6892 [label="var binderFactory = compilation.GetBinderFactory(SyntaxTree); 664184"];
6893 [label="compilation.GetBinderFactory(SyntaxTree) 664185"];
6894 [label="param GetBinderFactory(SyntaxTree syntaxTree) 664186"];
6895 [label="param GetBinderFactory(bool ignoreAccessibility = false) 664187"];
6896 [label="param GetBinderFactory(this) 664188"];
6897 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 664189"];
6898 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 664190"];
6899 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 664191"];
6900 [label="param GetBinderFactory(bool ignoreAccessibility) 664192"];
6901 [label="ignoreAccessibility 664193"];
6902 [label="GetSyntaxTreeOrdinal(syntaxTree) 664194"];
6903 [label="this.ContainsSyntaxTree(tree) 664195"];
6904 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 664196"];
6905 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 664197"];
6906 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 664198"];
6907 [label="BinderFactory? previousFactory; 664199"];
6908 [label="var previousWeakReference = binderFactories[treeNum]; 664200"];
6909 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 664201"];
6910 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 664202"];
6911 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 664203"];
6912 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 664204"];
6913 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 664205"];
6914 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 664206"];
6915 [label="param AddNewFactory(bool ignoreAccessibility) 664207"];
6916 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 664208"];
6917 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 664209"];
6918 [label="new BinderFactory(this, syntaxTree, ignoreAccessibility) 664210"];
6919 [label="param BinderFactory(bool ignoreAccessibility) 664211"];
6920 [label="param BinderFactory(this) 664212"];
6921 [label="_binderCache 664213"];
6922 [label="_compilation 664214"];
6923 [label="_syntaxTree 664215"];
6924 [label="_buckStopsHereBinder 664216"];
6925 [label="_ignoreAccessibility 664217"];
6926 [label="_binderFactoryVisitorPool 664218"];
6927 [label="_ignoreAccessibility 664219"];
6928 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 664220"];
6929 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 664221"];
6930 [label="_binderCache = new ConcurrentCache<BinderCacheKey, Binder>(50); 664222"];
6931 [label="_binderCache 664223"];
6932 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 664224"];
6933 [label="new BuckStopsHereBinder(compilation) 664225"];
6934 [label="param BuckStopsHereBinder(this) 664226"];
6935 [label="param BuckStopsHereBinder(this) 664227"];
6936 [label="param Binder(this) 664228"];
6937 [label="internal CSharpCompilation Compilation { get; } 664229"];
6938 [label="Flags 664230"];
6939 [label="protected internal Binder? Next { get; } 664231"];
6940 [label="_lazyConversions 664232"];
6941 [label="_lazyOverloadResolution 664233"];
6942 [label="RoslynDebug.Assert(compilation != null); 664234"];
6943 [label="RoslynDebug.Assert(compilation != null); 664235"];
6944 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 664236"];
6945 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 664237"];
6946 [label="compilation.Options 664238"];
6947 [label="_buckStopsHereBinder 664239"];
6948 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 664240"];
6949 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 664241"];
6950 [label="BinderFactory? previousFactory; 664242"];
6951 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 664243"];
6952 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 664244"];
6953 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 664245"];
6954 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 664246"];
6955 [label="var binder = binderFactory.GetBinder(typeSyntax); 664247"];
6956 [label="var binder = binderFactory.GetBinder(typeSyntax); 664248"];
6957 [label="binderFactory.GetBinder(typeSyntax) 664249"];
6958 [label="param GetBinder(SyntaxNode node) 664250"];
6959 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 664251"];
6960 [label="param GetBinder(Symbol memberOpt = null) 664252"];
6961 [label="param GetBinder(this) 664253"];
6962 [label="int position = node.SpanStart; 664254"];
6963 [label="InScript 664255"];
6964 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 664256"];
6965 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 664257"];
6966 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 664258"];
6967 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 664259"];
6968 [label="GetBinder(node, position, memberDeclarationOpt, memberOpt) 664260"];
6969 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 664261"];
6970 [label="param GetBinder(Symbol memberOpt = null) 664262"];
6971 [label="Debug.Assert(node != null); 664263"];
6972 [label="Debug.Assert(node != null); 664264"];
6973 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 664265"];
6974 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 664266"];
6975 [label="param BinderFactoryVisitor(this) 664267"];
6976 [label="_position 664268"];
6977 [label="_memberDeclarationOpt 664269"];
6978 [label="_memberOpt 664270"];
6979 [label="_factory 664271"];
6980 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 664272"];
6981 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 664273"];
6982 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt) 664274"];
6983 [label="param Initialize(CSharpSyntaxNode memberDeclarationOpt) 664275"];
6984 [label="param Initialize(Symbol memberOpt) 664276"];
6985 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 664277"];
6986 [label="memberDeclarationOpt == null 664278"];
6987 [label="param ==(Symbol left) 664279"];
6988 [label="param ==(Symbol right) 664280"];
6989 [label="if (right is null)\n            {\n                return left is null;\n            } 664281"];
6990 [label="return left is null; 664282"];
6991 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 664283"];
6992 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 664284"];
6993 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 664285"];
6994 [label="_memberDeclarationOpt 664286"];
6995 [label="_memberOpt 664287"];
6996 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 664288"];
6997 [label="visitor.Visit(node) 664289"];
6998 [label="VisitCore(node) 664290"];
6999 [label="return ((CSharpSyntaxNode)node).Accept(this); 664291"];
7000 [label="param DefaultVisit(SyntaxNode parent) 664292"];
7001 [label="param DefaultVisit(this) 664293"];
7002 [label="return VisitCore(parent.Parent); 664294"];
7003 [label="VisitCore(parent.Parent) 664295"];
7004 [label="param VisitCore(SyntaxNode node) 664296"];
7005 [label="param VisitCore(this) 664297"];
7006 [label="return ((CSharpSyntaxNode)node).Accept(this); 664298"];
7007 [label="param VisitFieldDeclaration(FieldDeclarationSyntax parent) 664299"];
7008 [label="param VisitFieldDeclaration(this) 664300"];
7009 [label="return VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers); 664301"];
7010 [label="VisitCore(parent.Parent) 664302"];
7011 [label="param VisitCore(SyntaxNode node) 664303"];
7012 [label="param VisitCore(this) 664304"];
7013 [label="return ((CSharpSyntaxNode)node).Accept(this); 664305"];
7014 [label="VisitTypeDeclarationCore(node) 664306"];
7015 [label="NodeUsage extraInfo = NodeUsage.Normal; 664307"];
7016 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 664308"];
7017 [label="VisitTypeDeclarationCore(parent, extraInfo) 664309"];
7018 [label="CreateBinderCacheKey(parent, extraInfo) 664310"];
7019 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 664311"];
7020 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 664312"];
7021 [label="return new BinderCacheKey(node, usage); 664313"];
7022 [label="new BinderCacheKey(node, usage) 664314"];
7023 [label="param BinderCacheKey(this) 664315"];
7024 [label="var key = CreateBinderCacheKey(parent, extraInfo); 664316"];
7025 [label="Binder resultBinder; 664317"];
7026 [label="binderCache 664318"];
7027 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 664319"];
7028 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 664320"];
7029 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 664321"];
7030 [label="SyntaxToken token; 664322"];
7031 [label="token 664323"];
7032 [label="Debug.Assert(!inUsing || inBody, 'inUsing => inBody'); 664324"];
7033 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 664325"];
7034 [label="Binder outer; 664326"];
7035 [label="var container = parent.Parent; 664327"];
7036 [label="Debug.Assert(node != null); 664328"];
7037 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 664329"];
7038 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 664330"];
7039 [label="memberDeclarationOpt == null 664331"];
7040 [label="param ==(Symbol left) 664332"];
7041 [label="param ==(Symbol right) 664333"];
7042 [label="if (right is null)\n            {\n                return left is null;\n            } 664334"];
7043 [label="return left is null; 664335"];
7044 [label="syntaxTree 664336"];
7045 [label="get\n                {\n                    return _factory._syntaxTree;\n                } 664337"];
7046 [label="return _factory._syntaxTree; 664338"];
7047 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 664339"];
7048 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 664340"];
7049 [label="RoslynDebug.Assert(next != null); 664341"];
7050 [label="_container 664342"];
7051 [label="Debug.Assert((object)container != null); 664343"];
7052 [label="Debug.Assert(declarationSyntax != null); 664344"];
7053 [label="param GetSimpleProgramEntryPoint(CompilationUnitSyntax compilationUnit) 664345"];
7054 [label="param GetSimpleProgramEntryPoint(bool fallbackToMainEntryPoint) 664346"];
7055 [label="GetBoundReferenceManager(); 664347"];
7056 [label="if (type is null)\n            {\n                return null;\n            } 664348"];
7057 [label="return null; 664349"];
7058 [label="param MakeNamespaceBinder(this) 664350"];
7059 [label="QualifiedNameSyntax dotted; 664351"];
7060 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 664352"];
7061 [label="NamespaceOrTypeSymbol container; 664353"];
7062 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 664354"];
7063 [label="if ((object)ns == null) return outer; 664355"];
7064 [label="Debug.Assert((object)container != null || imports != null); 664356"];
7065 [label="if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            } 664357"];
7066 [label="VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers) 664358"];
7067 [label="param WithUnsafeRegionIfNecessary(SyntaxTokenList modifiers) 664359"];
7068 [label="param WithUnsafeRegionIfNecessary(this) 664360"];
7069 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 664361"];
7070 [label="this.Flags.Includes(BinderFlags.UnsafeRegion) 664362"];
7071 [label="param Includes(BinderFlags other) 664363"];
7072 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 664364"];
7073 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 664365"];
7074 [label="binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this) 664366"];
7075 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags flags) 664367"];
7076 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(Symbol containing) 664368"];
7077 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(this) 664369"];
7078 [label="Debug.Assert((object)containing != null); 664370"];
7079 [label="Debug.Assert((object)containing != null); 664371"];
7080 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 664372"];
7081 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 664373"];
7082 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 664374"];
7083 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 664375"];
7084 [label="new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing) 664376"];
7085 [label="param BinderWithContainingMemberOrLambda(Binder next) 664377"];
7086 [label="param BinderWithContainingMemberOrLambda(BinderFlags flags) 664378"];
7087 [label="param BinderWithContainingMemberOrLambda(Symbol containingMemberOrLambda) 664379"];
7088 [label="param BinderWithContainingMemberOrLambda(this) 664380"];
7089 [label="next 664381"];
7090 [label="flags 664382"];
7091 [label="param BinderWithContainingMemberOrLambda(this) 664383"];
7092 [label="param Binder(Binder next) 664384"];
7093 [label="param Binder(BinderFlags flags) 664385"];
7094 [label="param Binder(this) 664386"];
7095 [label="internal CSharpCompilation Compilation { get; } 664387"];
7096 [label="Flags 664388"];
7097 [label="protected internal Binder? Next { get; } 664389"];
7098 [label="_lazyConversions 664390"];
7099 [label="_lazyOverloadResolution 664391"];
7100 [label="RoslynDebug.Assert(next != null); 664392"];
7101 [label="RoslynDebug.Assert(next != null); 664393"];
7102 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 664394"];
7103 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 664395"];
7104 [label="flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion) 664396"];
7105 [label="param Includes(this BinderFlags self) 664397"];
7106 [label="param Includes(BinderFlags other) 664398"];
7107 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 664399"];
7108 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 664400"];
7109 [label="flags.Includes(BinderFlags.InNestedFinallyBlock) 664401"];
7110 [label="param Includes(this BinderFlags self) 664402"];
7111 [label="param Includes(BinderFlags other) 664403"];
7112 [label="Next 664404"];
7113 [label="this.Flags 664405"];
7114 [label="this.Compilation 664406"];
7115 [label="_containingMemberOrLambda 664407"];
7116 [label="Debug.Assert(containingMemberOrLambda != null); 664408"];
7117 [label="containingMemberOrLambda != null 664409"];
7118 [label="param !=(Symbol left) 664410"];
7119 [label="param !=(Symbol right) 664411"];
7120 [label="if (right is null)\n            {\n                return left is object;\n            } 664412"];
7121 [label="return left is object; 664413"];
7122 [label="Debug.Assert(containingMemberOrLambda != null); 664414"];
7123 [label="_containingMemberOrLambda 664415"];
7124 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 664416"];
7125 [label="ContainingType 664417"];
7126 [label="get\n            {\n                return this.containingType;\n            } 664418"];
7127 [label="return this.containingType; 664419"];
7128 [label="if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                } 664420"];
7129 [label="ContainingType.IsScriptClass 664421"];
7130 [label="get\n            {\n                var kind = this.declaration.Declarations[0].Kind;\n                return kind == DeclarationKind.Script || kind == DeclarationKind.Submission;\n            } 664422"];
7131 [label="var kind = this.declaration.Declarations[0].Kind; 664423"];
7132 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 664424"];
7133 [label="type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator); 664425"];
7134 [label="type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator); 664426"];
7135 [label="type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator); 664427"];
7136 [label="binder.BindType(typeSyntax, diagnosticsForFirstDeclarator) 664428"];
7137 [label="param BindType(ExpressionSyntax syntax) 664429"];
7138 [label="param BindType(DiagnosticBag diagnostics) 664430"];
7139 [label="param BindType(ConsList<TypeSymbol> basesBeingResolved = null) 664431"];
7140 [label="param BindType(bool suppressUseSiteDiagnostics = false) 664432"];
7141 [label="param BindType(this) 664433"];
7142 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 664434"];
7143 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 664435"];
7144 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 664436"];
7145 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 664437"];
7146 [label="BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics) 664438"];
7147 [label="param BindTypeOrAlias(ExpressionSyntax syntax) 664439"];
7148 [label="param BindTypeOrAlias(DiagnosticBag diagnostics) 664440"];
7149 [label="param BindTypeOrAlias(ConsList<TypeSymbol> basesBeingResolved = null) 664441"];
7150 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 664442"];
7151 [label="param BindTypeOrAlias(this) 664443"];
7152 [label="Debug.Assert(diagnostics != null); 664444"];
7153 [label="Debug.Assert(diagnostics != null); 664445"];
7154 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 664446"];
7155 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 664447"];
7156 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 664448"];
7157 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 664449"];
7158 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 664450"];
7159 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 664451"];
7160 [label="BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics) 664452"];
7161 [label="param BindNamespaceOrTypeOrAliasSymbol(ExpressionSyntax syntax) 664453"];
7162 [label="param BindNamespaceOrTypeOrAliasSymbol(DiagnosticBag diagnostics) 664454"];
7163 [label="param BindNamespaceOrTypeOrAliasSymbol(ConsList<TypeSymbol> basesBeingResolved) 664455"];
7164 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 664456"];
7165 [label="param BindNamespaceOrTypeOrAliasSymbol(this) 664457"];
7166 [label="switch (syntax.Kind())\n            {\n                case SyntaxKind.NullableType:\n                    return bindNullable(syntax, diagnostics, basesBeingResolved);\n\n                case SyntaxKind.PredefinedType:\n                    return bindPredefined(syntax, diagnostics);\n\n                case SyntaxKind.IdentifierName:\n                    return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null);\n\n                case SyntaxKind.GenericName:\n                    return BindGenericSimpleNamespaceOrTypeOrAliasSymbol((GenericNameSyntax)syntax, diagnostics, basesBeingResolved, qualifierOpt: null);\n\n                case SyntaxKind.AliasQualifiedName:\n                    return bindAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n\n                case SyntaxKind.QualifiedName:\n                    {\n                        var node = (QualifiedNameSyntax)syntax;\n                        return BindQualifiedName(node.Left, node.Right, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                case SyntaxKind.SimpleMemberAccessExpression:\n                    {\n                        var node = (MemberAccessExpressionSyntax)syntax;\n                        return BindQualifiedName(node.Expression, node.Name, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                case SyntaxKind.ArrayType:\n                    {\n                        return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true);\n                    }\n\n                case SyntaxKind.PointerType:\n                    return bindPointer(syntax, diagnostics, basesBeingResolved);\n\n                case SyntaxKind.FunctionPointerType:\n                    var functionPointerTypeSyntax = (FunctionPointerTypeSyntax)syntax;\n                    if (GetUnsafeDiagnosticInfo(sizeOfTypeOpt: null) is CSDiagnosticInfo info)\n                    {\n                        var @delegate = functionPointerTypeSyntax.DelegateKeyword;\n                        var asterisk = functionPointerTypeSyntax.AsteriskToken;\n                        RoslynDebug.Assert(@delegate.SyntaxTree is object);\n                        diagnostics.Add(info, Location.Create(@delegate.SyntaxTree, TextSpan.FromBounds(@delegate.SpanStart, asterisk.Span.End)));\n                    }\n\n                    return TypeWithAnnotations.Create(\n                        FunctionPointerTypeSymbol.CreateFromSource(\n                            functionPointerTypeSyntax,\n                            this,\n                            diagnostics,\n                            basesBeingResolved,\n                            suppressUseSiteDiagnostics));\n\n                case SyntaxKind.OmittedTypeArgument:\n                    {\n                        return BindTypeArgument((TypeSyntax)syntax, diagnostics, basesBeingResolved);\n                    }\n\n                case SyntaxKind.TupleType:\n                    {\n                        var tupleTypeSyntax = (TupleTypeSyntax)syntax;\n                        return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(tupleTypeSyntax.CloseParenToken), BindTupleType(tupleTypeSyntax, diagnostics, basesBeingResolved));\n                    }\n\n                case SyntaxKind.RefType:\n                    {\n                        // ref needs to be handled by the caller\n                        var refTypeSyntax = (RefTypeSyntax)syntax;\n                        var refToken = refTypeSyntax.RefKeyword;\n                        if (!syntax.HasErrors)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_UnexpectedToken, refToken.GetLocation(), refToken.ToString());\n                        }\n\n                        return BindNamespaceOrTypeOrAliasSymbol(refTypeSyntax.Type, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                default:\n                    {\n                        // This is invalid syntax for a type.  This arises when a constant pattern that fails to bind\n                        // is attempted to be bound as a type pattern.\n                        return createErrorType(syntax);\n                    }\n            } 664458"];
7167 [label="return bindNullable(syntax, diagnostics, basesBeingResolved); 664459"];
7168 [label="return bindNullable(syntax, diagnostics, basesBeingResolved); 664460"];
7169 [label="return bindNullable(syntax, diagnostics, basesBeingResolved); 664461"];
7170 [label="bindNullable(syntax, diagnostics, basesBeingResolved) 664462"];
7171 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindNullable(ExpressionSyntax syntax, DiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved)\n            {\n                var nullableSyntax = (NullableTypeSyntax)syntax;\n                TypeSyntax typeArgumentSyntax = nullableSyntax.ElementType;\n                TypeWithAnnotations typeArgument = BindType(typeArgumentSyntax, diagnostics, basesBeingResolved);\n                TypeWithAnnotations constructedType = typeArgument.SetIsAnnotated(Compilation);\n\n                reportNullableReferenceTypesIfNeeded(nullableSyntax.QuestionToken, diagnostics, typeArgument);\n\n                if (!ShouldCheckConstraints)\n                {\n                    diagnostics.Add(new LazyUseSiteDiagnosticsInfoForNullableType(Compilation.LanguageVersion, constructedType), syntax.GetLocation());\n                }\n                else if (constructedType.IsNullableType())\n                {\n                    ReportUseSiteDiagnostics(constructedType.Type.OriginalDefinition, diagnostics, syntax);\n                    var type = (NamedTypeSymbol)constructedType.Type;\n                    var location = syntax.Location;\n                    type.CheckConstraints(new ConstraintsHelper.CheckConstraintsArgs(this.Compilation, this.Conversions, includeNullability: true, location, diagnostics));\n                }\n                else if (GetNullableUnconstrainedTypeParameterDiagnosticIfNecessary(Compilation.LanguageVersion, constructedType) is { } diagnosticInfo)\n                {\n                    diagnostics.Add(diagnosticInfo, syntax.Location);\n                }\n\n                return constructedType;\n            } 664463"];
7172 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindNullable(ExpressionSyntax syntax, DiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved)\n            {\n                var nullableSyntax = (NullableTypeSyntax)syntax;\n                TypeSyntax typeArgumentSyntax = nullableSyntax.ElementType;\n                TypeWithAnnotations typeArgument = BindType(typeArgumentSyntax, diagnostics, basesBeingResolved);\n                TypeWithAnnotations constructedType = typeArgument.SetIsAnnotated(Compilation);\n\n                reportNullableReferenceTypesIfNeeded(nullableSyntax.QuestionToken, diagnostics, typeArgument);\n\n                if (!ShouldCheckConstraints)\n                {\n                    diagnostics.Add(new LazyUseSiteDiagnosticsInfoForNullableType(Compilation.LanguageVersion, constructedType), syntax.GetLocation());\n                }\n                else if (constructedType.IsNullableType())\n                {\n                    ReportUseSiteDiagnostics(constructedType.Type.OriginalDefinition, diagnostics, syntax);\n                    var type = (NamedTypeSymbol)constructedType.Type;\n                    var location = syntax.Location;\n                    type.CheckConstraints(new ConstraintsHelper.CheckConstraintsArgs(this.Compilation, this.Conversions, includeNullability: true, location, diagnostics));\n                }\n                else if (GetNullableUnconstrainedTypeParameterDiagnosticIfNecessary(Compilation.LanguageVersion, constructedType) is { } diagnosticInfo)\n                {\n                    diagnostics.Add(diagnosticInfo, syntax.Location);\n                }\n\n                return constructedType;\n            } 664464"];
7173 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindNullable(ExpressionSyntax syntax, DiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved)\n            {\n                var nullableSyntax = (NullableTypeSyntax)syntax;\n                TypeSyntax typeArgumentSyntax = nullableSyntax.ElementType;\n                TypeWithAnnotations typeArgument = BindType(typeArgumentSyntax, diagnostics, basesBeingResolved);\n                TypeWithAnnotations constructedType = typeArgument.SetIsAnnotated(Compilation);\n\n                reportNullableReferenceTypesIfNeeded(nullableSyntax.QuestionToken, diagnostics, typeArgument);\n\n                if (!ShouldCheckConstraints)\n                {\n                    diagnostics.Add(new LazyUseSiteDiagnosticsInfoForNullableType(Compilation.LanguageVersion, constructedType), syntax.GetLocation());\n                }\n                else if (constructedType.IsNullableType())\n                {\n                    ReportUseSiteDiagnostics(constructedType.Type.OriginalDefinition, diagnostics, syntax);\n                    var type = (NamedTypeSymbol)constructedType.Type;\n                    var location = syntax.Location;\n                    type.CheckConstraints(new ConstraintsHelper.CheckConstraintsArgs(this.Compilation, this.Conversions, includeNullability: true, location, diagnostics));\n                }\n                else if (GetNullableUnconstrainedTypeParameterDiagnosticIfNecessary(Compilation.LanguageVersion, constructedType) is { } diagnosticInfo)\n                {\n                    diagnostics.Add(diagnosticInfo, syntax.Location);\n                }\n\n                return constructedType;\n            } 664465"];
7174 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindNullable(ExpressionSyntax syntax, DiagnosticBag diagnostics, ConsList<TypeSymbol> basesBeingResolved)\n            {\n                var nullableSyntax = (NullableTypeSyntax)syntax;\n                TypeSyntax typeArgumentSyntax = nullableSyntax.ElementType;\n                TypeWithAnnotations typeArgument = BindType(typeArgumentSyntax, diagnostics, basesBeingResolved);\n                TypeWithAnnotations constructedType = typeArgument.SetIsAnnotated(Compilation);\n\n                reportNullableReferenceTypesIfNeeded(nullableSyntax.QuestionToken, diagnostics, typeArgument);\n\n                if (!ShouldCheckConstraints)\n                {\n                    diagnostics.Add(new LazyUseSiteDiagnosticsInfoForNullableType(Compilation.LanguageVersion, constructedType), syntax.GetLocation());\n                }\n                else if (constructedType.IsNullableType())\n                {\n                    ReportUseSiteDiagnostics(constructedType.Type.OriginalDefinition, diagnostics, syntax);\n                    var type = (NamedTypeSymbol)constructedType.Type;\n                    var location = syntax.Location;\n                    type.CheckConstraints(new ConstraintsHelper.CheckConstraintsArgs(this.Compilation, this.Conversions, includeNullability: true, location, diagnostics));\n                }\n                else if (GetNullableUnconstrainedTypeParameterDiagnosticIfNecessary(Compilation.LanguageVersion, constructedType) is { } diagnosticInfo)\n                {\n                    diagnostics.Add(diagnosticInfo, syntax.Location);\n                }\n\n                return constructedType;\n            } 664466"];
7175 [label="var nullableSyntax = (NullableTypeSyntax)syntax; 664467"];
7176 [label="TypeSyntax typeArgumentSyntax = nullableSyntax.ElementType; 664468"];
7177 [label="TypeWithAnnotations typeArgument = BindType(typeArgumentSyntax, diagnostics, basesBeingResolved); 664469"];
7178 [label="TypeWithAnnotations typeArgument = BindType(typeArgumentSyntax, diagnostics, basesBeingResolved); 664470"];
7179 [label="TypeWithAnnotations typeArgument = BindType(typeArgumentSyntax, diagnostics, basesBeingResolved); 664471"];
7180 [label="TypeWithAnnotations typeArgument = BindType(typeArgumentSyntax, diagnostics, basesBeingResolved); 664472"];
7181 [label="BindType(typeArgumentSyntax, diagnostics, basesBeingResolved) 664473"];
7182 [label="param BindType(ExpressionSyntax syntax) 664474"];
7183 [label="param BindType(DiagnosticBag diagnostics) 664475"];
7184 [label="param BindType(ConsList<TypeSymbol> basesBeingResolved = null) 664476"];
7185 [label="param BindType(bool suppressUseSiteDiagnostics = false) 664477"];
7186 [label="param BindType(this) 664478"];
7187 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 664479"];
7188 [label="Debug.Assert(diagnostics != null); 664480"];
7189 [label="Debug.Assert(diagnostics != null); 664481"];
7190 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 664482"];
7191 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 664483"];
7192 [label="return bindPredefined(syntax, diagnostics); 664484"];
7193 [label="return bindPredefined(syntax, diagnostics); 664485"];
7194 [label="bindPredefined(syntax, diagnostics) 664486"];
7195 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindPredefined(ExpressionSyntax syntax, DiagnosticBag diagnostics)\n            {\n                var predefinedType = (PredefinedTypeSyntax)syntax;\n                var type = BindPredefinedTypeSymbol(predefinedType, diagnostics);\n                return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type);\n            } 664487"];
7196 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindPredefined(ExpressionSyntax syntax, DiagnosticBag diagnostics)\n            {\n                var predefinedType = (PredefinedTypeSyntax)syntax;\n                var type = BindPredefinedTypeSymbol(predefinedType, diagnostics);\n                return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type);\n            } 664488"];
7197 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindPredefined(ExpressionSyntax syntax, DiagnosticBag diagnostics)\n            {\n                var predefinedType = (PredefinedTypeSyntax)syntax;\n                var type = BindPredefinedTypeSymbol(predefinedType, diagnostics);\n                return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type);\n            } 664489"];
7198 [label="var predefinedType = (PredefinedTypeSyntax)syntax; 664490"];
7199 [label="var type = BindPredefinedTypeSymbol(predefinedType, diagnostics); 664491"];
7200 [label="var type = BindPredefinedTypeSymbol(predefinedType, diagnostics); 664492"];
7201 [label="BindPredefinedTypeSymbol(predefinedType, diagnostics) 664493"];
7202 [label="param BindPredefinedTypeSymbol(PredefinedTypeSyntax node) 664494"];
7203 [label="param BindPredefinedTypeSymbol(DiagnosticBag diagnostics) 664495"];
7204 [label="param BindPredefinedTypeSymbol(this) 664496"];
7205 [label="return GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node); 664497"];
7206 [label="return GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node); 664498"];
7207 [label="return GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node); 664499"];
7208 [label="GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node) 664500"];
7209 [label="param GetSpecialType(SpecialType typeId) 664501"];
7210 [label="param GetSpecialType(DiagnosticBag diagnostics) 664502"];
7211 [label="param GetSpecialType(SyntaxNode node) 664503"];
7212 [label="param GetSpecialType(this) 664504"];
7213 [label="return GetSpecialType(this.Compilation, typeId, node, diagnostics); 664505"];
7214 [label="return GetSpecialType(this.Compilation, typeId, node, diagnostics); 664506"];
7215 [label="return GetSpecialType(this.Compilation, typeId, node, diagnostics); 664507"];
7216 [label="return GetSpecialType(this.Compilation, typeId, node, diagnostics); 664508"];
7217 [label="GetSpecialType(this.Compilation, typeId, node, diagnostics) 664509"];
7218 [label="param GetSpecialType(CSharpCompilation compilation) 664510"];
7219 [label="param GetSpecialType(SpecialType typeId) 664511"];
7220 [label="param GetSpecialType(SyntaxNode node) 664512"];
7221 [label="param GetSpecialType(DiagnosticBag diagnostics) 664513"];
7222 [label="NamedTypeSymbol typeSymbol = compilation.GetSpecialType(typeId); 664514"];
7223 [label="compilation.GetSpecialType(typeId) 664515"];
7224 [label="param GetSpecialType(SpecialType specialType) 664516"];
7225 [label="param GetSpecialType(this) 664517"];
7226 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 664518"];
7227 [label="NamedTypeSymbol result; 664519"];
7228 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 664520"];
7229 [label="GetBoundReferenceManager(); 664521"];
7230 [label="this.Modules 664522"];
7231 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 664523"];
7232 [label="module.GetReferencedAssemblies() 664524"];
7233 [label="param GetReferencedAssemblies(this) 664525"];
7234 [label="AssertReferencesInitialized() 664526"];
7235 [label="param AssertReferencesInitialized(this) 664527"];
7236 [label="Debug.Assert(_moduleReferences != null); 664528"];
7237 [label="Debug.Assert(_moduleReferences != null); 664529"];
7238 [label="AssertReferencesInitialized(); 664530"];
7239 [label="return _moduleReferences.Identities; 664531"];
7240 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 664532"];
7241 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 664533"];
7242 [label="return _lazySpecialTypes[(int)type]; 664534"];
7243 [label="result.SpecialType 664535"];
7244 [label="get\n            {\n                return _corTypeId;\n            } 664536"];
7245 [label="Debug.Assert(result.SpecialType == specialType); 664537"];
7246 [label="return result; 664538"];
7247 [label="Debug.Assert((object)typeSymbol != null, 'Expect an error type if special type isn't found'); 664539"];
7248 [label="Debug.Assert((object)typeSymbol != null, 'Expect an error type if special type isn't found'); 664540"];
7249 [label="ReportUseSiteDiagnostics(typeSymbol, diagnostics, node); 664541"];
7250 [label="ReportUseSiteDiagnostics(typeSymbol, diagnostics, node); 664542"];
7251 [label="ReportUseSiteDiagnostics(typeSymbol, diagnostics, node); 664543"];
7252 [label="ReportUseSiteDiagnostics(typeSymbol, diagnostics, node) 664544"];
7253 [label="param ReportUseSiteDiagnostics(Symbol symbol) 664545"];
7254 [label="param ReportUseSiteDiagnostics(DiagnosticBag diagnostics) 664546"];
7255 [label="param ReportUseSiteDiagnostics(SyntaxNode node) 664547"];
7256 [label="symbol.GetUseSiteDiagnostic() 664548"];
7257 [label="param GetUseSiteDiagnostic(this) 664549"];
7258 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 664550"];
7259 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 664551"];
7260 [label="GetUseSiteDiagnosticImpl() 664552"];
7261 [label="param GetUseSiteDiagnosticImpl(this) 664553"];
7262 [label="DiagnosticInfo diagnostic = null; 664554"];
7263 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 664555"];
7264 [label="CalculateUseSiteDiagnostic() 664556"];
7265 [label="param CalculateUseSiteDiagnostic(this) 664557"];
7266 [label="DiagnosticInfo result = null; 664558"];
7267 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 664559"];
7268 [label="DeriveUseSiteDiagnosticFromBase() 664560"];
7269 [label="param DeriveUseSiteDiagnosticFromBase(this) 664561"];
7270 [label="this.BaseTypeNoUseSiteDiagnostics 664562"];
7271 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                }\n\n                return _lazyBaseType;\n            } 664563"];
7272 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 664564"];
7273 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 664565"];
7274 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 664566"];
7275 [label="MakeAcyclicBaseType() 664567"];
7276 [label="param MakeAcyclicBaseType(this) 664568"];
7277 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 664569"];
7278 [label="GetDeclaredBaseType(null) 664570"];
7279 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 664571"];
7280 [label="param GetDeclaredBaseType(this) 664572"];
7281 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 664573"];
7282 [label="GetDeclaredBaseType(skipTransformsIfNecessary: false) 664574"];
7283 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 664575"];
7284 [label="param GetDeclaredBaseType(this) 664576"];
7285 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 664577"];
7286 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 664578"];
7287 [label="MakeDeclaredBaseType() 664579"];
7288 [label="param MakeDeclaredBaseType(this) 664580"];
7289 [label="if (!_flags.IsInterface())\n            {\n                try\n                {\n                    var moduleSymbol = ContainingPEModule;\n                    EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle);\n                    if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    }\n                }\n                catch (BadImageFormatException mrEx)\n                {\n                    return new UnsupportedMetadataTypeSymbol(mrEx);\n                }\n            } 664581"];
7290 [label="ContainingPEModule 664582"];
7291 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 664583"];
7292 [label="Symbol s = _container; 664584"];
7293 [label="s.Kind 664585"];
7294 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 664586"];
7295 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 664587"];
7296 [label="((PENamespaceSymbol)s).ContainingPEModule 664588"];
7297 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 664589"];
7298 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 664590"];
7299 [label="var moduleSymbol = ContainingPEModule; 664591"];
7300 [label="moduleSymbol.Module 664592"];
7301 [label="get\n            {\n                return _module;\n            } 664593"];
7302 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 664594"];
7303 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 664595"];
7304 [label="if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    } 664596"];
7305 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 664597"];
7306 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 664598"];
7307 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 664599"];
7308 [label="new MetadataDecoder(moduleSymbol, this) 664600"];
7309 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 664601"];
7310 [label="param MetadataDecoder(PENamedTypeSymbol context) 664602"];
7311 [label="param MetadataDecoder(this) 664603"];
7312 [label="moduleSymbol 664604"];
7313 [label="context 664605"];
7314 [label="null 664606"];
7315 [label="param MetadataDecoder(this) 664607"];
7316 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 664608"];
7317 [label="param MetadataDecoder(PENamedTypeSymbol typeContextOpt) 664609"];
7318 [label="param MetadataDecoder(PEMethodSymbol methodContextOpt) 664610"];
7319 [label="param MetadataDecoder(this) 664611"];
7320 [label="moduleSymbol.Module 664612"];
7321 [label="get\n            {\n                return _module;\n            } 664613"];
7322 [label="moduleSymbol.ContainingAssembly 664614"];
7323 [label="get\n            {\n                return _assemblySymbol;\n            } 664615"];
7324 [label="(moduleSymbol.ContainingAssembly is PEAssemblySymbol) 664616"];
7325 [label="moduleSymbol.ContainingAssembly 664617"];
7326 [label="moduleSymbol.ContainingAssembly.Identity 664618"];
7327 [label="get\n            {\n                return _assembly.Identity;\n            } 664619"];
7328 [label="return _assembly.Identity; 664620"];
7329 [label="new SymbolFactory() 664621"];
7330 [label="param SymbolFactory(this) 664622"];
7331 [label="Instance = new SymbolFactory() 664623"];
7332 [label="SymbolFactory.Instance 664624"];
7333 [label="moduleSymbol 664625"];
7334 [label="param MetadataDecoder(this) 664626"];
7335 [label="param MetadataDecoder(this) 664627"];
7336 [label="_typeContextOpt 664628"];
7337 [label="_methodContextOpt 664629"];
7338 [label="Debug.Assert((object)moduleSymbol != null); 664630"];
7339 [label="Debug.Assert((object)moduleSymbol != null); 664631"];
7340 [label="_typeContextOpt 664632"];
7341 [label="_methodContextOpt 664633"];
7342 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 664634"];
7343 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 664635"];
7344 [label="param GetTypeHandleToTypeMap(this) 664636"];
7345 [label="return moduleSymbol.TypeHandleToTypeMap; 664637"];
7346 [label="var baseType = MakeDeclaredBaseType(); 664638"];
7347 [label="if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                } 664639"];
7348 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 664640"];
7349 [label="ContainingPEModule 664641"];
7350 [label="s.Kind 664642"];
7351 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 664643"];
7352 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 664644"];
7353 [label="var moduleSymbol = ContainingPEModule; 664645"];
7354 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 664646"];
7355 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 664647"];
7356 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 664648"];
7357 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 664649"];
7358 [label="DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol) 664650"];
7359 [label="param TransformType(TypeSymbol metadataType) 664651"];
7360 [label="param TransformType(int targetSymbolCustomModifierCount) 664652"];
7361 [label="param TransformType(EntityHandle targetSymbolToken) 664653"];
7362 [label="param TransformType(PEModuleSymbol containingModule) 664654"];
7363 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 664655"];
7364 [label="Debug.Assert((object)metadataType != null); 664656"];
7365 [label="Debug.Assert((object)metadataType != null); 664657"];
7366 [label="ImmutableArray<bool> dynamicTransformFlags; 664658"];
7367 [label="dynamicTransformFlags 664659"];
7368 [label="containingModule.Module 664660"];
7369 [label="get\n            {\n                return _module;\n            } 664661"];
7370 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 664662"];
7371 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 664663"];
7372 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 664664"];
7373 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 664665"];
7374 [label="return metadataType; 664666"];
7375 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 664667"];
7376 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 664668"];
7377 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 664669"];
7378 [label="NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol) 664670"];
7379 [label="param TransformType(TypeSymbol type) 664671"];
7380 [label="param TransformType(EntityHandle handle) 664672"];
7381 [label="param TransformType(PEModuleSymbol containingModule) 664673"];
7382 [label="containingModule.Module 664674"];
7383 [label="get\n            {\n                return _module;\n            } 664675"];
7384 [label="return _module; 664676"];
7385 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 664677"];
7386 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 664678"];
7387 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 664679"];
7388 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 664680"];
7389 [label="containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) 664681"];
7390 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 664682"];
7391 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 664683"];
7392 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 664684"];
7393 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 664685"];
7394 [label="TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol) 664686"];
7395 [label="param DecodeTupleTypesIfApplicable(TypeSymbol metadataType) 664687"];
7396 [label="param DecodeTupleTypesIfApplicable(EntityHandle targetHandle) 664688"];
7397 [label="param DecodeTupleTypesIfApplicable(PEModuleSymbol containingModule) 664689"];
7398 [label="ImmutableArray<string?> elementNames; 664690"];
7399 [label="elementNames 664691"];
7400 [label="containingModule\n                .Module 664692"];
7401 [label="get\n            {\n                return _module;\n            } 664693"];
7402 [label="return _module; 664694"];
7403 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 664695"];
7404 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 664696"];
7405 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 664697"];
7406 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 664698"];
7407 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 664699"];
7408 [label="return DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute); 664700"];
7409 [label="return DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute); 664701"];
7410 [label="DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute) 664702"];
7411 [label="param DecodeTupleTypesInternal(TypeSymbol metadataType) 664703"];
7412 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 664704"];
7413 [label="param DecodeTupleTypesInternal(bool hasTupleElementNamesAttribute) 664705"];
7414 [label="RoslynDebug.AssertNotNull(metadataType); 664706"];
7415 [label="RoslynDebug.AssertNotNull(metadataType); 664707"];
7416 [label="var decoder = new TupleTypeDecoder(elementNames); 664708"];
7417 [label="var decoder = new TupleTypeDecoder(elementNames); 664709"];
7418 [label="new TupleTypeDecoder(elementNames) 664710"];
7419 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 664711"];
7420 [label="param TupleTypeDecoder(this) 664712"];
7421 [label="_elementNames 664713"];
7422 [label="elementNames.IsDefault 664714"];
7423 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 664715"];
7424 [label="_namesIndex 664716"];
7425 [label="_decodingFailed = false; 664717"];
7426 [label="_decodingFailed 664718"];
7427 [label="_foundUsableErrorType = false; 664719"];
7428 [label="_foundUsableErrorType 664720"];
7429 [label="var decoded = decoder.DecodeType(metadataType); 664721"];
7430 [label="decoder.DecodeType(metadataType) 664722"];
7431 [label="param DecodeType(TypeSymbol type) 664723"];
7432 [label="param DecodeType(this) 664724"];
7433 [label="type.Kind 664725"];
7434 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 664726"];
7435 [label="switch (type.Kind)\n            {\n                case SymbolKind.ErrorType:\n                    _foundUsableErrorType = true;\n                    return type;\n\n                case SymbolKind.DynamicType:\n                case SymbolKind.TypeParameter:\n                    return type;\n\n                case SymbolKind.FunctionPointerType:\n                    return DecodeFunctionPointerType((FunctionPointerTypeSymbol)type);\n\n                case SymbolKind.PointerType:\n                    return DecodePointerType((PointerTypeSymbol)type);\n\n                case SymbolKind.NamedType:\n                    // We may have a tuple type from a substituted type symbol,\n                    // but it will be missing names from metadata, so we'll\n                    // need to re-create the type.\n                    //\n                    // Consider the declaration\n                    //\n                    //      class C : BaseType<(int x, int y)>\n                    //\n                    // The process for decoding tuples in C looks at the BaseType, calls\n                    // DecodeOrThrow, then passes the decoded type to the TupleTypeDecoder.\n                    // However, DecodeOrThrow uses the AbstractTypeMap to construct a\n                    // SubstitutedTypeSymbol, which eagerly converts tuple-compatible\n                    // types to TupleTypeSymbols. Thus, by the time we get to the Decoder\n                    // all metadata instances of System.ValueTuple will have been\n                    //  replaced with TupleTypeSymbols without names.\n                    // \n                    // Rather than fixing up after-the-fact it's possible that we could\n                    // flow up a SubstituteWith/Without tuple unification to the top level\n                    // of the type map and change DecodeOrThrow to call into the substitution\n                    // without unification instead.\n                    return DecodeNamedType((NamedTypeSymbol)type);\n\n                case SymbolKind.ArrayType:\n                    return DecodeArrayType((ArrayTypeSymbol)type);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(type.TypeKind);\n            } 664727"];
7436 [label="return DecodeNamedType((NamedTypeSymbol)type); 664728"];
7437 [label="DecodeNamedType((NamedTypeSymbol)type) 664729"];
7438 [label="param DecodeNamedType(NamedTypeSymbol type) 664730"];
7439 [label="param DecodeNamedType(this) 664731"];
7440 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 664732"];
7441 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 664733"];
7442 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 664734"];
7443 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 664735"];
7444 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 664736"];
7445 [label="DecodeTypeArguments(typeArgs) 664737"];
7446 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 664738"];
7447 [label="param DecodeTypeArguments(this) 664739"];
7448 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 664740"];
7449 [label="return typeArgs; 664741"];
7450 [label="NamedTypeSymbol decodedType = type; 664742"];
7451 [label="type.ContainingType 664743"];
7452 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 664744"];
7453 [label="return _container as NamedTypeSymbol; 664745"];
7454 [label="NamedTypeSymbol containingType = type.ContainingType; 664746"];
7455 [label="NamedTypeSymbol? decodedContainingType; 664747"];
7456 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 664748"];
7457 [label="decodedContainingType = containingType; 664749"];
7458 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 664750"];
7459 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 664751"];
7460 [label="var typeArgsChanged = typeArgs != decodedArgs; 664752"];
7461 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 664753"];
7462 [label="decodedType.IsTupleType 664754"];
7463 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 664755"];
7464 [label="_ 664756"];
7465 [label="tupleCardinality: out _ 664757"];
7466 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 664758"];
7467 [label="param IsTupleTypeOfCardinality(this) 664759"];
7468 [label="IsUnboundGenericType 664760"];
7469 [label="get\n            {\n                return false;\n            } 664761"];
7470 [label="return false; 664762"];
7471 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 664763"];
7472 [label="ContainingSymbol 664764"];
7473 [label="get\n            {\n                return _container;\n            } 664765"];
7474 [label="return _container; 664766"];
7475 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 664767"];
7476 [label=".Kind 664768"];
7477 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 664769"];
7478 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 664770"];
7479 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 664771"];
7480 [label="ContainingNamespace 664772"];
7481 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 664773"];
7482 [label="get\n            {\n                return _container;\n            } 664774"];
7483 [label="return _container; 664775"];
7484 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 664776"];
7485 [label="ContainingNamespace.ContainingNamespace 664777"];
7486 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 664778"];
7487 [label=".IsGlobalNamespace 664779"];
7488 [label="get\n            {\n                return true;\n            } 664780"];
7489 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 664781"];
7490 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 664782"];
7491 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 664783"];
7492 [label="Name 664784"];
7493 [label="get\n            {\n                return _name;\n            } 664785"];
7494 [label="return _name; 664786"];
7495 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 664787"];
7496 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 664788"];
7497 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 664789"];
7498 [label="tupleCardinality = 0; 664790"];
7499 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 664791"];
7500 [label="return decodedType; 664792"];
7501 [label="if (!decoder._decodingFailed)\n            {\n                if (!hasTupleElementNamesAttribute || decoder._namesIndex == 0)\n                {\n                    return decoded;\n                }\n            } 664793"];
7502 [label="if (!hasTupleElementNamesAttribute || decoder._namesIndex == 0)\n                {\n                    return decoded;\n                } 664794"];
7503 [label="return decoded; 664795"];
7504 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 664796"];
7505 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 664797"];
7506 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 664798"];
7507 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 664799"];
7508 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 664800"];
7509 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 664801"];
7510 [label="DebuggerDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 664802"];
7511 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 664803"];
7512 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 664804"];
7513 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 664805"];
7514 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 664806"];
7515 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 664807"];
7516 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 664808"];
7517 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 664809"];
7518 [label="TestDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 664810"];
7519 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 664811"];
7520 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 664812"];
7521 [label="TypeWithAnnotations.Create(decodedType) 664813"];
7522 [label="param Create(TypeSymbol typeSymbol) 664814"];
7523 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 664815"];
7524 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 664816"];
7525 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 664817"];
7526 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 664818"];
7527 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 664819"];
7528 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 664820"];
7529 [label="typeSymbol.IsNullableType() 664821"];
7530 [label="param IsNullableType(this TypeSymbol type) 664822"];
7531 [label="type.OriginalDefinition 664823"];
7532 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 664824"];
7533 [label="OriginalTypeSymbolDefinition 664825"];
7534 [label="get\n            {\n                return this.OriginalDefinition;\n            } 664826"];
7535 [label="this.OriginalDefinition 664827"];
7536 [label="get\n            {\n                return this;\n            } 664828"];
7537 [label="return this; 664829"];
7538 [label="return this.OriginalDefinition; 664830"];
7539 [label="return OriginalTypeSymbolDefinition; 664831"];
7540 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 664832"];
7541 [label="type.OriginalDefinition.SpecialType 664833"];
7542 [label="get\n            {\n                return _corTypeId;\n            } 664834"];
7543 [label="return _corTypeId; 664835"];
7544 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 664836"];
7545 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 664837"];
7546 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 664838"];
7547 [label="CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()) 664839"];
7548 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 664840"];
7549 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 664841"];
7550 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 664842"];
7551 [label="customModifiers: ImmutableArray<CustomModifier>.Empty 664843"];
7552 [label="new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 664844"];
7553 [label="param NonLazyType(ImmutableArray<CustomModifier> customModifiers) 664845"];
7554 [label="param NonLazyType(this) 664846"];
7555 [label="param Extensions(this) 664847"];
7556 [label="Debug.Assert(!customModifiers.IsDefault); 664848"];
7557 [label="_customModifiers 664849"];
7558 [label="Default = new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 664850"];
7559 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 664851"];
7560 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 664852"];
7561 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 664853"];
7562 [label="Extensions.Create(customModifiers) 664854"];
7563 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 664855"];
7564 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 664856"];
7565 [label="return Default; 664857"];
7566 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 664858"];
7567 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 664859"];
7568 [label="param TypeWithAnnotations(TypeSymbol defaultType) 664860"];
7569 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 664861"];
7570 [label="param TypeWithAnnotations(Extensions extensions) 664862"];
7571 [label="param TypeWithAnnotations(this) 664863"];
7572 [label="var a1 = defaultType is null; 664864"];
7573 [label="!a1 664865"];
7574 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 664866"];
7575 [label="defaultType.IsNullableType() 664867"];
7576 [label="param IsNullableType(this TypeSymbol type) 664868"];
7577 [label="type.OriginalDefinition 664869"];
7578 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 664870"];
7579 [label="OriginalTypeSymbolDefinition 664871"];
7580 [label="get\n            {\n                return this.OriginalDefinition;\n            } 664872"];
7581 [label="this.OriginalDefinition 664873"];
7582 [label="get\n            {\n                return this;\n            } 664874"];
7583 [label="return this; 664875"];
7584 [label="return this.OriginalDefinition; 664876"];
7585 [label="return OriginalTypeSymbolDefinition; 664877"];
7586 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 664878"];
7587 [label="type.OriginalDefinition.SpecialType 664879"];
7588 [label="get\n            {\n                return _corTypeId;\n            } 664880"];
7589 [label="return _corTypeId; 664881"];
7590 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 664882"];
7591 [label="Debug.Assert(a1 || a2 != true || a3); 664883"];
7592 [label="Debug.Assert(a1 || a2 != true || a3); 664884"];
7593 [label="Debug.Assert(extensions != null); 664885"];
7594 [label="Debug.Assert(extensions != null); 664886"];
7595 [label="DefaultType 664887"];
7596 [label="NullableAnnotation 664888"];
7597 [label="_extensions 664889"];
7598 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 664890"];
7599 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 664891"];
7600 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 664892"];
7601 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 664893"];
7602 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 664894"];
7603 [label="NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this) 664895"];
7604 [label="param TransformType(TypeWithAnnotations metadataType) 664896"];
7605 [label="param TransformType(EntityHandle targetSymbolToken) 664897"];
7606 [label="param TransformType(PEModuleSymbol containingModule) 664898"];
7607 [label="param TransformType(Symbol accessSymbol) 664899"];
7608 [label="param TransformType(Symbol nullableContext) 664900"];
7609 [label="metadataType.HasType 664901"];
7610 [label="=> !(DefaultType is null) 664902"];
7611 [label="DefaultType is null 664903"];
7612 [label="!(DefaultType is null) 664904"];
7613 [label="Debug.Assert(metadataType.HasType); 664905"];
7614 [label="accessSymbol.IsDefinition 664906"];
7615 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 664907"];
7616 [label="OriginalDefinition 664908"];
7617 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 664909"];
7618 [label="OriginalSymbolDefinition 664910"];
7619 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 664911"];
7620 [label="this.OriginalTypeSymbolDefinition 664912"];
7621 [label="get\n            {\n                return this.OriginalDefinition;\n            } 664913"];
7622 [label="this.OriginalDefinition 664914"];
7623 [label="get\n            {\n                return this;\n            } 664915"];
7624 [label="return this; 664916"];
7625 [label="return this.OriginalDefinition; 664917"];
7626 [label="return this.OriginalTypeSymbolDefinition; 664918"];
7627 [label="return OriginalSymbolDefinition; 664919"];
7628 [label="return (object)this == (object)OriginalDefinition; 664920"];
7629 [label="Debug.Assert(accessSymbol.IsDefinition); 664921"];
7630 [label="accessSymbol.ContainingModule 664922"];
7631 [label="get\n            {\n                return ContainingPEModule;\n            } 664923"];
7632 [label="ContainingPEModule 664924"];
7633 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 664925"];
7634 [label="Symbol s = _container; 664926"];
7635 [label="s.Kind 664927"];
7636 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 664928"];
7637 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 664929"];
7638 [label="return ContainingPEModule; 664930"];
7639 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 664931"];
7640 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 664932"];
7641 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 664933"];
7642 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 664934"];
7643 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 664935"];
7644 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 664936"];
7645 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 664937"];
7646 [label="Debug.Assert(symbol is object); 664938"];
7647 [label="symbol.Kind 664939"];
7648 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 664940"];
7649 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 664941"];
7650 [label="isInternal = false; 664942"];
7651 [label="symbol.DeclaredAccessibility 664943"];
7652 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 664944"];
7653 [label="Accessibility access = Accessibility.Private; 664945"];
7654 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 664946"];
7655 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 664947"];
7656 [label="symbol.ContainingType 664948"];
7657 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 664949"];
7658 [label="return _container as NamedTypeSymbol; 664950"];
7659 [label="symbol = symbol.ContainingType; 664951"];
7660 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 664952"];
7661 [label="return true; 664953"];
7662 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 664954"];
7663 [label="byte defaultTransformFlag; 664955"];
7664 [label="ImmutableArray<byte> nullableTransformFlags; 664956"];
7665 [label="nullableTransformFlags 664957"];
7666 [label="containingModule.Module 664958"];
7667 [label="get\n            {\n                return _module;\n            } 664959"];
7668 [label="return _module; 664960"];
7669 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 664961"];
7670 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 664962"];
7671 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 664963"];
7672 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 664964"];
7673 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 664965"];
7674 [label="nullableContext.GetNullableContextValue() 664966"];
7675 [label="param GetNullableContextValue(this) 664967"];
7676 [label="byte? value; 664968"];
7677 [label="if (!_lazyNullableContextValue.TryGetByte(out value))\n            {\n                value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue();\n                _lazyNullableContextValue = value.ToNullableContextFlags();\n            } 664969"];
7678 [label="if (!_lazyNullableContextValue.TryGetByte(out value))\n            {\n                value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue();\n                _lazyNullableContextValue = value.ToNullableContextFlags();\n            } 664970"];
7679 [label="_lazyNullableContextValue.TryGetByte(out value) 664971"];
7680 [label="param TryGetByte(this NullableContextKind kind) 664972"];
7681 [label="param TryGetByte(out byte? value) 664973"];
7682 [label="switch (kind)\n            {\n                case NullableContextKind.Unknown:\n                    value = null;\n                    return false;\n                case NullableContextKind.None:\n                    value = null;\n                    return true;\n                case NullableContextKind.Oblivious:\n                    value = NullableAnnotationExtensions.ObliviousAttributeValue;\n                    return true;\n                case NullableContextKind.NotAnnotated:\n                    value = NullableAnnotationExtensions.NotAnnotatedAttributeValue;\n                    return true;\n                case NullableContextKind.Annotated:\n                    value = NullableAnnotationExtensions.AnnotatedAttributeValue;\n                    return true;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 664974"];
7683 [label="value = null; 664975"];
7684 [label="return false; 664976"];
7685 [label="ContainingPEModule 664977"];
7686 [label="s.Kind 664978"];
7687 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 664979"];
7688 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 664980"];
7689 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 664981"];
7690 [label="ContainingPEModule.Module 664982"];
7691 [label="get\n            {\n                return _module;\n            } 664983"];
7692 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 664984"];
7693 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 664985"];
7694 [label="ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) 664986"];
7695 [label="_container.GetNullableContextValue() 664987"];
7696 [label="param GetNullableContextValue(this) 664988"];
7697 [label="GetLocalNullableContextValue() 664989"];
7698 [label="param GetLocalNullableContextValue(this) 664990"];
7699 [label="return null; 664991"];
7700 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 664992"];
7701 [label="ContainingSymbol 664993"];
7702 [label="get { return _containingNamespaceSymbol; } 664994"];
7703 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 664995"];
7704 [label=".GetNullableContextValue() 664996"];
7705 [label="param GetNullableContextValue(this) 664997"];
7706 [label="GetLocalNullableContextValue() 664998"];
7707 [label="param GetLocalNullableContextValue(this) 664999"];
7708 [label="return null; 665000"];
7709 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 665001"];
7710 [label="ContainingSymbol 665002"];
7711 [label="get\n            {\n                return _moduleSymbol;\n            } 665003"];
7712 [label="return _moduleSymbol; 665004"];
7713 [label="param GetLocalNullableContextValue(this) 665005"];
7714 [label="get\n            {\n                return _assemblySymbol;\n            } 665006"];
7715 [label="return _assemblySymbol; 665007"];
7716 [label="param GetLocalNullableContextValue(this) 665008"];
7717 [label="get\n            {\n                return null;\n            } 665009"];
7718 [label="return null; 665010"];
7719 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 665011"];
7720 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 665012"];
7721 [label="_lazyNullableContextValue = value.ToNullableContextFlags(); 665013"];
7722 [label="value.ToNullableContextFlags() 665014"];
7723 [label="param ToNullableContextFlags(this byte? value) 665015"];
7724 [label="switch (value)\n            {\n                case null:\n                    return NullableContextKind.None;\n                case NullableAnnotationExtensions.ObliviousAttributeValue:\n                    return NullableContextKind.Oblivious;\n                case NullableAnnotationExtensions.NotAnnotatedAttributeValue:\n                    return NullableContextKind.NotAnnotated;\n                case NullableAnnotationExtensions.AnnotatedAttributeValue:\n                    return NullableContextKind.Annotated;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(value);\n            } 665016"];
7725 [label="return NullableContextKind.None; 665017"];
7726 [label="_lazyNullableContextValue 665018"];
7727 [label="return value; 665019"];
7728 [label="byte? value = nullableContext.GetNullableContextValue(); 665020"];
7729 [label="if (value == null)\n                {\n                    return metadataType;\n                } 665021"];
7730 [label="if (value == null)\n                {\n                    return metadataType;\n                } 665022"];
7731 [label="return metadataType; 665023"];
7732 [label="NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type 665024"];
7733 [label="=> _extensions?.GetResolvedType(DefaultType) 665025"];
7734 [label="DefaultType 665026"];
7735 [label=".GetResolvedType(DefaultType) 665027"];
7736 [label="param GetResolvedType(TypeSymbol defaultType) 665028"];
7737 [label="=> defaultType 665029"];
7738 [label="defaultType 665030"];
7739 [label="_extensions?.GetResolvedType(DefaultType) 665031"];
7740 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 665032"];
7741 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 665033"];
7742 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 665034"];
7743 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 665035"];
7744 [label="return _lazyDeclaredBaseType; 665036"];
7745 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 665037"];
7746 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 665038"];
7747 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 665039"];
7748 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 665040"];
7749 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return CyclicInheritanceError(this, declaredBase);\n            } 665041"];
7750 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return CyclicInheritanceError(this, declaredBase);\n            } 665042"];
7751 [label="BaseTypeAnalysis.TypeDependsOn(declaredBase, this) 665043"];
7752 [label="param TypeDependsOn(NamedTypeSymbol depends) 665044"];
7753 [label="param TypeDependsOn(NamedTypeSymbol on) 665045"];
7754 [label="Debug.Assert((object)depends != null); 665046"];
7755 [label="Debug.Assert((object)depends != null); 665047"];
7756 [label="Debug.Assert((object)on != null); 665048"];
7757 [label="Debug.Assert((object)on != null); 665049"];
7758 [label="on.IsDefinition 665050"];
7759 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 665051"];
7760 [label="OriginalDefinition 665052"];
7761 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 665053"];
7762 [label="OriginalSymbolDefinition 665054"];
7763 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 665055"];
7764 [label="this.OriginalTypeSymbolDefinition 665056"];
7765 [label="get\n            {\n                return this.OriginalDefinition;\n            } 665057"];
7766 [label="this.OriginalDefinition 665058"];
7767 [label="get\n            {\n                return this;\n            } 665059"];
7768 [label="return this; 665060"];
7769 [label="return this.OriginalDefinition; 665061"];
7770 [label="return this.OriginalTypeSymbolDefinition; 665062"];
7771 [label="return OriginalSymbolDefinition; 665063"];
7772 [label="return (object)this == (object)OriginalDefinition; 665064"];
7773 [label="Debug.Assert(on.IsDefinition); 665065"];
7774 [label="var hs = PooledHashSet<Symbol>.GetInstance(); 665066"];
7775 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 665067"];
7776 [label="depends.DeclaringCompilation 665068"];
7777 [label="get { return null; } 665069"];
7778 [label="return null; 665070"];
7779 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 665071"];
7780 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 665072"];
7781 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs) 665073"];
7782 [label="param TypeDependsClosure(NamedTypeSymbol type) 665074"];
7783 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 665075"];
7784 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 665076"];
7785 [label="if ((object)type == null)\n            {\n                return;\n            } 665077"];
7786 [label="if ((object)type == null)\n            {\n                return;\n            } 665078"];
7787 [label="type.OriginalDefinition 665079"];
7788 [label="get\n            {\n                return this;\n            } 665080"];
7789 [label="return this; 665081"];
7790 [label="type = type.OriginalDefinition; 665082"];
7791 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 665083"];
7792 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 665084"];
7793 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 665085"];
7794 [label="param GetHashCode(this) 665086"];
7795 [label="this.SpecialType 665087"];
7796 [label="get\n            {\n                return _corTypeId;\n            } 665088"];
7797 [label="if (this.SpecialType == SpecialType.System_Object)\n            {\n                return (int)SpecialType.System_Object;\n            } 665089"];
7798 [label="OriginalDefinition 665090"];
7799 [label="get\n            {\n                return this;\n            } 665091"];
7800 [label="return RuntimeHelpers.GetHashCode(OriginalDefinition); 665092"];
7801 [label="type.IsInterface 665093"];
7802 [label="get\n            {\n                return _flags.IsInterface();\n            } 665094"];
7803 [label="return _flags.IsInterface(); 665095"];
7804 [label="if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                } 665096"];
7805 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 665097"];
7806 [label="type.GetDeclaredBaseType(null) 665098"];
7807 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 665099"];
7808 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 665100"];
7809 [label="s.Kind 665101"];
7810 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 665102"];
7811 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 665103"];
7812 [label="Debug.Assert((object)moduleSymbol != null); 665104"];
7813 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 665105"];
7814 [label="param TransformType(int targetSymbolCustomModifierCount) 665106"];
7815 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 665107"];
7816 [label="Debug.Assert((object)metadataType != null); 665108"];
7817 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 665109"];
7818 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 665110"];
7819 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 665111"];
7820 [label="_elementNames 665112"];
7821 [label="elementNames.IsDefault 665113"];
7822 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 665114"];
7823 [label="_namesIndex 665115"];
7824 [label="_foundUsableErrorType = false; 665116"];
7825 [label="_foundUsableErrorType 665117"];
7826 [label="param DecodeType(this) 665118"];
7827 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 665119"];
7828 [label="param DecodeNamedType(this) 665120"];
7829 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 665121"];
7830 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 665122"];
7831 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 665123"];
7832 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 665124"];
7833 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 665125"];
7834 [label="DecodeTypeArguments(typeArgs) 665126"];
7835 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 665127"];
7836 [label="param DecodeTypeArguments(this) 665128"];
7837 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 665129"];
7838 [label="return typeArgs; 665130"];
7839 [label="type.ContainingType 665131"];
7840 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 665132"];
7841 [label="return _container as NamedTypeSymbol; 665133"];
7842 [label="NamedTypeSymbol containingType = type.ContainingType; 665134"];
7843 [label="NamedTypeSymbol? decodedContainingType; 665135"];
7844 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 665136"];
7845 [label="decodedContainingType = containingType; 665137"];
7846 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 665138"];
7847 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 665139"];
7848 [label="var typeArgsChanged = typeArgs != decodedArgs; 665140"];
7849 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 665141"];
7850 [label="decodedType.IsTupleType 665142"];
7851 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 665143"];
7852 [label="_ 665144"];
7853 [label="tupleCardinality: out _ 665145"];
7854 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 665146"];
7855 [label="param IsTupleTypeOfCardinality(this) 665147"];
7856 [label="IsUnboundGenericType 665148"];
7857 [label="get\n            {\n                return false;\n            } 665149"];
7858 [label="return false; 665150"];
7859 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 665151"];
7860 [label="ContainingSymbol 665152"];
7861 [label="get\n            {\n                return _container;\n            } 665153"];
7862 [label="return _container; 665154"];
7863 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 665155"];
7864 [label=".Kind 665156"];
7865 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 665157"];
7866 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 665158"];
7867 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 665159"];
7868 [label="ContainingNamespace 665160"];
7869 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 665161"];
7870 [label="get\n            {\n                return _container;\n            } 665162"];
7871 [label="return _container; 665163"];
7872 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 665164"];
7873 [label="ContainingNamespace.ContainingNamespace 665165"];
7874 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 665166"];
7875 [label=".IsGlobalNamespace 665167"];
7876 [label="get\n            {\n                return true;\n            } 665168"];
7877 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 665169"];
7878 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 665170"];
7879 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 665171"];
7880 [label="Name 665172"];
7881 [label="get\n            {\n                return _name;\n            } 665173"];
7882 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 665174"];
7883 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 665175"];
7884 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 665176"];
7885 [label="tupleCardinality = 0; 665177"];
7886 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 665178"];
7887 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 665179"];
7888 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 665180"];
7889 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 665181"];
7890 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 665182"];
7891 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 665183"];
7892 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 665184"];
7893 [label="typeSymbol.IsNullableType() 665185"];
7894 [label="param IsNullableType(this TypeSymbol type) 665186"];
7895 [label="type.OriginalDefinition 665187"];
7896 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 665188"];
7897 [label="OriginalTypeSymbolDefinition 665189"];
7898 [label="get\n            {\n                return this.OriginalDefinition;\n            } 665190"];
7899 [label="this.OriginalDefinition 665191"];
7900 [label="get\n            {\n                return this;\n            } 665192"];
7901 [label="return this.OriginalDefinition; 665193"];
7902 [label="return OriginalTypeSymbolDefinition; 665194"];
7903 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 665195"];
7904 [label="type.OriginalDefinition.SpecialType 665196"];
7905 [label="get\n            {\n                return _corTypeId;\n            } 665197"];
7906 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 665198"];
7907 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 665199"];
7908 [label="Extensions.Create(customModifiers) 665200"];
7909 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 665201"];
7910 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 665202"];
7911 [label="return Default; 665203"];
7912 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 665204"];
7913 [label="param TypeWithAnnotations(Extensions extensions) 665205"];
7914 [label="var a1 = defaultType is null; 665206"];
7915 [label="!a1 665207"];
7916 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 665208"];
7917 [label="defaultType.IsNullableType() 665209"];
7918 [label="param IsNullableType(this TypeSymbol type) 665210"];
7919 [label="type.OriginalDefinition 665211"];
7920 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 665212"];
7921 [label="OriginalTypeSymbolDefinition 665213"];
7922 [label="get\n            {\n                return this.OriginalDefinition;\n            } 665214"];
7923 [label="this.OriginalDefinition 665215"];
7924 [label="get\n            {\n                return this;\n            } 665216"];
7925 [label="return this.OriginalDefinition; 665217"];
7926 [label="return OriginalTypeSymbolDefinition; 665218"];
7927 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 665219"];
7928 [label="type.OriginalDefinition.SpecialType 665220"];
7929 [label="get\n            {\n                return _corTypeId;\n            } 665221"];
7930 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 665222"];
7931 [label="Debug.Assert(a1 || a2 != true || a3); 665223"];
7932 [label="Debug.Assert(a1 || a2 != true || a3); 665224"];
7933 [label="Debug.Assert(extensions != null); 665225"];
7934 [label="Debug.Assert(extensions != null); 665226"];
7935 [label="NullableAnnotation 665227"];
7936 [label="_extensions 665228"];
7937 [label="param TransformType(Symbol accessSymbol) 665229"];
7938 [label="metadataType.HasType 665230"];
7939 [label="=> !(DefaultType is null) 665231"];
7940 [label="DefaultType is null 665232"];
7941 [label="!(DefaultType is null) 665233"];
7942 [label="Debug.Assert(metadataType.HasType); 665234"];
7943 [label="accessSymbol.IsDefinition 665235"];
7944 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 665236"];
7945 [label="OriginalDefinition 665237"];
7946 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 665238"];
7947 [label="OriginalSymbolDefinition 665239"];
7948 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 665240"];
7949 [label="this.OriginalTypeSymbolDefinition 665241"];
7950 [label="get\n            {\n                return this.OriginalDefinition;\n            } 665242"];
7951 [label="this.OriginalDefinition 665243"];
7952 [label="get\n            {\n                return this;\n            } 665244"];
7953 [label="return this.OriginalDefinition; 665245"];
7954 [label="return this.OriginalTypeSymbolDefinition; 665246"];
7955 [label="return OriginalSymbolDefinition; 665247"];
7956 [label="return (object)this == (object)OriginalDefinition; 665248"];
7957 [label="Debug.Assert(accessSymbol.IsDefinition); 665249"];
7958 [label="accessSymbol.ContainingModule 665250"];
7959 [label="get\n            {\n                return ContainingPEModule;\n            } 665251"];
7960 [label="ContainingPEModule 665252"];
7961 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 665253"];
7962 [label="s.Kind 665254"];
7963 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 665255"];
7964 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 665256"];
7965 [label="return ContainingPEModule; 665257"];
7966 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 665258"];
7967 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 665259"];
7968 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 665260"];
7969 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 665261"];
7970 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 665262"];
7971 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 665263"];
7972 [label="Debug.Assert(symbol is object); 665264"];
7973 [label="symbol.Kind 665265"];
7974 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 665266"];
7975 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 665267"];
7976 [label="isInternal = false; 665268"];
7977 [label="symbol.DeclaredAccessibility 665269"];
7978 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 665270"];
7979 [label="Accessibility access = Accessibility.Private; 665271"];
7980 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 665272"];
7981 [label="symbol.ContainingType 665273"];
7982 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 665274"];
7983 [label="return _container as NamedTypeSymbol; 665275"];
7984 [label="symbol = symbol.ContainingType; 665276"];
7985 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 665277"];
7986 [label="return true; 665278"];
7987 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 665279"];
7988 [label="byte? value; 665280"];
7989 [label="param TryGetByte(out byte? value) 665281"];
7990 [label="value = null; 665282"];
7991 [label="s.Kind 665283"];
7992 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 665284"];
7993 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 665285"];
7994 [label="param GetNullableContextValue(this) 665286"];
7995 [label="param GetLocalNullableContextValue(this) 665287"];
7996 [label="get\n            {\n                return _moduleSymbol;\n            } 665288"];
7997 [label="return _moduleSymbol; 665289"];
7998 [label="param GetLocalNullableContextValue(this) 665290"];
7999 [label="get\n            {\n                return _assemblySymbol;\n            } 665291"];
8000 [label="return _assemblySymbol; 665292"];
8001 [label="param GetLocalNullableContextValue(this) 665293"];
8002 [label="get\n            {\n                return null;\n            } 665294"];
8003 [label="=> defaultType 665295"];
8004 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 665296"];
8005 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 665297"];
8006 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 665298"];
8007 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure) 665299"];
8008 [label="param TypeDependsClosure(NamedTypeSymbol type) 665300"];
8009 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 665301"];
8010 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 665302"];
8011 [label="if ((object)type == null)\n            {\n                return;\n            } 665303"];
8012 [label="if ((object)type == null)\n            {\n                return;\n            } 665304"];
8013 [label="this.SpecialType 665305"];
8014 [label="get\n            {\n                return _corTypeId;\n            } 665306"];
8015 [label="if (this.SpecialType == SpecialType.System_Object)\n            {\n                return (int)SpecialType.System_Object;\n            } 665307"];
8016 [label="return (int)SpecialType.System_Object; 665308"];
8017 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 665309"];
8018 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 665310"];
8019 [label="s.Kind 665311"];
8020 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 665312"];
8021 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 665313"];
8022 [label="return null; 665314"];
8023 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 665315"];
8024 [label="if ((object)type == null)\n            {\n                return;\n            } 665316"];
8025 [label="if ((object)type == null)\n            {\n                return;\n            } 665317"];
8026 [label="return; 665318"];
8027 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 665319"];
8028 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 665320"];
8029 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 665321"];
8030 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 665322"];
8031 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 665323"];
8032 [label="var result = hs.Contains(on); 665324"];
8033 [label="var result = hs.Contains(on); 665325"];
8034 [label="var result = hs.Contains(on); 665326"];
8035 [label="this.SpecialType 665327"];
8036 [label="OriginalDefinition 665328"];
8037 [label="hs.Free(); 665329"];
8038 [label="return result; 665330"];
8039 [label="this.SetKnownToHaveNoDeclaredBaseCycles() 665331"];
8040 [label="param SetKnownToHaveNoDeclaredBaseCycles(this) 665332"];
8041 [label="_hasNoBaseCycles = true; 665333"];
8042 [label="_hasNoBaseCycles 665334"];
8043 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 665335"];
8044 [label="return declaredBase; 665336"];
8045 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 665337"];
8046 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 665338"];
8047 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 665339"];
8048 [label="return _lazyBaseType; 665340"];
8049 [label="NamedTypeSymbol @base = this.BaseTypeNoUseSiteDiagnostics; 665341"];
8050 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 665342"];
8051 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 665343"];
8052 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 665344"];
8053 [label="@base.IsErrorType() 665345"];
8054 [label="param IsErrorType(this TypeSymbol type) 665346"];
8055 [label="RoslynDebug.Assert((object)type != null); 665347"];
8056 [label="RoslynDebug.Assert((object)type != null); 665348"];
8057 [label="type.Kind 665349"];
8058 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 665350"];
8059 [label="return type.Kind == SymbolKind.ErrorType; 665351"];
8060 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 665352"];
8061 [label="@base.BaseTypeNoUseSiteDiagnostics 665353"];
8062 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 665354"];
8063 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 665355"];
8064 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 665356"];
8065 [label="Debug.Assert((object)depends != null); 665357"];
8066 [label="Debug.Assert((object)on != null); 665358"];
8067 [label="on.IsDefinition 665359"];
8068 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 665360"];
8069 [label="OriginalDefinition 665361"];
8070 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 665362"];
8071 [label="OriginalSymbolDefinition 665363"];
8072 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 665364"];
8073 [label="this.OriginalTypeSymbolDefinition 665365"];
8074 [label="get\n            {\n                return this.OriginalDefinition;\n            } 665366"];
8075 [label="this.OriginalDefinition 665367"];
8076 [label="get\n            {\n                return this;\n            } 665368"];
8077 [label="return this.OriginalDefinition; 665369"];
8078 [label="return this.OriginalTypeSymbolDefinition; 665370"];
8079 [label="return OriginalSymbolDefinition; 665371"];
8080 [label="return (object)this == (object)OriginalDefinition; 665372"];
8081 [label="Debug.Assert(on.IsDefinition); 665373"];
8082 [label="depends.DeclaringCompilation 665374"];
8083 [label="get { return null; } 665375"];
8084 [label="return null; 665376"];
8085 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 665377"];
8086 [label="if ((object)type == null)\n            {\n                return;\n            } 665378"];
8087 [label="return; 665379"];
8088 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 665380"];
8089 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 665381"];
8090 [label="return result; 665382"];
8091 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 665383"];
8092 [label="@base = @base.BaseTypeNoUseSiteDiagnostics; 665384"];
8093 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 665385"];
8094 [label="@base.IsErrorType() 665386"];
8095 [label="param IsErrorType(this TypeSymbol type) 665387"];
8096 [label="RoslynDebug.Assert((object)type != null); 665388"];
8097 [label="RoslynDebug.Assert((object)type != null); 665389"];
8098 [label="type.Kind 665390"];
8099 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 665391"];
8100 [label="return type.Kind == SymbolKind.ErrorType; 665392"];
8101 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 665393"];
8102 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 665394"];
8103 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 665395"];
8104 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 665396"];
8105 [label="return null; 665397"];
8106 [label="return null; 665398"];
8107 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 665399"];
8108 [label="MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()) 665400"];
8109 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 665401"];
8110 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 665402"];
8111 [label="param MergeUseSiteDiagnostics(this) 665403"];
8112 [label="if (info == null)\n            {\n                return false;\n            } 665404"];
8113 [label="if (info == null)\n            {\n                return false;\n            } 665405"];
8114 [label="return false; 665406"];
8115 [label="this.ContainingModule 665407"];
8116 [label="get\n            {\n                return ContainingPEModule;\n            } 665408"];
8117 [label="ContainingPEModule 665409"];
8118 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 665410"];
8119 [label="Symbol s = _container; 665411"];
8120 [label="s.Kind 665412"];
8121 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 665413"];
8122 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 665414"];
8123 [label="((PENamespaceSymbol)s).ContainingPEModule 665415"];
8124 [label="return ContainingPEModule; 665416"];
8125 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 665417"];
8126 [label="this.ContainingModule.HasUnifiedReferences 665418"];
8127 [label="get { return GetUnifiedAssemblies().Length > 0; } 665419"];
8128 [label="GetUnifiedAssemblies() 665420"];
8129 [label="param GetUnifiedAssemblies(this) 665421"];
8130 [label="AssertReferencesInitialized() 665422"];
8131 [label="param AssertReferencesInitialized(this) 665423"];
8132 [label="Debug.Assert(_moduleReferences != null); 665424"];
8133 [label="Debug.Assert(_moduleReferences != null); 665425"];
8134 [label="AssertReferencesInitialized(); 665426"];
8135 [label="return GetUnifiedAssemblies().Length > 0; 665427"];
8136 [label="return GetUnifiedAssemblies().Length > 0; 665428"];
8137 [label="return result; 665429"];
8138 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 665430"];
8139 [label="MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()) 665431"];
8140 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 665432"];
8141 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 665433"];
8142 [label="param MergeUseSiteDiagnostics(this) 665434"];
8143 [label="if (info == null)\n            {\n                return false;\n            } 665435"];
8144 [label="if (info == null)\n            {\n                return false;\n            } 665436"];
8145 [label="return false; 665437"];
8146 [label="this.ContainingPEModule 665438"];
8147 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 665439"];
8148 [label="Symbol s = _container; 665440"];
8149 [label="s.Kind 665441"];
8150 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 665442"];
8151 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 665443"];
8152 [label="((PENamespaceSymbol)s).ContainingPEModule 665444"];
8153 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 665445"];
8154 [label="this.ContainingPEModule.Module 665446"];
8155 [label="get\n            {\n                return _module;\n            } 665447"];
8156 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 665448"];
8157 [label="TypeKind 665449"];
8158 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 665450"];
8159 [label="TypeKind result = _lazyKind; 665451"];
8160 [label="if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                } 665452"];
8161 [label="if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    } 665453"];
8162 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 665454"];
8163 [label="GetDeclaredBaseType(skipTransformsIfNecessary: true) 665455"];
8164 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 665456"];
8165 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 665457"];
8166 [label="result = TypeKind.Class; 665458"];
8167 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 665459"];
8168 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 665460"];
8169 [label="@base.SpecialType 665461"];
8170 [label="SpecialType baseCorTypeId = @base.SpecialType; 665462"];
8171 [label="switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            } 665463"];
8172 [label="this.SpecialType 665464"];
8173 [label="if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    } 665465"];
8174 [label="result = TypeKind.Struct; 665466"];
8175 [label="_lazyKind 665467"];
8176 [label="return result; 665468"];
8177 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 665469"];
8178 [label="return diagnostic; 665470"];
8179 [label="_lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl(); 665471"];
8180 [label="_lazyUseSiteDiagnostic 665472"];
8181 [label="return _lazyUseSiteDiagnostic; 665473"];
8182 [label="DiagnosticInfo info = symbol.GetUseSiteDiagnostic(); 665474"];
8183 [label="return info != null && Symbol.ReportUseSiteDiagnostic(info, diagnostics, node.Location); 665475"];
8184 [label="return info != null && Symbol.ReportUseSiteDiagnostic(info, diagnostics, node.Location); 665476"];
8185 [label="return typeSymbol; 665477"];
8186 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 665478"];
8187 [label="AreNullableAnnotationsEnabled(predefinedType.Keyword) 665479"];
8188 [label="param AreNullableAnnotationsEnabled(SyntaxToken token) 665480"];
8189 [label="param AreNullableAnnotationsEnabled(this) 665481"];
8190 [label="RoslynDebug.Assert(token.SyntaxTree is object); 665482"];
8191 [label="RoslynDebug.Assert(token.SyntaxTree is object); 665483"];
8192 [label="return AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart); 665484"];
8193 [label="AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart) 665485"];
8194 [label="param AreNullableAnnotationsEnabled(SyntaxTree syntaxTree) 665486"];
8195 [label="param AreNullableAnnotationsEnabled(int position) 665487"];
8196 [label="param AreNullableAnnotationsEnabled(this) 665488"];
8197 [label="CSharpSyntaxTree csTree = (CSharpSyntaxTree)syntaxTree; 665489"];
8198 [label="Syntax.NullableContextState context = csTree.GetNullableContextState(position); 665490"];
8199 [label="Syntax.NullableContextState context = csTree.GetNullableContextState(position); 665491"];
8200 [label="context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            } 665492"];
8201 [label="this.Compilation.Options 665493"];
8202 [label="get\n            {\n                return _options;\n            } 665494"];
8203 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 665495"];
8204 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 665496"];
8205 [label="AreNullableAnnotationsGloballyEnabled() 665497"];
8206 [label="param AreNullableAnnotationsGloballyEnabled(this) 665498"];
8207 [label="RoslynDebug.Assert(Next is object); 665499"];
8208 [label="RoslynDebug.Assert(Next is object); 665500"];
8209 [label="Next.AreNullableAnnotationsGloballyEnabled() 665501"];
8210 [label="param AreNullableAnnotationsGloballyEnabled(this) 665502"];
8211 [label="RoslynDebug.Assert(Next is object); 665503"];
8212 [label="param AreNullableAnnotationsGloballyEnabled(this) 665504"];
8213 [label="GetGlobalAnnotationState() 665505"];
8214 [label="param GetGlobalAnnotationState(this) 665506"];
8215 [label="Compilation.Options 665507"];
8216 [label="get\n            {\n                return _options;\n            } 665508"];
8217 [label="switch (Compilation.Options.NullableContextOptions)\n            {\n                case NullableContextOptions.Enable:\n                case NullableContextOptions.Annotations:\n                    return true;\n\n                case NullableContextOptions.Disable:\n                case NullableContextOptions.Warnings:\n                    return false;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(Compilation.Options.NullableContextOptions);\n            } 665509"];
8218 [label="return false; 665510"];
8219 [label="return GetGlobalAnnotationState(); 665511"];
8220 [label="return Next.AreNullableAnnotationsGloballyEnabled(); 665512"];
8221 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 665513"];
8222 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 665514"];
8223 [label="TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type) 665515"];
8224 [label="param Create(bool isNullableEnabled) 665516"];
8225 [label="param Create(TypeSymbol typeSymbol) 665517"];
8226 [label="param Create(bool isAnnotated = false) 665518"];
8227 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 665519"];
8228 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 665520"];
8229 [label="isAnnotated 665521"];
8230 [label="isNullableEnabled 665522"];
8231 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 665523"];
8232 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 665524"];
8233 [label="Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious) 665525"];
8234 [label="param Create(TypeSymbol typeSymbol) 665526"];
8235 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 665527"];
8236 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 665528"];
8237 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 665529"];
8238 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 665530"];
8239 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 665531"];
8240 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 665532"];
8241 [label="typeSymbol.IsNullableType() 665533"];
8242 [label="param IsNullableType(this TypeSymbol type) 665534"];
8243 [label="type.OriginalDefinition 665535"];
8244 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 665536"];
8245 [label="OriginalTypeSymbolDefinition 665537"];
8246 [label="get\n            {\n                return this.OriginalDefinition;\n            } 665538"];
8247 [label="this.OriginalDefinition 665539"];
8248 [label="get\n            {\n                return this;\n            } 665540"];
8249 [label="return this.OriginalDefinition; 665541"];
8250 [label="return OriginalTypeSymbolDefinition; 665542"];
8251 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 665543"];
8252 [label="type.OriginalDefinition.SpecialType 665544"];
8253 [label="get\n            {\n                return _corTypeId;\n            } 665545"];
8254 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 665546"];
8255 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 665547"];
8256 [label="CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()) 665548"];
8257 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 665549"];
8258 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 665550"];
8259 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 665551"];
8260 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 665552"];
8261 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 665553"];
8262 [label="Extensions.Create(customModifiers) 665554"];
8263 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 665555"];
8264 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 665556"];
8265 [label="return Default; 665557"];
8266 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 665558"];
8267 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 665559"];
8268 [label="param TypeWithAnnotations(TypeSymbol defaultType) 665560"];
8269 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 665561"];
8270 [label="param TypeWithAnnotations(Extensions extensions) 665562"];
8271 [label="param TypeWithAnnotations(this) 665563"];
8272 [label="var a1 = defaultType is null; 665564"];
8273 [label="!a1 665565"];
8274 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 665566"];
8275 [label="defaultType.IsNullableType() 665567"];
8276 [label="param IsNullableType(this TypeSymbol type) 665568"];
8277 [label="type.OriginalDefinition 665569"];
8278 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 665570"];
8279 [label="OriginalTypeSymbolDefinition 665571"];
8280 [label="get\n            {\n                return this.OriginalDefinition;\n            } 665572"];
8281 [label="this.OriginalDefinition 665573"];
8282 [label="get\n            {\n                return this;\n            } 665574"];
8283 [label="return this; 665575"];
8284 [label="return this.OriginalDefinition; 665576"];
8285 [label="return OriginalTypeSymbolDefinition; 665577"];
8286 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 665578"];
8287 [label="type.OriginalDefinition.SpecialType 665579"];
8288 [label="get\n            {\n                return _corTypeId;\n            } 665580"];
8289 [label="return _corTypeId; 665581"];
8290 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 665582"];
8291 [label="Debug.Assert(a1 || a2 != true || a3); 665583"];
8292 [label="Debug.Assert(a1 || a2 != true || a3); 665584"];
8293 [label="Debug.Assert(extensions != null); 665585"];
8294 [label="Debug.Assert(extensions != null); 665586"];
8295 [label="DefaultType 665587"];
8296 [label="NullableAnnotation 665588"];
8297 [label="_extensions 665589"];
8298 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 665590"];
8299 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 665591"];
8300 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 665592"];
8301 [label="param operator(TypeWithAnnotations typeWithAnnotations) 665593"];
8302 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 665594"];
8303 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 665595"];
8304 [label="new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations) 665596"];
8305 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations typeWithAnnotations) 665597"];
8306 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(this) 665598"];
8307 [label="typeWithAnnotations.HasType 665599"];
8308 [label="=> !(DefaultType is null) 665600"];
8309 [label="DefaultType is null 665601"];
8310 [label="!(DefaultType is null) 665602"];
8311 [label="Debug.Assert(typeWithAnnotations.HasType); 665603"];
8312 [label="_typeWithAnnotations 665604"];
8313 [label="_symbol = null; 665605"];
8314 [label="_symbol 665606"];
8315 [label="_isNullableEnabled = false; 665607"];
8316 [label="_isNullableEnabled 665608"];
8317 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 665609"];
8318 [label="return bindPredefined(syntax, diagnostics); 665610"];
8319 [label="symbol.IsType 665611"];
8320 [label="=> !_typeWithAnnotations.IsDefault 665612"];
8321 [label="_typeWithAnnotations.IsDefault 665613"];
8322 [label="=> DefaultType is null && this.NullableAnnotation == 0 && (_extensions == null || _extensions == Extensions.Default) 665614"];
8323 [label="DefaultType is null 665615"];
8324 [label="DefaultType is null && this.NullableAnnotation == 0 665616"];
8325 [label="DefaultType is null && this.NullableAnnotation == 0 && (_extensions == null || _extensions == Extensions.Default) 665617"];
8326 [label="!_typeWithAnnotations.IsDefault 665618"];
8327 [label="if (symbol.IsType ||\n                (symbol.IsAlias && UnwrapAliasNoDiagnostics(symbol.Symbol, basesBeingResolved) is TypeSymbol))\n            {\n                if (symbol.IsType)\n                {\n                    // Obsolete alias targets are reported in UnwrapAlias, but if it was a type (not an\n                    // alias to a type) we report the obsolete type here.\n                    symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics);\n                }\n\n                return symbol;\n            } 665619"];
8328 [label="symbol.IsType 665620"];
8329 [label="if (symbol.IsType)\n                {\n                    // Obsolete alias targets are reported in UnwrapAlias, but if it was a type (not an\n                    // alias to a type) we report the obsolete type here.\n                    symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics);\n                } 665621"];
8330 [label="symbol.TypeWithAnnotations 665622"];
8331 [label="=> _typeWithAnnotations 665623"];
8332 [label="_typeWithAnnotations 665624"];
8333 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 665625"];
8334 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 665626"];
8335 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 665627"];
8336 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 665628"];
8337 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics) 665629"];
8338 [label="param ReportDiagnosticsIfObsolete(Binder binder) 665630"];
8339 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 665631"];
8340 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 665632"];
8341 [label="=>\n            _extensions.ReportDiagnosticsIfObsolete(this, binder, syntax, diagnostics) 665633"];
8342 [label="this 665634"];
8343 [label="binder 665635"];
8344 [label="syntax 665636"];
8345 [label="diagnostics 665637"];
8346 [label="_extensions.ReportDiagnosticsIfObsolete(this, binder, syntax, diagnostics) 665638"];
8347 [label="param ReportDiagnosticsIfObsolete(TypeWithAnnotations type) 665639"];
8348 [label="param ReportDiagnosticsIfObsolete(Binder binder) 665640"];
8349 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 665641"];
8350 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 665642"];
8351 [label="param ReportDiagnosticsIfObsolete(this) 665643"];
8352 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 665644"];
8353 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 665645"];
8354 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 665646"];
8355 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics) 665647"];
8356 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 665648"];
8357 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 665649"];
8358 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 665650"];
8359 [label="param ReportDiagnosticsIfObsoleteCore(this) 665651"];
8360 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 665652"];
8361 [label="Type 665653"];
8362 [label="=> _extensions?.GetResolvedType(DefaultType) 665654"];
8363 [label="DefaultType 665655"];
8364 [label=".GetResolvedType(DefaultType) 665656"];
8365 [label="param GetResolvedType(TypeSymbol defaultType) 665657"];
8366 [label="=> defaultType 665658"];
8367 [label="defaultType 665659"];
8368 [label="_extensions?.GetResolvedType(DefaultType) 665660"];
8369 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 665661"];
8370 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 665662"];
8371 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 665663"];
8372 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false) 665664"];
8373 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 665665"];
8374 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 665666"];
8375 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 665667"];
8376 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 665668"];
8377 [label="param ReportDiagnosticsIfObsolete(this) 665669"];
8378 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 665670"];
8379 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 665671"];
8380 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 665672"];
8381 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 665673"];
8382 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver) 665674"];
8383 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 665675"];
8384 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 665676"];
8385 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 665677"];
8386 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 665678"];
8387 [label="param ReportDiagnosticsIfObsolete(this) 665679"];
8388 [label="symbol.Kind 665680"];
8389 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 665681"];
8390 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Event:\n                case SymbolKind.Property:\n                    ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags);\n                    break;\n            } 665682"];
8391 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 665683"];
8392 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 665684"];
8393 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 665685"];
8394 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 665686"];
8395 [label="this.ContainingMemberOrLambda 665687"];
8396 [label="get { return _containingMemberOrLambda; } 665688"];
8397 [label="return _containingMemberOrLambda; 665689"];
8398 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 665690"];
8399 [label="this.ContainingType 665691"];
8400 [label="get\n            {\n                var member = this.ContainingMemberOrLambda;\n                RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType);\n                return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                };\n            } 665692"];
8401 [label="this.ContainingMemberOrLambda 665693"];
8402 [label="get { return _containingMemberOrLambda; } 665694"];
8403 [label="return _containingMemberOrLambda; 665695"];
8404 [label="var member = this.ContainingMemberOrLambda; 665696"];
8405 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 665697"];
8406 [label="member.Kind 665698"];
8407 [label="get\n            {\n                return SymbolKind.Field;\n            } 665699"];
8408 [label="return SymbolKind.Field; 665700"];
8409 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 665701"];
8410 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 665702"];
8411 [label="member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                } 665703"];
8412 [label="member.ContainingType 665704"];
8413 [label="return this.containingType; 665705"];
8414 [label="return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                }; 665706"];
8415 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 665707"];
8416 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 665708"];
8417 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags) 665709"];
8418 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 665710"];
8419 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 665711"];
8420 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 665712"];
8421 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 665713"];
8422 [label="param ReportDiagnosticsIfObsolete(Symbol? containingMember) 665714"];
8423 [label="param ReportDiagnosticsIfObsolete(NamedTypeSymbol? containingType) 665715"];
8424 [label="param ReportDiagnosticsIfObsolete(BinderFlags location) 665716"];
8425 [label="RoslynDebug.Assert(symbol is object); 665717"];
8426 [label="RoslynDebug.Assert(symbol is object); 665718"];
8427 [label="symbol.Kind 665719"];
8428 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 665720"];
8429 [label="RoslynDebug.Assert(symbol.Kind == SymbolKind.NamedType ||\n                         symbol.Kind == SymbolKind.Field ||\n                         symbol.Kind == SymbolKind.Method ||\n                         symbol.Kind == SymbolKind.Event ||\n                         symbol.Kind == SymbolKind.Property); 665721"];
8430 [label="symbol.Kind 665722"];
8431 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 665723"];
8432 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                symbol = ((MethodSymbol)symbol).ConstructedFrom;\n            } 665724"];
8433 [label="Symbol leastOverriddenSymbol = symbol.GetLeastOverriddenMember(containingType); 665725"];
8434 [label="Symbol leastOverriddenSymbol = symbol.GetLeastOverriddenMember(containingType); 665726"];
8435 [label="symbol.GetLeastOverriddenMember(containingType) 665727"];
8436 [label="param GetLeastOverriddenMember(this Symbol member) 665728"];
8437 [label="param GetLeastOverriddenMember(NamedTypeSymbol accessingTypeOpt) 665729"];
8438 [label="member.Kind 665730"];
8439 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 665731"];
8440 [label="switch (member.Kind)\n            {\n                case SymbolKind.Method:\n                    var method = (MethodSymbol)member;\n                    return method.GetConstructedLeastOverriddenMethod(accessingTypeOpt, requireSameReturnType: false);\n\n                case SymbolKind.Property:\n                    var property = (PropertySymbol)member;\n                    return property.GetLeastOverriddenProperty(accessingTypeOpt);\n\n                case SymbolKind.Event:\n                    var evnt = (EventSymbol)member;\n                    return evnt.GetLeastOverriddenEvent(accessingTypeOpt);\n\n                default:\n                    return member;\n            } 665732"];
8441 [label="return member; 665733"];
8442 [label="bool checkOverridingSymbol = hasBaseReceiver && !ReferenceEquals(symbol, leastOverriddenSymbol); 665734"];
8443 [label="if (checkOverridingSymbol)\n            {\n                // If we have a base receiver, we must be done with declaration binding, so it should\n                // be safe to decode diagnostics.  We want to do this since reporting for the overriding\n                // member is conditional on reporting for the overridden member (i.e. we need a definite\n                // answer so we don't double-report).  You might think that double reporting just results\n                // in cascading diagnostics, but it's possible that the second diagnostic is an error\n                // while the first is merely a warning.\n                leastOverriddenSymbol.GetAttributes();\n            } 665735"];
8444 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 665736"];
8445 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 665737"];
8446 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 665738"];
8447 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 665739"];
8448 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 665740"];
8449 [label="ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location) 665741"];
8450 [label="param ReportDiagnosticsIfObsoleteInternal(DiagnosticBag diagnostics) 665742"];
8451 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol symbol) 665743"];
8452 [label="param ReportDiagnosticsIfObsoleteInternal(SyntaxNodeOrToken node) 665744"];
8453 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol? containingMember) 665745"];
8454 [label="param ReportDiagnosticsIfObsoleteInternal(BinderFlags location) 665746"];
8455 [label="RoslynDebug.Assert(diagnostics != null); 665747"];
8456 [label="RoslynDebug.Assert(diagnostics != null); 665748"];
8457 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 665749"];
8458 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 665750"];
8459 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 665751"];
8460 [label="ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember) 665752"];
8461 [label="param GetObsoleteDiagnosticKind(Symbol symbol) 665753"];
8462 [label="param GetObsoleteDiagnosticKind(Symbol containingMember) 665754"];
8463 [label="param GetObsoleteDiagnosticKind(bool forceComplete = false) 665755"];
8464 [label="symbol.ObsoleteKind 665756"];
8465 [label="get\n            {\n                var data = this.ObsoleteAttributeData;\n                return (data == null) ? ObsoleteAttributeKind.None : data.Kind;\n            } 665757"];
8466 [label="this.ObsoleteAttributeData 665758"];
8467 [label="get\n            {\n                var uncommon = GetUncommonProperties();\n                if (uncommon == s_noUncommonProperties)\n                {\n                    return null;\n                }\n\n                bool ignoreByRefLikeMarker = this.IsRefLikeType;\n                ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker);\n                return uncommon.lazyObsoleteAttributeData;\n            } 665759"];
8468 [label="GetUncommonProperties() 665760"];
8469 [label="param GetUncommonProperties(this) 665761"];
8470 [label="var result = _lazyUncommonProperties; 665762"];
8471 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 665763"];
8472 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 665764"];
8473 [label="this.IsUncommon() 665765"];
8474 [label="param IsUncommon(this) 665766"];
8475 [label="this.ContainingPEModule 665767"];
8476 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 665768"];
8477 [label="Symbol s = _container; 665769"];
8478 [label="s.Kind 665770"];
8479 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 665771"];
8480 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 665772"];
8481 [label="((PENamespaceSymbol)s).ContainingPEModule 665773"];
8482 [label="if (this.ContainingPEModule.HasAnyCustomAttributes(_handle))\n            {\n                return true;\n            } 665774"];
8483 [label="if (this.ContainingPEModule.HasAnyCustomAttributes(_handle))\n            {\n                return true;\n            } 665775"];
8484 [label="this.ContainingPEModule.HasAnyCustomAttributes(_handle) 665776"];
8485 [label="param HasAnyCustomAttributes(EntityHandle token) 665777"];
8486 [label="param HasAnyCustomAttributes(this) 665778"];
8487 [label="foreach (var attr in _module.GetCustomAttributesOrThrow(token))\n                {\n                    return true;\n                } 665779"];
8488 [label="foreach (var attr in _module.GetCustomAttributesOrThrow(token))\n                {\n                    return true;\n                } 665780"];
8489 [label="return true; 665781"];
8490 [label="return true; 665782"];
8491 [label="if (this.IsUncommon())\n            {\n                result = new UncommonProperties();\n                return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result;\n            } 665783"];
8492 [label="result = new UncommonProperties(); 665784"];
8493 [label="new UncommonProperties() 665785"];
8494 [label="param UncommonProperties(this) 665786"];
8495 [label="lazyEnumUnderlyingType 665787"];
8496 [label="lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 665788"];
8497 [label="lazyAttributeUsageInfo = AttributeUsageInfo.Null 665789"];
8498 [label="lazyContainsExtensionMethods 665790"];
8499 [label="lazyIsByRefLike 665791"];
8500 [label="lazyIsReadOnly 665792"];
8501 [label="lazyDefaultMemberName 665793"];
8502 [label="lazyComImportCoClassType = ErrorTypeSymbol.UnknownResultType 665794"];
8503 [label="lazyHasEmbeddedAttribute = ThreeState.Unknown 665795"];
8504 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 665796"];
8505 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 665797"];
8506 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 665798"];
8507 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 665799"];
8508 [label="var uncommon = GetUncommonProperties(); 665800"];
8509 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return null;\n                } 665801"];
8510 [label="this.IsRefLikeType 665802"];
8511 [label="get\n            {\n                var uncommon = GetUncommonProperties();\n                if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                }\n\n                if (!uncommon.lazyIsByRefLike.HasValue())\n                {\n                    var isByRefLike = ThreeState.False;\n\n                    if (this.TypeKind == TypeKind.Struct)\n                    {\n                        var moduleSymbol = this.ContainingPEModule;\n                        var module = moduleSymbol.Module;\n                        isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState();\n                    }\n\n                    uncommon.lazyIsByRefLike = isByRefLike;\n                }\n\n                return uncommon.lazyIsByRefLike.Value();\n            } 665803"];
8512 [label="GetUncommonProperties() 665804"];
8513 [label="param GetUncommonProperties(this) 665805"];
8514 [label="var result = _lazyUncommonProperties; 665806"];
8515 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 665807"];
8516 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 665808"];
8517 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 665809"];
8518 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 665810"];
8519 [label="return result; 665811"];
8520 [label="var uncommon = GetUncommonProperties(); 665812"];
8521 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                } 665813"];
8522 [label="if (!uncommon.lazyIsByRefLike.HasValue())\n                {\n                    var isByRefLike = ThreeState.False;\n\n                    if (this.TypeKind == TypeKind.Struct)\n                    {\n                        var moduleSymbol = this.ContainingPEModule;\n                        var module = moduleSymbol.Module;\n                        isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState();\n                    }\n\n                    uncommon.lazyIsByRefLike = isByRefLike;\n                } 665814"];
8523 [label="var isByRefLike = ThreeState.False; 665815"];
8524 [label="this.TypeKind 665816"];
8525 [label="return result; 665817"];
8526 [label="if (this.TypeKind == TypeKind.Struct)\n                    {\n                        var moduleSymbol = this.ContainingPEModule;\n                        var module = moduleSymbol.Module;\n                        isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState();\n                    } 665818"];
8527 [label="this.ContainingPEModule 665819"];
8528 [label="s.Kind 665820"];
8529 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 665821"];
8530 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 665822"];
8531 [label="var moduleSymbol = this.ContainingPEModule; 665823"];
8532 [label="moduleSymbol.Module 665824"];
8533 [label="get\n            {\n                return _module;\n            } 665825"];
8534 [label="var module = moduleSymbol.Module; 665826"];
8535 [label="isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState(); 665827"];
8536 [label="isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState(); 665828"];
8537 [label="uncommon.lazyIsByRefLike 665829"];
8538 [label="return uncommon.lazyIsByRefLike.Value(); 665830"];
8539 [label="bool ignoreByRefLikeMarker = this.IsRefLikeType; 665831"];
8540 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 665832"];
8541 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 665833"];
8542 [label="ContainingPEModule 665834"];
8543 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 665835"];
8544 [label="Symbol s = _container; 665836"];
8545 [label="s.Kind 665837"];
8546 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 665838"];
8547 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 665839"];
8548 [label="((PENamespaceSymbol)s).ContainingPEModule 665840"];
8549 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 665841"];
8550 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 665842"];
8551 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker) 665843"];
8552 [label="param InitializeObsoleteDataFromMetadata(ref ObsoleteAttributeData data) 665844"];
8553 [label="param InitializeObsoleteDataFromMetadata(EntityHandle token) 665845"];
8554 [label="param InitializeObsoleteDataFromMetadata(PEModuleSymbol containingModule) 665846"];
8555 [label="param InitializeObsoleteDataFromMetadata(bool ignoreByRefLikeMarker) 665847"];
8556 [label="if (ReferenceEquals(data, ObsoleteAttributeData.Uninitialized))\n            {\n                ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker);\n                Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized);\n            } 665848"];
8557 [label="if (ReferenceEquals(data, ObsoleteAttributeData.Uninitialized))\n            {\n                ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker);\n                Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized);\n            } 665849"];
8558 [label="ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker); 665850"];
8559 [label="ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker); 665851"];
8560 [label="ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker); 665852"];
8561 [label="GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker) 665853"];
8562 [label="param GetObsoleteDataFromMetadata(EntityHandle token) 665854"];
8563 [label="param GetObsoleteDataFromMetadata(PEModuleSymbol containingModule) 665855"];
8564 [label="param GetObsoleteDataFromMetadata(bool ignoreByRefLikeMarker) 665856"];
8565 [label="containingModule.Module 665857"];
8566 [label="get\n            {\n                return _module;\n            } 665858"];
8567 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 665859"];
8568 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 665860"];
8569 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 665861"];
8570 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 665862"];
8571 [label="new MetadataDecoder(containingModule) 665863"];
8572 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 665864"];
8573 [label="param MetadataDecoder(this) 665865"];
8574 [label="moduleSymbol 665866"];
8575 [label="null 665867"];
8576 [label="null 665868"];
8577 [label="param MetadataDecoder(this) 665869"];
8578 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 665870"];
8579 [label="param MetadataDecoder(PENamedTypeSymbol typeContextOpt) 665871"];
8580 [label="param MetadataDecoder(PEMethodSymbol methodContextOpt) 665872"];
8581 [label="return _assembly.Identity; 665873"];
8582 [label="Debug.Assert((object)moduleSymbol != null); 665874"];
8583 [label="Debug.Assert((object)moduleSymbol != null); 665875"];
8584 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 665876"];
8585 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 665877"];
8586 [label="Debug.Assert(obsoleteAttributeData == null || !obsoleteAttributeData.IsUninitialized); 665878"];
8587 [label="Debug.Assert(obsoleteAttributeData == null || !obsoleteAttributeData.IsUninitialized); 665879"];
8588 [label="return obsoleteAttributeData; 665880"];
8589 [label="Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized); 665881"];
8590 [label="Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized); 665882"];
8591 [label="Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized); 665883"];
8592 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 665884"];
8593 [label="return uncommon.lazyObsoleteAttributeData; 665885"];
8594 [label="var data = this.ObsoleteAttributeData; 665886"];
8595 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 665887"];
8596 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 665888"];
8597 [label="(data == null) 665889"];
8598 [label="switch (symbol.ObsoleteKind)\n            {\n                case ObsoleteAttributeKind.None:\n                    return ObsoleteDiagnosticKind.NotObsolete;\n                case ObsoleteAttributeKind.Experimental:\n                    return ObsoleteDiagnosticKind.Diagnostic;\n                case ObsoleteAttributeKind.Uninitialized:\n                    // If we haven't cracked attributes on the symbol at all or we haven't\n                    // cracked attribute arguments enough to be able to report diagnostics for\n                    // ObsoleteAttribute, store the symbol so that we can report diagnostics at a \n                    // later stage.\n                    return ObsoleteDiagnosticKind.Lazy;\n            } 665890"];
8599 [label="return ObsoleteDiagnosticKind.NotObsolete; 665891"];
8600 [label="DiagnosticInfo? info = null; 665892"];
8601 [label="switch (kind)\n            {\n                case ObsoleteDiagnosticKind.Diagnostic:\n                    info = ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(symbol, location);\n                    break;\n                case ObsoleteDiagnosticKind.Lazy:\n                case ObsoleteDiagnosticKind.LazyPotentiallySuppressed:\n                    info = new LazyObsoleteDiagnosticInfo(symbol, containingMember, location);\n                    break;\n            } 665893"];
8602 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 665894"];
8603 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 665895"];
8604 [label="return kind; 665896"];
8605 [label="switch (diagnosticKind)\n            {\n                case ObsoleteDiagnosticKind.NotObsolete:\n                case ObsoleteDiagnosticKind.Lazy:\n                    if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    }\n                    break;\n            } 665897"];
8606 [label="if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    } 665898"];
8607 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 665899"];
8608 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 665900"];
8609 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 665901"];
8610 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 665902"];
8611 [label="return symbol; 665903"];
8612 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 665904"];
8613 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 665905"];
8614 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 665906"];
8615 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 665907"];
8616 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved) 665908"];
8617 [label="param UnwrapAlias(in NamespaceOrTypeOrAliasSymbolWithAnnotations symbol) 665909"];
8618 [label="param UnwrapAlias(DiagnosticBag diagnostics) 665910"];
8619 [label="param UnwrapAlias(SyntaxNode syntax) 665911"];
8620 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 665912"];
8621 [label="param UnwrapAlias(this) 665913"];
8622 [label="symbol.IsAlias 665914"];
8623 [label="=> _symbol?.Kind == SymbolKind.Alias 665915"];
8624 [label="_symbol 665916"];
8625 [label="_symbol?.Kind == SymbolKind.Alias 665917"];
8626 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 665918"];
8627 [label="return symbol; 665919"];
8628 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations 665920"];
8629 [label="=> _typeWithAnnotations 665921"];
8630 [label="_typeWithAnnotations 665922"];
8631 [label="TypeWithAnnotations constructedType = typeArgument.SetIsAnnotated(Compilation); 665923"];
8632 [label="typeArgument.SetIsAnnotated(Compilation) 665924"];
8633 [label="param SetIsAnnotated(CSharpCompilation compilation) 665925"];
8634 [label="param SetIsAnnotated(this) 665926"];
8635 [label="CustomModifiers 665927"];
8636 [label="=> _extensions.CustomModifiers 665928"];
8637 [label="_extensions.CustomModifiers 665929"];
8638 [label="=> _customModifiers 665930"];
8639 [label="_customModifiers 665931"];
8640 [label="Debug.Assert(CustomModifiers.IsEmpty); 665932"];
8641 [label="this.Type 665933"];
8642 [label="=> _extensions?.GetResolvedType(DefaultType) 665934"];
8643 [label="DefaultType 665935"];
8644 [label=".GetResolvedType(DefaultType) 665936"];
8645 [label="param GetResolvedType(TypeSymbol defaultType) 665937"];
8646 [label="=> defaultType 665938"];
8647 [label="defaultType 665939"];
8648 [label="_extensions?.GetResolvedType(DefaultType) 665940"];
8649 [label="var typeSymbol = this.Type; 665941"];
8650 [label="typeSymbol.TypeKind 665942"];
8651 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 665943"];
8652 [label="TypeKind result = _lazyKind; 665944"];
8653 [label="if (typeSymbol.TypeKind != TypeKind.TypeParameter)\n            {\n                if (!typeSymbol.IsValueType && !typeSymbol.IsErrorType())\n                {\n                    return CreateNonLazyType(typeSymbol, NullableAnnotation.Annotated, this.CustomModifiers);\n                }\n                else\n                {\n                    return makeNullableT(compilation, typeSymbol);\n                }\n            } 665945"];
8654 [label="typeSymbol.IsValueType 665946"];
8655 [label="get\n            {\n                var kind = TypeKind;\n                return kind == TypeKind.Struct || kind == TypeKind.Enum;\n            } 665947"];
8656 [label="TypeKind 665948"];
8657 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 665949"];
8658 [label="var kind = TypeKind; 665950"];
8659 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 665951"];
8660 [label="if (!typeSymbol.IsValueType && !typeSymbol.IsErrorType())\n                {\n                    return CreateNonLazyType(typeSymbol, NullableAnnotation.Annotated, this.CustomModifiers);\n                }\n                else\n                {\n                    return makeNullableT(compilation, typeSymbol);\n                } 665952"];
8661 [label="return makeNullableT(compilation, typeSymbol); 665953"];
8662 [label="return makeNullableT(compilation, typeSymbol); 665954"];
8663 [label="makeNullableT(compilation, typeSymbol) 665955"];
8664 [label="TypeWithAnnotations makeNullableT(CSharpCompilation comp, TypeSymbol typeSym)\n                => Create(comp.GetSpecialType(SpecialType.System_Nullable_T).Construct(ImmutableArray.Create(typeSym))); 665956"];
8665 [label="TypeWithAnnotations makeNullableT(CSharpCompilation comp, TypeSymbol typeSym)\n                => Create(comp.GetSpecialType(SpecialType.System_Nullable_T).Construct(ImmutableArray.Create(typeSym))); 665957"];
8666 [label="TypeWithAnnotations makeNullableT(CSharpCompilation comp, TypeSymbol typeSym)\n                => Create(comp.GetSpecialType(SpecialType.System_Nullable_T).Construct(ImmutableArray.Create(typeSym))); 665958"];
8667 [label="TypeWithAnnotations makeNullableT(CSharpCompilation comp, TypeSymbol typeSym)\n                => Create(comp.GetSpecialType(SpecialType.System_Nullable_T).Construct(ImmutableArray.Create(typeSym))); 665959"];
8668 [label="comp.GetSpecialType(SpecialType.System_Nullable_T) 665960"];
8669 [label="param GetSpecialType(SpecialType specialType) 665961"];
8670 [label="param GetSpecialType(this) 665962"];
8671 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 665963"];
8672 [label="NamedTypeSymbol result; 665964"];
8673 [label="GetBoundReferenceManager(); 665965"];
8674 [label="this.Modules 665966"];
8675 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 665967"];
8676 [label="module.GetReferencedAssemblies() 665968"];
8677 [label="param GetReferencedAssemblies(this) 665969"];
8678 [label="AssertReferencesInitialized() 665970"];
8679 [label="param AssertReferencesInitialized(this) 665971"];
8680 [label="Debug.Assert(_moduleReferences != null); 665972"];
8681 [label="Debug.Assert(_moduleReferences != null); 665973"];
8682 [label="AssertReferencesInitialized(); 665974"];
8683 [label="return _moduleReferences.Identities; 665975"];
8684 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 665976"];
8685 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 665977"];
8686 [label="result.SpecialType 665978"];
8687 [label="get\n            {\n                return _corTypeId;\n            } 665979"];
8688 [label="Debug.Assert(result.SpecialType == specialType); 665980"];
8689 [label="comp.GetSpecialType(SpecialType.System_Nullable_T).Construct(ImmutableArray.Create(typeSym)) 665981"];
8690 [label="param Construct(ImmutableArray<TypeSymbol> typeArguments) 665982"];
8691 [label="param Construct(this) 665983"];
8692 [label="return ConstructWithoutModifiers(typeArguments, false); 665984"];
8693 [label="return ConstructWithoutModifiers(typeArguments, false); 665985"];
8694 [label="ConstructWithoutModifiers(typeArguments, false) 665986"];
8695 [label="param ConstructWithoutModifiers(ImmutableArray<TypeSymbol> typeArguments) 665987"];
8696 [label="param ConstructWithoutModifiers(bool unbound) 665988"];
8697 [label="param ConstructWithoutModifiers(this) 665989"];
8698 [label="ImmutableArray<TypeWithAnnotations> modifiedArguments; 665990"];
8699 [label="modifiedArguments 665991"];
8700 [label="if (typeArguments.IsDefault)\n            {\n                modifiedArguments = default(ImmutableArray<TypeWithAnnotations>);\n            }\n            else\n            {\n                modifiedArguments = typeArguments.SelectAsArray(t => TypeWithAnnotations.Create(t));\n            } 665992"];
8701 [label="modifiedArguments = typeArguments.SelectAsArray(t => TypeWithAnnotations.Create(t)); 665993"];
8702 [label="modifiedArguments = typeArguments.SelectAsArray(t => TypeWithAnnotations.Create(t)); 665994"];
8703 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 665995"];
8704 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 665996"];
8705 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 665997"];
8706 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 665998"];
8707 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 665999"];
8708 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 666000"];
8709 [label="typeSymbol.IsNullableType() 666001"];
8710 [label="param IsNullableType(this TypeSymbol type) 666002"];
8711 [label="type.OriginalDefinition 666003"];
8712 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 666004"];
8713 [label="OriginalTypeSymbolDefinition 666005"];
8714 [label="get\n            {\n                return this.OriginalDefinition;\n            } 666006"];
8715 [label="this.OriginalDefinition 666007"];
8716 [label="get\n            {\n                return this;\n            } 666008"];
8717 [label="return this.OriginalDefinition; 666009"];
8718 [label="return OriginalTypeSymbolDefinition; 666010"];
8719 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 666011"];
8720 [label="type.OriginalDefinition.SpecialType 666012"];
8721 [label="get\n            {\n                return _corTypeId;\n            } 666013"];
8722 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 666014"];
8723 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 666015"];
8724 [label="Extensions.Create(customModifiers) 666016"];
8725 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 666017"];
8726 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 666018"];
8727 [label="return Default; 666019"];
8728 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 666020"];
8729 [label="param TypeWithAnnotations(Extensions extensions) 666021"];
8730 [label="var a1 = defaultType is null; 666022"];
8731 [label="!a1 666023"];
8732 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 666024"];
8733 [label="defaultType.IsNullableType() 666025"];
8734 [label="param IsNullableType(this TypeSymbol type) 666026"];
8735 [label="type.OriginalDefinition 666027"];
8736 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 666028"];
8737 [label="OriginalTypeSymbolDefinition 666029"];
8738 [label="get\n            {\n                return this.OriginalDefinition;\n            } 666030"];
8739 [label="this.OriginalDefinition 666031"];
8740 [label="get\n            {\n                return this;\n            } 666032"];
8741 [label="return this.OriginalDefinition; 666033"];
8742 [label="return OriginalTypeSymbolDefinition; 666034"];
8743 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 666035"];
8744 [label="type.OriginalDefinition.SpecialType 666036"];
8745 [label="get\n            {\n                return _corTypeId;\n            } 666037"];
8746 [label="return _corTypeId; 666038"];
8747 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 666039"];
8748 [label="Debug.Assert(a1 || a2 != true || a3); 666040"];
8749 [label="Debug.Assert(a1 || a2 != true || a3); 666041"];
8750 [label="Debug.Assert(extensions != null); 666042"];
8751 [label="Debug.Assert(extensions != null); 666043"];
8752 [label="NullableAnnotation 666044"];
8753 [label="_extensions 666045"];
8754 [label="modifiedArguments = typeArguments.SelectAsArray(t => TypeWithAnnotations.Create(t)); 666046"];
8755 [label="return Construct(modifiedArguments, unbound); 666047"];
8756 [label="return Construct(modifiedArguments, unbound); 666048"];
8757 [label="Construct(modifiedArguments, unbound) 666049"];
8758 [label="param Construct(ImmutableArray<TypeWithAnnotations> typeArguments) 666050"];
8759 [label="param Construct(bool unbound) 666051"];
8760 [label="param Construct(this) 666052"];
8761 [label="if (!ReferenceEquals(this, ConstructedFrom))\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromConstructed);\n            } 666053"];
8762 [label="ConstructedFrom 666054"];
8763 [label="get\n            {\n                return this;\n            } 666055"];
8764 [label="return this; 666056"];
8765 [label="if (!ReferenceEquals(this, ConstructedFrom))\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromConstructed);\n            } 666057"];
8766 [label="this.Arity 666058"];
8767 [label="get\n                {\n                    return _arity;\n                } 666059"];
8768 [label="return _arity; 666060"];
8769 [label="if (this.Arity == 0)\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromNongeneric);\n            } 666061"];
8770 [label="if (this.Arity == 0)\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromNongeneric);\n            } 666062"];
8771 [label="if (typeArguments.IsDefault)\n            {\n                throw new ArgumentNullException(nameof(typeArguments));\n            } 666063"];
8772 [label="if (typeArguments.Any(TypeWithAnnotationsIsNullFunction))\n            {\n                throw new ArgumentException(CSharpResources.TypeArgumentCannotBeNull, nameof(typeArguments));\n            } 666064"];
8773 [label="if (typeArguments.Any(TypeWithAnnotationsIsNullFunction))\n            {\n                throw new ArgumentException(CSharpResources.TypeArgumentCannotBeNull, nameof(typeArguments));\n            } 666065"];
8774 [label="if (typeArguments.Any(TypeWithAnnotationsIsNullFunction))\n            {\n                throw new ArgumentException(CSharpResources.TypeArgumentCannotBeNull, nameof(typeArguments));\n            } 666066"];
8775 [label="if (typeArguments.Any(TypeWithAnnotationsIsNullFunction))\n            {\n                throw new ArgumentException(CSharpResources.TypeArgumentCannotBeNull, nameof(typeArguments));\n            } 666067"];
8776 [label="=> !(DefaultType is null) 666068"];
8777 [label="DefaultType is null 666069"];
8778 [label="!(DefaultType is null) 666070"];
8779 [label="this.Arity 666071"];
8780 [label="get\n                {\n                    return _arity;\n                } 666072"];
8781 [label="return _arity; 666073"];
8782 [label="if (typeArguments.Length != this.Arity)\n            {\n                throw new ArgumentException(CSharpResources.WrongNumberOfTypeArguments, nameof(typeArguments));\n            } 666074"];
8783 [label="Debug.Assert(!unbound || typeArguments.All(TypeWithAnnotationsIsErrorType)); 666075"];
8784 [label="this.TypeParameters 666076"];
8785 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 666077"];
8786 [label="EnsureTypeParametersAreLoaded() 666078"];
8787 [label="param EnsureTypeParametersAreLoaded(this) 666079"];
8788 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 666080"];
8789 [label="ContainingPEModule 666081"];
8790 [label="s.Kind 666082"];
8791 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 666083"];
8792 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 666084"];
8793 [label="var moduleSymbol = ContainingPEModule; 666085"];
8794 [label="int firstIndex = _genericParameterHandles.Count - _arity; 666086"];
8795 [label="TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity]; 666087"];
8796 [label="for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    } 666088"];
8797 [label="for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    } 666089"];
8798 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 666090"];
8799 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 666091"];
8800 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 666092"];
8801 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 666093"];
8802 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 666094"];
8803 [label="new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]) 666095"];
8804 [label="param PETypeParameterSymbol(PEModuleSymbol moduleSymbol) 666096"];
8805 [label="param PETypeParameterSymbol(PENamedTypeSymbol definingNamedType) 666097"];
8806 [label="param PETypeParameterSymbol(ushort ordinal) 666098"];
8807 [label="param PETypeParameterSymbol(GenericParameterHandle handle) 666099"];
8808 [label="param PETypeParameterSymbol(this) 666100"];
8809 [label="moduleSymbol 666101"];
8810 [label="definingNamedType 666102"];
8811 [label="ordinal 666103"];
8812 [label="handle 666104"];
8813 [label="param PETypeParameterSymbol(this) 666105"];
8814 [label="param PETypeParameterSymbol(PEModuleSymbol moduleSymbol) 666106"];
8815 [label="param PETypeParameterSymbol(Symbol definingSymbol) 666107"];
8816 [label="param PETypeParameterSymbol(ushort ordinal) 666108"];
8817 [label="param PETypeParameterSymbol(GenericParameterHandle handle) 666109"];
8818 [label="param PETypeParameterSymbol(this) 666110"];
8819 [label="param PETypeParameterSymbol(this) 666111"];
8820 [label="param TypeParameterSymbol(this) 666112"];
8821 [label="param TypeParameterSymbol(this) 666113"];
8822 [label="_lazyAdapter 666114"];
8823 [label="_containingSymbol 666115"];
8824 [label="_name 666116"];
8825 [label="_ordinal 666117"];
8826 [label="_lazyConstraintsUseSiteErrorInfo = CSDiagnosticInfo.EmptyErrorInfo 666118"];
8827 [label="_flags 666119"];
8828 [label="_lazyHasIsUnmanagedConstraint 666120"];
8829 [label="new TypeParameterBounds() 666121"];
8830 [label="param TypeParameterBounds(this) 666122"];
8831 [label="EffectiveBaseClass 666123"];
8832 [label="DeducedBaseType 666124"];
8833 [label="EffectiveBaseClass = null!; 666125"];
8834 [label="EffectiveBaseClass 666126"];
8835 [label="DeducedBaseType = null!; 666127"];
8836 [label="DeducedBaseType 666128"];
8837 [label="Unset = new TypeParameterBounds() 666129"];
8838 [label="_lazyBounds = TypeParameterBounds.Unset 666130"];
8839 [label="Debug.Assert((object)moduleSymbol != null); 666131"];
8840 [label="Debug.Assert((object)moduleSymbol != null); 666132"];
8841 [label="Debug.Assert((object)definingSymbol != null); 666133"];
8842 [label="Debug.Assert((object)definingSymbol != null); 666134"];
8843 [label="Debug.Assert(ordinal >= 0); 666135"];
8844 [label="Debug.Assert(ordinal >= 0); 666136"];
8845 [label="Debug.Assert(!handle.IsNil); 666137"];
8846 [label="_containingSymbol 666138"];
8847 [label="GenericParameterAttributes flags = 0; 666139"];
8848 [label="moduleSymbol.Module 666140"];
8849 [label="get\n            {\n                return _module;\n            } 666141"];
8850 [label="return _module; 666142"];
8851 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 666143"];
8852 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 666144"];
8853 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 666145"];
8854 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 666146"];
8855 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 666147"];
8856 [label="_flags = ((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) ? flags : (flags & ~GenericParameterAttributes.DefaultConstructorConstraint); 666148"];
8857 [label="_flags = ((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) ? flags : (flags & ~GenericParameterAttributes.DefaultConstructorConstraint); 666149"];
8858 [label="((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) 666150"];
8859 [label="_flags 666151"];
8860 [label="_ordinal 666152"];
8861 [label="_handle 666153"];
8862 [label="ownedParams[i] 666154"];
8863 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 666155"];
8864 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 666156"];
8865 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 666157"];
8866 [label="EnsureTypeParametersAreLoaded(); 666158"];
8867 [label="return _lazyTypeParameters; 666159"];
8868 [label="if (ConstructedNamedTypeSymbol.TypeParametersMatchTypeArguments(this.TypeParameters, typeArguments))\n            {\n                return this;\n            } 666160"];
8869 [label="if (ConstructedNamedTypeSymbol.TypeParametersMatchTypeArguments(this.TypeParameters, typeArguments))\n            {\n                return this;\n            } 666161"];
8870 [label="ConstructedNamedTypeSymbol.TypeParametersMatchTypeArguments(this.TypeParameters, typeArguments) 666162"];
8871 [label="param TypeParametersMatchTypeArguments(ImmutableArray<TypeParameterSymbol> typeParameters) 666163"];
8872 [label="param TypeParametersMatchTypeArguments(ImmutableArray<TypeWithAnnotations> typeArguments) 666164"];
8873 [label="int n = typeParameters.Length; 666165"];
8874 [label="Debug.Assert(typeArguments.Length == n); 666166"];
8875 [label="Debug.Assert(typeArguments.Length > 0); 666167"];
8876 [label="Debug.Assert(typeArguments.Length > 0); 666168"];
8877 [label="for (int i = 0; i < n; i++)\n            {\n                if (!typeArguments[i].Is(typeParameters[i]))\n                {\n                    return false;\n                }\n            } 666169"];
8878 [label="for (int i = 0; i < n; i++)\n            {\n                if (!typeArguments[i].Is(typeParameters[i]))\n                {\n                    return false;\n                }\n            } 666170"];
8879 [label="if (!typeArguments[i].Is(typeParameters[i]))\n                {\n                    return false;\n                } 666171"];
8880 [label="typeArguments[i].Is(typeParameters[i]) 666172"];
8881 [label="param Is(TypeParameterSymbol other) 666173"];
8882 [label="param Is(this) 666174"];
8883 [label="1 666175"];
8884 [label="NotAnnotatedAttributeValue = 1 666176"];
8885 [label="2 666177"];
8886 [label="AnnotatedAttributeValue = 2 666178"];
8887 [label="0 666179"];
8888 [label="ObliviousAttributeValue = 0 666180"];
8889 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 666181"];
8890 [label="NullableAnnotation.IsOblivious() 666182"];
8891 [label="param IsOblivious(this NullableAnnotation annotation) 666183"];
8892 [label="annotation == NullableAnnotation.Oblivious 666184"];
8893 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 666185"];
8894 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 666186"];
8895 [label="return false; 666187"];
8896 [label="return this.ConstructCore(typeArguments, unbound); 666188"];
8897 [label="return this.ConstructCore(typeArguments, unbound); 666189"];
8898 [label="this.ConstructCore(typeArguments, unbound) 666190"];
8899 [label="param ConstructCore(ImmutableArray<TypeWithAnnotations> typeArguments) 666191"];
8900 [label="param ConstructCore(bool unbound) 666192"];
8901 [label="param ConstructCore(this) 666193"];
8902 [label="return new ConstructedNamedTypeSymbol(this, typeArguments, unbound); 666194"];
8903 [label="return new ConstructedNamedTypeSymbol(this, typeArguments, unbound); 666195"];
8904 [label="return new ConstructedNamedTypeSymbol(this, typeArguments, unbound); 666196"];
8905 [label="return new ConstructedNamedTypeSymbol(this, typeArguments, unbound); 666197"];
8906 [label="new ConstructedNamedTypeSymbol(this, typeArguments, unbound) 666198"];
8907 [label="param ConstructedNamedTypeSymbol(NamedTypeSymbol constructedFrom) 666199"];
8908 [label="param ConstructedNamedTypeSymbol(ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations) 666200"];
8909 [label="param ConstructedNamedTypeSymbol(bool unbound = false) 666201"];
8910 [label="param ConstructedNamedTypeSymbol(TupleExtraData tupleData = null) 666202"];
8911 [label="param ConstructedNamedTypeSymbol(this) 666203"];
8912 [label="constructedFrom.ContainingSymbol 666204"];
8913 [label="get\n            {\n                return _container;\n            } 666205"];
8914 [label="return _container; 666206"];
8915 [label="constructedFrom.ContainingType 666207"];
8916 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 666208"];
8917 [label="return _container as NamedTypeSymbol; 666209"];
8918 [label="constructedFrom.OriginalDefinition 666210"];
8919 [label="get\n            {\n                return this;\n            } 666211"];
8920 [label="constructedFrom.OriginalDefinition.TypeParameters 666212"];
8921 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 666213"];
8922 [label="EnsureTypeParametersAreLoaded() 666214"];
8923 [label="param EnsureTypeParametersAreLoaded(this) 666215"];
8924 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 666216"];
8925 [label="EnsureTypeParametersAreLoaded(); 666217"];
8926 [label="return _lazyTypeParameters; 666218"];
8927 [label="t => t.Type 666219"];
8928 [label="AsTypeSymbol = t => t.Type 666220"];
8929 [label="ReferenceEqualityComparer.Instance 666221"];
8930 [label="new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance) 666222"];
8931 [label="s_emptyDictionary =\n            new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance) 666223"];
8932 [label="new TypeMap() 666224"];
8933 [label="param TypeMap(this) 666225"];
8934 [label="s_emptyDictionary 666226"];
8935 [label="param AbstractTypeParameterMap(SmallDictionary<TypeParameterSymbol, TypeWithAnnotations> mapping) 666227"];
8936 [label="param AbstractTypeParameterMap(this) 666228"];
8937 [label="param AbstractTypeMap(this) 666229"];
8938 [label="Mapping 666230"];
8939 [label="this.Mapping 666231"];
8940 [label="Debug.Assert(s_emptyDictionary.IsEmpty()); 666232"];
8941 [label="s_emptyTypeMap = new TypeMap() 666233"];
8942 [label="typeArgumentsWithAnnotations 666234"];
8943 [label="new TypeMap(constructedFrom.ContainingType, constructedFrom.OriginalDefinition.TypeParameters, typeArgumentsWithAnnotations) 666235"];
8944 [label="param TypeMap(NamedTypeSymbol containingType) 666236"];
8945 [label="param TypeMap(ImmutableArray<TypeParameterSymbol> typeParameters) 666237"];
8946 [label="param TypeMap(ImmutableArray<TypeWithAnnotations> typeArguments) 666238"];
8947 [label="param TypeMap(this) 666239"];
8948 [label="containingType 666240"];
8949 [label="ForType(containingType) 666241"];
8950 [label="param ForType(NamedTypeSymbol containingType) 666242"];
8951 [label="var substituted = containingType as SubstitutedNamedTypeSymbol; 666243"];
8952 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 666244"];
8953 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 666245"];
8954 [label="(object)substituted != null 666246"];
8955 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 666247"];
8956 [label="param AbstractTypeParameterMap(SmallDictionary<TypeParameterSymbol, TypeWithAnnotations> mapping) 666248"];
8957 [label="param AbstractTypeParameterMap(this) 666249"];
8958 [label="param AbstractTypeMap(this) 666250"];
8959 [label="Mapping 666251"];
8960 [label="this.Mapping 666252"];
8961 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 666253"];
8962 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 666254"];
8963 [label="TypeParameterSymbol tp = typeParameters[i]; 666255"];
8964 [label="TypeWithAnnotations ta = typeArguments[i]; 666256"];
8965 [label="if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                } 666257"];
8966 [label="ta.Is(tp) 666258"];
8967 [label="param Is(TypeParameterSymbol other) 666259"];
8968 [label="param Is(this) 666260"];
8969 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 666261"];
8970 [label="NullableAnnotation.IsOblivious() 666262"];
8971 [label="param IsOblivious(this NullableAnnotation annotation) 666263"];
8972 [label="annotation == NullableAnnotation.Oblivious 666264"];
8973 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 666265"];
8974 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 666266"];
8975 [label="Mapping.Add(tp, ta); 666267"];
8976 [label="Mapping.Add(tp, ta); 666268"];
8977 [label="Mapping.Add(tp, ta); 666269"];
8978 [label="constructedFrom.OriginalDefinition 666270"];
8979 [label="get\n            {\n                return this;\n            } 666271"];
8980 [label="s_symbolAsMemberFunc = SymbolExtensions.SymbolAsMember 666272"];
8981 [label="constructedFrom 666273"];
8982 [label="unbound 666274"];
8983 [label="tupleData 666275"];
8984 [label="param ConstructedNamedTypeSymbol(this) 666276"];
8985 [label="param SubstitutedNamedTypeSymbol(Symbol newContainer) 666277"];
8986 [label="param SubstitutedNamedTypeSymbol(TypeMap map) 666278"];
8987 [label="param SubstitutedNamedTypeSymbol(NamedTypeSymbol originalDefinition) 666279"];
8988 [label="param SubstitutedNamedTypeSymbol(NamedTypeSymbol constructedFrom = null) 666280"];
8989 [label="param SubstitutedNamedTypeSymbol(bool unbound = false) 666281"];
8990 [label="param SubstitutedNamedTypeSymbol(TupleExtraData tupleData = null) 666282"];
8991 [label="param SubstitutedNamedTypeSymbol(this) 666283"];
8992 [label="originalDefinition 666284"];
8993 [label="tupleData 666285"];
8994 [label="param SubstitutedNamedTypeSymbol(this) 666286"];
8995 [label="param WrappedNamedTypeSymbol(NamedTypeSymbol underlyingType) 666287"];
8996 [label="param WrappedNamedTypeSymbol(TupleExtraData tupleData) 666288"];
8997 [label="param WrappedNamedTypeSymbol(this) 666289"];
8998 [label="tupleData 666290"];
8999 [label="param WrappedNamedTypeSymbol(this) 666291"];
9000 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 666292"];
9001 [label="_lazyTupleData 666293"];
9002 [label="_underlyingType 666294"];
9003 [label="Debug.Assert((object)underlyingType != null); 666295"];
9004 [label="Debug.Assert((object)underlyingType != null); 666296"];
9005 [label="_underlyingType 666297"];
9006 [label="_unbound 666298"];
9007 [label="_inputMap 666299"];
9008 [label="_newContainer 666300"];
9009 [label="_lazyMap 666301"];
9010 [label="_hashCode 666302"];
9011 [label="_lazyMembersByNameCache 666303"];
9012 [label="originalDefinition.IsDefinition 666304"];
9013 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 666305"];
9014 [label="OriginalDefinition 666306"];
9015 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 666307"];
9016 [label="OriginalSymbolDefinition 666308"];
9017 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 666309"];
9018 [label="this.OriginalTypeSymbolDefinition 666310"];
9019 [label="get\n            {\n                return this.OriginalDefinition;\n            } 666311"];
9020 [label="this.OriginalDefinition 666312"];
9021 [label="get\n            {\n                return this;\n            } 666313"];
9022 [label="return this.OriginalDefinition; 666314"];
9023 [label="return this.OriginalTypeSymbolDefinition; 666315"];
9024 [label="return OriginalSymbolDefinition; 666316"];
9025 [label="return (object)this == (object)OriginalDefinition; 666317"];
9026 [label="Debug.Assert(originalDefinition.IsDefinition); 666318"];
9027 [label="Debug.Assert(!originalDefinition.IsErrorType()); 666319"];
9028 [label="originalDefinition.IsErrorType() 666320"];
9029 [label="param IsErrorType(this TypeSymbol type) 666321"];
9030 [label="RoslynDebug.Assert((object)type != null); 666322"];
9031 [label="RoslynDebug.Assert((object)type != null); 666323"];
9032 [label="type.Kind 666324"];
9033 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 666325"];
9034 [label="return type.Kind == SymbolKind.ErrorType; 666326"];
9035 [label="Debug.Assert(!originalDefinition.IsErrorType()); 666327"];
9036 [label="_newContainer 666328"];
9037 [label="_inputMap 666329"];
9038 [label="_unbound 666330"];
9039 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 666331"];
9040 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 666332"];
9041 [label="constructedFrom.ConstructedFrom 666333"];
9042 [label="get\n            {\n                return this;\n            } 666334"];
9043 [label="return this; 666335"];
9044 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 666336"];
9045 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 666337"];
9046 [label="constructedFrom.TypeParameters 666338"];
9047 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 666339"];
9048 [label="EnsureTypeParametersAreLoaded() 666340"];
9049 [label="param EnsureTypeParametersAreLoaded(this) 666341"];
9050 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 666342"];
9051 [label="EnsureTypeParametersAreLoaded(); 666343"];
9052 [label="return _lazyTypeParameters; 666344"];
9053 [label="_lazyTypeParameters = constructedFrom.TypeParameters; 666345"];
9054 [label="_lazyTypeParameters 666346"];
9055 [label="_lazyMap 666347"];
9056 [label="_constructedFrom 666348"];
9057 [label="_typeArgumentsWithAnnotations 666349"];
9058 [label="_constructedFrom 666350"];
9059 [label="constructedFrom.Arity 666351"];
9060 [label="get\n                {\n                    return _arity;\n                } 666352"];
9061 [label="return _arity; 666353"];
9062 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 666354"];
9063 [label="constructedFrom.Arity 666355"];
9064 [label="get\n                {\n                    return _arity;\n                } 666356"];
9065 [label="return _arity; 666357"];
9066 [label="Debug.Assert(constructedFrom.Arity != 0); 666358"];
9067 [label="Debug.Assert(constructedFrom.Arity != 0); 666359"];
9068 [label="return this.ConstructCore(typeArguments, unbound); 666360"];
9069 [label="return Construct(modifiedArguments, unbound); 666361"];
9070 [label="return ConstructWithoutModifiers(typeArguments, false); 666362"];
9071 [label="TypeWithAnnotations makeNullableT(CSharpCompilation comp, TypeSymbol typeSym)\n                => Create(comp.GetSpecialType(SpecialType.System_Nullable_T).Construct(ImmutableArray.Create(typeSym))); 666363"];
9072 [label="TypeWithAnnotations makeNullableT(CSharpCompilation comp, TypeSymbol typeSym)\n                => Create(comp.GetSpecialType(SpecialType.System_Nullable_T).Construct(ImmutableArray.Create(typeSym))); 666364"];
9073 [label="Create(comp.GetSpecialType(SpecialType.System_Nullable_T).Construct(ImmutableArray.Create(typeSym))) 666365"];
9074 [label="param Create(TypeSymbol typeSymbol) 666366"];
9075 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 666367"];
9076 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 666368"];
9077 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 666369"];
9078 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 666370"];
9079 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 666371"];
9080 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 666372"];
9081 [label="typeSymbol.IsNullableType() 666373"];
9082 [label="param IsNullableType(this TypeSymbol type) 666374"];
9083 [label="type.OriginalDefinition 666375"];
9084 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 666376"];
9085 [label="OriginalTypeSymbolDefinition 666377"];
9086 [label="get\n            {\n                return this.OriginalDefinition;\n            } 666378"];
9087 [label="this.OriginalDefinition 666379"];
9088 [label="get { return _underlyingType; } 666380"];
9089 [label="return _underlyingType; 666381"];
9090 [label="return this.OriginalDefinition; 666382"];
9091 [label="return OriginalTypeSymbolDefinition; 666383"];
9092 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 666384"];
9093 [label="type.OriginalDefinition.SpecialType 666385"];
9094 [label="get\n            {\n                return _corTypeId;\n            } 666386"];
9095 [label="return _corTypeId; 666387"];
9096 [label="nullableAnnotation = NullableAnnotation.Annotated; 666388"];
9097 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 666389"];
9098 [label="Extensions.Create(customModifiers) 666390"];
9099 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 666391"];
9100 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 666392"];
9101 [label="return Default; 666393"];
9102 [label="param TypeWithAnnotations(Extensions extensions) 666394"];
9103 [label="var a1 = defaultType is null; 666395"];
9104 [label="!a1 666396"];
9105 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 666397"];
9106 [label="defaultType.IsNullableType() 666398"];
9107 [label="param IsNullableType(this TypeSymbol type) 666399"];
9108 [label="type.OriginalDefinition 666400"];
9109 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 666401"];
9110 [label="OriginalTypeSymbolDefinition 666402"];
9111 [label="get\n            {\n                return this.OriginalDefinition;\n            } 666403"];
9112 [label="this.OriginalDefinition 666404"];
9113 [label="get { return _underlyingType; } 666405"];
9114 [label="return _underlyingType; 666406"];
9115 [label="return this.OriginalDefinition; 666407"];
9116 [label="return OriginalTypeSymbolDefinition; 666408"];
9117 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 666409"];
9118 [label="type.OriginalDefinition.SpecialType 666410"];
9119 [label="get\n            {\n                return _corTypeId;\n            } 666411"];
9120 [label="return _corTypeId; 666412"];
9121 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 666413"];
9122 [label="Debug.Assert(a1 || a2 != true || a3); 666414"];
9123 [label="Debug.Assert(a1 || a2 != true || a3); 666415"];
9124 [label="Debug.Assert(a1 || a2 != true || a3); 666416"];
9125 [label="Debug.Assert(extensions != null); 666417"];
9126 [label="Debug.Assert(extensions != null); 666418"];
9127 [label="_extensions 666419"];
9128 [label="TypeWithAnnotations makeNullableT(CSharpCompilation comp, TypeSymbol typeSym)\n                => Create(comp.GetSpecialType(SpecialType.System_Nullable_T).Construct(ImmutableArray.Create(typeSym))); 666420"];
9129 [label="return makeNullableT(compilation, typeSymbol); 666421"];
9130 [label="TypeWithAnnotations constructedType = typeArgument.SetIsAnnotated(Compilation); 666422"];
9131 [label="reportNullableReferenceTypesIfNeeded(nullableSyntax.QuestionToken, diagnostics, typeArgument); 666423"];
9132 [label="reportNullableReferenceTypesIfNeeded(nullableSyntax.QuestionToken, diagnostics, typeArgument); 666424"];
9133 [label="reportNullableReferenceTypesIfNeeded(nullableSyntax.QuestionToken, diagnostics, typeArgument); 666425"];
9134 [label="reportNullableReferenceTypesIfNeeded(nullableSyntax.QuestionToken, diagnostics, typeArgument) 666426"];
9135 [label="void reportNullableReferenceTypesIfNeeded(SyntaxToken questionToken, DiagnosticBag diagnostics, TypeWithAnnotations typeArgument = default)\n            {\n                bool isNullableEnabled = AreNullableAnnotationsEnabled(questionToken);\n                bool isGeneratedCode = IsGeneratedCode(questionToken);\n                var location = questionToken.GetLocation();\n\n                // Inside a method body or other executable code, we can question IsValueType without causing cycles.\n                if (typeArgument.HasType && !ShouldCheckConstraints)\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                }\n                else\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.ReportNullableReferenceTypesIfNeeded(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                }\n            } 666427"];
9136 [label="void reportNullableReferenceTypesIfNeeded(SyntaxToken questionToken, DiagnosticBag diagnostics, TypeWithAnnotations typeArgument = default)\n            {\n                bool isNullableEnabled = AreNullableAnnotationsEnabled(questionToken);\n                bool isGeneratedCode = IsGeneratedCode(questionToken);\n                var location = questionToken.GetLocation();\n\n                // Inside a method body or other executable code, we can question IsValueType without causing cycles.\n                if (typeArgument.HasType && !ShouldCheckConstraints)\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                }\n                else\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.ReportNullableReferenceTypesIfNeeded(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                }\n            } 666428"];
9137 [label="void reportNullableReferenceTypesIfNeeded(SyntaxToken questionToken, DiagnosticBag diagnostics, TypeWithAnnotations typeArgument = default)\n            {\n                bool isNullableEnabled = AreNullableAnnotationsEnabled(questionToken);\n                bool isGeneratedCode = IsGeneratedCode(questionToken);\n                var location = questionToken.GetLocation();\n\n                // Inside a method body or other executable code, we can question IsValueType without causing cycles.\n                if (typeArgument.HasType && !ShouldCheckConstraints)\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                }\n                else\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.ReportNullableReferenceTypesIfNeeded(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                }\n            } 666429"];
9138 [label="void reportNullableReferenceTypesIfNeeded(SyntaxToken questionToken, DiagnosticBag diagnostics, TypeWithAnnotations typeArgument = default)\n            {\n                bool isNullableEnabled = AreNullableAnnotationsEnabled(questionToken);\n                bool isGeneratedCode = IsGeneratedCode(questionToken);\n                var location = questionToken.GetLocation();\n\n                // Inside a method body or other executable code, we can question IsValueType without causing cycles.\n                if (typeArgument.HasType && !ShouldCheckConstraints)\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                }\n                else\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.ReportNullableReferenceTypesIfNeeded(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                }\n            } 666430"];
9139 [label="bool isNullableEnabled = AreNullableAnnotationsEnabled(questionToken); 666431"];
9140 [label="AreNullableAnnotationsEnabled(questionToken) 666432"];
9141 [label="param AreNullableAnnotationsEnabled(SyntaxToken token) 666433"];
9142 [label="param AreNullableAnnotationsEnabled(this) 666434"];
9143 [label="AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart) 666435"];
9144 [label="param AreNullableAnnotationsEnabled(this) 666436"];
9145 [label="bool isGeneratedCode = IsGeneratedCode(questionToken); 666437"];
9146 [label="IsGeneratedCode(questionToken) 666438"];
9147 [label="param IsGeneratedCode(SyntaxToken token) 666439"];
9148 [label="param IsGeneratedCode(this) 666440"];
9149 [label="var tree = (CSharpSyntaxTree)token.SyntaxTree!; 666441"];
9150 [label="Compilation.Options 666442"];
9151 [label="get\n            {\n                return _options;\n            } 666443"];
9152 [label="return _options; 666444"];
9153 [label="return tree.IsGeneratedCode(Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None); 666445"];
9154 [label="return tree.IsGeneratedCode(Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None); 666446"];
9155 [label="return tree.IsGeneratedCode(Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None); 666447"];
9156 [label="var location = questionToken.GetLocation(); 666448"];
9157 [label="typeArgument.HasType 666449"];
9158 [label="=> !(DefaultType is null) 666450"];
9159 [label="DefaultType is null 666451"];
9160 [label="!(DefaultType is null) 666452"];
9161 [label="if (typeArgument.HasType && !ShouldCheckConstraints)\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                }\n                else\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.ReportNullableReferenceTypesIfNeeded(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                } 666453"];
9162 [label="ShouldCheckConstraints 666454"];
9163 [label="get\n            {\n                return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks);\n            } 666455"];
9164 [label="return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks); 666456"];
9165 [label="return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks); 666457"];
9166 [label="this.Flags.Includes(BinderFlags.SuppressConstraintChecks) 666458"];
9167 [label="param Includes(this BinderFlags self) 666459"];
9168 [label="param Includes(BinderFlags other) 666460"];
9169 [label="if (typeArgument.HasType && !ShouldCheckConstraints)\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                }\n                else\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.ReportNullableReferenceTypesIfNeeded(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                } 666461"];
9170 [label="if (typeArgument.HasType && !ShouldCheckConstraints)\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                }\n                else\n                {\n                    LazyMissingNonNullTypesContextDiagnosticInfo.ReportNullableReferenceTypesIfNeeded(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics);\n                } 666462"];
9171 [label="LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics); 666463"];
9172 [label="LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics); 666464"];
9173 [label="LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics); 666465"];
9174 [label="LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics); 666466"];
9175 [label="LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics); 666467"];
9176 [label="LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics); 666468"];
9177 [label="LazyMissingNonNullTypesContextDiagnosticInfo.AddAll(\n                        isNullableEnabled,\n                        isGeneratedCode,\n                        typeArgument,\n                        location,\n                        diagnostics); 666469"];
9178 [label="reportNullableReferenceTypesIfNeeded(nullableSyntax.QuestionToken, diagnostics, typeArgument); 666470"];
9179 [label="ShouldCheckConstraints 666471"];
9180 [label="get\n            {\n                return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks);\n            } 666472"];
9181 [label="return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks); 666473"];
9182 [label="return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks); 666474"];
9183 [label="this.Flags.Includes(BinderFlags.SuppressConstraintChecks) 666475"];
9184 [label="param Includes(this BinderFlags self) 666476"];
9185 [label="param Includes(BinderFlags other) 666477"];
9186 [label="if (!ShouldCheckConstraints)\n                {\n                    diagnostics.Add(new LazyUseSiteDiagnosticsInfoForNullableType(Compilation.LanguageVersion, constructedType), syntax.GetLocation());\n                }\n                else if (constructedType.IsNullableType())\n                {\n                    ReportUseSiteDiagnostics(constructedType.Type.OriginalDefinition, diagnostics, syntax);\n                    var type = (NamedTypeSymbol)constructedType.Type;\n                    var location = syntax.Location;\n                    type.CheckConstraints(new ConstraintsHelper.CheckConstraintsArgs(this.Compilation, this.Conversions, includeNullability: true, location, diagnostics));\n                }\n                else if (GetNullableUnconstrainedTypeParameterDiagnosticIfNecessary(Compilation.LanguageVersion, constructedType) is { } diagnosticInfo)\n                {\n                    diagnostics.Add(diagnosticInfo, syntax.Location);\n                } 666478"];
9187 [label="diagnostics.Add(new LazyUseSiteDiagnosticsInfoForNullableType(Compilation.LanguageVersion, constructedType), syntax.GetLocation()); 666479"];
9188 [label="diagnostics.Add(new LazyUseSiteDiagnosticsInfoForNullableType(Compilation.LanguageVersion, constructedType), syntax.GetLocation()); 666480"];
9189 [label="diagnostics.Add(new LazyUseSiteDiagnosticsInfoForNullableType(Compilation.LanguageVersion, constructedType), syntax.GetLocation()); 666481"];
9190 [label="diagnostics.Add(new LazyUseSiteDiagnosticsInfoForNullableType(Compilation.LanguageVersion, constructedType), syntax.GetLocation()); 666482"];
9191 [label="return constructedType; 666483"];
9192 [label="constructedType 666484"];
9193 [label="param operator(TypeWithAnnotations typeWithAnnotations) 666485"];
9194 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 666486"];
9195 [label="new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations) 666487"];
9196 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(this) 666488"];
9197 [label="typeWithAnnotations.HasType 666489"];
9198 [label="=> !(DefaultType is null) 666490"];
9199 [label="DefaultType is null 666491"];
9200 [label="!(DefaultType is null) 666492"];
9201 [label="Debug.Assert(typeWithAnnotations.HasType); 666493"];
9202 [label="_symbol = null; 666494"];
9203 [label="_symbol 666495"];
9204 [label="_isNullableEnabled = false; 666496"];
9205 [label="_isNullableEnabled 666497"];
9206 [label="return constructedType; 666498"];
9207 [label="return bindNullable(syntax, diagnostics, basesBeingResolved); 666499"];
9208 [label="symbol.IsType 666500"];
9209 [label="=> !_typeWithAnnotations.IsDefault 666501"];
9210 [label="_typeWithAnnotations.IsDefault 666502"];
9211 [label="DefaultType is null 666503"];
9212 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 666504"];
9213 [label="param ReportDiagnosticsIfObsolete(Binder binder) 666505"];
9214 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 666506"];
9215 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 666507"];
9216 [label="binder 666508"];
9217 [label="syntax 666509"];
9218 [label="diagnostics 666510"];
9219 [label="param ReportDiagnosticsIfObsolete(Binder binder) 666511"];
9220 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 666512"];
9221 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 666513"];
9222 [label="param ReportDiagnosticsIfObsolete(this) 666514"];
9223 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 666515"];
9224 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 666516"];
9225 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 666517"];
9226 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 666518"];
9227 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 666519"];
9228 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 666520"];
9229 [label="=> defaultType 666521"];
9230 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 666522"];
9231 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 666523"];
9232 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 666524"];
9233 [label="param ReportDiagnosticsIfObsolete(this) 666525"];
9234 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 666526"];
9235 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 666527"];
9236 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 666528"];
9237 [label="param ReportDiagnosticsIfObsolete(this) 666529"];
9238 [label="get { return OriginalDefinition.Kind; } 666530"];
9239 [label="OriginalDefinition 666531"];
9240 [label="get { return _underlyingType; } 666532"];
9241 [label="return _underlyingType; 666533"];
9242 [label="return OriginalDefinition.Kind; 666534"];
9243 [label="OriginalDefinition.Kind 666535"];
9244 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 666536"];
9245 [label="return OriginalDefinition.Kind; 666537"];
9246 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 666538"];
9247 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 666539"];
9248 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 666540"];
9249 [label="this.ContainingMemberOrLambda 666541"];
9250 [label="get { return _containingMemberOrLambda; } 666542"];
9251 [label="return _containingMemberOrLambda; 666543"];
9252 [label="this.ContainingType 666544"];
9253 [label="get\n            {\n                var member = this.ContainingMemberOrLambda;\n                RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType);\n                return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                };\n            } 666545"];
9254 [label="this.ContainingMemberOrLambda 666546"];
9255 [label="get { return _containingMemberOrLambda; } 666547"];
9256 [label="return _containingMemberOrLambda; 666548"];
9257 [label="var member = this.ContainingMemberOrLambda; 666549"];
9258 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 666550"];
9259 [label="member.Kind 666551"];
9260 [label="get\n            {\n                return SymbolKind.Field;\n            } 666552"];
9261 [label="return SymbolKind.Field; 666553"];
9262 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 666554"];
9263 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 666555"];
9264 [label="member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                } 666556"];
9265 [label="member.ContainingType 666557"];
9266 [label="return this.containingType; 666558"];
9267 [label="return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                }; 666559"];
9268 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 666560"];
9269 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 666561"];
9270 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 666562"];
9271 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 666563"];
9272 [label="param ReportDiagnosticsIfObsolete(Symbol? containingMember) 666564"];
9273 [label="param ReportDiagnosticsIfObsolete(NamedTypeSymbol? containingType) 666565"];
9274 [label="param ReportDiagnosticsIfObsolete(BinderFlags location) 666566"];
9275 [label="RoslynDebug.Assert(symbol is object); 666567"];
9276 [label="symbol.Kind 666568"];
9277 [label="get { return OriginalDefinition.Kind; } 666569"];
9278 [label="OriginalDefinition 666570"];
9279 [label="get { return _underlyingType; } 666571"];
9280 [label="return _underlyingType; 666572"];
9281 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 666573"];
9282 [label="RoslynDebug.Assert(symbol.Kind == SymbolKind.NamedType ||\n                         symbol.Kind == SymbolKind.Field ||\n                         symbol.Kind == SymbolKind.Method ||\n                         symbol.Kind == SymbolKind.Event ||\n                         symbol.Kind == SymbolKind.Property); 666574"];
9283 [label="symbol.Kind 666575"];
9284 [label="get { return OriginalDefinition.Kind; } 666576"];
9285 [label="OriginalDefinition 666577"];
9286 [label="get { return _underlyingType; } 666578"];
9287 [label="return _underlyingType; 666579"];
9288 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 666580"];
9289 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                symbol = ((MethodSymbol)symbol).ConstructedFrom;\n            } 666581"];
9290 [label="param GetLeastOverriddenMember(NamedTypeSymbol accessingTypeOpt) 666582"];
9291 [label="get { return OriginalDefinition.Kind; } 666583"];
9292 [label="OriginalDefinition 666584"];
9293 [label="get { return _underlyingType; } 666585"];
9294 [label="return _underlyingType; 666586"];
9295 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 666587"];
9296 [label="bool checkOverridingSymbol = hasBaseReceiver && !ReferenceEquals(symbol, leastOverriddenSymbol); 666588"];
9297 [label="if (checkOverridingSymbol)\n            {\n                // If we have a base receiver, we must be done with declaration binding, so it should\n                // be safe to decode diagnostics.  We want to do this since reporting for the overriding\n                // member is conditional on reporting for the overridden member (i.e. we need a definite\n                // answer so we don't double-report).  You might think that double reporting just results\n                // in cascading diagnostics, but it's possible that the second diagnostic is an error\n                // while the first is merely a warning.\n                leastOverriddenSymbol.GetAttributes();\n            } 666589"];
9298 [label="param ReportDiagnosticsIfObsoleteInternal(DiagnosticBag diagnostics) 666590"];
9299 [label="param ReportDiagnosticsIfObsoleteInternal(SyntaxNodeOrToken node) 666591"];
9300 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol? containingMember) 666592"];
9301 [label="param ReportDiagnosticsIfObsoleteInternal(BinderFlags location) 666593"];
9302 [label="RoslynDebug.Assert(diagnostics != null); 666594"];
9303 [label="RoslynDebug.Assert(diagnostics != null); 666595"];
9304 [label="param GetObsoleteDiagnosticKind(Symbol containingMember) 666596"];
9305 [label="param GetObsoleteDiagnosticKind(bool forceComplete = false) 666597"];
9306 [label="get { return _underlyingType.ObsoleteAttributeData; } 666598"];
9307 [label="_underlyingType.ObsoleteAttributeData 666599"];
9308 [label="get\n            {\n                var uncommon = GetUncommonProperties();\n                if (uncommon == s_noUncommonProperties)\n                {\n                    return null;\n                }\n\n                bool ignoreByRefLikeMarker = this.IsRefLikeType;\n                ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker);\n                return uncommon.lazyObsoleteAttributeData;\n            } 666600"];
9309 [label="s.Kind 666601"];
9310 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 666602"];
9311 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 666603"];
9312 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return null;\n                } 666604"];
9313 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 666605"];
9314 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 666606"];
9315 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                } 666607"];
9316 [label="var isByRefLike = ThreeState.False; 666608"];
9317 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 666609"];
9318 [label="s.Kind 666610"];
9319 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 666611"];
9320 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 666612"];
9321 [label="Debug.Assert((object)moduleSymbol != null); 666613"];
9322 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 666614"];
9323 [label="return baseType; 666615"];
9324 [label="result = TypeKind.Class; 666616"];
9325 [label="s.Kind 666617"];
9326 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 666618"];
9327 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 666619"];
9328 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 666620"];
9329 [label="Debug.Assert((object)moduleSymbol != null); 666621"];
9330 [label="Debug.Assert(obsoleteAttributeData == null || !obsoleteAttributeData.IsUninitialized); 666622"];
9331 [label="return uncommon.lazyObsoleteAttributeData; 666623"];
9332 [label="return _underlyingType.ObsoleteAttributeData; 666624"];
9333 [label="var data = this.ObsoleteAttributeData; 666625"];
9334 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 666626"];
9335 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 666627"];
9336 [label="(data == null) 666628"];
9337 [label="switch (symbol.ObsoleteKind)\n            {\n                case ObsoleteAttributeKind.None:\n                    return ObsoleteDiagnosticKind.NotObsolete;\n                case ObsoleteAttributeKind.Experimental:\n                    return ObsoleteDiagnosticKind.Diagnostic;\n                case ObsoleteAttributeKind.Uninitialized:\n                    // If we haven't cracked attributes on the symbol at all or we haven't\n                    // cracked attribute arguments enough to be able to report diagnostics for\n                    // ObsoleteAttribute, store the symbol so that we can report diagnostics at a \n                    // later stage.\n                    return ObsoleteDiagnosticKind.Lazy;\n            } 666629"];
9338 [label="return ObsoleteDiagnosticKind.NotObsolete; 666630"];
9339 [label="DiagnosticInfo? info = null; 666631"];
9340 [label="switch (kind)\n            {\n                case ObsoleteDiagnosticKind.Diagnostic:\n                    info = ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(symbol, location);\n                    break;\n                case ObsoleteDiagnosticKind.Lazy:\n                case ObsoleteDiagnosticKind.LazyPotentiallySuppressed:\n                    info = new LazyObsoleteDiagnosticInfo(symbol, containingMember, location);\n                    break;\n            } 666632"];
9341 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 666633"];
9342 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 666634"];
9343 [label="return kind; 666635"];
9344 [label="switch (diagnosticKind)\n            {\n                case ObsoleteDiagnosticKind.NotObsolete:\n                case ObsoleteDiagnosticKind.Lazy:\n                    if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    }\n                    break;\n            } 666636"];
9345 [label="if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    } 666637"];
9346 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 666638"];
9347 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 666639"];
9348 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 666640"];
9349 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 666641"];
9350 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved) 666642"];
9351 [label="param UnwrapAlias(DiagnosticBag diagnostics) 666643"];
9352 [label="param UnwrapAlias(SyntaxNode syntax) 666644"];
9353 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 666645"];
9354 [label="param UnwrapAlias(this) 666646"];
9355 [label="symbol.IsAlias 666647"];
9356 [label="=> _symbol?.Kind == SymbolKind.Alias 666648"];
9357 [label="_symbol 666649"];
9358 [label="_symbol?.Kind == SymbolKind.Alias 666650"];
9359 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 666651"];
9360 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations 666652"];
9361 [label="IsFixedSizeBuffer 666653"];
9362 [label="=> (Modifiers & DeclarationModifiers.Fixed) != 0 666654"];
9363 [label="Modifiers 666655"];
9364 [label="get\n            {\n                return _modifiers;\n            } 666656"];
9365 [label="return _modifiers; 666657"];
9366 [label="Modifiers & DeclarationModifiers.Fixed 666658"];
9367 [label="0 666659"];
9368 [label="(Modifiers & DeclarationModifiers.Fixed) != 0 666660"];
9369 [label="if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                } 666661"];
9370 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 666662"];
9371 [label="this.RequiredCustomModifiers 666663"];
9372 [label="get\n            {\n                if (!IsVolatile)\n                {\n                    return ImmutableArray<CustomModifier>.Empty;\n                }\n                else\n                {\n                    return ImmutableArray.Create<CustomModifier>(\n                            CSharpCustomModifier.CreateRequired(this.ContainingAssembly.GetSpecialType(SpecialType.System_Runtime_CompilerServices_IsVolatile)));\n                }\n            } 666664"];
9373 [label="IsVolatile 666665"];
9374 [label="=> (Modifiers & DeclarationModifiers.Volatile) != 0 666666"];
9375 [label="Modifiers 666667"];
9376 [label="get\n            {\n                return _modifiers;\n            } 666668"];
9377 [label="return _modifiers; 666669"];
9378 [label="Modifiers & DeclarationModifiers.Volatile 666670"];
9379 [label="0 666671"];
9380 [label="(Modifiers & DeclarationModifiers.Volatile) != 0 666672"];
9381 [label="if (!IsVolatile)\n                {\n                    return ImmutableArray<CustomModifier>.Empty;\n                }\n                else\n                {\n                    return ImmutableArray.Create<CustomModifier>(\n                            CSharpCustomModifier.CreateRequired(this.ContainingAssembly.GetSpecialType(SpecialType.System_Runtime_CompilerServices_IsVolatile)));\n                } 666673"];
9382 [label="return ImmutableArray<CustomModifier>.Empty; 666674"];
9383 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 666675"];
9384 [label="type.WithModifiers(this.RequiredCustomModifiers) 666676"];
9385 [label="param WithModifiers(ImmutableArray<CustomModifier> customModifiers) 666677"];
9386 [label="=>\n            _extensions.WithModifiers(this, customModifiers) 666678"];
9387 [label="this 666679"];
9388 [label="customModifiers 666680"];
9389 [label="_extensions.WithModifiers(this, customModifiers) 666681"];
9390 [label="param WithModifiers(TypeWithAnnotations type) 666682"];
9391 [label="param WithModifiers(ImmutableArray<CustomModifier> customModifiers) 666683"];
9392 [label="param WithModifiers(this) 666684"];
9393 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 666685"];
9394 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 666686"];
9395 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 666687"];
9396 [label="CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers) 666688"];
9397 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 666689"];
9398 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 666690"];
9399 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 666691"];
9400 [label="Extensions.Create(customModifiers) 666692"];
9401 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 666693"];
9402 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 666694"];
9403 [label="param TypeWithAnnotations(this) 666695"];
9404 [label="var a1 = defaultType is null; 666696"];
9405 [label="!a1 666697"];
9406 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 666698"];
9407 [label="defaultType.IsNullableType() 666699"];
9408 [label="param IsNullableType(this TypeSymbol type) 666700"];
9409 [label="type.OriginalDefinition 666701"];
9410 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 666702"];
9411 [label="OriginalTypeSymbolDefinition 666703"];
9412 [label="get\n            {\n                return this.OriginalDefinition;\n            } 666704"];
9413 [label="this.OriginalDefinition 666705"];
9414 [label="get { return _underlyingType; } 666706"];
9415 [label="return _underlyingType; 666707"];
9416 [label="type.OriginalDefinition.SpecialType 666708"];
9417 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 666709"];
9418 [label="Debug.Assert(a1 || a2 != true || a3); 666710"];
9419 [label="Debug.Assert(a1 || a2 != true || a3); 666711"];
9420 [label="Debug.Assert(a1 || a2 != true || a3); 666712"];
9421 [label="Debug.Assert(extensions != null); 666713"];
9422 [label="Debug.Assert(extensions != null); 666714"];
9423 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 666715"];
9424 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 666716"];
9425 [label="default 666717"];
9426 [label="new Boxed(default) 666718"];
9427 [label="param Boxed(TypeWithAnnotations value) 666719"];
9428 [label="param Boxed(this) 666720"];
9429 [label="Value 666721"];
9430 [label="Sentinel = new Boxed(default) 666722"];
9431 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 666723"];
9432 [label="new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)) 666724"];
9433 [label="param Boxed(TypeWithAnnotations value) 666725"];
9434 [label="param Boxed(this) 666726"];
9435 [label="Value 666727"];
9436 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 666728"];
9437 [label="type.Type 666729"];
9438 [label="=> defaultType 666730"];
9439 [label="TypeChecks(type.Type, diagnostics); 666731"];
9440 [label="TypeChecks(type.Type, diagnostics); 666732"];
9441 [label="TypeChecks(type.Type, diagnostics) 666733"];
9442 [label="param TypeChecks(TypeSymbol type) 666734"];
9443 [label="param TypeChecks(DiagnosticBag diagnostics) 666735"];
9444 [label="param TypeChecks(this) 666736"];
9445 [label="type.IsStatic 666737"];
9446 [label="get\n            {\n                return _underlyingType.IsStatic;\n            } 666738"];
9447 [label="_underlyingType.IsStatic 666739"];
9448 [label="get\n            {\n                return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0;\n            } 666740"];
9449 [label="return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0; 666741"];
9450 [label="return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0; 666742"];
9451 [label="return _underlyingType.IsStatic; 666743"];
9452 [label="if (type.IsStatic)\n            {\n                // Cannot declare a variable of static type '{0}'\n                diagnostics.Add(ErrorCode.ERR_VarDeclIsStaticClass, this.ErrorLocation, type);\n            }\n            else if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 666744"];
9453 [label="if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 666745"];
9454 [label="type.IsVoidType() 666746"];
9455 [label="param IsVoidType(this TypeSymbol type) 666747"];
9456 [label="type.SpecialType 666748"];
9457 [label="get\n            {\n                return SpecialType.None;\n            } 666749"];
9458 [label="return SpecialType.None; 666750"];
9459 [label="return type.SpecialType == SpecialType.System_Void; 666751"];
9460 [label="if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 666752"];
9461 [label="if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 666753"];
9462 [label="if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 666754"];
9463 [label="type.IsRestrictedType(ignoreSpanLikeTypes: true) 666755"];
9464 [label="param IsRestrictedType(this TypeSymbol type) 666756"];
9465 [label="param IsRestrictedType(bool ignoreSpanLikeTypes = false) 666757"];
9466 [label="RoslynDebug.Assert((object)type != null); 666758"];
9467 [label="RoslynDebug.Assert((object)type != null); 666759"];
9468 [label="type.SpecialType 666760"];
9469 [label="get\n            {\n                return SpecialType.None;\n            } 666761"];
9470 [label="switch (type.SpecialType)\n            {\n                case SpecialType.System_TypedReference:\n                case SpecialType.System_ArgIterator:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            } 666762"];
9471 [label="ignoreSpanLikeTypes 666763"];
9472 [label="return ignoreSpanLikeTypes ?\n                        false :\n                        type.IsRefLikeType; 666764"];
9473 [label="type.IsRefLikeType 666765"];
9474 [label="get { return _underlyingType.IsRefLikeType; } 666766"];
9475 [label="_underlyingType.IsRefLikeType 666767"];
9476 [label="get\n            {\n                var uncommon = GetUncommonProperties();\n                if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                }\n\n                if (!uncommon.lazyIsByRefLike.HasValue())\n                {\n                    var isByRefLike = ThreeState.False;\n\n                    if (this.TypeKind == TypeKind.Struct)\n                    {\n                        var moduleSymbol = this.ContainingPEModule;\n                        var module = moduleSymbol.Module;\n                        isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState();\n                    }\n\n                    uncommon.lazyIsByRefLike = isByRefLike;\n                }\n\n                return uncommon.lazyIsByRefLike.Value();\n            } 666768"];
9477 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 666769"];
9478 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 666770"];
9479 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                } 666771"];
9480 [label="return _underlyingType.IsRefLikeType; 666772"];
9481 [label="if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 666773"];
9482 [label="IsConst 666774"];
9483 [label="=> (Modifiers & DeclarationModifiers.Const) != 0 666775"];
9484 [label="Modifiers 666776"];
9485 [label="get\n            {\n                return _modifiers;\n            } 666777"];
9486 [label="Modifiers & DeclarationModifiers.Const 666778"];
9487 [label="0 666779"];
9488 [label="(Modifiers & DeclarationModifiers.Const) != 0 666780"];
9489 [label="if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 666781"];
9490 [label="IsVolatile 666782"];
9491 [label="if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 666783"];
9492 [label="HashSet<DiagnosticInfo> useSiteDiagnostics = null; 666784"];
9493 [label="if (!this.IsNoMoreVisibleThan(type, ref useSiteDiagnostics))\n            {\n                // Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'\n                diagnostics.Add(ErrorCode.ERR_BadVisFieldType, this.ErrorLocation, this, type);\n            } 666785"];
9494 [label="if (!this.IsNoMoreVisibleThan(type, ref useSiteDiagnostics))\n            {\n                // Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'\n                diagnostics.Add(ErrorCode.ERR_BadVisFieldType, this.ErrorLocation, this, type);\n            } 666786"];
9495 [label="if (!this.IsNoMoreVisibleThan(type, ref useSiteDiagnostics))\n            {\n                // Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'\n                diagnostics.Add(ErrorCode.ERR_BadVisFieldType, this.ErrorLocation, this, type);\n            } 666787"];
9496 [label="this.IsNoMoreVisibleThan(type, ref useSiteDiagnostics) 666788"];
9497 [label="param IsNoMoreVisibleThan(this Symbol symbol) 666789"];
9498 [label="param IsNoMoreVisibleThan(TypeSymbol type) 666790"];
9499 [label="param IsNoMoreVisibleThan(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 666791"];
9500 [label="return type.IsAtLeastAsVisibleAs(symbol, ref useSiteDiagnostics); 666792"];
9501 [label="return type.IsAtLeastAsVisibleAs(symbol, ref useSiteDiagnostics); 666793"];
9502 [label="return type.IsAtLeastAsVisibleAs(symbol, ref useSiteDiagnostics); 666794"];
9503 [label="type.IsAtLeastAsVisibleAs(symbol, ref useSiteDiagnostics) 666795"];
9504 [label="param IsAtLeastAsVisibleAs(this TypeSymbol type) 666796"];
9505 [label="param IsAtLeastAsVisibleAs(Symbol sym) 666797"];
9506 [label="param IsAtLeastAsVisibleAs(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 666798"];
9507 [label="HashSet<DiagnosticInfo>? localUseSiteDiagnostics = useSiteDiagnostics; 666799"];
9508 [label="var result = type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true); 666800"];
9509 [label="var result = type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true); 666801"];
9510 [label="var result = type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true); 666802"];
9511 [label="var result = type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true); 666803"];
9512 [label="type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true) 666804"];
9513 [label="param VisitType(this TypeSymbol type) 666805"];
9514 [label="param VisitType(Func<TypeSymbol, T, bool, bool> predicate) 666806"];
9515 [label="param VisitType(T arg) 666807"];
9516 [label="param VisitType(bool canDigThroughNullable = false) 666808"];
9517 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 666809"];
9518 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 666810"];
9519 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 666811"];
9520 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 666812"];
9521 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 666813"];
9522 [label="VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable) 666814"];
9523 [label="param VisitType(this TypeWithAnnotations typeWithAnnotationsOpt) 666815"];
9524 [label="param VisitType(TypeSymbol? type) 666816"];
9525 [label="param VisitType(Func<TypeWithAnnotations, T, bool, bool>? typeWithAnnotationsPredicate) 666817"];
9526 [label="param VisitType(Func<TypeSymbol, T, bool, bool>? typePredicate) 666818"];
9527 [label="param VisitType(T arg) 666819"];
9528 [label="param VisitType(bool canDigThroughNullable = false) 666820"];
9529 [label="param VisitType(bool useDefaultType = false) 666821"];
9530 [label="typeWithAnnotationsOpt.HasType 666822"];
9531 [label="=> !(DefaultType is null) 666823"];
9532 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 666824"];
9533 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 666825"];
9534 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 666826"];
9535 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 666827"];
9536 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 666828"];
9537 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 666829"];
9538 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 666830"];
9539 [label="while (true)\n            {\n                TypeSymbol current = type ?? (useDefaultType ? typeWithAnnotationsOpt.DefaultType : typeWithAnnotationsOpt.Type);\n                bool isNestedNamedType = false;\n\n                // Visit containing types from outer-most to inner-most.\n                switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                }\n\n                if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n\n                TypeWithAnnotations next;\n\n                switch (current.TypeKind)\n                {\n                    case TypeKind.Dynamic:\n                    case TypeKind.TypeParameter:\n                    case TypeKind.Submission:\n                    case TypeKind.Enum:\n                        return null;\n\n                    case TypeKind.Error:\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Delegate:\n                        var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics;\n                        if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        }\n\n                        int i;\n                        for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        }\n\n                        next = typeArguments[i];\n                        break;\n\n                    case TypeKind.Array:\n                        next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.Pointer:\n                        next = ((PointerTypeSymbol)current).PointedAtTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.FunctionPointer:\n                        {\n                            var result = visitFunctionPointerType((FunctionPointerTypeSymbol)current, typeWithAnnotationsPredicate, typePredicate, arg, useDefaultType, canDigThroughNullable, out next);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n\n                            break;\n                        }\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(current.TypeKind);\n                }\n\n                // Let's try to avoid early resolution of nullable types\n                typeWithAnnotationsOpt = canDigThroughNullable ? default : next;\n                type = canDigThroughNullable ? next.NullableUnderlyingTypeOrSelf : null;\n            } 666831"];
9540 [label="TypeSymbol current = type ?? (useDefaultType ? typeWithAnnotationsOpt.DefaultType : typeWithAnnotationsOpt.Type); 666832"];
9541 [label="bool isNestedNamedType = false; 666833"];
9542 [label="current.TypeKind 666834"];
9543 [label="get\n            {\n                return _underlyingType.TypeKind;\n            } 666835"];
9544 [label="_underlyingType.TypeKind 666836"];
9545 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 666837"];
9546 [label="return _underlyingType.TypeKind; 666838"];
9547 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 666839"];
9548 [label="current.ContainingType 666840"];
9549 [label="get\n            {\n                return _newContainer as NamedTypeSymbol;\n            } 666841"];
9550 [label="return _newContainer as NamedTypeSymbol; 666842"];
9551 [label="var containingType = current.ContainingType; 666843"];
9552 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 666844"];
9553 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 666845"];
9554 [label="typeWithAnnotationsOpt.HasType 666846"];
9555 [label="=> !(DefaultType is null) 666847"];
9556 [label="if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 666848"];
9557 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 666849"];
9558 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 666850"];
9559 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 666851"];
9560 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 666852"];
9561 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 666853"];
9562 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 666854"];
9563 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 666855"];
9564 [label="param IsTypeLessVisibleThan(TypeSymbol type) 666856"];
9565 [label="param IsTypeLessVisibleThan(Symbol sym) 666857"];
9566 [label="param IsTypeLessVisibleThan(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 666858"];
9567 [label="type.TypeKind 666859"];
9568 [label="get\n            {\n                return _underlyingType.TypeKind;\n            } 666860"];
9569 [label="_underlyingType.TypeKind 666861"];
9570 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 666862"];
9571 [label="return _underlyingType.TypeKind; 666863"];
9572 [label="switch (type.TypeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Struct:\n                case TypeKind.Interface:\n                case TypeKind.Enum:\n                case TypeKind.Delegate:\n                case TypeKind.Submission:\n                    return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics);\n\n                default:\n                    return false;\n            } 666864"];
9573 [label="return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics); 666865"];
9574 [label="return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics); 666866"];
9575 [label="return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics); 666867"];
9576 [label="IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics) 666868"];
9577 [label="param IsAsRestrictive(NamedTypeSymbol s1) 666869"];
9578 [label="param IsAsRestrictive(Symbol sym2) 666870"];
9579 [label="param IsAsRestrictive(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 666871"];
9580 [label="s1.DeclaredAccessibility 666872"];
9581 [label="get\n            {\n                return _underlyingType.DeclaredAccessibility;\n            } 666873"];
9582 [label="_underlyingType.DeclaredAccessibility 666874"];
9583 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 666875"];
9584 [label="Accessibility access = Accessibility.Private; 666876"];
9585 [label="return _underlyingType.DeclaredAccessibility; 666877"];
9586 [label="Accessibility acc1 = s1.DeclaredAccessibility; 666878"];
9587 [label="if (acc1 == Accessibility.Public)\n            {\n                return true;\n            } 666879"];
9588 [label="return true; 666880"];
9589 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 666881"];
9590 [label="TypeWithAnnotations next; 666882"];
9591 [label="next 666883"];
9592 [label="current.TypeKind 666884"];
9593 [label="get\n            {\n                return _underlyingType.TypeKind;\n            } 666885"];
9594 [label="_underlyingType.TypeKind 666886"];
9595 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 666887"];
9596 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Dynamic:\n                    case TypeKind.TypeParameter:\n                    case TypeKind.Submission:\n                    case TypeKind.Enum:\n                        return null;\n\n                    case TypeKind.Error:\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Delegate:\n                        var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics;\n                        if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        }\n\n                        int i;\n                        for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        }\n\n                        next = typeArguments[i];\n                        break;\n\n                    case TypeKind.Array:\n                        next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.Pointer:\n                        next = ((PointerTypeSymbol)current).PointedAtTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.FunctionPointer:\n                        {\n                            var result = visitFunctionPointerType((FunctionPointerTypeSymbol)current, typeWithAnnotationsPredicate, typePredicate, arg, useDefaultType, canDigThroughNullable, out next);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n\n                            break;\n                        }\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(current.TypeKind);\n                } 666888"];
9597 [label="((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 666889"];
9598 [label="get\n            {\n                return _typeArgumentsWithAnnotations;\n            } 666890"];
9599 [label="return _typeArgumentsWithAnnotations; 666891"];
9600 [label="var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 666892"];
9601 [label="if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        } 666893"];
9602 [label="int i; 666894"];
9603 [label="for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        } 666895"];
9604 [label="for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        } 666896"];
9605 [label="next = typeArguments[i]; 666897"];
9606 [label="canDigThroughNullable 666898"];
9607 [label="typeWithAnnotationsOpt = canDigThroughNullable ? default : next; 666899"];
9608 [label="canDigThroughNullable 666900"];
9609 [label="next.NullableUnderlyingTypeOrSelf 666901"];
9610 [label="=> _extensions.GetNullableUnderlyingTypeOrSelf(DefaultType) 666902"];
9611 [label="DefaultType 666903"];
9612 [label="_extensions.GetNullableUnderlyingTypeOrSelf(DefaultType) 666904"];
9613 [label="param GetNullableUnderlyingTypeOrSelf(TypeSymbol typeSymbol) 666905"];
9614 [label="=> typeSymbol.StrippedType() 666906"];
9615 [label="typeSymbol 666907"];
9616 [label="typeSymbol.StrippedType() 666908"];
9617 [label="param StrippedType(this TypeSymbol type) 666909"];
9618 [label="return type.IsNullableType() ? type.GetNullableUnderlyingType() : type; 666910"];
9619 [label="type.IsNullableType() 666911"];
9620 [label="param IsNullableType(this TypeSymbol type) 666912"];
9621 [label="type = canDigThroughNullable ? next.NullableUnderlyingTypeOrSelf : null; 666913"];
9622 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 666914"];
9623 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 666915"];
9624 [label="current.ContainingType 666916"];
9625 [label="var containingType = current.ContainingType; 666917"];
9626 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 666918"];
9627 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 666919"];
9628 [label="=> !(DefaultType is null) 666920"];
9629 [label="if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 666921"];
9630 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 666922"];
9631 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 666923"];
9632 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 666924"];
9633 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 666925"];
9634 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 666926"];
9635 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 666927"];
9636 [label="param IsTypeLessVisibleThan(Symbol sym) 666928"];
9637 [label="type.TypeKind 666929"];
9638 [label="param IsAsRestrictive(Symbol sym2) 666930"];
9639 [label="Accessibility access = Accessibility.Private; 666931"];
9640 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 666932"];
9641 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 666933"];
9642 [label="if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        } 666934"];
9643 [label="return null; 666935"];
9644 [label="useSiteDiagnostics = localUseSiteDiagnostics; 666936"];
9645 [label="return result is null; 666937"];
9646 [label="diagnostics.Add(this.ErrorLocation, useSiteDiagnostics); 666938"];
9647 [label="this.ErrorLocation 666939"];
9648 [label="get\n            {\n                return _location;\n            } 666940"];
9649 [label="return _location; 666941"];
9650 [label="diagnostics.Add(this.ErrorLocation, useSiteDiagnostics); 666942"];
9651 [label="diagnostics.Add(this.ErrorLocation, useSiteDiagnostics); 666943"];
9652 [label="diagnostics.Add(this.ErrorLocation, useSiteDiagnostics); 666944"];
9653 [label="TypeChecks(type.Type, diagnostics); 666945"];
9654 [label="compilation.DeclarationDiagnostics 666946"];
9655 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 666947"];
9656 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 666948"];
9657 [label="return _lazyDeclarationDiagnostics; 666949"];
9658 [label="compilation.DeclarationDiagnostics.AddRange(diagnostics); 666950"];
9659 [label="compilation.DeclarationDiagnostics.AddRange(diagnostics); 666951"];
9660 [label="bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator; 666952"];
9661 [label="bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator; 666953"];
9662 [label="if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                } 666954"];
9663 [label="compilation.DeclarationDiagnostics 666955"];
9664 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 666956"];
9665 [label="compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator); 666957"];
9666 [label="compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator); 666958"];
9667 [label="state.NotePartComplete(CompletionPart.Type); 666959"];
9668 [label="state.NotePartComplete(CompletionPart.Type) 666960"];
9669 [label="param NotePartComplete(CompletionPart part) 666961"];
9670 [label="param NotePartComplete(this) 666962"];
9671 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 666963"];
9672 [label="diagnostics.Free(); 666964"];
9673 [label="diagnosticsForFirstDeclarator.Free(); 666965"];
9674 [label="return _lazyType.Value; 666966"];
9675 [label="return GetFieldType(ConsList<FieldSymbol>.Empty); 666967"];
9676 [label="TypeWithAnnotations.Type 666968"];
9677 [label="=> _extensions?.GetResolvedType(DefaultType) 666969"];
9678 [label=".GetResolvedType(DefaultType) 666970"];
9679 [label="=> defaultType 666971"];
9680 [label="varX.Type.OriginalDefinition 666972"];
9681 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 666973"];
9682 [label="OriginalTypeSymbolDefinition 666974"];
9683 [label="this.OriginalDefinition 666975"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 3;
192 -> 191;
193 -> 192;
194 -> 193;
194 -> 192;
195 -> 1;
195 -> 2;
195 -> 194;
196 -> 1;
197 -> 1;
198 -> 197;
198 -> 1;
199 -> 1;
200 -> 198;
200 -> 199;
201 -> 200;
201 -> 199;
202 -> 199;
203 -> 201;
203 -> 202;
204 -> 202;
205 -> 203;
205 -> 204;
205 -> 202;
206 -> 202;
206 -> 1;
207 -> 1;
208 -> 1;
209 -> 206;
209 -> 208;
210 -> 207;
210 -> 208;
211 -> 207;
211 -> 208;
212 -> 207;
212 -> 208;
213 -> 207;
213 -> 208;
214 -> 207;
214 -> 208;
215 -> 207;
215 -> 208;
216 -> 207;
216 -> 208;
217 -> 209;
217 -> 208;
218 -> 213;
218 -> 208;
219 -> 210;
219 -> 208;
220 -> 208;
221 -> 218;
221 -> 220;
222 -> 219;
222 -> 220;
223 -> 221;
223 -> 220;
224 -> 220;
225 -> 223;
225 -> 224;
226 -> 225;
226 -> 224;
227 -> 226;
228 -> 0;
228 -> 227;
229 -> 228;
230 -> 229;
231 -> 229;
232 -> 0;
232 -> 231;
233 -> 232;
233 -> 230;
233 -> 229;
234 -> 233;
234 -> 227;
235 -> 220;
236 -> 222;
236 -> 235;
236 -> 220;
237 -> 234;
237 -> 236;
238 -> 211;
238 -> 208;
239 -> 212;
239 -> 208;
240 -> 214;
240 -> 208;
241 -> 215;
241 -> 208;
242 -> 216;
242 -> 208;
243 -> 208;
244 -> 217;
244 -> 243;
245 -> 237;
245 -> 243;
246 -> 238;
246 -> 243;
247 -> 239;
247 -> 243;
248 -> 240;
248 -> 243;
249 -> 241;
249 -> 243;
250 -> 242;
250 -> 243;
251 -> 244;
251 -> 243;
252 -> 245;
252 -> 243;
253 -> 246;
253 -> 243;
254 -> 247;
254 -> 243;
255 -> 248;
255 -> 243;
256 -> 249;
256 -> 243;
257 -> 250;
257 -> 243;
258 -> 243;
259 -> 258;
259 -> 243;
260 -> 243;
261 -> 251;
261 -> 260;
262 -> 252;
262 -> 260;
263 -> 253;
263 -> 260;
264 -> 254;
264 -> 260;
265 -> 255;
265 -> 260;
266 -> 256;
266 -> 260;
267 -> 257;
267 -> 260;
268 -> 259;
268 -> 260;
269 -> 264;
269 -> 260;
270 -> 266;
270 -> 260;
271 -> 260;
272 -> 269;
272 -> 271;
273 -> 270;
273 -> 271;
274 -> 261;
274 -> 271;
275 -> 274;
275 -> 205;
275 -> 271;
276 -> 275;
277 -> 273;
277 -> 275;
278 -> 272;
278 -> 275;
279 -> 275;
280 -> 276;
280 -> 279;
281 -> 277;
281 -> 279;
282 -> 278;
282 -> 279;
283 -> 276;
283 -> 279;
284 -> 279;
285 -> 282;
285 -> 284;
285 -> 279;
286 -> 0;
287 -> 0;
289 -> 286;
289 -> 287;
289 -> 288;
290 -> 289;
291 -> 0;
292 -> 290;
292 -> 289;
292 -> 291;
293 -> 292;
294 -> 0;
295 -> 290;
295 -> 289;
295 -> 294;
296 -> 295;
297 -> 0;
298 -> 290;
298 -> 289;
298 -> 297;
299 -> 298;
300 -> 0;
301 -> 290;
301 -> 289;
301 -> 300;
302 -> 301;
303 -> 0;
304 -> 290;
304 -> 289;
304 -> 303;
305 -> 304;
306 -> 0;
307 -> 290;
307 -> 289;
307 -> 306;
308 -> 307;
309 -> 0;
310 -> 290;
310 -> 289;
310 -> 309;
311 -> 310;
312 -> 0;
313 -> 290;
313 -> 289;
313 -> 312;
314 -> 313;
315 -> 0;
316 -> 290;
316 -> 289;
316 -> 315;
317 -> 316;
318 -> 0;
319 -> 290;
319 -> 289;
319 -> 318;
320 -> 319;
321 -> 0;
322 -> 290;
322 -> 289;
322 -> 321;
323 -> 322;
324 -> 290;
327 -> 324;
327 -> 326;
328 -> 325;
328 -> 326;
329 -> 326;
330 -> 327;
330 -> 289;
330 -> 326;
331 -> 326;
332 -> 328;
332 -> 326;
333 -> 329;
333 -> 326;
334 -> 332;
334 -> 333;
334 -> 326;
335 -> 334;
335 -> 331;
335 -> 326;
336 -> 330;
336 -> 331;
336 -> 289;
336 -> 335;
336 -> 334;
336 -> 326;
337 -> 336;
338 -> 0;
339 -> 338;
341 -> 339;
341 -> 340;
342 -> 290;
342 -> 289;
342 -> 341;
343 -> 342;
344 -> 0;
345 -> 344;
346 -> 290;
346 -> 289;
346 -> 345;
347 -> 346;
348 -> 0;
349 -> 290;
349 -> 289;
349 -> 348;
350 -> 349;
351 -> 314;
353 -> 352;
354 -> 0;
355 -> 0;
356 -> 0;
358 -> 354;
358 -> 355;
358 -> 356;
358 -> 357;
359 -> 353;
360 -> 358;
360 -> 359;
360 -> 352;
361 -> 360;
365 -> 362;
365 -> 363;
365 -> 364;
366 -> 296;
366 -> 289;
366 -> 295;
366 -> 362;
366 -> 365;
367 -> 366;
368 -> 308;
369 -> 317;
370 -> 317;
371 -> 314;
372 -> 0;
373 -> 0;
375 -> 372;
375 -> 374;
376 -> 373;
376 -> 374;
377 -> 374;
378 -> 375;
378 -> 374;
379 -> 376;
379 -> 374;
380 -> 0;
380 -> 374;
381 -> 377;
381 -> 374;
382 -> 374;
383 -> 378;
383 -> 379;
383 -> 380;
383 -> 381;
383 -> 382;
383 -> 374;
384 -> 383;
385 -> 0;
386 -> 0;
388 -> 385;
388 -> 387;
389 -> 386;
389 -> 387;
390 -> 387;
391 -> 388;
391 -> 387;
392 -> 389;
392 -> 387;
393 -> 0;
393 -> 387;
394 -> 390;
394 -> 387;
395 -> 387;
396 -> 391;
396 -> 392;
396 -> 393;
396 -> 394;
396 -> 395;
396 -> 387;
397 -> 396;
399 -> 384;
399 -> 383;
399 -> 398;
400 -> 399;
402 -> 397;
402 -> 396;
402 -> 401;
403 -> 402;
404 -> 0;
405 -> 0;
407 -> 404;
407 -> 406;
408 -> 405;
408 -> 406;
409 -> 406;
410 -> 407;
410 -> 406;
411 -> 408;
411 -> 406;
412 -> 0;
412 -> 406;
413 -> 409;
413 -> 406;
414 -> 406;
415 -> 410;
415 -> 411;
415 -> 412;
415 -> 413;
415 -> 414;
415 -> 406;
416 -> 415;
417 -> 0;
418 -> 0;
420 -> 417;
420 -> 419;
421 -> 418;
421 -> 419;
422 -> 419;
423 -> 420;
423 -> 419;
424 -> 421;
424 -> 419;
425 -> 0;
425 -> 419;
426 -> 422;
426 -> 419;
427 -> 419;
428 -> 423;
428 -> 424;
428 -> 425;
428 -> 426;
428 -> 427;
428 -> 419;
429 -> 428;
430 -> 0;
431 -> 0;
433 -> 430;
433 -> 432;
434 -> 431;
434 -> 432;
435 -> 432;
436 -> 433;
436 -> 432;
437 -> 434;
437 -> 432;
438 -> 0;
438 -> 432;
439 -> 435;
439 -> 432;
440 -> 432;
441 -> 436;
441 -> 437;
441 -> 438;
441 -> 439;
441 -> 440;
441 -> 432;
442 -> 441;
443 -> 0;
444 -> 0;
446 -> 443;
446 -> 445;
447 -> 444;
447 -> 445;
448 -> 445;
449 -> 446;
449 -> 445;
450 -> 447;
450 -> 445;
451 -> 0;
451 -> 445;
452 -> 448;
452 -> 445;
453 -> 445;
454 -> 449;
454 -> 450;
454 -> 451;
454 -> 452;
454 -> 453;
454 -> 445;
455 -> 454;
456 -> 0;
457 -> 0;
459 -> 456;
459 -> 458;
460 -> 457;
460 -> 458;
461 -> 458;
462 -> 459;
462 -> 458;
463 -> 460;
463 -> 458;
464 -> 0;
464 -> 458;
465 -> 461;
465 -> 458;
466 -> 458;
467 -> 462;
467 -> 463;
467 -> 464;
467 -> 465;
467 -> 466;
467 -> 458;
468 -> 467;
469 -> 0;
470 -> 0;
472 -> 469;
472 -> 471;
473 -> 470;
473 -> 471;
474 -> 471;
475 -> 472;
475 -> 471;
476 -> 473;
476 -> 471;
477 -> 0;
477 -> 471;
478 -> 474;
478 -> 471;
479 -> 471;
480 -> 475;
480 -> 476;
480 -> 477;
480 -> 478;
480 -> 479;
480 -> 471;
481 -> 480;
483 -> 384;
483 -> 383;
483 -> 482;
484 -> 483;
486 -> 397;
486 -> 396;
486 -> 485;
487 -> 486;
489 -> 416;
489 -> 415;
489 -> 488;
490 -> 489;
492 -> 429;
492 -> 428;
492 -> 491;
493 -> 492;
494 -> 0;
495 -> 384;
495 -> 383;
495 -> 494;
495 -> 0;
496 -> 495;
497 -> 0;
498 -> 397;
498 -> 396;
498 -> 497;
498 -> 0;
499 -> 498;
500 -> 0;
501 -> 468;
501 -> 467;
501 -> 500;
501 -> 0;
502 -> 501;
503 -> 0;
504 -> 416;
504 -> 415;
504 -> 503;
504 -> 0;
505 -> 504;
506 -> 0;
507 -> 0;
507 -> 506;
508 -> 507;
509 -> 290;
509 -> 285;
510 -> 280;
510 -> 279;
511 -> 0;
511 -> 279;
512 -> 511;
512 -> 283;
512 -> 279;
513 -> 279;
514 -> 510;
514 -> 512;
514 -> 513;
514 -> 0;
514 -> 279;
515 -> 514;
515 -> 279;
516 -> 509;
516 -> 279;
517 -> 281;
517 -> 279;
518 -> 279;
519 -> 515;
519 -> 516;
519 -> 517;
519 -> 518;
519 -> 514;
519 -> 289;
519 -> 279;
520 -> 279;
521 -> 519;
521 -> 520;
522 -> 520;
523 -> 520;
524 -> 521;
524 -> 519;
524 -> 523;
524 -> 520;
525 -> 522;
525 -> 520;
526 -> 520;
527 -> 524;
527 -> 519;
527 -> 523;
527 -> 525;
527 -> 526;
527 -> 522;
527 -> 520;
528 -> 520;
529 -> 528;
529 -> 522;
529 -> 520;
530 -> 522;
530 -> 520;
531 -> 520;
532 -> 530;
532 -> 531;
532 -> 522;
532 -> 529;
532 -> 520;
533 -> 521;
533 -> 520;
534 -> 533;
534 -> 276;
534 -> 275;
535 -> 276;
535 -> 260;
536 -> 260;
537 -> 263;
537 -> 536;
537 -> 260;
538 -> 535;
538 -> 537;
539 -> 537;
540 -> 538;
540 -> 539;
540 -> 276;
540 -> 534;
540 -> 519;
540 -> 537;
541 -> 540;
541 -> 537;
542 -> 384;
542 -> 541;
543 -> 0;
543 -> 260;
544 -> 268;
544 -> 260;
545 -> 265;
545 -> 535;
545 -> 262;
545 -> 542;
545 -> 260;
546 -> 545;
546 -> 260;
547 -> 260;
548 -> 546;
548 -> 547;
549 -> 0;
549 -> 547;
550 -> 549;
551 -> 260;
552 -> 545;
552 -> 276;
552 -> 534;
552 -> 519;
552 -> 233;
552 -> 0;
552 -> 383;
552 -> 230;
552 -> 260;
553 -> 260;
554 -> 553;
555 -> 552;
555 -> 554;
555 -> 260;
556 -> 0;
558 -> 556;
558 -> 557;
559 -> 558;
560 -> 0;
562 -> 560;
562 -> 561;
564 -> 562;
564 -> 563;
565 -> 564;
566 -> 552;
566 -> 553;
567 -> 552;
567 -> 553;
568 -> 552;
568 -> 553;
569 -> 552;
569 -> 553;
570 -> 566;
570 -> 553;
571 -> 569;
571 -> 553;
572 -> 567;
572 -> 553;
573 -> 568;
573 -> 553;
574 -> 553;
575 -> 553;
576 -> 570;
576 -> 575;
577 -> 571;
577 -> 575;
578 -> 572;
578 -> 575;
579 -> 573;
579 -> 575;
580 -> 574;
580 -> 575;
581 -> 574;
581 -> 575;
582 -> 574;
582 -> 575;
583 -> 574;
583 -> 575;
584 -> 575;
585 -> 577;
585 -> 584;
585 -> 575;
586 -> 583;
586 -> 575;
587 -> 579;
587 -> 575;
588 -> 587;
588 -> 555;
588 -> 575;
589 -> 576;
589 -> 575;
590 -> 577;
590 -> 575;
591 -> 588;
591 -> 575;
592 -> 580;
592 -> 575;
593 -> 581;
593 -> 575;
594 -> 582;
594 -> 575;
595 -> 583;
595 -> 575;
596 -> 575;
597 -> 0;
597 -> 575;
598 -> 577;
598 -> 588;
598 -> 575;
599 -> 597;
599 -> 598;
599 -> 595;
599 -> 596;
599 -> 0;
599 -> 588;
599 -> 575;
600 -> 575;
601 -> 589;
601 -> 600;
602 -> 590;
602 -> 600;
603 -> 591;
603 -> 600;
604 -> 592;
604 -> 600;
605 -> 593;
605 -> 600;
606 -> 594;
606 -> 600;
607 -> 595;
607 -> 600;
608 -> 596;
608 -> 600;
609 -> 596;
609 -> 600;
610 -> 599;
610 -> 600;
611 -> 596;
611 -> 600;
612 -> 596;
612 -> 600;
613 -> 596;
613 -> 600;
614 -> 601;
614 -> 600;
615 -> 602;
615 -> 600;
616 -> 603;
616 -> 600;
617 -> 604;
617 -> 600;
618 -> 605;
618 -> 600;
619 -> 606;
619 -> 600;
620 -> 607;
620 -> 600;
621 -> 608;
621 -> 600;
622 -> 609;
622 -> 600;
623 -> 610;
623 -> 600;
624 -> 610;
624 -> 599;
624 -> 600;
625 -> 624;
625 -> 599;
625 -> 600;
626 -> 611;
626 -> 600;
627 -> 612;
627 -> 600;
628 -> 600;
629 -> 614;
629 -> 628;
630 -> 615;
630 -> 628;
631 -> 616;
631 -> 628;
632 -> 617;
632 -> 628;
633 -> 618;
633 -> 628;
634 -> 619;
634 -> 628;
635 -> 620;
635 -> 628;
636 -> 621;
636 -> 628;
637 -> 622;
637 -> 628;
638 -> 623;
638 -> 628;
639 -> 625;
639 -> 628;
640 -> 626;
640 -> 628;
641 -> 627;
641 -> 628;
642 -> 613;
642 -> 628;
643 -> 629;
643 -> 628;
644 -> 631;
644 -> 628;
645 -> 639;
645 -> 628;
646 -> 635;
646 -> 628;
647 -> 640;
647 -> 628;
648 -> 641;
648 -> 628;
649 -> 628;
650 -> 649;
650 -> 643;
650 -> 644;
650 -> 645;
650 -> 646;
650 -> 647;
650 -> 648;
650 -> 588;
650 -> 625;
650 -> 628;
651 -> 649;
651 -> 628;
652 -> 649;
652 -> 628;
653 -> 649;
653 -> 628;
654 -> 649;
654 -> 628;
655 -> 649;
655 -> 628;
656 -> 649;
656 -> 628;
657 -> 649;
657 -> 628;
658 -> 649;
658 -> 628;
659 -> 649;
659 -> 628;
660 -> 649;
660 -> 628;
661 -> 649;
661 -> 628;
662 -> 649;
662 -> 628;
663 -> 649;
663 -> 628;
664 -> 649;
664 -> 628;
665 -> 649;
665 -> 628;
666 -> 649;
666 -> 628;
667 -> 649;
667 -> 628;
668 -> 649;
668 -> 628;
669 -> 649;
669 -> 628;
670 -> 649;
670 -> 628;
671 -> 649;
671 -> 628;
672 -> 649;
672 -> 628;
673 -> 649;
673 -> 628;
674 -> 649;
674 -> 628;
675 -> 649;
675 -> 628;
676 -> 649;
676 -> 628;
677 -> 628;
678 -> 677;
678 -> 649;
678 -> 628;
679 -> 649;
679 -> 628;
680 -> 649;
680 -> 628;
681 -> 649;
681 -> 628;
682 -> 649;
682 -> 628;
683 -> 649;
683 -> 628;
684 -> 649;
684 -> 628;
685 -> 649;
685 -> 628;
686 -> 628;
687 -> 628;
688 -> 685;
688 -> 687;
689 -> 686;
689 -> 687;
691 -> 690;
692 -> 690;
693 -> 687;
694 -> 689;
694 -> 693;
695 -> 693;
696 -> 689;
696 -> 687;
697 -> 688;
697 -> 689;
697 -> 687;
698 -> 686;
698 -> 649;
698 -> 628;
699 -> 630;
699 -> 649;
699 -> 628;
700 -> 649;
700 -> 628;
701 -> 700;
701 -> 650;
701 -> 651;
701 -> 699;
701 -> 652;
701 -> 653;
701 -> 654;
701 -> 655;
701 -> 656;
701 -> 657;
701 -> 658;
701 -> 659;
701 -> 660;
701 -> 661;
701 -> 662;
701 -> 663;
701 -> 664;
701 -> 665;
701 -> 666;
701 -> 667;
701 -> 668;
701 -> 669;
701 -> 670;
701 -> 671;
701 -> 672;
701 -> 673;
701 -> 674;
701 -> 675;
701 -> 676;
701 -> 678;
701 -> 679;
701 -> 698;
701 -> 680;
701 -> 681;
701 -> 682;
701 -> 683;
701 -> 684;
701 -> 677;
701 -> 695;
701 -> 696;
701 -> 697;
701 -> 628;
702 -> 701;
702 -> 649;
702 -> 628;
703 -> 649;
703 -> 701;
703 -> 628;
704 -> 703;
704 -> 701;
704 -> 702;
704 -> 628;
705 -> 704;
705 -> 649;
705 -> 628;
706 -> 649;
706 -> 704;
706 -> 628;
707 -> 706;
707 -> 704;
707 -> 705;
707 -> 628;
708 -> 707;
708 -> 649;
708 -> 628;
709 -> 649;
709 -> 707;
709 -> 628;
710 -> 709;
710 -> 707;
710 -> 708;
710 -> 628;
711 -> 710;
711 -> 649;
711 -> 628;
712 -> 649;
712 -> 710;
712 -> 628;
713 -> 712;
713 -> 710;
713 -> 711;
713 -> 628;
714 -> 713;
714 -> 649;
714 -> 628;
715 -> 649;
715 -> 628;
716 -> 628;
717 -> 628;
718 -> 715;
718 -> 717;
719 -> 716;
719 -> 717;
720 -> 717;
721 -> 720;
721 -> 717;
722 -> 720;
722 -> 717;
723 -> 720;
723 -> 717;
724 -> 717;
725 -> 724;
725 -> 720;
725 -> 717;
726 -> 717;
727 -> 718;
727 -> 726;
727 -> 717;
728 -> 718;
728 -> 720;
728 -> 717;
729 -> 716;
729 -> 649;
729 -> 628;
730 -> 638;
730 -> 713;
730 -> 628;
731 -> 628;
732 -> 730;
732 -> 731;
733 -> 731;
734 -> 732;
734 -> 731;
735 -> 734;
735 -> 713;
735 -> 714;
735 -> 729;
735 -> 731;
736 -> 0;
736 -> 731;
737 -> 736;
737 -> 733;
737 -> 731;
738 -> 737;
738 -> 628;
739 -> 738;
739 -> 649;
739 -> 628;
740 -> 635;
740 -> 628;
741 -> 740;
742 -> 632;
742 -> 741;
742 -> 740;
743 -> 633;
743 -> 741;
743 -> 740;
744 -> 742;
744 -> 743;
744 -> 740;
745 -> 634;
745 -> 741;
745 -> 740;
746 -> 744;
746 -> 745;
746 -> 740;
747 -> 637;
747 -> 628;
748 -> 649;
748 -> 713;
748 -> 714;
748 -> 729;
748 -> 739;
748 -> 720;
748 -> 721;
748 -> 728;
748 -> 722;
748 -> 723;
748 -> 725;
748 -> 724;
748 -> 747;
749 -> 747;
750 -> 649;
750 -> 749;
751 -> 750;
751 -> 748;
751 -> 749;
752 -> 636;
752 -> 747;
753 -> 747;
754 -> 747;
755 -> 748;
755 -> 754;
756 -> 751;
756 -> 754;
757 -> 752;
757 -> 754;
758 -> 753;
758 -> 754;
759 -> 755;
759 -> 754;
760 -> 756;
760 -> 754;
761 -> 757;
761 -> 754;
762 -> 754;
763 -> 762;
763 -> 759;
763 -> 760;
763 -> 761;
763 -> 748;
763 -> 754;
764 -> 753;
764 -> 649;
764 -> 747;
765 -> 638;
765 -> 649;
765 -> 628;
766 -> 649;
766 -> 763;
766 -> 628;
767 -> 628;
768 -> 649;
768 -> 763;
768 -> 767;
768 -> 628;
769 -> 575;
770 -> 578;
770 -> 769;
770 -> 575;
771 -> 578;
771 -> 770;
772 -> 770;
773 -> 771;
773 -> 772;
774 -> 596;
774 -> 772;
775 -> 772;
776 -> 773;
776 -> 775;
776 -> 772;
777 -> 773;
777 -> 772;
778 -> 777;
778 -> 763;
778 -> 764;
778 -> 765;
778 -> 772;
779 -> 772;
780 -> 774;
780 -> 778;
780 -> 772;
781 -> 779;
781 -> 772;
782 -> 780;
782 -> 778;
782 -> 772;
783 -> 781;
783 -> 782;
783 -> 779;
783 -> 778;
783 -> 772;
784 -> 772;
785 -> 772;
786 -> 773;
786 -> 772;
787 -> 786;
787 -> 783;
787 -> 772;
788 -> 787;
789 -> 787;
790 -> 787;
791 -> 774;
791 -> 790;
791 -> 787;
792 -> 787;
793 -> 779;
793 -> 792;
793 -> 790;
793 -> 787;
794 -> 784;
794 -> 787;
794 -> 793;
795 -> 785;
795 -> 787;
796 -> 779;
796 -> 793;
796 -> 772;
797 -> 774;
797 -> 796;
797 -> 772;
798 -> 773;
798 -> 772;
799 -> 780;
799 -> 798;
799 -> 796;
799 -> 772;
800 -> 774;
800 -> 799;
800 -> 772;
801 -> 794;
801 -> 772;
802 -> 799;
802 -> 772;
803 -> 772;
804 -> 800;
804 -> 803;
805 -> 801;
805 -> 803;
806 -> 802;
806 -> 803;
807 -> 774;
807 -> 803;
808 -> 807;
808 -> 799;
808 -> 803;
809 -> 803;
810 -> 807;
810 -> 809;
811 -> 810;
811 -> 799;
811 -> 809;
812 -> 811;
812 -> 809;
813 -> 812;
813 -> 803;
814 -> 803;
815 -> 808;
815 -> 814;
816 -> 815;
816 -> 808;
816 -> 814;
817 -> 803;
818 -> 816;
818 -> 817;
819 -> 804;
819 -> 803;
820 -> 805;
820 -> 803;
821 -> 806;
821 -> 803;
822 -> 803;
823 -> 803;
824 -> 808;
824 -> 823;
825 -> 808;
825 -> 823;
826 -> 808;
826 -> 823;
827 -> 813;
827 -> 823;
828 -> 816;
828 -> 823;
829 -> 818;
829 -> 823;
830 -> 818;
830 -> 823;
831 -> 819;
831 -> 823;
832 -> 820;
832 -> 823;
833 -> 821;
833 -> 823;
834 -> 818;
834 -> 823;
835 -> 822;
835 -> 823;
836 -> 822;
836 -> 823;
837 -> 827;
837 -> 823;
838 -> 828;
838 -> 823;
839 -> 829;
839 -> 823;
840 -> 833;
840 -> 818;
840 -> 823;
841 -> 835;
841 -> 823;
842 -> 823;
843 -> 837;
843 -> 842;
844 -> 838;
844 -> 842;
845 -> 839;
845 -> 842;
846 -> 841;
846 -> 842;
847 -> 836;
847 -> 842;
848 -> 846;
848 -> 842;
849 -> 842;
850 -> 849;
850 -> 842;
851 -> 849;
851 -> 842;
852 -> 849;
852 -> 842;
853 -> 849;
853 -> 842;
854 -> 849;
854 -> 842;
855 -> 849;
855 -> 842;
856 -> 849;
856 -> 842;
857 -> 849;
857 -> 842;
858 -> 849;
858 -> 842;
859 -> 849;
859 -> 842;
860 -> 849;
860 -> 842;
861 -> 849;
861 -> 842;
862 -> 849;
862 -> 842;
863 -> 849;
863 -> 842;
864 -> 849;
864 -> 842;
865 -> 849;
865 -> 842;
866 -> 849;
866 -> 842;
867 -> 849;
867 -> 842;
868 -> 849;
868 -> 842;
869 -> 849;
869 -> 842;
870 -> 849;
870 -> 842;
871 -> 849;
871 -> 842;
872 -> 849;
872 -> 842;
873 -> 849;
873 -> 842;
874 -> 849;
874 -> 842;
875 -> 849;
875 -> 842;
876 -> 842;
877 -> 876;
877 -> 849;
877 -> 842;
878 -> 849;
878 -> 842;
879 -> 849;
879 -> 842;
880 -> 849;
880 -> 842;
881 -> 849;
881 -> 842;
882 -> 849;
882 -> 842;
883 -> 849;
883 -> 842;
884 -> 849;
884 -> 842;
885 -> 842;
886 -> 842;
887 -> 884;
887 -> 886;
888 -> 885;
888 -> 886;
889 -> 886;
890 -> 888;
890 -> 889;
891 -> 889;
892 -> 888;
892 -> 886;
893 -> 887;
893 -> 888;
893 -> 886;
894 -> 885;
894 -> 849;
894 -> 842;
895 -> 849;
895 -> 842;
896 -> 849;
896 -> 842;
897 -> 842;
898 -> 842;
899 -> 896;
899 -> 898;
900 -> 897;
900 -> 898;
901 -> 898;
902 -> 901;
902 -> 898;
903 -> 901;
903 -> 898;
904 -> 901;
904 -> 898;
905 -> 898;
906 -> 905;
906 -> 901;
906 -> 898;
907 -> 898;
908 -> 899;
908 -> 907;
908 -> 898;
909 -> 899;
909 -> 901;
909 -> 898;
910 -> 897;
910 -> 849;
910 -> 842;
911 -> 842;
912 -> 840;
912 -> 911;
913 -> 911;
914 -> 912;
914 -> 911;
915 -> 914;
915 -> 840;
915 -> 910;
915 -> 901;
915 -> 902;
915 -> 909;
915 -> 903;
915 -> 904;
915 -> 906;
915 -> 905;
916 -> 914;
917 -> 915;
917 -> 916;
918 -> 830;
918 -> 842;
919 -> 918;
920 -> 843;
920 -> 919;
920 -> 918;
921 -> 844;
921 -> 919;
921 -> 918;
922 -> 920;
922 -> 921;
922 -> 918;
923 -> 845;
923 -> 919;
923 -> 918;
924 -> 922;
924 -> 923;
924 -> 918;
925 -> 831;
925 -> 832;
926 -> 849;
926 -> 832;
927 -> 831;
927 -> 926;
927 -> 840;
927 -> 910;
927 -> 917;
927 -> 901;
927 -> 902;
927 -> 909;
927 -> 903;
927 -> 904;
927 -> 906;
927 -> 905;
927 -> 832;
928 -> 831;
928 -> 849;
928 -> 832;
929 -> 849;
929 -> 927;
929 -> 842;
930 -> 842;
931 -> 849;
931 -> 927;
931 -> 930;
931 -> 842;
932 -> 822;
932 -> 772;
933 -> 932;
933 -> 770;
934 -> 933;
934 -> 927;
934 -> 575;
935 -> 933;
935 -> 575;
936 -> 552;
936 -> 935;
936 -> 927;
936 -> 928;
936 -> 833;
936 -> 260;
937 -> 936;
937 -> 260;
938 -> 260;
939 -> 937;
939 -> 938;
940 -> 938;
941 -> 939;
941 -> 940;
942 -> 941;
942 -> 936;
942 -> 940;
943 -> 942;
943 -> 938;
944 -> 943;
944 -> 942;
944 -> 938;
945 -> 938;
946 -> 943;
946 -> 945;
946 -> 942;
946 -> 938;
947 -> 0;
947 -> 938;
948 -> 946;
948 -> 947;
948 -> 938;
949 -> 267;
949 -> 948;
949 -> 260;
950 -> 936;
950 -> 260;
951 -> 1;
952 -> 950;
952 -> 951;
953 -> 952;
953 -> 948;
953 -> 951;
954 -> 953;
955 -> 954;
955 -> 953;
956 -> 953;
957 -> 955;
957 -> 956;
958 -> 952;
958 -> 956;
959 -> 956;
960 -> 958;
960 -> 959;
961 -> 959;
962 -> 960;
962 -> 961;
963 -> 961;
964 -> 962;
964 -> 963;
965 -> 964;
965 -> 948;
965 -> 963;
966 -> 964;
966 -> 965;
967 -> 965;
968 -> 966;
968 -> 967;
969 -> 964;
969 -> 948;
969 -> 967;
970 -> 968;
970 -> 967;
971 -> 967;
972 -> 970;
972 -> 971;
973 -> 969;
973 -> 971;
974 -> 971;
975 -> 971;
976 -> 971;
977 -> 972;
977 -> 976;
978 -> 977;
978 -> 971;
979 -> 971;
980 -> 971;
981 -> 980;
981 -> 971;
982 -> 971;
983 -> 982;
983 -> 971;
984 -> 971;
985 -> 984;
985 -> 971;
986 -> 971;
987 -> 986;
987 -> 971;
988 -> 972;
988 -> 971;
989 -> 975;
989 -> 971;
990 -> 986;
990 -> 971;
991 -> 979;
991 -> 971;
992 -> 980;
992 -> 971;
993 -> 982;
993 -> 971;
994 -> 984;
994 -> 971;
995 -> 974;
995 -> 971;
996 -> 988;
996 -> 989;
996 -> 990;
996 -> 991;
996 -> 992;
996 -> 993;
996 -> 994;
996 -> 995;
996 -> 973;
996 -> 948;
996 -> 975;
996 -> 974;
996 -> 987;
996 -> 981;
996 -> 983;
996 -> 985;
996 -> 971;
997 -> 971;
998 -> 996;
998 -> 997;
999 -> 997;
1000 -> 998;
1000 -> 999;
1001 -> 1000;
1001 -> 996;
1001 -> 999;
1002 -> 1001;
1002 -> 997;
1003 -> 0;
1004 -> 0;
1004 -> 1003;
1005 -> 0;
1006 -> 1004;
1006 -> 0;
1006 -> 1005;
1007 -> 1006;
1008 -> 997;
1009 -> 1002;
1009 -> 1008;
1010 -> 1002;
1010 -> 1008;
1011 -> 1008;
1012 -> 1009;
1012 -> 1002;
1012 -> 1011;
1012 -> 1008;
1013 -> 1002;
1013 -> 1008;
1014 -> 1002;
1014 -> 1008;
1015 -> 0;
1015 -> 1008;
1016 -> 1008;
1017 -> 1008;
1018 -> 1013;
1018 -> 1008;
1019 -> 1018;
1020 -> 1018;
1021 -> 1019;
1021 -> 1020;
1022 -> 1021;
1022 -> 1020;
1023 -> 0;
1023 -> 1022;
1024 -> 1018;
1025 -> 1023;
1025 -> 1018;
1026 -> 1015;
1026 -> 1018;
1027 -> 1016;
1027 -> 1018;
1028 -> 1017;
1028 -> 1018;
1029 -> 1014;
1029 -> 1018;
1030 -> 1018;
1031 -> 1024;
1031 -> 1030;
1032 -> 1025;
1032 -> 1030;
1033 -> 1026;
1033 -> 1030;
1034 -> 1027;
1034 -> 1030;
1035 -> 1028;
1035 -> 1030;
1036 -> 1029;
1036 -> 1030;
1037 -> 1033;
1037 -> 1032;
1037 -> 1030;
1038 -> 1030;
1039 -> 1015;
1039 -> 1023;
1039 -> 1018;
1040 -> 1039;
1040 -> 0;
1040 -> 1008;
1041 -> 1039;
1041 -> 1008;
1042 -> 996;
1042 -> 997;
1043 -> 1042;
1043 -> 1041;
1043 -> 997;
1044 -> 996;
1044 -> 997;
1045 -> 0;
1045 -> 997;
1046 -> 996;
1046 -> 1045;
1046 -> 1043;
1046 -> 971;
1047 -> 996;
1047 -> 997;
1048 -> 996;
1048 -> 997;
1049 -> 996;
1049 -> 997;
1050 -> 996;
1050 -> 997;
1051 -> 996;
1051 -> 997;
1052 -> 996;
1052 -> 997;
1053 -> 996;
1053 -> 997;
1054 -> 1047;
1054 -> 997;
1055 -> 1048;
1055 -> 997;
1056 -> 1052;
1056 -> 997;
1057 -> 1049;
1057 -> 997;
1058 -> 1050;
1058 -> 997;
1059 -> 1051;
1059 -> 997;
1060 -> 997;
1061 -> 997;
1062 -> 1054;
1062 -> 1061;
1063 -> 1055;
1063 -> 1061;
1064 -> 1056;
1064 -> 1061;
1065 -> 1057;
1065 -> 1061;
1066 -> 1058;
1066 -> 1061;
1067 -> 1059;
1067 -> 1061;
1068 -> 1060;
1068 -> 1061;
1069 -> 1062;
1069 -> 1046;
1069 -> 1061;
1070 -> 1062;
1070 -> 1046;
1070 -> 1061;
1071 -> 1064;
1071 -> 1061;
1072 -> 1061;
1073 -> 1069;
1073 -> 1072;
1074 -> 1070;
1074 -> 1072;
1075 -> 1071;
1075 -> 1072;
1076 -> 1068;
1076 -> 1072;
1077 -> 1072;
1078 -> 1077;
1078 -> 1072;
1079 -> 1077;
1079 -> 1072;
1080 -> 1077;
1080 -> 1072;
1081 -> 1072;
1082 -> 1073;
1082 -> 1081;
1082 -> 1072;
1083 -> 1074;
1083 -> 1046;
1083 -> 1072;
1084 -> 1075;
1084 -> 1077;
1084 -> 1072;
1085 -> 1073;
1085 -> 1077;
1085 -> 1072;
1086 -> 1074;
1086 -> 1077;
1086 -> 1072;
1087 -> 1068;
1087 -> 1061;
1088 -> 1068;
1088 -> 1061;
1089 -> 1068;
1089 -> 1061;
1090 -> 1068;
1090 -> 1061;
1091 -> 1068;
1091 -> 1061;
1092 -> 1068;
1092 -> 1061;
1093 -> 1068;
1093 -> 1061;
1094 -> 1061;
1095 -> 1065;
1095 -> 1094;
1095 -> 1061;
1096 -> 1061;
1097 -> 1063;
1097 -> 1096;
1097 -> 1061;
1098 -> 1063;
1098 -> 1068;
1098 -> 1061;
1099 -> 1062;
1099 -> 1068;
1099 -> 1061;
1100 -> 1065;
1100 -> 1068;
1100 -> 1061;
1101 -> 1067;
1101 -> 1068;
1101 -> 1061;
1102 -> 1066;
1102 -> 1068;
1102 -> 1061;
1103 -> 996;
1103 -> 1060;
1103 -> 1046;
1103 -> 1077;
1103 -> 1078;
1103 -> 1079;
1103 -> 1085;
1103 -> 1080;
1103 -> 1084;
1103 -> 1086;
1103 -> 1087;
1103 -> 1099;
1103 -> 1088;
1103 -> 1098;
1103 -> 1089;
1103 -> 1100;
1103 -> 1090;
1103 -> 1101;
1103 -> 1091;
1103 -> 1102;
1103 -> 1092;
1103 -> 1093;
1103 -> 971;
1104 -> 1103;
1104 -> 1081;
1104 -> 1072;
1105 -> 1103;
1105 -> 1072;
1106 -> 973;
1106 -> 1103;
1106 -> 971;
1107 -> 971;
1108 -> 1103;
1108 -> 971;
1109 -> 1106;
1109 -> 1107;
1110 -> 1109;
1110 -> 1106;
1110 -> 1107;
1111 -> 971;
1112 -> 1110;
1112 -> 971;
1113 -> 971;
1114 -> 971;
1115 -> 971;
1116 -> 1115;
1116 -> 971;
1117 -> 971;
1118 -> 1117;
1118 -> 971;
1119 -> 971;
1120 -> 1119;
1120 -> 971;
1121 -> 972;
1121 -> 1112;
1121 -> 971;
1122 -> 971;
1123 -> 1121;
1123 -> 1122;
1123 -> 971;
1124 -> 1123;
1124 -> 971;
1125 -> 971;
1126 -> 1124;
1126 -> 1125;
1126 -> 971;
1127 -> 1126;
1127 -> 971;
1128 -> 971;
1129 -> 1127;
1129 -> 1128;
1129 -> 971;
1130 -> 1129;
1130 -> 971;
1131 -> 0;
1131 -> 971;
1132 -> 1131;
1132 -> 1130;
1132 -> 971;
1133 -> 972;
1133 -> 971;
1134 -> 1112;
1134 -> 971;
1135 -> 1103;
1135 -> 971;
1136 -> 971;
1137 -> 972;
1137 -> 1136;
1138 -> 1137;
1138 -> 1112;
1138 -> 1136;
1139 -> 1138;
1139 -> 971;
1140 -> 971;
1141 -> 972;
1141 -> 1140;
1142 -> 1141;
1142 -> 1112;
1142 -> 1140;
1143 -> 1142;
1143 -> 971;
1144 -> 978;
1144 -> 971;
1145 -> 975;
1145 -> 971;
1146 -> 1119;
1146 -> 971;
1147 -> 1115;
1147 -> 971;
1148 -> 1117;
1148 -> 971;
1149 -> 1132;
1149 -> 971;
1150 -> 974;
1150 -> 971;
1151 -> 1113;
1151 -> 971;
1152 -> 1114;
1152 -> 971;
1153 -> 1133;
1153 -> 1134;
1153 -> 1135;
1153 -> 1139;
1153 -> 1143;
1153 -> 1144;
1153 -> 1145;
1153 -> 1146;
1153 -> 1147;
1153 -> 1148;
1153 -> 1149;
1153 -> 1150;
1153 -> 1151;
1153 -> 1152;
1153 -> 973;
1153 -> 1112;
1153 -> 1103;
1153 -> 1120;
1153 -> 1116;
1153 -> 1118;
1153 -> 0;
1153 -> 971;
1154 -> 971;
1155 -> 1153;
1155 -> 1154;
1156 -> 1153;
1156 -> 1154;
1157 -> 1153;
1157 -> 1154;
1158 -> 1157;
1158 -> 1153;
1158 -> 1154;
1159 -> 1155;
1159 -> 1154;
1160 -> 1154;
1161 -> 1156;
1161 -> 1154;
1162 -> 1158;
1162 -> 1159;
1162 -> 1160;
1162 -> 1161;
1162 -> 1153;
1162 -> 1154;
1163 -> 1153;
1163 -> 1154;
1164 -> 1163;
1164 -> 1162;
1164 -> 1154;
1165 -> 1153;
1165 -> 1154;
1166 -> 1165;
1166 -> 1164;
1166 -> 1154;
1167 -> 1153;
1167 -> 1154;
1168 -> 1167;
1168 -> 1166;
1168 -> 1154;
1169 -> 1153;
1169 -> 1154;
1170 -> 1169;
1170 -> 1168;
1170 -> 1154;
1171 -> 1153;
1171 -> 1154;
1172 -> 1154;
1173 -> 1171;
1173 -> 1170;
1173 -> 1172;
1173 -> 1154;
1174 -> 1173;
1175 -> 1174;
1175 -> 1171;
1175 -> 1173;
1176 -> 1171;
1176 -> 1170;
1176 -> 1175;
1176 -> 1173;
1177 -> 1173;
1178 -> 1176;
1178 -> 1177;
1179 -> 1171;
1179 -> 1177;
1180 -> 1179;
1180 -> 1170;
1180 -> 1177;
1181 -> 1180;
1181 -> 1170;
1181 -> 1175;
1181 -> 1177;
1182 -> 1173;
1183 -> 1171;
1183 -> 1170;
1183 -> 1175;
1183 -> 1154;
1184 -> 1171;
1184 -> 1183;
1185 -> 1183;
1186 -> 1184;
1186 -> 1185;
1187 -> 1171;
1187 -> 1185;
1188 -> 1187;
1188 -> 1183;
1188 -> 1185;
1189 -> 1183;
1190 -> 1183;
1190 -> 971;
1191 -> 1183;
1191 -> 971;
1192 -> 1183;
1192 -> 971;
1193 -> 1103;
1193 -> 1192;
1193 -> 1183;
1193 -> 1191;
1193 -> 971;
1194 -> 971;
1195 -> 971;
1196 -> 1195;
1196 -> 971;
1197 -> 1183;
1197 -> 971;
1198 -> 1191;
1198 -> 971;
1199 -> 1193;
1199 -> 971;
1200 -> 1103;
1200 -> 971;
1201 -> 1103;
1201 -> 1193;
1201 -> 971;
1202 -> 975;
1202 -> 971;
1203 -> 978;
1203 -> 971;
1204 -> 1194;
1204 -> 971;
1205 -> 1195;
1205 -> 971;
1206 -> 1197;
1206 -> 1198;
1206 -> 1199;
1206 -> 1200;
1206 -> 1201;
1206 -> 1202;
1206 -> 1203;
1206 -> 1204;
1206 -> 1205;
1206 -> 1193;
1206 -> 1191;
1206 -> 1196;
1206 -> 971;
1207 -> 971;
1208 -> 971;
1209 -> 1208;
1209 -> 1183;
1209 -> 1206;
1209 -> 971;
1210 -> 1183;
1210 -> 1206;
1210 -> 1208;
1210 -> 1209;
1211 -> 1210;
1211 -> 1206;
1211 -> 1209;
1212 -> 1183;
1212 -> 1208;
1212 -> 1206;
1212 -> 1211;
1213 -> 1211;
1214 -> 1212;
1214 -> 1213;
1215 -> 1214;
1215 -> 1212;
1215 -> 1213;
1216 -> 1213;
1217 -> 1214;
1217 -> 1216;
1218 -> 1217;
1218 -> 1213;
1219 -> 1213;
1220 -> 1214;
1220 -> 1219;
1221 -> 1219;
1222 -> 1220;
1222 -> 1221;
1223 -> 1222;
1223 -> 1212;
1223 -> 1221;
1224 -> 1222;
1224 -> 1212;
1224 -> 1223;
1225 -> 1224;
1225 -> 1222;
1225 -> 1223;
1226 -> 1223;
1227 -> 1226;
1227 -> 1222;
1227 -> 1223;
1228 -> 1222;
1228 -> 1224;
1228 -> 1225;
1228 -> 1221;
1229 -> 1228;
1229 -> 1219;
1230 -> 1220;
1230 -> 1224;
1230 -> 1219;
1231 -> 1230;
1231 -> 1213;
1232 -> 1213;
1233 -> 1213;
1234 -> 1215;
1234 -> 1233;
1235 -> 1215;
1235 -> 1233;
1236 -> 1218;
1236 -> 1233;
1237 -> 1231;
1237 -> 1233;
1238 -> 1232;
1238 -> 1233;
1239 -> 1233;
1240 -> 1238;
1240 -> 1239;
1241 -> 1239;
1242 -> 1240;
1242 -> 1241;
1245 -> 1244;
1245 -> 1243;
1246 -> 1243;
1247 -> 1241;
1248 -> 1242;
1248 -> 1247;
1249 -> 1247;
1250 -> 1248;
1250 -> 1249;
1251 -> 1250;
1251 -> 1249;
1252 -> 1248;
1252 -> 1247;
1253 -> 1241;
1254 -> 1253;
1254 -> 1242;
1254 -> 1241;
1255 -> 1242;
1255 -> 1241;
1256 -> 1240;
1256 -> 1239;
1257 -> 1240;
1257 -> 1239;
1258 -> 1240;
1258 -> 1239;
1259 -> 1240;
1259 -> 1239;
1260 -> 1240;
1260 -> 1239;
1261 -> 1240;
1261 -> 1239;
1262 -> 1240;
1262 -> 1239;
1263 -> 1238;
1263 -> 1233;
1264 -> 1238;
1264 -> 1233;
1265 -> 1238;
1265 -> 1233;
1266 -> 1233;
1267 -> 1234;
1267 -> 1266;
1267 -> 1233;
1268 -> 1233;
1269 -> 1235;
1269 -> 1268;
1269 -> 1233;
1270 -> 1234;
1270 -> 1238;
1270 -> 1233;
1271 -> 1235;
1271 -> 1238;
1271 -> 1233;
1272 -> 1234;
1272 -> 1224;
1272 -> 1225;
1272 -> 1227;
1272 -> 1233;
1273 -> 1233;
1274 -> 1273;
1274 -> 1234;
1274 -> 1224;
1274 -> 1225;
1274 -> 1227;
1274 -> 1233;
1275 -> 1238;
1275 -> 1274;
1277 -> 1276;
1278 -> 1234;
1278 -> 1224;
1278 -> 1273;
1278 -> 1225;
1278 -> 1227;
1278 -> 1274;
1279 -> 1237;
1279 -> 1274;
1280 -> 1273;
1280 -> 1274;
1281 -> 1274;
1282 -> 1274;
1283 -> 1275;
1283 -> 1282;
1284 -> 1278;
1284 -> 1282;
1285 -> 1279;
1285 -> 1282;
1286 -> 1280;
1286 -> 1282;
1287 -> 1281;
1287 -> 1282;
1288 -> 1283;
1288 -> 1282;
1289 -> 1284;
1289 -> 1282;
1290 -> 1285;
1290 -> 1282;
1291 -> 1286;
1291 -> 1282;
1292 -> 1282;
1293 -> 1288;
1293 -> 1292;
1294 -> 1289;
1294 -> 1292;
1295 -> 1290;
1295 -> 1292;
1296 -> 1291;
1296 -> 1292;
1297 -> 1287;
1297 -> 1292;
1298 -> 1292;
1299 -> 1297;
1299 -> 1298;
1300 -> 1298;
1301 -> 1299;
1301 -> 1300;
1302 -> 1300;
1303 -> 1301;
1303 -> 1302;
1304 -> 1303;
1304 -> 1302;
1305 -> 1299;
1305 -> 1298;
1306 -> 1297;
1306 -> 1292;
1307 -> 1297;
1307 -> 1292;
1308 -> 1297;
1308 -> 1292;
1309 -> 1297;
1309 -> 1292;
1310 -> 1297;
1310 -> 1292;
1311 -> 1297;
1311 -> 1292;
1312 -> 1297;
1312 -> 1292;
1313 -> 1292;
1314 -> 1313;
1314 -> 1292;
1315 -> 1277;
1315 -> 1292;
1316 -> 1314;
1316 -> 1315;
1316 -> 1292;
1317 -> 1316;
1317 -> 1297;
1317 -> 1292;
1318 -> 1292;
1319 -> 1318;
1319 -> 1292;
1320 -> 1277;
1320 -> 1292;
1321 -> 1319;
1321 -> 1320;
1321 -> 1292;
1322 -> 1321;
1322 -> 1297;
1322 -> 1292;
1323 -> 1297;
1323 -> 1292;
1324 -> 1297;
1324 -> 1292;
1325 -> 1297;
1325 -> 1292;
1326 -> 1297;
1326 -> 1292;
1327 -> 1292;
1328 -> 1293;
1328 -> 1327;
1328 -> 1292;
1329 -> 1292;
1330 -> 1294;
1330 -> 1329;
1330 -> 1292;
1331 -> 1293;
1331 -> 1297;
1331 -> 1292;
1332 -> 1296;
1332 -> 1297;
1332 -> 1292;
1333 -> 1294;
1333 -> 1297;
1333 -> 1292;
1334 -> 1295;
1334 -> 1297;
1334 -> 1292;
1335 -> 1297;
1335 -> 1292;
1336 -> 1292;
1337 -> 1292;
1338 -> 1335;
1338 -> 1337;
1339 -> 1336;
1339 -> 1337;
1340 -> 1337;
1341 -> 1339;
1341 -> 1340;
1342 -> 1340;
1343 -> 1341;
1343 -> 1342;
1344 -> 1342;
1345 -> 1343;
1345 -> 1344;
1346 -> 1344;
1347 -> 1345;
1347 -> 1346;
1348 -> 1347;
1348 -> 1346;
1349 -> 1343;
1349 -> 1342;
1350 -> 1343;
1350 -> 1342;
1351 -> 1341;
1351 -> 1340;
1352 -> 1341;
1352 -> 1340;
1353 -> 1341;
1353 -> 1340;
1354 -> 1339;
1354 -> 1337;
1355 -> 1337;
1356 -> 1338;
1356 -> 1355;
1356 -> 1337;
1357 -> 1338;
1357 -> 1339;
1357 -> 1337;
1358 -> 1336;
1358 -> 1297;
1358 -> 1292;
1359 -> 1297;
1359 -> 1292;
1360 -> 1359;
1360 -> 1304;
1360 -> 1305;
1360 -> 1331;
1360 -> 1332;
1360 -> 1333;
1360 -> 1358;
1360 -> 1310;
1360 -> 1311;
1360 -> 1312;
1360 -> 1317;
1360 -> 1322;
1360 -> 1334;
1360 -> 1324;
1360 -> 1325;
1360 -> 1326;
1360 -> 1316;
1360 -> 1321;
1360 -> 1251;
1360 -> 1252;
1360 -> 1254;
1360 -> 1255;
1360 -> 1256;
1360 -> 1257;
1360 -> 1258;
1360 -> 1259;
1360 -> 1260;
1360 -> 1261;
1360 -> 1262;
1360 -> 1270;
1360 -> 1271;
1360 -> 1265;
1360 -> 1253;
1360 -> 1278;
1360 -> 1348;
1360 -> 1349;
1360 -> 1350;
1360 -> 1351;
1360 -> 1352;
1360 -> 1353;
1360 -> 1357;
1360 -> 1292;
1361 -> 1360;
1361 -> 1297;
1361 -> 1292;
1362 -> 1282;
1363 -> 1286;
1363 -> 1362;
1363 -> 1282;
1364 -> 1281;
1364 -> 1273;
1364 -> 1272;
1364 -> 1274;
1365 -> 1272;
1365 -> 1233;
1366 -> 1365;
1366 -> 1272;
1366 -> 1364;
1366 -> 1360;
1366 -> 1361;
1366 -> 1233;
1367 -> 1366;
1367 -> 1238;
1367 -> 1233;
1368 -> 1236;
1368 -> 1238;
1368 -> 1233;
1369 -> 1232;
1369 -> 1211;
1370 -> 1369;
1370 -> 1210;
1370 -> 1211;
1371 -> 1208;
1371 -> 1211;
1372 -> 1207;
1372 -> 1371;
1372 -> 1211;
1373 -> 1183;
1373 -> 1208;
1373 -> 1366;
1373 -> 1367;
1373 -> 1368;
1373 -> 1209;
1374 -> 1209;
1375 -> 1373;
1375 -> 1374;
1376 -> 1209;
1377 -> 1210;
1377 -> 1206;
1377 -> 1370;
1377 -> 1376;
1378 -> 1377;
1378 -> 1373;
1378 -> 1376;
1379 -> 1375;
1379 -> 1378;
1379 -> 1209;
1380 -> 1373;
1381 -> 1380;
1381 -> 1373;
1382 -> 1373;
1383 -> 1373;
1384 -> 1373;
1385 -> 1373;
1386 -> 1373;
1387 -> 1373;
1388 -> 1373;
1389 -> 1373;
1390 -> 1373;
1391 -> 1373;
1392 -> 1373;
1393 -> 1373;
1394 -> 1373;
1395 -> 1373;
1396 -> 1373;
1397 -> 1209;
1397 -> 1373;
1398 -> 1207;
1398 -> 1372;
1398 -> 1397;
1398 -> 1373;
1399 -> 1373;
1400 -> 1373;
1401 -> 1373;
1401 -> 1396;
1401 -> 1400;
1402 -> 1401;
1402 -> 1373;
1402 -> 1400;
1403 -> 1399;
1403 -> 1402;
1403 -> 1373;
1404 -> 1399;
1404 -> 1373;
1405 -> 1399;
1405 -> 1373;
1406 -> 1399;
1407 -> 1399;
1408 -> 1399;
1409 -> 1399;
1410 -> 1399;
1411 -> 1399;
1412 -> 1399;
1413 -> 1399;
1414 -> 1399;
1415 -> 1399;
1415 -> 1395;
1415 -> 1373;
1416 -> 1399;
1416 -> 1373;
1417 -> 1373;
1418 -> 1373;
1418 -> 1416;
1418 -> 1400;
1419 -> 1418;
1419 -> 1399;
1419 -> 1400;
1420 -> 1399;
1421 -> 1420;
1421 -> 1399;
1422 -> 1399;
1423 -> 1399;
1424 -> 1399;
1425 -> 1399;
1426 -> 1399;
1427 -> 1399;
1428 -> 1373;
1428 -> 1399;
1429 -> 1207;
1429 -> 1372;
1429 -> 1398;
1429 -> 1428;
1429 -> 1399;
1430 -> 1399;
1431 -> 1399;
1431 -> 1427;
1431 -> 1430;
1432 -> 1431;
1432 -> 1399;
1432 -> 1430;
1433 -> 1399;
1434 -> 972;
1434 -> 971;
1435 -> 973;
1435 -> 1399;
1435 -> 971;
1436 -> 972;
1436 -> 1399;
1436 -> 971;
1437 -> 971;
1439 -> 1103;
1439 -> 971;
1440 -> 971;
1441 -> 1434;
1441 -> 1440;
1442 -> 1435;
1442 -> 1440;
1443 -> 1436;
1443 -> 1440;
1444 -> 1439;
1444 -> 1440;
1445 -> 1437;
1445 -> 1440;
1446 -> 1440;
1447 -> 1445;
1447 -> 1446;
1448 -> 1446;
1449 -> 1447;
1449 -> 1448;
1450 -> 1448;
1451 -> 1449;
1451 -> 1450;
1452 -> 1450;
1453 -> 1451;
1453 -> 1452;
1454 -> 1453;
1454 -> 1452;
1455 -> 1451;
1455 -> 1450;
1456 -> 1448;
1457 -> 1456;
1457 -> 1449;
1457 -> 1448;
1458 -> 1449;
1458 -> 1448;
1459 -> 1447;
1459 -> 1446;
1460 -> 1447;
1460 -> 1446;
1461 -> 1447;
1461 -> 1446;
1462 -> 1447;
1462 -> 1446;
1463 -> 1447;
1463 -> 1446;
1464 -> 1447;
1464 -> 1446;
1465 -> 1447;
1465 -> 1446;
1466 -> 1445;
1466 -> 1440;
1467 -> 1445;
1467 -> 1440;
1468 -> 1445;
1468 -> 1440;
1469 -> 1445;
1469 -> 1440;
1470 -> 1445;
1470 -> 1440;
1471 -> 1445;
1471 -> 1440;
1472 -> 1445;
1472 -> 1440;
1473 -> 1445;
1473 -> 1440;
1474 -> 1445;
1474 -> 1440;
1475 -> 1440;
1476 -> 1475;
1476 -> 1445;
1476 -> 1440;
1477 -> 1440;
1478 -> 1477;
1478 -> 1445;
1478 -> 1440;
1479 -> 1440;
1480 -> 1479;
1480 -> 1445;
1480 -> 1440;
1481 -> 1445;
1481 -> 1440;
1482 -> 1445;
1482 -> 1440;
1483 -> 1440;
1484 -> 1441;
1484 -> 1483;
1484 -> 1440;
1485 -> 1440;
1486 -> 1442;
1486 -> 1485;
1486 -> 1440;
1487 -> 1443;
1487 -> 1440;
1488 -> 1444;
1488 -> 1103;
1488 -> 1440;
1489 -> 1441;
1489 -> 1445;
1489 -> 1440;
1490 -> 1442;
1490 -> 1445;
1490 -> 1440;
1491 -> 1440;
1492 -> 1491;
1492 -> 1444;
1492 -> 1103;
1492 -> 1440;
1493 -> 1445;
1493 -> 1440;
1494 -> 1440;
1495 -> 1441;
1495 -> 1494;
1496 -> 1495;
1496 -> 1436;
1496 -> 1494;
1497 -> 1496;
1497 -> 1440;
1498 -> 1443;
1498 -> 1440;
1499 -> 1440;
1500 -> 1440;
1501 -> 1493;
1501 -> 1500;
1502 -> 1497;
1502 -> 1500;
1503 -> 1498;
1503 -> 1500;
1504 -> 1499;
1504 -> 1500;
1505 -> 1500;
1506 -> 1504;
1506 -> 1505;
1507 -> 1505;
1508 -> 1506;
1508 -> 1507;
1509 -> 1507;
1510 -> 1508;
1510 -> 1509;
1511 -> 1510;
1511 -> 1509;
1512 -> 1506;
1512 -> 1505;
1513 -> 1504;
1513 -> 1500;
1514 -> 0;
1514 -> 1504;
1514 -> 1500;
1515 -> 1504;
1515 -> 1500;
1516 -> 1504;
1516 -> 1500;
1517 -> 1504;
1517 -> 1500;
1518 -> 1504;
1518 -> 1500;
1519 -> 1504;
1519 -> 1500;
1520 -> 1500;
1521 -> 1501;
1521 -> 1520;
1521 -> 1500;
1522 -> 1501;
1522 -> 1504;
1522 -> 1500;
1523 -> 1502;
1523 -> 1504;
1523 -> 1500;
1524 -> 1503;
1524 -> 1504;
1524 -> 1500;
1525 -> 1492;
1525 -> 1499;
1525 -> 1511;
1525 -> 1512;
1525 -> 1522;
1525 -> 1514;
1525 -> 1523;
1525 -> 1516;
1525 -> 1517;
1525 -> 1518;
1525 -> 1524;
1525 -> 1454;
1525 -> 1455;
1525 -> 1457;
1525 -> 1458;
1525 -> 1459;
1525 -> 1460;
1525 -> 1461;
1525 -> 1462;
1525 -> 1463;
1525 -> 1464;
1525 -> 1465;
1525 -> 1489;
1525 -> 1467;
1525 -> 1490;
1525 -> 1469;
1525 -> 1470;
1525 -> 1471;
1525 -> 1472;
1525 -> 1473;
1525 -> 1474;
1525 -> 1476;
1525 -> 1478;
1525 -> 1480;
1525 -> 1481;
1525 -> 1482;
1525 -> 1456;
1525 -> 1496;
1525 -> 1475;
1525 -> 1477;
1525 -> 1479;
1525 -> 1440;
1526 -> 1440;
1527 -> 1441;
1527 -> 1526;
1528 -> 1527;
1528 -> 1525;
1528 -> 1526;
1529 -> 1528;
1529 -> 1440;
1530 -> 1529;
1530 -> 1440;
1531 -> 1444;
1531 -> 1440;
1532 -> 1492;
1532 -> 1525;
1532 -> 1440;
1533 -> 1532;
1533 -> 1445;
1533 -> 1440;
1534 -> 1440;
1535 -> 1441;
1535 -> 1534;
1536 -> 1535;
1536 -> 1525;
1536 -> 1534;
1537 -> 1536;
1537 -> 1440;
1538 -> 1537;
1538 -> 1525;
1538 -> 1533;
1538 -> 1440;
1539 -> 971;
1540 -> 971;
1541 -> 1183;
1541 -> 1540;
1541 -> 971;
1542 -> 1541;
1543 -> 1183;
1543 -> 1525;
1543 -> 1533;
1543 -> 1542;
1544 -> 1543;
1544 -> 971;
1545 -> 971;
1546 -> 1544;
1546 -> 1545;
1547 -> 1437;
1547 -> 1545;
1548 -> 1545;
1549 -> 1547;
1549 -> 1525;
1549 -> 1548;
1549 -> 1545;
1550 -> 1546;
1550 -> 1547;
1550 -> 1545;
1551 -> 971;
1552 -> 971;
1553 -> 971;
1554 -> 1183;
1554 -> 1525;
1554 -> 1553;
1554 -> 971;
1555 -> 971;
1556 -> 1555;
1556 -> 971;
1557 -> 1437;
1557 -> 971;
1558 -> 1103;
1558 -> 971;
1559 -> 1554;
1559 -> 971;
1560 -> 1183;
1560 -> 971;
1561 -> 1552;
1561 -> 971;
1562 -> 1555;
1562 -> 971;
1563 -> 971;
1564 -> 1557;
1564 -> 1563;
1565 -> 1558;
1565 -> 1563;
1566 -> 1559;
1566 -> 1563;
1567 -> 1560;
1567 -> 1563;
1568 -> 1561;
1568 -> 1563;
1569 -> 1562;
1569 -> 1563;
1570 -> 1563;
1571 -> 1564;
1571 -> 1570;
1572 -> 1571;
1572 -> 1525;
1572 -> 1533;
1572 -> 1570;
1573 -> 1572;
1573 -> 1563;
1574 -> 1563;
1575 -> 1574;
1575 -> 1565;
1575 -> 1103;
1575 -> 1563;
1576 -> 1573;
1576 -> 1525;
1576 -> 1532;
1576 -> 1575;
1576 -> 1563;
1577 -> 1563;
1578 -> 1573;
1578 -> 1525;
1578 -> 1532;
1578 -> 1577;
1578 -> 1563;
1579 -> 1578;
1579 -> 1563;
1580 -> 1563;
1581 -> 1563;
1582 -> 1581;
1582 -> 1573;
1582 -> 1525;
1582 -> 1532;
1582 -> 1563;
1583 -> 1582;
1584 -> 1583;
1584 -> 1582;
1585 -> 1566;
1585 -> 1584;
1586 -> 1585;
1586 -> 1582;
1587 -> 1585;
1587 -> 1582;
1588 -> 1582;
1589 -> 1582;
1590 -> 1589;
1590 -> 1585;
1590 -> 1582;
1591 -> 1590;
1592 -> 1567;
1592 -> 1525;
1592 -> 1533;
1592 -> 1550;
1592 -> 1591;
1592 -> 1590;
1593 -> 1590;
1594 -> 1567;
1594 -> 1525;
1594 -> 1533;
1594 -> 1550;
1594 -> 1593;
1594 -> 1590;
1595 -> 1580;
1595 -> 1589;
1595 -> 1590;
1596 -> 1594;
1596 -> 1525;
1596 -> 1533;
1596 -> 1550;
1596 -> 1532;
1596 -> 1595;
1596 -> 1590;
1597 -> 1596;
1597 -> 1525;
1597 -> 1532;
1597 -> 1590;
1598 -> 1596;
1598 -> 1525;
1598 -> 1532;
1598 -> 1590;
1599 -> 1567;
1599 -> 1598;
1600 -> 1596;
1600 -> 1598;
1601 -> 1588;
1601 -> 1598;
1602 -> 1598;
1603 -> 1599;
1603 -> 1602;
1604 -> 1600;
1604 -> 1602;
1605 -> 1601;
1605 -> 1602;
1606 -> 1604;
1606 -> 1525;
1606 -> 1532;
1606 -> 1602;
1607 -> 1604;
1607 -> 1525;
1607 -> 1532;
1607 -> 1602;
1608 -> 1603;
1608 -> 1525;
1608 -> 1533;
1608 -> 1550;
1608 -> 1604;
1608 -> 1532;
1608 -> 1602;
1609 -> 1608;
1609 -> 1602;
1610 -> 1602;
1611 -> 1604;
1611 -> 1525;
1611 -> 1532;
1611 -> 1610;
1611 -> 1602;
1612 -> 1608;
1612 -> 1602;
1613 -> 1612;
1613 -> 1589;
1613 -> 1587;
1613 -> 1598;
1614 -> 1596;
1614 -> 1525;
1614 -> 1532;
1614 -> 1589;
1614 -> 1586;
1614 -> 1590;
1615 -> 1580;
1615 -> 1590;
1616 -> 1594;
1616 -> 1525;
1616 -> 1533;
1616 -> 1550;
1616 -> 1532;
1616 -> 1615;
1616 -> 1590;
1617 -> 1616;
1617 -> 1525;
1617 -> 1532;
1617 -> 1590;
1618 -> 1616;
1618 -> 1525;
1618 -> 1532;
1618 -> 1590;
1619 -> 1567;
1619 -> 1618;
1620 -> 1616;
1620 -> 1618;
1621 -> 1618;
1622 -> 1619;
1622 -> 1621;
1623 -> 1620;
1623 -> 1621;
1624 -> 1623;
1624 -> 1525;
1624 -> 1532;
1624 -> 1621;
1625 -> 1623;
1625 -> 1525;
1625 -> 1532;
1625 -> 1621;
1626 -> 1622;
1626 -> 1525;
1626 -> 1533;
1626 -> 1550;
1626 -> 1623;
1626 -> 1532;
1626 -> 1621;
1627 -> 1626;
1627 -> 1621;
1628 -> 1621;
1629 -> 1623;
1629 -> 1525;
1629 -> 1532;
1629 -> 1628;
1629 -> 1621;
1630 -> 1626;
1630 -> 1621;
1631 -> 1630;
1631 -> 1590;
1631 -> 1587;
1631 -> 1618;
1632 -> 1616;
1632 -> 1525;
1632 -> 1532;
1632 -> 1590;
1632 -> 1586;
1633 -> 1586;
1633 -> 1582;
1634 -> 1633;
1634 -> 1586;
1634 -> 1614;
1634 -> 1632;
1634 -> 1525;
1634 -> 1533;
1634 -> 1550;
1634 -> 1532;
1634 -> 1582;
1635 -> 1587;
1635 -> 1582;
1636 -> 1635;
1636 -> 1587;
1636 -> 1613;
1636 -> 1631;
1636 -> 1634;
1636 -> 1582;
1637 -> 1605;
1637 -> 1582;
1638 -> 1634;
1638 -> 1636;
1638 -> 1637;
1638 -> 1582;
1639 -> 1582;
1640 -> 1573;
1640 -> 1581;
1640 -> 1525;
1640 -> 1533;
1640 -> 1550;
1640 -> 1532;
1640 -> 1638;
1640 -> 1582;
1641 -> 1638;
1641 -> 1582;
1642 -> 1564;
1642 -> 1582;
1643 -> 1582;
1644 -> 1641;
1644 -> 1643;
1645 -> 1642;
1645 -> 1643;
1646 -> 1640;
1646 -> 1643;
1647 -> 1643;
1648 -> 1644;
1648 -> 1647;
1648 -> 1643;
1649 -> 1643;
1650 -> 1646;
1650 -> 1649;
1651 -> 1649;
1652 -> 1650;
1652 -> 1640;
1652 -> 1651;
1652 -> 1649;
1653 -> 1643;
1654 -> 1644;
1654 -> 1646;
1654 -> 1643;
1655 -> 1582;
1656 -> 1580;
1656 -> 1585;
1656 -> 1582;
1657 -> 1579;
1657 -> 1563;
1658 -> 971;
1659 -> 971;
1660 -> 1207;
1660 -> 1372;
1660 -> 1398;
1660 -> 1429;
1660 -> 1659;
1660 -> 971;
1661 -> 1183;
1661 -> 1660;
1662 -> 1207;
1662 -> 1660;
1663 -> 1437;
1663 -> 1660;
1664 -> 1183;
1664 -> 1660;
1665 -> 1568;
1665 -> 1660;
1666 -> 1660;
1667 -> 1662;
1667 -> 1666;
1668 -> 1663;
1668 -> 1666;
1669 -> 1664;
1669 -> 1666;
1670 -> 1664;
1670 -> 1666;
1671 -> 1665;
1671 -> 1666;
1672 -> 1666;
1673 -> 1667;
1673 -> 1207;
1673 -> 1372;
1673 -> 1398;
1673 -> 1429;
1673 -> 1672;
1673 -> 1666;
1674 -> 1666;
1675 -> 1668;
1675 -> 1674;
1676 -> 1675;
1676 -> 1640;
1676 -> 1674;
1677 -> 1676;
1677 -> 1666;
1678 -> 1666;
1679 -> 1677;
1679 -> 1678;
1679 -> 1666;
1680 -> 1667;
1680 -> 1666;
1681 -> 1669;
1681 -> 1680;
1681 -> 1640;
1681 -> 1654;
1682 -> 1680;
1683 -> 1681;
1683 -> 1682;
1683 -> 1680;
1684 -> 1669;
1684 -> 1680;
1684 -> 1681;
1684 -> 1683;
1685 -> 1684;
1685 -> 1683;
1686 -> 1670;
1686 -> 1683;
1687 -> 1670;
1687 -> 1684;
1687 -> 1680;
1687 -> 1683;
1688 -> 1671;
1688 -> 1683;
1689 -> 1668;
1689 -> 1683;
1690 -> 1683;
1691 -> 1685;
1691 -> 1690;
1692 -> 1686;
1692 -> 1690;
1693 -> 1687;
1693 -> 1690;
1694 -> 1688;
1694 -> 1690;
1695 -> 1689;
1695 -> 1690;
1696 -> 1693;
1696 -> 1684;
1696 -> 1690;
1697 -> 1693;
1697 -> 1684;
1697 -> 1690;
1698 -> 1693;
1698 -> 1684;
1698 -> 1690;
1699 -> 1690;
1700 -> 1698;
1700 -> 1699;
1701 -> 1700;
1701 -> 1684;
1701 -> 1699;
1702 -> 1701;
1702 -> 1690;
1703 -> 1702;
1703 -> 1684;
1703 -> 1690;
1704 -> 1690;
1705 -> 1690;
1706 -> 1705;
1706 -> 1703;
1706 -> 1690;
1707 -> 1691;
1707 -> 1684;
1707 -> 1705;
1707 -> 1706;
1708 -> 1707;
1708 -> 1706;
1709 -> 1707;
1709 -> 1706;
1710 -> 1706;
1711 -> 1691;
1711 -> 1710;
1712 -> 1711;
1712 -> 1707;
1712 -> 1710;
1713 -> 1712;
1713 -> 1706;
1714 -> 1704;
1714 -> 1706;
1715 -> 1708;
1715 -> 1706;
1716 -> 1706;
1717 -> 1707;
1717 -> 1706;
1718 -> 1713;
1718 -> 1714;
1718 -> 1715;
1718 -> 1716;
1718 -> 1717;
1718 -> 1707;
1718 -> 1708;
1718 -> 1706;
1719 -> 1706;
1720 -> 1706;
1721 -> 1720;
1721 -> 1707;
1721 -> 1706;
1722 -> 1708;
1722 -> 1706;
1723 -> 1722;
1723 -> 1718;
1723 -> 1706;
1724 -> 1709;
1724 -> 1706;
1725 -> 1719;
1725 -> 1706;
1726 -> 1723;
1726 -> 1724;
1726 -> 1725;
1726 -> 1706;
1727 -> 1702;
1727 -> 1705;
1727 -> 1684;
1727 -> 1726;
1727 -> 1706;
1728 -> 1726;
1728 -> 1706;
1729 -> 1695;
1729 -> 1706;
1730 -> 1706;
1731 -> 1728;
1731 -> 1730;
1732 -> 1729;
1732 -> 1730;
1733 -> 1727;
1733 -> 1730;
1734 -> 1730;
1735 -> 1731;
1735 -> 1734;
1735 -> 1730;
1736 -> 1730;
1737 -> 1733;
1737 -> 1736;
1738 -> 1736;
1739 -> 1737;
1739 -> 1727;
1739 -> 1738;
1739 -> 1736;
1740 -> 1730;
1741 -> 1706;
1742 -> 1704;
1742 -> 1707;
1742 -> 1706;
1743 -> 1683;
1744 -> 1694;
1744 -> 1731;
1745 -> 1668;
1745 -> 1731;
1746 -> 1731;
1747 -> 1745;
1747 -> 1731;
1748 -> 1731;
1749 -> 1731;
1750 -> 1731;
1751 -> 1731;
1751 -> 1750;
1752 -> 1751;
1752 -> 1731;
1752 -> 1750;
1753 -> 1746;
1753 -> 1752;
1754 -> 1751;
1754 -> 1752;
1755 -> 1731;
1755 -> 1752;
1756 -> 1752;
1757 -> 1753;
1757 -> 1756;
1758 -> 1754;
1758 -> 1756;
1759 -> 1755;
1759 -> 1756;
1760 -> 1758;
1760 -> 1731;
1760 -> 1756;
1761 -> 1758;
1761 -> 1731;
1761 -> 1756;
1762 -> 1757;
1762 -> 1756;
1763 -> 1756;
1764 -> 1758;
1764 -> 1731;
1764 -> 1763;
1764 -> 1756;
1765 -> 1757;
1765 -> 1750;
1765 -> 1731;
1765 -> 1752;
1766 -> 1731;
1766 -> 1750;
1766 -> 1752;
1767 -> 1744;
1767 -> 1752;
1768 -> 1752;
1769 -> 1766;
1769 -> 1768;
1770 -> 1767;
1770 -> 1768;
1771 -> 1768;
1772 -> 1768;
1773 -> 1770;
1773 -> 1772;
1773 -> 1768;
1774 -> 1773;
1775 -> 1769;
1775 -> 1768;
1776 -> 1768;
1777 -> 1768;
1778 -> 1775;
1778 -> 1777;
1779 -> 1776;
1779 -> 1777;
1780 -> 1777;
1781 -> 1779;
1781 -> 1777;
1782 -> 1779;
1782 -> 1777;
1783 -> 1777;
1784 -> 1778;
1784 -> 1783;
1784 -> 1777;
1785 -> 1778;
1785 -> 1779;
1785 -> 1777;
1786 -> 1779;
1786 -> 1777;
1787 -> 1777;
1788 -> 1777;
1789 -> 1786;
1789 -> 1788;
1790 -> 1787;
1790 -> 1788;
1791 -> 1787;
1791 -> 1788;
1792 -> 1788;
1793 -> 1791;
1793 -> 1788;
1794 -> 1791;
1794 -> 1788;
1795 -> 1791;
1795 -> 1788;
1796 -> 1788;
1797 -> 1789;
1797 -> 1796;
1797 -> 1788;
1798 -> 1788;
1799 -> 1790;
1799 -> 1798;
1799 -> 1788;
1800 -> 1789;
1800 -> 1791;
1800 -> 1788;
1801 -> 1790;
1801 -> 1791;
1801 -> 1788;
1802 -> 1791;
1802 -> 1788;
1803 -> 1788;
1804 -> 1788;
1805 -> 1802;
1805 -> 1804;
1806 -> 1803;
1806 -> 1804;
1807 -> 1804;
1808 -> 1806;
1808 -> 1804;
1809 -> 1806;
1809 -> 1804;
1810 -> 1804;
1811 -> 1805;
1811 -> 1810;
1811 -> 1804;
1812 -> 1805;
1812 -> 1806;
1812 -> 1804;
1813 -> 0;
1813 -> 1806;
1813 -> 1804;
1814 -> 1803;
1814 -> 1791;
1814 -> 1788;
1815 -> 1787;
1815 -> 1779;
1815 -> 1777;
1816 -> 1769;
1816 -> 1768;
1817 -> 1776;
1817 -> 1768;
1818 -> 1774;
1818 -> 1816;
1818 -> 1817;
1818 -> 1768;
1819 -> 1776;
1819 -> 1768;
1820 -> 1819;
1820 -> 1752;
1821 -> 1820;
1821 -> 1750;
1821 -> 1731;
1821 -> 1752;
1822 -> 1769;
1822 -> 1774;
1823 -> 1771;
1823 -> 1774;
1824 -> 1774;
1824 -> 1822;
1824 -> 1823;
1824 -> 1731;
1824 -> 1818;
1824 -> 1779;
1824 -> 1785;
1824 -> 1815;
1824 -> 1791;
1824 -> 1800;
1824 -> 1801;
1824 -> 1814;
1824 -> 1806;
1824 -> 1813;
1824 -> 1812;
1825 -> 1731;
1825 -> 1765;
1825 -> 1821;
1825 -> 1824;
1826 -> 1747;
1826 -> 1731;
1827 -> 1731;
1828 -> 1825;
1828 -> 1827;
1828 -> 1731;
1829 -> 1731;
1830 -> 1825;
1830 -> 1829;
1831 -> 1829;
1832 -> 1830;
1832 -> 1825;
1832 -> 1831;
1832 -> 1829;
1833 -> 1731;
1834 -> 1731;
1835 -> 1668;
1835 -> 1825;
1836 -> 1835;
1836 -> 1825;
1837 -> 1825;
1838 -> 1825;
1839 -> 1825;
1840 -> 1825;
1841 -> 1825;
1842 -> 1825;
1843 -> 1825;
1844 -> 1843;
1844 -> 1825;
1845 -> 1843;
1845 -> 1825;
1846 -> 1825;
1847 -> 1843;
1847 -> 1846;
1847 -> 1825;
1848 -> 1843;
1848 -> 1825;
1849 -> 1843;
1849 -> 1825;
1850 -> 1843;
1850 -> 1825;
1851 -> 1825;
1852 -> 1843;
1852 -> 1851;
1852 -> 1825;
1853 -> 1825;
1854 -> 1843;
1854 -> 1853;
1854 -> 1825;
1855 -> 1843;
1855 -> 1825;
1856 -> 1843;
1856 -> 1825;
1857 -> 1825;
1858 -> 1843;
1858 -> 1857;
1858 -> 1825;
1859 -> 1843;
1860 -> 1843;
1861 -> 1843;
1862 -> 1843;
1863 -> 1843;
1864 -> 1843;
1865 -> 1843;
1866 -> 1843;
1867 -> 1843;
1868 -> 1843;
1869 -> 1843;
1870 -> 1836;
1870 -> 1825;
1871 -> 1825;
1872 -> 1843;
1872 -> 1871;
1872 -> 1825;
1873 -> 1825;
1874 -> 1843;
1874 -> 1873;
1875 -> 1873;
1876 -> 1874;
1876 -> 1843;
1876 -> 1875;
1876 -> 1873;
1877 -> 1825;
1878 -> 1825;
1879 -> 1668;
1879 -> 1843;
1880 -> 1879;
1880 -> 1843;
1881 -> 1843;
1882 -> 1843;
1883 -> 1843;
1884 -> 1843;
1885 -> 1843;
1886 -> 1843;
1887 -> 1886;
1888 -> 1887;
1889 -> 1843;
1889 -> 1886;
1890 -> 1888;
1890 -> 1889;
1890 -> 1886;
1891 -> 1890;
1892 -> 1890;
1893 -> 1890;
1894 -> 1890;
1895 -> 1890;
1896 -> 1890;
1897 -> 1890;
1898 -> 1890;
1899 -> 1890;
1900 -> 1890;
1901 -> 1890;
1902 -> 1880;
1902 -> 1843;
1903 -> 1843;
1904 -> 1890;
1904 -> 1903;
1904 -> 1843;
1905 -> 1843;
1906 -> 1890;
1906 -> 1905;
1907 -> 1905;
1908 -> 1906;
1908 -> 1890;
1908 -> 1907;
1908 -> 1905;
1909 -> 1843;
1910 -> 1843;
1911 -> 1668;
1911 -> 1890;
1912 -> 1911;
1912 -> 1890;
1913 -> 1890;
1914 -> 1890;
1915 -> 1890;
1916 -> 1890;
1917 -> 1890;
1918 -> 1912;
1918 -> 1890;
1919 -> 1890;
1920 -> 1890;
1921 -> 1890;
1921 -> 1920;
1922 -> 1920;
1923 -> 1921;
1923 -> 1890;
1923 -> 1922;
1923 -> 1920;
1924 -> 1890;
1925 -> 1890;
1926 -> 1666;
1927 -> 1666;
1928 -> 1668;
1928 -> 1927;
1929 -> 1928;
1929 -> 1890;
1929 -> 1927;
1930 -> 1929;
1930 -> 1666;
1931 -> 1666;
1932 -> 1666;
1933 -> 1930;
1933 -> 1932;
1934 -> 1932;
1935 -> 1933;
1935 -> 1934;
1936 -> 1934;
1937 -> 1935;
1937 -> 1930;
1937 -> 1936;
1937 -> 1934;
1938 -> 1932;
1939 -> 1933;
1939 -> 1930;
1939 -> 1932;
1940 -> 1667;
1940 -> 1666;
1941 -> 1670;
1941 -> 1930;
1941 -> 1940;
1942 -> 1941;
1942 -> 1930;
1942 -> 1940;
1943 -> 1941;
1943 -> 1930;
1943 -> 1940;
1944 -> 1669;
1944 -> 1940;
1944 -> 1930;
1945 -> 1940;
1946 -> 1944;
1946 -> 1945;
1947 -> 1926;
1947 -> 1940;
1948 -> 1669;
1948 -> 1940;
1948 -> 1946;
1949 -> 1940;
1950 -> 1948;
1950 -> 1949;
1951 -> 1941;
1951 -> 1930;
1951 -> 1940;
1952 -> 1951;
1952 -> 1948;
1952 -> 1940;
1953 -> 1940;
1954 -> 1926;
1954 -> 1947;
1954 -> 1953;
1954 -> 1940;
1955 -> 1677;
1955 -> 1940;
1956 -> 1940;
1957 -> 1955;
1957 -> 1956;
1958 -> 1941;
1958 -> 1930;
1958 -> 1956;
1959 -> 1956;
1960 -> 1958;
1960 -> 1948;
1960 -> 1959;
1960 -> 1956;
1961 -> 1957;
1961 -> 1958;
1961 -> 1956;
1962 -> 1940;
1963 -> 1670;
1963 -> 1948;
1963 -> 1961;
1963 -> 1940;
1964 -> 1963;
1964 -> 1948;
1964 -> 1940;
1965 -> 1963;
1965 -> 1948;
1965 -> 1940;
1966 -> 1669;
1966 -> 1940;
1966 -> 1948;
1966 -> 1961;
1967 -> 1966;
1967 -> 1949;
1968 -> 1963;
1968 -> 1948;
1968 -> 1940;
1969 -> 1669;
1969 -> 1968;
1969 -> 1966;
1970 -> 1968;
1971 -> 1969;
1971 -> 1970;
1972 -> 1963;
1972 -> 1969;
1972 -> 1959;
1972 -> 1956;
1973 -> 1969;
1973 -> 1940;
1974 -> 1969;
1974 -> 1940;
1975 -> 1969;
1975 -> 1949;
1976 -> 1969;
1977 -> 1969;
1977 -> 1959;
1977 -> 1956;
1978 -> 1926;
1978 -> 1947;
1978 -> 1666;
1979 -> 1666;
1980 -> 1890;
1980 -> 1979;
1980 -> 1666;
1981 -> 1890;
1981 -> 1969;
1981 -> 1980;
1982 -> 1677;
1982 -> 1981;
1983 -> 1981;
1984 -> 1982;
1984 -> 1983;
1985 -> 1983;
1986 -> 1981;
1987 -> 1984;
1988 -> 1660;
1989 -> 972;
1989 -> 1969;
1989 -> 971;
1990 -> 972;
1990 -> 1969;
1990 -> 1989;
1991 -> 973;
1991 -> 1969;
1991 -> 1990;
1992 -> 1207;
1992 -> 1990;
1993 -> 1183;
1993 -> 1990;
1994 -> 1990;
1995 -> 1992;
1995 -> 1994;
1996 -> 1993;
1996 -> 1994;
1997 -> 1993;
1997 -> 1994;
1998 -> 1995;
1998 -> 1994;
1999 -> 1997;
1999 -> 1969;
1999 -> 1984;
1999 -> 1998;
2000 -> 1999;
2000 -> 1969;
2000 -> 1998;
2001 -> 1996;
2001 -> 1998;
2001 -> 1969;
2001 -> 1984;
2002 -> 1998;
2003 -> 2001;
2003 -> 2002;
2003 -> 1998;
2004 -> 1996;
2004 -> 1998;
2004 -> 2001;
2004 -> 2003;
2005 -> 1999;
2005 -> 1969;
2005 -> 2003;
2006 -> 2004;
2006 -> 2005;
2006 -> 2003;
2007 -> 2006;
2007 -> 1998;
2008 -> 1990;
2009 -> 1206;
2009 -> 1990;
2010 -> 1103;
2010 -> 1990;
2011 -> 1183;
2011 -> 1990;
2012 -> 974;
2012 -> 2006;
2012 -> 1990;
2013 -> 1543;
2013 -> 1990;
2014 -> 1437;
2014 -> 1990;
2015 -> 2013;
2015 -> 1990;
2016 -> 1657;
2016 -> 1990;
2017 -> 1990;
2018 -> 1437;
2018 -> 2017;
2019 -> 2017;
2020 -> 2018;
2020 -> 2019;
2021 -> 2020;
2021 -> 2012;
2021 -> 2019;
2022 -> 2021;
2022 -> 2017;
2023 -> 2017;
2024 -> 1990;
2025 -> 2022;
2025 -> 2024;
2026 -> 2024;
2027 -> 2025;
2027 -> 2026;
2028 -> 2026;
2029 -> 2027;
2029 -> 2022;
2029 -> 2028;
2029 -> 2026;
2030 -> 2024;
2031 -> 2025;
2031 -> 2022;
2031 -> 2024;
2032 -> 1990;
2033 -> 1437;
2033 -> 2032;
2034 -> 2032;
2035 -> 2033;
2035 -> 2034;
2036 -> 2035;
2036 -> 2022;
2036 -> 2034;
2037 -> 2032;
2038 -> 1990;
2039 -> 2036;
2039 -> 2038;
2040 -> 2038;
2041 -> 2039;
2041 -> 2040;
2042 -> 2040;
2043 -> 2041;
2043 -> 2036;
2043 -> 2042;
2043 -> 2040;
2044 -> 2038;
2045 -> 2039;
2045 -> 2036;
2045 -> 2038;
2046 -> 973;
2046 -> 2009;
2046 -> 2010;
2046 -> 2011;
2046 -> 2012;
2046 -> 2015;
2046 -> 2016;
2046 -> 2031;
2046 -> 2045;
2046 -> 2036;
2046 -> 2022;
2046 -> 1103;
2046 -> 2006;
2046 -> 1657;
2046 -> 1206;
2046 -> 1990;
2047 -> 972;
2047 -> 2046;
2047 -> 1990;
2048 -> 973;
2048 -> 1990;
2049 -> 973;
2049 -> 972;
2049 -> 1990;
2050 -> 1437;
2050 -> 972;
2050 -> 1990;
2051 -> 971;
2052 -> 974;
2052 -> 2046;
2052 -> 2049;
2052 -> 2050;
2052 -> 971;
2053 -> 975;
2053 -> 2052;
2053 -> 971;
2054 -> 2051;
2054 -> 967;
2055 -> 969;
2055 -> 2053;
2055 -> 2054;
2055 -> 967;
2056 -> 969;
2056 -> 2053;
2056 -> 967;
2057 -> 968;
2057 -> 2056;
2057 -> 967;
2058 -> 965;
2059 -> 964;
2059 -> 2056;
2059 -> 965;
2060 -> 964;
2060 -> 2056;
2060 -> 963;
2061 -> 2060;
2061 -> 961;
2062 -> 962;
2062 -> 2056;
2062 -> 961;
2063 -> 962;
2063 -> 2062;
2063 -> 961;
2064 -> 2063;
2064 -> 959;
2065 -> 2064;
2065 -> 956;
2066 -> 956;
2067 -> 2065;
2067 -> 2066;
2068 -> 957;
2068 -> 2067;
2068 -> 954;
2068 -> 2062;
2068 -> 956;
2069 -> 956;
2070 -> 958;
2070 -> 2069;
2071 -> 2070;
2071 -> 2068;
2071 -> 2069;
2072 -> 2070;
2072 -> 2068;
2072 -> 2069;
2073 -> 2072;
2073 -> 956;
2074 -> 956;
2075 -> 2074;
2075 -> 2073;
2075 -> 2068;
2075 -> 956;
2076 -> 2074;
2076 -> 2075;
2077 -> 2073;
2077 -> 2076;
2077 -> 2074;
2078 -> 2076;
2079 -> 2077;
2079 -> 2078;
2080 -> 953;
2081 -> 952;
2081 -> 953;
2082 -> 953;
2083 -> 953;
2084 -> 2081;
2084 -> 2083;
2085 -> 2082;
2085 -> 2083;
2086 -> 0;
2086 -> 2085;
2086 -> 2083;
2087 -> 2084;
2087 -> 2085;
2087 -> 2083;
2088 -> 2082;
2088 -> 954;
2088 -> 2079;
2088 -> 953;
2089 -> 2088;
2089 -> 2082;
2090 -> 2082;
2091 -> 2089;
2091 -> 2088;
2091 -> 2090;
2091 -> 2082;
2092 -> 2091;
2093 -> 2089;
2093 -> 2091;
2094 -> 2091;
2095 -> 2089;
2095 -> 2094;
2096 -> 2094;
2097 -> 2095;
2097 -> 2088;
2097 -> 2096;
2098 -> 2097;
2098 -> 2088;
2098 -> 2096;
2099 -> 2098;
2099 -> 2094;
2100 -> 2099;
2100 -> 2091;
2101 -> 2091;
2102 -> 2100;
2102 -> 2101;
2103 -> 2101;
2104 -> 2102;
2104 -> 2103;
2105 -> 2104;
2105 -> 2101;
2106 -> 2102;
2106 -> 2101;
2107 -> 2101;
2109 -> 2108;
2111 -> 2110;
2112 -> 2092;
2112 -> 2091;
2113 -> 2091;
2114 -> 2091;
2115 -> 2093;
2115 -> 2114;
2116 -> 2093;
2116 -> 2114;
2117 -> 2105;
2117 -> 2114;
2118 -> 2112;
2118 -> 2114;
2119 -> 2113;
2119 -> 2114;
2120 -> 2114;
2121 -> 2119;
2121 -> 2114;
2122 -> 2119;
2122 -> 2114;
2123 -> 2119;
2123 -> 2114;
2124 -> 2119;
2124 -> 2114;
2125 -> 2119;
2125 -> 2114;
2126 -> 2119;
2126 -> 2114;
2129 -> 2128;
2129 -> 2127;
2131 -> 2130;
2131 -> 2127;
2132 -> 2127;
2135 -> 2134;
2135 -> 2133;
2137 -> 2136;
2137 -> 2133;
2138 -> 2133;
2140 -> 0;
2140 -> 2139;
2142 -> 0;
2142 -> 2141;
2143 -> 2142;
2143 -> 2139;
2144 -> 2139;
2146 -> 0;
2146 -> 2145;
2147 -> 0;
2147 -> 2145;
2148 -> 2145;
2149 -> 2138;
2149 -> 2119;
2149 -> 2114;
2150 -> 2114;
2151 -> 2117;
2151 -> 2150;
2151 -> 2114;
2152 -> 2115;
2152 -> 2119;
2152 -> 2114;
2153 -> 2116;
2153 -> 2119;
2153 -> 2114;
2154 -> 2117;
2154 -> 2119;
2154 -> 2114;
2155 -> 2117;
2155 -> 2105;
2155 -> 2114;
2156 -> 2155;
2156 -> 2105;
2157 -> 2118;
2157 -> 2156;
2157 -> 2092;
2157 -> 2105;
2157 -> 2155;
2158 -> 2092;
2158 -> 2157;
2158 -> 2091;
2159 -> 2092;
2159 -> 2157;
2159 -> 2091;
2160 -> 2089;
2160 -> 2159;
2160 -> 2091;
2161 -> 2113;
2161 -> 2091;
2162 -> 2091;
2163 -> 2160;
2163 -> 2161;
2163 -> 2162;
2163 -> 2119;
2163 -> 2152;
2163 -> 2153;
2163 -> 2154;
2163 -> 2124;
2163 -> 2125;
2163 -> 2126;
2163 -> 2149;
2163 -> 2159;
2163 -> 2135;
2163 -> 2137;
2163 -> 2133;
2163 -> 2091;
2164 -> 2089;
2164 -> 2163;
2164 -> 2082;
2165 -> 2088;
2165 -> 2082;
2166 -> 2165;
2166 -> 2082;
2167 -> 2166;
2167 -> 2164;
2167 -> 2082;
2168 -> 2088;
2168 -> 2082;
2169 -> 2168;
2169 -> 2167;
2169 -> 2082;
2170 -> 953;
2171 -> 2082;
2171 -> 2170;
2172 -> 2082;
2172 -> 2170;
2173 -> 2169;
2173 -> 2170;
2174 -> 2082;
2174 -> 2170;
2175 -> 2170;
2176 -> 2173;
2176 -> 2169;
2176 -> 2175;
2176 -> 2170;
2177 -> 2170;
2178 -> 2173;
2178 -> 2169;
2178 -> 2177;
2178 -> 2170;
2179 -> 2178;
2179 -> 2170;
2180 -> 2171;
2180 -> 2179;
2181 -> 2172;
2181 -> 2179;
2182 -> 2174;
2182 -> 2179;
2183 -> 2179;
2184 -> 2180;
2184 -> 2183;
2185 -> 2181;
2185 -> 2183;
2186 -> 2179;
2186 -> 2183;
2187 -> 2182;
2187 -> 2183;
2188 -> 2179;
2188 -> 2183;
2189 -> 2183;
2190 -> 2188;
2190 -> 2183;
2191 -> 2188;
2191 -> 2183;
2192 -> 2188;
2192 -> 2183;
2193 -> 2184;
2193 -> 2188;
2193 -> 2183;
2194 -> 2186;
2194 -> 2188;
2194 -> 2183;
2195 -> 2185;
2195 -> 2188;
2195 -> 2183;
2196 -> 2188;
2196 -> 2183;
2197 -> 0;
2197 -> 2183;
2198 -> 2196;
2198 -> 2188;
2198 -> 2183;
2199 -> 2187;
2199 -> 2188;
2199 -> 2183;
2200 -> 2186;
2200 -> 2183;
2201 -> 2200;
2202 -> 2200;
2202 -> 2201;
2203 -> 2202;
2203 -> 2201;
2204 -> 2203;
2204 -> 2200;
2205 -> 2200;
2206 -> 954;
2206 -> 2169;
2206 -> 953;
2207 -> 952;
2207 -> 2206;
2207 -> 953;
2208 -> 2179;
2208 -> 953;
2209 -> 953;
2210 -> 2207;
2210 -> 2208;
2210 -> 2209;
2210 -> 2188;
2210 -> 2195;
2210 -> 2199;
2210 -> 2198;
2210 -> 2193;
2210 -> 2194;
2210 -> 2206;
2210 -> 2086;
2210 -> 2087;
2210 -> 2169;
2210 -> 2196;
2210 -> 953;
2211 -> 952;
2211 -> 2210;
2211 -> 951;
2212 -> 2211;
2212 -> 1;
2213 -> 1;
2214 -> 1;
2215 -> 2213;
2215 -> 2214;
2216 -> 2212;
2216 -> 2214;
2217 -> 2216;
2217 -> 2210;
2217 -> 2215;
2217 -> 2214;
2218 -> 2214;
2219 -> 2217;
2219 -> 2218;
2220 -> 2217;
2220 -> 2218;
2221 -> 2218;
2222 -> 2218;
2223 -> 2220;
2223 -> 2217;
2223 -> 2218;
2224 -> 2219;
2224 -> 2223;
2225 -> 2223;
2226 -> 2224;
2226 -> 2225;
2227 -> 2223;
2227 -> 2225;
2228 -> 2225;
2229 -> 2228;
2229 -> 2225;
2230 -> 2225;
2231 -> 2227;
2231 -> 2230;
2232 -> 2230;
2233 -> 2231;
2233 -> 2217;
2233 -> 2232;
2233 -> 2230;
2234 -> 2233;
2235 -> 2231;
2235 -> 2217;
2235 -> 2233;
2236 -> 2234;
2236 -> 2233;
2237 -> 2233;
2238 -> 2236;
2238 -> 2237;
2239 -> 2231;
2239 -> 2237;
2240 -> 2239;
2240 -> 2217;
2240 -> 2237;
2241 -> 2237;
2242 -> 2240;
2242 -> 2241;
2243 -> 2240;
2243 -> 2241;
2244 -> 2242;
2244 -> 2241;
2245 -> 0;
2245 -> 2241;
2246 -> 2244;
2246 -> 2243;
2246 -> 2241;
2247 -> 2239;
2247 -> 2246;
2247 -> 2237;
2248 -> 2247;
2249 -> 2238;
2249 -> 2247;
2250 -> 2247;
2251 -> 2248;
2251 -> 2250;
2252 -> 2249;
2252 -> 2250;
2253 -> 2239;
2253 -> 2250;
2254 -> 2251;
2254 -> 2246;
2254 -> 2250;
2255 -> 2253;
2255 -> 2246;
2255 -> 2254;
2256 -> 2253;
2256 -> 2254;
2257 -> 2251;
2257 -> 2254;
2258 -> 2252;
2258 -> 2254;
2259 -> 2254;
2260 -> 2254;
2261 -> 2255;
2261 -> 2260;
2262 -> 2256;
2262 -> 2260;
2263 -> 2257;
2263 -> 2260;
2264 -> 2258;
2264 -> 2260;
2265 -> 2259;
2265 -> 2260;
2266 -> 2265;
2266 -> 2260;
2267 -> 2265;
2267 -> 2260;
2268 -> 2265;
2268 -> 2260;
2269 -> 2260;
2270 -> 2263;
2270 -> 2269;
2270 -> 2260;
2271 -> 2247;
2272 -> 2259;
2272 -> 2271;
2273 -> 2246;
2273 -> 2271;
2274 -> 2271;
2275 -> 2272;
2275 -> 2274;
2276 -> 2275;
2276 -> 2263;
2276 -> 2264;
2276 -> 2274;
2277 -> 2276;
2277 -> 2271;
2278 -> 2271;
2279 -> 2277;
2279 -> 2271;
2280 -> 2278;
2280 -> 2271;
2281 -> 2273;
2281 -> 2246;
2281 -> 2279;
2281 -> 2280;
2281 -> 2271;
2282 -> 2272;
2282 -> 2277;
2282 -> 2273;
2282 -> 2281;
2283 -> 2237;
2284 -> 2246;
2284 -> 2283;
2285 -> 2284;
2285 -> 2246;
2285 -> 2282;
2285 -> 2281;
2285 -> 2283;
2286 -> 0;
2286 -> 2283;
2287 -> 2284;
2287 -> 2246;
2287 -> 2282;
2287 -> 2283;
2288 -> 2287;
2288 -> 2281;
2289 -> 2287;
2290 -> 2289;
2290 -> 2287;
2291 -> 2288;
2291 -> 2287;
2292 -> 2287;
2293 -> 2291;
2293 -> 2292;
2293 -> 2287;
2294 -> 2288;
2294 -> 2293;
2295 -> 2293;
2296 -> 2294;
2296 -> 2295;
2297 -> 0;
2297 -> 2295;
2298 -> 2297;
2298 -> 2293;
2299 -> 2298;
2299 -> 2293;
2300 -> 2294;
2300 -> 2299;
2301 -> 2287;
2301 -> 2281;
2302 -> 2300;
2302 -> 2287;
2303 -> 2285;
2303 -> 2301;
2303 -> 2302;
2303 -> 2287;
2304 -> 2285;
2304 -> 2283;
2305 -> 2304;
2305 -> 2237;
2306 -> 2239;
2306 -> 2237;
2307 -> 2305;
2307 -> 2237;
2308 -> 2238;
2308 -> 2237;
2309 -> 2237;
2310 -> 2306;
2310 -> 2309;
2311 -> 2307;
2311 -> 2309;
2312 -> 2308;
2312 -> 2309;
2313 -> 2309;
2314 -> 2309;
2315 -> 2309;
2316 -> 2310;
2316 -> 2315;
2317 -> 2315;
2318 -> 2316;
2318 -> 2264;
2318 -> 2317;
2319 -> 2318;
2319 -> 2264;
2319 -> 2317;
2320 -> 2319;
2320 -> 2309;
2321 -> 2309;
2322 -> 2320;
2322 -> 2321;
2323 -> 2309;
2324 -> 2311;
2324 -> 2285;
2324 -> 2309;
2325 -> 2324;
2325 -> 2285;
2325 -> 2303;
2325 -> 2309;
2326 -> 2313;
2326 -> 2325;
2327 -> 2325;
2328 -> 2311;
2328 -> 2325;
2328 -> 2285;
2328 -> 2303;
2328 -> 2264;
2328 -> 2281;
2328 -> 2300;
2329 -> 2328;
2330 -> 2328;
2331 -> 2329;
2331 -> 2330;
2331 -> 2328;
2332 -> 2331;
2332 -> 2328;
2333 -> 2332;
2333 -> 2313;
2333 -> 2326;
2333 -> 2328;
2334 -> 2313;
2334 -> 2326;
2334 -> 2332;
2334 -> 2328;
2335 -> 2328;
2336 -> 2334;
2336 -> 2335;
2336 -> 2328;
2337 -> 2314;
2337 -> 2335;
2337 -> 2328;
2338 -> 2336;
2338 -> 2337;
2338 -> 2328;
2339 -> 2328;
2340 -> 2334;
2340 -> 2339;
2340 -> 2328;
2341 -> 2328;
2341 -> 2332;
2341 -> 2313;
2342 -> 2328;
2343 -> 2329;
2343 -> 2342;
2343 -> 2328;
2344 -> 2237;
2345 -> 2305;
2345 -> 2237;
2346 -> 2233;
2347 -> 2235;
2347 -> 2345;
2347 -> 2346;
2347 -> 2328;
2347 -> 2233;
2348 -> 2347;
2349 -> 2231;
2349 -> 2348;
2350 -> 2348;
2351 -> 2349;
2351 -> 2350;
2352 -> 2350;
2352 -> 2348;
2353 -> 2348;
2354 -> 2349;
2354 -> 2353;
2355 -> 2354;
2355 -> 2347;
2355 -> 2353;
2356 -> 2355;
2356 -> 2348;
2357 -> 2348;
2358 -> 2356;
2358 -> 2357;
2358 -> 2348;
2359 -> 2358;
2359 -> 2348;
2360 -> 2359;
2361 -> 2360;
2361 -> 2347;
2362 -> 2347;
2363 -> 2361;
2363 -> 2362;
2364 -> 2363;
2364 -> 2347;
2364 -> 2362;
2365 -> 2362;
2366 -> 2363;
2366 -> 2347;
2366 -> 2365;
2366 -> 2362;
2367 -> 2366;
2368 -> 2363;
2368 -> 2347;
2368 -> 2366;
2369 -> 2367;
2369 -> 2366;
2370 -> 2366;
2371 -> 2363;
2371 -> 2369;
2371 -> 2362;
2372 -> 2234;
2372 -> 2347;
2373 -> 2347;
2374 -> 2231;
2374 -> 2373;
2375 -> 2373;
2376 -> 2374;
2376 -> 2375;
2377 -> 2375;
2378 -> 2376;
2378 -> 2371;
2378 -> 2377;
2379 -> 2378;
2379 -> 2371;
2379 -> 2377;
2380 -> 2379;
2380 -> 2373;
2381 -> 2373;
2382 -> 2380;
2382 -> 2381;
2383 -> 2381;
2384 -> 2382;
2384 -> 2383;
2385 -> 2384;
2385 -> 2381;
2386 -> 2382;
2386 -> 2381;
2387 -> 2385;
2387 -> 2373;
2388 -> 2347;
2389 -> 2347;
2390 -> 2231;
2390 -> 2389;
2391 -> 2389;
2392 -> 2390;
2392 -> 2391;
2393 -> 2391;
2393 -> 2389;
2394 -> 2389;
2395 -> 2390;
2395 -> 2394;
2396 -> 2395;
2396 -> 2371;
2396 -> 2394;
2397 -> 2389;
2398 -> 2396;
2398 -> 2347;
2399 -> 2231;
2399 -> 2347;
2400 -> 2347;
2401 -> 2399;
2401 -> 2400;
2402 -> 2398;
2402 -> 2400;
2403 -> 2402;
2403 -> 2400;
2404 -> 2401;
2404 -> 2400;
2405 -> 2404;
2405 -> 2371;
2405 -> 2400;
2406 -> 2400;
2407 -> 2403;
2407 -> 2405;
2407 -> 2406;
2407 -> 2400;
2408 -> 2347;
2409 -> 0;
2409 -> 2347;
2410 -> 2347;
2411 -> 2409;
2411 -> 2410;
2412 -> 2231;
2412 -> 2407;
2412 -> 2410;
2413 -> 2412;
2413 -> 2407;
2413 -> 2410;
2414 -> 2411;
2414 -> 2410;
2415 -> 2413;
2415 -> 2414;
2415 -> 2410;
2416 -> 2415;
2416 -> 2347;
2417 -> 2234;
2417 -> 2407;
2417 -> 2415;
2417 -> 2233;
2418 -> 2231;
2418 -> 2417;
2418 -> 2230;
2419 -> 2418;
2419 -> 2225;
2420 -> 2226;
2420 -> 2225;
2421 -> 2228;
2421 -> 2225;
2422 -> 2419;
2422 -> 2420;
2422 -> 2421;
2422 -> 2417;
2422 -> 2229;
2422 -> 2225;
2423 -> 2422;
2423 -> 2225;
2424 -> 2423;
2425 -> 2423;
2425 -> 2424;
2426 -> 2424;
2426 -> 2423;
2427 -> 2426;
2428 -> 2427;
2428 -> 2221;
2428 -> 2426;
2429 -> 2423;
2429 -> 2426;
2430 -> 2428;
2430 -> 2429;
2430 -> 2427;
2430 -> 2423;
2430 -> 2426;
2431 -> 2430;
2432 -> 2430;
2433 -> 2430;
2434 -> 2432;
2434 -> 2433;
2435 -> 2433;
2436 -> 2434;
2436 -> 2430;
2436 -> 2435;
2436 -> 2433;
2437 -> 2436;
2438 -> 2436;
2439 -> 2434;
2439 -> 2430;
2439 -> 2438;
2440 -> 2439;
2440 -> 2430;
2440 -> 2438;
2441 -> 2440;
2441 -> 2436;
2442 -> 0;
2442 -> 2436;
2443 -> 2441;
2443 -> 2436;
2444 -> 2436;
2445 -> 2443;
2445 -> 2444;
2446 -> 2434;
2446 -> 2444;
2447 -> 2444;
2448 -> 2445;
2448 -> 2447;
2448 -> 2444;
2449 -> 2444;
2450 -> 2444;
2451 -> 2444;
2452 -> 2446;
2452 -> 2451;
2453 -> 2451;
2454 -> 2453;
2454 -> 2444;
2455 -> 2454;
2455 -> 2444;
2456 -> 2454;
2456 -> 2444;
2457 -> 2456;
2458 -> 2445;
2458 -> 2444;
2459 -> 0;
2459 -> 2444;
2460 -> 2449;
2460 -> 2444;
2461 -> 2450;
2461 -> 2444;
2462 -> 2455;
2462 -> 2457;
2462 -> 2458;
2462 -> 2459;
2462 -> 2460;
2462 -> 2461;
2462 -> 2441;
2462 -> 2444;
2463 -> 2462;
2463 -> 2444;
2464 -> 2444;
2465 -> 2463;
2465 -> 2464;
2466 -> 2446;
2466 -> 2464;
2467 -> 2464;
2468 -> 2466;
2468 -> 2462;
2468 -> 2467;
2468 -> 2464;
2469 -> 0;
2469 -> 2468;
2470 -> 2465;
2470 -> 2468;
2471 -> 2470;
2471 -> 2462;
2472 -> 2466;
2472 -> 2470;
2473 -> 2470;
2474 -> 2470;
2475 -> 2471;
2475 -> 2474;
2476 -> 2472;
2476 -> 2474;
2477 -> 2471;
2477 -> 2474;
2478 -> 2473;
2478 -> 2474;
2479 -> 2474;
2480 -> 2478;
2480 -> 2474;
2481 -> 2478;
2481 -> 2474;
2482 -> 2478;
2482 -> 2474;
2483 -> 2474;
2484 -> 2475;
2484 -> 2483;
2484 -> 2474;
2485 -> 2474;
2486 -> 2476;
2486 -> 2485;
2486 -> 2474;
2487 -> 2474;
2488 -> 2477;
2488 -> 2487;
2488 -> 2474;
2489 -> 2476;
2489 -> 2478;
2489 -> 2474;
2490 -> 2475;
2490 -> 2478;
2490 -> 2474;
2491 -> 2477;
2491 -> 2478;
2491 -> 2474;
2492 -> 2470;
2493 -> 2473;
2493 -> 2492;
2494 -> 2493;
2494 -> 2490;
2494 -> 2492;
2495 -> 2494;
2495 -> 2470;
2496 -> 2473;
2496 -> 2470;
2497 -> 2469;
2497 -> 2495;
2497 -> 2496;
2497 -> 2470;
2498 -> 2466;
2498 -> 2462;
2498 -> 2468;
2499 -> 2469;
2499 -> 2468;
2500 -> 2468;
2501 -> 2498;
2501 -> 2499;
2501 -> 2500;
2501 -> 2469;
2501 -> 2462;
2501 -> 2497;
2501 -> 2478;
2501 -> 2489;
2501 -> 2490;
2501 -> 2491;
2501 -> 2468;
2502 -> 2444;
2503 -> 2462;
2503 -> 2444;
2504 -> 2444;
2505 -> 2503;
2505 -> 2504;
2506 -> 2446;
2506 -> 2504;
2507 -> 2504;
2508 -> 2506;
2508 -> 2501;
2508 -> 2507;
2508 -> 2504;
2509 -> 2508;
2510 -> 2506;
2510 -> 2509;
2511 -> 2510;
2511 -> 2501;
2511 -> 2509;
2512 -> 2511;
2512 -> 2508;
2513 -> 2508;
2514 -> 2508;
2515 -> 2512;
2515 -> 2514;
2516 -> 2515;
2516 -> 2508;
2517 -> 2508;
2518 -> 2505;
2518 -> 2508;
2519 -> 2518;
2519 -> 2516;
2519 -> 2508;
2520 -> 2519;
2521 -> 2516;
2521 -> 2520;
2522 -> 2512;
2522 -> 2521;
2523 -> 2506;
2523 -> 2521;
2524 -> 2520;
2524 -> 2521;
2525 -> 0;
2526 -> 2525;
2527 -> 2526;
2529 -> 2528;
2530 -> 2529;
2530 -> 2528;
2531 -> 0;
2531 -> 2529;
2531 -> 2528;
2532 -> 0;
2532 -> 2529;
2532 -> 2528;
2533 -> 2529;
2533 -> 2528;
2534 -> 2529;
2534 -> 2528;
2535 -> 2529;
2535 -> 2528;
2536 -> 2529;
2536 -> 2528;
2538 -> 2537;
2539 -> 2537;
2540 -> 2539;
2541 -> 2539;
2543 -> 2542;
2545 -> 2544;
2547 -> 2546;
2549 -> 2548;
2551 -> 2549;
2551 -> 2550;
2552 -> 2551;
2554 -> 2553;
2556 -> 2555;
2558 -> 2557;
2560 -> 2559;
2570 -> 2562;
2570 -> 2561;
2571 -> 2563;
2571 -> 2561;
2572 -> 2564;
2572 -> 2561;
2573 -> 2565;
2573 -> 2561;
2574 -> 2566;
2574 -> 2561;
2575 -> 2567;
2575 -> 2561;
2576 -> 2568;
2576 -> 2561;
2577 -> 2569;
2577 -> 2561;
2578 -> 2561;
2579 -> 2541;
2579 -> 2539;
2580 -> 2579;
2580 -> 2540;
2581 -> 2540;
2583 -> 2582;
2585 -> 0;
2587 -> 2585;
2587 -> 2586;
2588 -> 2586;
2589 -> 2588;
2589 -> 2586;
2590 -> 2587;
2590 -> 2588;
2590 -> 2586;
2591 -> 2586;
2592 -> 0;
2594 -> 2592;
2594 -> 2593;
2595 -> 2593;
2596 -> 2595;
2596 -> 2593;
2597 -> 2594;
2597 -> 2595;
2597 -> 2593;
2598 -> 2593;
2599 -> 0;
2601 -> 2599;
2601 -> 2600;
2602 -> 2600;
2603 -> 2602;
2603 -> 2600;
2604 -> 2601;
2604 -> 2602;
2604 -> 2600;
2605 -> 2600;
2606 -> 0;
2608 -> 2606;
2608 -> 2607;
2609 -> 2607;
2610 -> 2609;
2610 -> 2607;
2611 -> 2608;
2611 -> 2609;
2611 -> 2607;
2612 -> 2607;
2613 -> 0;
2615 -> 2613;
2615 -> 2614;
2616 -> 2614;
2617 -> 2616;
2617 -> 2614;
2618 -> 2615;
2618 -> 2616;
2618 -> 2614;
2619 -> 2614;
2620 -> 0;
2622 -> 2620;
2622 -> 2621;
2623 -> 2621;
2624 -> 2623;
2624 -> 2621;
2625 -> 2622;
2625 -> 2623;
2625 -> 2621;
2626 -> 2621;
2627 -> 0;
2629 -> 2627;
2629 -> 2628;
2630 -> 2628;
2631 -> 2630;
2631 -> 2628;
2632 -> 2629;
2632 -> 2630;
2632 -> 2628;
2633 -> 2628;
2634 -> 0;
2636 -> 2634;
2636 -> 2635;
2637 -> 2635;
2638 -> 2637;
2638 -> 2635;
2639 -> 2636;
2639 -> 2637;
2639 -> 2635;
2640 -> 2635;
2641 -> 2640;
2643 -> 2584;
2643 -> 2641;
2643 -> 2642;
2643 -> 2637;
2643 -> 2638;
2643 -> 2639;
2644 -> 2643;
2646 -> 2645;
2647 -> 2646;
2647 -> 2645;
2648 -> 2646;
2648 -> 2645;
2649 -> 2646;
2649 -> 2645;
2650 -> 2645;
2652 -> 2651;
2653 -> 2581;
2654 -> 2653;
2655 -> 2654;
2656 -> 2655;
2656 -> 2654;
2657 -> 2653;
2657 -> 2581;
2658 -> 2653;
2658 -> 2581;
2659 -> 2581;
2659 -> 2540;
2660 -> 2581;
2660 -> 2540;
2661 -> 2581;
2661 -> 2540;
2662 -> 2580;
2662 -> 2581;
2662 -> 2540;
2663 -> 2539;
2663 -> 2537;
2664 -> 2538;
2664 -> 2539;
2664 -> 2537;
2665 -> 2537;
2666 -> 2665;
2666 -> 2529;
2666 -> 2528;
2667 -> 0;
2667 -> 2529;
2667 -> 2528;
2668 -> 2528;
2669 -> 2519;
2669 -> 2516;
2669 -> 2521;
2670 -> 2521;
2671 -> 2522;
2671 -> 2670;
2672 -> 2523;
2672 -> 2670;
2673 -> 2524;
2673 -> 2670;
2674 -> 2669;
2674 -> 2670;
2675 -> 2670;
2676 -> 2675;
2676 -> 2670;
2677 -> 2670;
2678 -> 2670;
2679 -> 2671;
2679 -> 2670;
2680 -> 2673;
2680 -> 2670;
2681 -> 2675;
2681 -> 2670;
2682 -> 2677;
2682 -> 2670;
2683 -> 2678;
2683 -> 2670;
2684 -> 2670;
2685 -> 2679;
2685 -> 2684;
2686 -> 2680;
2686 -> 2684;
2687 -> 2681;
2687 -> 2684;
2688 -> 2682;
2688 -> 2684;
2689 -> 2683;
2689 -> 2684;
2690 -> 2684;
2691 -> 2685;
2691 -> 2690;
2692 -> 2691;
2692 -> 2684;
2693 -> 2686;
2693 -> 2684;
2694 -> 2692;
2694 -> 2693;
2694 -> 2516;
2694 -> 2684;
2695 -> 2694;
2695 -> 2684;
2696 -> 2684;
2697 -> 2670;
2698 -> 2670;
2699 -> 2670;
2700 -> 2670;
2701 -> 2695;
2701 -> 2700;
2701 -> 2670;
2702 -> 2671;
2702 -> 2701;
2703 -> 2672;
2703 -> 2701;
2704 -> 2673;
2704 -> 2701;
2705 -> 2674;
2705 -> 2701;
2706 -> 2698;
2706 -> 2701;
2707 -> 2701;
2708 -> 2701;
2709 -> 2702;
2709 -> 2708;
2710 -> 2703;
2710 -> 2708;
2711 -> 2704;
2711 -> 2708;
2712 -> 2705;
2712 -> 2708;
2713 -> 2706;
2713 -> 2708;
2714 -> 2707;
2714 -> 2708;
2715 -> 2709;
2715 -> 2708;
2716 -> 2710;
2716 -> 2708;
2717 -> 2711;
2717 -> 2708;
2718 -> 2712;
2718 -> 2708;
2719 -> 2708;
2720 -> 2713;
2720 -> 2708;
2721 -> 2708;
2722 -> 2715;
2722 -> 2721;
2723 -> 2716;
2723 -> 2721;
2724 -> 2717;
2724 -> 2721;
2725 -> 2718;
2725 -> 2721;
2726 -> 2719;
2726 -> 2721;
2727 -> 2720;
2727 -> 2721;
2728 -> 2714;
2728 -> 2721;
2729 -> 2721;
2730 -> 2728;
2730 -> 2729;
2731 -> 2729;
2732 -> 2729;
2733 -> 2730;
2733 -> 2732;
2734 -> 2732;
2735 -> 2733;
2735 -> 2732;
2736 -> 2733;
2736 -> 2732;
2737 -> 2730;
2737 -> 2729;
2738 -> 2730;
2738 -> 2729;
2739 -> 2730;
2739 -> 2729;
2740 -> 2731;
2740 -> 2730;
2740 -> 2729;
2741 -> 2728;
2741 -> 2721;
2742 -> 2728;
2742 -> 2721;
2743 -> 2728;
2743 -> 2721;
2744 -> 2728;
2744 -> 2721;
2745 -> 2728;
2745 -> 2721;
2746 -> 2728;
2746 -> 2721;
2747 -> 2728;
2747 -> 2721;
2748 -> 2728;
2748 -> 2721;
2749 -> 2728;
2749 -> 2721;
2750 -> 2665;
2750 -> 2728;
2750 -> 2721;
2751 -> 2721;
2752 -> 2751;
2752 -> 2728;
2752 -> 2721;
2753 -> 2665;
2753 -> 2728;
2753 -> 2721;
2754 -> 2721;
2755 -> 2754;
2755 -> 2728;
2755 -> 2721;
2756 -> 2728;
2756 -> 2721;
2757 -> 0;
2757 -> 2728;
2757 -> 2721;
2758 -> 2728;
2758 -> 2721;
2759 -> 2728;
2759 -> 2721;
2760 -> 2724;
2760 -> 2516;
2760 -> 2721;
2761 -> 2721;
2762 -> 2723;
2762 -> 2761;
2762 -> 2721;
2763 -> 2721;
2764 -> 2726;
2764 -> 2763;
2764 -> 2721;
2765 -> 2721;
2766 -> 2721;
2767 -> 2721;
2768 -> 2722;
2768 -> 2767;
2769 -> 2768;
2769 -> 2721;
2770 -> 2724;
2770 -> 2721;
2771 -> 2769;
2771 -> 2770;
2771 -> 2694;
2771 -> 2516;
2771 -> 2721;
2772 -> 2724;
2772 -> 2728;
2772 -> 2721;
2773 -> 2723;
2773 -> 2728;
2773 -> 2721;
2774 -> 2721;
2775 -> 2722;
2775 -> 2774;
2776 -> 2775;
2776 -> 2771;
2776 -> 2774;
2777 -> 2776;
2777 -> 2721;
2778 -> 2724;
2778 -> 2721;
2779 -> 2777;
2779 -> 2728;
2779 -> 2721;
2780 -> 2721;
2781 -> 2726;
2781 -> 2780;
2781 -> 2721;
2782 -> 2771;
2782 -> 2728;
2782 -> 2781;
2783 -> 2781;
2784 -> 2721;
2785 -> 2725;
2785 -> 2784;
2785 -> 2721;
2786 -> 2721;
2787 -> 2722;
2787 -> 2786;
2788 -> 2787;
2788 -> 2777;
2788 -> 2786;
2789 -> 2788;
2789 -> 2721;
2790 -> 2721;
2791 -> 2789;
2791 -> 2790;
2792 -> 2790;
2793 -> 2791;
2793 -> 2792;
2794 -> 2793;
2794 -> 2790;
2795 -> 2791;
2795 -> 2790;
2796 -> 2791;
2796 -> 2777;
2796 -> 0;
2796 -> 2790;
2797 -> 2785;
2797 -> 2794;
2797 -> 2721;
2798 -> 2721;
2799 -> 2728;
2799 -> 2798;
2800 -> 0;
2800 -> 2798;
2801 -> 2799;
2801 -> 2779;
2801 -> 0;
2801 -> 2798;
2802 -> 0;
2802 -> 2801;
2803 -> 2802;
2803 -> 2798;
2804 -> 2803;
2804 -> 2721;
2805 -> 2797;
2805 -> 2804;
2805 -> 2721;
2806 -> 0;
2806 -> 2728;
2806 -> 2805;
2807 -> 2766;
2807 -> 2721;
2808 -> 2670;
2809 -> 2696;
2809 -> 2808;
2809 -> 2670;
2810 -> 2707;
2810 -> 2670;
2811 -> 2513;
2811 -> 2810;
2811 -> 2733;
2811 -> 2735;
2811 -> 2736;
2811 -> 2737;
2811 -> 2738;
2811 -> 2740;
2811 -> 2773;
2811 -> 2782;
2811 -> 2779;
2811 -> 2806;
2811 -> 2745;
2811 -> 2746;
2811 -> 2747;
2811 -> 2748;
2811 -> 2749;
2811 -> 2750;
2811 -> 2752;
2811 -> 2753;
2811 -> 2755;
2811 -> 2756;
2811 -> 2757;
2811 -> 2758;
2811 -> 2759;
2811 -> 2772;
2811 -> 2656;
2811 -> 2657;
2811 -> 2658;
2811 -> 2659;
2811 -> 2660;
2811 -> 2662;
2811 -> 2664;
2811 -> 2751;
2811 -> 2754;
2811 -> 0;
2811 -> 2516;
2811 -> 2777;
2811 -> 2521;
2812 -> 2811;
2813 -> 2812;
2813 -> 2811;
2814 -> 2811;
2815 -> 2811;
2816 -> 2812;
2816 -> 2811;
2817 -> 2814;
2817 -> 2811;
2818 -> 2815;
2818 -> 2811;
2819 -> 2811;
2820 -> 2811;
2821 -> 2811;
2822 -> 2811;
2823 -> 2820;
2823 -> 2811;
2824 -> 2811;
2825 -> 2822;
2825 -> 2824;
2826 -> 2822;
2826 -> 2824;
2827 -> 2822;
2827 -> 2824;
2828 -> 2822;
2828 -> 2824;
2829 -> 2822;
2829 -> 2824;
2830 -> 2822;
2830 -> 2824;
2831 -> 2823;
2831 -> 2824;
2832 -> 2822;
2832 -> 2824;
2833 -> 2825;
2833 -> 2824;
2834 -> 2826;
2834 -> 2824;
2835 -> 2827;
2835 -> 2824;
2836 -> 2828;
2836 -> 2824;
2837 -> 2830;
2837 -> 2824;
2838 -> 2831;
2838 -> 2824;
2839 -> 2824;
2840 -> 2833;
2840 -> 2839;
2841 -> 2834;
2841 -> 2839;
2842 -> 2835;
2842 -> 2839;
2843 -> 2836;
2843 -> 2839;
2844 -> 2837;
2844 -> 2839;
2845 -> 2838;
2845 -> 2839;
2846 -> 2832;
2846 -> 2839;
2847 -> 2832;
2847 -> 2839;
2848 -> 2832;
2848 -> 2839;
2849 -> 2832;
2849 -> 2839;
2850 -> 2832;
2850 -> 2839;
2851 -> 2842;
2851 -> 2811;
2851 -> 2839;
2852 -> 2839;
2853 -> 2841;
2853 -> 2852;
2853 -> 2839;
2854 -> 2839;
2855 -> 2844;
2855 -> 2854;
2855 -> 2839;
2856 -> 2839;
2857 -> 2839;
2858 -> 2840;
2858 -> 2842;
2858 -> 2811;
2858 -> 2839;
2859 -> 2858;
2859 -> 2844;
2860 -> 2844;
2861 -> 2859;
2861 -> 2832;
2861 -> 2844;
2862 -> 2832;
2862 -> 2861;
2862 -> 2844;
2863 -> 2858;
2863 -> 2844;
2864 -> 2832;
2864 -> 2861;
2864 -> 2858;
2864 -> 2844;
2865 -> 2832;
2865 -> 2861;
2865 -> 2844;
2866 -> 2858;
2866 -> 2844;
2867 -> 2843;
2867 -> 2858;
2867 -> 2839;
2868 -> 0;
2868 -> 2839;
2869 -> 2857;
2869 -> 2839;
2870 -> 2832;
2870 -> 2824;
2871 -> 2832;
2871 -> 2824;
2872 -> 2824;
2873 -> 2829;
2873 -> 2811;
2873 -> 2872;
2873 -> 2824;
2874 -> 2830;
2874 -> 2832;
2874 -> 2824;
2875 -> 2829;
2875 -> 2832;
2875 -> 2824;
2876 -> 2865;
2876 -> 2832;
2876 -> 2824;
2877 -> 2811;
2878 -> 2819;
2878 -> 2877;
2878 -> 2811;
2879 -> 2513;
2879 -> 2822;
2879 -> 2858;
2879 -> 2832;
2879 -> 2841;
2879 -> 2861;
2879 -> 2867;
2879 -> 2842;
2879 -> 2874;
2879 -> 2876;
2879 -> 2875;
2879 -> 2839;
2879 -> 2811;
2880 -> 2879;
2881 -> 2880;
2881 -> 2879;
2882 -> 2879;
2883 -> 2879;
2884 -> 2880;
2884 -> 2879;
2885 -> 2882;
2885 -> 2879;
2886 -> 2883;
2886 -> 2879;
2887 -> 2879;
2888 -> 2879;
2889 -> 2879;
2890 -> 2888;
2890 -> 2879;
2891 -> 2890;
2891 -> 2879;
2892 -> 2891;
2892 -> 2888;
2893 -> 2888;
2894 -> 2888;
2895 -> 2888;
2896 -> 2888;
2897 -> 2888;
2898 -> 2888;
2898 -> 2879;
2899 -> 2888;
2900 -> 2888;
2901 -> 2888;
2902 -> 2888;
2903 -> 2888;
2904 -> 0;
2904 -> 2888;
2905 -> 2902;
2905 -> 2888;
2906 -> 2888;
2906 -> 2879;
2907 -> 2888;
2907 -> 2879;
2908 -> 2879;
2909 -> 2879;
2910 -> 2887;
2910 -> 2909;
2910 -> 2879;
2911 -> 2888;
2912 -> 2911;
2912 -> 2888;
2913 -> 2888;
2914 -> 2888;
2915 -> 2911;
2915 -> 2888;
2916 -> 2913;
2916 -> 2888;
2917 -> 2914;
2917 -> 2888;
2918 -> 2888;
2919 -> 2888;
2920 -> 2888;
2921 -> 2920;
2921 -> 2888;
2922 -> 2921;
2922 -> 2888;
2923 -> 2888;
2924 -> 2888;
2925 -> 2888;
2926 -> 2918;
2926 -> 2925;
2926 -> 2888;
2927 -> 2911;
2928 -> 2927;
2928 -> 2911;
2929 -> 2928;
2929 -> 2911;
2930 -> 2911;
2931 -> 2911;
2932 -> 2911;
2933 -> 2911;
2934 -> 2911;
2935 -> 2911;
2935 -> 2888;
2936 -> 2911;
2937 -> 2911;
2938 -> 2911;
2939 -> 2911;
2940 -> 2911;
2941 -> 0;
2941 -> 2911;
2942 -> 2939;
2942 -> 2911;
2943 -> 2911;
2944 -> 2911;
2945 -> 2911;
2946 -> 2911;
2947 -> 2944;
2947 -> 2911;
2948 -> 2945;
2948 -> 2911;
2949 -> 2911;
2950 -> 2911;
2951 -> 2911;
2952 -> 2911;
2953 -> 2949;
2953 -> 2952;
2953 -> 2911;
2954 -> 2944;
2954 -> 2911;
2955 -> 2944;
2956 -> 2955;
2956 -> 2944;
2957 -> 2956;
2957 -> 2944;
2958 -> 2944;
2959 -> 2944;
2960 -> 2944;
2961 -> 2944;
2962 -> 2944;
2963 -> 2944;
2963 -> 2911;
2964 -> 2944;
2965 -> 2944;
2966 -> 2944;
2967 -> 2944;
2968 -> 2944;
2969 -> 0;
2969 -> 2944;
2970 -> 2967;
2970 -> 2944;
2971 -> 2508;
2972 -> 0;
2972 -> 2508;
2973 -> 2971;
2973 -> 2972;
2973 -> 2513;
2973 -> 2944;
2973 -> 2508;
2974 -> 2973;
2974 -> 2971;
2975 -> 2974;
2975 -> 2973;
2975 -> 2971;
2976 -> 2513;
2976 -> 2975;
2976 -> 2508;
2977 -> 2508;
2978 -> 2517;
2978 -> 2977;
2978 -> 2508;
2979 -> 2506;
2979 -> 2976;
2979 -> 2508;
2980 -> 2975;
2980 -> 2508;
2981 -> 2508;
2982 -> 2508;
2983 -> 2979;
2983 -> 2982;
2983 -> 2508;
2984 -> 2975;
2984 -> 2983;
2985 -> 2983;
2986 -> 2984;
2986 -> 2985;
2987 -> 2512;
2987 -> 2985;
2988 -> 2985;
2989 -> 2987;
2989 -> 2979;
2989 -> 2988;
2989 -> 2985;
2990 -> 2985;
2991 -> 2987;
2991 -> 2979;
2991 -> 2990;
2992 -> 2991;
2992 -> 2985;
2993 -> 2986;
2993 -> 2979;
2993 -> 2985;
2994 -> 2993;
2995 -> 2994;
2996 -> 2994;
2997 -> 2994;
2997 -> 2996;
2998 -> 2997;
2998 -> 2979;
2998 -> 2996;
2999 -> 2998;
2999 -> 2994;
3000 -> 2994;
3001 -> 2987;
3001 -> 2979;
3001 -> 2999;
3001 -> 3000;
3001 -> 2994;
3002 -> 3001;
3002 -> 2994;
3003 -> 2994;
3004 -> 2994;
3004 -> 3003;
3005 -> 3004;
3005 -> 3001;
3005 -> 3003;
3006 -> 3005;
3006 -> 2994;
3007 -> 2992;
3007 -> 3006;
3007 -> 2994;
3008 -> 3001;
3009 -> 3001;
3010 -> 3001;
3011 -> 3001;
3011 -> 3010;
3012 -> 3011;
3012 -> 3001;
3012 -> 3010;
3013 -> 3012;
3013 -> 3001;
3014 -> 2992;
3014 -> 3013;
3014 -> 3001;
3015 -> 2983;
3016 -> 2444;
3017 -> 2436;
3018 -> 2430;
3019 -> 2430;
3020 -> 2430;
3021 -> 3020;
3021 -> 2430;
3022 -> 2431;
3022 -> 2430;
3023 -> 3019;
3023 -> 2430;
3024 -> 2432;
3024 -> 3001;
3024 -> 3022;
3024 -> 3023;
3024 -> 2430;
3025 -> 2431;
3025 -> 3024;
3026 -> 3020;
3026 -> 3024;
3027 -> 2432;
3027 -> 3024;
3027 -> 3025;
3027 -> 3026;
3027 -> 3021;
3028 -> 0;
3028 -> 2430;
3029 -> 3027;
3030 -> 3027;
3031 -> 3027;
3032 -> 3027;
3033 -> 3027;
3034 -> 3027;
3035 -> 3027;
3036 -> 3027;
3037 -> 3027;
3038 -> 3027;
3039 -> 3027;
3040 -> 3027;
3041 -> 3027;
3042 -> 3027;
3043 -> 3040;
3043 -> 3027;
3044 -> 3027;
3045 -> 3027;
3046 -> 3027;
3047 -> 3046;
3047 -> 3027;
3048 -> 3047;
3048 -> 3027;
3049 -> 3027;
3050 -> 3027;
3051 -> 3027;
3052 -> 3027;
3053 -> 3027;
3054 -> 3027;
3055 -> 3027;
3056 -> 3027;
3057 -> 3027;
3058 -> 3027;
3059 -> 3027;
3060 -> 3058;
3060 -> 3027;
3061 -> 3027;
3062 -> 3044;
3062 -> 3061;
3062 -> 3027;
3063 -> 3040;
3063 -> 3027;
3064 -> 3040;
3064 -> 3027;
3065 -> 3040;
3066 -> 3065;
3066 -> 3040;
3067 -> 3066;
3067 -> 3040;
3068 -> 3040;
3069 -> 3040;
3070 -> 3040;
3071 -> 3040;
3072 -> 3040;
3073 -> 3040;
3073 -> 3027;
3074 -> 3040;
3075 -> 3040;
3076 -> 3040;
3077 -> 3040;
3078 -> 3040;
3079 -> 3077;
3079 -> 3040;
3080 -> 3040;
3081 -> 3040;
3082 -> 3040;
3083 -> 3040;
3084 -> 3040;
3085 -> 3040;
3086 -> 3040;
3087 -> 3040;
3088 -> 3084;
3088 -> 3087;
3088 -> 3040;
3089 -> 3027;
3090 -> 3038;
3090 -> 3089;
3090 -> 3027;
3091 -> 3040;
3092 -> 3040;
3093 -> 3092;
3093 -> 3040;
3094 -> 3040;
3095 -> 3040;
3096 -> 3093;
3096 -> 3040;
3097 -> 3027;
3098 -> 0;
3098 -> 3027;
3099 -> 3040;
3100 -> 3040;
3101 -> 3040;
3102 -> 3040;
3103 -> 3040;
3104 -> 3040;
3105 -> 3040;
3106 -> 3040;
3107 -> 3040;
3108 -> 3040;
3109 -> 3040;
3110 -> 3108;
3110 -> 3109;
3110 -> 3040;
3111 -> 3092;
3112 -> 3092;
3113 -> 3092;
3114 -> 3111;
3114 -> 3092;
3115 -> 3040;
3116 -> 0;
3116 -> 3040;
3117 -> 3092;
3118 -> 3092;
3119 -> 3092;
3120 -> 3092;
3121 -> 3092;
3122 -> 3092;
3123 -> 3092;
3124 -> 3092;
3125 -> 3092;
3126 -> 3092;
3127 -> 3092;
3128 -> 3092;
3129 -> 3092;
3130 -> 3092;
3131 -> 3092;
3132 -> 3092;
3133 -> 3092;
3134 -> 3133;
3134 -> 3092;
3135 -> 3134;
3135 -> 3092;
3136 -> 3092;
3137 -> 3092;
3138 -> 3092;
3139 -> 3092;
3140 -> 3092;
3141 -> 3092;
3142 -> 3092;
3143 -> 3092;
3144 -> 3092;
3145 -> 3092;
3146 -> 3092;
3147 -> 3145;
3147 -> 3092;
3148 -> 3092;
3149 -> 3131;
3149 -> 3148;
3149 -> 3092;
3150 -> 3092;
3151 -> 3126;
3151 -> 3150;
3151 -> 3092;
3152 -> 3092;
3153 -> 0;
3153 -> 3092;
3154 -> 2218;
3155 -> 2428;
3155 -> 3154;
3155 -> 2218;
3156 -> 2220;
3156 -> 3092;
3156 -> 3155;
3157 -> 2220;
3157 -> 3155;
3158 -> 2428;
3158 -> 3092;
3158 -> 3155;
3159 -> 3155;
3160 -> 3155;
3161 -> 3156;
3161 -> 3160;
3162 -> 3157;
3162 -> 3160;
3163 -> 3158;
3163 -> 3160;
3164 -> 3159;
3164 -> 3160;
3165 -> 3160;
3166 -> 3163;
3166 -> 3158;
3166 -> 3165;
3166 -> 3160;
3167 -> 2222;
3167 -> 3163;
3167 -> 3155;
3168 -> 2222;
3168 -> 3167;
3168 -> 2218;
3169 -> 1;
3170 -> 1;
3171 -> 3169;
3171 -> 3170;
3172 -> 3168;
3172 -> 3170;
3173 -> 3170;
3174 -> 3173;
3174 -> 3170;
3175 -> 3170;
3176 -> 3172;
3176 -> 3175;
3177 -> 3175;
3178 -> 3176;
3178 -> 3168;
3178 -> 3177;
3178 -> 3175;
3179 -> 3176;
3179 -> 3168;
3179 -> 3178;
3180 -> 3178;
3181 -> 3180;
3182 -> 3181;
3182 -> 3180;
3183 -> 3180;
3184 -> 3180;
3185 -> 3182;
3185 -> 3184;
3186 -> 3183;
3186 -> 3184;
3187 -> 3183;
3187 -> 3184;
3188 -> 3183;
3188 -> 3184;
3189 -> 3183;
3189 -> 3184;
3191 -> 3190;
3193 -> 3192;
3195 -> 3194;
3197 -> 3196;
3199 -> 3198;
3201 -> 3200;
3202 -> 0;
3204 -> 3191;
3204 -> 3203;
3205 -> 3193;
3205 -> 3203;
3206 -> 3195;
3206 -> 3203;
3207 -> 3197;
3207 -> 3203;
3208 -> 3199;
3208 -> 3203;
3209 -> 3201;
3209 -> 3203;
3210 -> 3202;
3210 -> 3203;
3211 -> 3203;
3212 -> 3211;
3212 -> 3203;
3213 -> 3211;
3213 -> 3203;
3214 -> 3211;
3214 -> 3203;
3215 -> 3211;
3215 -> 3203;
3216 -> 3211;
3216 -> 3203;
3217 -> 3211;
3217 -> 3203;
3218 -> 3211;
3218 -> 3203;
3219 -> 3205;
3219 -> 3203;
3220 -> 3203;
3221 -> 3204;
3221 -> 3211;
3221 -> 3203;
3222 -> 3205;
3222 -> 3211;
3222 -> 3203;
3223 -> 3206;
3223 -> 3211;
3223 -> 3203;
3224 -> 3207;
3224 -> 3211;
3224 -> 3203;
3225 -> 3208;
3225 -> 3211;
3225 -> 3203;
3226 -> 3209;
3226 -> 3211;
3226 -> 3203;
3227 -> 3210;
3227 -> 3211;
3227 -> 3203;
3228 -> 3211;
3228 -> 3227;
3228 -> 0;
3228 -> 3203;
3229 -> 3203;
3230 -> 3209;
3230 -> 3203;
3231 -> 3203;
3233 -> 3232;
3235 -> 3234;
3237 -> 3236;
3239 -> 3238;
3241 -> 3240;
3243 -> 3242;
3244 -> 0;
3246 -> 3233;
3246 -> 3245;
3247 -> 3235;
3247 -> 3245;
3248 -> 3237;
3248 -> 3245;
3249 -> 3239;
3249 -> 3245;
3250 -> 3241;
3250 -> 3245;
3251 -> 3243;
3251 -> 3245;
3252 -> 3244;
3252 -> 3245;
3253 -> 3245;
3254 -> 3253;
3254 -> 3245;
3255 -> 3253;
3255 -> 3245;
3256 -> 3253;
3256 -> 3245;
3257 -> 3253;
3257 -> 3245;
3258 -> 3253;
3258 -> 3245;
3259 -> 3253;
3259 -> 3245;
3260 -> 3253;
3260 -> 3245;
3261 -> 3247;
3261 -> 3246;
3261 -> 3245;
3262 -> 3245;
3263 -> 3246;
3263 -> 3253;
3263 -> 3245;
3264 -> 3247;
3264 -> 3253;
3264 -> 3245;
3265 -> 3248;
3265 -> 3253;
3265 -> 3245;
3266 -> 3249;
3266 -> 3253;
3266 -> 3245;
3267 -> 3250;
3267 -> 3253;
3267 -> 3245;
3268 -> 3251;
3268 -> 3253;
3268 -> 3245;
3269 -> 3252;
3269 -> 3253;
3269 -> 3245;
3270 -> 3253;
3270 -> 3269;
3270 -> 0;
3270 -> 3245;
3271 -> 3245;
3272 -> 3251;
3272 -> 3245;
3273 -> 3245;
3275 -> 3274;
3277 -> 3276;
3279 -> 3278;
3281 -> 3280;
3283 -> 3282;
3285 -> 3284;
3286 -> 0;
3288 -> 3275;
3288 -> 3287;
3289 -> 3277;
3289 -> 3287;
3290 -> 3279;
3290 -> 3287;
3291 -> 3281;
3291 -> 3287;
3292 -> 3283;
3292 -> 3287;
3293 -> 3285;
3293 -> 3287;
3294 -> 3286;
3294 -> 3287;
3295 -> 3287;
3296 -> 3295;
3296 -> 3287;
3297 -> 3295;
3297 -> 3287;
3298 -> 3295;
3298 -> 3287;
3299 -> 3295;
3299 -> 3287;
3300 -> 3295;
3300 -> 3287;
3301 -> 3295;
3301 -> 3287;
3302 -> 3295;
3302 -> 3287;
3303 -> 3289;
3303 -> 3288;
3303 -> 3287;
3304 -> 3287;
3305 -> 3288;
3305 -> 3295;
3305 -> 3287;
3306 -> 3289;
3306 -> 3295;
3306 -> 3287;
3307 -> 3290;
3307 -> 3295;
3307 -> 3287;
3308 -> 3291;
3308 -> 3295;
3308 -> 3287;
3309 -> 3292;
3309 -> 3295;
3309 -> 3287;
3310 -> 3293;
3310 -> 3295;
3310 -> 3287;
3311 -> 3294;
3311 -> 3295;
3311 -> 3287;
3312 -> 3295;
3312 -> 3311;
3312 -> 0;
3312 -> 3287;
3313 -> 3287;
3314 -> 3293;
3314 -> 3287;
3315 -> 3287;
3317 -> 3316;
3319 -> 3318;
3321 -> 3320;
3323 -> 3322;
3325 -> 3324;
3327 -> 3326;
3328 -> 0;
3330 -> 3317;
3330 -> 3329;
3331 -> 3319;
3331 -> 3329;
3332 -> 3321;
3332 -> 3329;
3333 -> 3323;
3333 -> 3329;
3334 -> 3325;
3334 -> 3329;
3335 -> 3327;
3335 -> 3329;
3336 -> 3328;
3336 -> 3329;
3337 -> 3329;
3338 -> 3337;
3338 -> 3329;
3339 -> 3337;
3339 -> 3329;
3340 -> 3337;
3340 -> 3329;
3341 -> 3337;
3341 -> 3329;
3342 -> 3337;
3342 -> 3329;
3343 -> 3337;
3343 -> 3329;
3344 -> 3337;
3344 -> 3329;
3345 -> 3331;
3345 -> 3330;
3345 -> 3329;
3346 -> 3329;
3347 -> 3330;
3347 -> 3337;
3347 -> 3329;
3348 -> 3331;
3348 -> 3337;
3348 -> 3329;
3349 -> 3332;
3349 -> 3337;
3349 -> 3329;
3350 -> 3333;
3350 -> 3337;
3350 -> 3329;
3351 -> 3334;
3351 -> 3337;
3351 -> 3329;
3352 -> 3335;
3352 -> 3337;
3352 -> 3329;
3353 -> 3336;
3353 -> 3337;
3353 -> 3329;
3354 -> 3337;
3354 -> 3353;
3354 -> 0;
3354 -> 3329;
3355 -> 3329;
3356 -> 3335;
3356 -> 3329;
3357 -> 3337;
3357 -> 3353;
3357 -> 0;
3357 -> 3356;
3358 -> 3357;
3358 -> 3337;
3358 -> 3356;
3359 -> 3329;
3361 -> 3360;
3363 -> 3362;
3365 -> 3364;
3367 -> 3366;
3369 -> 3368;
3371 -> 3370;
3372 -> 0;
3374 -> 3361;
3374 -> 3373;
3375 -> 3363;
3375 -> 3373;
3376 -> 3365;
3376 -> 3373;
3377 -> 3367;
3377 -> 3373;
3378 -> 3369;
3378 -> 3373;
3379 -> 3371;
3379 -> 3373;
3380 -> 3372;
3380 -> 3373;
3381 -> 3373;
3382 -> 3381;
3382 -> 3373;
3383 -> 3381;
3383 -> 3373;
3384 -> 3381;
3384 -> 3373;
3385 -> 3381;
3385 -> 3373;
3386 -> 3381;
3386 -> 3373;
3387 -> 3381;
3387 -> 3373;
3388 -> 3381;
3388 -> 3373;
3389 -> 3375;
3389 -> 3374;
3389 -> 3373;
3390 -> 3373;
3391 -> 3374;
3391 -> 3381;
3391 -> 3373;
3392 -> 3375;
3392 -> 3381;
3392 -> 3373;
3393 -> 3376;
3393 -> 3381;
3393 -> 3373;
3394 -> 3377;
3394 -> 3381;
3394 -> 3373;
3395 -> 3378;
3395 -> 3381;
3395 -> 3373;
3396 -> 3379;
3396 -> 3381;
3396 -> 3373;
3397 -> 3380;
3397 -> 3381;
3397 -> 3373;
3398 -> 3381;
3398 -> 3397;
3398 -> 0;
3398 -> 3373;
3399 -> 3373;
3400 -> 3379;
3400 -> 3373;
3401 -> 3373;
3403 -> 3402;
3405 -> 3404;
3407 -> 3406;
3409 -> 3408;
3411 -> 3410;
3413 -> 3412;
3414 -> 0;
3416 -> 3403;
3416 -> 3415;
3417 -> 3405;
3417 -> 3415;
3418 -> 3407;
3418 -> 3415;
3419 -> 3409;
3419 -> 3415;
3420 -> 3411;
3420 -> 3415;
3421 -> 3413;
3421 -> 3415;
3422 -> 3414;
3422 -> 3415;
3423 -> 3415;
3424 -> 3423;
3424 -> 3415;
3425 -> 3423;
3425 -> 3415;
3426 -> 3423;
3426 -> 3415;
3427 -> 3423;
3427 -> 3415;
3428 -> 3423;
3428 -> 3415;
3429 -> 3423;
3429 -> 3415;
3430 -> 3423;
3430 -> 3415;
3431 -> 3417;
3431 -> 3416;
3431 -> 3415;
3432 -> 3415;
3433 -> 3416;
3433 -> 3423;
3433 -> 3415;
3434 -> 3417;
3434 -> 3423;
3434 -> 3415;
3435 -> 3418;
3435 -> 3423;
3435 -> 3415;
3436 -> 3419;
3436 -> 3423;
3436 -> 3415;
3437 -> 3420;
3437 -> 3423;
3437 -> 3415;
3438 -> 3421;
3438 -> 3423;
3438 -> 3415;
3439 -> 3422;
3439 -> 3423;
3439 -> 3415;
3440 -> 3423;
3440 -> 3439;
3440 -> 0;
3440 -> 3415;
3441 -> 3415;
3442 -> 3421;
3442 -> 3415;
3443 -> 3415;
3445 -> 3444;
3447 -> 3446;
3449 -> 3448;
3451 -> 3450;
3453 -> 3452;
3455 -> 3454;
3456 -> 0;
3458 -> 3445;
3458 -> 3457;
3459 -> 3447;
3459 -> 3457;
3460 -> 3449;
3460 -> 3457;
3461 -> 3451;
3461 -> 3457;
3462 -> 3453;
3462 -> 3457;
3463 -> 3455;
3463 -> 3457;
3464 -> 3456;
3464 -> 3457;
3465 -> 3457;
3466 -> 3465;
3466 -> 3457;
3467 -> 3465;
3467 -> 3457;
3468 -> 3465;
3468 -> 3457;
3469 -> 3465;
3469 -> 3457;
3470 -> 3465;
3470 -> 3457;
3471 -> 3465;
3471 -> 3457;
3472 -> 3465;
3472 -> 3457;
3473 -> 3459;
3473 -> 3457;
3474 -> 3457;
3475 -> 3458;
3475 -> 3465;
3475 -> 3457;
3476 -> 3459;
3476 -> 3465;
3476 -> 3457;
3477 -> 3460;
3477 -> 3465;
3477 -> 3457;
3478 -> 3461;
3478 -> 3465;
3478 -> 3457;
3479 -> 3462;
3479 -> 3465;
3479 -> 3457;
3480 -> 3463;
3480 -> 3465;
3480 -> 3457;
3481 -> 3464;
3481 -> 3465;
3481 -> 3457;
3482 -> 3465;
3482 -> 3481;
3482 -> 0;
3482 -> 3457;
3483 -> 3457;
3484 -> 3463;
3484 -> 3457;
3485 -> 3457;
3487 -> 3486;
3489 -> 3488;
3491 -> 3490;
3493 -> 3492;
3495 -> 3494;
3497 -> 3496;
3498 -> 0;
3499 -> 3498;
3501 -> 3487;
3501 -> 3500;
3502 -> 3489;
3502 -> 3500;
3503 -> 3491;
3503 -> 3500;
3504 -> 3493;
3504 -> 3500;
3505 -> 3495;
3505 -> 3500;
3506 -> 3497;
3506 -> 3500;
3507 -> 3499;
3507 -> 3500;
3508 -> 3500;
3509 -> 3508;
3509 -> 3500;
3510 -> 3508;
3510 -> 3500;
3511 -> 3508;
3511 -> 3500;
3512 -> 3508;
3512 -> 3500;
3513 -> 3508;
3513 -> 3500;
3514 -> 3508;
3514 -> 3500;
3515 -> 3508;
3515 -> 3500;
3516 -> 3502;
3516 -> 3500;
3517 -> 3500;
3518 -> 3501;
3518 -> 3508;
3518 -> 3500;
3519 -> 3502;
3519 -> 3508;
3519 -> 3500;
3520 -> 3503;
3520 -> 3508;
3520 -> 3500;
3521 -> 3504;
3521 -> 3508;
3521 -> 3500;
3522 -> 3505;
3522 -> 3508;
3522 -> 3500;
3523 -> 3506;
3523 -> 3508;
3523 -> 3500;
3524 -> 3507;
3524 -> 3508;
3524 -> 3500;
3525 -> 3508;
3525 -> 3524;
3525 -> 0;
3525 -> 3500;
3526 -> 3500;
3527 -> 3506;
3527 -> 3500;
3528 -> 3508;
3528 -> 3524;
3528 -> 0;
3528 -> 3527;
3529 -> 3528;
3529 -> 3508;
3529 -> 3527;
3530 -> 3500;
3532 -> 3531;
3534 -> 3533;
3536 -> 3535;
3538 -> 3537;
3540 -> 3539;
3542 -> 3541;
3543 -> 0;
3545 -> 3532;
3545 -> 3544;
3546 -> 3534;
3546 -> 3544;
3547 -> 3536;
3547 -> 3544;
3548 -> 3538;
3548 -> 3544;
3549 -> 3540;
3549 -> 3544;
3550 -> 3542;
3550 -> 3544;
3551 -> 3543;
3551 -> 3544;
3552 -> 3544;
3553 -> 3552;
3553 -> 3544;
3554 -> 3552;
3554 -> 3544;
3555 -> 3552;
3555 -> 3544;
3556 -> 3552;
3556 -> 3544;
3557 -> 3552;
3557 -> 3544;
3558 -> 3552;
3558 -> 3544;
3559 -> 3552;
3559 -> 3544;
3560 -> 3546;
3560 -> 3544;
3561 -> 3544;
3562 -> 3545;
3562 -> 3552;
3562 -> 3544;
3563 -> 3546;
3563 -> 3552;
3563 -> 3544;
3564 -> 3547;
3564 -> 3552;
3564 -> 3544;
3565 -> 3548;
3565 -> 3552;
3565 -> 3544;
3566 -> 3549;
3566 -> 3552;
3566 -> 3544;
3567 -> 3550;
3567 -> 3552;
3567 -> 3544;
3568 -> 3551;
3568 -> 3552;
3568 -> 3544;
3569 -> 3552;
3569 -> 3568;
3569 -> 0;
3569 -> 3544;
3570 -> 3544;
3571 -> 3550;
3571 -> 3544;
3572 -> 3552;
3572 -> 3568;
3572 -> 0;
3572 -> 3571;
3573 -> 3572;
3573 -> 3552;
3573 -> 3571;
3574 -> 3544;
3576 -> 3575;
3578 -> 3577;
3580 -> 3579;
3582 -> 3581;
3584 -> 3583;
3586 -> 3585;
3587 -> 0;
3589 -> 3576;
3589 -> 3588;
3590 -> 3578;
3590 -> 3588;
3591 -> 3580;
3591 -> 3588;
3592 -> 3582;
3592 -> 3588;
3593 -> 3584;
3593 -> 3588;
3594 -> 3586;
3594 -> 3588;
3595 -> 3587;
3595 -> 3588;
3596 -> 3588;
3597 -> 3596;
3597 -> 3588;
3598 -> 3596;
3598 -> 3588;
3599 -> 3596;
3599 -> 3588;
3600 -> 3596;
3600 -> 3588;
3601 -> 3596;
3601 -> 3588;
3602 -> 3596;
3602 -> 3588;
3603 -> 3596;
3603 -> 3588;
3604 -> 3590;
3604 -> 3588;
3605 -> 3588;
3606 -> 3589;
3606 -> 3596;
3606 -> 3588;
3607 -> 3590;
3607 -> 3596;
3607 -> 3588;
3608 -> 3591;
3608 -> 3596;
3608 -> 3588;
3609 -> 3592;
3609 -> 3596;
3609 -> 3588;
3610 -> 3593;
3610 -> 3596;
3610 -> 3588;
3611 -> 3594;
3611 -> 3596;
3611 -> 3588;
3612 -> 3595;
3612 -> 3596;
3612 -> 3588;
3613 -> 3596;
3613 -> 3612;
3613 -> 0;
3613 -> 3588;
3614 -> 3588;
3615 -> 3594;
3615 -> 3588;
3616 -> 3588;
3618 -> 3617;
3620 -> 3619;
3622 -> 3621;
3624 -> 3623;
3626 -> 3625;
3628 -> 3627;
3629 -> 0;
3630 -> 3629;
3630 -> 0;
3631 -> 3630;
3633 -> 3618;
3633 -> 3632;
3634 -> 3620;
3634 -> 3632;
3635 -> 3622;
3635 -> 3632;
3636 -> 3624;
3636 -> 3632;
3637 -> 3626;
3637 -> 3632;
3638 -> 3628;
3638 -> 3632;
3639 -> 3631;
3639 -> 3632;
3640 -> 3632;
3641 -> 3640;
3641 -> 3632;
3642 -> 3640;
3642 -> 3632;
3643 -> 3640;
3643 -> 3632;
3644 -> 3640;
3644 -> 3632;
3645 -> 3640;
3645 -> 3632;
3646 -> 3640;
3646 -> 3632;
3647 -> 3640;
3647 -> 3632;
3648 -> 3634;
3648 -> 3632;
3649 -> 3632;
3650 -> 3633;
3650 -> 3640;
3650 -> 3632;
3651 -> 3634;
3651 -> 3640;
3651 -> 3632;
3652 -> 3635;
3652 -> 3640;
3652 -> 3632;
3653 -> 3636;
3653 -> 3640;
3653 -> 3632;
3654 -> 3637;
3654 -> 3640;
3654 -> 3632;
3655 -> 3638;
3655 -> 3640;
3655 -> 3632;
3656 -> 3639;
3656 -> 3640;
3656 -> 3632;
3657 -> 3640;
3657 -> 3656;
3657 -> 0;
3657 -> 3632;
3658 -> 3632;
3659 -> 3638;
3659 -> 3632;
3660 -> 3632;
3662 -> 3661;
3664 -> 3663;
3666 -> 3665;
3668 -> 3667;
3670 -> 3669;
3672 -> 3671;
3673 -> 0;
3674 -> 3673;
3674 -> 0;
3675 -> 3674;
3677 -> 3662;
3677 -> 3676;
3678 -> 3664;
3678 -> 3676;
3679 -> 3666;
3679 -> 3676;
3680 -> 3668;
3680 -> 3676;
3681 -> 3670;
3681 -> 3676;
3682 -> 3672;
3682 -> 3676;
3683 -> 3675;
3683 -> 3676;
3684 -> 3676;
3685 -> 3684;
3685 -> 3676;
3686 -> 3684;
3686 -> 3676;
3687 -> 3684;
3687 -> 3676;
3688 -> 3684;
3688 -> 3676;
3689 -> 3684;
3689 -> 3676;
3690 -> 3684;
3690 -> 3676;
3691 -> 3684;
3691 -> 3676;
3692 -> 3678;
3692 -> 3676;
3693 -> 3676;
3694 -> 3677;
3694 -> 3684;
3694 -> 3676;
3695 -> 3678;
3695 -> 3684;
3695 -> 3676;
3696 -> 3679;
3696 -> 3684;
3696 -> 3676;
3697 -> 3680;
3697 -> 3684;
3697 -> 3676;
3698 -> 3681;
3698 -> 3684;
3698 -> 3676;
3699 -> 3682;
3699 -> 3684;
3699 -> 3676;
3700 -> 3683;
3700 -> 3684;
3700 -> 3676;
3701 -> 3684;
3701 -> 3700;
3701 -> 0;
3701 -> 3676;
3702 -> 3676;
3703 -> 3682;
3703 -> 3676;
3704 -> 3684;
3704 -> 3700;
3704 -> 0;
3704 -> 3703;
3705 -> 3704;
3705 -> 3684;
3705 -> 3703;
3706 -> 3676;
3708 -> 3707;
3710 -> 3709;
3712 -> 3711;
3714 -> 3713;
3716 -> 3715;
3718 -> 3717;
3719 -> 0;
3720 -> 3719;
3720 -> 0;
3721 -> 3720;
3723 -> 3708;
3723 -> 3722;
3724 -> 3710;
3724 -> 3722;
3725 -> 3712;
3725 -> 3722;
3726 -> 3714;
3726 -> 3722;
3727 -> 3716;
3727 -> 3722;
3728 -> 3718;
3728 -> 3722;
3729 -> 3721;
3729 -> 3722;
3730 -> 3722;
3731 -> 3730;
3731 -> 3722;
3732 -> 3730;
3732 -> 3722;
3733 -> 3730;
3733 -> 3722;
3734 -> 3730;
3734 -> 3722;
3735 -> 3730;
3735 -> 3722;
3736 -> 3730;
3736 -> 3722;
3737 -> 3730;
3737 -> 3722;
3738 -> 3724;
3738 -> 3722;
3739 -> 3722;
3740 -> 3723;
3740 -> 3730;
3740 -> 3722;
3741 -> 3724;
3741 -> 3730;
3741 -> 3722;
3742 -> 3725;
3742 -> 3730;
3742 -> 3722;
3743 -> 3726;
3743 -> 3730;
3743 -> 3722;
3744 -> 3727;
3744 -> 3730;
3744 -> 3722;
3745 -> 3728;
3745 -> 3730;
3745 -> 3722;
3746 -> 3729;
3746 -> 3730;
3746 -> 3722;
3747 -> 3730;
3747 -> 3746;
3747 -> 0;
3747 -> 3722;
3748 -> 3722;
3749 -> 3728;
3749 -> 3722;
3750 -> 3730;
3750 -> 3746;
3750 -> 0;
3750 -> 3749;
3751 -> 3750;
3751 -> 3730;
3751 -> 3749;
3752 -> 3722;
3754 -> 3753;
3756 -> 3755;
3758 -> 3757;
3760 -> 3759;
3762 -> 3761;
3764 -> 3763;
3765 -> 0;
3766 -> 3765;
3766 -> 0;
3767 -> 3766;
3769 -> 3754;
3769 -> 3768;
3770 -> 3756;
3770 -> 3768;
3771 -> 3758;
3771 -> 3768;
3772 -> 3760;
3772 -> 3768;
3773 -> 3762;
3773 -> 3768;
3774 -> 3764;
3774 -> 3768;
3775 -> 3767;
3775 -> 3768;
3776 -> 3768;
3777 -> 3776;
3777 -> 3768;
3778 -> 3776;
3778 -> 3768;
3779 -> 3776;
3779 -> 3768;
3780 -> 3776;
3780 -> 3768;
3781 -> 3776;
3781 -> 3768;
3782 -> 3776;
3782 -> 3768;
3783 -> 3776;
3783 -> 3768;
3784 -> 3770;
3784 -> 3768;
3785 -> 3768;
3786 -> 3769;
3786 -> 3776;
3786 -> 3768;
3787 -> 3770;
3787 -> 3776;
3787 -> 3768;
3788 -> 3771;
3788 -> 3776;
3788 -> 3768;
3789 -> 3772;
3789 -> 3776;
3789 -> 3768;
3790 -> 3773;
3790 -> 3776;
3790 -> 3768;
3791 -> 3774;
3791 -> 3776;
3791 -> 3768;
3792 -> 3775;
3792 -> 3776;
3792 -> 3768;
3793 -> 3776;
3793 -> 3792;
3793 -> 0;
3793 -> 3768;
3794 -> 3768;
3795 -> 3774;
3795 -> 3768;
3796 -> 3768;
3798 -> 3797;
3800 -> 3799;
3802 -> 3801;
3804 -> 3803;
3806 -> 3805;
3808 -> 3807;
3809 -> 0;
3810 -> 3809;
3810 -> 0;
3811 -> 3810;
3813 -> 3798;
3813 -> 3812;
3814 -> 3800;
3814 -> 3812;
3815 -> 3802;
3815 -> 3812;
3816 -> 3804;
3816 -> 3812;
3817 -> 3806;
3817 -> 3812;
3818 -> 3808;
3818 -> 3812;
3819 -> 3811;
3819 -> 3812;
3820 -> 3812;
3821 -> 3820;
3821 -> 3812;
3822 -> 3820;
3822 -> 3812;
3823 -> 3820;
3823 -> 3812;
3824 -> 3820;
3824 -> 3812;
3825 -> 3820;
3825 -> 3812;
3826 -> 3820;
3826 -> 3812;
3827 -> 3820;
3827 -> 3812;
3828 -> 3814;
3828 -> 3813;
3828 -> 3812;
3829 -> 3812;
3830 -> 3813;
3830 -> 3820;
3830 -> 3812;
3831 -> 3814;
3831 -> 3820;
3831 -> 3812;
3832 -> 3815;
3832 -> 3820;
3832 -> 3812;
3833 -> 3816;
3833 -> 3820;
3833 -> 3812;
3834 -> 3817;
3834 -> 3820;
3834 -> 3812;
3835 -> 3818;
3835 -> 3820;
3835 -> 3812;
3836 -> 3819;
3836 -> 3820;
3836 -> 3812;
3837 -> 3820;
3837 -> 3836;
3837 -> 0;
3837 -> 3812;
3838 -> 3812;
3839 -> 3818;
3839 -> 3812;
3840 -> 3820;
3840 -> 3836;
3840 -> 0;
3840 -> 3839;
3841 -> 3840;
3841 -> 3820;
3841 -> 3839;
3842 -> 3812;
3844 -> 3843;
3846 -> 3845;
3848 -> 3847;
3850 -> 3849;
3852 -> 3851;
3854 -> 3853;
3855 -> 0;
3856 -> 3855;
3856 -> 0;
3857 -> 3856;
3859 -> 3844;
3859 -> 3858;
3860 -> 3846;
3860 -> 3858;
3861 -> 3848;
3861 -> 3858;
3862 -> 3850;
3862 -> 3858;
3863 -> 3852;
3863 -> 3858;
3864 -> 3854;
3864 -> 3858;
3865 -> 3857;
3865 -> 3858;
3866 -> 3858;
3867 -> 3866;
3867 -> 3858;
3868 -> 3866;
3868 -> 3858;
3869 -> 3866;
3869 -> 3858;
3870 -> 3866;
3870 -> 3858;
3871 -> 3866;
3871 -> 3858;
3872 -> 3866;
3872 -> 3858;
3873 -> 3866;
3873 -> 3858;
3874 -> 3860;
3874 -> 3859;
3874 -> 3858;
3875 -> 3858;
3876 -> 3859;
3876 -> 3866;
3876 -> 3858;
3877 -> 3860;
3877 -> 3866;
3877 -> 3858;
3878 -> 3861;
3878 -> 3866;
3878 -> 3858;
3879 -> 3862;
3879 -> 3866;
3879 -> 3858;
3880 -> 3863;
3880 -> 3866;
3880 -> 3858;
3881 -> 3864;
3881 -> 3866;
3881 -> 3858;
3882 -> 3865;
3882 -> 3866;
3882 -> 3858;
3883 -> 3866;
3883 -> 3882;
3883 -> 0;
3883 -> 3858;
3884 -> 3858;
3885 -> 3864;
3885 -> 3858;
3886 -> 3858;
3888 -> 3887;
3890 -> 3889;
3892 -> 3891;
3894 -> 3893;
3896 -> 3895;
3898 -> 3897;
3899 -> 0;
3900 -> 3899;
3900 -> 0;
3901 -> 3900;
3903 -> 3888;
3903 -> 3902;
3904 -> 3890;
3904 -> 3902;
3905 -> 3892;
3905 -> 3902;
3906 -> 3894;
3906 -> 3902;
3907 -> 3896;
3907 -> 3902;
3908 -> 3898;
3908 -> 3902;
3909 -> 3901;
3909 -> 3902;
3910 -> 3902;
3911 -> 3910;
3911 -> 3902;
3912 -> 3910;
3912 -> 3902;
3913 -> 3910;
3913 -> 3902;
3914 -> 3910;
3914 -> 3902;
3915 -> 3910;
3915 -> 3902;
3916 -> 3910;
3916 -> 3902;
3917 -> 3910;
3917 -> 3902;
3918 -> 3904;
3918 -> 3902;
3919 -> 3902;
3920 -> 3903;
3920 -> 3910;
3920 -> 3902;
3921 -> 3904;
3921 -> 3910;
3921 -> 3902;
3922 -> 3905;
3922 -> 3910;
3922 -> 3902;
3923 -> 3906;
3923 -> 3910;
3923 -> 3902;
3924 -> 3907;
3924 -> 3910;
3924 -> 3902;
3925 -> 3908;
3925 -> 3910;
3925 -> 3902;
3926 -> 3909;
3926 -> 3910;
3926 -> 3902;
3927 -> 3910;
3927 -> 3926;
3927 -> 0;
3927 -> 3902;
3928 -> 3902;
3929 -> 3908;
3929 -> 3902;
3930 -> 3902;
3932 -> 3931;
3934 -> 3933;
3936 -> 3935;
3938 -> 3937;
3940 -> 3939;
3942 -> 3941;
3943 -> 0;
3944 -> 3943;
3944 -> 0;
3945 -> 3944;
3947 -> 3932;
3947 -> 3946;
3948 -> 3934;
3948 -> 3946;
3949 -> 3936;
3949 -> 3946;
3950 -> 3938;
3950 -> 3946;
3951 -> 3940;
3951 -> 3946;
3952 -> 3942;
3952 -> 3946;
3953 -> 3945;
3953 -> 3946;
3954 -> 3946;
3955 -> 3954;
3955 -> 3946;
3956 -> 3954;
3956 -> 3946;
3957 -> 3954;
3957 -> 3946;
3958 -> 3954;
3958 -> 3946;
3959 -> 3954;
3959 -> 3946;
3960 -> 3954;
3960 -> 3946;
3961 -> 3954;
3961 -> 3946;
3962 -> 3948;
3962 -> 3946;
3963 -> 3946;
3964 -> 3947;
3964 -> 3954;
3964 -> 3946;
3965 -> 3948;
3965 -> 3954;
3965 -> 3946;
3966 -> 3949;
3966 -> 3954;
3966 -> 3946;
3967 -> 3950;
3967 -> 3954;
3967 -> 3946;
3968 -> 3951;
3968 -> 3954;
3968 -> 3946;
3969 -> 3952;
3969 -> 3954;
3969 -> 3946;
3970 -> 3953;
3970 -> 3954;
3970 -> 3946;
3971 -> 3954;
3971 -> 3970;
3971 -> 0;
3971 -> 3946;
3972 -> 3946;
3973 -> 3952;
3973 -> 3946;
3974 -> 3946;
3975 -> 3401;
3976 -> 3975;
3976 -> 3391;
3976 -> 3392;
3976 -> 3393;
3976 -> 3394;
3976 -> 3395;
3976 -> 3396;
3976 -> 3397;
3977 -> 3976;
3978 -> 0;
3979 -> 3978;
3980 -> 3979;
3981 -> 0;
3982 -> 3981;
3983 -> 0;
3984 -> 3983;
3985 -> 3185;
3985 -> 3184;
3986 -> 3186;
3986 -> 3184;
3987 -> 3187;
3987 -> 3184;
3988 -> 3188;
3988 -> 3184;
3989 -> 3184;
3990 -> 3985;
3990 -> 3989;
3991 -> 3986;
3991 -> 3989;
3992 -> 3987;
3992 -> 3989;
3993 -> 3988;
3993 -> 3989;
3994 -> 3189;
3994 -> 3989;
3995 -> 3993;
3995 -> 3989;
3996 -> 3989;
3997 -> 3995;
3997 -> 3996;
3998 -> 3994;
3998 -> 3996;
3999 -> 3994;
3999 -> 3989;
4000 -> 3994;
4000 -> 3989;
4001 -> 3994;
4001 -> 3989;
4003 -> 4002;
4004 -> 4003;
4004 -> 4002;
4005 -> 4003;
4005 -> 4002;
4006 -> 4003;
4006 -> 4002;
4007 -> 4003;
4007 -> 4002;
4008 -> 4003;
4008 -> 4002;
4009 -> 4003;
4009 -> 4002;
4010 -> 4002;
4011 -> 4010;
4011 -> 3994;
4011 -> 3989;
4012 -> 3994;
4012 -> 3989;
4013 -> 3994;
4013 -> 3989;
4014 -> 3994;
4014 -> 3989;
4015 -> 3994;
4015 -> 3989;
4016 -> 3994;
4016 -> 3989;
4017 -> 2138;
4017 -> 3994;
4017 -> 3989;
4018 -> 3994;
4018 -> 3989;
4019 -> 3994;
4019 -> 3989;
4020 -> 3990;
4020 -> 3994;
4020 -> 3989;
4021 -> 3991;
4021 -> 3994;
4021 -> 3989;
4022 -> 3991;
4022 -> 3180;
4022 -> 3989;
4023 -> 3989;
4024 -> 4022;
4024 -> 4023;
4025 -> 4024;
4025 -> 4023;
4026 -> 0;
4026 -> 4025;
4027 -> 4026;
4027 -> 3989;
4028 -> 3992;
4028 -> 3989;
4029 -> 3989;
4030 -> 4027;
4030 -> 4029;
4031 -> 4028;
4031 -> 4029;
4032 -> 3994;
4032 -> 4029;
4033 -> 4029;
4034 -> 4032;
4034 -> 4033;
4035 -> 4034;
4035 -> 4020;
4035 -> 4033;
4036 -> 4035;
4036 -> 4029;
4037 -> 4029;
4038 -> 0;
4038 -> 4029;
4039 -> 4029;
4040 -> 4036;
4040 -> 4039;
4041 -> 4039;
4041 -> 4029;
4042 -> 0;
4042 -> 4041;
4043 -> 4030;
4043 -> 4029;
4044 -> 0;
4044 -> 4043;
4045 -> 4038;
4045 -> 4044;
4045 -> 4043;
4046 -> 4043;
4047 -> 4032;
4047 -> 4046;
4048 -> 4046;
4049 -> 4047;
4049 -> 4021;
4049 -> 3180;
4049 -> 4048;
4049 -> 4046;
4050 -> 4049;
4050 -> 4043;
4051 -> 4045;
4051 -> 0;
4051 -> 4050;
4052 -> 4029;
4053 -> 4042;
4053 -> 4029;
4054 -> 4051;
4054 -> 4029;
4055 -> 4031;
4055 -> 4029;
4056 -> 4052;
4056 -> 4029;
4057 -> 4029;
4058 -> 4053;
4058 -> 4057;
4059 -> 4054;
4059 -> 4057;
4060 -> 4055;
4060 -> 4057;
4061 -> 4056;
4061 -> 4057;
4062 -> 4032;
4062 -> 4057;
4063 -> 4057;
4064 -> 0;
4064 -> 4057;
4065 -> 4062;
4065 -> 4021;
4065 -> 4049;
4065 -> 4057;
4066 -> 4057;
4067 -> 4057;
4068 -> 4067;
4068 -> 4065;
4068 -> 4057;
4069 -> 4062;
4069 -> 4021;
4069 -> 4049;
4069 -> 4067;
4069 -> 4068;
4070 -> 4069;
4070 -> 4068;
4071 -> 4068;
4072 -> 4063;
4072 -> 4068;
4073 -> 4070;
4073 -> 4072;
4074 -> 4059;
4074 -> 4072;
4075 -> 4062;
4075 -> 4021;
4075 -> 4069;
4075 -> 4067;
4075 -> 4072;
4076 -> 4060;
4076 -> 4072;
4077 -> 4072;
4078 -> 4063;
4078 -> 4072;
4079 -> 4072;
4080 -> 4073;
4080 -> 4079;
4081 -> 4074;
4081 -> 4079;
4082 -> 4075;
4082 -> 4079;
4083 -> 4076;
4083 -> 4079;
4084 -> 4077;
4084 -> 4079;
4085 -> 4078;
4085 -> 4079;
4086 -> 4079;
4087 -> 4080;
4087 -> 4081;
4087 -> 4079;
4088 -> 4080;
4088 -> 4081;
4088 -> 4079;
4089 -> 4087;
4089 -> 0;
4089 -> 4079;
4090 -> 4088;
4090 -> 0;
4090 -> 4079;
4091 -> 4079;
4092 -> 4088;
4092 -> 4079;
4093 -> 4086;
4093 -> 4072;
4094 -> 4092;
4094 -> 4093;
4095 -> 4062;
4095 -> 4093;
4096 -> 4093;
4097 -> 4093;
4098 -> 4094;
4098 -> 4097;
4099 -> 4095;
4099 -> 4097;
4100 -> 4096;
4100 -> 4097;
4101 -> 4098;
4101 -> 4097;
4102 -> 4097;
4103 -> 4101;
4103 -> 4102;
4104 -> 4103;
4104 -> 0;
4104 -> 4102;
4105 -> 4104;
4106 -> 4097;
4107 -> 4099;
4107 -> 4106;
4108 -> 0;
4108 -> 4106;
4109 -> 4108;
4109 -> 4097;
4110 -> 4100;
4110 -> 4109;
4110 -> 4097;
4111 -> 4098;
4111 -> 0;
4111 -> 4097;
4112 -> 4097;
4113 -> 4110;
4113 -> 4111;
4113 -> 4097;
4114 -> 4098;
4114 -> 0;
4114 -> 4113;
4115 -> 4097;
4116 -> 4115;
4116 -> 4093;
4117 -> 4093;
4118 -> 4116;
4118 -> 4117;
4118 -> 4093;
4119 -> 4064;
4119 -> 0;
4119 -> 4068;
4120 -> 4092;
4120 -> 4119;
4121 -> 4120;
4121 -> 0;
4121 -> 4057;
4122 -> 4057;
4123 -> 4066;
4123 -> 4057;
4124 -> 4057;
4125 -> 4062;
4125 -> 4124;
4126 -> 4125;
4126 -> 4021;
4126 -> 4075;
4126 -> 4124;
4127 -> 4126;
4127 -> 4057;
4128 -> 0;
4128 -> 4057;
4129 -> 4120;
4129 -> 4057;
4131 -> 4130;
4132 -> 4032;
4132 -> 4029;
4133 -> 4129;
4133 -> 4029;
4134 -> 4031;
4134 -> 4029;
4135 -> 4029;
4136 -> 4132;
4136 -> 4135;
4137 -> 4133;
4137 -> 4135;
4138 -> 4134;
4138 -> 4135;
4139 -> 4136;
4139 -> 4135;
4140 -> 4137;
4140 -> 4135;
4141 -> 4135;
4142 -> 4136;
4142 -> 4141;
4143 -> 4142;
4143 -> 4021;
4143 -> 4075;
4143 -> 4141;
4144 -> 4143;
4144 -> 4135;
4145 -> 4135;
4146 -> 4138;
4146 -> 4135;
4147 -> 4135;
4148 -> 4139;
4148 -> 4147;
4149 -> 4140;
4149 -> 4147;
4150 -> 4144;
4150 -> 4147;
4151 -> 4146;
4151 -> 4147;
4152 -> 4149;
4152 -> 0;
4152 -> 4147;
4153 -> 4029;
4154 -> 4129;
4154 -> 0;
4154 -> 4029;
4155 -> 4029;
4156 -> 4086;
4156 -> 4154;
4156 -> 4029;
4157 -> 0;
4157 -> 4029;
4158 -> 4129;
4158 -> 4157;
4158 -> 4029;
4159 -> 4086;
4159 -> 4158;
4159 -> 4029;
4160 -> 4030;
4160 -> 4029;
4161 -> 4129;
4161 -> 4029;
4162 -> 3991;
4162 -> 4144;
4162 -> 3989;
4163 -> 4162;
4163 -> 4144;
4164 -> 3992;
4164 -> 4163;
4164 -> 3180;
4164 -> 4144;
4164 -> 4162;
4165 -> 4161;
4165 -> 0;
4165 -> 3989;
4166 -> 3989;
4167 -> 4165;
4167 -> 4166;
4167 -> 3989;
4168 -> 4161;
4168 -> 3994;
4168 -> 3989;
4169 -> 4165;
4169 -> 0;
4169 -> 3989;
4170 -> 4169;
4170 -> 3989;
4171 -> 4170;
4172 -> 3994;
4172 -> 4171;
4173 -> 4171;
4174 -> 4172;
4174 -> 4173;
4175 -> 4174;
4175 -> 4020;
4175 -> 4173;
4176 -> 4175;
4176 -> 4171;
4177 -> 4171;
4178 -> 4176;
4178 -> 4177;
4179 -> 4177;
4179 -> 4171;
4180 -> 4171;
4181 -> 4172;
4181 -> 4180;
4182 -> 4181;
4182 -> 4020;
4182 -> 4180;
4183 -> 4182;
4183 -> 4171;
4184 -> 4171;
4185 -> 4183;
4185 -> 4184;
4186 -> 4184;
4187 -> 4185;
4187 -> 4164;
4187 -> 4186;
4188 -> 4187;
4188 -> 4164;
4188 -> 4186;
4189 -> 4171;
4190 -> 4188;
4190 -> 4189;
4191 -> 4179;
4191 -> 4190;
4191 -> 4171;
4192 -> 0;
4192 -> 4191;
4194 -> 4193;
4196 -> 4195;
4197 -> 4194;
4197 -> 4196;
4198 -> 4197;
4200 -> 4199;
4201 -> 4198;
4201 -> 4200;
4202 -> 4201;
4204 -> 4203;
4205 -> 4202;
4205 -> 4204;
4206 -> 4205;
4208 -> 4207;
4209 -> 4206;
4209 -> 4208;
4210 -> 4209;
4212 -> 4211;
4213 -> 4210;
4213 -> 4212;
4214 -> 4213;
4216 -> 4215;
4218 -> 4217;
4218 -> 4196;
4220 -> 4218;
4220 -> 4219;
4221 -> 4220;
4223 -> 4222;
4223 -> 4200;
4225 -> 4223;
4225 -> 4224;
4226 -> 4225;
4228 -> 4227;
4228 -> 4212;
4230 -> 4228;
4230 -> 4229;
4231 -> 4230;
4233 -> 4232;
4233 -> 4216;
4235 -> 4233;
4235 -> 4234;
4236 -> 4235;
4238 -> 4237;
4238 -> 4202;
4239 -> 4238;
4241 -> 4240;
4241 -> 4206;
4242 -> 4241;
4243 -> 4221;
4244 -> 4236;
4245 -> 4192;
4245 -> 3989;
4246 -> 4026;
4246 -> 3989;
4247 -> 3989;
4248 -> 3989;
4249 -> 4245;
4249 -> 4248;
4250 -> 4246;
4250 -> 4248;
4251 -> 4247;
4251 -> 4248;
4252 -> 4249;
4252 -> 4221;
4252 -> 4248;
4253 -> 4252;
4253 -> 4194;
4253 -> 4248;
4254 -> 4250;
4254 -> 4231;
4254 -> 4248;
4255 -> 4254;
4255 -> 4210;
4255 -> 4248;
4256 -> 4253;
4256 -> 4255;
4256 -> 4248;
4257 -> 4256;
4257 -> 4251;
4257 -> 4248;
4258 -> 4247;
4258 -> 3994;
4258 -> 3989;
4259 -> 3989;
4260 -> 3994;
4260 -> 4259;
4261 -> 4260;
4261 -> 4020;
4261 -> 4259;
4262 -> 4261;
4262 -> 3989;
4263 -> 4262;
4263 -> 3989;
4264 -> 3989;
4265 -> 0;
4265 -> 3989;
4266 -> 3989;
4267 -> 4265;
4267 -> 4266;
4268 -> 3994;
4268 -> 4266;
4269 -> 4268;
4269 -> 4267;
4269 -> 4266;
4270 -> 3189;
4270 -> 3184;
4271 -> 3189;
4271 -> 3184;
4272 -> 3189;
4272 -> 3184;
4273 -> 0;
4273 -> 3189;
4273 -> 3184;
4274 -> 3189;
4274 -> 3184;
4275 -> 2665;
4275 -> 3189;
4275 -> 3184;
4276 -> 3189;
4276 -> 3184;
4277 -> 2665;
4277 -> 3189;
4277 -> 3184;
4278 -> 3186;
4278 -> 4164;
4278 -> 3184;
4279 -> 3184;
4280 -> 3185;
4280 -> 4279;
4281 -> 4279;
4281 -> 3184;
4282 -> 3183;
4282 -> 3180;
4283 -> 4282;
4283 -> 4021;
4283 -> 4164;
4283 -> 3180;
4284 -> 4283;
4285 -> 4284;
4285 -> 4283;
4286 -> 4283;
4287 -> 0;
4287 -> 4283;
4288 -> 3180;
4289 -> 3180;
4290 -> 3180;
4291 -> 3180;
4292 -> 3180;
4293 -> 4288;
4293 -> 4292;
4294 -> 4292;
4295 -> 4293;
4295 -> 4164;
4295 -> 4294;
4296 -> 4295;
4296 -> 4164;
4296 -> 4294;
4297 -> 4296;
4297 -> 3180;
4298 -> 3180;
4299 -> 4297;
4299 -> 4298;
4300 -> 3180;
4301 -> 4290;
4301 -> 4287;
4302 -> 4287;
4303 -> 4287;
4304 -> 4287;
4305 -> 4303;
4305 -> 4304;
4305 -> 4287;
4306 -> 4305;
4306 -> 4287;
4307 -> 4306;
4308 -> 4303;
4308 -> 4307;
4309 -> 4308;
4309 -> 4287;
4309 -> 4307;
4310 -> 4309;
4310 -> 4290;
4310 -> 4301;
4310 -> 4287;
4311 -> 4290;
4311 -> 4301;
4311 -> 4309;
4311 -> 4287;
4312 -> 4287;
4313 -> 4311;
4313 -> 4312;
4313 -> 4287;
4314 -> 4291;
4314 -> 4312;
4314 -> 4287;
4315 -> 4313;
4315 -> 4314;
4315 -> 4287;
4316 -> 4287;
4317 -> 4311;
4317 -> 4316;
4317 -> 4287;
4318 -> 4287;
4318 -> 4309;
4318 -> 4290;
4319 -> 4287;
4320 -> 4303;
4320 -> 4319;
4320 -> 4287;
4321 -> 4320;
4322 -> 4303;
4322 -> 4321;
4323 -> 4322;
4323 -> 4287;
4323 -> 4321;
4324 -> 4321;
4325 -> 4323;
4325 -> 4324;
4326 -> 4325;
4326 -> 0;
4326 -> 4324;
4327 -> 0;
4327 -> 4326;
4328 -> 4327;
4328 -> 4320;
4329 -> 4328;
4329 -> 0;
4329 -> 4320;
4330 -> 4287;
4331 -> 4287;
4331 -> 4330;
4332 -> 4330;
4332 -> 4287;
4333 -> 4287;
4334 -> 4287;
4335 -> 3180;
4335 -> 4334;
4336 -> 4334;
4337 -> 4335;
4337 -> 4336;
4338 -> 4336;
4339 -> 4337;
4339 -> 4287;
4339 -> 4338;
4340 -> 4339;
4340 -> 4287;
4340 -> 4338;
4341 -> 4340;
4341 -> 4334;
4342 -> 4334;
4343 -> 4341;
4343 -> 4342;
4344 -> 4343;
4344 -> 4334;
4345 -> 4287;
4346 -> 4287;
4347 -> 4287;
4347 -> 3178;
4348 -> 3178;
4349 -> 4347;
4349 -> 4348;
4350 -> 0;
4350 -> 4348;
4351 -> 4349;
4351 -> 4348;
4352 -> 4351;
4352 -> 4287;
4353 -> 4351;
4354 -> 4351;
4355 -> 4352;
4355 -> 4351;
4356 -> 4355;
4357 -> 4355;
4357 -> 4356;
4358 -> 4356;
4358 -> 4355;
4359 -> 4358;
4360 -> 4354;
4360 -> 4358;
4361 -> 4359;
4361 -> 4351;
4362 -> 4354;
4362 -> 4361;
4363 -> 4351;
4363 -> 4287;
4363 -> 4362;
4364 -> 4352;
4364 -> 4287;
4364 -> 4362;
4365 -> 4350;
4365 -> 4363;
4365 -> 4364;
4365 -> 4362;
4366 -> 4350;
4366 -> 4348;
4367 -> 4366;
4367 -> 3178;
4368 -> 3178;
4369 -> 3179;
4369 -> 4367;
4369 -> 4368;
4369 -> 4350;
4369 -> 4364;
4369 -> 4365;
4369 -> 3178;
4370 -> 3176;
4370 -> 4369;
4370 -> 3175;
4371 -> 4370;
4371 -> 3170;
4372 -> 3171;
4372 -> 3170;
4373 -> 3173;
4373 -> 3170;
4374 -> 4371;
4374 -> 4372;
4374 -> 4373;
4374 -> 4369;
4374 -> 3174;
4374 -> 3170;
4375 -> 4374;
4375 -> 3170;
4376 -> 1;
4377 -> 1;
4378 -> 4376;
4378 -> 4377;
4379 -> 4375;
4379 -> 4377;
4380 -> 4377;
4381 -> 4380;
4381 -> 4377;
4382 -> 4377;
4383 -> 4379;
4383 -> 4382;
4384 -> 0;
4384 -> 4382;
4385 -> 4382;
4386 -> 4384;
4386 -> 4385;
4387 -> 4383;
4387 -> 4375;
4387 -> 4385;
4388 -> 4387;
4388 -> 4375;
4388 -> 4386;
4388 -> 4385;
4389 -> 4382;
4390 -> 4383;
4390 -> 4389;
4391 -> 4389;
4392 -> 4390;
4392 -> 4375;
4392 -> 4391;
4392 -> 4389;
4393 -> 4392;
4394 -> 4393;
4394 -> 4392;
4395 -> 4392;
4396 -> 4394;
4396 -> 4395;
4397 -> 4390;
4397 -> 4395;
4398 -> 4395;
4399 -> 4395;
4400 -> 4397;
4400 -> 4399;
4401 -> 4400;
4401 -> 4375;
4401 -> 4399;
4402 -> 4399;
4403 -> 4401;
4403 -> 4402;
4403 -> 4399;
4404 -> 4399;
4405 -> 4404;
4405 -> 4399;
4406 -> 4399;
4407 -> 4405;
4407 -> 4406;
4408 -> 4400;
4408 -> 4406;
4409 -> 4406;
4410 -> 4408;
4410 -> 4409;
4411 -> 4410;
4411 -> 4375;
4411 -> 4409;
4412 -> 4411;
4412 -> 4010;
4412 -> 4409;
4413 -> 4410;
4413 -> 4375;
4413 -> 4409;
4414 -> 4409;
4415 -> 4414;
4415 -> 4409;
4416 -> 4409;
4417 -> 4415;
4417 -> 4416;
4418 -> 4410;
4418 -> 4416;
4419 -> 4416;
4420 -> 4416;
4421 -> 4419;
4421 -> 4420;
4422 -> 4420;
4423 -> 4422;
4423 -> 4421;
4423 -> 4420;
4424 -> 4420;
4425 -> 4424;
4425 -> 4421;
4425 -> 4420;
4426 -> 4420;
4427 -> 4426;
4427 -> 4421;
4427 -> 4420;
4428 -> 4421;
4428 -> 4420;
4429 -> 4421;
4429 -> 4420;
4430 -> 4421;
4430 -> 4420;
4431 -> 4420;
4432 -> 4431;
4432 -> 4421;
4432 -> 4420;
4433 -> 4421;
4433 -> 4420;
4434 -> 4421;
4434 -> 4420;
4435 -> 4419;
4435 -> 4416;
4436 -> 4417;
4436 -> 4416;
4437 -> 4416;
4438 -> 4435;
4438 -> 4437;
4439 -> 4436;
4439 -> 4437;
4440 -> 4418;
4440 -> 4437;
4441 -> 4440;
4441 -> 4413;
4441 -> 4437;
4442 -> 4441;
4442 -> 4413;
4443 -> 4441;
4444 -> 4441;
4445 -> 4444;
4445 -> 4441;
4446 -> 4444;
4446 -> 4445;
4447 -> 4438;
4447 -> 4445;
4448 -> 4445;
4449 -> 4446;
4449 -> 4445;
4450 -> 4439;
4450 -> 4445;
4451 -> 4445;
4452 -> 4447;
4452 -> 4451;
4453 -> 4448;
4453 -> 4451;
4454 -> 4449;
4454 -> 4451;
4455 -> 4450;
4455 -> 4451;
4456 -> 4440;
4456 -> 4451;
4457 -> 4451;
4458 -> 4454;
4458 -> 4445;
4458 -> 4457;
4458 -> 4451;
4459 -> 4451;
4460 -> 4454;
4460 -> 4459;
4460 -> 4445;
4460 -> 4451;
4461 -> 4460;
4461 -> 4451;
4462 -> 4451;
4463 -> 4461;
4463 -> 4462;
4464 -> 4456;
4464 -> 4462;
4465 -> 4462;
4466 -> 4464;
4466 -> 4465;
4467 -> 4465;
4468 -> 4466;
4468 -> 4467;
4469 -> 4467;
4469 -> 4465;
4470 -> 4466;
4470 -> 4465;
4471 -> 4465;
4472 -> 4470;
4472 -> 4471;
4473 -> 4472;
4473 -> 4460;
4473 -> 4471;
4474 -> 4473;
4474 -> 4465;
4475 -> 4465;
4476 -> 4474;
4476 -> 4475;
4476 -> 4465;
4477 -> 4476;
4477 -> 4465;
4478 -> 4477;
4479 -> 4478;
4479 -> 4462;
4480 -> 4463;
4480 -> 4462;
4481 -> 4462;
4482 -> 4480;
4482 -> 4481;
4483 -> 4479;
4483 -> 4481;
4484 -> 4482;
4484 -> 4460;
4484 -> 4481;
4485 -> 4481;
4486 -> 4481;
4487 -> 4484;
4487 -> 4486;
4488 -> 4485;
4488 -> 4486;
4489 -> 4483;
4489 -> 4486;
4490 -> 4488;
4490 -> 4486;
4491 -> 4487;
4491 -> 4486;
4492 -> 4486;
4493 -> 4489;
4493 -> 4460;
4493 -> 4486;
4494 -> 4486;
4495 -> 4491;
4495 -> 4494;
4496 -> 4492;
4496 -> 4494;
4497 -> 4493;
4497 -> 4494;
4498 -> 4489;
4498 -> 4494;
4499 -> 4497;
4499 -> 4494;
4500 -> 4496;
4500 -> 4494;
4501 -> 4498;
4501 -> 4460;
4501 -> 4500;
4502 -> 4498;
4502 -> 4460;
4502 -> 4501;
4502 -> 4494;
4503 -> 4499;
4503 -> 4502;
4503 -> 4460;
4503 -> 4501;
4503 -> 4494;
4504 -> 4495;
4504 -> 4494;
4505 -> 4494;
4506 -> 4504;
4506 -> 4505;
4507 -> 4498;
4507 -> 4505;
4508 -> 4506;
4508 -> 4505;
4509 -> 4505;
4510 -> 4508;
4510 -> 4509;
4511 -> 4507;
4511 -> 4509;
4512 -> 4509;
4513 -> 4510;
4513 -> 4512;
4513 -> 4509;
4514 -> 4511;
4514 -> 4503;
4514 -> 4509;
4515 -> 4510;
4515 -> 4509;
4516 -> 4514;
4516 -> 4515;
4516 -> 4509;
4517 -> 4507;
4517 -> 4516;
4517 -> 4505;
4518 -> 4503;
4518 -> 4494;
4519 -> 4494;
4520 -> 4518;
4520 -> 4519;
4520 -> 4494;
4521 -> 4520;
4522 -> 4521;
4522 -> 4517;
4523 -> 4522;
4523 -> 4520;
4524 -> 4503;
4524 -> 4520;
4525 -> 4523;
4525 -> 4520;
4526 -> 4520;
4527 -> 4494;
4528 -> 4525;
4528 -> 4517;
4528 -> 4494;
4529 -> 4494;
4530 -> 4528;
4530 -> 4529;
4530 -> 4494;
4531 -> 4495;
4531 -> 4494;
4532 -> 4496;
4532 -> 4494;
4533 -> 4525;
4533 -> 4517;
4533 -> 4494;
4534 -> 4494;
4535 -> 4531;
4535 -> 4534;
4536 -> 4532;
4536 -> 4534;
4537 -> 4533;
4537 -> 4534;
4538 -> 4498;
4538 -> 4534;
4539 -> 4538;
4539 -> 4534;
4540 -> 4535;
4540 -> 4534;
4541 -> 4536;
4541 -> 4534;
4542 -> 4534;
4543 -> 4534;
4544 -> 4539;
4544 -> 4543;
4545 -> 4540;
4545 -> 4543;
4546 -> 4541;
4546 -> 4543;
4547 -> 4542;
4547 -> 4543;
4548 -> 4547;
4548 -> 4543;
4549 -> 4547;
4549 -> 4543;
4550 -> 4547;
4550 -> 4543;
4551 -> 4547;
4551 -> 4543;
4552 -> 4547;
4552 -> 4543;
4553 -> 4547;
4553 -> 4543;
4554 -> 4544;
4554 -> 4547;
4554 -> 4543;
4555 -> 4545;
4555 -> 4547;
4555 -> 4543;
4556 -> 4546;
4556 -> 4547;
4556 -> 4543;
4557 -> 4547;
4557 -> 4543;
4558 -> 4543;
4559 -> 4557;
4559 -> 4558;
4559 -> 4548;
4559 -> 4554;
4559 -> 4555;
4559 -> 4551;
4559 -> 4556;
4559 -> 4553;
4559 -> 4525;
4559 -> 4543;
4560 -> 4559;
4560 -> 4547;
4560 -> 4543;
4561 -> 4543;
4562 -> 4561;
4562 -> 4547;
4562 -> 4543;
4563 -> 4544;
4563 -> 4543;
4564 -> 4543;
4565 -> 4543;
4566 -> 4563;
4566 -> 4565;
4567 -> 4564;
4567 -> 4565;
4569 -> 4568;
4571 -> 4570;
4573 -> 4572;
4576 -> 4575;
4577 -> 0;
4578 -> 0;
4579 -> 0;
4580 -> 4579;
4582 -> 4577;
4582 -> 4578;
4582 -> 4580;
4582 -> 4581;
4583 -> 4582;
4585 -> 4584;
4587 -> 4586;
4589 -> 4588;
4591 -> 4590;
4592 -> 4566;
4592 -> 4565;
4593 -> 4565;
4594 -> 4592;
4594 -> 4593;
4595 -> 4567;
4595 -> 4593;
4596 -> 4595;
4596 -> 4593;
4597 -> 4595;
4597 -> 4593;
4598 -> 4595;
4598 -> 4593;
4599 -> 4595;
4599 -> 4593;
4600 -> 4595;
4600 -> 4593;
4601 -> 4593;
4602 -> 4594;
4602 -> 4601;
4602 -> 4593;
4603 -> 4595;
4603 -> 4593;
4604 -> 4603;
4604 -> 4596;
4604 -> 4597;
4604 -> 4598;
4604 -> 4599;
4604 -> 4600;
4604 -> 4593;
4605 -> 4593;
4606 -> 4594;
4606 -> 4605;
4607 -> 4606;
4607 -> 4559;
4607 -> 4605;
4608 -> 4607;
4608 -> 4593;
4609 -> 4608;
4609 -> 4559;
4609 -> 4595;
4609 -> 4593;
4610 -> 4594;
4610 -> 4595;
4610 -> 4593;
4611 -> 4564;
4611 -> 4547;
4611 -> 4543;
4612 -> 4542;
4612 -> 4534;
4613 -> 4612;
4613 -> 4559;
4613 -> 4560;
4613 -> 4562;
4613 -> 4611;
4613 -> 4561;
4613 -> 4604;
4613 -> 4609;
4613 -> 4610;
4613 -> 4534;
4614 -> 4534;
4615 -> 4614;
4616 -> 4537;
4616 -> 4614;
4617 -> 4614;
4618 -> 4616;
4618 -> 4617;
4618 -> 4614;
4619 -> 4537;
4619 -> 4614;
4620 -> 4613;
4620 -> 4614;
4621 -> 4616;
4621 -> 4614;
4622 -> 4619;
4622 -> 4620;
4622 -> 4621;
4622 -> 4613;
4622 -> 4614;
4623 -> 4542;
4623 -> 4622;
4624 -> 4482;
4624 -> 4481;
4625 -> 4481;
4626 -> 4624;
4626 -> 4625;
4627 -> 4485;
4627 -> 4625;
4628 -> 4485;
4628 -> 4625;
4629 -> 4623;
4629 -> 4625;
4630 -> 4626;
4630 -> 4622;
4630 -> 4625;
4631 -> 4625;
4632 -> 4629;
4632 -> 4631;
4633 -> 4632;
4633 -> 4622;
4633 -> 4525;
4633 -> 0;
4633 -> 4631;
4634 -> 4633;
4634 -> 4625;
4635 -> 4625;
4636 -> 4626;
4636 -> 4622;
4636 -> 4635;
4636 -> 4625;
4637 -> 4634;
4637 -> 4636;
4637 -> 4625;
4638 -> 4626;
4638 -> 4622;
4638 -> 4637;
4639 -> 4638;
4639 -> 4625;
4640 -> 4630;
4640 -> 4625;
4641 -> 4627;
4641 -> 4625;
4642 -> 4628;
4642 -> 4625;
4643 -> 4625;
4644 -> 4639;
4644 -> 4643;
4645 -> 4640;
4645 -> 4643;
4646 -> 4641;
4646 -> 4643;
4647 -> 4642;
4647 -> 4643;
4648 -> 4629;
4648 -> 4643;
4649 -> 4643;
4650 -> 4644;
4650 -> 4649;
4650 -> 4643;
4651 -> 4647;
4651 -> 4643;
4652 -> 4648;
4652 -> 4622;
4652 -> 4643;
4653 -> 4648;
4653 -> 4622;
4653 -> 4525;
4653 -> 4643;
4654 -> 4643;
4655 -> 4653;
4655 -> 4654;
4656 -> 4652;
4656 -> 4654;
4657 -> 4654;
4658 -> 4657;
4658 -> 4654;
4659 -> 4657;
4659 -> 4654;
4660 -> 4657;
4660 -> 4654;
4661 -> 4657;
4661 -> 4654;
4662 -> 4655;
4662 -> 4657;
4662 -> 4654;
4663 -> 4653;
4663 -> 4652;
4663 -> 4657;
4663 -> 4658;
4663 -> 4659;
4663 -> 4660;
4663 -> 4661;
4663 -> 4662;
4663 -> 4643;
4664 -> 4645;
4664 -> 4643;
4665 -> 4646;
4665 -> 4643;
4666 -> 4647;
4666 -> 4643;
4667 -> 4643;
4668 -> 4664;
4668 -> 4667;
4669 -> 4665;
4669 -> 4667;
4670 -> 4666;
4670 -> 4667;
4671 -> 4663;
4671 -> 4667;
4672 -> 4667;
4673 -> 4667;
4674 -> 4669;
4674 -> 4673;
4675 -> 4672;
4675 -> 4673;
4676 -> 4675;
4676 -> 4673;
4677 -> 4674;
4677 -> 4676;
4678 -> 4669;
4678 -> 4672;
4678 -> 4667;
4679 -> 4670;
4679 -> 4672;
4679 -> 4667;
4680 -> 4678;
4680 -> 4679;
4680 -> 4667;
4681 -> 4668;
4681 -> 4671;
4681 -> 4667;
4682 -> 4669;
4682 -> 4671;
4682 -> 4667;
4683 -> 4670;
4683 -> 4671;
4683 -> 4667;
4684 -> 4643;
4685 -> 4644;
4685 -> 4643;
4686 -> 4643;
4687 -> 4685;
4687 -> 4686;
4688 -> 4663;
4688 -> 4686;
4689 -> 4687;
4689 -> 4686;
4690 -> 4686;
4691 -> 4689;
4691 -> 4690;
4692 -> 4688;
4692 -> 4690;
4693 -> 4692;
4693 -> 4690;
4694 -> 4693;
4694 -> 4691;
4694 -> 4663;
4694 -> 4681;
4694 -> 4682;
4694 -> 4683;
4694 -> 4690;
4695 -> 4690;
4696 -> 4694;
4696 -> 4695;
4697 -> 4694;
4697 -> 4695;
4698 -> 4696;
4698 -> 4695;
4699 -> 4695;
4700 -> 4698;
4700 -> 4699;
4701 -> 4697;
4701 -> 4699;
4702 -> 4701;
4702 -> 4694;
4702 -> 4699;
4703 -> 4700;
4703 -> 4699;
4704 -> 4702;
4704 -> 4703;
4704 -> 4694;
4704 -> 4699;
4705 -> 0;
4705 -> 4699;
4706 -> 4699;
4707 -> 4700;
4707 -> 4704;
4707 -> 4706;
4707 -> 4699;
4708 -> 4701;
4708 -> 4704;
4708 -> 4699;
4709 -> 4700;
4709 -> 4704;
4709 -> 4699;
4710 -> 0;
4710 -> 4707;
4711 -> 4700;
4711 -> 4699;
4712 -> 4710;
4712 -> 4699;
4713 -> 4699;
4714 -> 4711;
4714 -> 4713;
4715 -> 4712;
4715 -> 4713;
4716 -> 4701;
4716 -> 4713;
4717 -> 4714;
4717 -> 4713;
4718 -> 4715;
4718 -> 4713;
4719 -> 4713;
4720 -> 4717;
4720 -> 4719;
4721 -> 4718;
4721 -> 4719;
4722 -> 4721;
4722 -> 4719;
4723 -> 4719;
4724 -> 4720;
4724 -> 4719;
4725 -> 4721;
4725 -> 4719;
4726 -> 4719;
4727 -> 4719;
4728 -> 4724;
4728 -> 4727;
4729 -> 4725;
4729 -> 4727;
4730 -> 4726;
4730 -> 4727;
4731 -> 4728;
4731 -> 4730;
4731 -> 4727;
4732 -> 4729;
4732 -> 4730;
4732 -> 4727;
4733 -> 4726;
4733 -> 4713;
4734 -> 4713;
4735 -> 4713;
4736 -> 4716;
4736 -> 4735;
4737 -> 4736;
4737 -> 4708;
4737 -> 4735;
4738 -> 4737;
4738 -> 4713;
4739 -> 4733;
4739 -> 4713;
4740 -> 4734;
4740 -> 4713;
4741 -> 4739;
4741 -> 4740;
4741 -> 4738;
4741 -> 4731;
4741 -> 4732;
4741 -> 4708;
4741 -> 4713;
4742 -> 4713;
4743 -> 4741;
4743 -> 4742;
4744 -> 4743;
4744 -> 4741;
4744 -> 4742;
4745 -> 4714;
4745 -> 4744;
4746 -> 4744;
4747 -> 4745;
4747 -> 4746;
4748 -> 4747;
4748 -> 4746;
4749 -> 4747;
4749 -> 4746;
4750 -> 4749;
4750 -> 4747;
4750 -> 4746;
4751 -> 4748;
4751 -> 4746;
4752 -> 4750;
4752 -> 4751;
4752 -> 4747;
4752 -> 4746;
4753 -> 4749;
4753 -> 4752;
4753 -> 4746;
4754 -> 4748;
4754 -> 4752;
4754 -> 4746;
4755 -> 4748;
4755 -> 4746;
4756 -> 4746;
4757 -> 4755;
4757 -> 4756;
4758 -> 4749;
4758 -> 4756;
4759 -> 4757;
4759 -> 4753;
4759 -> 4756;
4760 -> 4756;
4761 -> 4760;
4761 -> 4756;
4762 -> 4757;
4762 -> 4753;
4762 -> 4756;
4763 -> 4758;
4763 -> 4762;
4763 -> 4759;
4763 -> 4753;
4763 -> 4756;
4764 -> 4758;
4764 -> 4762;
4764 -> 4759;
4764 -> 4753;
4764 -> 4763;
4765 -> 4758;
4765 -> 4762;
4765 -> 4764;
4766 -> 4764;
4767 -> 4765;
4767 -> 4756;
4768 -> 4756;
4769 -> 4767;
4769 -> 4768;
4769 -> 4756;
4770 -> 4767;
4770 -> 4757;
4770 -> 4756;
4771 -> 4767;
4771 -> 4769;
4772 -> 0;
4772 -> 4769;
4773 -> 4767;
4773 -> 4771;
4773 -> 4769;
4774 -> 4756;
4775 -> 4774;
4775 -> 4746;
4776 -> 4748;
4776 -> 4746;
4777 -> 4749;
4777 -> 4773;
4777 -> 4746;
4778 -> 4753;
4778 -> 4746;
4779 -> 4775;
4779 -> 4746;
4780 -> 4746;
4781 -> 4776;
4781 -> 4780;
4782 -> 4777;
4782 -> 4780;
4783 -> 4778;
4783 -> 4780;
4784 -> 4779;
4784 -> 4780;
4785 -> 4749;
4785 -> 4780;
4786 -> 4784;
4786 -> 4780;
4787 -> 4780;
4788 -> 4784;
4788 -> 4780;
4789 -> 4783;
4789 -> 4788;
4790 -> 0;
4790 -> 4789;
4791 -> 4781;
4791 -> 4780;
4792 -> 4790;
4792 -> 4780;
4793 -> 4780;
4794 -> 4791;
4794 -> 4793;
4795 -> 4792;
4795 -> 4793;
4796 -> 4795;
4796 -> 4793;
4797 -> 4793;
4798 -> 4793;
4798 -> 4780;
4799 -> 4780;
4800 -> 4780;
4801 -> 4785;
4801 -> 4800;
4802 -> 4801;
4802 -> 4773;
4802 -> 4800;
4803 -> 4802;
4803 -> 4780;
4804 -> 4798;
4804 -> 4780;
4805 -> 4799;
4805 -> 4780;
4806 -> 4804;
4806 -> 4805;
4806 -> 4803;
4806 -> 4794;
4806 -> 4795;
4806 -> 4773;
4806 -> 4780;
4807 -> 4780;
4808 -> 4806;
4809 -> 4781;
4809 -> 4806;
4810 -> 4806;
4811 -> 4785;
4811 -> 4810;
4812 -> 4810;
4813 -> 4811;
4813 -> 4806;
4813 -> 4812;
4814 -> 4813;
4814 -> 4810;
4815 -> 4814;
4815 -> 4806;
4816 -> 4781;
4816 -> 4806;
4816 -> 4815;
4817 -> 4782;
4817 -> 4815;
4818 -> 4815;
4819 -> 4815;
4820 -> 4816;
4820 -> 4819;
4821 -> 4817;
4821 -> 4819;
4822 -> 4818;
4822 -> 4819;
4823 -> 4818;
4823 -> 4819;
4824 -> 4819;
4825 -> 4820;
4825 -> 4824;
4825 -> 4819;
4826 -> 4823;
4826 -> 4819;
4827 -> 4819;
4828 -> 4819;
4829 -> 4822;
4829 -> 4828;
4830 -> 4827;
4830 -> 4828;
4831 -> 4830;
4831 -> 4828;
4832 -> 4829;
4832 -> 4831;
4833 -> 4822;
4833 -> 4827;
4833 -> 4819;
4834 -> 4823;
4834 -> 4827;
4834 -> 4819;
4835 -> 4821;
4835 -> 4819;
4836 -> 4821;
4836 -> 4819;
4837 -> 4835;
4837 -> 4819;
4838 -> 4819;
4839 -> 4837;
4839 -> 4838;
4840 -> 4836;
4840 -> 4838;
4841 -> 4838;
4842 -> 4841;
4842 -> 4838;
4843 -> 4840;
4843 -> 4839;
4843 -> 4821;
4844 -> 4838;
4844 -> 4819;
4845 -> 4819;
4846 -> 4836;
4846 -> 4845;
4847 -> 4846;
4847 -> 4843;
4847 -> 4845;
4848 -> 4819;
4849 -> 4837;
4849 -> 4848;
4850 -> 4844;
4850 -> 4848;
4851 -> 4847;
4851 -> 4848;
4852 -> 4836;
4852 -> 4848;
4853 -> 4848;
4854 -> 4852;
4854 -> 4853;
4855 -> 4854;
4855 -> 4843;
4855 -> 4853;
4856 -> 4855;
4856 -> 4848;
4857 -> 4848;
4858 -> 4849;
4858 -> 4856;
4858 -> 4848;
4859 -> 4850;
4859 -> 4848;
4860 -> 4851;
4860 -> 4859;
4861 -> 0;
4861 -> 4860;
4862 -> 4849;
4862 -> 4848;
4863 -> 4861;
4863 -> 4848;
4864 -> 4848;
4865 -> 4862;
4865 -> 4864;
4866 -> 4863;
4866 -> 4864;
4867 -> 4866;
4867 -> 4864;
4868 -> 4864;
4869 -> 4864;
4869 -> 4848;
4870 -> 4848;
4871 -> 4848;
4872 -> 4852;
4872 -> 4871;
4873 -> 4872;
4873 -> 4843;
4873 -> 4871;
4874 -> 4873;
4874 -> 4848;
4875 -> 4869;
4875 -> 4848;
4876 -> 4870;
4876 -> 4848;
4877 -> 4875;
4877 -> 4876;
4877 -> 4874;
4877 -> 4865;
4877 -> 4866;
4877 -> 4843;
4877 -> 4848;
4878 -> 4848;
4879 -> 4877;
4880 -> 4852;
4880 -> 4879;
4881 -> 4880;
4881 -> 4877;
4881 -> 4879;
4882 -> 4881;
4882 -> 4877;
4883 -> 4851;
4883 -> 4877;
4884 -> 4883;
4885 -> 4852;
4885 -> 4884;
4886 -> 4885;
4886 -> 4877;
4886 -> 4884;
4887 -> 4886;
4887 -> 4883;
4888 -> 4883;
4889 -> 4887;
4889 -> 4888;
4890 -> 4882;
4890 -> 4883;
4891 -> 4849;
4891 -> 4883;
4892 -> 4850;
4892 -> 4883;
4893 -> 4883;
4894 -> 4883;
4895 -> 4889;
4895 -> 4894;
4896 -> 4890;
4896 -> 4894;
4897 -> 4891;
4897 -> 4894;
4898 -> 4892;
4898 -> 4894;
4899 -> 4893;
4899 -> 4894;
4900 -> 4896;
4900 -> 4894;
4901 -> 4894;
4902 -> 4900;
4902 -> 4901;
4903 -> 4899;
4903 -> 4901;
4904 -> 4901;
4905 -> 4901;
4906 -> 4902;
4906 -> 4905;
4906 -> 4901;
4907 -> 4902;
4907 -> 4903;
4907 -> 4901;
4908 -> 4902;
4908 -> 4877;
4908 -> 4903;
4908 -> 4901;
4909 -> 4902;
4909 -> 4877;
4909 -> 4903;
4909 -> 4901;
4910 -> 4904;
4910 -> 4903;
4910 -> 4901;
4911 -> 4899;
4911 -> 4894;
4912 -> 4899;
4912 -> 4894;
4913 -> 4899;
4913 -> 4894;
4914 -> 4899;
4914 -> 4894;
4915 -> 4899;
4915 -> 4894;
4916 -> 4894;
4917 -> 4895;
4917 -> 4916;
4917 -> 4894;
4918 -> 4894;
4919 -> 4897;
4919 -> 4918;
4919 -> 4894;
4920 -> 4895;
4920 -> 4899;
4920 -> 4894;
4921 -> 4897;
4921 -> 4899;
4921 -> 4898;
4921 -> 4894;
4922 -> 4921;
4922 -> 4899;
4922 -> 4894;
4923 -> 4898;
4923 -> 4894;
4924 -> 4897;
4924 -> 4877;
4924 -> 4923;
4925 -> 4897;
4925 -> 4924;
4926 -> 4925;
4926 -> 4924;
4926 -> 4899;
4927 -> 4883;
4928 -> 4852;
4928 -> 4927;
4929 -> 4928;
4929 -> 4924;
4929 -> 4927;
4930 -> 4929;
4930 -> 4883;
4931 -> 4849;
4931 -> 4883;
4932 -> 4883;
4933 -> 4883;
4934 -> 4930;
4934 -> 4933;
4935 -> 4931;
4935 -> 4933;
4936 -> 4932;
4936 -> 4933;
4937 -> 4934;
4937 -> 4933;
4938 -> 4933;
4939 -> 4937;
4939 -> 4938;
4940 -> 4938;
4941 -> 4939;
4941 -> 4940;
4942 -> 4940;
4943 -> 4941;
4943 -> 4942;
4944 -> 4943;
4944 -> 4942;
4945 -> 4943;
4945 -> 4940;
4946 -> 4940;
4947 -> 4945;
4947 -> 4946;
4948 -> 4940;
4949 -> 4947;
4949 -> 4938;
4950 -> 4938;
4951 -> 4949;
4951 -> 4950;
4952 -> 0;
4952 -> 4938;
4953 -> 4938;
4954 -> 4952;
4954 -> 4953;
4955 -> 4951;
4955 -> 4953;
4956 -> 4955;
4957 -> 4955;
4958 -> 4955;
4959 -> 4955;
4959 -> 4958;
4960 -> 4958;
4960 -> 4955;
4961 -> 4955;
4962 -> 4956;
4962 -> 4955;
4963 -> 4955;
4963 -> 4933;
4964 -> 4963;
4965 -> 4877;
4966 -> 4965;
4966 -> 4955;
4967 -> 4966;
4967 -> 4877;
4968 -> 4869;
4968 -> 4877;
4969 -> 4893;
4969 -> 4877;
4970 -> 4968;
4970 -> 4969;
4970 -> 4967;
4970 -> 4865;
4970 -> 4866;
4970 -> 4909;
4970 -> 4908;
4970 -> 4907;
4970 -> 4910;
4970 -> 4903;
4970 -> 4920;
4970 -> 4922;
4970 -> 4913;
4970 -> 4914;
4970 -> 4915;
4970 -> 4926;
4970 -> 4955;
4970 -> 4921;
4970 -> 4924;
4970 -> 4877;
4971 -> 4877;
4972 -> 4893;
4972 -> 4848;
4973 -> 4821;
4973 -> 4972;
4973 -> 4970;
4973 -> 4819;
4974 -> 4819;
4975 -> 4819;
4975 -> 4973;
4975 -> 4974;
4976 -> 4973;
4976 -> 4819;
4977 -> 4783;
4977 -> 4806;
4978 -> 4781;
4978 -> 4977;
4979 -> 4781;
4979 -> 4975;
4979 -> 4977;
4980 -> 4976;
4980 -> 4977;
4981 -> 4784;
4981 -> 4977;
4982 -> 4977;
4983 -> 4978;
4983 -> 4982;
4984 -> 4979;
4984 -> 4982;
4985 -> 4980;
4985 -> 4982;
4986 -> 4981;
4986 -> 4982;
4987 -> 4785;
4987 -> 4982;
4988 -> 4982;
4989 -> 4984;
4989 -> 4982;
4990 -> 4982;
4991 -> 4984;
4991 -> 4990;
4991 -> 4982;
4992 -> 4982;
4993 -> 4985;
4993 -> 4982;
4994 -> 4993;
4995 -> 4993;
4995 -> 4994;
4996 -> 4995;
4996 -> 4975;
4996 -> 4994;
4997 -> 4996;
4997 -> 4993;
4998 -> 4984;
4998 -> 4982;
4999 -> 4982;
5000 -> 4998;
5000 -> 4999;
5001 -> 4997;
5001 -> 4999;
5002 -> 5000;
5002 -> 4975;
5002 -> 4999;
5003 -> 5000;
5003 -> 5002;
5004 -> 5002;
5005 -> 5003;
5005 -> 5004;
5006 -> 5003;
5006 -> 5004;
5007 -> 5005;
5007 -> 5004;
5008 -> 5004;
5009 -> 5007;
5009 -> 5008;
5010 -> 5006;
5010 -> 5008;
5011 -> 5010;
5011 -> 5003;
5011 -> 5009;
5011 -> 5008;
5012 -> 5011;
5013 -> 5011;
5013 -> 5012;
5014 -> 5012;
5014 -> 5011;
5015 -> 5011;
5015 -> 5014;
5016 -> 5001;
5016 -> 5015;
5016 -> 5002;
5017 -> 4982;
5018 -> 5016;
5018 -> 5017;
5018 -> 4982;
5019 -> 5016;
5019 -> 4982;
5020 -> 4985;
5020 -> 4982;
5021 -> 4983;
5021 -> 4982;
5022 -> 4986;
5022 -> 4982;
5023 -> 4982;
5024 -> 4982;
5025 -> 5019;
5025 -> 5024;
5026 -> 5020;
5026 -> 5024;
5027 -> 5021;
5027 -> 5024;
5028 -> 5022;
5028 -> 5024;
5029 -> 5023;
5029 -> 5024;
5030 -> 5024;
5031 -> 5029;
5031 -> 5030;
5032 -> 5030;
5033 -> 5030;
5034 -> 5026;
5034 -> 5033;
5034 -> 5030;
5035 -> 5026;
5035 -> 5016;
5035 -> 5031;
5035 -> 5030;
5036 -> 5026;
5036 -> 5016;
5036 -> 5031;
5036 -> 5030;
5037 -> 5032;
5037 -> 5031;
5037 -> 5030;
5038 -> 5029;
5038 -> 5024;
5039 -> 5029;
5039 -> 5024;
5040 -> 5029;
5040 -> 5024;
5041 -> 5029;
5041 -> 5024;
5042 -> 5029;
5042 -> 5024;
5043 -> 5024;
5044 -> 5025;
5044 -> 5043;
5044 -> 5024;
5045 -> 5024;
5046 -> 5027;
5046 -> 5045;
5046 -> 5024;
5047 -> 5027;
5047 -> 5029;
5047 -> 5028;
5047 -> 5024;
5048 -> 5047;
5048 -> 5029;
5048 -> 5024;
5049 -> 5028;
5049 -> 5024;
5050 -> 5027;
5050 -> 5016;
5050 -> 5049;
5051 -> 5027;
5051 -> 5050;
5052 -> 5027;
5052 -> 5051;
5053 -> 5052;
5053 -> 5051;
5053 -> 5029;
5054 -> 5023;
5054 -> 4977;
5055 -> 4806;
5056 -> 5055;
5056 -> 5051;
5057 -> 5056;
5057 -> 4806;
5058 -> 4798;
5058 -> 4806;
5059 -> 5054;
5059 -> 4806;
5060 -> 5058;
5060 -> 5059;
5060 -> 5057;
5060 -> 4794;
5060 -> 4795;
5060 -> 5036;
5060 -> 5035;
5060 -> 5026;
5060 -> 5037;
5060 -> 5031;
5060 -> 5025;
5060 -> 5048;
5060 -> 5040;
5060 -> 5041;
5060 -> 5042;
5060 -> 5053;
5060 -> 5051;
5060 -> 5047;
5060 -> 4806;
5061 -> 4806;
5062 -> 5054;
5062 -> 4780;
5063 -> 4747;
5063 -> 5062;
5063 -> 5060;
5063 -> 4746;
5064 -> 4715;
5064 -> 4861;
5064 -> 4744;
5065 -> 5064;
5066 -> 5063;
5066 -> 5065;
5067 -> 5066;
5067 -> 5063;
5067 -> 5065;
5068 -> 5065;
5069 -> 5067;
5069 -> 5068;
5069 -> 5065;
5070 -> 5069;
5070 -> 5065;
5071 -> 5066;
5071 -> 5063;
5071 -> 5070;
5072 -> 5071;
5072 -> 5064;
5073 -> 4714;
5073 -> 5064;
5074 -> 5064;
5075 -> 5073;
5075 -> 5074;
5076 -> 5072;
5076 -> 5074;
5077 -> 5075;
5077 -> 5063;
5077 -> 5071;
5077 -> 5074;
5078 -> 5075;
5078 -> 5063;
5078 -> 5074;
5079 -> 5075;
5079 -> 5074;
5080 -> 5074;
5081 -> 5077;
5081 -> 5080;
5082 -> 5078;
5082 -> 5080;
5083 -> 5077;
5083 -> 5080;
5084 -> 5079;
5084 -> 5080;
5085 -> 5076;
5085 -> 5080;
5086 -> 5083;
5086 -> 5080;
5087 -> 5080;
5088 -> 5086;
5088 -> 5087;
5089 -> 5081;
5089 -> 5080;
5090 -> 5082;
5090 -> 5080;
5091 -> 5080;
5092 -> 5089;
5092 -> 5091;
5093 -> 5090;
5093 -> 5091;
5094 -> 5085;
5094 -> 5091;
5095 -> 5092;
5095 -> 5091;
5096 -> 5091;
5097 -> 5095;
5097 -> 5096;
5098 -> 5094;
5098 -> 5096;
5099 -> 5098;
5099 -> 5077;
5099 -> 5096;
5100 -> 5098;
5100 -> 5077;
5100 -> 5096;
5101 -> 5100;
5101 -> 5097;
5101 -> 5096;
5101 -> 5077;
5102 -> 5091;
5103 -> 5093;
5103 -> 5091;
5104 -> 5101;
5104 -> 5102;
5104 -> 5103;
5104 -> 5091;
5105 -> 5104;
5105 -> 5102;
5106 -> 5105;
5106 -> 5104;
5106 -> 5102;
5107 -> 5106;
5108 -> 5106;
5109 -> 5107;
5109 -> 5108;
5109 -> 5106;
5110 -> 5106;
5111 -> 5107;
5111 -> 5110;
5112 -> 5110;
5113 -> 5111;
5113 -> 5106;
5113 -> 5112;
5114 -> 5113;
5114 -> 5106;
5114 -> 4210;
5114 -> 5112;
5115 -> 5114;
5115 -> 4231;
5115 -> 5112;
5116 -> 5115;
5116 -> 5110;
5117 -> 5116;
5117 -> 5106;
5118 -> 5117;
5118 -> 5088;
5118 -> 5106;
5119 -> 5118;
5120 -> 5084;
5120 -> 5119;
5120 -> 5118;
5121 -> 5120;
5122 -> 5121;
5122 -> 5120;
5123 -> 5122;
5123 -> 5121;
5123 -> 5084;
5124 -> 5122;
5124 -> 5121;
5125 -> 5107;
5125 -> 5123;
5126 -> 4715;
5126 -> 0;
5126 -> 5064;
5127 -> 5125;
5127 -> 5126;
5128 -> 5063;
5128 -> 5126;
5129 -> 5126;
5130 -> 5126;
5131 -> 5127;
5131 -> 5130;
5132 -> 5128;
5132 -> 5130;
5133 -> 5129;
5133 -> 5130;
5134 -> 5129;
5134 -> 5130;
5135 -> 5132;
5135 -> 5130;
5136 -> 5130;
5137 -> 5135;
5137 -> 5136;
5138 -> 5134;
5138 -> 5136;
5139 -> 5136;
5140 -> 5136;
5141 -> 5137;
5141 -> 5140;
5141 -> 5136;
5142 -> 5137;
5142 -> 5124;
5142 -> 5138;
5142 -> 5136;
5143 -> 5137;
5143 -> 5124;
5143 -> 5138;
5143 -> 5136;
5144 -> 5139;
5144 -> 5138;
5144 -> 5136;
5145 -> 5134;
5145 -> 5130;
5146 -> 5134;
5146 -> 5130;
5147 -> 5134;
5147 -> 5130;
5148 -> 5134;
5148 -> 5130;
5149 -> 5134;
5149 -> 5130;
5150 -> 5130;
5151 -> 5131;
5151 -> 5150;
5151 -> 5130;
5152 -> 5131;
5152 -> 5134;
5152 -> 5130;
5154 -> 0;
5155 -> 0;
5156 -> 0;
5159 -> 5153;
5159 -> 5158;
5160 -> 5154;
5160 -> 5158;
5161 -> 5155;
5161 -> 5158;
5162 -> 5156;
5162 -> 5158;
5163 -> 5157;
5163 -> 5158;
5164 -> 5158;
5165 -> 5164;
5165 -> 5158;
5166 -> 5164;
5166 -> 5158;
5167 -> 5164;
5167 -> 5158;
5168 -> 5158;
5169 -> 5160;
5169 -> 5168;
5169 -> 5158;
5170 -> 5161;
5170 -> 0;
5170 -> 5158;
5171 -> 5162;
5171 -> 0;
5171 -> 5158;
5172 -> 5159;
5172 -> 5164;
5172 -> 5158;
5173 -> 5160;
5173 -> 5164;
5173 -> 5158;
5174 -> 5161;
5174 -> 5164;
5174 -> 5158;
5175 -> 5163;
5175 -> 5164;
5175 -> 5158;
5176 -> 5162;
5176 -> 5164;
5176 -> 5158;
5177 -> 5158;
5178 -> 5177;
5178 -> 5130;
5179 -> 5178;
5179 -> 5133;
5179 -> 5130;
5180 -> 5179;
5180 -> 5134;
5180 -> 5130;
5181 -> 5126;
5182 -> 4714;
5182 -> 5124;
5182 -> 5181;
5182 -> 5126;
5183 -> 4714;
5183 -> 5124;
5183 -> 4744;
5184 -> 4744;
5185 -> 5183;
5185 -> 5184;
5186 -> 5129;
5186 -> 5184;
5187 -> 5186;
5187 -> 5142;
5187 -> 5184;
5188 -> 0;
5188 -> 5184;
5189 -> 5184;
5190 -> 5187;
5190 -> 5189;
5191 -> 5188;
5191 -> 5189;
5192 -> 5190;
5192 -> 5191;
5192 -> 5189;
5193 -> 5185;
5193 -> 5184;
5194 -> 5192;
5194 -> 5193;
5194 -> 5184;
5195 -> 5194;
5195 -> 5184;
5196 -> 4744;
5197 -> 5196;
5197 -> 5193;
5198 -> 5197;
5198 -> 4744;
5199 -> 4733;
5199 -> 4744;
5200 -> 5195;
5200 -> 4744;
5201 -> 5199;
5201 -> 5200;
5201 -> 5198;
5201 -> 4731;
5201 -> 4732;
5201 -> 5143;
5201 -> 5142;
5201 -> 5137;
5201 -> 5144;
5201 -> 5138;
5201 -> 5152;
5201 -> 5146;
5201 -> 5180;
5201 -> 5148;
5201 -> 5149;
5201 -> 5193;
5201 -> 5106;
5201 -> 5172;
5201 -> 5175;
5201 -> 5173;
5201 -> 5174;
5201 -> 5176;
5201 -> 0;
5201 -> 4744;
5202 -> 4744;
5203 -> 5195;
5203 -> 4713;
5204 -> 4694;
5204 -> 5203;
5204 -> 5201;
5204 -> 4690;
5205 -> 4663;
5205 -> 4643;
5206 -> 4451;
5207 -> 4451;
5208 -> 4456;
5208 -> 5207;
5209 -> 5207;
5210 -> 5208;
5210 -> 5209;
5211 -> 5209;
5211 -> 5207;
5212 -> 5208;
5212 -> 5207;
5213 -> 5207;
5214 -> 5212;
5214 -> 5213;
5215 -> 5214;
5215 -> 5204;
5215 -> 5213;
5216 -> 5207;
5217 -> 5215;
5217 -> 4451;
5218 -> 4454;
5218 -> 4451;
5219 -> 5218;
5219 -> 5204;
5219 -> 4451;
5220 -> 5219;
5221 -> 5219;
5221 -> 5204;
5222 -> 5219;
5222 -> 5204;
5223 -> 5219;
5223 -> 5222;
5224 -> 5222;
5225 -> 4456;
5225 -> 5224;
5226 -> 5224;
5227 -> 5225;
5227 -> 5222;
5227 -> 5226;
5227 -> 5224;
5228 -> 5227;
5228 -> 5222;
5229 -> 5222;
5230 -> 4456;
5230 -> 5222;
5231 -> 5222;
5232 -> 5223;
5232 -> 5227;
5232 -> 5231;
5232 -> 5222;
5233 -> 4455;
5233 -> 5222;
5234 -> 5229;
5234 -> 5222;
5235 -> 5222;
5236 -> 5230;
5236 -> 5235;
5237 -> 5232;
5237 -> 5235;
5238 -> 5232;
5238 -> 5235;
5239 -> 5233;
5239 -> 5235;
5240 -> 5234;
5240 -> 5235;
5241 -> 5235;
5242 -> 5236;
5242 -> 5241;
5243 -> 5241;
5244 -> 5242;
5244 -> 5243;
5245 -> 5244;
5245 -> 5232;
5245 -> 5243;
5246 -> 5245;
5246 -> 5241;
5247 -> 5246;
5247 -> 5235;
5248 -> 5247;
5248 -> 5235;
5249 -> 0;
5249 -> 5235;
5250 -> 5237;
5250 -> 5235;
5251 -> 5238;
5251 -> 5235;
5252 -> 5248;
5252 -> 5235;
5253 -> 5249;
5253 -> 5235;
5254 -> 5250;
5254 -> 5235;
5255 -> 5239;
5255 -> 5235;
5256 -> 5240;
5256 -> 5235;
5257 -> 5235;
5258 -> 5251;
5258 -> 5257;
5259 -> 5252;
5259 -> 5257;
5260 -> 5253;
5260 -> 5257;
5261 -> 5254;
5261 -> 5257;
5262 -> 5255;
5262 -> 5257;
5263 -> 5256;
5263 -> 5257;
5264 -> 5258;
5264 -> 5257;
5265 -> 5262;
5265 -> 5257;
5266 -> 5257;
5267 -> 5264;
5267 -> 5266;
5268 -> 5265;
5268 -> 5266;
5269 -> 5266;
5270 -> 5266;
5271 -> 5266;
5271 -> 0;
5272 -> 5266;
5272 -> 5257;
5273 -> 5272;
5273 -> 5257;
5274 -> 5260;
5274 -> 5257;
5275 -> 5261;
5275 -> 5257;
5276 -> 5262;
5276 -> 5257;
5277 -> 5258;
5277 -> 5257;
5278 -> 5263;
5278 -> 5257;
5279 -> 5257;
5280 -> 5273;
5280 -> 5279;
5281 -> 5274;
5281 -> 5279;
5282 -> 5275;
5282 -> 5279;
5283 -> 5276;
5283 -> 5279;
5284 -> 5277;
5284 -> 5279;
5285 -> 5278;
5285 -> 5279;
5286 -> 5279;
5287 -> 5280;
5287 -> 5281;
5287 -> 5279;
5288 -> 5280;
5288 -> 5281;
5288 -> 5279;
5289 -> 5287;
5289 -> 0;
5289 -> 5279;
5290 -> 5288;
5290 -> 0;
5290 -> 5279;
5291 -> 5279;
5292 -> 5288;
5292 -> 5279;
5293 -> 5292;
5293 -> 0;
5293 -> 5257;
5294 -> 5257;
5295 -> 5292;
5295 -> 5259;
5295 -> 5293;
5296 -> 5295;
5296 -> 5257;
5297 -> 5296;
5297 -> 0;
5297 -> 5235;
5298 -> 5235;
5299 -> 5296;
5299 -> 0;
5299 -> 5235;
5300 -> 5235;
5301 -> 5296;
5301 -> 0;
5301 -> 5235;
5302 -> 5235;
5303 -> 5236;
5303 -> 5301;
5304 -> 5296;
5304 -> 5301;
5305 -> 5250;
5305 -> 5301;
5306 -> 5239;
5306 -> 5301;
5307 -> 5301;
5308 -> 5303;
5308 -> 5307;
5309 -> 5304;
5309 -> 5307;
5310 -> 5305;
5310 -> 5307;
5311 -> 5306;
5311 -> 5307;
5312 -> 5309;
5312 -> 0;
5312 -> 5307;
5313 -> 5301;
5314 -> 5296;
5314 -> 5235;
5315 -> 5223;
5315 -> 5250;
5315 -> 5222;
5316 -> 5314;
5316 -> 0;
5316 -> 5315;
5317 -> 5315;
5318 -> 5316;
5318 -> 5315;
5319 -> 5286;
5319 -> 5318;
5320 -> 4455;
5320 -> 5318;
5321 -> 5318;
5322 -> 5318;
5322 -> 5321;
5323 -> 5318;
5323 -> 5321;
5324 -> 5318;
5324 -> 5321;
5325 -> 5319;
5325 -> 5321;
5326 -> 5320;
5326 -> 5321;
5327 -> 5318;
5327 -> 5321;
5328 -> 5322;
5328 -> 5321;
5329 -> 5324;
5329 -> 5321;
5330 -> 5323;
5330 -> 5250;
5330 -> 5321;
5331 -> 5323;
5331 -> 5250;
5331 -> 5321;
5332 -> 5323;
5332 -> 5331;
5332 -> 5321;
5333 -> 5321;
5334 -> 5332;
5334 -> 5333;
5335 -> 5332;
5335 -> 5333;
5336 -> 5332;
5336 -> 5333;
5337 -> 5332;
5337 -> 5333;
5338 -> 5332;
5338 -> 5333;
5339 -> 5332;
5339 -> 5333;
5340 -> 5334;
5340 -> 5333;
5341 -> 5336;
5341 -> 5333;
5342 -> 5337;
5342 -> 5333;
5343 -> 5338;
5343 -> 5333;
5344 -> 5333;
5345 -> 5340;
5345 -> 5344;
5346 -> 5341;
5346 -> 5344;
5347 -> 5342;
5347 -> 5344;
5348 -> 5343;
5348 -> 5344;
5349 -> 5339;
5349 -> 5344;
5350 -> 5345;
5350 -> 5344;
5351 -> 5344;
5352 -> 5350;
5352 -> 5351;
5353 -> 5349;
5353 -> 5351;
5354 -> 5351;
5355 -> 5353;
5355 -> 5354;
5356 -> 5354;
5357 -> 5355;
5357 -> 5356;
5358 -> 5356;
5359 -> 5357;
5359 -> 5356;
5360 -> 5355;
5360 -> 5354;
5361 -> 5353;
5361 -> 5351;
5362 -> 5351;
5363 -> 5352;
5363 -> 5362;
5363 -> 5351;
5364 -> 5352;
5364 -> 5353;
5364 -> 5351;
5365 -> 5349;
5365 -> 5344;
5366 -> 5349;
5366 -> 5344;
5367 -> 5349;
5367 -> 5344;
5368 -> 5349;
5368 -> 5344;
5369 -> 5349;
5369 -> 5344;
5370 -> 0;
5370 -> 5349;
5370 -> 5344;
5371 -> 0;
5371 -> 5349;
5371 -> 5344;
5372 -> 5344;
5373 -> 5346;
5373 -> 5372;
5373 -> 5344;
5374 -> 5344;
5375 -> 5347;
5375 -> 5374;
5375 -> 5344;
5376 -> 5344;
5377 -> 5348;
5377 -> 5376;
5377 -> 5344;
5378 -> 5346;
5378 -> 5349;
5378 -> 5344;
5379 -> 5347;
5379 -> 5349;
5379 -> 5344;
5380 -> 5348;
5380 -> 5349;
5380 -> 5344;
5381 -> 5339;
5381 -> 5333;
5382 -> 5335;
5382 -> 5339;
5382 -> 5333;
5383 -> 5332;
5383 -> 5357;
5383 -> 5359;
5383 -> 5360;
5383 -> 5364;
5383 -> 5378;
5383 -> 5380;
5383 -> 5379;
5383 -> 5368;
5383 -> 5369;
5383 -> 5370;
5383 -> 5371;
5383 -> 5382;
5383 -> 0;
5383 -> 5321;
5384 -> 5323;
5384 -> 5383;
5384 -> 5321;
5385 -> 5321;
5386 -> 5385;
5386 -> 5328;
5386 -> 5329;
5386 -> 5330;
5386 -> 5331;
5386 -> 5384;
5386 -> 5321;
5387 -> 5385;
5387 -> 5321;
5388 -> 5385;
5388 -> 5321;
5389 -> 5385;
5389 -> 5321;
5390 -> 5321;
5391 -> 5323;
5391 -> 5386;
5391 -> 5390;
5391 -> 5321;
5392 -> 5391;
5392 -> 5385;
5392 -> 5321;
5393 -> 5326;
5393 -> 5321;
5394 -> 5321;
5395 -> 5393;
5395 -> 5394;
5396 -> 5385;
5396 -> 5394;
5397 -> 5394;
5398 -> 5396;
5398 -> 5397;
5399 -> 5398;
5399 -> 5386;
5399 -> 5397;
5400 -> 5399;
5400 -> 5394;
5401 -> 5396;
5401 -> 5394;
5402 -> 5394;
5403 -> 5394;
5404 -> 5400;
5404 -> 5403;
5405 -> 5401;
5405 -> 5403;
5406 -> 5402;
5406 -> 5403;
5407 -> 5404;
5407 -> 5403;
5408 -> 5403;
5409 -> 5407;
5409 -> 5408;
5410 -> 5409;
5410 -> 0;
5410 -> 5408;
5411 -> 5410;
5412 -> 5403;
5413 -> 5405;
5413 -> 5412;
5414 -> 0;
5414 -> 5412;
5415 -> 5414;
5415 -> 5403;
5416 -> 5406;
5416 -> 5415;
5416 -> 5403;
5417 -> 5404;
5417 -> 0;
5417 -> 5403;
5418 -> 5403;
5419 -> 5416;
5419 -> 5417;
5419 -> 5403;
5420 -> 5404;
5420 -> 0;
5420 -> 5419;
5421 -> 5403;
5422 -> 5421;
5422 -> 5394;
5423 -> 5394;
5424 -> 5422;
5424 -> 5423;
5424 -> 5394;
5425 -> 5321;
5426 -> 5325;
5426 -> 5321;
5427 -> 5326;
5427 -> 5426;
5428 -> 5426;
5429 -> 5427;
5429 -> 5428;
5430 -> 5385;
5430 -> 5428;
5431 -> 5428;
5432 -> 5430;
5432 -> 5431;
5433 -> 5432;
5433 -> 5386;
5433 -> 5431;
5434 -> 5433;
5434 -> 5428;
5435 -> 5428;
5436 -> 5434;
5436 -> 5435;
5437 -> 0;
5437 -> 5435;
5438 -> 5435;
5439 -> 5437;
5439 -> 5438;
5440 -> 5436;
5440 -> 5438;
5441 -> 5440;
5441 -> 5386;
5441 -> 5439;
5441 -> 5438;
5442 -> 5438;
5443 -> 5441;
5443 -> 5442;
5443 -> 5438;
5444 -> 5443;
5445 -> 5430;
5445 -> 5444;
5446 -> 5444;
5447 -> 5445;
5447 -> 5446;
5448 -> 5447;
5448 -> 5386;
5448 -> 5446;
5449 -> 5448;
5449 -> 0;
5449 -> 5444;
5450 -> 5444;
5451 -> 5449;
5451 -> 5450;
5451 -> 5444;
5452 -> 5451;
5452 -> 5443;
5453 -> 5452;
5454 -> 5430;
5454 -> 5386;
5454 -> 5453;
5455 -> 0;
5455 -> 5453;
5456 -> 5453;
5457 -> 5455;
5457 -> 5456;
5458 -> 5454;
5458 -> 5456;
5459 -> 5458;
5459 -> 5386;
5459 -> 5457;
5459 -> 5456;
5460 -> 5459;
5460 -> 5452;
5461 -> 5460;
5462 -> 5430;
5462 -> 5461;
5463 -> 5461;
5464 -> 5462;
5464 -> 5463;
5465 -> 5464;
5465 -> 0;
5465 -> 5461;
5466 -> 5461;
5467 -> 5465;
5467 -> 5466;
5467 -> 5461;
5468 -> 5467;
5468 -> 5460;
5469 -> 5460;
5470 -> 5430;
5470 -> 5469;
5471 -> 5469;
5472 -> 5470;
5472 -> 5471;
5473 -> 5472;
5473 -> 0;
5473 -> 5469;
5474 -> 5469;
5475 -> 5473;
5475 -> 5474;
5475 -> 5469;
5476 -> 5475;
5476 -> 5460;
5477 -> 5468;
5477 -> 5476;
5477 -> 5460;
5478 -> 5460;
5479 -> 5430;
5479 -> 5386;
5479 -> 5478;
5480 -> 0;
5480 -> 5478;
5481 -> 5478;
5482 -> 5480;
5482 -> 5481;
5483 -> 5479;
5483 -> 5481;
5484 -> 5483;
5484 -> 5386;
5484 -> 5482;
5484 -> 5481;
5485 -> 5484;
5485 -> 5460;
5486 -> 5477;
5486 -> 5485;
5486 -> 5460;
5487 -> 5426;
5488 -> 5321;
5489 -> 5322;
5489 -> 5488;
5490 -> 5489;
5490 -> 5386;
5490 -> 5488;
5491 -> 5490;
5491 -> 5321;
5492 -> 5318;
5492 -> 5315;
5493 -> 4452;
5493 -> 4423;
5493 -> 5492;
5493 -> 4422;
5493 -> 5386;
5493 -> 5387;
5493 -> 5392;
5493 -> 5388;
5493 -> 5389;
5493 -> 5315;
5494 -> 5315;
5495 -> 5318;
5495 -> 5494;
5496 -> 5494;
5497 -> 5495;
5497 -> 5496;
5498 -> 5497;
5498 -> 5493;
5498 -> 5496;
5499 -> 5498;
5499 -> 0;
5499 -> 5494;
5500 -> 5494;
5501 -> 5499;
5501 -> 5500;
5501 -> 5494;
5502 -> 5501;
5502 -> 5315;
5503 -> 5217;
5503 -> 5315;
5504 -> 5315;
5505 -> 5315;
5506 -> 5502;
5506 -> 5505;
5507 -> 5503;
5507 -> 5505;
5508 -> 5504;
5508 -> 5505;
5509 -> 4452;
5509 -> 5505;
5510 -> 5506;
5510 -> 5505;
5511 -> 5505;
5512 -> 5510;
5512 -> 5511;
5513 -> 5509;
5513 -> 5511;
5514 -> 5512;
5514 -> 5511;
5515 -> 5513;
5515 -> 4433;
5515 -> 5514;
5516 -> 5513;
5516 -> 5515;
5516 -> 5511;
5517 -> 5508;
5517 -> 5505;
5518 -> 5505;
5519 -> 5517;
5519 -> 5518;
5520 -> 5507;
5520 -> 5518;
5521 -> 5519;
5521 -> 5493;
5521 -> 5518;
5522 -> 5518;
5523 -> 5521;
5523 -> 5522;
5524 -> 5521;
5524 -> 5522;
5525 -> 5520;
5525 -> 5522;
5526 -> 5522;
5527 -> 5525;
5527 -> 5526;
5528 -> 5526;
5529 -> 5527;
5529 -> 5528;
5529 -> 5493;
5529 -> 5526;
5530 -> 5529;
5530 -> 5526;
5531 -> 5530;
5531 -> 5522;
5532 -> 5524;
5532 -> 5522;
5533 -> 5523;
5533 -> 5532;
5533 -> 5529;
5533 -> 5493;
5533 -> 5522;
5534 -> 5522;
5535 -> 5525;
5535 -> 5534;
5536 -> 5535;
5536 -> 5533;
5536 -> 5534;
5537 -> 5522;
5538 -> 5536;
5538 -> 5531;
5538 -> 5522;
5539 -> 5516;
5539 -> 5538;
5539 -> 5505;
5540 -> 5315;
5541 -> 4456;
5541 -> 5540;
5542 -> 5540;
5543 -> 5541;
5543 -> 5533;
5543 -> 5542;
5543 -> 5540;
5544 -> 5543;
5544 -> 0;
5544 -> 5540;
5545 -> 5544;
5545 -> 5315;
5546 -> 5315;
5547 -> 5315;
5547 -> 5543;
5547 -> 5546;
5548 -> 5547;
5549 -> 5318;
5549 -> 5548;
5550 -> 5548;
5551 -> 5549;
5551 -> 5550;
5552 -> 5551;
5552 -> 5543;
5552 -> 5550;
5553 -> 5552;
5553 -> 0;
5553 -> 5548;
5554 -> 5548;
5555 -> 5553;
5555 -> 5554;
5555 -> 5548;
5556 -> 5555;
5556 -> 5547;
5557 -> 4453;
5557 -> 5556;
5558 -> 5318;
5558 -> 5556;
5559 -> 5315;
5559 -> 5543;
5559 -> 5556;
5560 -> 5556;
5561 -> 5557;
5561 -> 5560;
5562 -> 5558;
5562 -> 5560;
5563 -> 5559;
5563 -> 5560;
5564 -> 5560;
5565 -> 5561;
5565 -> 5564;
5565 -> 5560;
5566 -> 5565;
5567 -> 5562;
5567 -> 5560;
5568 -> 5563;
5568 -> 5560;
5569 -> 5560;
5570 -> 5560;
5571 -> 5567;
5571 -> 5570;
5572 -> 5568;
5572 -> 5570;
5573 -> 5569;
5573 -> 5570;
5574 -> 5572;
5574 -> 5570;
5575 -> 0;
5575 -> 5570;
5576 -> 5572;
5576 -> 5570;
5577 -> 0;
5577 -> 5570;
5578 -> 5576;
5578 -> 5577;
5578 -> 5574;
5578 -> 5570;
5579 -> 5570;
5580 -> 5570;
5581 -> 5571;
5581 -> 5580;
5582 -> 5579;
5582 -> 5580;
5583 -> 5582;
5583 -> 5580;
5584 -> 5581;
5584 -> 5583;
5585 -> 5571;
5585 -> 5579;
5585 -> 5570;
5586 -> 5572;
5586 -> 5570;
5587 -> 5574;
5587 -> 5570;
5588 -> 5587;
5588 -> 5585;
5588 -> 5570;
5589 -> 5571;
5589 -> 5573;
5589 -> 5570;
5590 -> 5572;
5590 -> 5578;
5590 -> 5570;
5591 -> 5590;
5591 -> 5573;
5591 -> 5570;
5592 -> 5566;
5592 -> 5569;
5592 -> 5589;
5592 -> 5591;
5592 -> 5590;
5592 -> 5560;
5593 -> 5556;
5594 -> 4452;
5594 -> 4427;
5594 -> 4451;
5595 -> 5566;
5595 -> 4451;
5596 -> 4451;
5597 -> 5594;
5597 -> 5596;
5598 -> 5595;
5598 -> 5596;
5599 -> 5596;
5600 -> 5598;
5600 -> 5599;
5600 -> 5596;
5601 -> 5598;
5601 -> 5600;
5602 -> 5597;
5602 -> 5601;
5602 -> 4426;
5602 -> 5592;
5602 -> 5600;
5603 -> 4451;
5604 -> 4452;
5604 -> 4425;
5604 -> 4451;
5605 -> 5206;
5605 -> 4451;
5606 -> 4451;
5607 -> 5604;
5607 -> 5606;
5608 -> 5605;
5608 -> 5606;
5609 -> 5606;
5610 -> 5608;
5610 -> 5609;
5610 -> 5606;
5611 -> 4451;
5612 -> 4416;
5613 -> 4416;
5614 -> 4418;
5614 -> 5613;
5615 -> 5613;
5616 -> 5614;
5616 -> 5602;
5616 -> 5615;
5617 -> 5616;
5617 -> 4416;
5618 -> 4416;
5619 -> 4418;
5619 -> 5618;
5620 -> 5618;
5621 -> 5620;
5621 -> 5618;
5622 -> 5618;
5623 -> 5621;
5623 -> 5622;
5624 -> 5619;
5624 -> 5622;
5625 -> 5622;
5626 -> 5624;
5626 -> 5625;
5627 -> 5625;
5628 -> 5627;
5628 -> 5622;
5629 -> 5622;
5630 -> 5624;
5630 -> 5629;
5631 -> 5630;
5631 -> 5602;
5631 -> 5629;
5632 -> 5631;
5632 -> 5622;
5633 -> 5622;
5634 -> 5632;
5634 -> 5633;
5635 -> 5633;
5635 -> 5622;
5636 -> 5628;
5636 -> 5635;
5636 -> 5622;
5637 -> 5622;
5638 -> 5624;
5638 -> 5637;
5639 -> 5637;
5640 -> 5638;
5640 -> 5639;
5641 -> 5640;
5641 -> 5602;
5641 -> 5639;
5642 -> 5641;
5642 -> 5637;
5643 -> 5637;
5644 -> 5642;
5645 -> 5642;
5646 -> 5644;
5646 -> 5645;
5646 -> 5642;
5647 -> 5644;
5647 -> 5646;
5648 -> 5647;
5648 -> 5622;
5649 -> 5622;
5650 -> 5648;
5650 -> 5649;
5651 -> 5649;
5652 -> 5650;
5652 -> 5651;
5653 -> 5652;
5653 -> 5602;
5653 -> 5651;
5654 -> 5649;
5655 -> 5622;
5656 -> 5653;
5656 -> 5655;
5657 -> 5655;
5658 -> 5656;
5658 -> 5657;
5659 -> 5657;
5660 -> 5657;
5661 -> 5658;
5662 -> 5658;
5662 -> 5661;
5663 -> 5662;
5663 -> 5602;
5663 -> 5661;
5664 -> 5663;
5665 -> 5663;
5666 -> 5657;
5667 -> 5666;
5667 -> 5655;
5668 -> 5655;
5669 -> 5667;
5669 -> 5622;
5670 -> 5622;
5671 -> 5636;
5671 -> 5669;
5671 -> 5622;
5672 -> 5622;
5673 -> 5624;
5673 -> 5672;
5674 -> 5673;
5674 -> 5602;
5674 -> 5672;
5675 -> 5674;
5675 -> 5622;
5676 -> 5675;
5676 -> 2554;
5676 -> 5622;
5677 -> 5671;
5677 -> 5676;
5677 -> 5622;
5678 -> 5622;
5679 -> 5622;
5680 -> 5679;
5680 -> 4416;
5681 -> 4418;
5681 -> 5602;
5681 -> 4416;
5682 -> 5681;
5682 -> 4010;
5682 -> 4416;
5683 -> 4416;
5684 -> 4419;
5684 -> 5683;
5685 -> 5684;
5685 -> 4423;
5685 -> 5681;
5685 -> 5683;
5686 -> 5684;
5686 -> 4425;
5686 -> 5683;
5687 -> 5683;
5688 -> 5686;
5688 -> 5687;
5689 -> 5687;
5690 -> 5688;
5690 -> 4424;
5690 -> 5689;
5690 -> 5687;
5691 -> 5688;
5691 -> 4424;
5691 -> 5690;
5692 -> 0;
5692 -> 5690;
5693 -> 5684;
5693 -> 4427;
5693 -> 5683;
5694 -> 5683;
5695 -> 5693;
5695 -> 5694;
5696 -> 5694;
5697 -> 5695;
5697 -> 5681;
5697 -> 5696;
5697 -> 5694;
5698 -> 5695;
5698 -> 5681;
5698 -> 5694;
5699 -> 5695;
5699 -> 5694;
5700 -> 5699;
5700 -> 5681;
5700 -> 5694;
5701 -> 5700;
5701 -> 5681;
5702 -> 5698;
5702 -> 5701;
5702 -> 5681;
5702 -> 5700;
5703 -> 5695;
5703 -> 5702;
5703 -> 5694;
5704 -> 5698;
5704 -> 5703;
5704 -> 5694;
5705 -> 5684;
5705 -> 4428;
5705 -> 5683;
5706 -> 5684;
5706 -> 4429;
5706 -> 5683;
5707 -> 5684;
5707 -> 4430;
5707 -> 5683;
5708 -> 5684;
5708 -> 4432;
5708 -> 5683;
5709 -> 5684;
5709 -> 5515;
5709 -> 5683;
5710 -> 5684;
5710 -> 4434;
5710 -> 5683;
5711 -> 5683;
5712 -> 5683;
5713 -> 5685;
5713 -> 5712;
5714 -> 5692;
5714 -> 5712;
5715 -> 5704;
5715 -> 5712;
5716 -> 5705;
5716 -> 5712;
5717 -> 5706;
5717 -> 5712;
5718 -> 5707;
5718 -> 5712;
5719 -> 5708;
5719 -> 5712;
5720 -> 5709;
5720 -> 5712;
5721 -> 5710;
5721 -> 5712;
5722 -> 5711;
5722 -> 5712;
5723 -> 5722;
5723 -> 5712;
5724 -> 5722;
5724 -> 5712;
5725 -> 5722;
5725 -> 5712;
5726 -> 5722;
5726 -> 5712;
5727 -> 5722;
5727 -> 5712;
5728 -> 5722;
5728 -> 5712;
5729 -> 5713;
5729 -> 5685;
5729 -> 5712;
5730 -> 5714;
5730 -> 0;
5730 -> 5712;
5731 -> 5715;
5731 -> 5704;
5731 -> 5712;
5732 -> 5713;
5732 -> 5712;
5733 -> 5712;
5734 -> 5732;
5734 -> 5733;
5734 -> 5685;
5734 -> 5703;
5734 -> 5712;
5735 -> 5717;
5735 -> 5718;
5735 -> 5712;
5736 -> 5713;
5736 -> 5722;
5736 -> 5712;
5737 -> 5714;
5737 -> 5722;
5737 -> 5712;
5738 -> 5715;
5738 -> 5722;
5738 -> 5712;
5739 -> 5716;
5739 -> 5722;
5739 -> 5712;
5740 -> 5717;
5740 -> 5722;
5740 -> 5712;
5741 -> 5718;
5741 -> 5722;
5741 -> 5712;
5742 -> 5719;
5742 -> 5722;
5742 -> 5712;
5743 -> 5720;
5743 -> 5722;
5743 -> 5712;
5744 -> 5721;
5744 -> 5722;
5744 -> 5712;
5745 -> 5711;
5745 -> 4416;
5746 -> 5745;
5746 -> 4409;
5747 -> 4410;
5747 -> 5734;
5747 -> 4409;
5748 -> 5746;
5748 -> 4409;
5749 -> 4010;
5749 -> 4409;
5750 -> 5747;
5750 -> 5748;
5750 -> 5749;
5750 -> 5739;
5750 -> 5740;
5750 -> 5741;
5750 -> 5742;
5750 -> 5743;
5750 -> 5744;
5750 -> 5736;
5750 -> 5737;
5750 -> 5738;
5750 -> 4004;
5750 -> 4005;
5750 -> 4006;
5750 -> 4007;
5750 -> 4008;
5750 -> 4009;
5750 -> 5734;
5750 -> 5685;
5750 -> 0;
5750 -> 5704;
5750 -> 4409;
5751 -> 5750;
5751 -> 4010;
5751 -> 4409;
5752 -> 4414;
5752 -> 4409;
5753 -> 4409;
5754 -> 5752;
5754 -> 5753;
5755 -> 4410;
5755 -> 5753;
5756 -> 5753;
5757 -> 5755;
5757 -> 5756;
5758 -> 5757;
5758 -> 5750;
5758 -> 5756;
5759 -> 5758;
5759 -> 5753;
5760 -> 5754;
5760 -> 4414;
5760 -> 5753;
5761 -> 4409;
5762 -> 4414;
5762 -> 4409;
5763 -> 5746;
5763 -> 4409;
5764 -> 5763;
5764 -> 4406;
5765 -> 5764;
5765 -> 4406;
5766 -> 5764;
5766 -> 4406;
5767 -> 4406;
5768 -> 4406;
5769 -> 5766;
5769 -> 5768;
5770 -> 5767;
5770 -> 5768;
5771 -> 5770;
5771 -> 5768;
5772 -> 5770;
5772 -> 5768;
5773 -> 5770;
5773 -> 5768;
5774 -> 5770;
5774 -> 5768;
5775 -> 5769;
5775 -> 4010;
5775 -> 5768;
5776 -> 5769;
5776 -> 5750;
5776 -> 5770;
5776 -> 5768;
5777 -> 5769;
5777 -> 5750;
5777 -> 5770;
5777 -> 5768;
5778 -> 5767;
5778 -> 4406;
5779 -> 5764;
5779 -> 4406;
5780 -> 4407;
5780 -> 4406;
5781 -> 4406;
5782 -> 5778;
5782 -> 5781;
5783 -> 5779;
5783 -> 5781;
5784 -> 5780;
5784 -> 5781;
5785 -> 4408;
5785 -> 5781;
5786 -> 5781;
5787 -> 5785;
5787 -> 5786;
5788 -> 5786;
5789 -> 5787;
5789 -> 5750;
5789 -> 5788;
5790 -> 5789;
5790 -> 5781;
5791 -> 5782;
5791 -> 5790;
5792 -> 5783;
5792 -> 5790;
5793 -> 5784;
5793 -> 5790;
5794 -> 5790;
5795 -> 5791;
5795 -> 5794;
5796 -> 5792;
5796 -> 5794;
5797 -> 5793;
5797 -> 5794;
5798 -> 5785;
5798 -> 5794;
5799 -> 5798;
5799 -> 5750;
5799 -> 0;
5799 -> 5794;
5800 -> 5799;
5801 -> 5790;
5802 -> 5782;
5802 -> 5790;
5803 -> 5783;
5803 -> 5790;
5804 -> 5784;
5804 -> 5790;
5805 -> 5790;
5806 -> 5802;
5806 -> 5805;
5807 -> 5803;
5807 -> 5805;
5808 -> 5804;
5808 -> 5805;
5809 -> 5785;
5809 -> 5805;
5810 -> 5805;
5811 -> 5805;
5812 -> 5805;
5813 -> 5807;
5813 -> 5805;
5814 -> 5805;
5815 -> 5813;
5815 -> 5814;
5816 -> 5806;
5816 -> 5814;
5817 -> 5815;
5817 -> 5750;
5817 -> 5814;
5818 -> 5817;
5818 -> 5816;
5818 -> 5771;
5818 -> 5814;
5819 -> 5818;
5819 -> 5805;
5820 -> 5819;
5821 -> 5819;
5821 -> 5820;
5822 -> 0;
5822 -> 5820;
5823 -> 5822;
5823 -> 5819;
5824 -> 5810;
5824 -> 5819;
5829 -> 5825;
5829 -> 5828;
5830 -> 5826;
5830 -> 5828;
5831 -> 5827;
5831 -> 5828;
5832 -> 5828;
5833 -> 0;
5834 -> 5833;
5835 -> 0;
5836 -> 5835;
5837 -> 0;
5838 -> 5837;
5839 -> 0;
5840 -> 5839;
5841 -> 5809;
5841 -> 5805;
5842 -> 5805;
5843 -> 5841;
5843 -> 5842;
5844 -> 5842;
5845 -> 5843;
5845 -> 5844;
5845 -> 5842;
5846 -> 5842;
5847 -> 5843;
5847 -> 5846;
5848 -> 5847;
5848 -> 5842;
5849 -> 5811;
5849 -> 5848;
5849 -> 5805;
5850 -> 5805;
5851 -> 5809;
5851 -> 5850;
5852 -> 0;
5852 -> 5850;
5853 -> 5850;
5854 -> 5852;
5854 -> 5853;
5855 -> 5851;
5855 -> 5853;
5856 -> 5855;
5856 -> 5750;
5856 -> 5854;
5856 -> 5853;
5857 -> 5853;
5858 -> 5856;
5858 -> 5857;
5858 -> 5853;
5859 -> 5858;
5859 -> 5805;
5860 -> 5810;
5860 -> 5859;
5860 -> 5805;
5861 -> 5805;
5862 -> 5809;
5862 -> 5861;
5863 -> 5862;
5863 -> 5805;
5864 -> 5860;
5864 -> 5863;
5864 -> 5805;
5865 -> 5849;
5865 -> 5864;
5865 -> 5805;
5866 -> 5865;
5867 -> 5866;
5867 -> 5865;
5868 -> 5867;
5868 -> 5865;
5869 -> 5868;
5870 -> 5868;
5870 -> 5869;
5871 -> 5868;
5871 -> 5869;
5872 -> 5869;
5873 -> 5871;
5873 -> 5872;
5875 -> 5874;
5876 -> 5872;
5877 -> 5873;
5877 -> 5876;
5878 -> 5876;
5879 -> 5877;
5879 -> 5876;
5880 -> 5877;
5880 -> 5876;
5881 -> 5873;
5881 -> 5872;
5882 -> 5871;
5882 -> 5869;
5883 -> 5869;
5884 -> 5870;
5884 -> 5883;
5884 -> 5869;
5885 -> 5870;
5885 -> 5871;
5885 -> 5869;
5886 -> 5807;
5886 -> 5865;
5887 -> 5865;
5888 -> 5868;
5888 -> 5887;
5889 -> 5886;
5889 -> 5887;
5890 -> 5806;
5890 -> 5887;
5891 -> 5890;
5891 -> 5771;
5891 -> 5887;
5892 -> 5891;
5893 -> 5889;
5893 -> 5750;
5893 -> 5892;
5893 -> 5891;
5894 -> 5893;
5894 -> 5890;
5894 -> 5891;
5895 -> 5889;
5895 -> 5750;
5895 -> 5891;
5896 -> 5890;
5896 -> 5894;
5896 -> 5895;
5896 -> 5893;
5896 -> 5750;
5896 -> 5891;
5897 -> 5888;
5897 -> 5887;
5898 -> 5890;
5898 -> 5894;
5898 -> 5897;
5898 -> 5896;
5898 -> 5877;
5898 -> 5879;
5898 -> 5880;
5898 -> 5881;
5898 -> 5885;
5898 -> 5887;
5899 -> 5865;
5900 -> 5807;
5900 -> 5898;
5900 -> 5805;
5901 -> 5805;
5902 -> 5900;
5902 -> 5901;
5903 -> 5902;
5903 -> 5901;
5904 -> 5901;
5905 -> 5812;
5905 -> 5903;
5905 -> 5805;
5906 -> 5805;
5907 -> 5809;
5907 -> 5906;
5908 -> 5907;
5908 -> 5903;
5908 -> 5906;
5909 -> 5908;
5909 -> 0;
5909 -> 5906;
5910 -> 5909;
5910 -> 5805;
5911 -> 5790;
5912 -> 4406;
5913 -> 4408;
5913 -> 5908;
5913 -> 4406;
5914 -> 4406;
5915 -> 5764;
5915 -> 4406;
5916 -> 4406;
5917 -> 5915;
5917 -> 5916;
5918 -> 5767;
5918 -> 5916;
5919 -> 5918;
5919 -> 5894;
5919 -> 5913;
5919 -> 5916;
5920 -> 5918;
5920 -> 5772;
5920 -> 5916;
5921 -> 5920;
5921 -> 5916;
5922 -> 5917;
5922 -> 5913;
5922 -> 5921;
5923 -> 5919;
5923 -> 5916;
5924 -> 5917;
5924 -> 5913;
5924 -> 5916;
5925 -> 5922;
5925 -> 5916;
5926 -> 5918;
5926 -> 5776;
5926 -> 5916;
5927 -> 5918;
5927 -> 5777;
5927 -> 5916;
5928 -> 5916;
5929 -> 5916;
5930 -> 5923;
5930 -> 5929;
5931 -> 5924;
5931 -> 5929;
5932 -> 5925;
5932 -> 5929;
5933 -> 5924;
5933 -> 5929;
5934 -> 5926;
5934 -> 5929;
5935 -> 5927;
5935 -> 5929;
5936 -> 5928;
5936 -> 5929;
5937 -> 5936;
5937 -> 5929;
5938 -> 5936;
5938 -> 5929;
5939 -> 5936;
5939 -> 5929;
5940 -> 5930;
5940 -> 5919;
5940 -> 5929;
5941 -> 5931;
5941 -> 5913;
5941 -> 5929;
5942 -> 5931;
5942 -> 5929;
5943 -> 5929;
5944 -> 5942;
5944 -> 5943;
5944 -> 5913;
5944 -> 5922;
5944 -> 5929;
5945 -> 5932;
5945 -> 5913;
5945 -> 5929;
5946 -> 5932;
5946 -> 5929;
5947 -> 5929;
5948 -> 5946;
5948 -> 5947;
5948 -> 5913;
5948 -> 5922;
5948 -> 5944;
5948 -> 5929;
5949 -> 5930;
5949 -> 5929;
5950 -> 5929;
5951 -> 5949;
5951 -> 5950;
5951 -> 5919;
5951 -> 5948;
5951 -> 5929;
5952 -> 5930;
5952 -> 5929;
5953 -> 5929;
5954 -> 5952;
5954 -> 5953;
5954 -> 5919;
5954 -> 5951;
5954 -> 5929;
5955 -> 5933;
5955 -> 5954;
5955 -> 5929;
5956 -> 5955;
5956 -> 5953;
5957 -> 5953;
5958 -> 5956;
5958 -> 5957;
5959 -> 0;
5959 -> 5957;
5960 -> 5959;
5960 -> 5953;
5961 -> 5955;
5961 -> 5960;
5961 -> 5929;
5962 -> 5956;
5962 -> 5957;
5963 -> 0;
5963 -> 5957;
5964 -> 5963;
5964 -> 5953;
5965 -> 5955;
5965 -> 5964;
5965 -> 5961;
5965 -> 5929;
5966 -> 5955;
5966 -> 5960;
5966 -> 5964;
5966 -> 5929;
5967 -> 5930;
5967 -> 5936;
5967 -> 5929;
5968 -> 5931;
5968 -> 5936;
5968 -> 5929;
5969 -> 5932;
5969 -> 5936;
5969 -> 5929;
5970 -> 5933;
5970 -> 5936;
5970 -> 5929;
5971 -> 5934;
5971 -> 5936;
5971 -> 5929;
5972 -> 5935;
5972 -> 5936;
5972 -> 5929;
5973 -> 5928;
5973 -> 4406;
5974 -> 5973;
5974 -> 4399;
5975 -> 4400;
5975 -> 5954;
5975 -> 4399;
5976 -> 5974;
5976 -> 4399;
5977 -> 4399;
5978 -> 5975;
5978 -> 5976;
5978 -> 5977;
5978 -> 5970;
5978 -> 5971;
5978 -> 5972;
5978 -> 5967;
5978 -> 5968;
5978 -> 5969;
5978 -> 5954;
5978 -> 5919;
5978 -> 5913;
5978 -> 5922;
5978 -> 4399;
5979 -> 4399;
5980 -> 5978;
5980 -> 5979;
5980 -> 4399;
5981 -> 4404;
5981 -> 4399;
5982 -> 4399;
5983 -> 5981;
5983 -> 5982;
5984 -> 4400;
5984 -> 5982;
5985 -> 5982;
5986 -> 5984;
5986 -> 5985;
5987 -> 5986;
5987 -> 5978;
5987 -> 5985;
5988 -> 5987;
5988 -> 5982;
5989 -> 5983;
5989 -> 4404;
5989 -> 5982;
5990 -> 4399;
5991 -> 4404;
5991 -> 4399;
5992 -> 4399;
5993 -> 5992;
5993 -> 4400;
5993 -> 4399;
5994 -> 5974;
5994 -> 4399;
5995 -> 5994;
5995 -> 4395;
5996 -> 4395;
5997 -> 4397;
5997 -> 5996;
5998 -> 5996;
5999 -> 5998;
5999 -> 5996;
6000 -> 5996;
6001 -> 5999;
6001 -> 6000;
6002 -> 5997;
6002 -> 6000;
6003 -> 6000;
6004 -> 6002;
6004 -> 6003;
6005 -> 6003;
6006 -> 6005;
6006 -> 6000;
6007 -> 6000;
6008 -> 6002;
6008 -> 6007;
6009 -> 6008;
6009 -> 5978;
6009 -> 6007;
6010 -> 6009;
6010 -> 6000;
6011 -> 6000;
6012 -> 6010;
6012 -> 6011;
6013 -> 6011;
6013 -> 6000;
6014 -> 6006;
6014 -> 6013;
6014 -> 6000;
6015 -> 6000;
6016 -> 6002;
6016 -> 6015;
6017 -> 6015;
6018 -> 6016;
6018 -> 6017;
6019 -> 6018;
6019 -> 5978;
6019 -> 6017;
6020 -> 6019;
6020 -> 6015;
6021 -> 6015;
6022 -> 6020;
6023 -> 6020;
6024 -> 6022;
6024 -> 6023;
6024 -> 6020;
6025 -> 6022;
6025 -> 6024;
6026 -> 6025;
6026 -> 6000;
6027 -> 6000;
6028 -> 6026;
6028 -> 6027;
6029 -> 6027;
6030 -> 6028;
6030 -> 6029;
6031 -> 6030;
6031 -> 5978;
6031 -> 6029;
6032 -> 6027;
6033 -> 6000;
6034 -> 6031;
6034 -> 6033;
6035 -> 6033;
6036 -> 6034;
6036 -> 6035;
6037 -> 6035;
6038 -> 6035;
6039 -> 6036;
6040 -> 6036;
6040 -> 6039;
6041 -> 6040;
6041 -> 5978;
6041 -> 6039;
6042 -> 6041;
6043 -> 6041;
6044 -> 6035;
6045 -> 6044;
6045 -> 6033;
6046 -> 6033;
6047 -> 6045;
6047 -> 6000;
6048 -> 6000;
6049 -> 6014;
6049 -> 6047;
6049 -> 6000;
6050 -> 6000;
6051 -> 6002;
6051 -> 6050;
6052 -> 6051;
6052 -> 5978;
6052 -> 5993;
6052 -> 6050;
6053 -> 6052;
6053 -> 6000;
6054 -> 6053;
6054 -> 2554;
6054 -> 6000;
6055 -> 6049;
6055 -> 6054;
6055 -> 6000;
6056 -> 6000;
6057 -> 6000;
6058 -> 6057;
6058 -> 4395;
6059 -> 5995;
6059 -> 5978;
6059 -> 6058;
6059 -> 4395;
6060 -> 5995;
6060 -> 5978;
6060 -> 6059;
6061 -> 6059;
6062 -> 0;
6062 -> 6059;
6063 -> 6060;
6063 -> 6061;
6063 -> 6062;
6063 -> 5978;
6063 -> 5993;
6063 -> 6059;
6064 -> 6063;
6064 -> 6061;
6065 -> 6064;
6065 -> 6063;
6065 -> 6061;
6066 -> 6063;
6066 -> 6061;
6067 -> 0;
6067 -> 6061;
6068 -> 6063;
6068 -> 6067;
6068 -> 6065;
6068 -> 6059;
6069 -> 6068;
6069 -> 6059;
6070 -> 6059;
6071 -> 4397;
6071 -> 6070;
6072 -> 6070;
6073 -> 6071;
6073 -> 6068;
6073 -> 6072;
6073 -> 6070;
6074 -> 6073;
6075 -> 6071;
6075 -> 6068;
6075 -> 6073;
6076 -> 6074;
6076 -> 6073;
6077 -> 6073;
6078 -> 6076;
6078 -> 6077;
6079 -> 6071;
6079 -> 6077;
6080 -> 6077;
6081 -> 6077;
6082 -> 6079;
6082 -> 6068;
6082 -> 6077;
6083 -> 6077;
6084 -> 6079;
6084 -> 6083;
6085 -> 6084;
6085 -> 6077;
6086 -> 6077;
6087 -> 3980;
6087 -> 3979;
6087 -> 6086;
6087 -> 6077;
6088 -> 6077;
6089 -> 6080;
6089 -> 6088;
6089 -> 6077;
6090 -> 6089;
6090 -> 6077;
6091 -> 3980;
6091 -> 6090;
6092 -> 6080;
6092 -> 6077;
6093 -> 6091;
6093 -> 6073;
6094 -> 6073;
6095 -> 6074;
6095 -> 6093;
6096 -> 6093;
6097 -> 6095;
6097 -> 6096;
6098 -> 6071;
6098 -> 6096;
6099 -> 6096;
6100 -> 6098;
6100 -> 6099;
6101 -> 6100;
6101 -> 6096;
6102 -> 6097;
6102 -> 6074;
6102 -> 6096;
6103 -> 6093;
6104 -> 0;
6104 -> 6093;
6105 -> 6093;
6106 -> 6104;
6106 -> 6105;
6107 -> 6074;
6107 -> 6073;
6108 -> 6071;
6108 -> 6093;
6108 -> 6070;
6109 -> 6108;
6109 -> 6059;
6110 -> 6059;
6111 -> 6069;
6111 -> 6110;
6112 -> 6109;
6112 -> 6110;
6113 -> 6112;
6113 -> 6110;
6114 -> 6113;
6114 -> 6093;
6114 -> 6106;
6114 -> 6110;
6115 -> 6059;
6116 -> 6068;
6116 -> 4395;
6117 -> 4396;
6117 -> 4395;
6118 -> 4395;
6119 -> 6116;
6119 -> 6118;
6120 -> 6117;
6120 -> 6118;
6121 -> 4397;
6121 -> 6118;
6122 -> 6119;
6122 -> 6093;
6122 -> 6118;
6123 -> 6119;
6123 -> 6093;
6123 -> 6118;
6124 -> 6122;
6124 -> 6123;
6124 -> 6093;
6124 -> 6106;
6124 -> 6118;
6125 -> 3443;
6125 -> 6118;
6126 -> 6122;
6126 -> 6118;
6127 -> 6126;
6127 -> 6124;
6127 -> 6118;
6128 -> 6125;
6128 -> 3433;
6128 -> 3434;
6128 -> 3435;
6128 -> 3436;
6128 -> 3437;
6128 -> 3438;
6128 -> 3439;
6128 -> 6127;
6129 -> 6119;
6129 -> 6127;
6129 -> 6124;
6130 -> 6129;
6131 -> 6130;
6131 -> 6129;
6132 -> 6125;
6132 -> 6128;
6132 -> 6129;
6133 -> 6125;
6133 -> 6128;
6133 -> 6129;
6134 -> 6125;
6134 -> 6133;
6134 -> 6129;
6135 -> 6122;
6135 -> 6129;
6136 -> 4395;
6137 -> 6119;
6137 -> 4395;
6138 -> 6137;
6138 -> 4392;
6139 -> 4390;
6139 -> 6135;
6139 -> 4392;
6140 -> 6138;
6140 -> 4392;
6141 -> 4392;
6142 -> 6139;
6142 -> 6140;
6142 -> 6141;
6142 -> 6135;
6142 -> 4392;
6143 -> 4393;
6143 -> 6142;
6144 -> 6142;
6145 -> 6143;
6145 -> 6144;
6146 -> 4390;
6146 -> 6144;
6147 -> 6144;
6148 -> 6146;
6148 -> 6147;
6149 -> 6148;
6149 -> 6144;
6150 -> 6145;
6150 -> 4393;
6150 -> 6144;
6151 -> 6142;
6152 -> 0;
6152 -> 6142;
6153 -> 6142;
6154 -> 6152;
6154 -> 6153;
6155 -> 4393;
6155 -> 4392;
6156 -> 0;
6156 -> 4389;
6157 -> 4389;
6158 -> 4389;
6159 -> 6156;
6159 -> 6158;
6160 -> 6157;
6160 -> 6158;
6161 -> 4390;
6161 -> 6142;
6161 -> 6158;
6162 -> 6159;
6162 -> 6158;
6163 -> 6158;
6164 -> 6162;
6164 -> 6163;
6165 -> 6161;
6165 -> 6163;
6166 -> 6165;
6166 -> 6142;
6166 -> 6154;
6166 -> 6164;
6166 -> 6163;
6167 -> 6166;
6168 -> 4390;
6168 -> 6142;
6168 -> 4389;
6169 -> 6168;
6169 -> 4382;
6170 -> 6169;
6170 -> 4377;
6171 -> 4378;
6171 -> 4377;
6172 -> 4380;
6172 -> 4377;
6173 -> 6170;
6173 -> 6171;
6173 -> 6172;
6173 -> 6142;
6173 -> 6154;
6173 -> 4381;
6173 -> 4377;
6174 -> 6173;
6175 -> 0;
6175 -> 1;
6176 -> 1;
6177 -> 6174;
6177 -> 6176;
6178 -> 0;
6178 -> 6176;
6179 -> 6178;
6179 -> 1;
6180 -> 0;
6180 -> 1;
6181 -> 1;
6182 -> 6180;
6182 -> 6181;
6183 -> 950;
6183 -> 6181;
6184 -> 6182;
6184 -> 0;
6184 -> 6181;
6185 -> 6181;
6186 -> 6182;
6186 -> 6181;
6187 -> 6183;
6187 -> 6186;
6187 -> 6174;
6187 -> 6181;
6188 -> 6187;
6189 -> 6188;
6190 -> 6188;
6190 -> 6187;
6191 -> 6182;
6191 -> 6187;
6192 -> 6187;
6193 -> 6191;
6193 -> 6192;
6194 -> 6190;
6194 -> 6192;
6195 -> 6192;
6196 -> 6194;
6196 -> 6195;
6197 -> 6196;
6197 -> 6192;
6198 -> 6193;
6198 -> 6192;
6199 -> 6192;
6200 -> 6198;
6200 -> 6199;
6201 -> 6197;
6201 -> 6199;
6202 -> 6199;
6203 -> 6201;
6203 -> 6202;
6204 -> 6203;
6204 -> 6199;
6205 -> 6204;
6206 -> 6204;
6206 -> 6205;
6207 -> 6205;
6208 -> 6206;
6208 -> 6207;
6209 -> 6207;
6210 -> 6208;
6210 -> 6188;
6210 -> 6209;
6210 -> 6207;
6211 -> 6205;
6212 -> 6206;
6212 -> 6188;
6212 -> 6205;
6213 -> 6212;
6213 -> 6204;
6214 -> 6204;
6215 -> 6199;
6216 -> 6201;
6216 -> 6188;
6216 -> 6215;
6216 -> 6199;
6217 -> 6200;
6217 -> 6216;
6218 -> 6216;
6219 -> 6216;
6220 -> 6219;
6220 -> 6216;
6221 -> 6216;
6222 -> 6217;
6222 -> 6216;
6223 -> 6216;
6224 -> 6222;
6224 -> 6223;
6225 -> 6220;
6225 -> 6223;
6226 -> 6223;
6227 -> 6223;
6228 -> 6225;
6228 -> 6227;
6229 -> 6228;
6229 -> 6223;
6230 -> 6224;
6230 -> 6217;
6230 -> 6223;
6231 -> 6223;
6232 -> 6230;
6232 -> 6231;
6233 -> 6229;
6233 -> 6231;
6234 -> 6233;
6234 -> 6231;
6235 -> 6232;
6235 -> 6231;
6236 -> 6235;
6237 -> 6235;
6238 -> 6235;
6239 -> 6237;
6239 -> 6238;
6240 -> 6234;
6240 -> 6238;
6241 -> 6238;
6242 -> 6240;
6242 -> 6220;
6242 -> 6239;
6242 -> 6238;
6243 -> 6239;
6243 -> 6242;
6244 -> 6238;
6244 -> 6242;
6245 -> 6242;
6245 -> 6243;
6246 -> 6245;
6247 -> 6245;
6248 -> 6246;
6248 -> 6247;
6248 -> 6245;
6249 -> 6248;
6250 -> 6236;
6250 -> 6249;
6250 -> 6248;
6251 -> 6246;
6251 -> 6248;
6252 -> 6251;
6252 -> 6235;
6253 -> 6235;
6254 -> 6252;
6254 -> 6253;
6254 -> 6235;
6255 -> 6252;
6255 -> 6231;
6256 -> 6223;
6257 -> 6255;
6257 -> 6256;
6257 -> 6223;
6258 -> 6224;
6258 -> 6257;
6259 -> 6257;
6260 -> 6258;
6260 -> 6259;
6261 -> 6255;
6261 -> 6259;
6262 -> 6260;
6262 -> 6217;
6262 -> 6259;
6263 -> 6261;
6263 -> 6259;
6264 -> 6259;
6265 -> 6263;
6265 -> 6264;
6266 -> 6264;
6266 -> 6259;
6267 -> 6259;
6268 -> 6259;
6269 -> 6268;
6269 -> 6259;
6270 -> 6259;
6271 -> 6263;
6271 -> 6270;
6272 -> 6270;
6273 -> 6271;
6273 -> 6272;
6274 -> 6272;
6274 -> 6270;
6275 -> 6274;
6275 -> 6259;
6276 -> 0;
6276 -> 6259;
6277 -> 6259;
6278 -> 6276;
6278 -> 6277;
6279 -> 6263;
6279 -> 6277;
6280 -> 6277;
6281 -> 6279;
6281 -> 6280;
6282 -> 6281;
6282 -> 6245;
6282 -> 6243;
6282 -> 6280;
6283 -> 6281;
6283 -> 6245;
6283 -> 6243;
6283 -> 6282;
6284 -> 6282;
6285 -> 6281;
6285 -> 6284;
6286 -> 6285;
6286 -> 6284;
6287 -> 6284;
6288 -> 6284;
6289 -> 6286;
6289 -> 6288;
6290 -> 6287;
6290 -> 6288;
6291 -> 6288;
6292 -> 6290;
6292 -> 6291;
6293 -> 6291;
6294 -> 6292;
6294 -> 6293;
6295 -> 6290;
6295 -> 6288;
6296 -> 6289;
6296 -> 6288;
6297 -> 6289;
6297 -> 6290;
6297 -> 6288;
6298 -> 6287;
6298 -> 6282;
6299 -> 6282;
6300 -> 6283;
6300 -> 6298;
6300 -> 6299;
6300 -> 6297;
6300 -> 6243;
6300 -> 6245;
6300 -> 6282;
6301 -> 6281;
6301 -> 6300;
6301 -> 6280;
6302 -> 6301;
6302 -> 6277;
6303 -> 6278;
6303 -> 6277;
6304 -> 6277;
6305 -> 6302;
6305 -> 6304;
6306 -> 6303;
6306 -> 6304;
6307 -> 6305;
6307 -> 6304;
6308 -> 6306;
6308 -> 6304;
6309 -> 6304;
6310 -> 6307;
6310 -> 6309;
6311 -> 6308;
6311 -> 6309;
6312 -> 6311;
6312 -> 6309;
6313 -> 6310;
6313 -> 6309;
6314 -> 6309;
6315 -> 6312;
6315 -> 6309;
6316 -> 6309;
6317 -> 6313;
6317 -> 6316;
6318 -> 6314;
6318 -> 6316;
6319 -> 6314;
6319 -> 6316;
6320 -> 6315;
6320 -> 6316;
6321 -> 6314;
6321 -> 6316;
6322 -> 6316;
6323 -> 6317;
6323 -> 6322;
6323 -> 6316;
6324 -> 6321;
6324 -> 6316;
6325 -> 6324;
6326 -> 6318;
6326 -> 6325;
6326 -> 6324;
6327 -> 6324;
6328 -> 6319;
6328 -> 6327;
6328 -> 6324;
6329 -> 6317;
6329 -> 6316;
6330 -> 6316;
6332 -> 6331;
6334 -> 6333;
6335 -> 6330;
6335 -> 6316;
6336 -> 6320;
6336 -> 6316;
6337 -> 6318;
6337 -> 6316;
6338 -> 6319;
6338 -> 6316;
6339 -> 6316;
6340 -> 6316;
6341 -> 6335;
6341 -> 6340;
6342 -> 6336;
6342 -> 6340;
6343 -> 6337;
6343 -> 6340;
6344 -> 6338;
6344 -> 6340;
6345 -> 6339;
6345 -> 6340;
6346 -> 6341;
6346 -> 6340;
6347 -> 6342;
6347 -> 6340;
6348 -> 6340;
6349 -> 6343;
6349 -> 6340;
6350 -> 6344;
6350 -> 6340;
6351 -> 6340;
6352 -> 6351;
6352 -> 6346;
6352 -> 6347;
6352 -> 6348;
6352 -> 6349;
6352 -> 6350;
6352 -> 6330;
6352 -> 0;
6352 -> 6340;
6353 -> 6351;
6353 -> 6340;
6354 -> 6351;
6354 -> 6340;
6355 -> 6342;
6355 -> 6352;
6355 -> 6340;
6356 -> 0;
6356 -> 6340;
6357 -> 6355;
6357 -> 6351;
6357 -> 6340;
6358 -> 6339;
6358 -> 6316;
6359 -> 6316;
6360 -> 6358;
6360 -> 6359;
6361 -> 6317;
6361 -> 6359;
6362 -> 6360;
6362 -> 6359;
6363 -> 6359;
6364 -> 6362;
6364 -> 6363;
6365 -> 6361;
6365 -> 6363;
6366 -> 6365;
6366 -> 6363;
6367 -> 6363;
6368 -> 6366;
6368 -> 6367;
6369 -> 6364;
6369 -> 6367;
6370 -> 6369;
6370 -> 6352;
6370 -> 6367;
6371 -> 6369;
6371 -> 6352;
6371 -> 6353;
6371 -> 6357;
6371 -> 6354;
6371 -> 6367;
6372 -> 0;
6372 -> 6367;
6373 -> 6369;
6373 -> 6352;
6373 -> 6353;
6373 -> 6357;
6373 -> 6354;
6373 -> 0;
6373 -> 6367;
6374 -> 6373;
6375 -> 6368;
6375 -> 6374;
6376 -> 6374;
6377 -> 6375;
6377 -> 6376;
6378 -> 6377;
6378 -> 6300;
6378 -> 6376;
6379 -> 6374;
6380 -> 6378;
6380 -> 6379;
6381 -> 6379;
6382 -> 6380;
6382 -> 6381;
6383 -> 6382;
6383 -> 6300;
6383 -> 6381;
6384 -> 6383;
6384 -> 6379;
6385 -> 6379;
6386 -> 6384;
6387 -> 6384;
6388 -> 6386;
6388 -> 6387;
6388 -> 6384;
6389 -> 6386;
6389 -> 6388;
6390 -> 6374;
6391 -> 6389;
6391 -> 6390;
6392 -> 6391;
6392 -> 6390;
6393 -> 6390;
6394 -> 6392;
6394 -> 6393;
6395 -> 6393;
6396 -> 6394;
6396 -> 6395;
6397 -> 6396;
6398 -> 6397;
6399 -> 6396;
6400 -> 6396;
6401 -> 6396;
6401 -> 6393;
6402 -> 6401;
6402 -> 6373;
6403 -> 6402;
6403 -> 6373;
6404 -> 6373;
6405 -> 6403;
6405 -> 6404;
6406 -> 6369;
6406 -> 6404;
6407 -> 6405;
6407 -> 6404;
6408 -> 6404;
6409 -> 6407;
6409 -> 6408;
6409 -> 6404;
6410 -> 6406;
6410 -> 6352;
6410 -> 6353;
6410 -> 6357;
6410 -> 6354;
6410 -> 0;
6410 -> 6404;
6411 -> 6404;
6412 -> 6407;
6412 -> 6411;
6413 -> 6411;
6414 -> 6412;
6414 -> 6396;
6414 -> 6413;
6415 -> 6413;
6415 -> 6404;
6416 -> 6406;
6416 -> 6352;
6416 -> 6353;
6416 -> 6357;
6416 -> 6354;
6416 -> 0;
6416 -> 6404;
6417 -> 6415;
6417 -> 6416;
6417 -> 6404;
6418 -> 6417;
6418 -> 6373;
6419 -> 6367;
6420 -> 6368;
6420 -> 6419;
6421 -> 6419;
6422 -> 6420;
6422 -> 6396;
6422 -> 6421;
6423 -> 6421;
6424 -> 6423;
6424 -> 6367;
6425 -> 0;
6425 -> 6424;
6426 -> 6368;
6426 -> 6424;
6427 -> 6424;
6428 -> 6368;
6428 -> 6427;
6429 -> 6427;
6430 -> 6428;
6430 -> 6429;
6431 -> 6430;
6431 -> 6396;
6431 -> 6429;
6432 -> 6427;
6433 -> 6431;
6433 -> 6432;
6434 -> 6433;
6434 -> 6424;
6435 -> 6424;
6436 -> 6425;
6436 -> 6435;
6437 -> 6426;
6437 -> 6435;
6438 -> 6434;
6438 -> 6435;
6439 -> 6369;
6439 -> 6435;
6440 -> 6435;
6441 -> 6438;
6441 -> 6440;
6441 -> 6435;
6442 -> 6441;
6442 -> 6435;
6443 -> 6439;
6443 -> 6352;
6443 -> 6353;
6443 -> 6357;
6443 -> 6442;
6444 -> 6443;
6444 -> 6442;
6445 -> 6436;
6445 -> 6435;
6446 -> 6437;
6446 -> 6435;
6447 -> 6444;
6447 -> 6435;
6448 -> 6445;
6448 -> 6446;
6448 -> 6447;
6448 -> 6396;
6448 -> 6435;
6449 -> 6363;
6450 -> 6359;
6451 -> 6316;
6452 -> 6330;
6452 -> 6448;
6452 -> 6316;
6453 -> 6452;
6453 -> 6260;
6453 -> 6217;
6453 -> 6259;
6454 -> 6275;
6454 -> 6453;
6454 -> 6259;
6455 -> 6260;
6455 -> 6217;
6455 -> 6259;
6456 -> 6260;
6456 -> 6217;
6456 -> 6455;
6457 -> 6455;
6458 -> 6455;
6459 -> 6260;
6459 -> 6217;
6459 -> 6458;
6460 -> 6458;
6461 -> 6459;
6461 -> 6460;
6462 -> 6263;
6462 -> 6460;
6463 -> 6460;
6464 -> 6462;
6464 -> 6463;
6465 -> 6464;
6465 -> 6452;
6465 -> 6463;
6466 -> 6463;
6467 -> 6464;
6467 -> 6452;
6467 -> 6466;
6467 -> 6463;
6468 -> 6467;
6469 -> 6465;
6469 -> 6468;
6469 -> 6467;
6470 -> 6465;
6470 -> 6467;
6471 -> 6467;
6472 -> 6470;
6472 -> 6471;
6473 -> 6471;
6474 -> 6472;
6474 -> 6473;
6474 -> 6471;
6475 -> 6471;
6476 -> 6471;
6477 -> 6471;
6477 -> 6476;
6478 -> 6476;
6479 -> 6477;
6479 -> 6478;
6480 -> 6479;
6480 -> 6476;
6481 -> 6476;
6482 -> 6477;
6482 -> 6481;
6483 -> 6482;
6483 -> 6476;
6484 -> 6476;
6485 -> 6483;
6485 -> 6484;
6486 -> 6484;
6486 -> 6476;
6487 -> 6476;
6488 -> 6480;
6488 -> 6476;
6489 -> 6471;
6489 -> 6488;
6489 -> 6472;
6489 -> 6452;
6490 -> 6489;
6491 -> 6489;
6492 -> 6489;
6493 -> 6489;
6494 -> 6489;
6495 -> 6489;
6496 -> 6471;
6496 -> 6489;
6497 -> 6489;
6498 -> 6496;
6498 -> 6489;
6498 -> 6497;
6499 -> 6498;
6499 -> 6489;
6500 -> 6489;
6501 -> 6499;
6502 -> 6499;
6503 -> 6499;
6504 -> 6499;
6505 -> 6499;
6506 -> 6499;
6507 -> 6499;
6508 -> 6507;
6508 -> 6499;
6509 -> 6508;
6509 -> 6499;
6510 -> 6499;
6511 -> 6499;
6512 -> 6499;
6513 -> 6499;
6514 -> 6499;
6515 -> 6499;
6516 -> 6499;
6517 -> 6499;
6518 -> 6499;
6519 -> 6499;
6520 -> 6499;
6521 -> 0;
6521 -> 6499;
6522 -> 0;
6522 -> 6499;
6523 -> 6499;
6523 -> 6522;
6524 -> 6523;
6524 -> 6499;
6524 -> 6522;
6525 -> 6519;
6525 -> 6499;
6526 -> 6499;
6527 -> 6505;
6527 -> 6526;
6527 -> 6499;
6528 -> 6524;
6529 -> 6524;
6530 -> 6524;
6531 -> 6524;
6532 -> 6524;
6533 -> 6524;
6534 -> 6524;
6535 -> 6534;
6535 -> 6524;
6536 -> 6535;
6536 -> 6524;
6537 -> 6524;
6538 -> 6524;
6539 -> 6524;
6540 -> 6524;
6541 -> 6524;
6542 -> 6524;
6543 -> 6524;
6544 -> 6524;
6545 -> 6524;
6546 -> 6524;
6547 -> 6524;
6548 -> 0;
6548 -> 6524;
6549 -> 6546;
6549 -> 6524;
6550 -> 6524;
6551 -> 6532;
6551 -> 6550;
6551 -> 6524;
6552 -> 6524;
6553 -> 6552;
6553 -> 6524;
6554 -> 6553;
6554 -> 6524;
6555 -> 6524;
6556 -> 6524;
6557 -> 6524;
6558 -> 6524;
6559 -> 6489;
6560 -> 6500;
6560 -> 6559;
6560 -> 6489;
6561 -> 6524;
6562 -> 6524;
6563 -> 6524;
6564 -> 6524;
6565 -> 6524;
6565 -> 6564;
6566 -> 6565;
6566 -> 6524;
6566 -> 6564;
6567 -> 6566;
6567 -> 6524;
6568 -> 6561;
6568 -> 6567;
6568 -> 6524;
6569 -> 6524;
6569 -> 6568;
6570 -> 6568;
6571 -> 6569;
6571 -> 6570;
6572 -> 6524;
6572 -> 6570;
6573 -> 6570;
6574 -> 6571;
6574 -> 6573;
6575 -> 6574;
6575 -> 6570;
6576 -> 6575;
6576 -> 0;
6576 -> 6570;
6577 -> 6570;
6578 -> 6571;
6578 -> 6577;
6579 -> 6577;
6580 -> 6578;
6580 -> 6579;
6581 -> 6580;
6581 -> 6524;
6581 -> 6579;
6582 -> 6581;
6582 -> 6577;
6583 -> 6577;
6584 -> 6582;
6584 -> 6583;
6584 -> 6577;
6585 -> 6584;
6585 -> 6577;
6586 -> 6585;
6587 -> 6582;
6587 -> 6586;
6588 -> 6586;
6589 -> 6587;
6589 -> 6588;
6590 -> 6589;
6590 -> 6586;
6591 -> 6586;
6592 -> 6590;
6592 -> 6591;
6593 -> 6592;
6593 -> 6570;
6594 -> 6572;
6594 -> 6570;
6595 -> 6593;
6595 -> 6594;
6595 -> 6570;
6596 -> 6570;
6597 -> 6571;
6597 -> 6596;
6598 -> 6596;
6599 -> 6597;
6599 -> 6598;
6600 -> 6599;
6600 -> 6524;
6600 -> 6598;
6601 -> 6598;
6602 -> 6600;
6602 -> 6601;
6603 -> 6601;
6603 -> 6598;
6604 -> 6598;
6605 -> 6600;
6605 -> 6604;
6606 -> 6605;
6606 -> 6598;
6607 -> 6606;
6607 -> 6596;
6608 -> 6607;
6608 -> 6570;
6609 -> 6570;
6610 -> 6608;
6610 -> 6609;
6611 -> 6610;
6611 -> 6524;
6611 -> 6609;
6612 -> 6570;
6613 -> 6570;
6614 -> 6572;
6614 -> 6613;
6615 -> 6614;
6615 -> 6570;
6616 -> 6572;
6616 -> 6570;
6617 -> 6570;
6618 -> 6572;
6618 -> 6524;
6618 -> 6617;
6618 -> 6570;
6619 -> 6572;
6619 -> 6524;
6619 -> 6618;
6620 -> 6618;
6621 -> 6572;
6621 -> 6619;
6621 -> 6575;
6621 -> 6570;
6622 -> 6571;
6622 -> 6570;
6623 -> 6570;
6624 -> 6572;
6624 -> 6621;
6625 -> 6621;
6626 -> 6572;
6626 -> 6621;
6626 -> 6624;
6626 -> 6625;
6627 -> 6572;
6627 -> 6621;
6627 -> 6624;
6627 -> 0;
6628 -> 6568;
6629 -> 6568;
6630 -> 6524;
6630 -> 6621;
6630 -> 6629;
6631 -> 6630;
6631 -> 6621;
6631 -> 6624;
6631 -> 0;
6631 -> 6629;
6632 -> 6631;
6632 -> 6568;
6633 -> 6624;
6634 -> 6624;
6635 -> 6632;
6635 -> 0;
6636 -> 6632;
6637 -> 6632;
6637 -> 6636;
6638 -> 6636;
6639 -> 6637;
6639 -> 6638;
6640 -> 6639;
6640 -> 6624;
6640 -> 6638;
6641 -> 6640;
6641 -> 6636;
6642 -> 6636;
6643 -> 6641;
6643 -> 6642;
6643 -> 6636;
6644 -> 6643;
6644 -> 6636;
6645 -> 6644;
6646 -> 6641;
6646 -> 6645;
6647 -> 6645;
6648 -> 6646;
6648 -> 6647;
6649 -> 6648;
6649 -> 6645;
6650 -> 6645;
6651 -> 6649;
6651 -> 6650;
6652 -> 6651;
6652 -> 6632;
6653 -> 6632;
6654 -> 6632;
6655 -> 6632;
6655 -> 6654;
6656 -> 6654;
6657 -> 6655;
6657 -> 6656;
6658 -> 6657;
6658 -> 6624;
6658 -> 6656;
6659 -> 6656;
6660 -> 6658;
6660 -> 6659;
6661 -> 6659;
6661 -> 6656;
6662 -> 6656;
6663 -> 6658;
6663 -> 6662;
6664 -> 6663;
6664 -> 6656;
6665 -> 6664;
6665 -> 6654;
6666 -> 6665;
6666 -> 6632;
6667 -> 6632;
6668 -> 6666;
6668 -> 6667;
6669 -> 6668;
6669 -> 6624;
6669 -> 6667;
6670 -> 6632;
6671 -> 6632;
6672 -> 6671;
6672 -> 6632;
6673 -> 6632;
6674 -> 6632;
6675 -> 6632;
6675 -> 0;
6676 -> 6632;
6677 -> 6632;
6678 -> 6671;
6678 -> 0;
6679 -> 6671;
6680 -> 6671;
6680 -> 6679;
6681 -> 6679;
6682 -> 6680;
6682 -> 6681;
6683 -> 6682;
6683 -> 6632;
6683 -> 6681;
6684 -> 6683;
6684 -> 6679;
6685 -> 6679;
6686 -> 6684;
6686 -> 6685;
6686 -> 6679;
6687 -> 6686;
6687 -> 6679;
6688 -> 6687;
6689 -> 6684;
6689 -> 6688;
6690 -> 6688;
6691 -> 6689;
6691 -> 6690;
6692 -> 6691;
6692 -> 6688;
6693 -> 6688;
6694 -> 6692;
6694 -> 6693;
6695 -> 6694;
6695 -> 6671;
6696 -> 6671;
6697 -> 6671;
6698 -> 6671;
6698 -> 6697;
6699 -> 6697;
6700 -> 6698;
6700 -> 6699;
6701 -> 6700;
6701 -> 6632;
6701 -> 6699;
6702 -> 6699;
6703 -> 6701;
6703 -> 6702;
6704 -> 6702;
6704 -> 6699;
6705 -> 6699;
6706 -> 6701;
6706 -> 6705;
6707 -> 6706;
6707 -> 6699;
6708 -> 6707;
6708 -> 6697;
6709 -> 6708;
6709 -> 6671;
6710 -> 6671;
6711 -> 6709;
6711 -> 6710;
6712 -> 6711;
6712 -> 6632;
6712 -> 6710;
6713 -> 6671;
6714 -> 6671;
6715 -> 6671;
6716 -> 6671;
6716 -> 0;
6717 -> 6671;
6718 -> 6671;
6719 -> 6682;
6719 -> 6671;
6719 -> 6681;
6720 -> 6719;
6720 -> 6679;
6721 -> 6720;
6721 -> 6685;
6721 -> 6679;
6722 -> 6721;
6722 -> 6679;
6723 -> 6722;
6724 -> 6720;
6724 -> 6723;
6725 -> 6723;
6726 -> 6724;
6726 -> 6725;
6727 -> 6726;
6727 -> 6723;
6728 -> 6723;
6729 -> 6727;
6729 -> 6728;
6730 -> 6729;
6730 -> 6671;
6731 -> 6700;
6731 -> 6671;
6731 -> 6699;
6732 -> 6731;
6732 -> 6702;
6733 -> 6731;
6733 -> 6705;
6734 -> 6733;
6734 -> 6699;
6735 -> 6734;
6735 -> 6697;
6736 -> 6735;
6736 -> 6671;
6737 -> 6736;
6737 -> 6710;
6738 -> 6737;
6738 -> 6671;
6738 -> 6710;
6739 -> 6467;
6740 -> 6464;
6740 -> 6671;
6740 -> 6467;
6741 -> 6467;
6742 -> 6460;
6743 -> 6460;
6744 -> 6743;
6744 -> 6460;
6745 -> 6461;
6745 -> 6460;
6746 -> 6743;
6746 -> 6460;
6747 -> 6462;
6747 -> 6740;
6747 -> 6745;
6747 -> 6746;
6747 -> 6744;
6747 -> 6460;
6748 -> 6747;
6748 -> 6460;
6749 -> 6748;
6749 -> 6458;
6750 -> 6749;
6751 -> 6749;
6751 -> 6750;
6752 -> 6751;
6752 -> 6748;
6752 -> 6750;
6753 -> 6752;
6753 -> 6749;
6754 -> 6749;
6755 -> 6749;
6755 -> 6754;
6756 -> 6755;
6756 -> 6748;
6756 -> 6754;
6757 -> 6756;
6757 -> 6749;
6758 -> 6753;
6758 -> 6757;
6758 -> 6749;
6759 -> 6758;
6760 -> 6267;
6760 -> 6759;
6760 -> 6758;
6761 -> 6749;
6761 -> 6758;
6762 -> 6749;
6762 -> 6750;
6763 -> 6750;
6764 -> 6763;
6764 -> 6749;
6765 -> 6260;
6765 -> 6217;
6765 -> 6259;
6766 -> 6260;
6766 -> 6217;
6766 -> 6259;
6767 -> 6766;
6768 -> 6767;
6769 -> 6761;
6769 -> 6768;
6769 -> 6767;
6770 -> 6761;
6770 -> 6767;
6771 -> 6223;
6772 -> 6770;
6772 -> 6771;
6772 -> 6223;
6773 -> 6770;
6773 -> 6223;
6774 -> 6216;
6775 -> 6773;
6775 -> 6774;
6776 -> 6774;
6776 -> 6216;
6777 -> 6216;
6778 -> 6773;
6778 -> 6777;
6779 -> 0;
6779 -> 6777;
6780 -> 6778;
6780 -> 6216;
6781 -> 6776;
6781 -> 6780;
6781 -> 6216;
6782 -> 6773;
6782 -> 6216;
6783 -> 6216;
6784 -> 6782;
6784 -> 6783;
6785 -> 6201;
6785 -> 6783;
6786 -> 6783;
6787 -> 6784;
6787 -> 0;
6787 -> 6783;
6788 -> 6783;
6789 -> 6784;
6789 -> 6788;
6790 -> 6788;
6791 -> 6789;
6791 -> 6790;
6792 -> 6791;
6792 -> 6748;
6792 -> 6790;
6793 -> 6792;
6793 -> 6788;
6794 -> 6788;
6795 -> 6793;
6795 -> 6794;
6795 -> 6788;
6796 -> 6795;
6796 -> 6788;
6797 -> 6796;
6798 -> 6793;
6798 -> 6797;
6799 -> 6797;
6800 -> 6798;
6800 -> 6799;
6801 -> 6800;
6801 -> 6797;
6802 -> 6797;
6803 -> 6801;
6803 -> 6802;
6804 -> 6803;
6804 -> 6783;
6805 -> 6785;
6805 -> 6783;
6806 -> 6783;
6807 -> 6784;
6807 -> 6806;
6808 -> 6806;
6809 -> 6807;
6809 -> 6808;
6810 -> 6809;
6810 -> 6748;
6810 -> 6808;
6811 -> 6808;
6812 -> 6810;
6812 -> 6811;
6813 -> 6811;
6813 -> 6808;
6814 -> 6808;
6815 -> 6810;
6815 -> 6814;
6816 -> 6814;
6817 -> 6815;
6817 -> 6808;
6818 -> 6817;
6818 -> 6806;
6819 -> 6818;
6819 -> 6783;
6820 -> 6783;
6821 -> 6819;
6821 -> 6820;
6822 -> 6821;
6822 -> 6748;
6822 -> 6820;
6823 -> 6783;
6824 -> 6783;
6825 -> 6785;
6825 -> 6824;
6826 -> 6825;
6826 -> 6748;
6826 -> 6824;
6827 -> 6826;
6827 -> 6783;
6828 -> 6785;
6828 -> 6783;
6829 -> 6783;
6830 -> 6785;
6830 -> 6748;
6830 -> 6829;
6830 -> 6783;
6831 -> 6783;
6832 -> 6784;
6833 -> 6785;
6833 -> 6784;
6834 -> 6216;
6835 -> 6201;
6835 -> 6784;
6835 -> 6200;
6835 -> 6199;
6836 -> 6181;
6837 -> 6835;
6837 -> 6836;
6838 -> 6837;
6838 -> 6181;
6839 -> 6835;
6839 -> 6181;
6840 -> 1;
6841 -> 6174;
6841 -> 6840;
6842 -> 6840;
6843 -> 6841;
6843 -> 6842;
6844 -> 0;
6844 -> 6842;
6845 -> 6842;
6846 -> 6844;
6846 -> 6845;
6847 -> 6843;
6847 -> 6845;
6848 -> 6845;
6849 -> 6846;
6849 -> 6848;
6849 -> 6845;
6850 -> 6845;
6851 -> 6847;
6851 -> 6784;
6851 -> 6850;
6851 -> 6845;
6852 -> 6845;
6853 -> 6847;
6853 -> 6852;
6854 -> 6852;
6855 -> 6853;
6855 -> 6854;
6856 -> 6854;
6857 -> 6855;
6857 -> 6784;
6857 -> 6856;
6857 -> 6854;
6858 -> 6857;
6858 -> 6852;
6859 -> 6858;
6859 -> 6845;
6860 -> 6859;
6860 -> 6845;
6861 -> 6845;
6862 -> 6860;
6862 -> 6861;
6863 -> 6862;
6863 -> 6857;
6863 -> 6861;
6864 -> 6863;
6864 -> 6857;
6864 -> 6845;
6865 -> 6845;
6866 -> 6847;
6866 -> 6865;
6867 -> 6865;
6868 -> 6866;
6868 -> 6867;
6869 -> 0;
6869 -> 6867;
6870 -> 6869;
6870 -> 6865;
6871 -> 6865;
6872 -> 6871;
6873 -> 6866;
6873 -> 6872;
6874 -> 6873;
6874 -> 6857;
6874 -> 6872;
6875 -> 6871;
6876 -> 6865;
6877 -> 6874;
6877 -> 6845;
6878 -> 6845;
6879 -> 6845;
6880 -> 6879;
6880 -> 6845;
6881 -> 6845;
6882 -> 6845;
6883 -> 6847;
6883 -> 6882;
6884 -> 6882;
6885 -> 6884;
6885 -> 6845;
6886 -> 6845;
6887 -> 6885;
6887 -> 6886;
6887 -> 6845;
6888 -> 6887;
6889 -> 6847;
6889 -> 6888;
6890 -> 6889;
6890 -> 6857;
6890 -> 6888;
6891 -> 6890;
6891 -> 6887;
6892 -> 6887;
6893 -> 6887;
6894 -> 6891;
6894 -> 6893;
6895 -> 6892;
6895 -> 6893;
6896 -> 6877;
6896 -> 6893;
6897 -> 6895;
6897 -> 6893;
6898 -> 6893;
6899 -> 6893;
6900 -> 6898;
6900 -> 6899;
6901 -> 6900;
6901 -> 6899;
6902 -> 6899;
6903 -> 6902;
6904 -> 6903;
6905 -> 6896;
6905 -> 6894;
6905 -> 6903;
6906 -> 6899;
6907 -> 6899;
6908 -> 6896;
6908 -> 6905;
6908 -> 6899;
6909 -> 6899;
6910 -> 6908;
6910 -> 6909;
6910 -> 6899;
6911 -> 6907;
6911 -> 6899;
6912 -> 6908;
6912 -> 6911;
6912 -> 6905;
6912 -> 6899;
6913 -> 6900;
6913 -> 6899;
6914 -> 6899;
6915 -> 6913;
6915 -> 6914;
6916 -> 6915;
6916 -> 6914;
6917 -> 6914;
6918 -> 6914;
6919 -> 6916;
6919 -> 6918;
6920 -> 6917;
6920 -> 6918;
6921 -> 6920;
6921 -> 6918;
6922 -> 6920;
6922 -> 6918;
6923 -> 6920;
6923 -> 6918;
6924 -> 6920;
6924 -> 6918;
6925 -> 6920;
6925 -> 6918;
6926 -> 6920;
6926 -> 6918;
6927 -> 6919;
6927 -> 6920;
6927 -> 6918;
6928 -> 6920;
6928 -> 6918;
6929 -> 6918;
6930 -> 6918;
6931 -> 6930;
6931 -> 6920;
6931 -> 6918;
6932 -> 6918;
6933 -> 6918;
6934 -> 6932;
6934 -> 6933;
6935 -> 6933;
6936 -> 6934;
6936 -> 6935;
6937 -> 6936;
6937 -> 6935;
6938 -> 6936;
6938 -> 6935;
6939 -> 6936;
6939 -> 6935;
6940 -> 6936;
6940 -> 6935;
6941 -> 6936;
6941 -> 6935;
6942 -> 6935;
6943 -> 6896;
6943 -> 6942;
6943 -> 6935;
6944 -> 6936;
6944 -> 6935;
6945 -> 6944;
6945 -> 6937;
6945 -> 6938;
6945 -> 6939;
6945 -> 6940;
6945 -> 6941;
6945 -> 6935;
6946 -> 6935;
6947 -> 6932;
6947 -> 6920;
6947 -> 6918;
6948 -> 6917;
6948 -> 6914;
6949 -> 6914;
6950 -> 6949;
6951 -> 6949;
6952 -> 6912;
6952 -> 6951;
6952 -> 6949;
6953 -> 6950;
6953 -> 6949;
6954 -> 6912;
6954 -> 6953;
6954 -> 6949;
6955 -> 6864;
6955 -> 6887;
6956 -> 6887;
6957 -> 6887;
6958 -> 6955;
6958 -> 6957;
6959 -> 6956;
6959 -> 6957;
6960 -> 6956;
6960 -> 6957;
6961 -> 6954;
6961 -> 6957;
6962 -> 6958;
6962 -> 6954;
6962 -> 6957;
6963 -> 6957;
6964 -> 6957;
6965 -> 6958;
6965 -> 6954;
6965 -> 6964;
6965 -> 6957;
6966 -> 6959;
6966 -> 6957;
6967 -> 6960;
6967 -> 6957;
6968 -> 6957;
6969 -> 6966;
6969 -> 6968;
6970 -> 6967;
6970 -> 6968;
6971 -> 6968;
6972 -> 6965;
6972 -> 6971;
6972 -> 6968;
6973 -> 6970;
6973 -> 6968;
6974 -> 6968;
6975 -> 6974;
6976 -> 6975;
6976 -> 6974;
6977 -> 6975;
6977 -> 6974;
6978 -> 6975;
6978 -> 6974;
6979 -> 6975;
6979 -> 6974;
6980 -> 6969;
6980 -> 6968;
6981 -> 6970;
6981 -> 6968;
6982 -> 6968;
6983 -> 6980;
6983 -> 6982;
6984 -> 6981;
6984 -> 6982;
6985 -> 6982;
6986 -> 6982;
6987 -> 6983;
6987 -> 6986;
6988 -> 6985;
6988 -> 6986;
6989 -> 6988;
6989 -> 6986;
6990 -> 6987;
6990 -> 6989;
6991 -> 6983;
6991 -> 6985;
6991 -> 6982;
6992 -> 6984;
6992 -> 6985;
6992 -> 6982;
6993 -> 6991;
6993 -> 6992;
6993 -> 6982;
6994 -> 6983;
6994 -> 6961;
6994 -> 6982;
6995 -> 6984;
6995 -> 6961;
6995 -> 6982;
6996 -> 6968;
6997 -> 6968;
6998 -> 6997;
6999 -> 6998;
7000 -> 6965;
7000 -> 6999;
7001 -> 6965;
7001 -> 6999;
7002 -> 7000;
7002 -> 6965;
7002 -> 6999;
7003 -> 6999;
7004 -> 7002;
7004 -> 7003;
7005 -> 7001;
7005 -> 7003;
7006 -> 7005;
7006 -> 7004;
7006 -> 6965;
7006 -> 7003;
7007 -> 7006;
7007 -> 7003;
7008 -> 7006;
7008 -> 7003;
7009 -> 7007;
7009 -> 7006;
7009 -> 7003;
7010 -> 7003;
7011 -> 7009;
7011 -> 7010;
7012 -> 7008;
7012 -> 7010;
7013 -> 7012;
7013 -> 7011;
7013 -> 7006;
7013 -> 7010;
7014 -> 7010;
7015 -> 4861;
7015 -> 7014;
7016 -> 7014;
7017 -> 7014;
7018 -> 7017;
7019 -> 7013;
7019 -> 7018;
7020 -> 7018;
7021 -> 7018;
7022 -> 7018;
7023 -> 7021;
7023 -> 7022;
7024 -> 7021;
7024 -> 7017;
7025 -> 7017;
7026 -> 7017;
7027 -> 7024;
7027 -> 7017;
7028 -> 7025;
7028 -> 7017;
7029 -> 7017;
7030 -> 7013;
7031 -> 7030;
7031 -> 7013;
7032 -> 7013;
7033 -> 7013;
7034 -> 7013;
7035 -> 7013;
7036 -> 7013;
7037 -> 7013;
7038 -> 7013;
7039 -> 7013;
7040 -> 7013;
7040 -> 7039;
7041 -> 7038;
7041 -> 7039;
7042 -> 7041;
7042 -> 7039;
7043 -> 7040;
7043 -> 7042;
7044 -> 7013;
7045 -> 7013;
7045 -> 7044;
7046 -> 7045;
7046 -> 7013;
7046 -> 7044;
7047 -> 7046;
7047 -> 7013;
7048 -> 7013;
7049 -> 7013;
7050 -> 7013;
7051 -> 7013;
7052 -> 7013;
7053 -> 7013;
7054 -> 7013;
7055 -> 7013;
7056 -> 7013;
7057 -> 7056;
7058 -> 7013;
7059 -> 7013;
7060 -> 7013;
7061 -> 7013;
7062 -> 7013;
7063 -> 7013;
7064 -> 7013;
7065 -> 7013;
7066 -> 7003;
7067 -> 7013;
7067 -> 7066;
7068 -> 7013;
7068 -> 7066;
7069 -> 0;
7069 -> 7066;
7070 -> 7066;
7071 -> 7069;
7071 -> 7070;
7072 -> 0;
7072 -> 6887;
7073 -> 6847;
7073 -> 6887;
7074 -> 6887;
7075 -> 7072;
7075 -> 7074;
7076 -> 7073;
7076 -> 7074;
7077 -> 7068;
7077 -> 7074;
7078 -> 7074;
7079 -> 7076;
7079 -> 7078;
7079 -> 7074;
7080 -> 7077;
7080 -> 7074;
7081 -> 7077;
7081 -> 7068;
7081 -> 7075;
7081 -> 7074;
7082 -> 7076;
7082 -> 7074;
7083 -> 7074;
7084 -> 7074;
7085 -> 7080;
7085 -> 7084;
7086 -> 7081;
7086 -> 7084;
7087 -> 7082;
7087 -> 7084;
7088 -> 7083;
7088 -> 7084;
7089 -> 7085;
7089 -> 7084;
7090 -> 7086;
7090 -> 7084;
7091 -> 7084;
7092 -> 7089;
7092 -> 7091;
7093 -> 7090;
7093 -> 7091;
7094 -> 7088;
7094 -> 7091;
7095 -> 7094;
7095 -> 7091;
7096 -> 7094;
7096 -> 7091;
7097 -> 7094;
7097 -> 7091;
7098 -> 7094;
7098 -> 7091;
7099 -> 7094;
7099 -> 7091;
7100 -> 7091;
7101 -> 7092;
7101 -> 7100;
7101 -> 7091;
7102 -> 7093;
7102 -> 7091;
7103 -> 0;
7103 -> 7091;
7104 -> 7091;
7105 -> 7102;
7105 -> 7104;
7106 -> 7103;
7106 -> 7104;
7107 -> 7093;
7107 -> 7091;
7108 -> 0;
7108 -> 7091;
7109 -> 7091;
7110 -> 7107;
7110 -> 7109;
7111 -> 7108;
7111 -> 7109;
7112 -> 7092;
7112 -> 7094;
7112 -> 7091;
7113 -> 7093;
7113 -> 7094;
7113 -> 7091;
7114 -> 7092;
7114 -> 7068;
7114 -> 7094;
7114 -> 7091;
7115 -> 7088;
7115 -> 7084;
7116 -> 7084;
7117 -> 7084;
7118 -> 7087;
7118 -> 7117;
7119 -> 7116;
7119 -> 7117;
7120 -> 7119;
7120 -> 7117;
7121 -> 7118;
7121 -> 7120;
7122 -> 7087;
7122 -> 7116;
7122 -> 7084;
7123 -> 7087;
7123 -> 7088;
7123 -> 7084;
7124 -> 7083;
7124 -> 6887;
7125 -> 6887;
7126 -> 6847;
7126 -> 7125;
7127 -> 7126;
7127 -> 7068;
7127 -> 7125;
7128 -> 7127;
7128 -> 6887;
7129 -> 6887;
7130 -> 7128;
7130 -> 7129;
7131 -> 7129;
7132 -> 7130;
7132 -> 0;
7132 -> 7129;
7133 -> 6864;
7133 -> 7132;
7134 -> 6881;
7134 -> 7132;
7135 -> 7132;
7136 -> 7132;
7137 -> 7133;
7137 -> 7136;
7138 -> 7134;
7138 -> 7136;
7139 -> 7135;
7139 -> 7136;
7140 -> 7135;
7140 -> 7136;
7141 -> 7124;
7141 -> 7136;
7142 -> 7137;
7142 -> 7136;
7143 -> 7138;
7143 -> 7136;
7144 -> 7139;
7144 -> 7136;
7145 -> 7140;
7145 -> 7136;
7146 -> 7136;
7147 -> 7142;
7147 -> 7146;
7148 -> 7143;
7148 -> 7146;
7149 -> 7144;
7149 -> 7146;
7150 -> 7145;
7150 -> 7146;
7151 -> 7141;
7151 -> 7146;
7152 -> 7146;
7153 -> 7148;
7153 -> 7152;
7153 -> 7146;
7154 -> 7147;
7154 -> 7146;
7155 -> 7148;
7155 -> 7146;
7156 -> 7149;
7156 -> 7146;
7157 -> 7146;
7158 -> 7149;
7158 -> 7157;
7158 -> 7146;
7159 -> 7158;
7159 -> 7150;
7159 -> 7146;
7160 -> 7146;
7161 -> 7154;
7161 -> 7160;
7162 -> 7155;
7162 -> 7160;
7163 -> 7156;
7163 -> 7160;
7164 -> 7159;
7164 -> 7160;
7165 -> 7151;
7165 -> 7160;
7166 -> 7161;
7166 -> 7130;
7166 -> 7160;
7167 -> 7161;
7167 -> 7166;
7168 -> 7162;
7168 -> 7166;
7169 -> 7163;
7169 -> 7166;
7170 -> 7166;
7171 -> 7167;
7171 -> 7170;
7172 -> 7168;
7172 -> 7170;
7173 -> 7169;
7173 -> 7170;
7174 -> 7165;
7174 -> 7170;
7175 -> 7171;
7175 -> 7170;
7176 -> 7175;
7176 -> 7166;
7176 -> 7170;
7177 -> 7176;
7177 -> 7170;
7178 -> 7172;
7178 -> 7170;
7179 -> 7173;
7179 -> 7170;
7180 -> 7170;
7181 -> 7170;
7182 -> 7177;
7182 -> 7181;
7183 -> 7178;
7183 -> 7181;
7184 -> 7179;
7184 -> 7181;
7185 -> 7180;
7185 -> 7181;
7186 -> 7174;
7186 -> 7181;
7187 -> 7185;
7187 -> 7181;
7188 -> 7181;
7189 -> 7183;
7189 -> 7188;
7189 -> 7181;
7190 -> 7184;
7190 -> 7187;
7190 -> 7181;
7191 -> 7190;
7191 -> 7181;
7192 -> 7182;
7193 -> 7183;
7193 -> 7182;
7194 -> 7182;
7195 -> 7192;
7195 -> 7194;
7196 -> 7193;
7196 -> 7194;
7197 -> 7186;
7197 -> 7194;
7198 -> 7195;
7198 -> 7194;
7199 -> 7198;
7199 -> 7194;
7200 -> 7196;
7200 -> 7194;
7201 -> 7194;
7202 -> 7199;
7202 -> 7201;
7203 -> 7200;
7203 -> 7201;
7204 -> 7197;
7204 -> 7201;
7205 -> 7202;
7205 -> 7182;
7205 -> 7201;
7206 -> 7203;
7206 -> 7201;
7207 -> 7202;
7207 -> 7201;
7208 -> 7201;
7209 -> 7205;
7209 -> 7208;
7210 -> 7206;
7210 -> 7208;
7211 -> 7207;
7211 -> 7208;
7212 -> 7204;
7212 -> 7208;
7213 -> 7212;
7213 -> 7114;
7213 -> 7208;
7214 -> 7209;
7214 -> 7208;
7215 -> 7211;
7215 -> 7208;
7216 -> 7210;
7216 -> 7208;
7217 -> 7208;
7218 -> 7213;
7218 -> 7217;
7219 -> 7214;
7219 -> 7217;
7220 -> 7215;
7220 -> 7217;
7221 -> 7216;
7221 -> 7217;
7222 -> 7219;
7222 -> 7217;
7223 -> 7217;
7224 -> 7222;
7224 -> 7223;
7225 -> 7218;
7225 -> 7223;
7226 -> 7224;
7226 -> 0;
7226 -> 7223;
7227 -> 7223;
7228 -> 7225;
7228 -> 7224;
7228 -> 7205;
7228 -> 7223;
7229 -> 7228;
7230 -> 7228;
7231 -> 7230;
7231 -> 7228;
7232 -> 7231;
7233 -> 7231;
7233 -> 7232;
7234 -> 7232;
7235 -> 7233;
7235 -> 7234;
7236 -> 7234;
7237 -> 7235;
7237 -> 7228;
7237 -> 7236;
7237 -> 7234;
7238 -> 7232;
7239 -> 7233;
7239 -> 7228;
7239 -> 7232;
7240 -> 7239;
7240 -> 7231;
7241 -> 7231;
7242 -> 7228;
7243 -> 7223;
7244 -> 7242;
7244 -> 7243;
7245 -> 7244;
7245 -> 7223;
7246 -> 7242;
7246 -> 7223;
7247 -> 7217;
7248 -> 7246;
7248 -> 7247;
7248 -> 7217;
7249 -> 7246;
7249 -> 7217;
7250 -> 7221;
7250 -> 7217;
7251 -> 7220;
7251 -> 7217;
7252 -> 7217;
7253 -> 7249;
7253 -> 7252;
7254 -> 7250;
7254 -> 7252;
7255 -> 7251;
7255 -> 7252;
7256 -> 7252;
7257 -> 7253;
7257 -> 7256;
7258 -> 7257;
7258 -> 7228;
7258 -> 7256;
7259 -> 0;
7259 -> 7256;
7260 -> 7258;
7261 -> 7257;
7261 -> 7260;
7262 -> 7260;
7263 -> 7262;
7263 -> 7260;
7264 -> 7260;
7265 -> 7261;
7265 -> 7264;
7266 -> 7264;
7267 -> 7266;
7267 -> 7264;
7268 -> 7264;
7269 -> 7265;
7269 -> 7268;
7270 -> 7268;
7271 -> 7269;
7271 -> 7270;
7272 -> 7271;
7272 -> 7228;
7272 -> 7270;
7273 -> 2665;
7273 -> 7270;
7274 -> 7271;
7274 -> 7228;
7274 -> 7272;
7275 -> 7272;
7276 -> 7271;
7276 -> 7275;
7277 -> 7275;
7278 -> 7275;
7279 -> 7277;
7279 -> 7278;
7280 -> 7276;
7280 -> 7278;
7281 -> 7278;
7282 -> 7278;
7283 -> 7281;
7283 -> 7282;
7284 -> 7280;
7284 -> 7282;
7285 -> 7284;
7285 -> 7228;
7285 -> 7282;
7286 -> 2665;
7286 -> 7282;
7287 -> 7285;
7288 -> 7284;
7288 -> 7287;
7289 -> 7288;
7289 -> 7228;
7289 -> 7287;
7290 -> 7289;
7291 -> 7288;
7291 -> 7290;
7292 -> 7291;
7292 -> 7228;
7292 -> 7290;
7293 -> 7290;
7294 -> 7292;
7294 -> 7293;
7295 -> 7293;
7295 -> 7290;
7296 -> 7290;
7297 -> 7292;
7297 -> 7296;
7298 -> 7297;
7298 -> 7290;
7299 -> 7298;
7299 -> 7289;
7300 -> 7289;
7301 -> 7299;
7301 -> 7300;
7302 -> 7301;
7302 -> 7289;
7303 -> 7288;
7303 -> 7228;
7303 -> 7289;
7304 -> 7302;
7304 -> 7289;
7305 -> 7299;
7305 -> 7304;
7306 -> 7288;
7306 -> 7304;
7307 -> 7304;
7308 -> 7304;
7309 -> 7305;
7309 -> 7308;
7310 -> 7306;
7310 -> 7308;
7311 -> 7307;
7311 -> 7308;
7312 -> 7309;
7312 -> 7308;
7313 -> 7310;
7313 -> 7308;
7314 -> 7308;
7315 -> 7308;
7316 -> 7312;
7316 -> 7315;
7317 -> 7313;
7317 -> 7315;
7318 -> 7314;
7318 -> 7315;
7319 -> 7311;
7319 -> 7315;
7320 -> 7315;
7321 -> 7316;
7321 -> 7320;
7322 -> 7315;
7323 -> 7316;
7323 -> 7322;
7324 -> 7323;
7324 -> 7315;
7325 -> 7324;
7326 -> 7324;
7327 -> 7325;
7327 -> 7326;
7328 -> 7327;
7328 -> 7302;
7328 -> 7326;
7330 -> 7329;
7331 -> 7329;
7332 -> 7331;
7332 -> 7315;
7333 -> 7316;
7333 -> 7315;
7334 -> 7315;
7335 -> 7334;
7335 -> 7321;
7335 -> 7328;
7335 -> 7332;
7335 -> 7333;
7335 -> 7302;
7335 -> 7330;
7335 -> 7315;
7336 -> 7334;
7336 -> 7315;
7337 -> 7334;
7337 -> 7315;
7338 -> 7315;
7339 -> 7316;
7339 -> 7338;
7339 -> 7315;
7340 -> 7317;
7340 -> 7334;
7340 -> 7315;
7341 -> 7318;
7341 -> 7334;
7341 -> 7315;
7342 -> 7302;
7342 -> 7304;
7343 -> 7342;
7343 -> 7307;
7343 -> 7302;
7343 -> 7335;
7343 -> 7336;
7343 -> 7340;
7343 -> 7337;
7343 -> 7341;
7343 -> 7304;
7344 -> 7343;
7344 -> 7307;
7345 -> 7344;
7345 -> 7343;
7345 -> 7307;
7346 -> 7345;
7346 -> 7285;
7347 -> 7346;
7347 -> 7285;
7348 -> 7283;
7348 -> 7347;
7349 -> 7347;
7350 -> 7349;
7351 -> 7349;
7351 -> 7350;
7352 -> 7350;
7352 -> 7349;
7353 -> 7349;
7353 -> 7347;
7354 -> 7346;
7354 -> 7347;
7355 -> 7347;
7356 -> 7284;
7356 -> 7345;
7356 -> 7347;
7357 -> 7353;
7357 -> 7347;
7358 -> 7347;
7359 -> 7354;
7359 -> 7358;
7360 -> 7355;
7360 -> 7358;
7361 -> 7356;
7361 -> 7358;
7362 -> 7357;
7362 -> 7358;
7363 -> 7355;
7363 -> 7358;
7364 -> 7358;
7365 -> 7359;
7365 -> 7364;
7365 -> 7358;
7366 -> 7358;
7367 -> 7366;
7367 -> 7358;
7368 -> 7358;
7369 -> 7362;
7369 -> 7368;
7370 -> 7369;
7370 -> 7358;
7371 -> 7361;
7371 -> 7358;
7372 -> 7366;
7372 -> 7358;
7373 -> 7370;
7373 -> 7371;
7373 -> 7372;
7373 -> 7345;
7373 -> 7367;
7373 -> 7358;
7374 -> 7359;
7374 -> 7358;
7375 -> 7374;
7375 -> 7347;
7376 -> 7284;
7376 -> 7373;
7376 -> 7347;
7377 -> 7353;
7377 -> 7347;
7378 -> 7347;
7379 -> 7375;
7379 -> 7378;
7380 -> 7376;
7380 -> 7378;
7381 -> 7377;
7381 -> 7378;
7382 -> 7378;
7383 -> 7381;
7383 -> 7382;
7384 -> 7383;
7384 -> 7373;
7384 -> 7382;
7385 -> 7384;
7385 -> 7378;
7386 -> 7380;
7386 -> 7378;
7387 -> 7378;
7388 -> 7385;
7388 -> 7386;
7388 -> 7387;
7388 -> 7373;
7388 -> 7378;
7389 -> 7388;
7389 -> 7378;
7390 -> 7379;
7390 -> 7389;
7391 -> 7390;
7391 -> 7347;
7392 -> 7284;
7392 -> 7388;
7392 -> 7347;
7393 -> 7353;
7393 -> 7347;
7394 -> 7347;
7395 -> 7391;
7395 -> 7394;
7396 -> 7392;
7396 -> 7394;
7397 -> 7393;
7397 -> 7394;
7398 -> 7394;
7399 -> 7398;
7399 -> 7394;
7400 -> 7394;
7401 -> 7397;
7401 -> 7400;
7402 -> 7401;
7402 -> 7388;
7402 -> 7400;
7403 -> 7402;
7403 -> 7394;
7404 -> 7396;
7404 -> 7394;
7405 -> 7398;
7405 -> 7394;
7406 -> 7403;
7406 -> 7404;
7406 -> 7405;
7406 -> 7388;
7406 -> 7399;
7406 -> 7394;
7407 -> 7406;
7407 -> 7394;
7408 -> 7395;
7408 -> 7394;
7409 -> 7406;
7409 -> 7394;
7410 -> 7394;
7411 -> 7408;
7411 -> 7410;
7412 -> 7409;
7412 -> 7410;
7413 -> 7409;
7413 -> 7410;
7414 -> 7411;
7414 -> 7410;
7415 -> 7414;
7415 -> 7406;
7415 -> 7410;
7416 -> 7412;
7416 -> 7410;
7417 -> 7410;
7418 -> 7410;
7419 -> 7416;
7419 -> 7418;
7420 -> 7417;
7420 -> 7418;
7421 -> 7419;
7421 -> 7420;
7421 -> 7418;
7422 -> 7419;
7422 -> 7406;
7422 -> 7418;
7423 -> 7422;
7424 -> 7423;
7424 -> 7420;
7424 -> 7418;
7425 -> 7418;
7426 -> 7425;
7426 -> 7420;
7426 -> 7418;
7427 -> 7418;
7428 -> 7427;
7428 -> 7420;
7428 -> 7418;
7429 -> 7411;
7429 -> 7410;
7430 -> 7410;
7431 -> 7429;
7431 -> 7430;
7432 -> 7417;
7432 -> 7430;
7433 -> 7430;
7434 -> 7431;
7434 -> 7433;
7435 -> 7433;
7435 -> 7430;
7436 -> 7431;
7436 -> 7435;
7437 -> 7435;
7438 -> 7436;
7438 -> 7437;
7439 -> 7432;
7439 -> 7437;
7440 -> 7437;
7441 -> 7438;
7441 -> 7440;
7442 -> 0;
7442 -> 7440;
7443 -> 7442;
7443 -> 7437;
7444 -> 7443;
7444 -> 7437;
7445 -> 7437;
7446 -> 7444;
7446 -> 7445;
7447 -> 7439;
7447 -> 7445;
7448 -> 7446;
7448 -> 0;
7448 -> 7445;
7449 -> 7446;
7449 -> 7448;
7450 -> 7438;
7450 -> 7437;
7451 -> 7437;
7452 -> 7438;
7452 -> 7451;
7453 -> 7452;
7453 -> 7415;
7453 -> 7451;
7454 -> 7453;
7454 -> 7437;
7455 -> 7437;
7456 -> 7454;
7456 -> 7437;
7457 -> 7454;
7457 -> 7456;
7458 -> 7457;
7458 -> 7437;
7459 -> 7454;
7459 -> 7437;
7460 -> 7443;
7460 -> 7449;
7460 -> 7437;
7461 -> 7460;
7461 -> 7458;
7461 -> 7437;
7462 -> 7437;
7463 -> 7450;
7463 -> 7462;
7464 -> 7462;
7465 -> 7464;
7465 -> 7462;
7466 -> 7465;
7466 -> 7462;
7467 -> 7463;
7467 -> 7462;
7468 -> 7462;
7469 -> 7467;
7469 -> 7468;
7470 -> 7468;
7471 -> 7470;
7471 -> 7462;
7472 -> 7462;
7473 -> 7467;
7473 -> 7472;
7474 -> 7473;
7474 -> 7415;
7474 -> 7472;
7475 -> 7474;
7475 -> 7462;
7476 -> 7462;
7477 -> 7475;
7477 -> 7476;
7478 -> 7476;
7478 -> 7462;
7479 -> 7471;
7479 -> 7478;
7479 -> 7462;
7480 -> 7462;
7481 -> 7467;
7481 -> 7480;
7482 -> 7481;
7482 -> 7480;
7483 -> 7482;
7483 -> 7415;
7483 -> 7480;
7484 -> 7483;
7484 -> 7462;
7485 -> 7462;
7486 -> 7484;
7486 -> 7485;
7487 -> 7462;
7488 -> 7486;
7488 -> 7487;
7489 -> 7487;
7489 -> 7462;
7490 -> 7462;
7491 -> 7479;
7491 -> 7489;
7491 -> 7462;
7492 -> 7462;
7493 -> 7467;
7493 -> 7492;
7494 -> 7493;
7494 -> 7415;
7494 -> 7492;
7495 -> 7494;
7495 -> 7462;
7496 -> 7495;
7496 -> 2554;
7496 -> 7462;
7497 -> 7491;
7497 -> 7496;
7497 -> 7462;
7498 -> 7462;
7499 -> 7462;
7499 -> 7437;
7500 -> 7450;
7500 -> 7437;
7501 -> 7417;
7501 -> 7426;
7501 -> 7410;
7502 -> 7413;
7502 -> 7501;
7503 -> 7500;
7503 -> 7502;
7504 -> 0;
7505 -> 0;
7506 -> 0;
7507 -> 7506;
7509 -> 7504;
7509 -> 7505;
7509 -> 7507;
7509 -> 7508;
7510 -> 7509;
7511 -> 0;
7512 -> 0;
7513 -> 0;
7514 -> 7513;
7514 -> 0;
7515 -> 7514;
7517 -> 7511;
7517 -> 7512;
7517 -> 7515;
7517 -> 7516;
7518 -> 7517;
7519 -> 7503;
7519 -> 7347;
7520 -> 7347;
7521 -> 7347;
7522 -> 7519;
7522 -> 7521;
7523 -> 7520;
7523 -> 7521;
7524 -> 7520;
7524 -> 7521;
7525 -> 7522;
7525 -> 7521;
7526 -> 7523;
7526 -> 0;
7526 -> 7521;
7527 -> 7523;
7527 -> 7521;
7528 -> 7522;
7528 -> 7527;
7529 -> 7527;
7530 -> 7528;
7530 -> 7529;
7531 -> 7529;
7532 -> 7530;
7532 -> 7531;
7533 -> 7531;
7534 -> 7532;
7534 -> 7533;
7535 -> 7533;
7536 -> 7534;
7536 -> 7535;
7537 -> 7536;
7537 -> 7535;
7538 -> 7537;
7538 -> 7533;
7539 -> 7538;
7539 -> 7531;
7540 -> 7539;
7540 -> 7529;
7541 -> 7529;
7542 -> 7540;
7542 -> 7541;
7543 -> 7542;
7543 -> 7415;
7543 -> 7541;
7544 -> 7522;
7544 -> 7521;
7545 -> 7523;
7545 -> 7521;
7546 -> 7524;
7546 -> 7521;
7547 -> 7521;
7548 -> 7544;
7548 -> 7547;
7549 -> 7545;
7549 -> 7547;
7550 -> 7546;
7550 -> 7547;
7551 -> 0;
7553 -> 7551;
7553 -> 7552;
7554 -> 7552;
7555 -> 7554;
7556 -> 7553;
7556 -> 0;
7556 -> 7552;
7557 -> 7553;
7557 -> 7554;
7557 -> 7552;
7558 -> 7552;
7559 -> 7548;
7559 -> 7547;
7560 -> 7549;
7560 -> 7547;
7561 -> 7550;
7561 -> 7547;
7562 -> 7547;
7563 -> 7561;
7563 -> 7562;
7564 -> 7563;
7564 -> 7546;
7564 -> 7562;
7565 -> 7558;
7565 -> 7564;
7566 -> 7547;
7567 -> 7547;
7568 -> 7559;
7568 -> 7567;
7569 -> 7560;
7569 -> 7567;
7570 -> 7565;
7570 -> 7567;
7571 -> 7566;
7571 -> 7567;
7572 -> 7568;
7572 -> 7567;
7573 -> 7572;
7573 -> 7567;
7574 -> 7568;
7574 -> 7573;
7575 -> 7573;
7576 -> 7574;
7576 -> 7575;
7577 -> 7575;
7578 -> 7576;
7578 -> 7577;
7579 -> 7577;
7580 -> 7578;
7580 -> 7579;
7581 -> 7579;
7582 -> 7580;
7582 -> 7581;
7583 -> 7582;
7583 -> 7581;
7584 -> 7583;
7584 -> 7579;
7585 -> 7584;
7585 -> 7577;
7586 -> 7585;
7586 -> 7575;
7587 -> 7575;
7588 -> 7586;
7588 -> 7587;
7589 -> 7588;
7589 -> 7415;
7589 -> 7587;
7590 -> 7569;
7590 -> 0;
7590 -> 7567;
7591 -> 7567;
7592 -> 7589;
7592 -> 7591;
7592 -> 7567;
7593 -> 7567;
7594 -> 7570;
7594 -> 7593;
7594 -> 7567;
7595 -> 7568;
7595 -> 7571;
7595 -> 7567;
7596 -> 7569;
7596 -> 7571;
7596 -> 7567;
7597 -> 7570;
7597 -> 7571;
7597 -> 7567;
7598 -> 7566;
7598 -> 7521;
7599 -> 7598;
7599 -> 7347;
7600 -> 7284;
7600 -> 7415;
7600 -> 7347;
7601 -> 7353;
7601 -> 7347;
7602 -> 7284;
7602 -> 7347;
7603 -> 7347;
7604 -> 7599;
7604 -> 7603;
7605 -> 7600;
7605 -> 7603;
7606 -> 7601;
7606 -> 7603;
7607 -> 7602;
7607 -> 7603;
7608 -> 7602;
7608 -> 7603;
7609 -> 7603;
7610 -> 7604;
7610 -> 7609;
7611 -> 7610;
7611 -> 7595;
7611 -> 7609;
7612 -> 7611;
7612 -> 7609;
7613 -> 7612;
7613 -> 7603;
7614 -> 7603;
7615 -> 7607;
7615 -> 7614;
7616 -> 7614;
7617 -> 7615;
7617 -> 7616;
7618 -> 7616;
7619 -> 7617;
7619 -> 7618;
7620 -> 7618;
7621 -> 7619;
7621 -> 7620;
7622 -> 7620;
7623 -> 7621;
7623 -> 7622;
7624 -> 7623;
7624 -> 7622;
7625 -> 7624;
7625 -> 7620;
7626 -> 7625;
7626 -> 7618;
7627 -> 7626;
7627 -> 7616;
7628 -> 7627;
7628 -> 7614;
7629 -> 7628;
7629 -> 7603;
7630 -> 7603;
7631 -> 7607;
7631 -> 7630;
7632 -> 7630;
7633 -> 7631;
7633 -> 7632;
7634 -> 7633;
7634 -> 7415;
7634 -> 7632;
7635 -> 7632;
7636 -> 7634;
7636 -> 7635;
7637 -> 7635;
7637 -> 7632;
7638 -> 7634;
7638 -> 7630;
7639 -> 7638;
7639 -> 7603;
7640 -> 7639;
7640 -> 7606;
7640 -> 7603;
7641 -> 7603;
7642 -> 7607;
7642 -> 7603;
7643 -> 7603;
7644 -> 7642;
7644 -> 7643;
7645 -> 7641;
7645 -> 7643;
7646 -> 7644;
7646 -> 7643;
7647 -> 7643;
7648 -> 7644;
7648 -> 7647;
7649 -> 7647;
7649 -> 7643;
7650 -> 7643;
7651 -> 7643;
7652 -> 7644;
7652 -> 7651;
7653 -> 0;
7653 -> 7651;
7654 -> 7652;
7654 -> 7415;
7654 -> 0;
7654 -> 7651;
7655 -> 7654;
7655 -> 7643;
7656 -> 7643;
7657 -> 7644;
7657 -> 7656;
7658 -> 7657;
7658 -> 7415;
7658 -> 7656;
7659 -> 7658;
7659 -> 7643;
7660 -> 7659;
7660 -> 7643;
7661 -> 7643;
7662 -> 7661;
7662 -> 7603;
7663 -> 7603;
7664 -> 7603;
7665 -> 7664;
7665 -> 7603;
7666 -> 7603;
7667 -> 7606;
7667 -> 7666;
7668 -> 7667;
7668 -> 7415;
7668 -> 7666;
7669 -> 7668;
7669 -> 7603;
7670 -> 7605;
7670 -> 7603;
7671 -> 7663;
7671 -> 7603;
7672 -> 7664;
7672 -> 7603;
7673 -> 7669;
7673 -> 7670;
7673 -> 7671;
7673 -> 7672;
7673 -> 7415;
7673 -> 7665;
7673 -> 7603;
7674 -> 7673;
7675 -> 7608;
7675 -> 7674;
7676 -> 7674;
7677 -> 7675;
7677 -> 7673;
7677 -> 7674;
7678 -> 7676;
7678 -> 7674;
7679 -> 7674;
7680 -> 7677;
7680 -> 7679;
7681 -> 7678;
7681 -> 7679;
7682 -> 7680;
7682 -> 7679;
7683 -> 7682;
7684 -> 7682;
7685 -> 7684;
7686 -> 7685;
7687 -> 7685;
7687 -> 7686;
7688 -> 7686;
7688 -> 7685;
7689 -> 7685;
7689 -> 7684;
7690 -> 7684;
7691 -> 7689;
7691 -> 7690;
7692 -> 7675;
7692 -> 7673;
7692 -> 7684;
7693 -> 7684;
7694 -> 7691;
7694 -> 7684;
7695 -> 7694;
7696 -> 7675;
7696 -> 7691;
7696 -> 7695;
7697 -> 7695;
7698 -> 7696;
7698 -> 7697;
7699 -> 7697;
7700 -> 7699;
7700 -> 7695;
7701 -> 7695;
7702 -> 7696;
7702 -> 7701;
7703 -> 7702;
7703 -> 7695;
7704 -> 7695;
7705 -> 7703;
7705 -> 7704;
7706 -> 7704;
7707 -> 7705;
7707 -> 7706;
7708 -> 7706;
7709 -> 7708;
7709 -> 7704;
7710 -> 7704;
7711 -> 7705;
7711 -> 7710;
7712 -> 7711;
7712 -> 7691;
7712 -> 7710;
7713 -> 7712;
7713 -> 7706;
7714 -> 7712;
7714 -> 7710;
7715 -> 7714;
7715 -> 7691;
7715 -> 7710;
7716 -> 7715;
7716 -> 7706;
7717 -> 7715;
7717 -> 7710;
7718 -> 7710;
7719 -> 7718;
7719 -> 7704;
7720 -> 7719;
7720 -> 7709;
7720 -> 7704;
7721 -> 7720;
7721 -> 7684;
7722 -> 7684;
7723 -> 7721;
7723 -> 7722;
7724 -> 7723;
7724 -> 7722;
7725 -> 0;
7725 -> 7724;
7726 -> 7725;
7726 -> 7675;
7726 -> 7684;
7727 -> 7720;
7727 -> 7674;
7728 -> 7727;
7728 -> 7673;
7729 -> 7673;
7730 -> 7728;
7730 -> 7729;
7730 -> 7673;
7731 -> 7604;
7731 -> 7730;
7732 -> 7347;
7733 -> 7731;
7733 -> 7732;
7734 -> 7733;
7734 -> 7595;
7734 -> 7732;
7735 -> 7732;
7736 -> 7734;
7736 -> 7735;
7737 -> 7733;
7737 -> 7597;
7737 -> 7735;
7738 -> 7736;
7738 -> 7735;
7739 -> 7738;
7739 -> 7732;
7740 -> 7284;
7740 -> 7691;
7740 -> 7285;
7741 -> 7739;
7741 -> 7285;
7742 -> 2665;
7742 -> 7285;
7743 -> 7740;
7743 -> 7741;
7743 -> 7742;
7743 -> 7691;
7743 -> 7726;
7743 -> 7285;
7744 -> 7284;
7744 -> 7743;
7744 -> 7282;
7745 -> 7744;
7745 -> 7278;
7746 -> 7745;
7746 -> 7275;
7747 -> 7275;
7748 -> 7746;
7748 -> 7747;
7748 -> 7275;
7749 -> 7746;
7749 -> 7275;
7750 -> 7276;
7750 -> 7275;
7751 -> 7275;
7752 -> 7749;
7752 -> 7751;
7753 -> 7750;
7753 -> 7751;
7754 -> 7751;
7755 -> 7752;
7755 -> 7754;
7755 -> 7751;
7756 -> 7751;
7757 -> 7753;
7757 -> 7756;
7757 -> 7751;
7758 -> 7751;
7759 -> 7753;
7759 -> 7758;
7760 -> 7758;
7761 -> 7759;
7761 -> 7760;
7762 -> 7760;
7763 -> 7761;
7763 -> 7762;
7764 -> 7762;
7765 -> 7763;
7765 -> 7764;
7766 -> 7764;
7767 -> 7765;
7767 -> 7766;
7768 -> 7767;
7768 -> 7766;
7769 -> 7768;
7769 -> 7764;
7770 -> 7769;
7770 -> 7762;
7771 -> 7770;
7771 -> 7760;
7772 -> 7771;
7772 -> 7758;
7773 -> 7772;
7773 -> 7751;
7774 -> 7751;
7775 -> 7752;
7775 -> 7751;
7776 -> 7751;
7777 -> 7752;
7777 -> 7776;
7778 -> 7776;
7779 -> 7778;
7779 -> 7751;
7780 -> 7774;
7780 -> 7751;
7781 -> 7751;
7782 -> 7775;
7782 -> 7781;
7783 -> 7779;
7783 -> 7781;
7784 -> 7780;
7784 -> 7781;
7785 -> 7781;
7786 -> 7782;
7786 -> 7785;
7786 -> 7781;
7787 -> 7781;
7788 -> 7782;
7788 -> 7787;
7789 -> 7788;
7789 -> 7787;
7790 -> 7789;
7790 -> 7781;
7791 -> 7790;
7791 -> 7781;
7792 -> 7791;
7792 -> 7784;
7792 -> 7743;
7792 -> 7774;
7792 -> 7781;
7793 -> 7781;
7794 -> 7792;
7794 -> 7793;
7795 -> 7793;
7796 -> 7794;
7796 -> 7795;
7797 -> 7796;
7797 -> 7793;
7798 -> 7793;
7799 -> 7794;
7799 -> 7798;
7800 -> 7799;
7800 -> 7793;
7801 -> 7800;
7802 -> 7790;
7802 -> 7801;
7803 -> 7802;
7803 -> 7800;
7803 -> 7801;
7804 -> 7803;
7804 -> 7800;
7805 -> 7804;
7806 -> 7804;
7807 -> 7805;
7807 -> 7806;
7808 -> 7806;
7809 -> 7806;
7810 -> 7806;
7810 -> 7809;
7811 -> 7809;
7811 -> 7806;
7812 -> 7806;
7813 -> 7808;
7813 -> 7806;
7814 -> 7806;
7815 -> 7806;
7816 -> 7806;
7817 -> 7806;
7818 -> 7806;
7819 -> 7818;
7819 -> 7806;
7820 -> 7819;
7820 -> 7818;
7820 -> 7806;
7821 -> 7819;
7821 -> 7806;
7822 -> 7821;
7823 -> 7822;
7823 -> 7818;
7823 -> 7806;
7824 -> 7806;
7825 -> 7824;
7825 -> 7818;
7825 -> 7806;
7826 -> 7818;
7826 -> 7806;
7827 -> 7806;
7828 -> 7826;
7828 -> 7806;
7829 -> 7806;
7830 -> 7806;
7830 -> 7829;
7831 -> 0;
7831 -> 7829;
7832 -> 7831;
7832 -> 7806;
7833 -> 7832;
7833 -> 7806;
7834 -> 7806;
7835 -> 7833;
7835 -> 7834;
7836 -> 7828;
7836 -> 7834;
7837 -> 7835;
7837 -> 0;
7837 -> 7834;
7838 -> 7835;
7838 -> 7837;
7839 -> 7806;
7840 -> 7806;
7840 -> 7839;
7841 -> 7840;
7841 -> 7806;
7841 -> 7839;
7842 -> 7841;
7842 -> 7806;
7843 -> 7806;
7844 -> 7842;
7844 -> 7806;
7845 -> 7842;
7845 -> 7844;
7846 -> 7845;
7846 -> 7806;
7847 -> 7842;
7847 -> 7806;
7848 -> 7832;
7848 -> 7838;
7848 -> 7806;
7849 -> 7848;
7849 -> 7846;
7849 -> 7806;
7850 -> 7806;
7851 -> 7806;
7851 -> 7850;
7852 -> 7850;
7853 -> 7852;
7853 -> 7850;
7854 -> 7853;
7854 -> 7850;
7855 -> 7851;
7855 -> 7850;
7856 -> 7850;
7857 -> 7855;
7857 -> 7856;
7858 -> 7856;
7859 -> 7858;
7859 -> 7850;
7860 -> 7850;
7861 -> 7855;
7861 -> 7860;
7862 -> 7861;
7862 -> 7806;
7862 -> 7860;
7863 -> 7862;
7863 -> 7850;
7864 -> 7850;
7865 -> 7863;
7865 -> 7864;
7866 -> 7864;
7866 -> 7850;
7867 -> 7859;
7867 -> 7866;
7867 -> 7850;
7868 -> 7850;
7869 -> 7855;
7869 -> 7868;
7870 -> 7869;
7870 -> 7868;
7871 -> 7870;
7871 -> 7806;
7871 -> 7868;
7872 -> 7871;
7872 -> 7850;
7873 -> 7850;
7874 -> 7872;
7874 -> 7873;
7875 -> 7850;
7876 -> 7874;
7876 -> 7875;
7877 -> 7875;
7877 -> 7850;
7878 -> 7850;
7879 -> 7867;
7879 -> 7877;
7879 -> 7850;
7880 -> 7850;
7881 -> 7855;
7881 -> 7880;
7882 -> 7881;
7882 -> 7850;
7883 -> 7882;
7883 -> 2554;
7883 -> 7850;
7884 -> 7879;
7884 -> 7883;
7884 -> 7850;
7885 -> 7850;
7886 -> 7850;
7886 -> 7806;
7887 -> 7818;
7887 -> 7806;
7888 -> 7818;
7888 -> 7806;
7889 -> 7818;
7889 -> 7806;
7890 -> 7887;
7890 -> 0;
7890 -> 7806;
7891 -> 7887;
7891 -> 7806;
7892 -> 7818;
7892 -> 7891;
7893 -> 7891;
7894 -> 7892;
7894 -> 7893;
7895 -> 7893;
7896 -> 7894;
7896 -> 7895;
7897 -> 7895;
7898 -> 7896;
7898 -> 7897;
7899 -> 7897;
7900 -> 7898;
7900 -> 7899;
7901 -> 7900;
7901 -> 7897;
7902 -> 7901;
7902 -> 7895;
7903 -> 7902;
7903 -> 7893;
7904 -> 7893;
7905 -> 7903;
7905 -> 7904;
7906 -> 7887;
7906 -> 7806;
7907 -> 7888;
7907 -> 7806;
7908 -> 7806;
7909 -> 7907;
7909 -> 7908;
7910 -> 7909;
7910 -> 7888;
7910 -> 7908;
7911 -> 7558;
7911 -> 7910;
7912 -> 7906;
7912 -> 7806;
7913 -> 7911;
7913 -> 7806;
7914 -> 7818;
7914 -> 7806;
7915 -> 7914;
7915 -> 7806;
7916 -> 7818;
7916 -> 7915;
7917 -> 7915;
7918 -> 7916;
7918 -> 7917;
7919 -> 7917;
7920 -> 7918;
7920 -> 7919;
7921 -> 7919;
7922 -> 7920;
7922 -> 7921;
7923 -> 7921;
7924 -> 7922;
7924 -> 7923;
7925 -> 7924;
7925 -> 7921;
7926 -> 7925;
7926 -> 7919;
7927 -> 7926;
7927 -> 7917;
7928 -> 7917;
7929 -> 7927;
7929 -> 7928;
7930 -> 7912;
7930 -> 0;
7930 -> 7806;
7931 -> 7806;
7932 -> 7929;
7932 -> 7931;
7932 -> 7806;
7933 -> 7806;
7934 -> 7913;
7934 -> 7933;
7934 -> 7806;
7935 -> 7912;
7935 -> 7818;
7935 -> 7806;
7936 -> 7913;
7936 -> 7818;
7936 -> 7806;
7937 -> 7818;
7937 -> 7806;
7938 -> 7806;
7939 -> 7818;
7939 -> 7938;
7940 -> 7939;
7940 -> 7818;
7940 -> 7938;
7941 -> 7940;
7941 -> 7938;
7942 -> 7941;
7942 -> 7806;
7943 -> 7806;
7944 -> 7937;
7944 -> 7943;
7945 -> 7943;
7946 -> 7944;
7946 -> 7945;
7947 -> 7945;
7948 -> 7946;
7948 -> 7947;
7949 -> 7947;
7950 -> 7948;
7950 -> 7949;
7951 -> 7949;
7952 -> 7950;
7952 -> 7951;
7953 -> 7952;
7953 -> 7949;
7954 -> 7953;
7954 -> 7947;
7955 -> 7954;
7955 -> 7945;
7956 -> 7955;
7956 -> 7943;
7957 -> 7956;
7957 -> 7806;
7958 -> 7806;
7959 -> 7937;
7959 -> 7958;
7960 -> 7958;
7961 -> 7959;
7961 -> 7960;
7962 -> 7960;
7963 -> 7961;
7963 -> 7962;
7964 -> 7962;
7964 -> 7960;
7965 -> 7961;
7965 -> 7958;
7966 -> 7965;
7966 -> 7806;
7967 -> 7806;
7968 -> 7937;
7968 -> 7806;
7969 -> 7806;
7970 -> 7968;
7970 -> 7969;
7971 -> 7967;
7971 -> 7969;
7972 -> 7970;
7972 -> 7969;
7973 -> 7969;
7974 -> 7970;
7974 -> 7973;
7975 -> 7973;
7975 -> 7969;
7976 -> 7969;
7977 -> 7969;
7978 -> 7970;
7978 -> 7977;
7979 -> 0;
7979 -> 7977;
7980 -> 7978;
7980 -> 7969;
7981 -> 7969;
7982 -> 7970;
7982 -> 7981;
7983 -> 7982;
7983 -> 7806;
7983 -> 7981;
7984 -> 7983;
7984 -> 7969;
7985 -> 7984;
7985 -> 7969;
7986 -> 7969;
7987 -> 7986;
7987 -> 7806;
7988 -> 7818;
7989 -> 7988;
7989 -> 7818;
7990 -> 7818;
7991 -> 7988;
7992 -> 7988;
7992 -> 7991;
7993 -> 7991;
7993 -> 7988;
7994 -> 7818;
7994 -> 7988;
7995 -> 7994;
7995 -> 7988;
7996 -> 7994;
7996 -> 7988;
7997 -> 7996;
7997 -> 7988;
7998 -> 7997;
7998 -> 7988;
7999 -> 7997;
7999 -> 7988;
8000 -> 7999;
8000 -> 7988;
8001 -> 8000;
8001 -> 7988;
8002 -> 8000;
8002 -> 7988;
8003 -> 7988;
8003 -> 7936;
8003 -> 7806;
8004 -> 7988;
8004 -> 7804;
8005 -> 7783;
8005 -> 7804;
8006 -> 7784;
8006 -> 7804;
8007 -> 7804;
8008 -> 8004;
8008 -> 8007;
8009 -> 8005;
8009 -> 8007;
8010 -> 8006;
8010 -> 8007;
8011 -> 8007;
8012 -> 8008;
8012 -> 8011;
8012 -> 8007;
8013 -> 8007;
8014 -> 8008;
8014 -> 8013;
8015 -> 8014;
8015 -> 8007;
8016 -> 0;
8016 -> 8015;
8017 -> 8016;
8018 -> 8016;
8019 -> 8016;
8020 -> 8016;
8020 -> 8019;
8021 -> 8019;
8021 -> 8016;
8022 -> 8016;
8023 -> 8009;
8023 -> 8016;
8024 -> 8016;
8025 -> 8022;
8025 -> 8024;
8025 -> 8016;
8026 -> 8025;
8027 -> 8016;
8028 -> 8009;
8028 -> 8027;
8028 -> 8016;
8029 -> 7800;
8030 -> 7783;
8030 -> 8029;
8030 -> 7800;
8031 -> 7751;
8032 -> 7753;
8032 -> 7751;
8033 -> 8032;
8033 -> 7774;
8033 -> 8022;
8033 -> 7751;
8034 -> 7751;
8035 -> 8034;
8036 -> 8034;
8037 -> 7774;
8037 -> 8033;
8037 -> 7751;
8038 -> 8033;
8038 -> 7751;
8039 -> 7275;
8040 -> 7276;
8040 -> 8039;
8041 -> 8039;
8042 -> 8041;
8042 -> 8040;
8042 -> 8039;
8043 -> 7275;
8044 -> 7746;
8044 -> 7275;
8045 -> 8044;
8045 -> 7272;
8046 -> 2665;
8046 -> 7272;
8047 -> 7274;
8047 -> 8045;
8047 -> 8046;
8047 -> 8037;
8047 -> 8042;
8047 -> 7272;
8048 -> 7271;
8048 -> 8047;
8048 -> 7270;
8049 -> 8048;
8049 -> 7268;
8050 -> 7268;
8051 -> 8049;
8051 -> 8050;
8051 -> 7268;
8052 -> 8049;
8052 -> 8051;
8053 -> 8051;
8054 -> 8052;
8054 -> 8053;
8055 -> 8053;
8056 -> 8054;
8056 -> 8055;
8056 -> 8053;
8057 -> 8053;
8058 -> 8054;
8058 -> 8057;
8059 -> 8057;
8059 -> 8053;
8060 -> 8059;
8060 -> 8051;
8061 -> 8051;
8062 -> 8061;
8063 -> 8061;
8064 -> 8061;
8065 -> 8061;
8066 -> 8061;
8067 -> 8061;
8068 -> 8061;
8068 -> 8067;
8069 -> 8067;
8070 -> 8068;
8070 -> 8069;
8071 -> 8069;
8072 -> 8070;
8072 -> 8071;
8073 -> 8071;
8074 -> 8072;
8074 -> 8073;
8075 -> 8073;
8076 -> 8074;
8076 -> 8075;
8077 -> 8076;
8077 -> 8073;
8078 -> 8077;
8078 -> 8071;
8079 -> 8078;
8079 -> 8069;
8080 -> 8079;
8080 -> 8067;
8081 -> 8080;
8081 -> 8061;
8082 -> 8061;
8083 -> 8061;
8083 -> 8082;
8084 -> 8082;
8085 -> 8084;
8085 -> 8061;
8086 -> 8061;
8087 -> 8086;
8088 -> 8061;
8089 -> 8085;
8089 -> 8088;
8089 -> 8061;
8090 -> 8061;
8091 -> 8061;
8092 -> 8061;
8092 -> 8051;
8093 -> 8092;
8094 -> 8092;
8095 -> 8093;
8095 -> 8094;
8096 -> 8094;
8097 -> 8095;
8097 -> 8096;
8097 -> 8094;
8098 -> 8094;
8099 -> 8095;
8099 -> 8098;
8100 -> 8098;
8100 -> 8094;
8101 -> 8100;
8101 -> 8092;
8102 -> 8092;
8103 -> 8092;
8104 -> 8092;
8105 -> 8104;
8106 -> 7268;
8107 -> 8106;
8107 -> 7264;
8108 -> 7264;
8109 -> 7267;
8109 -> 8108;
8110 -> 8107;
8110 -> 8108;
8111 -> 7265;
8111 -> 8108;
8112 -> 8108;
8113 -> 8110;
8113 -> 8112;
8113 -> 8108;
8114 -> 8113;
8115 -> 7264;
8116 -> 7265;
8116 -> 8115;
8117 -> 8115;
8118 -> 8116;
8118 -> 8117;
8119 -> 8118;
8119 -> 8105;
8119 -> 8117;
8120 -> 8117;
8121 -> 8119;
8121 -> 8120;
8122 -> 8120;
8122 -> 8117;
8123 -> 8117;
8124 -> 8119;
8124 -> 8115;
8125 -> 8124;
8125 -> 7264;
8126 -> 7264;
8127 -> 8125;
8127 -> 8126;
8128 -> 8126;
8129 -> 8127;
8129 -> 8128;
8130 -> 8128;
8131 -> 8129;
8131 -> 8130;
8132 -> 8130;
8133 -> 8131;
8133 -> 8105;
8133 -> 8132;
8133 -> 8130;
8134 -> 8128;
8135 -> 8129;
8135 -> 8126;
8136 -> 8126;
8137 -> 8109;
8137 -> 7264;
8138 -> 8137;
8138 -> 7260;
8139 -> 7260;
8140 -> 7263;
8140 -> 8139;
8141 -> 8138;
8141 -> 8139;
8142 -> 7261;
8142 -> 8139;
8143 -> 8139;
8144 -> 8141;
8144 -> 8143;
8144 -> 8139;
8145 -> 8144;
8146 -> 8145;
8147 -> 7261;
8147 -> 8146;
8148 -> 8147;
8148 -> 8105;
8148 -> 8146;
8149 -> 8146;
8150 -> 8148;
8150 -> 8149;
8151 -> 8149;
8151 -> 8146;
8152 -> 8146;
8153 -> 8148;
8153 -> 8145;
8154 -> 8145;
8155 -> 8153;
8155 -> 8154;
8156 -> 7261;
8156 -> 8105;
8156 -> 8145;
8157 -> 8155;
8158 -> 7261;
8158 -> 8157;
8159 -> 8158;
8159 -> 8155;
8159 -> 8157;
8160 -> 8159;
8160 -> 0;
8160 -> 8157;
8161 -> 8158;
8161 -> 8155;
8161 -> 8160;
8162 -> 8161;
8163 -> 8161;
8164 -> 8162;
8164 -> 8163;
8165 -> 8163;
8165 -> 8161;
8166 -> 0;
8166 -> 8161;
8167 -> 8161;
8168 -> 8165;
8168 -> 8167;
8168 -> 8161;
8169 -> 8168;
8170 -> 8169;
8170 -> 8168;
8171 -> 8170;
8171 -> 8168;
8172 -> 8171;
8173 -> 8172;
8173 -> 8171;
8174 -> 0;
8174 -> 8173;
8175 -> 8174;
8175 -> 8158;
8175 -> 8160;
8176 -> 8174;
8176 -> 8157;
8177 -> 8176;
8177 -> 8155;
8178 -> 8140;
8178 -> 7260;
8179 -> 8178;
8179 -> 7258;
8180 -> 8179;
8180 -> 7257;
8180 -> 7258;
8181 -> 7257;
8181 -> 8155;
8181 -> 8180;
8181 -> 7256;
8182 -> 8181;
8182 -> 7252;
8183 -> 7252;
8184 -> 8182;
8184 -> 8183;
8184 -> 7252;
8185 -> 7246;
8185 -> 7217;
8186 -> 7198;
8186 -> 8155;
8186 -> 7194;
8187 -> 7194;
8188 -> 8186;
8188 -> 8187;
8189 -> 7197;
8189 -> 8187;
8190 -> 8188;
8190 -> 8155;
8190 -> 8187;
8191 -> 8190;
8191 -> 8155;
8191 -> 8175;
8191 -> 8180;
8191 -> 8187;
8192 -> 8188;
8192 -> 8155;
8192 -> 8187;
8193 -> 8187;
8194 -> 8192;
8194 -> 8193;
8195 -> 8192;
8195 -> 8193;
8196 -> 8189;
8196 -> 8193;
8197 -> 8194;
8197 -> 8193;
8198 -> 8195;
8198 -> 8193;
8199 -> 8197;
8199 -> 8198;
8199 -> 8191;
8199 -> 8193;
8200 -> 8199;
8200 -> 8193;
8201 -> 8200;
8202 -> 8196;
8202 -> 7114;
8202 -> 8201;
8203 -> 8202;
8203 -> 8200;
8204 -> 0;
8204 -> 8200;
8205 -> 8200;
8206 -> 8196;
8206 -> 8205;
8207 -> 8206;
8207 -> 7112;
8207 -> 8205;
8208 -> 8207;
8208 -> 8203;
8208 -> 8205;
8209 -> 8205;
8210 -> 8206;
8210 -> 7112;
8210 -> 8209;
8211 -> 8210;
8211 -> 8208;
8211 -> 8209;
8212 -> 8211;
8212 -> 8209;
8213 -> 8209;
8214 -> 8212;
8214 -> 8213;
8215 -> 8213;
8216 -> 8214;
8216 -> 8211;
8216 -> 8215;
8217 -> 8216;
8217 -> 8213;
8218 -> 8217;
8219 -> 8218;
8219 -> 8209;
8220 -> 8219;
8220 -> 8209;
8221 -> 8185;
8221 -> 7194;
8222 -> 7194;
8223 -> 7194;
8224 -> 8220;
8224 -> 8223;
8225 -> 8221;
8225 -> 8223;
8226 -> 8222;
8226 -> 8223;
8227 -> 8225;
8227 -> 8223;
8228 -> 8225;
8228 -> 8223;
8229 -> 8226;
8229 -> 8223;
8230 -> 8224;
8230 -> 8229;
8231 -> 0;
8231 -> 8230;
8232 -> 8223;
8233 -> 8223;
8234 -> 8228;
8234 -> 8233;
8235 -> 8231;
8235 -> 8233;
8236 -> 8232;
8236 -> 8233;
8237 -> 8234;
8237 -> 8233;
8238 -> 8235;
8238 -> 0;
8238 -> 8233;
8239 -> 8235;
8239 -> 8233;
8240 -> 8234;
8240 -> 8239;
8241 -> 8239;
8242 -> 8240;
8242 -> 8241;
8243 -> 8241;
8244 -> 8242;
8244 -> 8243;
8245 -> 8243;
8246 -> 8244;
8246 -> 8245;
8247 -> 8245;
8248 -> 8246;
8248 -> 8247;
8249 -> 8248;
8249 -> 8245;
8250 -> 8249;
8250 -> 8243;
8251 -> 8250;
8251 -> 8241;
8252 -> 8241;
8253 -> 8251;
8253 -> 8252;
8254 -> 8234;
8254 -> 8233;
8255 -> 8236;
8255 -> 8233;
8256 -> 8233;
8257 -> 8254;
8257 -> 8256;
8258 -> 8235;
8258 -> 8256;
8259 -> 8255;
8259 -> 8256;
8260 -> 8257;
8260 -> 8256;
8261 -> 8259;
8261 -> 8256;
8262 -> 8256;
8263 -> 8261;
8263 -> 8262;
8264 -> 8263;
8264 -> 8255;
8264 -> 8262;
8265 -> 7558;
8265 -> 8264;
8266 -> 8256;
8267 -> 8256;
8268 -> 8260;
8268 -> 8267;
8269 -> 8258;
8269 -> 8267;
8270 -> 8265;
8270 -> 8267;
8271 -> 8266;
8271 -> 8267;
8272 -> 8268;
8272 -> 8267;
8273 -> 8272;
8273 -> 8267;
8274 -> 8268;
8274 -> 8273;
8275 -> 8273;
8276 -> 8274;
8276 -> 8275;
8277 -> 8275;
8278 -> 8276;
8278 -> 8277;
8279 -> 8277;
8280 -> 8278;
8280 -> 8279;
8281 -> 8279;
8282 -> 8280;
8282 -> 8281;
8283 -> 8282;
8283 -> 8281;
8284 -> 8283;
8284 -> 8279;
8285 -> 8284;
8285 -> 8277;
8286 -> 8285;
8286 -> 8275;
8287 -> 8275;
8288 -> 8286;
8288 -> 8287;
8289 -> 8288;
8289 -> 8211;
8289 -> 8287;
8290 -> 8269;
8290 -> 0;
8290 -> 8267;
8291 -> 8267;
8292 -> 8289;
8292 -> 8291;
8292 -> 8267;
8293 -> 8267;
8294 -> 8270;
8294 -> 8293;
8294 -> 8267;
8295 -> 8268;
8295 -> 8271;
8295 -> 8267;
8296 -> 8269;
8296 -> 8271;
8296 -> 8267;
8297 -> 8270;
8297 -> 8271;
8297 -> 8267;
8298 -> 8266;
8298 -> 8233;
8299 -> 8298;
8299 -> 8223;
8300 -> 8299;
8300 -> 7194;
8301 -> 8300;
8301 -> 8223;
8302 -> 8301;
8302 -> 8223;
8303 -> 8223;
8304 -> 8223;
8305 -> 8302;
8305 -> 8304;
8306 -> 8303;
8306 -> 8304;
8307 -> 8304;
8308 -> 8305;
8308 -> 8307;
8309 -> 8308;
8309 -> 8295;
8309 -> 8307;
8310 -> 8309;
8310 -> 8307;
8311 -> 8310;
8311 -> 8304;
8312 -> 8305;
8312 -> 8306;
8312 -> 8304;
8313 -> 8304;
8314 -> 8313;
8314 -> 8306;
8314 -> 8304;
8315 -> 8304;
8316 -> 8315;
8316 -> 8306;
8316 -> 8304;
8317 -> 8303;
8317 -> 7194;
8318 -> 8317;
8318 -> 7182;
8319 -> 7181;
8320 -> 8318;
8320 -> 8319;
8321 -> 8319;
8322 -> 8320;
8322 -> 8312;
8322 -> 8321;
8323 -> 8322;
8323 -> 8295;
8323 -> 8321;
8324 -> 8323;
8324 -> 8321;
8325 -> 8324;
8325 -> 8321;
8326 -> 8325;
8326 -> 8319;
8327 -> 8326;
8327 -> 7181;
8328 -> 8327;
8329 -> 8328;
8329 -> 8327;
8330 -> 8329;
8331 -> 8318;
8331 -> 8330;
8332 -> 8331;
8332 -> 8312;
8332 -> 8330;
8333 -> 8332;
8333 -> 8329;
8334 -> 7186;
8334 -> 8329;
8335 -> 7182;
8335 -> 8329;
8336 -> 7183;
8336 -> 8329;
8337 -> 8329;
8338 -> 8334;
8338 -> 8337;
8339 -> 8335;
8339 -> 8337;
8340 -> 8336;
8340 -> 8337;
8341 -> 8333;
8341 -> 8337;
8342 -> 8341;
8342 -> 8337;
8343 -> 8338;
8343 -> 8337;
8344 -> 8339;
8344 -> 8337;
8345 -> 8340;
8345 -> 8337;
8346 -> 8337;
8347 -> 8342;
8347 -> 8346;
8348 -> 8343;
8348 -> 8346;
8349 -> 8344;
8349 -> 8346;
8350 -> 8345;
8350 -> 8346;
8351 -> 8341;
8351 -> 8297;
8351 -> 8346;
8352 -> 8348;
8352 -> 8346;
8353 -> 8349;
8353 -> 8346;
8354 -> 8350;
8354 -> 8346;
8355 -> 8346;
8356 -> 8352;
8356 -> 8355;
8357 -> 8353;
8357 -> 8355;
8358 -> 8354;
8358 -> 8355;
8359 -> 8347;
8359 -> 8355;
8360 -> 8358;
8360 -> 8355;
8361 -> 8355;
8362 -> 8359;
8362 -> 8361;
8363 -> 8362;
8363 -> 8295;
8363 -> 8361;
8364 -> 8361;
8365 -> 8363;
8365 -> 8364;
8366 -> 8362;
8366 -> 8297;
8366 -> 8364;
8367 -> 8365;
8367 -> 8364;
8368 -> 8367;
8368 -> 8361;
8369 -> 8368;
8369 -> 8355;
8370 -> 8357;
8370 -> 8355;
8371 -> 8355;
8372 -> 8355;
8373 -> 8360;
8373 -> 8372;
8374 -> 8369;
8374 -> 8372;
8375 -> 8370;
8375 -> 8372;
8376 -> 8371;
8376 -> 8372;
8377 -> 8356;
8377 -> 8372;
8378 -> 8373;
8378 -> 8372;
8379 -> 8374;
8379 -> 8372;
8380 -> 8375;
8380 -> 8372;
8381 -> 8376;
8381 -> 8372;
8382 -> 8372;
8383 -> 8378;
8383 -> 8382;
8384 -> 8379;
8384 -> 8382;
8385 -> 8380;
8385 -> 8382;
8386 -> 8381;
8386 -> 8382;
8387 -> 8377;
8387 -> 8382;
8388 -> 8382;
8389 -> 8384;
8389 -> 8388;
8390 -> 8388;
8390 -> 8382;
8391 -> 8383;
8391 -> 8390;
8392 -> 8384;
8392 -> 8390;
8393 -> 8385;
8393 -> 8390;
8394 -> 8386;
8394 -> 8390;
8395 -> 8390;
8396 -> 8387;
8396 -> 8395;
8397 -> 8396;
8397 -> 7123;
8397 -> 8395;
8398 -> 8397;
8398 -> 8390;
8399 -> 8390;
8400 -> 8387;
8400 -> 8399;
8401 -> 8399;
8402 -> 8400;
8402 -> 8401;
8403 -> 8402;
8403 -> 7123;
8403 -> 8401;
8404 -> 8403;
8404 -> 8399;
8405 -> 8404;
8405 -> 8399;
8406 -> 8399;
8407 -> 8404;
8407 -> 8406;
8408 -> 0;
8408 -> 8406;
8409 -> 8408;
8409 -> 8399;
8410 -> 8405;
8410 -> 8409;
8410 -> 8399;
8411 -> 8404;
8411 -> 8399;
8412 -> 8411;
8413 -> 8412;
8413 -> 8211;
8414 -> 8413;
8414 -> 8411;
8415 -> 8414;
8415 -> 8390;
8416 -> 8387;
8416 -> 7113;
8416 -> 8390;
8417 -> 8390;
8418 -> 8391;
8418 -> 8417;
8419 -> 8392;
8419 -> 8417;
8420 -> 8393;
8420 -> 8417;
8421 -> 8394;
8421 -> 8417;
8422 -> 8398;
8422 -> 8417;
8423 -> 8415;
8423 -> 8417;
8424 -> 8416;
8424 -> 8417;
8425 -> 8419;
8425 -> 8417;
8426 -> 8425;
8426 -> 8211;
8426 -> 8417;
8427 -> 8417;
8428 -> 8419;
8428 -> 8427;
8429 -> 8427;
8429 -> 8417;
8430 -> 8417;
8431 -> 8419;
8431 -> 8430;
8432 -> 8430;
8432 -> 8417;
8433 -> 8419;
8433 -> 8417;
8434 -> 8423;
8434 -> 8417;
8435 -> 8417;
8436 -> 8433;
8436 -> 8435;
8437 -> 8434;
8437 -> 8435;
8438 -> 8435;
8439 -> 8436;
8439 -> 8438;
8440 -> 8438;
8440 -> 8435;
8441 -> 8436;
8441 -> 8440;
8442 -> 8421;
8442 -> 8417;
8443 -> 8442;
8443 -> 8417;
8444 -> 8418;
8444 -> 8417;
8445 -> 8441;
8445 -> 8417;
8446 -> 8420;
8446 -> 8417;
8447 -> 8422;
8447 -> 8417;
8448 -> 8424;
8448 -> 8417;
8449 -> 8417;
8450 -> 8444;
8450 -> 8449;
8451 -> 8445;
8451 -> 8449;
8452 -> 8446;
8452 -> 8449;
8453 -> 8447;
8453 -> 8449;
8454 -> 8448;
8454 -> 8449;
8455 -> 8449;
8456 -> 8450;
8456 -> 8455;
8456 -> 8449;
8457 -> 8451;
8457 -> 8449;
8458 -> 8453;
8458 -> 8449;
8459 -> 8449;
8460 -> 8449;
8461 -> 8457;
8461 -> 8460;
8462 -> 8458;
8462 -> 8460;
8463 -> 8459;
8463 -> 8460;
8464 -> 8460;
8465 -> 8461;
8465 -> 8464;
8466 -> 8464;
8467 -> 8465;
8467 -> 8466;
8468 -> 8466;
8469 -> 8467;
8469 -> 8468;
8470 -> 8469;
8470 -> 8426;
8470 -> 8468;
8471 -> 8468;
8472 -> 8470;
8472 -> 8471;
8472 -> 8468;
8473 -> 8468;
8474 -> 8469;
8474 -> 8473;
8475 -> 8473;
8476 -> 8474;
8476 -> 8475;
8477 -> 8476;
8477 -> 8426;
8477 -> 8475;
8478 -> 8475;
8479 -> 8477;
8479 -> 8478;
8480 -> 8478;
8480 -> 8475;
8481 -> 8475;
8482 -> 8477;
8482 -> 8473;
8483 -> 8474;
8483 -> 8426;
8483 -> 8473;
8484 -> 8473;
8485 -> 8483;
8485 -> 8484;
8486 -> 8482;
8486 -> 8484;
8487 -> 8485;
8487 -> 8484;
8488 -> 8486;
8488 -> 8426;
8488 -> 8487;
8488 -> 8484;
8489 -> 8488;
8490 -> 8489;
8491 -> 8490;
8491 -> 8468;
8492 -> 8491;
8493 -> 8491;
8494 -> 8492;
8494 -> 8493;
8495 -> 8494;
8495 -> 8493;
8496 -> 0;
8496 -> 8494;
8496 -> 8493;
8497 -> 0;
8497 -> 8494;
8497 -> 8493;
8498 -> 8494;
8498 -> 8493;
8499 -> 8494;
8499 -> 8493;
8500 -> 8494;
8500 -> 8493;
8501 -> 8494;
8501 -> 8493;
8502 -> 2665;
8502 -> 8494;
8502 -> 8493;
8503 -> 0;
8503 -> 8494;
8503 -> 8493;
8504 -> 8469;
8504 -> 8488;
8504 -> 8491;
8505 -> 8492;
8505 -> 8491;
8506 -> 8491;
8507 -> 8504;
8507 -> 8505;
8507 -> 8506;
8507 -> 8495;
8507 -> 8496;
8507 -> 8497;
8507 -> 8498;
8507 -> 8499;
8507 -> 8500;
8507 -> 8501;
8507 -> 8502;
8507 -> 8503;
8507 -> 8488;
8507 -> 0;
8507 -> 8491;
8508 -> 8507;
8508 -> 8466;
8509 -> 8508;
8509 -> 2668;
8509 -> 8466;
8510 -> 8466;
8511 -> 8467;
8511 -> 8510;
8512 -> 8510;
8513 -> 8511;
8513 -> 8512;
8514 -> 8513;
8514 -> 8507;
8514 -> 8512;
8515 -> 8512;
8516 -> 8514;
8516 -> 8515;
8516 -> 8512;
8517 -> 8514;
8517 -> 2668;
8517 -> 8516;
8518 -> 8516;
8519 -> 8514;
8519 -> 8516;
8520 -> 8519;
8520 -> 8510;
8521 -> 8520;
8521 -> 2668;
8521 -> 8510;
8522 -> 8520;
8522 -> 8507;
8522 -> 8510;
8523 -> 0;
8523 -> 8522;
8524 -> 8522;
8525 -> 8524;
8526 -> 8525;
8526 -> 8522;
8527 -> 8526;
8528 -> 8527;
8529 -> 8527;
8529 -> 8528;
8530 -> 8528;
8530 -> 8527;
8531 -> 8527;
8531 -> 8526;
8532 -> 8526;
8533 -> 8531;
8533 -> 8532;
8534 -> 8533;
8534 -> 8526;
8535 -> 8511;
8535 -> 8507;
8535 -> 8526;
8536 -> 8534;
8536 -> 8535;
8536 -> 8507;
8536 -> 8526;
8537 -> 8536;
8537 -> 8520;
8537 -> 8522;
8538 -> 8520;
8538 -> 8536;
8538 -> 8537;
8538 -> 8510;
8539 -> 8538;
8539 -> 8466;
8540 -> 8508;
8540 -> 8536;
8540 -> 8466;
8541 -> 8467;
8541 -> 8536;
8541 -> 8466;
8542 -> 8466;
8543 -> 8467;
8543 -> 8542;
8544 -> 8543;
8544 -> 8536;
8544 -> 8542;
8545 -> 8542;
8546 -> 8544;
8546 -> 8545;
8547 -> 8545;
8547 -> 8542;
8548 -> 8542;
8549 -> 8544;
8549 -> 8466;
8550 -> 8539;
8550 -> 8466;
8551 -> 8466;
8552 -> 8540;
8552 -> 8551;
8553 -> 8541;
8553 -> 8551;
8554 -> 8549;
8554 -> 8551;
8555 -> 8550;
8555 -> 8551;
8556 -> 8552;
8556 -> 8551;
8557 -> 0;
8557 -> 8551;
8558 -> 8553;
8558 -> 8556;
8559 -> 8554;
8559 -> 8556;
8560 -> 8555;
8560 -> 8556;
8561 -> 8556;
8562 -> 8558;
8562 -> 8561;
8563 -> 8559;
8563 -> 8561;
8564 -> 8560;
8564 -> 8561;
8565 -> 8561;
8566 -> 8563;
8566 -> 8565;
8567 -> 8566;
8567 -> 8561;
8568 -> 8562;
8568 -> 8561;
8569 -> 8563;
8569 -> 8561;
8570 -> 8561;
8571 -> 8561;
8572 -> 8569;
8572 -> 8571;
8573 -> 8570;
8573 -> 8571;
8574 -> 8572;
8574 -> 8571;
8575 -> 8571;
8576 -> 8571;
8577 -> 8571;
8578 -> 8574;
8578 -> 8577;
8579 -> 8575;
8579 -> 8577;
8580 -> 8576;
8580 -> 8577;
8581 -> 8578;
8581 -> 8536;
8581 -> 8537;
8582 -> 8577;
8583 -> 8578;
8583 -> 8582;
8583 -> 8577;
8584 -> 8564;
8584 -> 8561;
8585 -> 8567;
8585 -> 8568;
8585 -> 8570;
8585 -> 8584;
8585 -> 8581;
8585 -> 8577;
8585 -> 8579;
8585 -> 8580;
8585 -> 8536;
8585 -> 8537;
8585 -> 8561;
8586 -> 8561;
8587 -> 8585;
8587 -> 8586;
8587 -> 8561;
8588 -> 8585;
8588 -> 8561;
8589 -> 8552;
8589 -> 8556;
8590 -> 8588;
8590 -> 8556;
8591 -> 0;
8591 -> 8556;
8592 -> 8466;
8593 -> 8508;
8593 -> 8590;
8593 -> 8466;
8594 -> 8593;
8594 -> 8464;
8595 -> 8464;
8596 -> 8594;
8596 -> 8595;
8596 -> 8464;
8597 -> 8596;
8597 -> 8464;
8598 -> 8597;
8598 -> 8460;
8599 -> 0;
8599 -> 8598;
8600 -> 8449;
8601 -> 8599;
8601 -> 8449;
8602 -> 8449;
8603 -> 8600;
8603 -> 8602;
8603 -> 8449;
8604 -> 8599;
8604 -> 8449;
8605 -> 8604;
8605 -> 8417;
8606 -> 8442;
8606 -> 8605;
8607 -> 8390;
8608 -> 8372;
8609 -> 8346;
8610 -> 8329;
8611 -> 8318;
8611 -> 8327;
8612 -> 8611;
8612 -> 7181;
8613 -> 7183;
8613 -> 7181;
8614 -> 7182;
8614 -> 7181;
8615 -> 7184;
8615 -> 7181;
8616 -> 7181;
8617 -> 8612;
8617 -> 8616;
8618 -> 8613;
8618 -> 8616;
8619 -> 8614;
8619 -> 8616;
8620 -> 8615;
8620 -> 8616;
8621 -> 7186;
8621 -> 8616;
8622 -> 8616;
8623 -> 8617;
8623 -> 8622;
8624 -> 8623;
8624 -> 8314;
8624 -> 8622;
8625 -> 8624;
8625 -> 0;
8625 -> 8622;
8626 -> 8625;
8626 -> 8616;
8627 -> 8617;
8627 -> 8616;
8628 -> 7181;
8629 -> 8627;
8629 -> 8628;
8630 -> 8629;
8630 -> 8312;
8630 -> 8628;
8631 -> 7174;
8631 -> 7114;
8631 -> 7170;
8632 -> 7170;
8633 -> 8631;
8633 -> 8632;
8634 -> 8630;
8634 -> 8632;
8635 -> 8632;
8636 -> 8634;
8636 -> 8635;
8637 -> 8635;
8638 -> 8636;
8638 -> 8297;
8638 -> 8637;
8639 -> 8638;
8639 -> 7557;
8639 -> 8637;
8640 -> 8639;
8640 -> 8632;
8641 -> 8632;
8642 -> 8634;
8642 -> 8641;
8643 -> 8642;
8643 -> 8295;
8643 -> 8641;
8644 -> 8641;
8645 -> 8643;
8645 -> 8644;
8646 -> 8642;
8646 -> 8297;
8646 -> 8644;
8647 -> 8645;
8647 -> 8644;
8648 -> 8647;
8648 -> 8641;
8649 -> 8648;
8649 -> 8632;
8650 -> 8632;
8651 -> 8649;
8651 -> 8650;
8652 -> 8651;
8652 -> 8590;
8652 -> 8650;
8653 -> 8652;
8653 -> 8632;
8654 -> 8653;
8655 -> 8649;
8655 -> 8654;
8656 -> 8654;
8657 -> 8655;
8657 -> 8656;
8658 -> 8657;
8658 -> 8654;
8659 -> 8658;
8659 -> 0;
8659 -> 8654;
8660 -> 8659;
8660 -> 8653;
8661 -> 8633;
8661 -> 8660;
8662 -> 8649;
8662 -> 8660;
8663 -> 8660;
8664 -> 8661;
8664 -> 8663;
8665 -> 8662;
8665 -> 8663;
8666 -> 8634;
8666 -> 8663;
8667 -> 0;
8667 -> 8663;
8668 -> 8663;
8669 -> 8667;
8669 -> 8668;
8670 -> 8664;
8670 -> 8668;
8671 -> 8669;
8671 -> 0;
8671 -> 8668;
8672 -> 8668;
8673 -> 8670;
8674 -> 8670;
8675 -> 8674;
8675 -> 8670;
8676 -> 8675;
8677 -> 8675;
8677 -> 8676;
8678 -> 8676;
8679 -> 8677;
8679 -> 8678;
8680 -> 8678;
8681 -> 8679;
8681 -> 8670;
8681 -> 8680;
8681 -> 8678;
8682 -> 8676;
8683 -> 8677;
8683 -> 8670;
8683 -> 8676;
8684 -> 8683;
8684 -> 8675;
8685 -> 8675;
8686 -> 8668;
8687 -> 8670;
8687 -> 8686;
8688 -> 8687;
8688 -> 8668;
8689 -> 8663;
8690 -> 8670;
8690 -> 8689;
8691 -> 8670;
8691 -> 8689;
8692 -> 8690;
8692 -> 8689;
8693 -> 8689;
8694 -> 8689;
8695 -> 8692;
8695 -> 8694;
8696 -> 8693;
8696 -> 8694;
8697 -> 8691;
8697 -> 8694;
8698 -> 8694;
8699 -> 8698;
8699 -> 8694;
8700 -> 8695;
8700 -> 8670;
8700 -> 8694;
8701 -> 8695;
8701 -> 8700;
8702 -> 8700;
8703 -> 8701;
8703 -> 8702;
8704 -> 8701;
8704 -> 8702;
8705 -> 8701;
8705 -> 8702;
8706 -> 8703;
8706 -> 0;
8706 -> 8702;
8707 -> 8703;
8707 -> 8702;
8708 -> 8701;
8708 -> 8707;
8709 -> 8707;
8710 -> 8708;
8710 -> 8709;
8711 -> 8709;
8712 -> 8710;
8712 -> 8711;
8713 -> 8711;
8714 -> 8712;
8714 -> 8713;
8715 -> 8713;
8716 -> 8714;
8716 -> 8715;
8717 -> 8716;
8717 -> 8713;
8718 -> 8717;
8718 -> 8711;
8719 -> 8718;
8719 -> 8709;
8720 -> 8709;
8721 -> 8719;
8721 -> 8720;
8722 -> 8703;
8722 -> 8702;
8723 -> 8704;
8723 -> 8702;
8724 -> 8702;
8725 -> 8723;
8725 -> 8724;
8726 -> 8725;
8726 -> 8704;
8726 -> 8724;
8727 -> 7558;
8727 -> 8726;
8728 -> 8722;
8728 -> 8702;
8729 -> 8727;
8729 -> 8702;
8730 -> 8701;
8730 -> 8702;
8731 -> 8730;
8731 -> 8702;
8732 -> 8701;
8732 -> 8731;
8733 -> 8731;
8734 -> 8732;
8734 -> 8733;
8735 -> 8733;
8736 -> 8734;
8736 -> 8735;
8737 -> 8735;
8738 -> 8736;
8738 -> 8737;
8739 -> 8737;
8740 -> 8738;
8740 -> 8739;
8741 -> 8740;
8741 -> 8737;
8742 -> 8741;
8742 -> 8735;
8743 -> 8742;
8743 -> 8733;
8744 -> 8733;
8745 -> 8743;
8745 -> 8744;
8746 -> 8745;
8746 -> 8704;
8746 -> 8744;
8747 -> 8728;
8747 -> 0;
8747 -> 8702;
8748 -> 8702;
8749 -> 8746;
8749 -> 8748;
8749 -> 8702;
8750 -> 8702;
8751 -> 8729;
8751 -> 8750;
8751 -> 8702;
8752 -> 8728;
8752 -> 8702;
8753 -> 8729;
8753 -> 8702;
8754 -> 8701;
8754 -> 8702;
8754 -> 8704;
8754 -> 8752;
8754 -> 8753;
8754 -> 7557;
8754 -> 0;
8754 -> 8700;
8755 -> 8754;
8755 -> 8694;
8756 -> 8696;
8756 -> 8694;
8757 -> 8694;
8758 -> 8755;
8758 -> 8757;
8759 -> 8756;
8759 -> 8757;
8760 -> 8697;
8760 -> 8757;
8761 -> 8760;
8761 -> 8757;
8762 -> 8757;
8763 -> 8760;
8763 -> 8762;
8764 -> 8763;
8764 -> 8762;
8765 -> 8764;
8765 -> 8757;
8766 -> 8757;
8767 -> 8760;
8767 -> 8766;
8768 -> 8767;
8768 -> 8754;
8768 -> 8766;
8769 -> 8768;
8769 -> 8757;
8770 -> 8757;
8771 -> 8758;
8771 -> 8754;
8771 -> 8757;
8772 -> 8758;
8772 -> 8757;
8773 -> 2545;
8773 -> 8757;
8774 -> 8772;
8774 -> 8773;
8774 -> 8754;
8774 -> 2544;
8774 -> 8757;
8775 -> 8757;
8776 -> 8774;
8776 -> 8775;
8777 -> 8776;
8777 -> 8774;
8777 -> 8775;
8778 -> 8777;
8778 -> 8775;
8779 -> 8757;
8780 -> 8760;
8780 -> 8779;
8781 -> 8780;
8781 -> 8778;
8781 -> 8779;
8782 -> 8781;
8782 -> 8757;
8783 -> 8759;
8783 -> 8757;
8784 -> 8757;
8785 -> 8760;
8785 -> 8784;
8786 -> 8784;
8787 -> 8785;
8787 -> 8786;
8788 -> 8787;
8788 -> 8778;
8788 -> 8786;
8789 -> 8788;
8790 -> 8789;
8791 -> 8789;
8791 -> 8790;
8792 -> 8790;
8792 -> 8789;
8793 -> 8789;
8793 -> 8788;
8794 -> 8787;
8794 -> 8778;
8794 -> 8788;
8795 -> 8787;
8795 -> 8778;
8795 -> 8788;
8796 -> 8788;
8797 -> 8796;
8797 -> 8795;
8797 -> 8788;
8798 -> 8793;
8798 -> 8797;
8799 -> 8787;
8799 -> 8797;
8800 -> 8796;
8800 -> 8797;
8801 -> 8794;
8801 -> 8796;
8801 -> 8797;
8802 -> 8797;
8803 -> 8797;
8804 -> 8798;
8804 -> 8803;
8805 -> 8799;
8805 -> 8803;
8806 -> 8800;
8806 -> 8803;
8807 -> 8801;
8807 -> 8803;
8808 -> 8802;
8808 -> 8803;
8809 -> 8804;
8809 -> 8803;
8810 -> 8805;
8810 -> 8803;
8811 -> 8806;
8811 -> 8803;
8812 -> 8807;
8812 -> 8803;
8813 -> 8803;
8814 -> 8809;
8814 -> 8813;
8815 -> 8810;
8815 -> 8813;
8816 -> 8811;
8816 -> 8813;
8817 -> 8812;
8817 -> 8813;
8818 -> 8808;
8818 -> 8813;
8819 -> 8813;
8820 -> 8818;
8820 -> 8819;
8821 -> 8819;
8822 -> 8820;
8822 -> 8819;
8823 -> 8818;
8823 -> 8813;
8824 -> 8818;
8824 -> 8813;
8825 -> 8818;
8825 -> 8813;
8826 -> 0;
8826 -> 8818;
8826 -> 8813;
8827 -> 8818;
8827 -> 8813;
8828 -> 8818;
8828 -> 8813;
8830 -> 8829;
8831 -> 8830;
8831 -> 8829;
8832 -> 8830;
8832 -> 8829;
8833 -> 8829;
8834 -> 8833;
8834 -> 8830;
8834 -> 8829;
8835 -> 8829;
8836 -> 8835;
8836 -> 8830;
8836 -> 8829;
8837 -> 8829;
8838 -> 8837;
8838 -> 8818;
8838 -> 8813;
8839 -> 8813;
8840 -> 8814;
8840 -> 8839;
8840 -> 8813;
8841 -> 8813;
8842 -> 8815;
8842 -> 8841;
8842 -> 8813;
8843 -> 8813;
8844 -> 8816;
8844 -> 8843;
8844 -> 8813;
8845 -> 8817;
8845 -> 8801;
8845 -> 8813;
8846 -> 8815;
8846 -> 8818;
8846 -> 8813;
8847 -> 8813;
8848 -> 8813;
8849 -> 8814;
8849 -> 8848;
8850 -> 8849;
8850 -> 8801;
8850 -> 8848;
8851 -> 8850;
8851 -> 8813;
8852 -> 8817;
8852 -> 8813;
8853 -> 8818;
8853 -> 8824;
8853 -> 8813;
8854 -> 8847;
8854 -> 8813;
8855 -> 8851;
8855 -> 8852;
8855 -> 8853;
8855 -> 8854;
8855 -> 8801;
8855 -> 8813;
8856 -> 8855;
8856 -> 0;
8856 -> 8813;
8857 -> 8813;
8858 -> 8856;
8858 -> 8813;
8859 -> 8858;
8859 -> 8818;
8859 -> 8813;
8860 -> 8816;
8860 -> 8818;
8860 -> 8813;
8861 -> 8817;
8861 -> 8818;
8861 -> 8813;
8862 -> 8802;
8862 -> 8796;
8862 -> 8795;
8862 -> 8797;
8863 -> 8787;
8863 -> 8855;
8863 -> 8788;
8864 -> 8795;
8864 -> 8788;
8865 -> 8864;
8865 -> 8795;
8865 -> 8862;
8865 -> 8820;
8865 -> 8822;
8865 -> 8846;
8865 -> 8855;
8865 -> 8860;
8865 -> 8826;
8865 -> 8859;
8865 -> 8828;
8865 -> 8838;
8865 -> 8861;
8865 -> 8834;
8865 -> 8836;
8865 -> 8801;
8865 -> 8788;
8866 -> 8784;
8867 -> 8785;
8867 -> 8865;
8867 -> 8784;
8868 -> 8867;
8868 -> 8757;
8869 -> 8758;
8869 -> 8757;
8870 -> 8757;
8871 -> 8868;
8871 -> 8870;
8872 -> 8869;
8872 -> 8870;
8873 -> 8871;
8873 -> 8865;
8873 -> 8870;
8874 -> 8872;
8874 -> 8754;
8874 -> 8873;
8874 -> 8870;
8875 -> 8870;
8876 -> 8872;
8876 -> 8754;
8876 -> 8875;
8876 -> 8870;
8877 -> 8870;
8878 -> 8877;
8878 -> 8873;
8878 -> 8870;
8879 -> 8872;
8879 -> 8877;
8879 -> 8754;
8879 -> 8865;
8879 -> 8878;
8880 -> 8878;
8881 -> 8879;
8881 -> 8880;
8882 -> 8879;
8882 -> 8880;
8884 -> 8883;
8886 -> 8885;
8888 -> 8887;
8889 -> 8882;
8889 -> 8879;
8889 -> 8880;
8890 -> 8880;
8891 -> 8889;
8891 -> 8890;
8892 -> 8891;
8892 -> 8231;
8892 -> 8890;
8893 -> 8882;
8893 -> 8879;
8893 -> 8881;
8893 -> 8880;
8894 -> 8892;
8894 -> 8893;
8894 -> 8880;
8895 -> 8894;
8896 -> 8758;
8896 -> 8757;
8897 -> 8759;
8897 -> 8757;
8898 -> 8757;
8899 -> 8896;
8899 -> 8898;
8900 -> 8897;
8900 -> 8898;
8901 -> 8760;
8901 -> 8898;
8902 -> 8901;
8902 -> 8898;
8903 -> 8899;
8903 -> 8898;
8904 -> 8900;
8904 -> 8898;
8905 -> 8898;
8906 -> 8898;
8907 -> 8902;
8907 -> 8906;
8908 -> 8903;
8908 -> 8906;
8909 -> 8904;
8909 -> 8906;
8910 -> 8905;
8910 -> 8906;
8911 -> 8905;
8911 -> 8906;
8912 -> 8906;
8913 -> 8907;
8913 -> 8912;
8914 -> 8913;
8914 -> 8879;
8914 -> 8912;
8915 -> 8906;
8916 -> 8907;
8916 -> 8915;
8917 -> 8916;
8917 -> 8879;
8917 -> 8915;
8918 -> 8906;
8919 -> 8907;
8919 -> 8918;
8920 -> 8906;
8921 -> 8919;
8921 -> 8920;
8922 -> 8920;
8923 -> 8921;
8923 -> 8922;
8924 -> 8923;
8924 -> 8879;
8924 -> 8922;
8925 -> 8920;
8926 -> 8921;
8926 -> 8879;
8926 -> 8920;
8928 -> 8927;
8929 -> 0;
8930 -> 8929;
8930 -> 0;
8931 -> 8930;
8933 -> 8932;
8934 -> 8931;
8934 -> 8932;
8935 -> 8934;
8935 -> 8933;
8936 -> 8933;
8937 -> 8936;
8938 -> 8936;
8938 -> 8933;
8939 -> 8935;
8939 -> 8936;
8939 -> 8933;
8940 -> 8931;
8940 -> 8932;
8941 -> 8932;
8942 -> 8908;
8942 -> 8906;
8943 -> 8906;
8944 -> 8917;
8944 -> 8943;
8945 -> 8926;
8945 -> 8943;
8946 -> 8942;
8946 -> 8943;
8947 -> 8943;
8948 -> 8944;
8948 -> 8943;
8949 -> 8943;
8950 -> 8948;
8950 -> 8949;
8951 -> 8950;
8951 -> 8949;
8952 -> 8949;
8953 -> 8951;
8953 -> 8952;
8953 -> 8949;
8954 -> 8953;
8954 -> 8949;
8955 -> 8954;
8955 -> 8940;
8956 -> 8955;
8956 -> 8947;
8957 -> 8947;
8958 -> 8957;
8959 -> 8957;
8959 -> 8947;
8960 -> 8956;
8960 -> 8957;
8960 -> 8947;
8961 -> 8943;
8962 -> 8961;
8962 -> 8945;
8962 -> 8879;
8962 -> 8943;
8963 -> 8945;
8963 -> 8961;
8963 -> 8879;
8963 -> 8962;
8964 -> 8946;
8964 -> 8961;
8964 -> 8754;
8964 -> 8963;
8964 -> 8962;
8965 -> 8963;
8965 -> 8962;
8966 -> 8962;
8967 -> 8965;
8967 -> 8966;
8968 -> 8964;
8968 -> 8966;
8969 -> 8968;
8969 -> 8964;
8969 -> 8966;
8970 -> 8966;
8971 -> 8969;
8971 -> 8970;
8972 -> 8971;
8972 -> 8231;
8972 -> 8970;
8973 -> 8968;
8973 -> 8964;
8973 -> 8967;
8973 -> 8966;
8974 -> 8972;
8974 -> 8973;
8974 -> 8966;
8975 -> 8963;
8975 -> 8974;
8976 -> 8964;
8976 -> 8974;
8977 -> 8947;
8977 -> 8960;
8977 -> 8975;
8977 -> 8976;
8977 -> 8955;
8977 -> 8964;
8977 -> 8974;
8978 -> 8906;
8979 -> 8907;
8979 -> 8978;
8980 -> 0;
8981 -> 8907;
8981 -> 8906;
8982 -> 8909;
8982 -> 8906;
8983 -> 8910;
8983 -> 8906;
8984 -> 8906;
8985 -> 8914;
8985 -> 8984;
8986 -> 8943;
8986 -> 8984;
8987 -> 8979;
8987 -> 8984;
8988 -> 8981;
8988 -> 8984;
8989 -> 8982;
8989 -> 8984;
8990 -> 8983;
8990 -> 8984;
8991 -> 8911;
8991 -> 8984;
8992 -> 8987;
8992 -> 8984;
8993 -> 8990;
8993 -> 8984;
8994 -> 8984;
8995 -> 8992;
8995 -> 8994;
8996 -> 8993;
8996 -> 8994;
8997 -> 8991;
8997 -> 8994;
8998 -> 8996;
8998 -> 8994;
8999 -> 8994;
9000 -> 8998;
9000 -> 8999;
9001 -> 8997;
9001 -> 8999;
9002 -> 8997;
9002 -> 8994;
9003 -> 8994;
9004 -> 8995;
9004 -> 9003;
9004 -> 8994;
9005 -> 8995;
9005 -> 8997;
9005 -> 8994;
9006 -> 8991;
9006 -> 8984;
9007 -> 8991;
9007 -> 8984;
9008 -> 8991;
9008 -> 8984;
9009 -> 8991;
9009 -> 8984;
9010 -> 8991;
9010 -> 8984;
9011 -> 8991;
9011 -> 8984;
9012 -> 8984;
9013 -> 8987;
9013 -> 9012;
9014 -> 9012;
9015 -> 9013;
9015 -> 9014;
9016 -> 9014;
9017 -> 9015;
9017 -> 9016;
9018 -> 9016;
9019 -> 9017;
9019 -> 9018;
9020 -> 9018;
9021 -> 9019;
9021 -> 9020;
9022 -> 9021;
9022 -> 9018;
9023 -> 9022;
9023 -> 9016;
9024 -> 9023;
9024 -> 9014;
9025 -> 9024;
9025 -> 9012;
9026 -> 9025;
9026 -> 8984;
9027 -> 8987;
9027 -> 8984;
9028 -> 8984;
9029 -> 9027;
9029 -> 9028;
9030 -> 9028;
9031 -> 9029;
9031 -> 9030;
9031 -> 9028;
9032 -> 9028;
9033 -> 9029;
9033 -> 9032;
9034 -> 9032;
9034 -> 9028;
9035 -> 9034;
9035 -> 8984;
9036 -> 8985;
9036 -> 8991;
9036 -> 8984;
9037 -> 8986;
9037 -> 8991;
9037 -> 8984;
9038 -> 8989;
9038 -> 8991;
9038 -> 8984;
9039 -> 8984;
9040 -> 8988;
9040 -> 9039;
9040 -> 8984;
9041 -> 9040;
9042 -> 8988;
9042 -> 9041;
9043 -> 9042;
9043 -> 9041;
9044 -> 9043;
9044 -> 9040;
9045 -> 8988;
9045 -> 9040;
9046 -> 9040;
9047 -> 8988;
9047 -> 9046;
9048 -> 9046;
9049 -> 9047;
9049 -> 9048;
9050 -> 9049;
9050 -> 8977;
9050 -> 9048;
9051 -> 9046;
9052 -> 9047;
9052 -> 8977;
9052 -> 9046;
9053 -> 9052;
9053 -> 9040;
9054 -> 9053;
9054 -> 8991;
9054 -> 9040;
9055 -> 8986;
9055 -> 8991;
9055 -> 9040;
9056 -> 8911;
9056 -> 8906;
9057 -> 8908;
9057 -> 8911;
9057 -> 8906;
9058 -> 8907;
9058 -> 8911;
9058 -> 8906;
9059 -> 8906;
9060 -> 8907;
9060 -> 9059;
9061 -> 9060;
9061 -> 8977;
9061 -> 9059;
9062 -> 9061;
9062 -> 8906;
9063 -> 8906;
9064 -> 8907;
9064 -> 9063;
9065 -> 9064;
9065 -> 8977;
9065 -> 9063;
9066 -> 9065;
9066 -> 8906;
9067 -> 8906;
9068 -> 8905;
9068 -> 8757;
9069 -> 9068;
9069 -> 8694;
9070 -> 9069;
9070 -> 8689;
9071 -> 9070;
9071 -> 8663;
9072 -> 8663;
9073 -> 8663;
9074 -> 9071;
9074 -> 9073;
9075 -> 9072;
9075 -> 9073;
9076 -> 9072;
9076 -> 9073;
9077 -> 9074;
9077 -> 9073;
9078 -> 9075;
9078 -> 0;
9078 -> 9073;
9079 -> 9075;
9079 -> 9073;
9080 -> 9074;
9080 -> 9079;
9081 -> 9079;
9082 -> 9080;
9082 -> 9081;
9083 -> 9081;
9084 -> 9082;
9084 -> 9083;
9085 -> 9083;
9086 -> 9084;
9086 -> 9085;
9087 -> 9085;
9088 -> 9086;
9088 -> 9087;
9089 -> 9088;
9089 -> 9005;
9089 -> 9087;
9090 -> 9089;
9090 -> 9085;
9091 -> 9090;
9091 -> 9083;
9092 -> 9091;
9092 -> 9081;
9093 -> 9081;
9094 -> 9092;
9094 -> 9093;
9095 -> 9094;
9095 -> 8977;
9095 -> 9093;
9096 -> 0;
9096 -> 9095;
9097 -> 9076;
9097 -> 9073;
9098 -> 9073;
9099 -> 9097;
9099 -> 9098;
9100 -> 9099;
9100 -> 9076;
9100 -> 9098;
9101 -> 7558;
9101 -> 9100;
9102 -> 9101;
9102 -> 9073;
9103 -> 9074;
9103 -> 9073;
9104 -> 9103;
9104 -> 9073;
9105 -> 9074;
9105 -> 9104;
9106 -> 9104;
9107 -> 9105;
9107 -> 9106;
9108 -> 9106;
9109 -> 9107;
9109 -> 9108;
9110 -> 9108;
9111 -> 9109;
9111 -> 9110;
9112 -> 9110;
9113 -> 9111;
9113 -> 9112;
9114 -> 9113;
9114 -> 9005;
9114 -> 9112;
9115 -> 9114;
9115 -> 9110;
9116 -> 9115;
9116 -> 9108;
9117 -> 9116;
9117 -> 9106;
9118 -> 9106;
9119 -> 9117;
9119 -> 9118;
9120 -> 9119;
9120 -> 8977;
9120 -> 9118;
9121 -> 9096;
9121 -> 0;
9121 -> 9073;
9122 -> 9073;
9123 -> 9120;
9123 -> 9122;
9123 -> 9073;
9124 -> 9123;
9124 -> 9121;
9124 -> 9073;
9125 -> 9073;
9126 -> 9102;
9126 -> 9125;
9126 -> 9073;
9127 -> 9102;
9127 -> 9073;
9128 -> 9073;
9128 -> 8663;
9129 -> 9128;
9129 -> 8660;
9130 -> 9129;
9130 -> 7170;
9131 -> 7175;
9131 -> 8977;
9131 -> 7170;
9132 -> 7172;
9132 -> 7170;
9133 -> 8630;
9133 -> 7170;
9134 -> 7170;
9135 -> 9131;
9135 -> 9134;
9136 -> 9132;
9136 -> 9134;
9137 -> 9133;
9137 -> 9134;
9138 -> 7174;
9138 -> 9134;
9139 -> 9135;
9139 -> 9134;
9140 -> 9134;
9141 -> 9139;
9141 -> 9140;
9142 -> 9138;
9142 -> 9140;
9143 -> 9140;
9144 -> 9142;
9144 -> 9143;
9145 -> 9135;
9145 -> 9134;
9146 -> 9134;
9147 -> 9145;
9147 -> 9146;
9148 -> 9138;
9148 -> 9146;
9149 -> 9147;
9149 -> 8977;
9149 -> 9146;
9150 -> 9146;
9151 -> 9148;
9151 -> 7114;
9151 -> 9150;
9152 -> 9151;
9152 -> 9141;
9152 -> 9150;
9153 -> 9152;
9153 -> 9146;
9154 -> 0;
9154 -> 9146;
9155 -> 9149;
9155 -> 9153;
9155 -> 9154;
9155 -> 9141;
9155 -> 0;
9155 -> 9146;
9156 -> 9135;
9156 -> 8977;
9156 -> 9155;
9156 -> 9134;
9157 -> 9134;
9158 -> 9137;
9158 -> 9157;
9159 -> 9158;
9159 -> 8295;
9159 -> 9157;
9160 -> 9159;
9160 -> 9157;
9161 -> 9160;
9161 -> 9134;
9162 -> 9134;
9163 -> 9138;
9163 -> 9162;
9164 -> 9163;
9164 -> 7113;
9164 -> 9162;
9165 -> 0;
9165 -> 9162;
9166 -> 9162;
9167 -> 9164;
9167 -> 9166;
9168 -> 9165;
9168 -> 9166;
9169 -> 9167;
9169 -> 9134;
9170 -> 9161;
9170 -> 9169;
9170 -> 9134;
9171 -> 9141;
9171 -> 9170;
9172 -> 9155;
9172 -> 9170;
9173 -> 9137;
9173 -> 9170;
9174 -> 9156;
9174 -> 9170;
9175 -> 9136;
9175 -> 9170;
9176 -> 9171;
9176 -> 9172;
9176 -> 9173;
9176 -> 9174;
9176 -> 9175;
9176 -> 8295;
9176 -> 8296;
9176 -> 8297;
9176 -> 9156;
9176 -> 6881;
9176 -> 9170;
9177 -> 9170;
9178 -> 7170;
9179 -> 7170;
9180 -> 7174;
9180 -> 9179;
9181 -> 9180;
9181 -> 7113;
9181 -> 9179;
9182 -> 0;
9182 -> 9179;
9183 -> 9179;
9184 -> 9181;
9184 -> 9183;
9185 -> 9182;
9185 -> 9183;
9186 -> 9184;
9186 -> 7170;
9187 -> 7172;
9187 -> 9186;
9188 -> 7174;
9188 -> 7114;
9188 -> 9176;
9188 -> 9186;
9189 -> 9130;
9189 -> 9186;
9190 -> 9188;
9190 -> 9189;
9190 -> 9074;
9190 -> 9096;
9190 -> 9127;
9190 -> 8997;
9190 -> 9000;
9190 -> 9005;
9190 -> 9038;
9190 -> 9037;
9190 -> 9036;
9190 -> 9055;
9190 -> 9010;
9190 -> 9011;
9190 -> 9054;
9190 -> 9058;
9190 -> 9057;
9190 -> 8960;
9190 -> 9176;
9190 -> 8977;
9190 -> 8754;
9190 -> 9186;
9191 -> 9130;
9191 -> 7170;
9192 -> 7170;
9193 -> 9191;
9193 -> 9192;
9194 -> 9192;
9195 -> 9192;
9196 -> 9194;
9196 -> 9195;
9197 -> 9195;
9198 -> 9193;
9198 -> 9197;
9199 -> 9198;
9199 -> 9074;
9199 -> 9197;
9200 -> 9199;
9200 -> 9197;
9201 -> 9200;
9201 -> 9195;
9202 -> 9195;
9203 -> 9202;
9203 -> 9196;
9203 -> 9195;
9204 -> 9195;
9205 -> 9204;
9205 -> 9196;
9205 -> 9195;
9206 -> 9194;
9206 -> 7170;
9207 -> 9206;
9207 -> 7166;
9208 -> 7146;
9209 -> 9207;
9209 -> 9208;
9210 -> 9208;
9211 -> 9193;
9211 -> 9074;
9211 -> 9210;
9212 -> 7148;
9212 -> 9211;
9213 -> 9211;
9214 -> 9211;
9215 -> 9212;
9215 -> 9211;
9216 -> 9213;
9216 -> 9211;
9217 -> 9214;
9217 -> 9211;
9218 -> 9215;
9218 -> 9211;
9219 -> 9216;
9219 -> 9211;
9220 -> 9217;
9220 -> 9211;
9221 -> 9218;
9221 -> 9211;
9222 -> 9211;
9222 -> 9127;
9223 -> 9219;
9223 -> 9211;
9224 -> 9220;
9224 -> 9211;
9225 -> 9221;
9225 -> 9211;
9226 -> 9223;
9226 -> 9211;
9227 -> 9224;
9227 -> 9211;
9228 -> 9225;
9228 -> 9211;
9229 -> 9211;
9229 -> 9127;
9230 -> 9228;
9230 -> 9211;
9231 -> 9227;
9231 -> 9211;
9232 -> 9211;
9233 -> 9226;
9233 -> 9211;
9234 -> 9230;
9234 -> 9211;
9235 -> 9231;
9235 -> 9211;
9236 -> 9232;
9236 -> 9211;
9237 -> 9233;
9237 -> 9211;
9238 -> 9211;
9239 -> 9211;
9240 -> 9238;
9240 -> 9239;
9241 -> 9240;
9241 -> 9190;
9241 -> 9239;
9242 -> 9241;
9242 -> 9211;
9243 -> 9211;
9244 -> 9242;
9244 -> 9243;
9245 -> 9243;
9245 -> 9211;
9246 -> 9234;
9246 -> 9245;
9247 -> 9235;
9247 -> 9245;
9248 -> 9236;
9248 -> 9245;
9249 -> 9245;
9250 -> 9237;
9250 -> 9249;
9251 -> 9250;
9251 -> 7123;
9251 -> 9249;
9252 -> 9245;
9253 -> 9237;
9253 -> 9252;
9254 -> 9252;
9255 -> 9253;
9255 -> 9254;
9256 -> 9255;
9256 -> 7123;
9256 -> 9254;
9257 -> 9256;
9257 -> 9252;
9258 -> 9257;
9258 -> 9252;
9259 -> 9252;
9260 -> 9257;
9260 -> 9259;
9261 -> 0;
9261 -> 9259;
9262 -> 9261;
9262 -> 9252;
9263 -> 9258;
9263 -> 9262;
9263 -> 9252;
9264 -> 9257;
9264 -> 9252;
9265 -> 9264;
9266 -> 9265;
9266 -> 9190;
9267 -> 9266;
9267 -> 9264;
9268 -> 9237;
9268 -> 7113;
9268 -> 9245;
9269 -> 9246;
9269 -> 9245;
9270 -> 9247;
9270 -> 9245;
9271 -> 9248;
9271 -> 9245;
9272 -> 9251;
9272 -> 9245;
9273 -> 9267;
9273 -> 9245;
9274 -> 9268;
9274 -> 9245;
9275 -> 9245;
9275 -> 9190;
9276 -> 9245;
9277 -> 9245;
9277 -> 9276;
9278 -> 9276;
9279 -> 9277;
9279 -> 9278;
9280 -> 9279;
9280 -> 9275;
9280 -> 9278;
9281 -> 9280;
9281 -> 9276;
9282 -> 9276;
9282 -> 9245;
9283 -> 9245;
9284 -> 9245;
9284 -> 9283;
9285 -> 9283;
9286 -> 9284;
9286 -> 9285;
9287 -> 9286;
9287 -> 9275;
9287 -> 9285;
9288 -> 9287;
9288 -> 9283;
9289 -> 9283;
9289 -> 9245;
9290 -> 9273;
9290 -> 9245;
9291 -> 9245;
9292 -> 9245;
9293 -> 9291;
9293 -> 9292;
9294 -> 9293;
9294 -> 9275;
9294 -> 9292;
9295 -> 9294;
9295 -> 9276;
9296 -> 9271;
9296 -> 9245;
9297 -> 9296;
9297 -> 9245;
9298 -> 9269;
9298 -> 9245;
9299 -> 9270;
9299 -> 9245;
9300 -> 9272;
9300 -> 9245;
9301 -> 9274;
9301 -> 9245;
9302 -> 9245;
9303 -> 9298;
9303 -> 9302;
9303 -> 9245;
9304 -> 9300;
9304 -> 9245;
9305 -> 9276;
9305 -> 9245;
9306 -> 9276;
9306 -> 9245;
9307 -> 9245;
9308 -> 9306;
9308 -> 9275;
9308 -> 9307;
9309 -> 9307;
9310 -> 9308;
9310 -> 9309;
9311 -> 9309;
9311 -> 9307;
9312 -> 9308;
9312 -> 2668;
9312 -> 9307;
9313 -> 9308;
9313 -> 2668;
9314 -> 9308;
9315 -> 9308;
9315 -> 2668;
9315 -> 9307;
9316 -> 0;
9316 -> 9308;
9317 -> 9308;
9318 -> 9308;
9319 -> 9308;
9319 -> 9318;
9320 -> 9318;
9320 -> 9308;
9321 -> 9308;
9322 -> 9317;
9322 -> 9308;
9323 -> 9308;
9323 -> 9322;
9324 -> 0;
9324 -> 9308;
9325 -> 9323;
9326 -> 9323;
9326 -> 9325;
9327 -> 9325;
9327 -> 9323;
9328 -> 9323;
9328 -> 9309;
9329 -> 9323;
9330 -> 9323;
9331 -> 9308;
9331 -> 9323;
9331 -> 9307;
9332 -> 9331;
9332 -> 9245;
9333 -> 9332;
9333 -> 9245;
9334 -> 9245;
9335 -> 9333;
9335 -> 9334;
9335 -> 9245;
9336 -> 9335;
9336 -> 9245;
9337 -> 9336;
9337 -> 9245;
9338 -> 0;
9338 -> 9337;
9339 -> 9245;
9340 -> 9338;
9340 -> 9245;
9341 -> 9245;
9342 -> 9339;
9342 -> 9341;
9342 -> 9245;
9343 -> 9338;
9343 -> 9245;
9344 -> 9343;
9344 -> 9245;
9345 -> 9296;
9345 -> 9344;
9346 -> 9211;
9347 -> 7138;
9347 -> 7136;
9348 -> 7137;
9348 -> 7136;
9349 -> 7139;
9349 -> 7136;
9350 -> 7136;
9351 -> 9347;
9351 -> 9350;
9352 -> 9348;
9352 -> 9350;
9353 -> 9349;
9353 -> 9350;
9354 -> 7141;
9354 -> 9350;
9355 -> 9350;
9356 -> 9211;
9356 -> 9355;
9357 -> 9356;
9357 -> 9203;
9357 -> 9355;
9358 -> 9357;
9358 -> 0;
9358 -> 9355;
9359 -> 9358;
9359 -> 9350;
9360 -> 7136;
9361 -> 6887;
9362 -> 6847;
9362 -> 9361;
9363 -> 9361;
9364 -> 9362;
9364 -> 9363;
9365 -> 9364;
9365 -> 9323;
9365 -> 9363;
9366 -> 9365;
9366 -> 0;
9366 -> 9361;
9367 -> 9361;
9368 -> 9366;
9368 -> 9367;
9368 -> 9361;
9369 -> 9368;
9369 -> 6887;
9370 -> 6847;
9370 -> 9323;
9370 -> 6845;
9371 -> 6845;
9372 -> 6847;
9372 -> 9371;
9373 -> 9371;
9374 -> 9372;
9374 -> 9373;
9375 -> 9373;
9376 -> 9374;
9376 -> 9375;
9377 -> 9376;
9377 -> 9323;
9377 -> 9375;
9378 -> 9377;
9378 -> 0;
9378 -> 9373;
9379 -> 9373;
9380 -> 9378;
9380 -> 9379;
9380 -> 9373;
9381 -> 9380;
9381 -> 9371;
9382 -> 0;
9382 -> 9381;
9383 -> 9382;
9383 -> 6845;
9384 -> 6845;
9385 -> 9383;
9385 -> 9384;
9386 -> 9211;
9386 -> 9384;
9387 -> 9386;
9387 -> 9384;
9388 -> 9385;
9388 -> 9384;
9389 -> 9384;
9390 -> 9387;
9390 -> 9389;
9391 -> 9388;
9391 -> 9389;
9392 -> 9386;
9392 -> 9127;
9392 -> 9389;
9393 -> 9390;
9393 -> 9074;
9393 -> 9389;
9394 -> 9390;
9394 -> 9096;
9394 -> 9389;
9395 -> 9391;
9395 -> 9389;
9396 -> 9389;
9397 -> 9393;
9397 -> 9396;
9398 -> 9394;
9398 -> 9396;
9399 -> 9395;
9399 -> 9396;
9400 -> 9396;
9401 -> 9396;
9402 -> 9396;
9403 -> 9401;
9403 -> 9402;
9404 -> 9397;
9404 -> 9402;
9405 -> 9404;
9405 -> 9402;
9406 -> 9397;
9406 -> 9405;
9407 -> 9405;
9408 -> 9406;
9408 -> 9407;
9409 -> 9407;
9410 -> 9408;
9410 -> 9409;
9411 -> 9409;
9412 -> 9410;
9412 -> 9411;
9413 -> 9411;
9414 -> 9412;
9414 -> 9413;
9415 -> 9414;
9415 -> 9323;
9415 -> 9413;
9416 -> 9407;
9417 -> 9398;
9417 -> 0;
9417 -> 9402;
9418 -> 9402;
9419 -> 9415;
9419 -> 9418;
9419 -> 9402;
9420 -> 9419;
9420 -> 9417;
9420 -> 9402;
9421 -> 9402;
9422 -> 9399;
9422 -> 9421;
9422 -> 9402;
9423 -> 9401;
9423 -> 9389;
9424 -> 9423;
9424 -> 6845;
9427 -> 9425;
9427 -> 9426;
9428 -> 9426;
9429 -> 9427;
9429 -> 9428;
9429 -> 9426;
9430 -> 9426;
9431 -> 6845;
9432 -> 6845;
9433 -> 9424;
9433 -> 9432;
9434 -> 9431;
9434 -> 9432;
9435 -> 9433;
9435 -> 9434;
9435 -> 9432;
9436 -> 9370;
9436 -> 9431;
9436 -> 9435;
9436 -> 9323;
9436 -> 9397;
9436 -> 9398;
9436 -> 9399;
9436 -> 6845;
9437 -> 9436;
9438 -> 9437;
9438 -> 9127;
9439 -> 9437;
9439 -> 9436;
9440 -> 6878;
9440 -> 9436;
9441 -> 9436;
9442 -> 9439;
9442 -> 9441;
9443 -> 9440;
9443 -> 9441;
9444 -> 6847;
9444 -> 9441;
9445 -> 9441;
9446 -> 9442;
9446 -> 9445;
9447 -> 9445;
9448 -> 9446;
9448 -> 9436;
9448 -> 9447;
9449 -> 9448;
9449 -> 9436;
9449 -> 0;
9449 -> 9447;
9450 -> 9447;
9451 -> 9449;
9451 -> 9445;
9452 -> 9451;
9452 -> 9441;
9453 -> 9442;
9453 -> 9452;
9454 -> 9452;
9455 -> 9453;
9455 -> 9454;
9456 -> 9454;
9457 -> 9455;
9457 -> 9456;
9458 -> 0;
9458 -> 9456;
9459 -> 9458;
9459 -> 9454;
9460 -> 9459;
9460 -> 9452;
9461 -> 9442;
9461 -> 9460;
9462 -> 9460;
9463 -> 9460;
9464 -> 9461;
9464 -> 9463;
9465 -> 9462;
9465 -> 9463;
9466 -> 9463;
9467 -> 9464;
9467 -> 9466;
9467 -> 9463;
9468 -> 9463;
9469 -> 9464;
9469 -> 9468;
9470 -> 9468;
9470 -> 9463;
9471 -> 9465;
9471 -> 9463;
9472 -> 9471;
9473 -> 9472;
9474 -> 9442;
9474 -> 9473;
9475 -> 9473;
9476 -> 9474;
9476 -> 9436;
9476 -> 9475;
9477 -> 9476;
9477 -> 2668;
9478 -> 9476;
9479 -> 9476;
9479 -> 2668;
9479 -> 9475;
9480 -> 9476;
9480 -> 9473;
9481 -> 9480;
9481 -> 9472;
9482 -> 9481;
9483 -> 9444;
9483 -> 9482;
9484 -> 9482;
9485 -> 9483;
9485 -> 9484;
9486 -> 9485;
9486 -> 0;
9486 -> 9482;
9487 -> 9482;
9488 -> 9486;
9488 -> 9487;
9488 -> 9482;
9489 -> 9488;
9489 -> 9481;
9490 -> 9489;
9491 -> 9490;
9491 -> 9489;
9492 -> 9441;
9493 -> 9444;
9493 -> 9441;
9494 -> 9442;
9494 -> 9441;
9495 -> 9492;
9495 -> 9441;
9496 -> 9441;
9497 -> 9493;
9497 -> 9496;
9498 -> 9494;
9498 -> 9496;
9499 -> 9495;
9499 -> 9496;
9500 -> 9498;
9500 -> 9496;
9501 -> 9497;
9501 -> 9496;
9502 -> 9499;
9502 -> 9496;
9503 -> 9496;
9504 -> 9500;
9504 -> 9503;
9505 -> 9501;
9505 -> 9503;
9506 -> 9502;
9506 -> 9503;
9507 -> 9506;
9507 -> 9503;
9508 -> 9504;
9508 -> 9503;
9509 -> 9507;
9509 -> 9503;
9510 -> 9505;
9510 -> 9503;
9511 -> 9503;
9512 -> 9503;
9513 -> 9508;
9513 -> 9512;
9514 -> 9509;
9514 -> 9512;
9515 -> 9510;
9515 -> 9512;
9516 -> 9511;
9516 -> 9512;
9517 -> 9512;
9518 -> 9513;
9518 -> 9512;
9519 -> 9514;
9519 -> 9512;
9520 -> 9515;
9520 -> 9512;
9521 -> 9516;
9521 -> 9512;
9522 -> 9512;
9523 -> 9517;
9523 -> 9522;
9524 -> 9518;
9524 -> 9522;
9525 -> 9517;
9525 -> 9522;
9526 -> 9519;
9526 -> 9522;
9527 -> 9520;
9527 -> 9522;
9528 -> 9521;
9528 -> 9522;
9529 -> 9517;
9529 -> 9522;
9530 -> 9522;
9531 -> 9523;
9531 -> 9530;
9532 -> 9531;
9532 -> 9522;
9533 -> 9524;
9533 -> 9522;
9534 -> 9532;
9534 -> 9533;
9534 -> 9522;
9535 -> 9522;
9536 -> 9528;
9536 -> 9535;
9536 -> 9522;
9537 -> 9529;
9537 -> 9535;
9537 -> 9522;
9538 -> 9536;
9538 -> 9537;
9538 -> 9522;
9539 -> 9522;
9540 -> 9524;
9540 -> 9539;
9541 -> 9539;
9542 -> 9539;
9543 -> 9540;
9543 -> 9542;
9544 -> 9542;
9545 -> 9543;
9545 -> 9436;
9545 -> 9544;
9546 -> 9545;
9546 -> 9542;
9547 -> 9546;
9547 -> 9539;
9548 -> 9547;
9549 -> 9540;
9549 -> 9548;
9550 -> 9549;
9550 -> 9436;
9550 -> 9548;
9551 -> 9550;
9551 -> 9547;
9552 -> 9547;
9553 -> 9551;
9553 -> 9552;
9553 -> 9547;
9554 -> 9539;
9555 -> 9523;
9555 -> 9554;
9556 -> 9555;
9556 -> 9539;
9557 -> 9556;
9558 -> 9526;
9558 -> 9557;
9558 -> 9556;
9559 -> 9540;
9559 -> 9558;
9560 -> 9527;
9560 -> 9558;
9561 -> 9541;
9561 -> 9558;
9562 -> 9559;
9562 -> 9560;
9562 -> 9561;
9562 -> 9526;
9562 -> 9436;
9562 -> 9509;
9562 -> 9558;
9563 -> 9558;
9564 -> 9562;
9564 -> 9563;
9565 -> 9562;
9565 -> 9563;
9566 -> 9562;
9566 -> 9563;
9567 -> 9563;
9568 -> 9564;
9568 -> 9567;
9569 -> 9567;
9570 -> 9568;
9570 -> 9562;
9570 -> 9569;
9571 -> 9570;
9571 -> 9567;
9572 -> 9571;
9572 -> 9563;
9573 -> 9564;
9573 -> 9572;
9574 -> 9565;
9574 -> 9572;
9575 -> 9566;
9575 -> 9572;
9576 -> 9572;
9577 -> 9573;
9577 -> 9576;
9578 -> 9574;
9578 -> 9576;
9579 -> 9575;
9579 -> 9576;
9580 -> 9576;
9581 -> 9577;
9581 -> 9580;
9582 -> 9580;
9583 -> 9581;
9583 -> 9562;
9583 -> 9582;
9584 -> 0;
9584 -> 9582;
9585 -> 9583;
9585 -> 9580;
9586 -> 9585;
9586 -> 9576;
9587 -> 9586;
9587 -> 0;
9587 -> 9576;
9588 -> 9587;
9589 -> 9579;
9589 -> 9588;
9589 -> 9562;
9589 -> 9558;
9590 -> 9539;
9591 -> 9590;
9591 -> 9539;
9592 -> 9539;
9593 -> 9540;
9593 -> 9592;
9594 -> 9592;
9595 -> 9593;
9595 -> 9589;
9595 -> 9594;
9596 -> 9595;
9596 -> 9539;
9597 -> 9596;
9598 -> 9540;
9598 -> 9597;
9599 -> 9598;
9599 -> 9589;
9599 -> 9597;
9600 -> 9599;
9600 -> 9596;
9601 -> 9600;
9601 -> 9589;
9601 -> 9596;
9602 -> 9596;
9603 -> 9596;
9604 -> 9600;
9604 -> 9589;
9604 -> 9603;
9604 -> 9596;
9605 -> 9600;
9605 -> 9603;
9605 -> 9589;
9605 -> 9596;
9606 -> 9528;
9606 -> 9539;
9607 -> 9606;
9608 -> 9528;
9608 -> 9539;
9609 -> 9608;
9610 -> 9605;
9610 -> 9609;
9611 -> 9610;
9611 -> 9605;
9611 -> 9609;
9612 -> 9609;
9613 -> 9611;
9613 -> 9612;
9614 -> 9610;
9614 -> 9605;
9614 -> 9612;
9615 -> 9613;
9615 -> 9612;
9616 -> 9612;
9617 -> 9615;
9617 -> 9616;
9618 -> 9617;
9618 -> 9616;
9619 -> 9616;
9620 -> 9618;
9620 -> 9619;
9621 -> 9620;
9621 -> 9608;
9622 -> 9621;
9622 -> 9542;
9623 -> 9622;
9623 -> 9539;
9624 -> 9623;
9625 -> 9624;
9625 -> 9623;
9626 -> 9623;
9627 -> 9625;
9627 -> 9626;
9627 -> 9623;
9628 -> 9607;
9628 -> 9554;
9629 -> 9628;
9629 -> 9539;
9630 -> 9629;
9631 -> 9526;
9631 -> 9630;
9631 -> 9629;
9632 -> 9621;
9632 -> 9631;
9633 -> 9527;
9633 -> 9631;
9634 -> 9541;
9634 -> 9631;
9635 -> 9631;
9636 -> 9632;
9636 -> 9635;
9637 -> 9635;
9638 -> 9636;
9638 -> 9632;
9639 -> 0;
9639 -> 9632;
9640 -> 9621;
9640 -> 9632;
9641 -> 0;
9641 -> 9632;
9642 -> 9641;
9642 -> 0;
9642 -> 9632;
9643 -> 9642;
9644 -> 9507;
9644 -> 9503;
9645 -> 9643;
9645 -> 9503;
9646 -> 9443;
9646 -> 9441;
9647 -> 9441;
9648 -> 9444;
9648 -> 9647;
9649 -> 9648;
9649 -> 9632;
9649 -> 9647;
9650 -> 9649;
9650 -> 9441;
9651 -> 9644;
9651 -> 9441;
9652 -> 9646;
9652 -> 9650;
9652 -> 9651;
9652 -> 6878;
9652 -> 9632;
9652 -> 9441;
9653 -> 9436;
9654 -> 9436;
9655 -> 9654;
9655 -> 9652;
9656 -> 9654;
9656 -> 9652;
9657 -> 9654;
9657 -> 9652;
9658 -> 9657;
9658 -> 9436;
9659 -> 6878;
9659 -> 9436;
9660 -> 9436;
9661 -> 6863;
9661 -> 9658;
9661 -> 9660;
9661 -> 9436;
9662 -> 9661;
9662 -> 9436;
9663 -> 9662;
9664 -> 9663;
9664 -> 9661;
9665 -> 9663;
9665 -> 9662;
9666 -> 6881;
9666 -> 9662;
9667 -> 0;
9667 -> 9436;
9668 -> 9436;
9669 -> 9667;
9669 -> 9668;
9670 -> 6847;
9670 -> 9665;
9670 -> 9668;
9671 -> 9670;
9671 -> 9669;
9671 -> 9668;
9672 -> 6878;
9672 -> 9665;
9672 -> 9671;
9672 -> 6845;
9673 -> 6881;
9673 -> 9672;
9673 -> 6845;
9674 -> 6847;
9674 -> 9673;
9674 -> 6845;
9675 -> 9674;
9675 -> 6842;
9676 -> 6840;
9677 -> 9675;
9677 -> 9676;
9678 -> 9676;
9679 -> 9677;
9679 -> 9673;
9679 -> 9678;
9680 -> 1;
9681 -> 9677;
9681 -> 9680;
9682 -> 9680;
9683 -> 9682;
}