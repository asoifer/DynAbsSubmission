digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 135999"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 136000"];
3 [label="RuntimeHelpers.RunModuleConstructor(typeof(TestBase).Module.ModuleHandle); 136001"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 136002"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 136003"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 136004"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 136005"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 136006"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 136007"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 136008"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 136009"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 136010"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 136011"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 136012"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 136013"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 136014"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 136015"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 136016"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 136017"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 136018"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 136019"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 136020"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 136021"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 136022"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 136023"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 136024"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 136025"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 136026"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 136027"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 136028"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 136029"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 136030"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 136031"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 136032"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 136033"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 136034"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 136035"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 136036"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 136037"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 136038"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 136039"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 136040"];
43 [label="LazyThreadSafetyMode.PublicationOnly 136041"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 136042"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 136043"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 136044"];
47 [label="LazyThreadSafetyMode.PublicationOnly 136045"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 136046"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 136047"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 136048"];
51 [label="'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' 136049"];
52 [label="new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51') 136050"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 136051"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 136052"];
55 [label="LazyThreadSafetyMode.PublicationOnly 136053"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 136054"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 136055"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 136056"];
59 [label="LazyThreadSafetyMode.PublicationOnly 136057"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 136058"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 136059"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 136060"];
63 [label="LazyThreadSafetyMode.PublicationOnly 136061"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 136062"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 136063"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 136064"];
67 [label="LazyThreadSafetyMode.PublicationOnly 136065"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136066"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136067"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 136068"];
71 [label="LazyThreadSafetyMode.PublicationOnly 136069"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136070"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136071"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 136072"];
75 [label="LazyThreadSafetyMode.PublicationOnly 136073"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136074"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136075"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 136076"];
79 [label="LazyThreadSafetyMode.PublicationOnly 136077"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136078"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136079"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 136080"];
83 [label="LazyThreadSafetyMode.PublicationOnly 136081"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136082"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136083"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 136084"];
87 [label="LazyThreadSafetyMode.PublicationOnly 136085"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136086"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136087"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 136088"];
91 [label="LazyThreadSafetyMode.PublicationOnly 136089"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136090"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136091"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 136092"];
95 [label="LazyThreadSafetyMode.PublicationOnly 136093"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 136094"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 136095"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 136096"];
99 [label="LazyThreadSafetyMode.PublicationOnly 136097"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 136098"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 136099"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 136100"];
103 [label="LazyThreadSafetyMode.PublicationOnly 136101"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136102"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136103"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 136104"];
107 [label="LazyThreadSafetyMode.PublicationOnly 136105"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136106"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136107"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 136108"];
111 [label="LazyThreadSafetyMode.PublicationOnly 136109"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136110"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136111"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 136112"];
115 [label="LazyThreadSafetyMode.PublicationOnly 136113"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136114"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136115"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 136116"];
119 [label="LazyThreadSafetyMode.PublicationOnly 136117"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 136118"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 136119"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 136120"];
123 [label="LazyThreadSafetyMode.PublicationOnly 136121"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136122"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136123"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 136124"];
127 [label="LazyThreadSafetyMode.PublicationOnly 136125"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136126"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136127"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 136128"];
131 [label="LazyThreadSafetyMode.PublicationOnly 136129"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136130"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136131"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 136132"];
135 [label="LazyThreadSafetyMode.PublicationOnly 136133"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136134"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136135"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 136136"];
139 [label="LazyThreadSafetyMode.PublicationOnly 136137"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136138"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136139"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 136140"];
143 [label="LazyThreadSafetyMode.PublicationOnly 136141"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136142"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136143"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 136144"];
147 [label="LazyThreadSafetyMode.PublicationOnly 136145"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136146"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136147"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 136148"];
151 [label="LazyThreadSafetyMode.PublicationOnly 136149"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136150"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136151"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 136152"];
155 [label="LazyThreadSafetyMode.PublicationOnly 136153"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136154"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136155"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 136156"];
159 [label="LazyThreadSafetyMode.PublicationOnly 136157"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136158"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136159"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 136160"];
163 [label="LazyThreadSafetyMode.PublicationOnly 136161"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136162"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136163"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 136164"];
167 [label="LazyThreadSafetyMode.PublicationOnly 136165"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136166"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136167"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 136168"];
171 [label="LazyThreadSafetyMode.PublicationOnly 136169"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136170"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 136171"];
174 [label="@'R:\\Invalid.dll' 136172"];
175 [label="fullPath: @'R:\\Invalid.dll' 136173"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 136174"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 136175"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 136176"];
179 [label="MscorlibRef_v4_0_30316_17626 136177"];
180 [label="Net451.mscorlib 136178"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 136179"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 136180"];
183 [label="'/*<bind>*/' 136181"];
184 [label="StartString = '/*<bind>*/' 136182"];
185 [label="'/*</bind>*/' 136183"];
186 [label="EndString = '/*</bind>*/' 136184"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 136185"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 136186"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 136187"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 136188"];
191 [label="param StatementParsingTests(ITestOutputHelper output) 136189"];
192 [label="param StatementParsingTests(this) 136190"];
193 [label="output 136191"];
194 [label="param ParsingTests(ITestOutputHelper output) 136192"];
195 [label="param ParsingTests(this) 136193"];
196 [label="param CSharpTestBase(this) 136194"];
197 [label="param CommonTestBase(this) 136195"];
198 [label="param TestBase(this) 136196"];
199 [label="_temp 136197"];
200 [label="_node 136198"];
201 [label="_treeEnumerator 136199"];
202 [label="_output 136200"];
203 [label="this._output 136201"];
204 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 136202"];
205 [label="param TestSwitchWithMultipleCases(this) 136203"];
206 [label="var text = 'switch (a) { case b:; case c:; }'; 136204"];
207 [label="var statement = this.ParseStatement(text); 136205"];
208 [label="var statement = this.ParseStatement(text); 136206"];
209 [label="this.ParseStatement(text) 136207"];
210 [label="param ParseStatement(string text) 136208"];
211 [label="param ParseStatement(int offset = 0) 136209"];
212 [label="param ParseStatement(ParseOptions options = null) 136210"];
213 [label="param ParseStatement(this) 136211"];
214 [label="'\\r\\n' 136212"];
215 [label="CrLf = '\\r\\n' 136213"];
216 [label="CrLf 136214"];
217 [label="EndOfLine(CrLf) 136215"];
218 [label="param EndOfLine(string text) 136216"];
219 [label="param EndOfLine(bool elastic = false) 136217"];
220 [label="SyntaxTrivia trivia = null; 136218"];
221 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 136219"];
222 [label="elastic 136220"];
223 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 136221"];
224 [label="if (trivia != null)\n            {\n                return trivia;\n            } 136222"];
225 [label="if (trivia != null)\n            {\n                return trivia;\n            } 136223"];
226 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTrivia), r => new SyntaxTrivia(r)); 136224"];
227 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136225"];
228 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136226"];
229 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 136227"];
230 [label="param Create(SyntaxKind kind) 136228"];
231 [label="param Create(string text) 136229"];
232 [label="return new SyntaxTrivia(kind, text); 136230"];
233 [label="return new SyntaxTrivia(kind, text); 136231"];
234 [label="return new SyntaxTrivia(kind, text); 136232"];
235 [label="new SyntaxTrivia(kind, text) 136233"];
236 [label="param SyntaxTrivia(SyntaxKind kind) 136234"];
237 [label="param SyntaxTrivia(string text) 136235"];
238 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 136236"];
239 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 136237"];
240 [label="param SyntaxTrivia(this) 136238"];
241 [label="kind 136239"];
242 [label="diagnostics 136240"];
243 [label="annotations 136241"];
244 [label="new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 136242"];
245 [label="s_structuresTable\n            = new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 136243"];
246 [label="text 136244"];
247 [label="param SyntaxTrivia(this) 136245"];
248 [label="param CSharpSyntaxNode(SyntaxKind kind) 136246"];
249 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 136247"];
250 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 136248"];
251 [label="param CSharpSyntaxNode(int fullWidth) 136249"];
252 [label="param CSharpSyntaxNode(this) 136250"];
253 [label="kind 136251"];
254 [label="diagnostics 136252"];
255 [label="annotations 136253"];
256 [label="fullWidth 136254"];
257 [label="param CSharpSyntaxNode(this) 136255"];
258 [label="param CSharpSyntaxNode(this) 136256"];
259 [label="GreenStats.NoteGreen(this); 136257"];
260 [label="GreenStats.NoteGreen(this); 136258"];
261 [label="Text 136259"];
262 [label="this.Text 136260"];
263 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136261"];
264 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136262"];
265 [label="if (!elastic)\n            {\n                return trivia;\n            } 136263"];
266 [label="return trivia; 136264"];
267 [label="CarriageReturnLineFeed = EndOfLine(CrLf) 136265"];
268 [label="'\\n' 136266"];
269 [label="EndOfLine('\\n') 136267"];
270 [label="param EndOfLine(string text) 136268"];
271 [label="param EndOfLine(bool elastic = false) 136269"];
272 [label="SyntaxTrivia trivia = null; 136270"];
273 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 136271"];
274 [label="elastic 136272"];
275 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 136273"];
276 [label="if (trivia != null)\n            {\n                return trivia;\n            } 136274"];
277 [label="if (trivia != null)\n            {\n                return trivia;\n            } 136275"];
278 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136276"];
279 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136277"];
280 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 136278"];
281 [label="param Create(SyntaxKind kind) 136279"];
282 [label="param Create(string text) 136280"];
283 [label="return new SyntaxTrivia(kind, text); 136281"];
284 [label="return new SyntaxTrivia(kind, text); 136282"];
285 [label="return new SyntaxTrivia(kind, text); 136283"];
286 [label="new SyntaxTrivia(kind, text) 136284"];
287 [label="param SyntaxTrivia(SyntaxKind kind) 136285"];
288 [label="param SyntaxTrivia(string text) 136286"];
289 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 136287"];
290 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 136288"];
291 [label="param SyntaxTrivia(this) 136289"];
292 [label="kind 136290"];
293 [label="diagnostics 136291"];
294 [label="annotations 136292"];
295 [label="text 136293"];
296 [label="param SyntaxTrivia(this) 136294"];
297 [label="param CSharpSyntaxNode(SyntaxKind kind) 136295"];
298 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 136296"];
299 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 136297"];
300 [label="param CSharpSyntaxNode(int fullWidth) 136298"];
301 [label="param CSharpSyntaxNode(this) 136299"];
302 [label="kind 136300"];
303 [label="diagnostics 136301"];
304 [label="annotations 136302"];
305 [label="fullWidth 136303"];
306 [label="param CSharpSyntaxNode(this) 136304"];
307 [label="param CSharpSyntaxNode(this) 136305"];
308 [label="GreenStats.NoteGreen(this); 136306"];
309 [label="GreenStats.NoteGreen(this); 136307"];
310 [label="Text 136308"];
311 [label="this.Text 136309"];
312 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136310"];
313 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136311"];
314 [label="if (!elastic)\n            {\n                return trivia;\n            } 136312"];
315 [label="return trivia; 136313"];
316 [label="LineFeed = EndOfLine('\\n') 136314"];
317 [label="'\\r' 136315"];
318 [label="EndOfLine('\\r') 136316"];
319 [label="param EndOfLine(string text) 136317"];
320 [label="param EndOfLine(bool elastic = false) 136318"];
321 [label="SyntaxTrivia trivia = null; 136319"];
322 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 136320"];
323 [label="elastic 136321"];
324 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 136322"];
325 [label="if (trivia != null)\n            {\n                return trivia;\n            } 136323"];
326 [label="if (trivia != null)\n            {\n                return trivia;\n            } 136324"];
327 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136325"];
328 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136326"];
329 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 136327"];
330 [label="param Create(SyntaxKind kind) 136328"];
331 [label="param Create(string text) 136329"];
332 [label="return new SyntaxTrivia(kind, text); 136330"];
333 [label="return new SyntaxTrivia(kind, text); 136331"];
334 [label="return new SyntaxTrivia(kind, text); 136332"];
335 [label="new SyntaxTrivia(kind, text) 136333"];
336 [label="param SyntaxTrivia(SyntaxKind kind) 136334"];
337 [label="param SyntaxTrivia(string text) 136335"];
338 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 136336"];
339 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 136337"];
340 [label="param SyntaxTrivia(this) 136338"];
341 [label="kind 136339"];
342 [label="diagnostics 136340"];
343 [label="annotations 136341"];
344 [label="text 136342"];
345 [label="param SyntaxTrivia(this) 136343"];
346 [label="param CSharpSyntaxNode(SyntaxKind kind) 136344"];
347 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 136345"];
348 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 136346"];
349 [label="param CSharpSyntaxNode(int fullWidth) 136347"];
350 [label="param CSharpSyntaxNode(this) 136348"];
351 [label="kind 136349"];
352 [label="diagnostics 136350"];
353 [label="annotations 136351"];
354 [label="fullWidth 136352"];
355 [label="param CSharpSyntaxNode(this) 136353"];
356 [label="param CSharpSyntaxNode(this) 136354"];
357 [label="GreenStats.NoteGreen(this); 136355"];
358 [label="GreenStats.NoteGreen(this); 136356"];
359 [label="Text 136357"];
360 [label="this.Text 136358"];
361 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136359"];
362 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136360"];
363 [label="if (!elastic)\n            {\n                return trivia;\n            } 136361"];
364 [label="return trivia; 136362"];
365 [label="CarriageReturn = EndOfLine('\\r') 136363"];
366 [label="' ' 136364"];
367 [label="Whitespace(' ') 136365"];
368 [label="param Whitespace(string text) 136366"];
369 [label="param Whitespace(bool elastic = false) 136367"];
370 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136368"];
371 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136369"];
372 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 136370"];
373 [label="param Create(SyntaxKind kind) 136371"];
374 [label="param Create(string text) 136372"];
375 [label="return new SyntaxTrivia(kind, text); 136373"];
376 [label="return new SyntaxTrivia(kind, text); 136374"];
377 [label="return new SyntaxTrivia(kind, text); 136375"];
378 [label="new SyntaxTrivia(kind, text) 136376"];
379 [label="param SyntaxTrivia(SyntaxKind kind) 136377"];
380 [label="param SyntaxTrivia(string text) 136378"];
381 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 136379"];
382 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 136380"];
383 [label="param SyntaxTrivia(this) 136381"];
384 [label="kind 136382"];
385 [label="diagnostics 136383"];
386 [label="annotations 136384"];
387 [label="text 136385"];
388 [label="param SyntaxTrivia(this) 136386"];
389 [label="param CSharpSyntaxNode(SyntaxKind kind) 136387"];
390 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 136388"];
391 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 136389"];
392 [label="param CSharpSyntaxNode(int fullWidth) 136390"];
393 [label="param CSharpSyntaxNode(this) 136391"];
394 [label="kind 136392"];
395 [label="diagnostics 136393"];
396 [label="annotations 136394"];
397 [label="fullWidth 136395"];
398 [label="param CSharpSyntaxNode(this) 136396"];
399 [label="param CSharpSyntaxNode(this) 136397"];
400 [label="GreenStats.NoteGreen(this); 136398"];
401 [label="GreenStats.NoteGreen(this); 136399"];
402 [label="Text 136400"];
403 [label="this.Text 136401"];
404 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136402"];
405 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136403"];
406 [label="if (!elastic)\n            {\n                return trivia;\n            } 136404"];
407 [label="return trivia; 136405"];
408 [label="Space = Whitespace(' ') 136406"];
409 [label="'\\t' 136407"];
410 [label="Whitespace('\\t') 136408"];
411 [label="param Whitespace(string text) 136409"];
412 [label="param Whitespace(bool elastic = false) 136410"];
413 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136411"];
414 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136412"];
415 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 136413"];
416 [label="param Create(SyntaxKind kind) 136414"];
417 [label="param Create(string text) 136415"];
418 [label="return new SyntaxTrivia(kind, text); 136416"];
419 [label="return new SyntaxTrivia(kind, text); 136417"];
420 [label="return new SyntaxTrivia(kind, text); 136418"];
421 [label="new SyntaxTrivia(kind, text) 136419"];
422 [label="param SyntaxTrivia(SyntaxKind kind) 136420"];
423 [label="param SyntaxTrivia(string text) 136421"];
424 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 136422"];
425 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 136423"];
426 [label="param SyntaxTrivia(this) 136424"];
427 [label="kind 136425"];
428 [label="diagnostics 136426"];
429 [label="annotations 136427"];
430 [label="text 136428"];
431 [label="param SyntaxTrivia(this) 136429"];
432 [label="param CSharpSyntaxNode(SyntaxKind kind) 136430"];
433 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 136431"];
434 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 136432"];
435 [label="param CSharpSyntaxNode(int fullWidth) 136433"];
436 [label="param CSharpSyntaxNode(this) 136434"];
437 [label="kind 136435"];
438 [label="diagnostics 136436"];
439 [label="annotations 136437"];
440 [label="fullWidth 136438"];
441 [label="param CSharpSyntaxNode(this) 136439"];
442 [label="param CSharpSyntaxNode(this) 136440"];
443 [label="GreenStats.NoteGreen(this); 136441"];
444 [label="GreenStats.NoteGreen(this); 136442"];
445 [label="Text 136443"];
446 [label="this.Text 136444"];
447 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136445"];
448 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136446"];
449 [label="if (!elastic)\n            {\n                return trivia;\n            } 136447"];
450 [label="return trivia; 136448"];
451 [label="Tab = Whitespace('\\t') 136449"];
452 [label="CrLf 136450"];
453 [label="true 136451"];
454 [label="elastic: true 136452"];
455 [label="EndOfLine(CrLf, elastic: true) 136453"];
456 [label="param EndOfLine(string text) 136454"];
457 [label="param EndOfLine(bool elastic = false) 136455"];
458 [label="SyntaxTrivia trivia = null; 136456"];
459 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 136457"];
460 [label="elastic 136458"];
461 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 136459"];
462 [label="if (trivia != null)\n            {\n                return trivia;\n            } 136460"];
463 [label="if (trivia != null)\n            {\n                return trivia;\n            } 136461"];
464 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136462"];
465 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136463"];
466 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 136464"];
467 [label="param Create(SyntaxKind kind) 136465"];
468 [label="param Create(string text) 136466"];
469 [label="return new SyntaxTrivia(kind, text); 136467"];
470 [label="return new SyntaxTrivia(kind, text); 136468"];
471 [label="return new SyntaxTrivia(kind, text); 136469"];
472 [label="new SyntaxTrivia(kind, text) 136470"];
473 [label="param SyntaxTrivia(SyntaxKind kind) 136471"];
474 [label="param SyntaxTrivia(string text) 136472"];
475 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 136473"];
476 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 136474"];
477 [label="param SyntaxTrivia(this) 136475"];
478 [label="kind 136476"];
479 [label="diagnostics 136477"];
480 [label="annotations 136478"];
481 [label="text 136479"];
482 [label="param SyntaxTrivia(this) 136480"];
483 [label="param CSharpSyntaxNode(SyntaxKind kind) 136481"];
484 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 136482"];
485 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 136483"];
486 [label="param CSharpSyntaxNode(int fullWidth) 136484"];
487 [label="param CSharpSyntaxNode(this) 136485"];
488 [label="kind 136486"];
489 [label="diagnostics 136487"];
490 [label="annotations 136488"];
491 [label="fullWidth 136489"];
492 [label="param CSharpSyntaxNode(this) 136490"];
493 [label="param CSharpSyntaxNode(this) 136491"];
494 [label="GreenStats.NoteGreen(this); 136492"];
495 [label="GreenStats.NoteGreen(this); 136493"];
496 [label="Text 136494"];
497 [label="this.Text 136495"];
498 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136496"];
499 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136497"];
500 [label="if (!elastic)\n            {\n                return trivia;\n            } 136498"];
501 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136499"];
502 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136500"];
503 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 136501"];
504 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136502"];
505 [label="param SetAnnotations(SyntaxAnnotation[]? annotations) 136503"];
506 [label="param SetAnnotations(this) 136504"];
507 [label="this.Kind 136505"];
508 [label="get { return (SyntaxKind)this.RawKind; } 136506"];
509 [label="return (SyntaxKind)this.RawKind; 136507"];
510 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 136508"];
511 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 136509"];
512 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 136510"];
513 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 136511"];
514 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 136512"];
515 [label="param SyntaxTrivia(SyntaxKind kind) 136513"];
516 [label="param SyntaxTrivia(string text) 136514"];
517 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 136515"];
518 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 136516"];
519 [label="param SyntaxTrivia(this) 136517"];
520 [label="param SyntaxTrivia(this) 136518"];
521 [label="param CSharpSyntaxNode(this) 136519"];
522 [label="param CSharpSyntaxNode(this) 136520"];
523 [label="param CSharpSyntaxNode(this) 136521"];
524 [label="GreenStats.NoteGreen(this); 136522"];
525 [label="Text 136523"];
526 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136524"];
527 [label="ElasticCarriageReturnLineFeed = EndOfLine(CrLf, elastic: true) 136525"];
528 [label="'\\n' 136526"];
529 [label="true 136527"];
530 [label="elastic: true 136528"];
531 [label="EndOfLine('\\n', elastic: true) 136529"];
532 [label="param EndOfLine(string text) 136530"];
533 [label="param EndOfLine(bool elastic = false) 136531"];
534 [label="SyntaxTrivia trivia = null; 136532"];
535 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 136533"];
536 [label="elastic 136534"];
537 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 136535"];
538 [label="if (trivia != null)\n            {\n                return trivia;\n            } 136536"];
539 [label="if (trivia != null)\n            {\n                return trivia;\n            } 136537"];
540 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136538"];
541 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136539"];
542 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 136540"];
543 [label="param Create(SyntaxKind kind) 136541"];
544 [label="param Create(string text) 136542"];
545 [label="return new SyntaxTrivia(kind, text); 136543"];
546 [label="return new SyntaxTrivia(kind, text); 136544"];
547 [label="return new SyntaxTrivia(kind, text); 136545"];
548 [label="new SyntaxTrivia(kind, text) 136546"];
549 [label="param SyntaxTrivia(SyntaxKind kind) 136547"];
550 [label="param SyntaxTrivia(string text) 136548"];
551 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 136549"];
552 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 136550"];
553 [label="param SyntaxTrivia(this) 136551"];
554 [label="kind 136552"];
555 [label="diagnostics 136553"];
556 [label="annotations 136554"];
557 [label="text 136555"];
558 [label="param SyntaxTrivia(this) 136556"];
559 [label="param CSharpSyntaxNode(SyntaxKind kind) 136557"];
560 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 136558"];
561 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 136559"];
562 [label="param CSharpSyntaxNode(int fullWidth) 136560"];
563 [label="param CSharpSyntaxNode(this) 136561"];
564 [label="kind 136562"];
565 [label="diagnostics 136563"];
566 [label="annotations 136564"];
567 [label="fullWidth 136565"];
568 [label="param CSharpSyntaxNode(this) 136566"];
569 [label="param CSharpSyntaxNode(this) 136567"];
570 [label="GreenStats.NoteGreen(this); 136568"];
571 [label="GreenStats.NoteGreen(this); 136569"];
572 [label="Text 136570"];
573 [label="this.Text 136571"];
574 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136572"];
575 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136573"];
576 [label="if (!elastic)\n            {\n                return trivia;\n            } 136574"];
577 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136575"];
578 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136576"];
579 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 136577"];
580 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136578"];
581 [label="this.Kind 136579"];
582 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 136580"];
583 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 136581"];
584 [label="param SyntaxTrivia(this) 136582"];
585 [label="param SyntaxTrivia(this) 136583"];
586 [label="param CSharpSyntaxNode(this) 136584"];
587 [label="param CSharpSyntaxNode(this) 136585"];
588 [label="GreenStats.NoteGreen(this); 136586"];
589 [label="Text 136587"];
590 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136588"];
591 [label="ElasticLineFeed = EndOfLine('\\n', elastic: true) 136589"];
592 [label="'\\r' 136590"];
593 [label="true 136591"];
594 [label="elastic: true 136592"];
595 [label="EndOfLine('\\r', elastic: true) 136593"];
596 [label="param EndOfLine(string text) 136594"];
597 [label="param EndOfLine(bool elastic = false) 136595"];
598 [label="SyntaxTrivia trivia = null; 136596"];
599 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 136597"];
600 [label="elastic 136598"];
601 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 136599"];
602 [label="if (trivia != null)\n            {\n                return trivia;\n            } 136600"];
603 [label="if (trivia != null)\n            {\n                return trivia;\n            } 136601"];
604 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136602"];
605 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136603"];
606 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 136604"];
607 [label="param Create(SyntaxKind kind) 136605"];
608 [label="param Create(string text) 136606"];
609 [label="return new SyntaxTrivia(kind, text); 136607"];
610 [label="return new SyntaxTrivia(kind, text); 136608"];
611 [label="return new SyntaxTrivia(kind, text); 136609"];
612 [label="new SyntaxTrivia(kind, text) 136610"];
613 [label="param SyntaxTrivia(SyntaxKind kind) 136611"];
614 [label="param SyntaxTrivia(string text) 136612"];
615 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 136613"];
616 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 136614"];
617 [label="param SyntaxTrivia(this) 136615"];
618 [label="kind 136616"];
619 [label="diagnostics 136617"];
620 [label="annotations 136618"];
621 [label="text 136619"];
622 [label="param SyntaxTrivia(this) 136620"];
623 [label="param CSharpSyntaxNode(SyntaxKind kind) 136621"];
624 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 136622"];
625 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 136623"];
626 [label="param CSharpSyntaxNode(int fullWidth) 136624"];
627 [label="param CSharpSyntaxNode(this) 136625"];
628 [label="kind 136626"];
629 [label="diagnostics 136627"];
630 [label="annotations 136628"];
631 [label="fullWidth 136629"];
632 [label="param CSharpSyntaxNode(this) 136630"];
633 [label="param CSharpSyntaxNode(this) 136631"];
634 [label="GreenStats.NoteGreen(this); 136632"];
635 [label="GreenStats.NoteGreen(this); 136633"];
636 [label="Text 136634"];
637 [label="this.Text 136635"];
638 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136636"];
639 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 136637"];
640 [label="if (!elastic)\n            {\n                return trivia;\n            } 136638"];
641 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136639"];
642 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136640"];
643 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 136641"];
644 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136642"];
645 [label="this.Kind 136643"];
646 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 136644"];
647 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 136645"];
648 [label="param SyntaxTrivia(this) 136646"];
649 [label="param SyntaxTrivia(this) 136647"];
650 [label="param CSharpSyntaxNode(this) 136648"];
651 [label="param CSharpSyntaxNode(this) 136649"];
652 [label="GreenStats.NoteGreen(this); 136650"];
653 [label="Text 136651"];
654 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136652"];
655 [label="ElasticCarriageReturn = EndOfLine('\\r', elastic: true) 136653"];
656 [label="' ' 136654"];
657 [label="true 136655"];
658 [label="elastic: true 136656"];
659 [label="Whitespace(' ', elastic: true) 136657"];
660 [label="param Whitespace(string text) 136658"];
661 [label="param Whitespace(bool elastic = false) 136659"];
662 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136660"];
663 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136661"];
664 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 136662"];
665 [label="param Create(SyntaxKind kind) 136663"];
666 [label="param Create(string text) 136664"];
667 [label="return new SyntaxTrivia(kind, text); 136665"];
668 [label="return new SyntaxTrivia(kind, text); 136666"];
669 [label="return new SyntaxTrivia(kind, text); 136667"];
670 [label="new SyntaxTrivia(kind, text) 136668"];
671 [label="param SyntaxTrivia(SyntaxKind kind) 136669"];
672 [label="param SyntaxTrivia(string text) 136670"];
673 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 136671"];
674 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 136672"];
675 [label="param SyntaxTrivia(this) 136673"];
676 [label="kind 136674"];
677 [label="diagnostics 136675"];
678 [label="annotations 136676"];
679 [label="text 136677"];
680 [label="param SyntaxTrivia(this) 136678"];
681 [label="param CSharpSyntaxNode(SyntaxKind kind) 136679"];
682 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 136680"];
683 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 136681"];
684 [label="param CSharpSyntaxNode(int fullWidth) 136682"];
685 [label="param CSharpSyntaxNode(this) 136683"];
686 [label="kind 136684"];
687 [label="diagnostics 136685"];
688 [label="annotations 136686"];
689 [label="fullWidth 136687"];
690 [label="param CSharpSyntaxNode(this) 136688"];
691 [label="param CSharpSyntaxNode(this) 136689"];
692 [label="GreenStats.NoteGreen(this); 136690"];
693 [label="GreenStats.NoteGreen(this); 136691"];
694 [label="Text 136692"];
695 [label="this.Text 136693"];
696 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136694"];
697 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136695"];
698 [label="if (!elastic)\n            {\n                return trivia;\n            } 136696"];
699 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136697"];
700 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136698"];
701 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 136699"];
702 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136700"];
703 [label="this.Kind 136701"];
704 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 136702"];
705 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 136703"];
706 [label="param SyntaxTrivia(this) 136704"];
707 [label="param SyntaxTrivia(this) 136705"];
708 [label="param CSharpSyntaxNode(this) 136706"];
709 [label="param CSharpSyntaxNode(this) 136707"];
710 [label="GreenStats.NoteGreen(this); 136708"];
711 [label="Text 136709"];
712 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136710"];
713 [label="ElasticSpace = Whitespace(' ', elastic: true) 136711"];
714 [label="'\\t' 136712"];
715 [label="true 136713"];
716 [label="elastic: true 136714"];
717 [label="Whitespace('\\t', elastic: true) 136715"];
718 [label="param Whitespace(string text) 136716"];
719 [label="param Whitespace(bool elastic = false) 136717"];
720 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136718"];
721 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136719"];
722 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 136720"];
723 [label="param Create(SyntaxKind kind) 136721"];
724 [label="param Create(string text) 136722"];
725 [label="return new SyntaxTrivia(kind, text); 136723"];
726 [label="return new SyntaxTrivia(kind, text); 136724"];
727 [label="return new SyntaxTrivia(kind, text); 136725"];
728 [label="new SyntaxTrivia(kind, text) 136726"];
729 [label="param SyntaxTrivia(SyntaxKind kind) 136727"];
730 [label="param SyntaxTrivia(string text) 136728"];
731 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 136729"];
732 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 136730"];
733 [label="param SyntaxTrivia(this) 136731"];
734 [label="kind 136732"];
735 [label="diagnostics 136733"];
736 [label="annotations 136734"];
737 [label="text 136735"];
738 [label="param SyntaxTrivia(this) 136736"];
739 [label="param CSharpSyntaxNode(SyntaxKind kind) 136737"];
740 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 136738"];
741 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 136739"];
742 [label="param CSharpSyntaxNode(int fullWidth) 136740"];
743 [label="param CSharpSyntaxNode(this) 136741"];
744 [label="kind 136742"];
745 [label="diagnostics 136743"];
746 [label="annotations 136744"];
747 [label="fullWidth 136745"];
748 [label="param CSharpSyntaxNode(this) 136746"];
749 [label="param CSharpSyntaxNode(this) 136747"];
750 [label="GreenStats.NoteGreen(this); 136748"];
751 [label="GreenStats.NoteGreen(this); 136749"];
752 [label="Text 136750"];
753 [label="this.Text 136751"];
754 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136752"];
755 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136753"];
756 [label="if (!elastic)\n            {\n                return trivia;\n            } 136754"];
757 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136755"];
758 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136756"];
759 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 136757"];
760 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136758"];
761 [label="this.Kind 136759"];
762 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 136760"];
763 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 136761"];
764 [label="param SyntaxTrivia(this) 136762"];
765 [label="param SyntaxTrivia(this) 136763"];
766 [label="param CSharpSyntaxNode(this) 136764"];
767 [label="param CSharpSyntaxNode(this) 136765"];
768 [label="GreenStats.NoteGreen(this); 136766"];
769 [label="Text 136767"];
770 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136768"];
771 [label="ElasticTab = Whitespace('\\t', elastic: true) 136769"];
772 [label="string.Empty 136770"];
773 [label="true 136771"];
774 [label="elastic: true 136772"];
775 [label="Whitespace(string.Empty, elastic: true) 136773"];
776 [label="param Whitespace(string text) 136774"];
777 [label="param Whitespace(bool elastic = false) 136775"];
778 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136776"];
779 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136777"];
780 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 136778"];
781 [label="param Create(SyntaxKind kind) 136779"];
782 [label="param Create(string text) 136780"];
783 [label="return new SyntaxTrivia(kind, text); 136781"];
784 [label="return new SyntaxTrivia(kind, text); 136782"];
785 [label="return new SyntaxTrivia(kind, text); 136783"];
786 [label="new SyntaxTrivia(kind, text) 136784"];
787 [label="param SyntaxTrivia(SyntaxKind kind) 136785"];
788 [label="param SyntaxTrivia(string text) 136786"];
789 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 136787"];
790 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 136788"];
791 [label="param SyntaxTrivia(this) 136789"];
792 [label="kind 136790"];
793 [label="diagnostics 136791"];
794 [label="annotations 136792"];
795 [label="text 136793"];
796 [label="param SyntaxTrivia(this) 136794"];
797 [label="param CSharpSyntaxNode(SyntaxKind kind) 136795"];
798 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 136796"];
799 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 136797"];
800 [label="param CSharpSyntaxNode(int fullWidth) 136798"];
801 [label="param CSharpSyntaxNode(this) 136799"];
802 [label="kind 136800"];
803 [label="diagnostics 136801"];
804 [label="annotations 136802"];
805 [label="fullWidth 136803"];
806 [label="param CSharpSyntaxNode(this) 136804"];
807 [label="param CSharpSyntaxNode(this) 136805"];
808 [label="GreenStats.NoteGreen(this); 136806"];
809 [label="GreenStats.NoteGreen(this); 136807"];
810 [label="Text 136808"];
811 [label="this.Text 136809"];
812 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136810"];
813 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 136811"];
814 [label="if (!elastic)\n            {\n                return trivia;\n            } 136812"];
815 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136813"];
816 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136814"];
817 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 136815"];
818 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 136816"];
819 [label="this.Kind 136817"];
820 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 136818"];
821 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 136819"];
822 [label="param SyntaxTrivia(this) 136820"];
823 [label="param SyntaxTrivia(this) 136821"];
824 [label="param CSharpSyntaxNode(this) 136822"];
825 [label="param CSharpSyntaxNode(this) 136823"];
826 [label="GreenStats.NoteGreen(this); 136824"];
827 [label="Text 136825"];
828 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 136826"];
829 [label="ElasticZeroSpace = Whitespace(string.Empty, elastic: true) 136827"];
830 [label="s_xmlCarriageReturnLineFeed 136828"];
831 [label="public static SyntaxTrivia CarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed; 136829"];
832 [label="param operator(SyntaxTrivia trivia) 136830"];
833 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136831"];
834 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136832"];
835 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136833"];
836 [label="public static SyntaxTrivia LineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.LineFeed; 136834"];
837 [label="param operator(SyntaxTrivia trivia) 136835"];
838 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136836"];
839 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136837"];
840 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136838"];
841 [label="public static SyntaxTrivia CarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn; 136839"];
842 [label="param operator(SyntaxTrivia trivia) 136840"];
843 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136841"];
844 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136842"];
845 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136843"];
846 [label="public static SyntaxTrivia Space { get; } = Syntax.InternalSyntax.SyntaxFactory.Space; 136844"];
847 [label="param operator(SyntaxTrivia trivia) 136845"];
848 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136846"];
849 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136847"];
850 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136848"];
851 [label="public static SyntaxTrivia Tab { get; } = Syntax.InternalSyntax.SyntaxFactory.Tab; 136849"];
852 [label="param operator(SyntaxTrivia trivia) 136850"];
853 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136851"];
854 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136852"];
855 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136853"];
856 [label="public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed; 136854"];
857 [label="param operator(SyntaxTrivia trivia) 136855"];
858 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136856"];
859 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136857"];
860 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136858"];
861 [label="public static SyntaxTrivia ElasticLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed; 136859"];
862 [label="param operator(SyntaxTrivia trivia) 136860"];
863 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136861"];
864 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136862"];
865 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136863"];
866 [label="public static SyntaxTrivia ElasticCarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn; 136864"];
867 [label="param operator(SyntaxTrivia trivia) 136865"];
868 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136866"];
869 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136867"];
870 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136868"];
871 [label="public static SyntaxTrivia ElasticSpace { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace; 136869"];
872 [label="param operator(SyntaxTrivia trivia) 136870"];
873 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136871"];
874 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136872"];
875 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136873"];
876 [label="public static SyntaxTrivia ElasticTab { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticTab; 136874"];
877 [label="param operator(SyntaxTrivia trivia) 136875"];
878 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136876"];
879 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136877"];
880 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136878"];
881 [label="public static SyntaxTrivia ElasticMarker { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace; 136879"];
882 [label="param operator(SyntaxTrivia trivia) 136880"];
883 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136881"];
884 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136882"];
885 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 136883"];
886 [label="return SyntaxFactory.ParseStatement(text, offset, options); 136884"];
887 [label="return SyntaxFactory.ParseStatement(text, offset, options); 136885"];
888 [label="return SyntaxFactory.ParseStatement(text, offset, options); 136886"];
889 [label="return SyntaxFactory.ParseStatement(text, offset, options); 136887"];
890 [label="SyntaxFactory.ParseStatement(text, offset, options) 136888"];
891 [label="param ParseStatement(string text) 136889"];
892 [label="param ParseStatement(int offset = 0) 136890"];
893 [label="param ParseStatement(ParseOptions? options = null) 136891"];
894 [label="param ParseStatement(bool consumeFullText = true) 136892"];
895 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 136893"];
896 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 136894"];
897 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 136895"];
898 [label="MakeLexer(text, offset, (CSharpParseOptions?)options) 136896"];
899 [label="param MakeLexer(string text) 136897"];
900 [label="param MakeLexer(int offset) 136898"];
901 [label="param MakeLexer(CSharpParseOptions? options = null) 136899"];
902 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 136900"];
903 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 136901"];
904 [label="MakeSourceText(text, offset) 136902"];
905 [label="param MakeSourceText(string text) 136903"];
906 [label="param MakeSourceText(int offset) 136904"];
907 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 136905"];
908 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 136906"];
909 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 136907"];
910 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 136908"];
911 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 136909"];
912 [label="8 136910"];
913 [label="TriviaListInitialCapacity = 8 136911"];
914 [label="TokensLexed 136912"];
915 [label="'<<<<<<<' 136913"];
916 [label="s_conflictMarkerLength = '<<<<<<<'.Length 136914"];
917 [label="42 136915"];
918 [label="MaxCachedTokenSize = 42 136916"];
919 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 136917"];
920 [label="{\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            } 136918"];
921 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 136919"];
922 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 136920"];
923 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 136921"];
924 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 136922"];
925 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 136923"];
926 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 136924"];
927 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 136925"];
928 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 136926"];
929 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 136927"];
930 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 136928"];
931 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 136929"];
932 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 136930"];
933 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 136931"];
934 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 136932"];
935 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 136933"];
936 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 136934"];
937 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 136935"];
938 [label="s_stateTransitions = new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 136936"];
939 [label="new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 136937"];
940 [label="s_charProperties = new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 136938"];
941 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 136939"];
942 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 136940"];
943 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 136941"];
944 [label="new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default) 136942"];
945 [label="param Lexer(SourceText text) 136943"];
946 [label="param Lexer(CSharpParseOptions options) 136944"];
947 [label="param Lexer(bool allowPreprocessorDirectives = true) 136945"];
948 [label="param Lexer(bool interpolationFollowedByColon = false) 136946"];
949 [label="param Lexer(this) 136947"];
950 [label="text 136948"];
951 [label="param Lexer(this) 136949"];
952 [label="param AbstractLexer(SourceText text) 136950"];
953 [label="param AbstractLexer(this) 136951"];
954 [label="TextWindow 136952"];
955 [label="_errors 136953"];
956 [label="InvalidCharacter = char.MaxValue 136954"];
957 [label="2048 136955"];
958 [label="DefaultWindowLength = 2048 136956"];
959 [label="() => new char[DefaultWindowLength] 136957"];
960 [label="new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 136958"];
961 [label="s_windowPool = new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 136959"];
962 [label="this.TextWindow = new SlidingTextWindow(text); 136960"];
963 [label="this.TextWindow = new SlidingTextWindow(text); 136961"];
964 [label="new SlidingTextWindow(text) 136962"];
965 [label="param SlidingTextWindow(SourceText text) 136963"];
966 [label="param SlidingTextWindow(this) 136964"];
967 [label="_text 136965"];
968 [label="_basis 136966"];
969 [label="_offset 136967"];
970 [label="_textEnd 136968"];
971 [label="_characterWindow 136969"];
972 [label="_characterWindowCount 136970"];
973 [label="_lexemeStart 136971"];
974 [label="_strings 136972"];
975 [label="_text 136973"];
976 [label="_basis = 0; 136974"];
977 [label="_basis 136975"];
978 [label="_offset = 0; 136976"];
979 [label="_offset 136977"];
980 [label="_textEnd 136978"];
981 [label="_strings = StringTable.GetInstance(); 136979"];
982 [label="_strings 136980"];
983 [label="_characterWindow = s_windowPool.Allocate(); 136981"];
984 [label="_characterWindow 136982"];
985 [label="_lexemeStart = 0; 136983"];
986 [label="_lexemeStart 136984"];
987 [label="this.TextWindow 136985"];
988 [label="_options 136986"];
989 [label="_mode 136987"];
990 [label="_builder 136988"];
991 [label="_identBuffer 136989"];
992 [label="_identLen 136990"];
993 [label="_cache 136991"];
994 [label="_allowPreprocessorDirectives 136992"];
995 [label="_interpolationFollowedByColon 136993"];
996 [label="_xmlParser 136994"];
997 [label="_badTokenCount 136995"];
998 [label="10 136996"];
999 [label="new SyntaxListBuilder(10) 136997"];
1000 [label="_leadingTriviaCache = new SyntaxListBuilder(10) 136998"];
1001 [label="10 136999"];
1002 [label="new SyntaxListBuilder(10) 137000"];
1003 [label="_trailingTriviaCache = new SyntaxListBuilder(10) 137001"];
1004 [label="_createWhitespaceTriviaFunction 137002"];
1005 [label="_createQuickTokenFunction 137003"];
1006 [label="Debug.Assert(options != null); 137004"];
1007 [label="Debug.Assert(options != null); 137005"];
1008 [label="_options 137006"];
1009 [label="_builder = new StringBuilder(); 137007"];
1010 [label="_builder 137008"];
1011 [label="_identBuffer = new char[32]; 137009"];
1012 [label="_identBuffer 137010"];
1013 [label="512 137011"];
1014 [label="(key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            } 137012"];
1015 [label="CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 137013"];
1016 [label="s_keywordKindPool =\n            CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 137014"];
1017 [label="10 137015"];
1018 [label="MaxKeywordLength = 10 137016"];
1019 [label="_cache = new LexerCache(); 137017"];
1020 [label="new LexerCache() 137018"];
1021 [label="param LexerCache(this) 137019"];
1022 [label="_triviaMap 137020"];
1023 [label="_tokenMap 137021"];
1024 [label="_keywordKindMap 137022"];
1025 [label="_triviaMap = TextKeyedCache<SyntaxTrivia>.GetInstance(); 137023"];
1026 [label="_triviaMap 137024"];
1027 [label="_tokenMap = TextKeyedCache<SyntaxToken>.GetInstance(); 137025"];
1028 [label="_tokenMap 137026"];
1029 [label="_keywordKindMap = s_keywordKindPool.Allocate(); 137027"];
1030 [label="_keywordKindMap 137028"];
1031 [label="_cache 137029"];
1032 [label="_createQuickTokenFunction 137030"];
1033 [label="_allowPreprocessorDirectives 137031"];
1034 [label="_interpolationFollowedByColon 137032"];
1035 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 137033"];
1036 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 137034"];
1037 [label="MakeParser(lexer) 137035"];
1038 [label="param MakeParser(InternalSyntax.Lexer lexer) 137036"];
1039 [label="LastTerminatorState = (int)TerminatorState.IsEndOfRecordSignature 137037"];
1040 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 137038"];
1041 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 137039"];
1042 [label="new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null) 137040"];
1043 [label="param LanguageParser(Lexer lexer) 137041"];
1044 [label="param LanguageParser(CSharp.CSharpSyntaxNode oldTree) 137042"];
1045 [label="param LanguageParser(IEnumerable<TextChangeRange> changes) 137043"];
1046 [label="param LanguageParser(LexerMode lexerMode = LexerMode.Syntax) 137044"];
1047 [label="param LanguageParser(CancellationToken cancellationToken = default(CancellationToken)) 137045"];
1048 [label="param LanguageParser(this) 137046"];
1049 [label="() => new BlendedNode[32] 137047"];
1050 [label="2 137048"];
1051 [label="new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 137049"];
1052 [label="s_blendedNodesPool = new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 137050"];
1053 [label="lexer 137051"];
1054 [label="lexerMode 137052"];
1055 [label="oldTree 137053"];
1056 [label="changes 137054"];
1057 [label="false 137055"];
1058 [label="true 137056"];
1059 [label="cancellationToken 137057"];
1060 [label="param LanguageParser(this) 137058"];
1061 [label="param SyntaxParser(Lexer lexer) 137059"];
1062 [label="param SyntaxParser(LexerMode mode) 137060"];
1063 [label="param SyntaxParser(CSharp.CSharpSyntaxNode oldTree) 137061"];
1064 [label="param SyntaxParser(IEnumerable<TextChangeRange> changes) 137062"];
1065 [label="param SyntaxParser(bool allowModeReset) 137063"];
1066 [label="param SyntaxParser(bool preLexIfNotIncremental = false) 137064"];
1067 [label="param SyntaxParser(CancellationToken cancellationToken = default(CancellationToken)) 137065"];
1068 [label="param SyntaxParser(this) 137066"];
1069 [label="lexer 137067"];
1070 [label="_isIncremental 137068"];
1071 [label="_allowModeReset 137069"];
1072 [label="_mode 137070"];
1073 [label="_currentToken 137071"];
1074 [label="_lexedTokens 137072"];
1075 [label="_prevTokenTrailingTrivia 137073"];
1076 [label="_firstToken 137074"];
1077 [label="_tokenOffset 137075"];
1078 [label="_tokenCount 137076"];
1079 [label="_resetCount 137077"];
1080 [label="_resetStart 137078"];
1081 [label="_blendedTokens 137079"];
1082 [label="this.lexer 137080"];
1083 [label="_mode 137081"];
1084 [label="_allowModeReset 137082"];
1085 [label="this.cancellationToken 137083"];
1086 [label="_currentNode = default(BlendedNode); 137084"];
1087 [label="_currentNode 137085"];
1088 [label="_isIncremental = oldTree != null; 137086"];
1089 [label="_isIncremental = oldTree != null; 137087"];
1090 [label="_isIncremental 137088"];
1091 [label="this.IsIncremental 137089"];
1092 [label="get\n            {\n                return _isIncremental;\n            } 137090"];
1093 [label="return _isIncremental; 137091"];
1094 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 137092"];
1095 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 137093"];
1096 [label="_firstBlender = default(Blender); 137094"];
1097 [label="_firstBlender 137095"];
1098 [label="_lexedTokens = new ArrayElement<SyntaxToken>[32]; 137096"];
1099 [label="_lexedTokens 137097"];
1100 [label="this.IsIncremental 137098"];
1101 [label="get\n            {\n                return _isIncremental;\n            } 137099"];
1102 [label="return _isIncremental; 137100"];
1103 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 137101"];
1104 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 137102"];
1105 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 137103"];
1106 [label="this.PreLex() 137104"];
1107 [label="param PreLex(this) 137105"];
1108 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 137106"];
1109 [label="this.lexer.TextWindow.Text 137107"];
1110 [label="=> _text 137108"];
1111 [label="_text 137109"];
1112 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 137110"];
1113 [label="_lexedTokens = new ArrayElement<SyntaxToken>[size]; 137111"];
1114 [label="_lexedTokens 137112"];
1115 [label="var lexer = this.lexer; 137113"];
1116 [label="var mode = _mode; 137114"];
1117 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 137115"];
1118 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 137116"];
1119 [label="var token = lexer.Lex(mode); 137117"];
1120 [label="lexer.Lex(mode) 137118"];
1121 [label="param Lex(LexerMode mode) 137119"];
1122 [label="param Lex(this) 137120"];
1123 [label="TokensLexed++; 137121"];
1124 [label="_mode 137122"];
1125 [label="switch (_mode)\n            {\n                case LexerMode.Syntax:\n                case LexerMode.DebuggerSyntax:\n                    return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();\n                case LexerMode.Directive:\n                    return this.LexDirectiveToken();\n            } 137123"];
1126 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 137124"];
1127 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 137125"];
1128 [label="param Start(this) 137126"];
1129 [label="TextWindow.Start() 137127"];
1130 [label="param Start(this) 137128"];
1131 [label="_lexemeStart 137129"];
1132 [label="TextWindow.Start(); 137130"];
1133 [label="_errors = null; 137131"];
1134 [label="_errors 137132"];
1135 [label="get\n            {\n                return _offset;\n            } 137133"];
1136 [label="return _offset; 137134"];
1137 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 137135"];
1138 [label="get\n            {\n                return _characterWindowCount;\n            } 137136"];
1139 [label="return _characterWindowCount; 137137"];
1140 [label="get\n            {\n                return _characterWindow;\n            } 137138"];
1141 [label="return _characterWindow; 137139"];
1142 [label="param AdvanceChar(int n) 137140"];
1143 [label="param AdvanceChar(this) 137141"];
1144 [label="_offset += n; 137142"];
1145 [label="_offset 137143"];
1146 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 137144"];
1147 [label="return _basis + _lexemeStart; 137145"];
1148 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 137146"];
1149 [label="param Reset(int position) 137147"];
1150 [label="param Reset(this) 137148"];
1151 [label="int relative = position - _basis; 137149"];
1152 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 137150"];
1153 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 137151"];
1154 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 137152"];
1155 [label="_offset 137153"];
1156 [label="this.LexSyntaxToken() 137154"];
1157 [label="param LexSyntaxToken(this) 137155"];
1158 [label="_leadingTriviaCache.Clear(); 137156"];
1159 [label="TextWindow.Position 137157"];
1160 [label="get\n            {\n                return _basis + _offset;\n            } 137158"];
1161 [label="return _basis + _offset; 137159"];
1162 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 137160"];
1163 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 137161"];
1164 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 137162"];
1165 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache) 137163"];
1166 [label="param LexSyntaxTrivia(bool afterFirstToken) 137164"];
1167 [label="param LexSyntaxTrivia(bool isTrailing) 137165"];
1168 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 137166"];
1169 [label="param LexSyntaxTrivia(this) 137167"];
1170 [label="bool onlyWhitespaceOnLine = !isTrailing; 137168"];
1171 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 137169"];
1172 [label="this.Start() 137170"];
1173 [label="param Start(this) 137171"];
1174 [label="TextWindow.Start() 137172"];
1175 [label="param Start(this) 137173"];
1176 [label="TextWindow.Start(); 137174"];
1177 [label="_errors = null; 137175"];
1178 [label="_errors 137176"];
1179 [label="this.Start(); 137177"];
1180 [label="TextWindow.PeekChar() 137178"];
1181 [label="param PeekChar(this) 137179"];
1182 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 137180"];
1183 [label="MoreChars() 137181"];
1184 [label="param MoreChars(this) 137182"];
1185 [label="if (_offset >= _characterWindowCount)\n            {\n                if (this.Position >= _textEnd)\n                {\n                    return false;\n                }\n\n                // if lexeme scanning is sufficiently into the char buffer, \n                // then refocus the window onto the lexeme\n                if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                }\n\n                if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                }\n\n                int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount);\n                _text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead);\n                _characterWindowCount += amountToRead;\n                return amountToRead > 0;\n            } 137183"];
1186 [label="this.Position 137184"];
1187 [label="get\n            {\n                return _basis + _offset;\n            } 137185"];
1188 [label="return _basis + _offset; 137186"];
1189 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 137187"];
1190 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 137188"];
1191 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 137189"];
1192 [label="if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                } 137190"];
1193 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 137191"];
1194 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 137192"];
1195 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 137193"];
1196 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 137194"];
1197 [label="_characterWindowCount += amountToRead; 137195"];
1198 [label="_characterWindowCount 137196"];
1199 [label="return amountToRead > 0; 137197"];
1200 [label="return amountToRead > 0; 137198"];
1201 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 137199"];
1202 [label="return _characterWindow[_offset]; 137200"];
1203 [label="char ch = TextWindow.PeekChar(); 137201"];
1204 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 137202"];
1205 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 137203"];
1206 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 137204"];
1207 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 137205"];
1208 [label="return; 137206"];
1209 [label="var leading = _leadingTriviaCache; 137207"];
1210 [label="var tokenInfo = default(TokenInfo); 137208"];
1211 [label="this.Start() 137209"];
1212 [label="param Start(this) 137210"];
1213 [label="TextWindow.Start() 137211"];
1214 [label="param Start(this) 137212"];
1215 [label="TextWindow.Start(); 137213"];
1216 [label="_errors = null; 137214"];
1217 [label="_errors 137215"];
1218 [label="this.Start(); 137216"];
1219 [label="this.ScanSyntaxToken(ref tokenInfo); 137217"];
1220 [label="this.ScanSyntaxToken(ref tokenInfo); 137218"];
1221 [label="this.ScanSyntaxToken(ref tokenInfo); 137219"];
1222 [label="get\n            {\n                return _basis + _offset;\n            } 137220"];
1223 [label="return _basis + _offset; 137221"];
1224 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 137222"];
1225 [label="return _characterWindow[_offset]; 137223"];
1226 [label="param ScanIdentifierOrKeyword(ref TokenInfo info) 137224"];
1227 [label="param ScanIdentifierOrKeyword(this) 137225"];
1228 [label="info.ContextualKind 137226"];
1229 [label="if (this.ScanIdentifier(ref info))\n            {\n                // check to see if it is an actual keyword\n                if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                }\n\n                return true;\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                return false;\n            } 137227"];
1230 [label="this.ScanIdentifier(ref info) 137228"];
1231 [label="param ScanIdentifier(ref TokenInfo info) 137229"];
1232 [label="param ScanIdentifier(this) 137230"];
1233 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 137231"];
1234 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 137232"];
1235 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 137233"];
1236 [label="param Intern(char[] array) 137234"];
1237 [label="param Intern(int start) 137235"];
1238 [label="param Intern(int length) 137236"];
1239 [label="param Intern(this) 137237"];
1240 [label="return _strings.Add(array, start, length); 137238"];
1241 [label="return _strings.Add(array, start, length); 137239"];
1242 [label="return _strings.Add(array, start, length); 137240"];
1243 [label="return _strings.Add(array, start, length); 137241"];
1244 [label="if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                } 137242"];
1245 [label="if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    } 137243"];
1246 [label="this.ModeIs(LexerMode.Directive) 137244"];
1247 [label="param ModeIs(LexerMode mode) 137245"];
1248 [label="param ModeIs(this) 137246"];
1249 [label="return ModeOf(_mode) == mode; 137247"];
1250 [label="ModeOf(_mode) 137248"];
1251 [label="param ModeOf(LexerMode mode) 137249"];
1252 [label="return mode & LexerMode.MaskLexMode; 137250"];
1253 [label="return ModeOf(_mode) == mode; 137251"];
1254 [label="if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 137252"];
1255 [label="_cache.TryGetKeywordKind(info.Text, out info.Kind) 137253"];
1256 [label="param TryGetKeywordKind(string key) 137254"];
1257 [label="param TryGetKeywordKind(out SyntaxKind kind) 137255"];
1258 [label="param TryGetKeywordKind(this) 137256"];
1259 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 137257"];
1260 [label="new SyntaxKindEqualityComparer() 137258"];
1261 [label="param SyntaxKindEqualityComparer(this) 137259"];
1262 [label="public static IEqualityComparer<SyntaxKind> EqualityComparer { get; } = new SyntaxKindEqualityComparer(); 137260"];
1263 [label="kind = _keywordKindMap.GetOrMakeValue(key); 137261"];
1264 [label="kind = _keywordKindMap.GetOrMakeValue(key); 137262"];
1265 [label="kind = _keywordKindMap.GetOrMakeValue(key); 137263"];
1266 [label="param GetKeywordKind(string text) 137264"];
1267 [label="switch (text)\n            {\n                case 'bool':\n                    return SyntaxKind.BoolKeyword;\n                case 'byte':\n                    return SyntaxKind.ByteKeyword;\n                case 'sbyte':\n                    return SyntaxKind.SByteKeyword;\n                case 'short':\n                    return SyntaxKind.ShortKeyword;\n                case 'ushort':\n                    return SyntaxKind.UShortKeyword;\n                case 'int':\n                    return SyntaxKind.IntKeyword;\n                case 'uint':\n                    return SyntaxKind.UIntKeyword;\n                case 'long':\n                    return SyntaxKind.LongKeyword;\n                case 'ulong':\n                    return SyntaxKind.ULongKeyword;\n                case 'double':\n                    return SyntaxKind.DoubleKeyword;\n                case 'float':\n                    return SyntaxKind.FloatKeyword;\n                case 'decimal':\n                    return SyntaxKind.DecimalKeyword;\n                case 'string':\n                    return SyntaxKind.StringKeyword;\n                case 'char':\n                    return SyntaxKind.CharKeyword;\n                case 'void':\n                    return SyntaxKind.VoidKeyword;\n                case 'object':\n                    return SyntaxKind.ObjectKeyword;\n                case 'typeof':\n                    return SyntaxKind.TypeOfKeyword;\n                case 'sizeof':\n                    return SyntaxKind.SizeOfKeyword;\n                case 'null':\n                    return SyntaxKind.NullKeyword;\n                case 'true':\n                    return SyntaxKind.TrueKeyword;\n                case 'false':\n                    return SyntaxKind.FalseKeyword;\n                case 'if':\n                    return SyntaxKind.IfKeyword;\n                case 'else':\n                    return SyntaxKind.ElseKeyword;\n                case 'while':\n                    return SyntaxKind.WhileKeyword;\n                case 'for':\n                    return SyntaxKind.ForKeyword;\n                case 'foreach':\n                    return SyntaxKind.ForEachKeyword;\n                case 'do':\n                    return SyntaxKind.DoKeyword;\n                case 'switch':\n                    return SyntaxKind.SwitchKeyword;\n                case 'case':\n                    return SyntaxKind.CaseKeyword;\n                case 'default':\n                    return SyntaxKind.DefaultKeyword;\n                case 'lock':\n                    return SyntaxKind.LockKeyword;\n                case 'try':\n                    return SyntaxKind.TryKeyword;\n                case 'throw':\n                    return SyntaxKind.ThrowKeyword;\n                case 'catch':\n                    return SyntaxKind.CatchKeyword;\n                case 'finally':\n                    return SyntaxKind.FinallyKeyword;\n                case 'goto':\n                    return SyntaxKind.GotoKeyword;\n                case 'break':\n                    return SyntaxKind.BreakKeyword;\n                case 'continue':\n                    return SyntaxKind.ContinueKeyword;\n                case 'return':\n                    return SyntaxKind.ReturnKeyword;\n                case 'public':\n                    return SyntaxKind.PublicKeyword;\n                case 'private':\n                    return SyntaxKind.PrivateKeyword;\n                case 'internal':\n                    return SyntaxKind.InternalKeyword;\n                case 'protected':\n                    return SyntaxKind.ProtectedKeyword;\n                case 'static':\n                    return SyntaxKind.StaticKeyword;\n                case 'readonly':\n                    return SyntaxKind.ReadOnlyKeyword;\n                case 'sealed':\n                    return SyntaxKind.SealedKeyword;\n                case 'const':\n                    return SyntaxKind.ConstKeyword;\n                case 'fixed':\n                    return SyntaxKind.FixedKeyword;\n                case 'stackalloc':\n                    return SyntaxKind.StackAllocKeyword;\n                case 'volatile':\n                    return SyntaxKind.VolatileKeyword;\n                case 'new':\n                    return SyntaxKind.NewKeyword;\n                case 'override':\n                    return SyntaxKind.OverrideKeyword;\n                case 'abstract':\n                    return SyntaxKind.AbstractKeyword;\n                case 'virtual':\n                    return SyntaxKind.VirtualKeyword;\n                case 'event':\n                    return SyntaxKind.EventKeyword;\n                case 'extern':\n                    return SyntaxKind.ExternKeyword;\n                case 'ref':\n                    return SyntaxKind.RefKeyword;\n                case 'out':\n                    return SyntaxKind.OutKeyword;\n                case 'in':\n                    return SyntaxKind.InKeyword;\n                case 'is':\n                    return SyntaxKind.IsKeyword;\n                case 'as':\n                    return SyntaxKind.AsKeyword;\n                case 'params':\n                    return SyntaxKind.ParamsKeyword;\n                case '__arglist':\n                    return SyntaxKind.ArgListKeyword;\n                case '__makeref':\n                    return SyntaxKind.MakeRefKeyword;\n                case '__reftype':\n                    return SyntaxKind.RefTypeKeyword;\n                case '__refvalue':\n                    return SyntaxKind.RefValueKeyword;\n                case 'this':\n                    return SyntaxKind.ThisKeyword;\n                case 'base':\n                    return SyntaxKind.BaseKeyword;\n                case 'namespace':\n                    return SyntaxKind.NamespaceKeyword;\n                case 'using':\n                    return SyntaxKind.UsingKeyword;\n                case 'class':\n                    return SyntaxKind.ClassKeyword;\n                case 'struct':\n                    return SyntaxKind.StructKeyword;\n                case 'interface':\n                    return SyntaxKind.InterfaceKeyword;\n                case 'enum':\n                    return SyntaxKind.EnumKeyword;\n                case 'delegate':\n                    return SyntaxKind.DelegateKeyword;\n                case 'checked':\n                    return SyntaxKind.CheckedKeyword;\n                case 'unchecked':\n                    return SyntaxKind.UncheckedKeyword;\n                case 'unsafe':\n                    return SyntaxKind.UnsafeKeyword;\n                case 'operator':\n                    return SyntaxKind.OperatorKeyword;\n                case 'implicit':\n                    return SyntaxKind.ImplicitKeyword;\n                case 'explicit':\n                    return SyntaxKind.ExplicitKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 137265"];
1268 [label="return SyntaxKind.SwitchKeyword; 137266"];
1269 [label="return kind != SyntaxKind.None; 137267"];
1270 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 137268"];
1271 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 137269"];
1272 [label="param IsContextualKeyword(SyntaxKind kind) 137270"];
1273 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 137271"];
1274 [label="return false; 137272"];
1275 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 137273"];
1276 [label="return true; 137274"];
1277 [label="this.ScanSyntaxToken(ref tokenInfo); 137275"];
1278 [label="var errors = this.GetErrors(GetFullWidth(leading)); 137276"];
1279 [label="GetFullWidth(leading) 137277"];
1280 [label="param GetFullWidth(SyntaxListBuilder builder) 137278"];
1281 [label="int width = 0; 137279"];
1282 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 137280"];
1283 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 137281"];
1284 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 137282"];
1285 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 137283"];
1286 [label="return width; 137284"];
1287 [label="var errors = this.GetErrors(GetFullWidth(leading)); 137285"];
1288 [label="this.GetErrors(GetFullWidth(leading)) 137286"];
1289 [label="param GetErrors(int leadingTriviaWidth) 137287"];
1290 [label="param GetErrors(this) 137288"];
1291 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 137289"];
1292 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 137290"];
1293 [label="return null; 137291"];
1294 [label="var errors = this.GetErrors(GetFullWidth(leading)); 137292"];
1295 [label="_trailingTriviaCache.Clear(); 137293"];
1296 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 137294"];
1297 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 137295"];
1298 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache) 137296"];
1299 [label="param LexSyntaxTrivia(bool afterFirstToken) 137297"];
1300 [label="param LexSyntaxTrivia(bool isTrailing) 137298"];
1301 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 137299"];
1302 [label="param LexSyntaxTrivia(this) 137300"];
1303 [label="bool onlyWhitespaceOnLine = !isTrailing; 137301"];
1304 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 137302"];
1305 [label="this.Start() 137303"];
1306 [label="param Start(this) 137304"];
1307 [label="TextWindow.Start() 137305"];
1308 [label="param Start(this) 137306"];
1309 [label="TextWindow.Start(); 137307"];
1310 [label="_errors = null; 137308"];
1311 [label="_errors 137309"];
1312 [label="this.Start(); 137310"];
1313 [label="TextWindow.PeekChar() 137311"];
1314 [label="param PeekChar(this) 137312"];
1315 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 137313"];
1316 [label="char ch = TextWindow.PeekChar(); 137314"];
1317 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 137315"];
1318 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 137316"];
1319 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 137317"];
1320 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 137318"];
1321 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 137319"];
1322 [label="param AdvanceChar(this) 137320"];
1323 [label="_offset 137321"];
1324 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 137322"];
1325 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 137323"];
1326 [label="return _offset - _lexemeStart; 137324"];
1327 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 137325"];
1328 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList) 137326"];
1329 [label="param AddTrivia(CSharpSyntaxNode trivia) 137327"];
1330 [label="param AddTrivia(ref SyntaxListBuilder list) 137328"];
1331 [label="param AddTrivia(this) 137329"];
1332 [label="this.HasErrors 137330"];
1333 [label="get { return _errors != null; } 137331"];
1334 [label="return _errors != null; 137332"];
1335 [label="return _errors != null; 137333"];
1336 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 137334"];
1337 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 137335"];
1338 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 137336"];
1339 [label="list.Add(trivia); 137337"];
1340 [label="list.Add(trivia); 137338"];
1341 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 137339"];
1342 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 137340"];
1343 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 137341"];
1344 [label="return; 137342"];
1345 [label="var trailing = _trailingTriviaCache; 137343"];
1346 [label="return Create(ref tokenInfo, leading, trailing, errors); 137344"];
1347 [label="return Create(ref tokenInfo, leading, trailing, errors); 137345"];
1348 [label="return Create(ref tokenInfo, leading, trailing, errors); 137346"];
1349 [label="return Create(ref tokenInfo, leading, trailing, errors); 137347"];
1350 [label="Create(ref tokenInfo, leading, trailing, errors) 137348"];
1351 [label="param Create(ref TokenInfo info) 137349"];
1352 [label="param Create(SyntaxListBuilder leading) 137350"];
1353 [label="param Create(SyntaxListBuilder trailing) 137351"];
1354 [label="param Create(SyntaxDiagnosticInfo[] errors) 137352"];
1355 [label="param Create(this) 137353"];
1356 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 137354"];
1357 [label="var leadingNode = leading?.ToListNode(); 137355"];
1358 [label="var trailingNode = trailing?.ToListNode(); 137356"];
1359 [label="SyntaxToken token; 137357"];
1360 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 137358"];
1361 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 137359"];
1362 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 137360"];
1363 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 137361"];
1364 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 137362"];
1365 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 137363"];
1366 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 137364"];
1367 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 137365"];
1368 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 137366"];
1369 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 137367"];
1370 [label="param Token(GreenNode leading) 137368"];
1371 [label="param Token(SyntaxKind kind) 137369"];
1372 [label="param Token(GreenNode trailing) 137370"];
1373 [label="FirstTokenWithWellKnownText = SyntaxKind.TildeToken 137371"];
1374 [label="LastTokenWithWellKnownText = SyntaxKind.EndOfFileToken 137372"];
1375 [label="1 137373"];
1376 [label="(int)LastTokenWithWellKnownText + 1 137374"];
1377 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 137375"];
1378 [label="s_tokensWithNoTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 137376"];
1379 [label="1 137377"];
1380 [label="(int)LastTokenWithWellKnownText + 1 137378"];
1381 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 137379"];
1382 [label="s_tokensWithElasticTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 137380"];
1383 [label="1 137381"];
1384 [label="(int)LastTokenWithWellKnownText + 1 137382"];
1385 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 137383"];
1386 [label="s_tokensWithSingleTrailingSpace = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 137384"];
1387 [label="1 137385"];
1388 [label="(int)LastTokenWithWellKnownText + 1 137386"];
1389 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 137387"];
1390 [label="s_tokensWithSingleTrailingCRLF = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 137388"];
1391 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxToken), r => new SyntaxToken(r)); 137389"];
1392 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 137390"];
1393 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 137391"];
1394 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 137392"];
1395 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 137393"];
1396 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 137394"];
1397 [label="new SyntaxToken(kind) 137395"];
1398 [label="param SyntaxToken(SyntaxKind kind) 137396"];
1399 [label="param SyntaxToken(this) 137397"];
1400 [label="kind 137398"];
1401 [label="param SyntaxToken(this) 137399"];
1402 [label="param CSharpSyntaxNode(SyntaxKind kind) 137400"];
1403 [label="param CSharpSyntaxNode(this) 137401"];
1404 [label="kind 137402"];
1405 [label="param CSharpSyntaxNode(this) 137403"];
1406 [label="param CSharpSyntaxNode(this) 137404"];
1407 [label="GreenStats.NoteGreen(this); 137405"];
1408 [label="GreenStats.NoteGreen(this); 137406"];
1409 [label="this.Text 137407"];
1410 [label="get { return SyntaxFacts.GetText(this.Kind); } 137408"];
1411 [label="this.Kind 137409"];
1412 [label="get { return (SyntaxKind)this.RawKind; } 137410"];
1413 [label="return (SyntaxKind)this.RawKind; 137411"];
1414 [label="return SyntaxFacts.GetText(this.Kind); 137412"];
1415 [label="SyntaxFacts.GetText(this.Kind) 137413"];
1416 [label="param GetText(SyntaxKind kind) 137414"];
1417 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 137415"];
1418 [label="return '~'; 137416"];
1419 [label="FullWidth = this.Text.Length; 137417"];
1420 [label="FullWidth 137418"];
1421 [label="this.flags |= NodeFlags.IsNotMissing; 137419"];
1422 [label="this.flags 137420"];
1423 [label="s_tokensWithNoTrivia[(int)kind].Value 137421"];
1424 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithTrivia), r => new SyntaxTokenWithTrivia(r)); 137422"];
1425 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 137423"];
1426 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 137424"];
1427 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 137425"];
1428 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 137426"];
1429 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 137427"];
1430 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 137428"];
1431 [label="param SyntaxTokenWithTrivia(GreenNode leading) 137429"];
1432 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 137430"];
1433 [label="param SyntaxTokenWithTrivia(this) 137431"];
1434 [label="kind 137432"];
1435 [label="param SyntaxTokenWithTrivia(this) 137433"];
1436 [label="param SyntaxToken(SyntaxKind kind) 137434"];
1437 [label="param SyntaxToken(this) 137435"];
1438 [label="kind 137436"];
1439 [label="param SyntaxToken(this) 137437"];
1440 [label="param CSharpSyntaxNode(SyntaxKind kind) 137438"];
1441 [label="param CSharpSyntaxNode(this) 137439"];
1442 [label="kind 137440"];
1443 [label="param CSharpSyntaxNode(this) 137441"];
1444 [label="param CSharpSyntaxNode(this) 137442"];
1445 [label="GreenStats.NoteGreen(this); 137443"];
1446 [label="GreenStats.NoteGreen(this); 137444"];
1447 [label="this.Text 137445"];
1448 [label="get { return SyntaxFacts.GetText(this.Kind); } 137446"];
1449 [label="this.Kind 137447"];
1450 [label="get { return (SyntaxKind)this.RawKind; } 137448"];
1451 [label="return (SyntaxKind)this.RawKind; 137449"];
1452 [label="return SyntaxFacts.GetText(this.Kind); 137450"];
1453 [label="SyntaxFacts.GetText(this.Kind) 137451"];
1454 [label="param GetText(SyntaxKind kind) 137452"];
1455 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 137453"];
1456 [label="return '~'; 137454"];
1457 [label="FullWidth = this.Text.Length; 137455"];
1458 [label="FullWidth 137456"];
1459 [label="this.flags |= NodeFlags.IsNotMissing; 137457"];
1460 [label="this.flags 137458"];
1461 [label="LeadingField 137459"];
1462 [label="TrailingField 137460"];
1463 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 137461"];
1464 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 137462"];
1465 [label="this.AdjustFlagsAndWidth(leading); 137463"];
1466 [label="this.AdjustFlagsAndWidth(leading); 137464"];
1467 [label="this.LeadingField 137465"];
1468 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 137466"];
1469 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 137467"];
1470 [label="this.AdjustFlagsAndWidth(trailing); 137468"];
1471 [label="this.AdjustFlagsAndWidth(trailing); 137469"];
1472 [label="this.TrailingField 137470"];
1473 [label="s_tokensWithElasticTrivia[(int)kind].Value 137471"];
1474 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 137472"];
1475 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 137473"];
1476 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 137474"];
1477 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 137475"];
1478 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 137476"];
1479 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 137477"];
1480 [label="param SyntaxTokenWithTrivia(GreenNode leading) 137478"];
1481 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 137479"];
1482 [label="param SyntaxTokenWithTrivia(this) 137480"];
1483 [label="kind 137481"];
1484 [label="param SyntaxTokenWithTrivia(this) 137482"];
1485 [label="param SyntaxToken(SyntaxKind kind) 137483"];
1486 [label="param SyntaxToken(this) 137484"];
1487 [label="kind 137485"];
1488 [label="param SyntaxToken(this) 137486"];
1489 [label="param CSharpSyntaxNode(SyntaxKind kind) 137487"];
1490 [label="param CSharpSyntaxNode(this) 137488"];
1491 [label="kind 137489"];
1492 [label="param CSharpSyntaxNode(this) 137490"];
1493 [label="param CSharpSyntaxNode(this) 137491"];
1494 [label="GreenStats.NoteGreen(this); 137492"];
1495 [label="GreenStats.NoteGreen(this); 137493"];
1496 [label="this.Text 137494"];
1497 [label="get { return SyntaxFacts.GetText(this.Kind); } 137495"];
1498 [label="this.Kind 137496"];
1499 [label="get { return (SyntaxKind)this.RawKind; } 137497"];
1500 [label="return (SyntaxKind)this.RawKind; 137498"];
1501 [label="return SyntaxFacts.GetText(this.Kind); 137499"];
1502 [label="SyntaxFacts.GetText(this.Kind) 137500"];
1503 [label="param GetText(SyntaxKind kind) 137501"];
1504 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 137502"];
1505 [label="return '~'; 137503"];
1506 [label="FullWidth = this.Text.Length; 137504"];
1507 [label="FullWidth 137505"];
1508 [label="this.flags |= NodeFlags.IsNotMissing; 137506"];
1509 [label="this.flags 137507"];
1510 [label="LeadingField 137508"];
1511 [label="TrailingField 137509"];
1512 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 137510"];
1513 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 137511"];
1514 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 137512"];
1515 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 137513"];
1516 [label="this.AdjustFlagsAndWidth(trailing); 137514"];
1517 [label="this.AdjustFlagsAndWidth(trailing); 137515"];
1518 [label="this.TrailingField 137516"];
1519 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 137517"];
1520 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 137518"];
1521 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 137519"];
1522 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 137520"];
1523 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 137521"];
1524 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 137522"];
1525 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 137523"];
1526 [label="param SyntaxTokenWithTrivia(GreenNode leading) 137524"];
1527 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 137525"];
1528 [label="param SyntaxTokenWithTrivia(this) 137526"];
1529 [label="kind 137527"];
1530 [label="param SyntaxTokenWithTrivia(this) 137528"];
1531 [label="param SyntaxToken(SyntaxKind kind) 137529"];
1532 [label="param SyntaxToken(this) 137530"];
1533 [label="kind 137531"];
1534 [label="param SyntaxToken(this) 137532"];
1535 [label="param CSharpSyntaxNode(SyntaxKind kind) 137533"];
1536 [label="param CSharpSyntaxNode(this) 137534"];
1537 [label="kind 137535"];
1538 [label="param CSharpSyntaxNode(this) 137536"];
1539 [label="param CSharpSyntaxNode(this) 137537"];
1540 [label="GreenStats.NoteGreen(this); 137538"];
1541 [label="GreenStats.NoteGreen(this); 137539"];
1542 [label="this.Text 137540"];
1543 [label="get { return SyntaxFacts.GetText(this.Kind); } 137541"];
1544 [label="this.Kind 137542"];
1545 [label="get { return (SyntaxKind)this.RawKind; } 137543"];
1546 [label="return (SyntaxKind)this.RawKind; 137544"];
1547 [label="return SyntaxFacts.GetText(this.Kind); 137545"];
1548 [label="SyntaxFacts.GetText(this.Kind) 137546"];
1549 [label="param GetText(SyntaxKind kind) 137547"];
1550 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 137548"];
1551 [label="return '~'; 137549"];
1552 [label="FullWidth = this.Text.Length; 137550"];
1553 [label="FullWidth 137551"];
1554 [label="this.flags |= NodeFlags.IsNotMissing; 137552"];
1555 [label="this.flags 137553"];
1556 [label="LeadingField 137554"];
1557 [label="TrailingField 137555"];
1558 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 137556"];
1559 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 137557"];
1560 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 137558"];
1561 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 137559"];
1562 [label="this.AdjustFlagsAndWidth(trailing); 137560"];
1563 [label="this.AdjustFlagsAndWidth(trailing); 137561"];
1564 [label="this.TrailingField 137562"];
1565 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 137563"];
1566 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 137564"];
1567 [label="param SyntaxToken(SyntaxKind kind) 137565"];
1568 [label="kind 137566"];
1569 [label="param CSharpSyntaxNode(SyntaxKind kind) 137567"];
1570 [label="kind 137568"];
1571 [label="param CSharpSyntaxNode(this) 137569"];
1572 [label="GreenStats.NoteGreen(this); 137570"];
1573 [label="return (SyntaxKind)this.RawKind; 137571"];
1574 [label="return SyntaxFacts.GetText(this.Kind); 137572"];
1575 [label="param GetText(SyntaxKind kind) 137573"];
1576 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 137574"];
1577 [label="return '!'; 137575"];
1578 [label="FullWidth = this.Text.Length; 137576"];
1579 [label="FullWidth 137577"];
1580 [label="this.flags |= NodeFlags.IsNotMissing; 137578"];
1581 [label="this.flags 137579"];
1582 [label="s_tokensWithNoTrivia[(int)kind].Value 137580"];
1583 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 137581"];
1584 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 137582"];
1585 [label="kind 137583"];
1586 [label="param SyntaxToken(SyntaxKind kind) 137584"];
1587 [label="kind 137585"];
1588 [label="param CSharpSyntaxNode(SyntaxKind kind) 137586"];
1589 [label="kind 137587"];
1590 [label="param CSharpSyntaxNode(this) 137588"];
1591 [label="GreenStats.NoteGreen(this); 137589"];
1592 [label="return (SyntaxKind)this.RawKind; 137590"];
1593 [label="return SyntaxFacts.GetText(this.Kind); 137591"];
1594 [label="param GetText(SyntaxKind kind) 137592"];
1595 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 137593"];
1596 [label="return '!'; 137594"];
1597 [label="FullWidth = this.Text.Length; 137595"];
1598 [label="FullWidth 137596"];
1599 [label="this.flags |= NodeFlags.IsNotMissing; 137597"];
1600 [label="this.flags 137598"];
1601 [label="this.AdjustFlagsAndWidth(leading); 137599"];
1602 [label="s_tokensWithElasticTrivia[(int)kind].Value 137600"];
1603 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 137601"];
1604 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 137602"];
1605 [label="kind 137603"];
1606 [label="param SyntaxToken(SyntaxKind kind) 137604"];
1607 [label="kind 137605"];
1608 [label="param CSharpSyntaxNode(SyntaxKind kind) 137606"];
1609 [label="kind 137607"];
1610 [label="param CSharpSyntaxNode(this) 137608"];
1611 [label="GreenStats.NoteGreen(this); 137609"];
1612 [label="return (SyntaxKind)this.RawKind; 137610"];
1613 [label="return SyntaxFacts.GetText(this.Kind); 137611"];
1614 [label="param GetText(SyntaxKind kind) 137612"];
1615 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 137613"];
1616 [label="return '!'; 137614"];
1617 [label="FullWidth = this.Text.Length; 137615"];
1618 [label="FullWidth 137616"];
1619 [label="this.flags |= NodeFlags.IsNotMissing; 137617"];
1620 [label="this.flags 137618"];
1621 [label="this.AdjustFlagsAndWidth(trailing); 137619"];
1622 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 137620"];
1623 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 137621"];
1624 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 137622"];
1625 [label="kind 137623"];
1626 [label="param SyntaxToken(SyntaxKind kind) 137624"];
1627 [label="kind 137625"];
1628 [label="param CSharpSyntaxNode(SyntaxKind kind) 137626"];
1629 [label="kind 137627"];
1630 [label="param CSharpSyntaxNode(this) 137628"];
1631 [label="GreenStats.NoteGreen(this); 137629"];
1632 [label="return (SyntaxKind)this.RawKind; 137630"];
1633 [label="return SyntaxFacts.GetText(this.Kind); 137631"];
1634 [label="param GetText(SyntaxKind kind) 137632"];
1635 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 137633"];
1636 [label="return '!'; 137634"];
1637 [label="FullWidth = this.Text.Length; 137635"];
1638 [label="FullWidth 137636"];
1639 [label="this.flags |= NodeFlags.IsNotMissing; 137637"];
1640 [label="this.flags 137638"];
1641 [label="this.AdjustFlagsAndWidth(trailing); 137639"];
1642 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 137640"];
1643 [label="return '$'; 137641"];
1644 [label="FullWidth = this.Text.Length; 137642"];
1645 [label="FullWidth 137643"];
1646 [label="return '$'; 137644"];
1647 [label="FullWidth = this.Text.Length; 137645"];
1648 [label="FullWidth 137646"];
1649 [label="this.AdjustFlagsAndWidth(leading); 137647"];
1650 [label="return '$'; 137648"];
1651 [label="FullWidth = this.Text.Length; 137649"];
1652 [label="FullWidth 137650"];
1653 [label="this.AdjustFlagsAndWidth(trailing); 137651"];
1654 [label="return '$'; 137652"];
1655 [label="FullWidth = this.Text.Length; 137653"];
1656 [label="FullWidth 137654"];
1657 [label="this.AdjustFlagsAndWidth(trailing); 137655"];
1658 [label="return '%'; 137656"];
1659 [label="FullWidth = this.Text.Length; 137657"];
1660 [label="FullWidth 137658"];
1661 [label="return '%'; 137659"];
1662 [label="FullWidth = this.Text.Length; 137660"];
1663 [label="FullWidth 137661"];
1664 [label="this.AdjustFlagsAndWidth(leading); 137662"];
1665 [label="return '%'; 137663"];
1666 [label="FullWidth = this.Text.Length; 137664"];
1667 [label="FullWidth 137665"];
1668 [label="this.AdjustFlagsAndWidth(trailing); 137666"];
1669 [label="return '%'; 137667"];
1670 [label="FullWidth = this.Text.Length; 137668"];
1671 [label="FullWidth 137669"];
1672 [label="this.AdjustFlagsAndWidth(trailing); 137670"];
1673 [label="return '^'; 137671"];
1674 [label="FullWidth = this.Text.Length; 137672"];
1675 [label="FullWidth 137673"];
1676 [label="return '^'; 137674"];
1677 [label="FullWidth = this.Text.Length; 137675"];
1678 [label="FullWidth 137676"];
1679 [label="this.AdjustFlagsAndWidth(leading); 137677"];
1680 [label="return '^'; 137678"];
1681 [label="FullWidth = this.Text.Length; 137679"];
1682 [label="FullWidth 137680"];
1683 [label="this.AdjustFlagsAndWidth(trailing); 137681"];
1684 [label="return '^'; 137682"];
1685 [label="FullWidth = this.Text.Length; 137683"];
1686 [label="FullWidth 137684"];
1687 [label="this.AdjustFlagsAndWidth(trailing); 137685"];
1688 [label="return '&'; 137686"];
1689 [label="FullWidth = this.Text.Length; 137687"];
1690 [label="FullWidth 137688"];
1691 [label="return '&'; 137689"];
1692 [label="FullWidth = this.Text.Length; 137690"];
1693 [label="FullWidth 137691"];
1694 [label="this.AdjustFlagsAndWidth(leading); 137692"];
1695 [label="return '&'; 137693"];
1696 [label="FullWidth = this.Text.Length; 137694"];
1697 [label="FullWidth 137695"];
1698 [label="this.AdjustFlagsAndWidth(trailing); 137696"];
1699 [label="return '&'; 137697"];
1700 [label="FullWidth = this.Text.Length; 137698"];
1701 [label="FullWidth 137699"];
1702 [label="this.AdjustFlagsAndWidth(trailing); 137700"];
1703 [label="return '*'; 137701"];
1704 [label="FullWidth = this.Text.Length; 137702"];
1705 [label="FullWidth 137703"];
1706 [label="return '*'; 137704"];
1707 [label="FullWidth = this.Text.Length; 137705"];
1708 [label="FullWidth 137706"];
1709 [label="this.AdjustFlagsAndWidth(leading); 137707"];
1710 [label="return '*'; 137708"];
1711 [label="FullWidth = this.Text.Length; 137709"];
1712 [label="FullWidth 137710"];
1713 [label="this.AdjustFlagsAndWidth(trailing); 137711"];
1714 [label="return '*'; 137712"];
1715 [label="FullWidth = this.Text.Length; 137713"];
1716 [label="FullWidth 137714"];
1717 [label="this.AdjustFlagsAndWidth(trailing); 137715"];
1718 [label="return '('; 137716"];
1719 [label="FullWidth = this.Text.Length; 137717"];
1720 [label="FullWidth 137718"];
1721 [label="return '('; 137719"];
1722 [label="FullWidth = this.Text.Length; 137720"];
1723 [label="FullWidth 137721"];
1724 [label="this.AdjustFlagsAndWidth(leading); 137722"];
1725 [label="return '('; 137723"];
1726 [label="FullWidth = this.Text.Length; 137724"];
1727 [label="FullWidth 137725"];
1728 [label="this.AdjustFlagsAndWidth(trailing); 137726"];
1729 [label="return '('; 137727"];
1730 [label="FullWidth = this.Text.Length; 137728"];
1731 [label="FullWidth 137729"];
1732 [label="this.AdjustFlagsAndWidth(trailing); 137730"];
1733 [label="return ')'; 137731"];
1734 [label="FullWidth = this.Text.Length; 137732"];
1735 [label="FullWidth 137733"];
1736 [label="return ')'; 137734"];
1737 [label="FullWidth = this.Text.Length; 137735"];
1738 [label="FullWidth 137736"];
1739 [label="this.AdjustFlagsAndWidth(leading); 137737"];
1740 [label="return ')'; 137738"];
1741 [label="FullWidth = this.Text.Length; 137739"];
1742 [label="FullWidth 137740"];
1743 [label="this.AdjustFlagsAndWidth(trailing); 137741"];
1744 [label="return ')'; 137742"];
1745 [label="FullWidth = this.Text.Length; 137743"];
1746 [label="FullWidth 137744"];
1747 [label="this.AdjustFlagsAndWidth(trailing); 137745"];
1748 [label="return '-'; 137746"];
1749 [label="FullWidth = this.Text.Length; 137747"];
1750 [label="FullWidth 137748"];
1751 [label="return '-'; 137749"];
1752 [label="FullWidth = this.Text.Length; 137750"];
1753 [label="FullWidth 137751"];
1754 [label="this.AdjustFlagsAndWidth(leading); 137752"];
1755 [label="return '-'; 137753"];
1756 [label="FullWidth = this.Text.Length; 137754"];
1757 [label="FullWidth 137755"];
1758 [label="this.AdjustFlagsAndWidth(trailing); 137756"];
1759 [label="return '-'; 137757"];
1760 [label="FullWidth = this.Text.Length; 137758"];
1761 [label="FullWidth 137759"];
1762 [label="this.AdjustFlagsAndWidth(trailing); 137760"];
1763 [label="return '+'; 137761"];
1764 [label="FullWidth = this.Text.Length; 137762"];
1765 [label="FullWidth 137763"];
1766 [label="return '+'; 137764"];
1767 [label="FullWidth = this.Text.Length; 137765"];
1768 [label="FullWidth 137766"];
1769 [label="this.AdjustFlagsAndWidth(leading); 137767"];
1770 [label="return '+'; 137768"];
1771 [label="FullWidth = this.Text.Length; 137769"];
1772 [label="FullWidth 137770"];
1773 [label="this.AdjustFlagsAndWidth(trailing); 137771"];
1774 [label="return '+'; 137772"];
1775 [label="FullWidth = this.Text.Length; 137773"];
1776 [label="FullWidth 137774"];
1777 [label="this.AdjustFlagsAndWidth(trailing); 137775"];
1778 [label="return '='; 137776"];
1779 [label="FullWidth = this.Text.Length; 137777"];
1780 [label="FullWidth 137778"];
1781 [label="return '='; 137779"];
1782 [label="FullWidth = this.Text.Length; 137780"];
1783 [label="FullWidth 137781"];
1784 [label="this.AdjustFlagsAndWidth(leading); 137782"];
1785 [label="return '='; 137783"];
1786 [label="FullWidth = this.Text.Length; 137784"];
1787 [label="FullWidth 137785"];
1788 [label="this.AdjustFlagsAndWidth(trailing); 137786"];
1789 [label="return '='; 137787"];
1790 [label="FullWidth = this.Text.Length; 137788"];
1791 [label="FullWidth 137789"];
1792 [label="this.AdjustFlagsAndWidth(trailing); 137790"];
1793 [label="return '{'; 137791"];
1794 [label="FullWidth = this.Text.Length; 137792"];
1795 [label="FullWidth 137793"];
1796 [label="return '{'; 137794"];
1797 [label="FullWidth = this.Text.Length; 137795"];
1798 [label="FullWidth 137796"];
1799 [label="this.AdjustFlagsAndWidth(leading); 137797"];
1800 [label="return '{'; 137798"];
1801 [label="FullWidth = this.Text.Length; 137799"];
1802 [label="FullWidth 137800"];
1803 [label="this.AdjustFlagsAndWidth(trailing); 137801"];
1804 [label="return '{'; 137802"];
1805 [label="FullWidth = this.Text.Length; 137803"];
1806 [label="FullWidth 137804"];
1807 [label="this.AdjustFlagsAndWidth(trailing); 137805"];
1808 [label="return '}'; 137806"];
1809 [label="FullWidth = this.Text.Length; 137807"];
1810 [label="FullWidth 137808"];
1811 [label="return '}'; 137809"];
1812 [label="FullWidth = this.Text.Length; 137810"];
1813 [label="FullWidth 137811"];
1814 [label="this.AdjustFlagsAndWidth(leading); 137812"];
1815 [label="return '}'; 137813"];
1816 [label="FullWidth = this.Text.Length; 137814"];
1817 [label="FullWidth 137815"];
1818 [label="this.AdjustFlagsAndWidth(trailing); 137816"];
1819 [label="return '}'; 137817"];
1820 [label="FullWidth = this.Text.Length; 137818"];
1821 [label="FullWidth 137819"];
1822 [label="this.AdjustFlagsAndWidth(trailing); 137820"];
1823 [label="return '['; 137821"];
1824 [label="FullWidth = this.Text.Length; 137822"];
1825 [label="FullWidth 137823"];
1826 [label="return '['; 137824"];
1827 [label="FullWidth = this.Text.Length; 137825"];
1828 [label="FullWidth 137826"];
1829 [label="this.AdjustFlagsAndWidth(leading); 137827"];
1830 [label="return '['; 137828"];
1831 [label="FullWidth = this.Text.Length; 137829"];
1832 [label="FullWidth 137830"];
1833 [label="this.AdjustFlagsAndWidth(trailing); 137831"];
1834 [label="return '['; 137832"];
1835 [label="FullWidth = this.Text.Length; 137833"];
1836 [label="FullWidth 137834"];
1837 [label="this.AdjustFlagsAndWidth(trailing); 137835"];
1838 [label="return ']'; 137836"];
1839 [label="FullWidth = this.Text.Length; 137837"];
1840 [label="FullWidth 137838"];
1841 [label="return ']'; 137839"];
1842 [label="FullWidth = this.Text.Length; 137840"];
1843 [label="FullWidth 137841"];
1844 [label="this.AdjustFlagsAndWidth(leading); 137842"];
1845 [label="return ']'; 137843"];
1846 [label="FullWidth = this.Text.Length; 137844"];
1847 [label="FullWidth 137845"];
1848 [label="this.AdjustFlagsAndWidth(trailing); 137846"];
1849 [label="return ']'; 137847"];
1850 [label="FullWidth = this.Text.Length; 137848"];
1851 [label="FullWidth 137849"];
1852 [label="this.AdjustFlagsAndWidth(trailing); 137850"];
1853 [label="return '|'; 137851"];
1854 [label="FullWidth = this.Text.Length; 137852"];
1855 [label="FullWidth 137853"];
1856 [label="return '|'; 137854"];
1857 [label="FullWidth = this.Text.Length; 137855"];
1858 [label="FullWidth 137856"];
1859 [label="this.AdjustFlagsAndWidth(leading); 137857"];
1860 [label="return '|'; 137858"];
1861 [label="FullWidth = this.Text.Length; 137859"];
1862 [label="FullWidth 137860"];
1863 [label="this.AdjustFlagsAndWidth(trailing); 137861"];
1864 [label="return '|'; 137862"];
1865 [label="FullWidth = this.Text.Length; 137863"];
1866 [label="FullWidth 137864"];
1867 [label="this.AdjustFlagsAndWidth(trailing); 137865"];
1868 [label="return '\\\\'; 137866"];
1869 [label="FullWidth = this.Text.Length; 137867"];
1870 [label="FullWidth 137868"];
1871 [label="return '\\\\'; 137869"];
1872 [label="FullWidth = this.Text.Length; 137870"];
1873 [label="FullWidth 137871"];
1874 [label="this.AdjustFlagsAndWidth(leading); 137872"];
1875 [label="return '\\\\'; 137873"];
1876 [label="FullWidth = this.Text.Length; 137874"];
1877 [label="FullWidth 137875"];
1878 [label="this.AdjustFlagsAndWidth(trailing); 137876"];
1879 [label="return '\\\\'; 137877"];
1880 [label="FullWidth = this.Text.Length; 137878"];
1881 [label="FullWidth 137879"];
1882 [label="this.AdjustFlagsAndWidth(trailing); 137880"];
1883 [label="return ':'; 137881"];
1884 [label="FullWidth = this.Text.Length; 137882"];
1885 [label="FullWidth 137883"];
1886 [label="return ':'; 137884"];
1887 [label="FullWidth = this.Text.Length; 137885"];
1888 [label="FullWidth 137886"];
1889 [label="this.AdjustFlagsAndWidth(leading); 137887"];
1890 [label="return ':'; 137888"];
1891 [label="FullWidth = this.Text.Length; 137889"];
1892 [label="FullWidth 137890"];
1893 [label="this.AdjustFlagsAndWidth(trailing); 137891"];
1894 [label="return ':'; 137892"];
1895 [label="FullWidth = this.Text.Length; 137893"];
1896 [label="FullWidth 137894"];
1897 [label="this.AdjustFlagsAndWidth(trailing); 137895"];
1898 [label="return ';'; 137896"];
1899 [label="FullWidth = this.Text.Length; 137897"];
1900 [label="FullWidth 137898"];
1901 [label="return ';'; 137899"];
1902 [label="FullWidth = this.Text.Length; 137900"];
1903 [label="FullWidth 137901"];
1904 [label="this.AdjustFlagsAndWidth(leading); 137902"];
1905 [label="return ';'; 137903"];
1906 [label="FullWidth = this.Text.Length; 137904"];
1907 [label="FullWidth 137905"];
1908 [label="this.AdjustFlagsAndWidth(trailing); 137906"];
1909 [label="return ';'; 137907"];
1910 [label="FullWidth = this.Text.Length; 137908"];
1911 [label="FullWidth 137909"];
1912 [label="this.AdjustFlagsAndWidth(trailing); 137910"];
1913 [label="return '\\''; 137911"];
1914 [label="FullWidth = this.Text.Length; 137912"];
1915 [label="FullWidth 137913"];
1916 [label="return '\\''; 137914"];
1917 [label="FullWidth = this.Text.Length; 137915"];
1918 [label="FullWidth 137916"];
1919 [label="this.AdjustFlagsAndWidth(leading); 137917"];
1920 [label="return '\\''; 137918"];
1921 [label="FullWidth = this.Text.Length; 137919"];
1922 [label="FullWidth 137920"];
1923 [label="this.AdjustFlagsAndWidth(trailing); 137921"];
1924 [label="return '\\''; 137922"];
1925 [label="FullWidth = this.Text.Length; 137923"];
1926 [label="FullWidth 137924"];
1927 [label="this.AdjustFlagsAndWidth(trailing); 137925"];
1928 [label="return '''; 137926"];
1929 [label="FullWidth = this.Text.Length; 137927"];
1930 [label="FullWidth 137928"];
1931 [label="return '''; 137929"];
1932 [label="FullWidth = this.Text.Length; 137930"];
1933 [label="FullWidth 137931"];
1934 [label="this.AdjustFlagsAndWidth(leading); 137932"];
1935 [label="return '''; 137933"];
1936 [label="FullWidth = this.Text.Length; 137934"];
1937 [label="FullWidth 137935"];
1938 [label="this.AdjustFlagsAndWidth(trailing); 137936"];
1939 [label="return '''; 137937"];
1940 [label="FullWidth = this.Text.Length; 137938"];
1941 [label="FullWidth 137939"];
1942 [label="this.AdjustFlagsAndWidth(trailing); 137940"];
1943 [label="return '<'; 137941"];
1944 [label="FullWidth = this.Text.Length; 137942"];
1945 [label="FullWidth 137943"];
1946 [label="return '<'; 137944"];
1947 [label="FullWidth = this.Text.Length; 137945"];
1948 [label="FullWidth 137946"];
1949 [label="this.AdjustFlagsAndWidth(leading); 137947"];
1950 [label="return '<'; 137948"];
1951 [label="FullWidth = this.Text.Length; 137949"];
1952 [label="FullWidth 137950"];
1953 [label="this.AdjustFlagsAndWidth(trailing); 137951"];
1954 [label="return '<'; 137952"];
1955 [label="FullWidth = this.Text.Length; 137953"];
1956 [label="FullWidth 137954"];
1957 [label="this.AdjustFlagsAndWidth(trailing); 137955"];
1958 [label="return ','; 137956"];
1959 [label="FullWidth = this.Text.Length; 137957"];
1960 [label="FullWidth 137958"];
1961 [label="return ','; 137959"];
1962 [label="FullWidth = this.Text.Length; 137960"];
1963 [label="FullWidth 137961"];
1964 [label="this.AdjustFlagsAndWidth(leading); 137962"];
1965 [label="return ','; 137963"];
1966 [label="FullWidth = this.Text.Length; 137964"];
1967 [label="FullWidth 137965"];
1968 [label="this.AdjustFlagsAndWidth(trailing); 137966"];
1969 [label="return ','; 137967"];
1970 [label="FullWidth = this.Text.Length; 137968"];
1971 [label="FullWidth 137969"];
1972 [label="this.AdjustFlagsAndWidth(trailing); 137970"];
1973 [label="return '>'; 137971"];
1974 [label="FullWidth = this.Text.Length; 137972"];
1975 [label="FullWidth 137973"];
1976 [label="return '>'; 137974"];
1977 [label="FullWidth = this.Text.Length; 137975"];
1978 [label="FullWidth 137976"];
1979 [label="this.AdjustFlagsAndWidth(leading); 137977"];
1980 [label="return '>'; 137978"];
1981 [label="FullWidth = this.Text.Length; 137979"];
1982 [label="FullWidth 137980"];
1983 [label="this.AdjustFlagsAndWidth(trailing); 137981"];
1984 [label="return '>'; 137982"];
1985 [label="FullWidth = this.Text.Length; 137983"];
1986 [label="FullWidth 137984"];
1987 [label="this.AdjustFlagsAndWidth(trailing); 137985"];
1988 [label="return '.'; 137986"];
1989 [label="FullWidth = this.Text.Length; 137987"];
1990 [label="FullWidth 137988"];
1991 [label="return '.'; 137989"];
1992 [label="FullWidth = this.Text.Length; 137990"];
1993 [label="FullWidth 137991"];
1994 [label="this.AdjustFlagsAndWidth(leading); 137992"];
1995 [label="return '.'; 137993"];
1996 [label="FullWidth = this.Text.Length; 137994"];
1997 [label="FullWidth 137995"];
1998 [label="this.AdjustFlagsAndWidth(trailing); 137996"];
1999 [label="return '.'; 137997"];
2000 [label="FullWidth = this.Text.Length; 137998"];
2001 [label="FullWidth 137999"];
2002 [label="this.AdjustFlagsAndWidth(trailing); 138000"];
2003 [label="return '?'; 138001"];
2004 [label="FullWidth = this.Text.Length; 138002"];
2005 [label="FullWidth 138003"];
2006 [label="return '?'; 138004"];
2007 [label="FullWidth = this.Text.Length; 138005"];
2008 [label="FullWidth 138006"];
2009 [label="this.AdjustFlagsAndWidth(leading); 138007"];
2010 [label="return '?'; 138008"];
2011 [label="FullWidth = this.Text.Length; 138009"];
2012 [label="FullWidth 138010"];
2013 [label="this.AdjustFlagsAndWidth(trailing); 138011"];
2014 [label="return '?'; 138012"];
2015 [label="FullWidth = this.Text.Length; 138013"];
2016 [label="FullWidth 138014"];
2017 [label="this.AdjustFlagsAndWidth(trailing); 138015"];
2018 [label="return '#'; 138016"];
2019 [label="FullWidth = this.Text.Length; 138017"];
2020 [label="FullWidth 138018"];
2021 [label="return '#'; 138019"];
2022 [label="FullWidth = this.Text.Length; 138020"];
2023 [label="FullWidth 138021"];
2024 [label="this.AdjustFlagsAndWidth(leading); 138022"];
2025 [label="return '#'; 138023"];
2026 [label="FullWidth = this.Text.Length; 138024"];
2027 [label="FullWidth 138025"];
2028 [label="this.AdjustFlagsAndWidth(trailing); 138026"];
2029 [label="return '#'; 138027"];
2030 [label="FullWidth = this.Text.Length; 138028"];
2031 [label="FullWidth 138029"];
2032 [label="this.AdjustFlagsAndWidth(trailing); 138030"];
2033 [label="return '/'; 138031"];
2034 [label="FullWidth = this.Text.Length; 138032"];
2035 [label="FullWidth 138033"];
2036 [label="return '/'; 138034"];
2037 [label="FullWidth = this.Text.Length; 138035"];
2038 [label="FullWidth 138036"];
2039 [label="this.AdjustFlagsAndWidth(leading); 138037"];
2040 [label="return '/'; 138038"];
2041 [label="FullWidth = this.Text.Length; 138039"];
2042 [label="FullWidth 138040"];
2043 [label="this.AdjustFlagsAndWidth(trailing); 138041"];
2044 [label="return '/'; 138042"];
2045 [label="FullWidth = this.Text.Length; 138043"];
2046 [label="FullWidth 138044"];
2047 [label="this.AdjustFlagsAndWidth(trailing); 138045"];
2048 [label="return '..'; 138046"];
2049 [label="FullWidth = this.Text.Length; 138047"];
2050 [label="FullWidth 138048"];
2051 [label="return '..'; 138049"];
2052 [label="FullWidth = this.Text.Length; 138050"];
2053 [label="FullWidth 138051"];
2054 [label="this.AdjustFlagsAndWidth(leading); 138052"];
2055 [label="return '..'; 138053"];
2056 [label="FullWidth = this.Text.Length; 138054"];
2057 [label="FullWidth 138055"];
2058 [label="this.AdjustFlagsAndWidth(trailing); 138056"];
2059 [label="return '..'; 138057"];
2060 [label="FullWidth = this.Text.Length; 138058"];
2061 [label="FullWidth 138059"];
2062 [label="this.AdjustFlagsAndWidth(trailing); 138060"];
2063 [label="return string.Empty; 138061"];
2064 [label="FullWidth = this.Text.Length; 138062"];
2065 [label="FullWidth 138063"];
2066 [label="return string.Empty; 138064"];
2067 [label="FullWidth = this.Text.Length; 138065"];
2068 [label="FullWidth 138066"];
2069 [label="this.AdjustFlagsAndWidth(leading); 138067"];
2070 [label="return string.Empty; 138068"];
2071 [label="FullWidth = this.Text.Length; 138069"];
2072 [label="FullWidth 138070"];
2073 [label="this.AdjustFlagsAndWidth(trailing); 138071"];
2074 [label="return string.Empty; 138072"];
2075 [label="FullWidth = this.Text.Length; 138073"];
2076 [label="FullWidth 138074"];
2077 [label="this.AdjustFlagsAndWidth(trailing); 138075"];
2078 [label="return '/>'; 138076"];
2079 [label="FullWidth = this.Text.Length; 138077"];
2080 [label="FullWidth 138078"];
2081 [label="return '/>'; 138079"];
2082 [label="FullWidth = this.Text.Length; 138080"];
2083 [label="FullWidth 138081"];
2084 [label="this.AdjustFlagsAndWidth(leading); 138082"];
2085 [label="return '/>'; 138083"];
2086 [label="FullWidth = this.Text.Length; 138084"];
2087 [label="FullWidth 138085"];
2088 [label="this.AdjustFlagsAndWidth(trailing); 138086"];
2089 [label="return '/>'; 138087"];
2090 [label="FullWidth = this.Text.Length; 138088"];
2091 [label="FullWidth 138089"];
2092 [label="this.AdjustFlagsAndWidth(trailing); 138090"];
2093 [label="return '</'; 138091"];
2094 [label="FullWidth = this.Text.Length; 138092"];
2095 [label="FullWidth 138093"];
2096 [label="return '</'; 138094"];
2097 [label="FullWidth = this.Text.Length; 138095"];
2098 [label="FullWidth 138096"];
2099 [label="this.AdjustFlagsAndWidth(leading); 138097"];
2100 [label="return '</'; 138098"];
2101 [label="FullWidth = this.Text.Length; 138099"];
2102 [label="FullWidth 138100"];
2103 [label="this.AdjustFlagsAndWidth(trailing); 138101"];
2104 [label="return '</'; 138102"];
2105 [label="FullWidth = this.Text.Length; 138103"];
2106 [label="FullWidth 138104"];
2107 [label="this.AdjustFlagsAndWidth(trailing); 138105"];
2108 [label="return '<!--'; 138106"];
2109 [label="FullWidth = this.Text.Length; 138107"];
2110 [label="FullWidth 138108"];
2111 [label="return '<!--'; 138109"];
2112 [label="FullWidth = this.Text.Length; 138110"];
2113 [label="FullWidth 138111"];
2114 [label="this.AdjustFlagsAndWidth(leading); 138112"];
2115 [label="return '<!--'; 138113"];
2116 [label="FullWidth = this.Text.Length; 138114"];
2117 [label="FullWidth 138115"];
2118 [label="this.AdjustFlagsAndWidth(trailing); 138116"];
2119 [label="return '<!--'; 138117"];
2120 [label="FullWidth = this.Text.Length; 138118"];
2121 [label="FullWidth 138119"];
2122 [label="this.AdjustFlagsAndWidth(trailing); 138120"];
2123 [label="return '-->'; 138121"];
2124 [label="FullWidth = this.Text.Length; 138122"];
2125 [label="FullWidth 138123"];
2126 [label="return '-->'; 138124"];
2127 [label="FullWidth = this.Text.Length; 138125"];
2128 [label="FullWidth 138126"];
2129 [label="this.AdjustFlagsAndWidth(leading); 138127"];
2130 [label="return '-->'; 138128"];
2131 [label="FullWidth = this.Text.Length; 138129"];
2132 [label="FullWidth 138130"];
2133 [label="this.AdjustFlagsAndWidth(trailing); 138131"];
2134 [label="return '-->'; 138132"];
2135 [label="FullWidth = this.Text.Length; 138133"];
2136 [label="FullWidth 138134"];
2137 [label="this.AdjustFlagsAndWidth(trailing); 138135"];
2138 [label="return '<![CDATA['; 138136"];
2139 [label="FullWidth = this.Text.Length; 138137"];
2140 [label="FullWidth 138138"];
2141 [label="return '<![CDATA['; 138139"];
2142 [label="FullWidth = this.Text.Length; 138140"];
2143 [label="FullWidth 138141"];
2144 [label="this.AdjustFlagsAndWidth(leading); 138142"];
2145 [label="return '<![CDATA['; 138143"];
2146 [label="FullWidth = this.Text.Length; 138144"];
2147 [label="FullWidth 138145"];
2148 [label="this.AdjustFlagsAndWidth(trailing); 138146"];
2149 [label="return '<![CDATA['; 138147"];
2150 [label="FullWidth = this.Text.Length; 138148"];
2151 [label="FullWidth 138149"];
2152 [label="this.AdjustFlagsAndWidth(trailing); 138150"];
2153 [label="return ']]>'; 138151"];
2154 [label="FullWidth = this.Text.Length; 138152"];
2155 [label="FullWidth 138153"];
2156 [label="return ']]>'; 138154"];
2157 [label="FullWidth = this.Text.Length; 138155"];
2158 [label="FullWidth 138156"];
2159 [label="this.AdjustFlagsAndWidth(leading); 138157"];
2160 [label="return ']]>'; 138158"];
2161 [label="FullWidth = this.Text.Length; 138159"];
2162 [label="FullWidth 138160"];
2163 [label="this.AdjustFlagsAndWidth(trailing); 138161"];
2164 [label="return ']]>'; 138162"];
2165 [label="FullWidth = this.Text.Length; 138163"];
2166 [label="FullWidth 138164"];
2167 [label="this.AdjustFlagsAndWidth(trailing); 138165"];
2168 [label="return '<?'; 138166"];
2169 [label="FullWidth = this.Text.Length; 138167"];
2170 [label="FullWidth 138168"];
2171 [label="return '<?'; 138169"];
2172 [label="FullWidth = this.Text.Length; 138170"];
2173 [label="FullWidth 138171"];
2174 [label="this.AdjustFlagsAndWidth(leading); 138172"];
2175 [label="return '<?'; 138173"];
2176 [label="FullWidth = this.Text.Length; 138174"];
2177 [label="FullWidth 138175"];
2178 [label="this.AdjustFlagsAndWidth(trailing); 138176"];
2179 [label="return '<?'; 138177"];
2180 [label="FullWidth = this.Text.Length; 138178"];
2181 [label="FullWidth 138179"];
2182 [label="this.AdjustFlagsAndWidth(trailing); 138180"];
2183 [label="return '?>'; 138181"];
2184 [label="FullWidth = this.Text.Length; 138182"];
2185 [label="FullWidth 138183"];
2186 [label="return '?>'; 138184"];
2187 [label="FullWidth = this.Text.Length; 138185"];
2188 [label="FullWidth 138186"];
2189 [label="this.AdjustFlagsAndWidth(leading); 138187"];
2190 [label="return '?>'; 138188"];
2191 [label="FullWidth = this.Text.Length; 138189"];
2192 [label="FullWidth 138190"];
2193 [label="this.AdjustFlagsAndWidth(trailing); 138191"];
2194 [label="return '?>'; 138192"];
2195 [label="FullWidth = this.Text.Length; 138193"];
2196 [label="FullWidth 138194"];
2197 [label="this.AdjustFlagsAndWidth(trailing); 138195"];
2198 [label="return '||'; 138196"];
2199 [label="FullWidth = this.Text.Length; 138197"];
2200 [label="FullWidth 138198"];
2201 [label="return '||'; 138199"];
2202 [label="FullWidth = this.Text.Length; 138200"];
2203 [label="FullWidth 138201"];
2204 [label="this.AdjustFlagsAndWidth(leading); 138202"];
2205 [label="return '||'; 138203"];
2206 [label="FullWidth = this.Text.Length; 138204"];
2207 [label="FullWidth 138205"];
2208 [label="this.AdjustFlagsAndWidth(trailing); 138206"];
2209 [label="return '||'; 138207"];
2210 [label="FullWidth = this.Text.Length; 138208"];
2211 [label="FullWidth 138209"];
2212 [label="this.AdjustFlagsAndWidth(trailing); 138210"];
2213 [label="return '&&'; 138211"];
2214 [label="FullWidth = this.Text.Length; 138212"];
2215 [label="FullWidth 138213"];
2216 [label="return '&&'; 138214"];
2217 [label="FullWidth = this.Text.Length; 138215"];
2218 [label="FullWidth 138216"];
2219 [label="this.AdjustFlagsAndWidth(leading); 138217"];
2220 [label="return '&&'; 138218"];
2221 [label="FullWidth = this.Text.Length; 138219"];
2222 [label="FullWidth 138220"];
2223 [label="this.AdjustFlagsAndWidth(trailing); 138221"];
2224 [label="return '&&'; 138222"];
2225 [label="FullWidth = this.Text.Length; 138223"];
2226 [label="FullWidth 138224"];
2227 [label="this.AdjustFlagsAndWidth(trailing); 138225"];
2228 [label="return '--'; 138226"];
2229 [label="FullWidth = this.Text.Length; 138227"];
2230 [label="FullWidth 138228"];
2231 [label="return '--'; 138229"];
2232 [label="FullWidth = this.Text.Length; 138230"];
2233 [label="FullWidth 138231"];
2234 [label="this.AdjustFlagsAndWidth(leading); 138232"];
2235 [label="return '--'; 138233"];
2236 [label="FullWidth = this.Text.Length; 138234"];
2237 [label="FullWidth 138235"];
2238 [label="this.AdjustFlagsAndWidth(trailing); 138236"];
2239 [label="return '--'; 138237"];
2240 [label="FullWidth = this.Text.Length; 138238"];
2241 [label="FullWidth 138239"];
2242 [label="this.AdjustFlagsAndWidth(trailing); 138240"];
2243 [label="return '++'; 138241"];
2244 [label="FullWidth = this.Text.Length; 138242"];
2245 [label="FullWidth 138243"];
2246 [label="return '++'; 138244"];
2247 [label="FullWidth = this.Text.Length; 138245"];
2248 [label="FullWidth 138246"];
2249 [label="this.AdjustFlagsAndWidth(leading); 138247"];
2250 [label="return '++'; 138248"];
2251 [label="FullWidth = this.Text.Length; 138249"];
2252 [label="FullWidth 138250"];
2253 [label="this.AdjustFlagsAndWidth(trailing); 138251"];
2254 [label="return '++'; 138252"];
2255 [label="FullWidth = this.Text.Length; 138253"];
2256 [label="FullWidth 138254"];
2257 [label="this.AdjustFlagsAndWidth(trailing); 138255"];
2258 [label="return '::'; 138256"];
2259 [label="FullWidth = this.Text.Length; 138257"];
2260 [label="FullWidth 138258"];
2261 [label="return '::'; 138259"];
2262 [label="FullWidth = this.Text.Length; 138260"];
2263 [label="FullWidth 138261"];
2264 [label="this.AdjustFlagsAndWidth(leading); 138262"];
2265 [label="return '::'; 138263"];
2266 [label="FullWidth = this.Text.Length; 138264"];
2267 [label="FullWidth 138265"];
2268 [label="this.AdjustFlagsAndWidth(trailing); 138266"];
2269 [label="return '::'; 138267"];
2270 [label="FullWidth = this.Text.Length; 138268"];
2271 [label="FullWidth 138269"];
2272 [label="this.AdjustFlagsAndWidth(trailing); 138270"];
2273 [label="return '??'; 138271"];
2274 [label="FullWidth = this.Text.Length; 138272"];
2275 [label="FullWidth 138273"];
2276 [label="return '??'; 138274"];
2277 [label="FullWidth = this.Text.Length; 138275"];
2278 [label="FullWidth 138276"];
2279 [label="this.AdjustFlagsAndWidth(leading); 138277"];
2280 [label="return '??'; 138278"];
2281 [label="FullWidth = this.Text.Length; 138279"];
2282 [label="FullWidth 138280"];
2283 [label="this.AdjustFlagsAndWidth(trailing); 138281"];
2284 [label="return '??'; 138282"];
2285 [label="FullWidth = this.Text.Length; 138283"];
2286 [label="FullWidth 138284"];
2287 [label="this.AdjustFlagsAndWidth(trailing); 138285"];
2288 [label="return '->'; 138286"];
2289 [label="FullWidth = this.Text.Length; 138287"];
2290 [label="FullWidth 138288"];
2291 [label="return '->'; 138289"];
2292 [label="FullWidth = this.Text.Length; 138290"];
2293 [label="FullWidth 138291"];
2294 [label="this.AdjustFlagsAndWidth(leading); 138292"];
2295 [label="return '->'; 138293"];
2296 [label="FullWidth = this.Text.Length; 138294"];
2297 [label="FullWidth 138295"];
2298 [label="this.AdjustFlagsAndWidth(trailing); 138296"];
2299 [label="return '->'; 138297"];
2300 [label="FullWidth = this.Text.Length; 138298"];
2301 [label="FullWidth 138299"];
2302 [label="this.AdjustFlagsAndWidth(trailing); 138300"];
2303 [label="return '!='; 138301"];
2304 [label="FullWidth = this.Text.Length; 138302"];
2305 [label="FullWidth 138303"];
2306 [label="return '!='; 138304"];
2307 [label="FullWidth = this.Text.Length; 138305"];
2308 [label="FullWidth 138306"];
2309 [label="this.AdjustFlagsAndWidth(leading); 138307"];
2310 [label="return '!='; 138308"];
2311 [label="FullWidth = this.Text.Length; 138309"];
2312 [label="FullWidth 138310"];
2313 [label="this.AdjustFlagsAndWidth(trailing); 138311"];
2314 [label="return '!='; 138312"];
2315 [label="FullWidth = this.Text.Length; 138313"];
2316 [label="FullWidth 138314"];
2317 [label="this.AdjustFlagsAndWidth(trailing); 138315"];
2318 [label="return '=='; 138316"];
2319 [label="FullWidth = this.Text.Length; 138317"];
2320 [label="FullWidth 138318"];
2321 [label="return '=='; 138319"];
2322 [label="FullWidth = this.Text.Length; 138320"];
2323 [label="FullWidth 138321"];
2324 [label="this.AdjustFlagsAndWidth(leading); 138322"];
2325 [label="return '=='; 138323"];
2326 [label="FullWidth = this.Text.Length; 138324"];
2327 [label="FullWidth 138325"];
2328 [label="this.AdjustFlagsAndWidth(trailing); 138326"];
2329 [label="return '=='; 138327"];
2330 [label="FullWidth = this.Text.Length; 138328"];
2331 [label="FullWidth 138329"];
2332 [label="this.AdjustFlagsAndWidth(trailing); 138330"];
2333 [label="return '=>'; 138331"];
2334 [label="FullWidth = this.Text.Length; 138332"];
2335 [label="FullWidth 138333"];
2336 [label="return '=>'; 138334"];
2337 [label="FullWidth = this.Text.Length; 138335"];
2338 [label="FullWidth 138336"];
2339 [label="this.AdjustFlagsAndWidth(leading); 138337"];
2340 [label="return '=>'; 138338"];
2341 [label="FullWidth = this.Text.Length; 138339"];
2342 [label="FullWidth 138340"];
2343 [label="this.AdjustFlagsAndWidth(trailing); 138341"];
2344 [label="return '=>'; 138342"];
2345 [label="FullWidth = this.Text.Length; 138343"];
2346 [label="FullWidth 138344"];
2347 [label="this.AdjustFlagsAndWidth(trailing); 138345"];
2348 [label="return '<='; 138346"];
2349 [label="FullWidth = this.Text.Length; 138347"];
2350 [label="FullWidth 138348"];
2351 [label="return '<='; 138349"];
2352 [label="FullWidth = this.Text.Length; 138350"];
2353 [label="FullWidth 138351"];
2354 [label="this.AdjustFlagsAndWidth(leading); 138352"];
2355 [label="return '<='; 138353"];
2356 [label="FullWidth = this.Text.Length; 138354"];
2357 [label="FullWidth 138355"];
2358 [label="this.AdjustFlagsAndWidth(trailing); 138356"];
2359 [label="return '<='; 138357"];
2360 [label="FullWidth = this.Text.Length; 138358"];
2361 [label="FullWidth 138359"];
2362 [label="this.AdjustFlagsAndWidth(trailing); 138360"];
2363 [label="return '<<'; 138361"];
2364 [label="FullWidth = this.Text.Length; 138362"];
2365 [label="FullWidth 138363"];
2366 [label="return '<<'; 138364"];
2367 [label="FullWidth = this.Text.Length; 138365"];
2368 [label="FullWidth 138366"];
2369 [label="this.AdjustFlagsAndWidth(leading); 138367"];
2370 [label="return '<<'; 138368"];
2371 [label="FullWidth = this.Text.Length; 138369"];
2372 [label="FullWidth 138370"];
2373 [label="this.AdjustFlagsAndWidth(trailing); 138371"];
2374 [label="return '<<'; 138372"];
2375 [label="FullWidth = this.Text.Length; 138373"];
2376 [label="FullWidth 138374"];
2377 [label="this.AdjustFlagsAndWidth(trailing); 138375"];
2378 [label="return '<<='; 138376"];
2379 [label="FullWidth = this.Text.Length; 138377"];
2380 [label="FullWidth 138378"];
2381 [label="return '<<='; 138379"];
2382 [label="FullWidth = this.Text.Length; 138380"];
2383 [label="FullWidth 138381"];
2384 [label="this.AdjustFlagsAndWidth(leading); 138382"];
2385 [label="return '<<='; 138383"];
2386 [label="FullWidth = this.Text.Length; 138384"];
2387 [label="FullWidth 138385"];
2388 [label="this.AdjustFlagsAndWidth(trailing); 138386"];
2389 [label="return '<<='; 138387"];
2390 [label="FullWidth = this.Text.Length; 138388"];
2391 [label="FullWidth 138389"];
2392 [label="this.AdjustFlagsAndWidth(trailing); 138390"];
2393 [label="return '>='; 138391"];
2394 [label="FullWidth = this.Text.Length; 138392"];
2395 [label="FullWidth 138393"];
2396 [label="return '>='; 138394"];
2397 [label="FullWidth = this.Text.Length; 138395"];
2398 [label="FullWidth 138396"];
2399 [label="this.AdjustFlagsAndWidth(leading); 138397"];
2400 [label="return '>='; 138398"];
2401 [label="FullWidth = this.Text.Length; 138399"];
2402 [label="FullWidth 138400"];
2403 [label="this.AdjustFlagsAndWidth(trailing); 138401"];
2404 [label="return '>='; 138402"];
2405 [label="FullWidth = this.Text.Length; 138403"];
2406 [label="FullWidth 138404"];
2407 [label="this.AdjustFlagsAndWidth(trailing); 138405"];
2408 [label="return '>>'; 138406"];
2409 [label="FullWidth = this.Text.Length; 138407"];
2410 [label="FullWidth 138408"];
2411 [label="return '>>'; 138409"];
2412 [label="FullWidth = this.Text.Length; 138410"];
2413 [label="FullWidth 138411"];
2414 [label="this.AdjustFlagsAndWidth(leading); 138412"];
2415 [label="return '>>'; 138413"];
2416 [label="FullWidth = this.Text.Length; 138414"];
2417 [label="FullWidth 138415"];
2418 [label="this.AdjustFlagsAndWidth(trailing); 138416"];
2419 [label="return '>>'; 138417"];
2420 [label="FullWidth = this.Text.Length; 138418"];
2421 [label="FullWidth 138419"];
2422 [label="this.AdjustFlagsAndWidth(trailing); 138420"];
2423 [label="return '>>='; 138421"];
2424 [label="FullWidth = this.Text.Length; 138422"];
2425 [label="FullWidth 138423"];
2426 [label="return '>>='; 138424"];
2427 [label="FullWidth = this.Text.Length; 138425"];
2428 [label="FullWidth 138426"];
2429 [label="this.AdjustFlagsAndWidth(leading); 138427"];
2430 [label="return '>>='; 138428"];
2431 [label="FullWidth = this.Text.Length; 138429"];
2432 [label="FullWidth 138430"];
2433 [label="this.AdjustFlagsAndWidth(trailing); 138431"];
2434 [label="return '>>='; 138432"];
2435 [label="FullWidth = this.Text.Length; 138433"];
2436 [label="FullWidth 138434"];
2437 [label="this.AdjustFlagsAndWidth(trailing); 138435"];
2438 [label="return '/='; 138436"];
2439 [label="FullWidth = this.Text.Length; 138437"];
2440 [label="FullWidth 138438"];
2441 [label="return '/='; 138439"];
2442 [label="FullWidth = this.Text.Length; 138440"];
2443 [label="FullWidth 138441"];
2444 [label="this.AdjustFlagsAndWidth(leading); 138442"];
2445 [label="return '/='; 138443"];
2446 [label="FullWidth = this.Text.Length; 138444"];
2447 [label="FullWidth 138445"];
2448 [label="this.AdjustFlagsAndWidth(trailing); 138446"];
2449 [label="return '/='; 138447"];
2450 [label="FullWidth = this.Text.Length; 138448"];
2451 [label="FullWidth 138449"];
2452 [label="this.AdjustFlagsAndWidth(trailing); 138450"];
2453 [label="return '*='; 138451"];
2454 [label="FullWidth = this.Text.Length; 138452"];
2455 [label="FullWidth 138453"];
2456 [label="return '*='; 138454"];
2457 [label="FullWidth = this.Text.Length; 138455"];
2458 [label="FullWidth 138456"];
2459 [label="this.AdjustFlagsAndWidth(leading); 138457"];
2460 [label="return '*='; 138458"];
2461 [label="FullWidth = this.Text.Length; 138459"];
2462 [label="FullWidth 138460"];
2463 [label="this.AdjustFlagsAndWidth(trailing); 138461"];
2464 [label="return '*='; 138462"];
2465 [label="FullWidth = this.Text.Length; 138463"];
2466 [label="FullWidth 138464"];
2467 [label="this.AdjustFlagsAndWidth(trailing); 138465"];
2468 [label="return '|='; 138466"];
2469 [label="FullWidth = this.Text.Length; 138467"];
2470 [label="FullWidth 138468"];
2471 [label="return '|='; 138469"];
2472 [label="FullWidth = this.Text.Length; 138470"];
2473 [label="FullWidth 138471"];
2474 [label="this.AdjustFlagsAndWidth(leading); 138472"];
2475 [label="return '|='; 138473"];
2476 [label="FullWidth = this.Text.Length; 138474"];
2477 [label="FullWidth 138475"];
2478 [label="this.AdjustFlagsAndWidth(trailing); 138476"];
2479 [label="return '|='; 138477"];
2480 [label="FullWidth = this.Text.Length; 138478"];
2481 [label="FullWidth 138479"];
2482 [label="this.AdjustFlagsAndWidth(trailing); 138480"];
2483 [label="return '&='; 138481"];
2484 [label="FullWidth = this.Text.Length; 138482"];
2485 [label="FullWidth 138483"];
2486 [label="return '&='; 138484"];
2487 [label="FullWidth = this.Text.Length; 138485"];
2488 [label="FullWidth 138486"];
2489 [label="this.AdjustFlagsAndWidth(leading); 138487"];
2490 [label="return '&='; 138488"];
2491 [label="FullWidth = this.Text.Length; 138489"];
2492 [label="FullWidth 138490"];
2493 [label="this.AdjustFlagsAndWidth(trailing); 138491"];
2494 [label="return '&='; 138492"];
2495 [label="FullWidth = this.Text.Length; 138493"];
2496 [label="FullWidth 138494"];
2497 [label="this.AdjustFlagsAndWidth(trailing); 138495"];
2498 [label="return '+='; 138496"];
2499 [label="FullWidth = this.Text.Length; 138497"];
2500 [label="FullWidth 138498"];
2501 [label="return '+='; 138499"];
2502 [label="FullWidth = this.Text.Length; 138500"];
2503 [label="FullWidth 138501"];
2504 [label="this.AdjustFlagsAndWidth(leading); 138502"];
2505 [label="return '+='; 138503"];
2506 [label="FullWidth = this.Text.Length; 138504"];
2507 [label="FullWidth 138505"];
2508 [label="this.AdjustFlagsAndWidth(trailing); 138506"];
2509 [label="return '+='; 138507"];
2510 [label="FullWidth = this.Text.Length; 138508"];
2511 [label="FullWidth 138509"];
2512 [label="this.AdjustFlagsAndWidth(trailing); 138510"];
2513 [label="return '-='; 138511"];
2514 [label="FullWidth = this.Text.Length; 138512"];
2515 [label="FullWidth 138513"];
2516 [label="return '-='; 138514"];
2517 [label="FullWidth = this.Text.Length; 138515"];
2518 [label="FullWidth 138516"];
2519 [label="this.AdjustFlagsAndWidth(leading); 138517"];
2520 [label="return '-='; 138518"];
2521 [label="FullWidth = this.Text.Length; 138519"];
2522 [label="FullWidth 138520"];
2523 [label="this.AdjustFlagsAndWidth(trailing); 138521"];
2524 [label="return '-='; 138522"];
2525 [label="FullWidth = this.Text.Length; 138523"];
2526 [label="FullWidth 138524"];
2527 [label="this.AdjustFlagsAndWidth(trailing); 138525"];
2528 [label="return '^='; 138526"];
2529 [label="FullWidth = this.Text.Length; 138527"];
2530 [label="FullWidth 138528"];
2531 [label="return '^='; 138529"];
2532 [label="FullWidth = this.Text.Length; 138530"];
2533 [label="FullWidth 138531"];
2534 [label="this.AdjustFlagsAndWidth(leading); 138532"];
2535 [label="return '^='; 138533"];
2536 [label="FullWidth = this.Text.Length; 138534"];
2537 [label="FullWidth 138535"];
2538 [label="this.AdjustFlagsAndWidth(trailing); 138536"];
2539 [label="return '^='; 138537"];
2540 [label="FullWidth = this.Text.Length; 138538"];
2541 [label="FullWidth 138539"];
2542 [label="this.AdjustFlagsAndWidth(trailing); 138540"];
2543 [label="return '%='; 138541"];
2544 [label="FullWidth = this.Text.Length; 138542"];
2545 [label="FullWidth 138543"];
2546 [label="return '%='; 138544"];
2547 [label="FullWidth = this.Text.Length; 138545"];
2548 [label="FullWidth 138546"];
2549 [label="this.AdjustFlagsAndWidth(leading); 138547"];
2550 [label="return '%='; 138548"];
2551 [label="FullWidth = this.Text.Length; 138549"];
2552 [label="FullWidth 138550"];
2553 [label="this.AdjustFlagsAndWidth(trailing); 138551"];
2554 [label="return '%='; 138552"];
2555 [label="FullWidth = this.Text.Length; 138553"];
2556 [label="FullWidth 138554"];
2557 [label="this.AdjustFlagsAndWidth(trailing); 138555"];
2558 [label="return '??='; 138556"];
2559 [label="FullWidth = this.Text.Length; 138557"];
2560 [label="FullWidth 138558"];
2561 [label="return '??='; 138559"];
2562 [label="FullWidth = this.Text.Length; 138560"];
2563 [label="FullWidth 138561"];
2564 [label="this.AdjustFlagsAndWidth(leading); 138562"];
2565 [label="return '??='; 138563"];
2566 [label="FullWidth = this.Text.Length; 138564"];
2567 [label="FullWidth 138565"];
2568 [label="this.AdjustFlagsAndWidth(trailing); 138566"];
2569 [label="return '??='; 138567"];
2570 [label="FullWidth = this.Text.Length; 138568"];
2571 [label="FullWidth 138569"];
2572 [label="this.AdjustFlagsAndWidth(trailing); 138570"];
2573 [label="return 'bool'; 138571"];
2574 [label="FullWidth = this.Text.Length; 138572"];
2575 [label="FullWidth 138573"];
2576 [label="return 'bool'; 138574"];
2577 [label="FullWidth = this.Text.Length; 138575"];
2578 [label="FullWidth 138576"];
2579 [label="this.AdjustFlagsAndWidth(leading); 138577"];
2580 [label="return 'bool'; 138578"];
2581 [label="FullWidth = this.Text.Length; 138579"];
2582 [label="FullWidth 138580"];
2583 [label="this.AdjustFlagsAndWidth(trailing); 138581"];
2584 [label="return 'bool'; 138582"];
2585 [label="FullWidth = this.Text.Length; 138583"];
2586 [label="FullWidth 138584"];
2587 [label="this.AdjustFlagsAndWidth(trailing); 138585"];
2588 [label="return 'byte'; 138586"];
2589 [label="FullWidth = this.Text.Length; 138587"];
2590 [label="FullWidth 138588"];
2591 [label="return 'byte'; 138589"];
2592 [label="FullWidth = this.Text.Length; 138590"];
2593 [label="FullWidth 138591"];
2594 [label="this.AdjustFlagsAndWidth(leading); 138592"];
2595 [label="return 'byte'; 138593"];
2596 [label="FullWidth = this.Text.Length; 138594"];
2597 [label="FullWidth 138595"];
2598 [label="this.AdjustFlagsAndWidth(trailing); 138596"];
2599 [label="return 'byte'; 138597"];
2600 [label="FullWidth = this.Text.Length; 138598"];
2601 [label="FullWidth 138599"];
2602 [label="this.AdjustFlagsAndWidth(trailing); 138600"];
2603 [label="return 'sbyte'; 138601"];
2604 [label="FullWidth = this.Text.Length; 138602"];
2605 [label="FullWidth 138603"];
2606 [label="return 'sbyte'; 138604"];
2607 [label="FullWidth = this.Text.Length; 138605"];
2608 [label="FullWidth 138606"];
2609 [label="this.AdjustFlagsAndWidth(leading); 138607"];
2610 [label="return 'sbyte'; 138608"];
2611 [label="FullWidth = this.Text.Length; 138609"];
2612 [label="FullWidth 138610"];
2613 [label="this.AdjustFlagsAndWidth(trailing); 138611"];
2614 [label="return 'sbyte'; 138612"];
2615 [label="FullWidth = this.Text.Length; 138613"];
2616 [label="FullWidth 138614"];
2617 [label="this.AdjustFlagsAndWidth(trailing); 138615"];
2618 [label="return 'short'; 138616"];
2619 [label="FullWidth = this.Text.Length; 138617"];
2620 [label="FullWidth 138618"];
2621 [label="return 'short'; 138619"];
2622 [label="FullWidth = this.Text.Length; 138620"];
2623 [label="FullWidth 138621"];
2624 [label="this.AdjustFlagsAndWidth(leading); 138622"];
2625 [label="return 'short'; 138623"];
2626 [label="FullWidth = this.Text.Length; 138624"];
2627 [label="FullWidth 138625"];
2628 [label="this.AdjustFlagsAndWidth(trailing); 138626"];
2629 [label="return 'short'; 138627"];
2630 [label="FullWidth = this.Text.Length; 138628"];
2631 [label="FullWidth 138629"];
2632 [label="this.AdjustFlagsAndWidth(trailing); 138630"];
2633 [label="return 'ushort'; 138631"];
2634 [label="FullWidth = this.Text.Length; 138632"];
2635 [label="FullWidth 138633"];
2636 [label="return 'ushort'; 138634"];
2637 [label="FullWidth = this.Text.Length; 138635"];
2638 [label="FullWidth 138636"];
2639 [label="this.AdjustFlagsAndWidth(leading); 138637"];
2640 [label="return 'ushort'; 138638"];
2641 [label="FullWidth = this.Text.Length; 138639"];
2642 [label="FullWidth 138640"];
2643 [label="this.AdjustFlagsAndWidth(trailing); 138641"];
2644 [label="return 'ushort'; 138642"];
2645 [label="FullWidth = this.Text.Length; 138643"];
2646 [label="FullWidth 138644"];
2647 [label="this.AdjustFlagsAndWidth(trailing); 138645"];
2648 [label="return 'int'; 138646"];
2649 [label="FullWidth = this.Text.Length; 138647"];
2650 [label="FullWidth 138648"];
2651 [label="return 'int'; 138649"];
2652 [label="FullWidth = this.Text.Length; 138650"];
2653 [label="FullWidth 138651"];
2654 [label="this.AdjustFlagsAndWidth(leading); 138652"];
2655 [label="return 'int'; 138653"];
2656 [label="FullWidth = this.Text.Length; 138654"];
2657 [label="FullWidth 138655"];
2658 [label="this.AdjustFlagsAndWidth(trailing); 138656"];
2659 [label="return 'int'; 138657"];
2660 [label="FullWidth = this.Text.Length; 138658"];
2661 [label="FullWidth 138659"];
2662 [label="this.AdjustFlagsAndWidth(trailing); 138660"];
2663 [label="return 'uint'; 138661"];
2664 [label="FullWidth = this.Text.Length; 138662"];
2665 [label="FullWidth 138663"];
2666 [label="return 'uint'; 138664"];
2667 [label="FullWidth = this.Text.Length; 138665"];
2668 [label="FullWidth 138666"];
2669 [label="this.AdjustFlagsAndWidth(leading); 138667"];
2670 [label="return 'uint'; 138668"];
2671 [label="FullWidth = this.Text.Length; 138669"];
2672 [label="FullWidth 138670"];
2673 [label="this.AdjustFlagsAndWidth(trailing); 138671"];
2674 [label="return 'uint'; 138672"];
2675 [label="FullWidth = this.Text.Length; 138673"];
2676 [label="FullWidth 138674"];
2677 [label="this.AdjustFlagsAndWidth(trailing); 138675"];
2678 [label="return 'long'; 138676"];
2679 [label="FullWidth = this.Text.Length; 138677"];
2680 [label="FullWidth 138678"];
2681 [label="return 'long'; 138679"];
2682 [label="FullWidth = this.Text.Length; 138680"];
2683 [label="FullWidth 138681"];
2684 [label="this.AdjustFlagsAndWidth(leading); 138682"];
2685 [label="return 'long'; 138683"];
2686 [label="FullWidth = this.Text.Length; 138684"];
2687 [label="FullWidth 138685"];
2688 [label="this.AdjustFlagsAndWidth(trailing); 138686"];
2689 [label="return 'long'; 138687"];
2690 [label="FullWidth = this.Text.Length; 138688"];
2691 [label="FullWidth 138689"];
2692 [label="this.AdjustFlagsAndWidth(trailing); 138690"];
2693 [label="return 'ulong'; 138691"];
2694 [label="FullWidth = this.Text.Length; 138692"];
2695 [label="FullWidth 138693"];
2696 [label="return 'ulong'; 138694"];
2697 [label="FullWidth = this.Text.Length; 138695"];
2698 [label="FullWidth 138696"];
2699 [label="this.AdjustFlagsAndWidth(leading); 138697"];
2700 [label="return 'ulong'; 138698"];
2701 [label="FullWidth = this.Text.Length; 138699"];
2702 [label="FullWidth 138700"];
2703 [label="this.AdjustFlagsAndWidth(trailing); 138701"];
2704 [label="return 'ulong'; 138702"];
2705 [label="FullWidth = this.Text.Length; 138703"];
2706 [label="FullWidth 138704"];
2707 [label="this.AdjustFlagsAndWidth(trailing); 138705"];
2708 [label="return 'double'; 138706"];
2709 [label="FullWidth = this.Text.Length; 138707"];
2710 [label="FullWidth 138708"];
2711 [label="return 'double'; 138709"];
2712 [label="FullWidth = this.Text.Length; 138710"];
2713 [label="FullWidth 138711"];
2714 [label="this.AdjustFlagsAndWidth(leading); 138712"];
2715 [label="return 'double'; 138713"];
2716 [label="FullWidth = this.Text.Length; 138714"];
2717 [label="FullWidth 138715"];
2718 [label="this.AdjustFlagsAndWidth(trailing); 138716"];
2719 [label="return 'double'; 138717"];
2720 [label="FullWidth = this.Text.Length; 138718"];
2721 [label="FullWidth 138719"];
2722 [label="this.AdjustFlagsAndWidth(trailing); 138720"];
2723 [label="return 'float'; 138721"];
2724 [label="FullWidth = this.Text.Length; 138722"];
2725 [label="FullWidth 138723"];
2726 [label="return 'float'; 138724"];
2727 [label="FullWidth = this.Text.Length; 138725"];
2728 [label="FullWidth 138726"];
2729 [label="this.AdjustFlagsAndWidth(leading); 138727"];
2730 [label="return 'float'; 138728"];
2731 [label="FullWidth = this.Text.Length; 138729"];
2732 [label="FullWidth 138730"];
2733 [label="this.AdjustFlagsAndWidth(trailing); 138731"];
2734 [label="return 'float'; 138732"];
2735 [label="FullWidth = this.Text.Length; 138733"];
2736 [label="FullWidth 138734"];
2737 [label="this.AdjustFlagsAndWidth(trailing); 138735"];
2738 [label="return 'decimal'; 138736"];
2739 [label="FullWidth = this.Text.Length; 138737"];
2740 [label="FullWidth 138738"];
2741 [label="return 'decimal'; 138739"];
2742 [label="FullWidth = this.Text.Length; 138740"];
2743 [label="FullWidth 138741"];
2744 [label="this.AdjustFlagsAndWidth(leading); 138742"];
2745 [label="return 'decimal'; 138743"];
2746 [label="FullWidth = this.Text.Length; 138744"];
2747 [label="FullWidth 138745"];
2748 [label="this.AdjustFlagsAndWidth(trailing); 138746"];
2749 [label="return 'decimal'; 138747"];
2750 [label="FullWidth = this.Text.Length; 138748"];
2751 [label="FullWidth 138749"];
2752 [label="this.AdjustFlagsAndWidth(trailing); 138750"];
2753 [label="return 'string'; 138751"];
2754 [label="FullWidth = this.Text.Length; 138752"];
2755 [label="FullWidth 138753"];
2756 [label="return 'string'; 138754"];
2757 [label="FullWidth = this.Text.Length; 138755"];
2758 [label="FullWidth 138756"];
2759 [label="this.AdjustFlagsAndWidth(leading); 138757"];
2760 [label="return 'string'; 138758"];
2761 [label="FullWidth = this.Text.Length; 138759"];
2762 [label="FullWidth 138760"];
2763 [label="this.AdjustFlagsAndWidth(trailing); 138761"];
2764 [label="return 'string'; 138762"];
2765 [label="FullWidth = this.Text.Length; 138763"];
2766 [label="FullWidth 138764"];
2767 [label="this.AdjustFlagsAndWidth(trailing); 138765"];
2768 [label="return 'char'; 138766"];
2769 [label="FullWidth = this.Text.Length; 138767"];
2770 [label="FullWidth 138768"];
2771 [label="return 'char'; 138769"];
2772 [label="FullWidth = this.Text.Length; 138770"];
2773 [label="FullWidth 138771"];
2774 [label="this.AdjustFlagsAndWidth(leading); 138772"];
2775 [label="return 'char'; 138773"];
2776 [label="FullWidth = this.Text.Length; 138774"];
2777 [label="FullWidth 138775"];
2778 [label="this.AdjustFlagsAndWidth(trailing); 138776"];
2779 [label="return 'char'; 138777"];
2780 [label="FullWidth = this.Text.Length; 138778"];
2781 [label="FullWidth 138779"];
2782 [label="this.AdjustFlagsAndWidth(trailing); 138780"];
2783 [label="return 'void'; 138781"];
2784 [label="FullWidth = this.Text.Length; 138782"];
2785 [label="FullWidth 138783"];
2786 [label="return 'void'; 138784"];
2787 [label="FullWidth = this.Text.Length; 138785"];
2788 [label="FullWidth 138786"];
2789 [label="this.AdjustFlagsAndWidth(leading); 138787"];
2790 [label="return 'void'; 138788"];
2791 [label="FullWidth = this.Text.Length; 138789"];
2792 [label="FullWidth 138790"];
2793 [label="this.AdjustFlagsAndWidth(trailing); 138791"];
2794 [label="return 'void'; 138792"];
2795 [label="FullWidth = this.Text.Length; 138793"];
2796 [label="FullWidth 138794"];
2797 [label="this.AdjustFlagsAndWidth(trailing); 138795"];
2798 [label="return 'object'; 138796"];
2799 [label="FullWidth = this.Text.Length; 138797"];
2800 [label="FullWidth 138798"];
2801 [label="return 'object'; 138799"];
2802 [label="FullWidth = this.Text.Length; 138800"];
2803 [label="FullWidth 138801"];
2804 [label="this.AdjustFlagsAndWidth(leading); 138802"];
2805 [label="return 'object'; 138803"];
2806 [label="FullWidth = this.Text.Length; 138804"];
2807 [label="FullWidth 138805"];
2808 [label="this.AdjustFlagsAndWidth(trailing); 138806"];
2809 [label="return 'object'; 138807"];
2810 [label="FullWidth = this.Text.Length; 138808"];
2811 [label="FullWidth 138809"];
2812 [label="this.AdjustFlagsAndWidth(trailing); 138810"];
2813 [label="return 'typeof'; 138811"];
2814 [label="FullWidth = this.Text.Length; 138812"];
2815 [label="FullWidth 138813"];
2816 [label="return 'typeof'; 138814"];
2817 [label="FullWidth = this.Text.Length; 138815"];
2818 [label="FullWidth 138816"];
2819 [label="this.AdjustFlagsAndWidth(leading); 138817"];
2820 [label="return 'typeof'; 138818"];
2821 [label="FullWidth = this.Text.Length; 138819"];
2822 [label="FullWidth 138820"];
2823 [label="this.AdjustFlagsAndWidth(trailing); 138821"];
2824 [label="return 'typeof'; 138822"];
2825 [label="FullWidth = this.Text.Length; 138823"];
2826 [label="FullWidth 138824"];
2827 [label="this.AdjustFlagsAndWidth(trailing); 138825"];
2828 [label="return 'sizeof'; 138826"];
2829 [label="FullWidth = this.Text.Length; 138827"];
2830 [label="FullWidth 138828"];
2831 [label="return 'sizeof'; 138829"];
2832 [label="FullWidth = this.Text.Length; 138830"];
2833 [label="FullWidth 138831"];
2834 [label="this.AdjustFlagsAndWidth(leading); 138832"];
2835 [label="return 'sizeof'; 138833"];
2836 [label="FullWidth = this.Text.Length; 138834"];
2837 [label="FullWidth 138835"];
2838 [label="this.AdjustFlagsAndWidth(trailing); 138836"];
2839 [label="return 'sizeof'; 138837"];
2840 [label="FullWidth = this.Text.Length; 138838"];
2841 [label="FullWidth 138839"];
2842 [label="this.AdjustFlagsAndWidth(trailing); 138840"];
2843 [label="return 'null'; 138841"];
2844 [label="FullWidth = this.Text.Length; 138842"];
2845 [label="FullWidth 138843"];
2846 [label="return 'null'; 138844"];
2847 [label="FullWidth = this.Text.Length; 138845"];
2848 [label="FullWidth 138846"];
2849 [label="this.AdjustFlagsAndWidth(leading); 138847"];
2850 [label="return 'null'; 138848"];
2851 [label="FullWidth = this.Text.Length; 138849"];
2852 [label="FullWidth 138850"];
2853 [label="this.AdjustFlagsAndWidth(trailing); 138851"];
2854 [label="return 'null'; 138852"];
2855 [label="FullWidth = this.Text.Length; 138853"];
2856 [label="FullWidth 138854"];
2857 [label="this.AdjustFlagsAndWidth(trailing); 138855"];
2858 [label="return 'true'; 138856"];
2859 [label="FullWidth = this.Text.Length; 138857"];
2860 [label="FullWidth 138858"];
2861 [label="return 'true'; 138859"];
2862 [label="FullWidth = this.Text.Length; 138860"];
2863 [label="FullWidth 138861"];
2864 [label="this.AdjustFlagsAndWidth(leading); 138862"];
2865 [label="return 'true'; 138863"];
2866 [label="FullWidth = this.Text.Length; 138864"];
2867 [label="FullWidth 138865"];
2868 [label="this.AdjustFlagsAndWidth(trailing); 138866"];
2869 [label="return 'true'; 138867"];
2870 [label="FullWidth = this.Text.Length; 138868"];
2871 [label="FullWidth 138869"];
2872 [label="this.AdjustFlagsAndWidth(trailing); 138870"];
2873 [label="return 'false'; 138871"];
2874 [label="FullWidth = this.Text.Length; 138872"];
2875 [label="FullWidth 138873"];
2876 [label="return 'false'; 138874"];
2877 [label="FullWidth = this.Text.Length; 138875"];
2878 [label="FullWidth 138876"];
2879 [label="this.AdjustFlagsAndWidth(leading); 138877"];
2880 [label="return 'false'; 138878"];
2881 [label="FullWidth = this.Text.Length; 138879"];
2882 [label="FullWidth 138880"];
2883 [label="this.AdjustFlagsAndWidth(trailing); 138881"];
2884 [label="return 'false'; 138882"];
2885 [label="FullWidth = this.Text.Length; 138883"];
2886 [label="FullWidth 138884"];
2887 [label="this.AdjustFlagsAndWidth(trailing); 138885"];
2888 [label="return 'if'; 138886"];
2889 [label="FullWidth = this.Text.Length; 138887"];
2890 [label="FullWidth 138888"];
2891 [label="return 'if'; 138889"];
2892 [label="FullWidth = this.Text.Length; 138890"];
2893 [label="FullWidth 138891"];
2894 [label="this.AdjustFlagsAndWidth(leading); 138892"];
2895 [label="return 'if'; 138893"];
2896 [label="FullWidth = this.Text.Length; 138894"];
2897 [label="FullWidth 138895"];
2898 [label="this.AdjustFlagsAndWidth(trailing); 138896"];
2899 [label="return 'if'; 138897"];
2900 [label="FullWidth = this.Text.Length; 138898"];
2901 [label="FullWidth 138899"];
2902 [label="this.AdjustFlagsAndWidth(trailing); 138900"];
2903 [label="return 'else'; 138901"];
2904 [label="FullWidth = this.Text.Length; 138902"];
2905 [label="FullWidth 138903"];
2906 [label="return 'else'; 138904"];
2907 [label="FullWidth = this.Text.Length; 138905"];
2908 [label="FullWidth 138906"];
2909 [label="this.AdjustFlagsAndWidth(leading); 138907"];
2910 [label="return 'else'; 138908"];
2911 [label="FullWidth = this.Text.Length; 138909"];
2912 [label="FullWidth 138910"];
2913 [label="this.AdjustFlagsAndWidth(trailing); 138911"];
2914 [label="return 'else'; 138912"];
2915 [label="FullWidth = this.Text.Length; 138913"];
2916 [label="FullWidth 138914"];
2917 [label="this.AdjustFlagsAndWidth(trailing); 138915"];
2918 [label="return 'while'; 138916"];
2919 [label="FullWidth = this.Text.Length; 138917"];
2920 [label="FullWidth 138918"];
2921 [label="return 'while'; 138919"];
2922 [label="FullWidth = this.Text.Length; 138920"];
2923 [label="FullWidth 138921"];
2924 [label="this.AdjustFlagsAndWidth(leading); 138922"];
2925 [label="return 'while'; 138923"];
2926 [label="FullWidth = this.Text.Length; 138924"];
2927 [label="FullWidth 138925"];
2928 [label="this.AdjustFlagsAndWidth(trailing); 138926"];
2929 [label="return 'while'; 138927"];
2930 [label="FullWidth = this.Text.Length; 138928"];
2931 [label="FullWidth 138929"];
2932 [label="this.AdjustFlagsAndWidth(trailing); 138930"];
2933 [label="return 'for'; 138931"];
2934 [label="FullWidth = this.Text.Length; 138932"];
2935 [label="FullWidth 138933"];
2936 [label="return 'for'; 138934"];
2937 [label="FullWidth = this.Text.Length; 138935"];
2938 [label="FullWidth 138936"];
2939 [label="this.AdjustFlagsAndWidth(leading); 138937"];
2940 [label="return 'for'; 138938"];
2941 [label="FullWidth = this.Text.Length; 138939"];
2942 [label="FullWidth 138940"];
2943 [label="this.AdjustFlagsAndWidth(trailing); 138941"];
2944 [label="return 'for'; 138942"];
2945 [label="FullWidth = this.Text.Length; 138943"];
2946 [label="FullWidth 138944"];
2947 [label="this.AdjustFlagsAndWidth(trailing); 138945"];
2948 [label="return 'foreach'; 138946"];
2949 [label="FullWidth = this.Text.Length; 138947"];
2950 [label="FullWidth 138948"];
2951 [label="return 'foreach'; 138949"];
2952 [label="FullWidth = this.Text.Length; 138950"];
2953 [label="FullWidth 138951"];
2954 [label="this.AdjustFlagsAndWidth(leading); 138952"];
2955 [label="return 'foreach'; 138953"];
2956 [label="FullWidth = this.Text.Length; 138954"];
2957 [label="FullWidth 138955"];
2958 [label="this.AdjustFlagsAndWidth(trailing); 138956"];
2959 [label="return 'foreach'; 138957"];
2960 [label="FullWidth = this.Text.Length; 138958"];
2961 [label="FullWidth 138959"];
2962 [label="this.AdjustFlagsAndWidth(trailing); 138960"];
2963 [label="return 'do'; 138961"];
2964 [label="FullWidth = this.Text.Length; 138962"];
2965 [label="FullWidth 138963"];
2966 [label="return 'do'; 138964"];
2967 [label="FullWidth = this.Text.Length; 138965"];
2968 [label="FullWidth 138966"];
2969 [label="this.AdjustFlagsAndWidth(leading); 138967"];
2970 [label="return 'do'; 138968"];
2971 [label="FullWidth = this.Text.Length; 138969"];
2972 [label="FullWidth 138970"];
2973 [label="this.AdjustFlagsAndWidth(trailing); 138971"];
2974 [label="return 'do'; 138972"];
2975 [label="FullWidth = this.Text.Length; 138973"];
2976 [label="FullWidth 138974"];
2977 [label="this.AdjustFlagsAndWidth(trailing); 138975"];
2978 [label="return 'switch'; 138976"];
2979 [label="FullWidth = this.Text.Length; 138977"];
2980 [label="FullWidth 138978"];
2981 [label="return 'switch'; 138979"];
2982 [label="FullWidth = this.Text.Length; 138980"];
2983 [label="FullWidth 138981"];
2984 [label="this.AdjustFlagsAndWidth(leading); 138982"];
2985 [label="return 'switch'; 138983"];
2986 [label="FullWidth = this.Text.Length; 138984"];
2987 [label="FullWidth 138985"];
2988 [label="this.AdjustFlagsAndWidth(trailing); 138986"];
2989 [label="return 'switch'; 138987"];
2990 [label="FullWidth = this.Text.Length; 138988"];
2991 [label="FullWidth 138989"];
2992 [label="this.AdjustFlagsAndWidth(trailing); 138990"];
2993 [label="return 'case'; 138991"];
2994 [label="FullWidth = this.Text.Length; 138992"];
2995 [label="FullWidth 138993"];
2996 [label="return 'case'; 138994"];
2997 [label="FullWidth = this.Text.Length; 138995"];
2998 [label="FullWidth 138996"];
2999 [label="this.AdjustFlagsAndWidth(leading); 138997"];
3000 [label="return 'case'; 138998"];
3001 [label="FullWidth = this.Text.Length; 138999"];
3002 [label="FullWidth 139000"];
3003 [label="this.AdjustFlagsAndWidth(trailing); 139001"];
3004 [label="return 'case'; 139002"];
3005 [label="FullWidth = this.Text.Length; 139003"];
3006 [label="FullWidth 139004"];
3007 [label="this.AdjustFlagsAndWidth(trailing); 139005"];
3008 [label="return 'default'; 139006"];
3009 [label="FullWidth = this.Text.Length; 139007"];
3010 [label="FullWidth 139008"];
3011 [label="return 'default'; 139009"];
3012 [label="FullWidth = this.Text.Length; 139010"];
3013 [label="FullWidth 139011"];
3014 [label="this.AdjustFlagsAndWidth(leading); 139012"];
3015 [label="return 'default'; 139013"];
3016 [label="FullWidth = this.Text.Length; 139014"];
3017 [label="FullWidth 139015"];
3018 [label="this.AdjustFlagsAndWidth(trailing); 139016"];
3019 [label="return 'default'; 139017"];
3020 [label="FullWidth = this.Text.Length; 139018"];
3021 [label="FullWidth 139019"];
3022 [label="this.AdjustFlagsAndWidth(trailing); 139020"];
3023 [label="return 'try'; 139021"];
3024 [label="FullWidth = this.Text.Length; 139022"];
3025 [label="FullWidth 139023"];
3026 [label="return 'try'; 139024"];
3027 [label="FullWidth = this.Text.Length; 139025"];
3028 [label="FullWidth 139026"];
3029 [label="this.AdjustFlagsAndWidth(leading); 139027"];
3030 [label="return 'try'; 139028"];
3031 [label="FullWidth = this.Text.Length; 139029"];
3032 [label="FullWidth 139030"];
3033 [label="this.AdjustFlagsAndWidth(trailing); 139031"];
3034 [label="return 'try'; 139032"];
3035 [label="FullWidth = this.Text.Length; 139033"];
3036 [label="FullWidth 139034"];
3037 [label="this.AdjustFlagsAndWidth(trailing); 139035"];
3038 [label="return 'catch'; 139036"];
3039 [label="FullWidth = this.Text.Length; 139037"];
3040 [label="FullWidth 139038"];
3041 [label="return 'catch'; 139039"];
3042 [label="FullWidth = this.Text.Length; 139040"];
3043 [label="FullWidth 139041"];
3044 [label="this.AdjustFlagsAndWidth(leading); 139042"];
3045 [label="return 'catch'; 139043"];
3046 [label="FullWidth = this.Text.Length; 139044"];
3047 [label="FullWidth 139045"];
3048 [label="this.AdjustFlagsAndWidth(trailing); 139046"];
3049 [label="return 'catch'; 139047"];
3050 [label="FullWidth = this.Text.Length; 139048"];
3051 [label="FullWidth 139049"];
3052 [label="this.AdjustFlagsAndWidth(trailing); 139050"];
3053 [label="return 'finally'; 139051"];
3054 [label="FullWidth = this.Text.Length; 139052"];
3055 [label="FullWidth 139053"];
3056 [label="return 'finally'; 139054"];
3057 [label="FullWidth = this.Text.Length; 139055"];
3058 [label="FullWidth 139056"];
3059 [label="this.AdjustFlagsAndWidth(leading); 139057"];
3060 [label="return 'finally'; 139058"];
3061 [label="FullWidth = this.Text.Length; 139059"];
3062 [label="FullWidth 139060"];
3063 [label="this.AdjustFlagsAndWidth(trailing); 139061"];
3064 [label="return 'finally'; 139062"];
3065 [label="FullWidth = this.Text.Length; 139063"];
3066 [label="FullWidth 139064"];
3067 [label="this.AdjustFlagsAndWidth(trailing); 139065"];
3068 [label="return 'lock'; 139066"];
3069 [label="FullWidth = this.Text.Length; 139067"];
3070 [label="FullWidth 139068"];
3071 [label="return 'lock'; 139069"];
3072 [label="FullWidth = this.Text.Length; 139070"];
3073 [label="FullWidth 139071"];
3074 [label="this.AdjustFlagsAndWidth(leading); 139072"];
3075 [label="return 'lock'; 139073"];
3076 [label="FullWidth = this.Text.Length; 139074"];
3077 [label="FullWidth 139075"];
3078 [label="this.AdjustFlagsAndWidth(trailing); 139076"];
3079 [label="return 'lock'; 139077"];
3080 [label="FullWidth = this.Text.Length; 139078"];
3081 [label="FullWidth 139079"];
3082 [label="this.AdjustFlagsAndWidth(trailing); 139080"];
3083 [label="return 'goto'; 139081"];
3084 [label="FullWidth = this.Text.Length; 139082"];
3085 [label="FullWidth 139083"];
3086 [label="return 'goto'; 139084"];
3087 [label="FullWidth = this.Text.Length; 139085"];
3088 [label="FullWidth 139086"];
3089 [label="this.AdjustFlagsAndWidth(leading); 139087"];
3090 [label="return 'goto'; 139088"];
3091 [label="FullWidth = this.Text.Length; 139089"];
3092 [label="FullWidth 139090"];
3093 [label="this.AdjustFlagsAndWidth(trailing); 139091"];
3094 [label="return 'goto'; 139092"];
3095 [label="FullWidth = this.Text.Length; 139093"];
3096 [label="FullWidth 139094"];
3097 [label="this.AdjustFlagsAndWidth(trailing); 139095"];
3098 [label="return 'break'; 139096"];
3099 [label="FullWidth = this.Text.Length; 139097"];
3100 [label="FullWidth 139098"];
3101 [label="return 'break'; 139099"];
3102 [label="FullWidth = this.Text.Length; 139100"];
3103 [label="FullWidth 139101"];
3104 [label="this.AdjustFlagsAndWidth(leading); 139102"];
3105 [label="return 'break'; 139103"];
3106 [label="FullWidth = this.Text.Length; 139104"];
3107 [label="FullWidth 139105"];
3108 [label="this.AdjustFlagsAndWidth(trailing); 139106"];
3109 [label="return 'break'; 139107"];
3110 [label="FullWidth = this.Text.Length; 139108"];
3111 [label="FullWidth 139109"];
3112 [label="this.AdjustFlagsAndWidth(trailing); 139110"];
3113 [label="return 'continue'; 139111"];
3114 [label="FullWidth = this.Text.Length; 139112"];
3115 [label="FullWidth 139113"];
3116 [label="return 'continue'; 139114"];
3117 [label="FullWidth = this.Text.Length; 139115"];
3118 [label="FullWidth 139116"];
3119 [label="this.AdjustFlagsAndWidth(leading); 139117"];
3120 [label="return 'continue'; 139118"];
3121 [label="FullWidth = this.Text.Length; 139119"];
3122 [label="FullWidth 139120"];
3123 [label="this.AdjustFlagsAndWidth(trailing); 139121"];
3124 [label="return 'continue'; 139122"];
3125 [label="FullWidth = this.Text.Length; 139123"];
3126 [label="FullWidth 139124"];
3127 [label="this.AdjustFlagsAndWidth(trailing); 139125"];
3128 [label="return 'return'; 139126"];
3129 [label="FullWidth = this.Text.Length; 139127"];
3130 [label="FullWidth 139128"];
3131 [label="return 'return'; 139129"];
3132 [label="FullWidth = this.Text.Length; 139130"];
3133 [label="FullWidth 139131"];
3134 [label="this.AdjustFlagsAndWidth(leading); 139132"];
3135 [label="return 'return'; 139133"];
3136 [label="FullWidth = this.Text.Length; 139134"];
3137 [label="FullWidth 139135"];
3138 [label="this.AdjustFlagsAndWidth(trailing); 139136"];
3139 [label="return 'return'; 139137"];
3140 [label="FullWidth = this.Text.Length; 139138"];
3141 [label="FullWidth 139139"];
3142 [label="this.AdjustFlagsAndWidth(trailing); 139140"];
3143 [label="return 'throw'; 139141"];
3144 [label="FullWidth = this.Text.Length; 139142"];
3145 [label="FullWidth 139143"];
3146 [label="return 'throw'; 139144"];
3147 [label="FullWidth = this.Text.Length; 139145"];
3148 [label="FullWidth 139146"];
3149 [label="this.AdjustFlagsAndWidth(leading); 139147"];
3150 [label="return 'throw'; 139148"];
3151 [label="FullWidth = this.Text.Length; 139149"];
3152 [label="FullWidth 139150"];
3153 [label="this.AdjustFlagsAndWidth(trailing); 139151"];
3154 [label="return 'throw'; 139152"];
3155 [label="FullWidth = this.Text.Length; 139153"];
3156 [label="FullWidth 139154"];
3157 [label="this.AdjustFlagsAndWidth(trailing); 139155"];
3158 [label="return 'public'; 139156"];
3159 [label="FullWidth = this.Text.Length; 139157"];
3160 [label="FullWidth 139158"];
3161 [label="return 'public'; 139159"];
3162 [label="FullWidth = this.Text.Length; 139160"];
3163 [label="FullWidth 139161"];
3164 [label="this.AdjustFlagsAndWidth(leading); 139162"];
3165 [label="return 'public'; 139163"];
3166 [label="FullWidth = this.Text.Length; 139164"];
3167 [label="FullWidth 139165"];
3168 [label="this.AdjustFlagsAndWidth(trailing); 139166"];
3169 [label="return 'public'; 139167"];
3170 [label="FullWidth = this.Text.Length; 139168"];
3171 [label="FullWidth 139169"];
3172 [label="this.AdjustFlagsAndWidth(trailing); 139170"];
3173 [label="return 'private'; 139171"];
3174 [label="FullWidth = this.Text.Length; 139172"];
3175 [label="FullWidth 139173"];
3176 [label="return 'private'; 139174"];
3177 [label="FullWidth = this.Text.Length; 139175"];
3178 [label="FullWidth 139176"];
3179 [label="this.AdjustFlagsAndWidth(leading); 139177"];
3180 [label="return 'private'; 139178"];
3181 [label="FullWidth = this.Text.Length; 139179"];
3182 [label="FullWidth 139180"];
3183 [label="this.AdjustFlagsAndWidth(trailing); 139181"];
3184 [label="return 'private'; 139182"];
3185 [label="FullWidth = this.Text.Length; 139183"];
3186 [label="FullWidth 139184"];
3187 [label="this.AdjustFlagsAndWidth(trailing); 139185"];
3188 [label="return 'internal'; 139186"];
3189 [label="FullWidth = this.Text.Length; 139187"];
3190 [label="FullWidth 139188"];
3191 [label="return 'internal'; 139189"];
3192 [label="FullWidth = this.Text.Length; 139190"];
3193 [label="FullWidth 139191"];
3194 [label="this.AdjustFlagsAndWidth(leading); 139192"];
3195 [label="return 'internal'; 139193"];
3196 [label="FullWidth = this.Text.Length; 139194"];
3197 [label="FullWidth 139195"];
3198 [label="this.AdjustFlagsAndWidth(trailing); 139196"];
3199 [label="return 'internal'; 139197"];
3200 [label="FullWidth = this.Text.Length; 139198"];
3201 [label="FullWidth 139199"];
3202 [label="this.AdjustFlagsAndWidth(trailing); 139200"];
3203 [label="return 'protected'; 139201"];
3204 [label="FullWidth = this.Text.Length; 139202"];
3205 [label="FullWidth 139203"];
3206 [label="return 'protected'; 139204"];
3207 [label="FullWidth = this.Text.Length; 139205"];
3208 [label="FullWidth 139206"];
3209 [label="this.AdjustFlagsAndWidth(leading); 139207"];
3210 [label="return 'protected'; 139208"];
3211 [label="FullWidth = this.Text.Length; 139209"];
3212 [label="FullWidth 139210"];
3213 [label="this.AdjustFlagsAndWidth(trailing); 139211"];
3214 [label="return 'protected'; 139212"];
3215 [label="FullWidth = this.Text.Length; 139213"];
3216 [label="FullWidth 139214"];
3217 [label="this.AdjustFlagsAndWidth(trailing); 139215"];
3218 [label="return 'static'; 139216"];
3219 [label="FullWidth = this.Text.Length; 139217"];
3220 [label="FullWidth 139218"];
3221 [label="return 'static'; 139219"];
3222 [label="FullWidth = this.Text.Length; 139220"];
3223 [label="FullWidth 139221"];
3224 [label="this.AdjustFlagsAndWidth(leading); 139222"];
3225 [label="return 'static'; 139223"];
3226 [label="FullWidth = this.Text.Length; 139224"];
3227 [label="FullWidth 139225"];
3228 [label="this.AdjustFlagsAndWidth(trailing); 139226"];
3229 [label="return 'static'; 139227"];
3230 [label="FullWidth = this.Text.Length; 139228"];
3231 [label="FullWidth 139229"];
3232 [label="this.AdjustFlagsAndWidth(trailing); 139230"];
3233 [label="return 'readonly'; 139231"];
3234 [label="FullWidth = this.Text.Length; 139232"];
3235 [label="FullWidth 139233"];
3236 [label="return 'readonly'; 139234"];
3237 [label="FullWidth = this.Text.Length; 139235"];
3238 [label="FullWidth 139236"];
3239 [label="this.AdjustFlagsAndWidth(leading); 139237"];
3240 [label="return 'readonly'; 139238"];
3241 [label="FullWidth = this.Text.Length; 139239"];
3242 [label="FullWidth 139240"];
3243 [label="this.AdjustFlagsAndWidth(trailing); 139241"];
3244 [label="return 'readonly'; 139242"];
3245 [label="FullWidth = this.Text.Length; 139243"];
3246 [label="FullWidth 139244"];
3247 [label="this.AdjustFlagsAndWidth(trailing); 139245"];
3248 [label="return 'sealed'; 139246"];
3249 [label="FullWidth = this.Text.Length; 139247"];
3250 [label="FullWidth 139248"];
3251 [label="return 'sealed'; 139249"];
3252 [label="FullWidth = this.Text.Length; 139250"];
3253 [label="FullWidth 139251"];
3254 [label="this.AdjustFlagsAndWidth(leading); 139252"];
3255 [label="return 'sealed'; 139253"];
3256 [label="FullWidth = this.Text.Length; 139254"];
3257 [label="FullWidth 139255"];
3258 [label="this.AdjustFlagsAndWidth(trailing); 139256"];
3259 [label="return 'sealed'; 139257"];
3260 [label="FullWidth = this.Text.Length; 139258"];
3261 [label="FullWidth 139259"];
3262 [label="this.AdjustFlagsAndWidth(trailing); 139260"];
3263 [label="return 'const'; 139261"];
3264 [label="FullWidth = this.Text.Length; 139262"];
3265 [label="FullWidth 139263"];
3266 [label="return 'const'; 139264"];
3267 [label="FullWidth = this.Text.Length; 139265"];
3268 [label="FullWidth 139266"];
3269 [label="this.AdjustFlagsAndWidth(leading); 139267"];
3270 [label="return 'const'; 139268"];
3271 [label="FullWidth = this.Text.Length; 139269"];
3272 [label="FullWidth 139270"];
3273 [label="this.AdjustFlagsAndWidth(trailing); 139271"];
3274 [label="return 'const'; 139272"];
3275 [label="FullWidth = this.Text.Length; 139273"];
3276 [label="FullWidth 139274"];
3277 [label="this.AdjustFlagsAndWidth(trailing); 139275"];
3278 [label="return 'fixed'; 139276"];
3279 [label="FullWidth = this.Text.Length; 139277"];
3280 [label="FullWidth 139278"];
3281 [label="return 'fixed'; 139279"];
3282 [label="FullWidth = this.Text.Length; 139280"];
3283 [label="FullWidth 139281"];
3284 [label="this.AdjustFlagsAndWidth(leading); 139282"];
3285 [label="return 'fixed'; 139283"];
3286 [label="FullWidth = this.Text.Length; 139284"];
3287 [label="FullWidth 139285"];
3288 [label="this.AdjustFlagsAndWidth(trailing); 139286"];
3289 [label="return 'fixed'; 139287"];
3290 [label="FullWidth = this.Text.Length; 139288"];
3291 [label="FullWidth 139289"];
3292 [label="this.AdjustFlagsAndWidth(trailing); 139290"];
3293 [label="return 'stackalloc'; 139291"];
3294 [label="FullWidth = this.Text.Length; 139292"];
3295 [label="FullWidth 139293"];
3296 [label="return 'stackalloc'; 139294"];
3297 [label="FullWidth = this.Text.Length; 139295"];
3298 [label="FullWidth 139296"];
3299 [label="this.AdjustFlagsAndWidth(leading); 139297"];
3300 [label="return 'stackalloc'; 139298"];
3301 [label="FullWidth = this.Text.Length; 139299"];
3302 [label="FullWidth 139300"];
3303 [label="this.AdjustFlagsAndWidth(trailing); 139301"];
3304 [label="return 'stackalloc'; 139302"];
3305 [label="FullWidth = this.Text.Length; 139303"];
3306 [label="FullWidth 139304"];
3307 [label="this.AdjustFlagsAndWidth(trailing); 139305"];
3308 [label="return 'volatile'; 139306"];
3309 [label="FullWidth = this.Text.Length; 139307"];
3310 [label="FullWidth 139308"];
3311 [label="return 'volatile'; 139309"];
3312 [label="FullWidth = this.Text.Length; 139310"];
3313 [label="FullWidth 139311"];
3314 [label="this.AdjustFlagsAndWidth(leading); 139312"];
3315 [label="return 'volatile'; 139313"];
3316 [label="FullWidth = this.Text.Length; 139314"];
3317 [label="FullWidth 139315"];
3318 [label="this.AdjustFlagsAndWidth(trailing); 139316"];
3319 [label="return 'volatile'; 139317"];
3320 [label="FullWidth = this.Text.Length; 139318"];
3321 [label="FullWidth 139319"];
3322 [label="this.AdjustFlagsAndWidth(trailing); 139320"];
3323 [label="return 'new'; 139321"];
3324 [label="FullWidth = this.Text.Length; 139322"];
3325 [label="FullWidth 139323"];
3326 [label="return 'new'; 139324"];
3327 [label="FullWidth = this.Text.Length; 139325"];
3328 [label="FullWidth 139326"];
3329 [label="this.AdjustFlagsAndWidth(leading); 139327"];
3330 [label="return 'new'; 139328"];
3331 [label="FullWidth = this.Text.Length; 139329"];
3332 [label="FullWidth 139330"];
3333 [label="this.AdjustFlagsAndWidth(trailing); 139331"];
3334 [label="return 'new'; 139332"];
3335 [label="FullWidth = this.Text.Length; 139333"];
3336 [label="FullWidth 139334"];
3337 [label="this.AdjustFlagsAndWidth(trailing); 139335"];
3338 [label="return 'override'; 139336"];
3339 [label="FullWidth = this.Text.Length; 139337"];
3340 [label="FullWidth 139338"];
3341 [label="return 'override'; 139339"];
3342 [label="FullWidth = this.Text.Length; 139340"];
3343 [label="FullWidth 139341"];
3344 [label="this.AdjustFlagsAndWidth(leading); 139342"];
3345 [label="return 'override'; 139343"];
3346 [label="FullWidth = this.Text.Length; 139344"];
3347 [label="FullWidth 139345"];
3348 [label="this.AdjustFlagsAndWidth(trailing); 139346"];
3349 [label="return 'override'; 139347"];
3350 [label="FullWidth = this.Text.Length; 139348"];
3351 [label="FullWidth 139349"];
3352 [label="this.AdjustFlagsAndWidth(trailing); 139350"];
3353 [label="return 'abstract'; 139351"];
3354 [label="FullWidth = this.Text.Length; 139352"];
3355 [label="FullWidth 139353"];
3356 [label="return 'abstract'; 139354"];
3357 [label="FullWidth = this.Text.Length; 139355"];
3358 [label="FullWidth 139356"];
3359 [label="this.AdjustFlagsAndWidth(leading); 139357"];
3360 [label="return 'abstract'; 139358"];
3361 [label="FullWidth = this.Text.Length; 139359"];
3362 [label="FullWidth 139360"];
3363 [label="this.AdjustFlagsAndWidth(trailing); 139361"];
3364 [label="return 'abstract'; 139362"];
3365 [label="FullWidth = this.Text.Length; 139363"];
3366 [label="FullWidth 139364"];
3367 [label="this.AdjustFlagsAndWidth(trailing); 139365"];
3368 [label="return 'virtual'; 139366"];
3369 [label="FullWidth = this.Text.Length; 139367"];
3370 [label="FullWidth 139368"];
3371 [label="return 'virtual'; 139369"];
3372 [label="FullWidth = this.Text.Length; 139370"];
3373 [label="FullWidth 139371"];
3374 [label="this.AdjustFlagsAndWidth(leading); 139372"];
3375 [label="return 'virtual'; 139373"];
3376 [label="FullWidth = this.Text.Length; 139374"];
3377 [label="FullWidth 139375"];
3378 [label="this.AdjustFlagsAndWidth(trailing); 139376"];
3379 [label="return 'virtual'; 139377"];
3380 [label="FullWidth = this.Text.Length; 139378"];
3381 [label="FullWidth 139379"];
3382 [label="this.AdjustFlagsAndWidth(trailing); 139380"];
3383 [label="return 'event'; 139381"];
3384 [label="FullWidth = this.Text.Length; 139382"];
3385 [label="FullWidth 139383"];
3386 [label="return 'event'; 139384"];
3387 [label="FullWidth = this.Text.Length; 139385"];
3388 [label="FullWidth 139386"];
3389 [label="this.AdjustFlagsAndWidth(leading); 139387"];
3390 [label="return 'event'; 139388"];
3391 [label="FullWidth = this.Text.Length; 139389"];
3392 [label="FullWidth 139390"];
3393 [label="this.AdjustFlagsAndWidth(trailing); 139391"];
3394 [label="return 'event'; 139392"];
3395 [label="FullWidth = this.Text.Length; 139393"];
3396 [label="FullWidth 139394"];
3397 [label="this.AdjustFlagsAndWidth(trailing); 139395"];
3398 [label="return 'extern'; 139396"];
3399 [label="FullWidth = this.Text.Length; 139397"];
3400 [label="FullWidth 139398"];
3401 [label="return 'extern'; 139399"];
3402 [label="FullWidth = this.Text.Length; 139400"];
3403 [label="FullWidth 139401"];
3404 [label="this.AdjustFlagsAndWidth(leading); 139402"];
3405 [label="return 'extern'; 139403"];
3406 [label="FullWidth = this.Text.Length; 139404"];
3407 [label="FullWidth 139405"];
3408 [label="this.AdjustFlagsAndWidth(trailing); 139406"];
3409 [label="return 'extern'; 139407"];
3410 [label="FullWidth = this.Text.Length; 139408"];
3411 [label="FullWidth 139409"];
3412 [label="this.AdjustFlagsAndWidth(trailing); 139410"];
3413 [label="return 'ref'; 139411"];
3414 [label="FullWidth = this.Text.Length; 139412"];
3415 [label="FullWidth 139413"];
3416 [label="return 'ref'; 139414"];
3417 [label="FullWidth = this.Text.Length; 139415"];
3418 [label="FullWidth 139416"];
3419 [label="this.AdjustFlagsAndWidth(leading); 139417"];
3420 [label="return 'ref'; 139418"];
3421 [label="FullWidth = this.Text.Length; 139419"];
3422 [label="FullWidth 139420"];
3423 [label="this.AdjustFlagsAndWidth(trailing); 139421"];
3424 [label="return 'ref'; 139422"];
3425 [label="FullWidth = this.Text.Length; 139423"];
3426 [label="FullWidth 139424"];
3427 [label="this.AdjustFlagsAndWidth(trailing); 139425"];
3428 [label="return 'out'; 139426"];
3429 [label="FullWidth = this.Text.Length; 139427"];
3430 [label="FullWidth 139428"];
3431 [label="return 'out'; 139429"];
3432 [label="FullWidth = this.Text.Length; 139430"];
3433 [label="FullWidth 139431"];
3434 [label="this.AdjustFlagsAndWidth(leading); 139432"];
3435 [label="return 'out'; 139433"];
3436 [label="FullWidth = this.Text.Length; 139434"];
3437 [label="FullWidth 139435"];
3438 [label="this.AdjustFlagsAndWidth(trailing); 139436"];
3439 [label="return 'out'; 139437"];
3440 [label="FullWidth = this.Text.Length; 139438"];
3441 [label="FullWidth 139439"];
3442 [label="this.AdjustFlagsAndWidth(trailing); 139440"];
3443 [label="return 'in'; 139441"];
3444 [label="FullWidth = this.Text.Length; 139442"];
3445 [label="FullWidth 139443"];
3446 [label="return 'in'; 139444"];
3447 [label="FullWidth = this.Text.Length; 139445"];
3448 [label="FullWidth 139446"];
3449 [label="this.AdjustFlagsAndWidth(leading); 139447"];
3450 [label="return 'in'; 139448"];
3451 [label="FullWidth = this.Text.Length; 139449"];
3452 [label="FullWidth 139450"];
3453 [label="this.AdjustFlagsAndWidth(trailing); 139451"];
3454 [label="return 'in'; 139452"];
3455 [label="FullWidth = this.Text.Length; 139453"];
3456 [label="FullWidth 139454"];
3457 [label="this.AdjustFlagsAndWidth(trailing); 139455"];
3458 [label="return 'is'; 139456"];
3459 [label="FullWidth = this.Text.Length; 139457"];
3460 [label="FullWidth 139458"];
3461 [label="return 'is'; 139459"];
3462 [label="FullWidth = this.Text.Length; 139460"];
3463 [label="FullWidth 139461"];
3464 [label="this.AdjustFlagsAndWidth(leading); 139462"];
3465 [label="return 'is'; 139463"];
3466 [label="FullWidth = this.Text.Length; 139464"];
3467 [label="FullWidth 139465"];
3468 [label="this.AdjustFlagsAndWidth(trailing); 139466"];
3469 [label="return 'is'; 139467"];
3470 [label="FullWidth = this.Text.Length; 139468"];
3471 [label="FullWidth 139469"];
3472 [label="this.AdjustFlagsAndWidth(trailing); 139470"];
3473 [label="return 'as'; 139471"];
3474 [label="FullWidth = this.Text.Length; 139472"];
3475 [label="FullWidth 139473"];
3476 [label="return 'as'; 139474"];
3477 [label="FullWidth = this.Text.Length; 139475"];
3478 [label="FullWidth 139476"];
3479 [label="this.AdjustFlagsAndWidth(leading); 139477"];
3480 [label="return 'as'; 139478"];
3481 [label="FullWidth = this.Text.Length; 139479"];
3482 [label="FullWidth 139480"];
3483 [label="this.AdjustFlagsAndWidth(trailing); 139481"];
3484 [label="return 'as'; 139482"];
3485 [label="FullWidth = this.Text.Length; 139483"];
3486 [label="FullWidth 139484"];
3487 [label="this.AdjustFlagsAndWidth(trailing); 139485"];
3488 [label="return 'params'; 139486"];
3489 [label="FullWidth = this.Text.Length; 139487"];
3490 [label="FullWidth 139488"];
3491 [label="return 'params'; 139489"];
3492 [label="FullWidth = this.Text.Length; 139490"];
3493 [label="FullWidth 139491"];
3494 [label="this.AdjustFlagsAndWidth(leading); 139492"];
3495 [label="return 'params'; 139493"];
3496 [label="FullWidth = this.Text.Length; 139494"];
3497 [label="FullWidth 139495"];
3498 [label="this.AdjustFlagsAndWidth(trailing); 139496"];
3499 [label="return 'params'; 139497"];
3500 [label="FullWidth = this.Text.Length; 139498"];
3501 [label="FullWidth 139499"];
3502 [label="this.AdjustFlagsAndWidth(trailing); 139500"];
3503 [label="return '__arglist'; 139501"];
3504 [label="FullWidth = this.Text.Length; 139502"];
3505 [label="FullWidth 139503"];
3506 [label="return '__arglist'; 139504"];
3507 [label="FullWidth = this.Text.Length; 139505"];
3508 [label="FullWidth 139506"];
3509 [label="this.AdjustFlagsAndWidth(leading); 139507"];
3510 [label="return '__arglist'; 139508"];
3511 [label="FullWidth = this.Text.Length; 139509"];
3512 [label="FullWidth 139510"];
3513 [label="this.AdjustFlagsAndWidth(trailing); 139511"];
3514 [label="return '__arglist'; 139512"];
3515 [label="FullWidth = this.Text.Length; 139513"];
3516 [label="FullWidth 139514"];
3517 [label="this.AdjustFlagsAndWidth(trailing); 139515"];
3518 [label="return '__makeref'; 139516"];
3519 [label="FullWidth = this.Text.Length; 139517"];
3520 [label="FullWidth 139518"];
3521 [label="return '__makeref'; 139519"];
3522 [label="FullWidth = this.Text.Length; 139520"];
3523 [label="FullWidth 139521"];
3524 [label="this.AdjustFlagsAndWidth(leading); 139522"];
3525 [label="return '__makeref'; 139523"];
3526 [label="FullWidth = this.Text.Length; 139524"];
3527 [label="FullWidth 139525"];
3528 [label="this.AdjustFlagsAndWidth(trailing); 139526"];
3529 [label="return '__makeref'; 139527"];
3530 [label="FullWidth = this.Text.Length; 139528"];
3531 [label="FullWidth 139529"];
3532 [label="this.AdjustFlagsAndWidth(trailing); 139530"];
3533 [label="return '__reftype'; 139531"];
3534 [label="FullWidth = this.Text.Length; 139532"];
3535 [label="FullWidth 139533"];
3536 [label="return '__reftype'; 139534"];
3537 [label="FullWidth = this.Text.Length; 139535"];
3538 [label="FullWidth 139536"];
3539 [label="this.AdjustFlagsAndWidth(leading); 139537"];
3540 [label="return '__reftype'; 139538"];
3541 [label="FullWidth = this.Text.Length; 139539"];
3542 [label="FullWidth 139540"];
3543 [label="this.AdjustFlagsAndWidth(trailing); 139541"];
3544 [label="return '__reftype'; 139542"];
3545 [label="FullWidth = this.Text.Length; 139543"];
3546 [label="FullWidth 139544"];
3547 [label="this.AdjustFlagsAndWidth(trailing); 139545"];
3548 [label="return '__refvalue'; 139546"];
3549 [label="FullWidth = this.Text.Length; 139547"];
3550 [label="FullWidth 139548"];
3551 [label="return '__refvalue'; 139549"];
3552 [label="FullWidth = this.Text.Length; 139550"];
3553 [label="FullWidth 139551"];
3554 [label="this.AdjustFlagsAndWidth(leading); 139552"];
3555 [label="return '__refvalue'; 139553"];
3556 [label="FullWidth = this.Text.Length; 139554"];
3557 [label="FullWidth 139555"];
3558 [label="this.AdjustFlagsAndWidth(trailing); 139556"];
3559 [label="return '__refvalue'; 139557"];
3560 [label="FullWidth = this.Text.Length; 139558"];
3561 [label="FullWidth 139559"];
3562 [label="this.AdjustFlagsAndWidth(trailing); 139560"];
3563 [label="return 'this'; 139561"];
3564 [label="FullWidth = this.Text.Length; 139562"];
3565 [label="FullWidth 139563"];
3566 [label="return 'this'; 139564"];
3567 [label="FullWidth = this.Text.Length; 139565"];
3568 [label="FullWidth 139566"];
3569 [label="this.AdjustFlagsAndWidth(leading); 139567"];
3570 [label="return 'this'; 139568"];
3571 [label="FullWidth = this.Text.Length; 139569"];
3572 [label="FullWidth 139570"];
3573 [label="this.AdjustFlagsAndWidth(trailing); 139571"];
3574 [label="return 'this'; 139572"];
3575 [label="FullWidth = this.Text.Length; 139573"];
3576 [label="FullWidth 139574"];
3577 [label="this.AdjustFlagsAndWidth(trailing); 139575"];
3578 [label="return 'base'; 139576"];
3579 [label="FullWidth = this.Text.Length; 139577"];
3580 [label="FullWidth 139578"];
3581 [label="return 'base'; 139579"];
3582 [label="FullWidth = this.Text.Length; 139580"];
3583 [label="FullWidth 139581"];
3584 [label="this.AdjustFlagsAndWidth(leading); 139582"];
3585 [label="return 'base'; 139583"];
3586 [label="FullWidth = this.Text.Length; 139584"];
3587 [label="FullWidth 139585"];
3588 [label="this.AdjustFlagsAndWidth(trailing); 139586"];
3589 [label="return 'base'; 139587"];
3590 [label="FullWidth = this.Text.Length; 139588"];
3591 [label="FullWidth 139589"];
3592 [label="this.AdjustFlagsAndWidth(trailing); 139590"];
3593 [label="return 'namespace'; 139591"];
3594 [label="FullWidth = this.Text.Length; 139592"];
3595 [label="FullWidth 139593"];
3596 [label="return 'namespace'; 139594"];
3597 [label="FullWidth = this.Text.Length; 139595"];
3598 [label="FullWidth 139596"];
3599 [label="this.AdjustFlagsAndWidth(leading); 139597"];
3600 [label="return 'namespace'; 139598"];
3601 [label="FullWidth = this.Text.Length; 139599"];
3602 [label="FullWidth 139600"];
3603 [label="this.AdjustFlagsAndWidth(trailing); 139601"];
3604 [label="return 'namespace'; 139602"];
3605 [label="FullWidth = this.Text.Length; 139603"];
3606 [label="FullWidth 139604"];
3607 [label="this.AdjustFlagsAndWidth(trailing); 139605"];
3608 [label="return 'using'; 139606"];
3609 [label="FullWidth = this.Text.Length; 139607"];
3610 [label="FullWidth 139608"];
3611 [label="return 'using'; 139609"];
3612 [label="FullWidth = this.Text.Length; 139610"];
3613 [label="FullWidth 139611"];
3614 [label="this.AdjustFlagsAndWidth(leading); 139612"];
3615 [label="return 'using'; 139613"];
3616 [label="FullWidth = this.Text.Length; 139614"];
3617 [label="FullWidth 139615"];
3618 [label="this.AdjustFlagsAndWidth(trailing); 139616"];
3619 [label="return 'using'; 139617"];
3620 [label="FullWidth = this.Text.Length; 139618"];
3621 [label="FullWidth 139619"];
3622 [label="this.AdjustFlagsAndWidth(trailing); 139620"];
3623 [label="return 'class'; 139621"];
3624 [label="FullWidth = this.Text.Length; 139622"];
3625 [label="FullWidth 139623"];
3626 [label="return 'class'; 139624"];
3627 [label="FullWidth = this.Text.Length; 139625"];
3628 [label="FullWidth 139626"];
3629 [label="this.AdjustFlagsAndWidth(leading); 139627"];
3630 [label="return 'class'; 139628"];
3631 [label="FullWidth = this.Text.Length; 139629"];
3632 [label="FullWidth 139630"];
3633 [label="this.AdjustFlagsAndWidth(trailing); 139631"];
3634 [label="return 'class'; 139632"];
3635 [label="FullWidth = this.Text.Length; 139633"];
3636 [label="FullWidth 139634"];
3637 [label="this.AdjustFlagsAndWidth(trailing); 139635"];
3638 [label="return 'struct'; 139636"];
3639 [label="FullWidth = this.Text.Length; 139637"];
3640 [label="FullWidth 139638"];
3641 [label="return 'struct'; 139639"];
3642 [label="FullWidth = this.Text.Length; 139640"];
3643 [label="FullWidth 139641"];
3644 [label="this.AdjustFlagsAndWidth(leading); 139642"];
3645 [label="return 'struct'; 139643"];
3646 [label="FullWidth = this.Text.Length; 139644"];
3647 [label="FullWidth 139645"];
3648 [label="this.AdjustFlagsAndWidth(trailing); 139646"];
3649 [label="return 'struct'; 139647"];
3650 [label="FullWidth = this.Text.Length; 139648"];
3651 [label="FullWidth 139649"];
3652 [label="this.AdjustFlagsAndWidth(trailing); 139650"];
3653 [label="return 'interface'; 139651"];
3654 [label="FullWidth = this.Text.Length; 139652"];
3655 [label="FullWidth 139653"];
3656 [label="return 'interface'; 139654"];
3657 [label="FullWidth = this.Text.Length; 139655"];
3658 [label="FullWidth 139656"];
3659 [label="this.AdjustFlagsAndWidth(leading); 139657"];
3660 [label="return 'interface'; 139658"];
3661 [label="FullWidth = this.Text.Length; 139659"];
3662 [label="FullWidth 139660"];
3663 [label="this.AdjustFlagsAndWidth(trailing); 139661"];
3664 [label="return 'interface'; 139662"];
3665 [label="FullWidth = this.Text.Length; 139663"];
3666 [label="FullWidth 139664"];
3667 [label="this.AdjustFlagsAndWidth(trailing); 139665"];
3668 [label="return 'enum'; 139666"];
3669 [label="FullWidth = this.Text.Length; 139667"];
3670 [label="FullWidth 139668"];
3671 [label="return 'enum'; 139669"];
3672 [label="FullWidth = this.Text.Length; 139670"];
3673 [label="FullWidth 139671"];
3674 [label="this.AdjustFlagsAndWidth(leading); 139672"];
3675 [label="return 'enum'; 139673"];
3676 [label="FullWidth = this.Text.Length; 139674"];
3677 [label="FullWidth 139675"];
3678 [label="this.AdjustFlagsAndWidth(trailing); 139676"];
3679 [label="return 'enum'; 139677"];
3680 [label="FullWidth = this.Text.Length; 139678"];
3681 [label="FullWidth 139679"];
3682 [label="this.AdjustFlagsAndWidth(trailing); 139680"];
3683 [label="return 'delegate'; 139681"];
3684 [label="FullWidth = this.Text.Length; 139682"];
3685 [label="FullWidth 139683"];
3686 [label="return 'delegate'; 139684"];
3687 [label="FullWidth = this.Text.Length; 139685"];
3688 [label="FullWidth 139686"];
3689 [label="this.AdjustFlagsAndWidth(leading); 139687"];
3690 [label="return 'delegate'; 139688"];
3691 [label="FullWidth = this.Text.Length; 139689"];
3692 [label="FullWidth 139690"];
3693 [label="this.AdjustFlagsAndWidth(trailing); 139691"];
3694 [label="return 'delegate'; 139692"];
3695 [label="FullWidth = this.Text.Length; 139693"];
3696 [label="FullWidth 139694"];
3697 [label="this.AdjustFlagsAndWidth(trailing); 139695"];
3698 [label="return 'checked'; 139696"];
3699 [label="FullWidth = this.Text.Length; 139697"];
3700 [label="FullWidth 139698"];
3701 [label="return 'checked'; 139699"];
3702 [label="FullWidth = this.Text.Length; 139700"];
3703 [label="FullWidth 139701"];
3704 [label="this.AdjustFlagsAndWidth(leading); 139702"];
3705 [label="return 'checked'; 139703"];
3706 [label="FullWidth = this.Text.Length; 139704"];
3707 [label="FullWidth 139705"];
3708 [label="this.AdjustFlagsAndWidth(trailing); 139706"];
3709 [label="return 'checked'; 139707"];
3710 [label="FullWidth = this.Text.Length; 139708"];
3711 [label="FullWidth 139709"];
3712 [label="this.AdjustFlagsAndWidth(trailing); 139710"];
3713 [label="return 'unchecked'; 139711"];
3714 [label="FullWidth = this.Text.Length; 139712"];
3715 [label="FullWidth 139713"];
3716 [label="return 'unchecked'; 139714"];
3717 [label="FullWidth = this.Text.Length; 139715"];
3718 [label="FullWidth 139716"];
3719 [label="this.AdjustFlagsAndWidth(leading); 139717"];
3720 [label="return 'unchecked'; 139718"];
3721 [label="FullWidth = this.Text.Length; 139719"];
3722 [label="FullWidth 139720"];
3723 [label="this.AdjustFlagsAndWidth(trailing); 139721"];
3724 [label="return 'unchecked'; 139722"];
3725 [label="FullWidth = this.Text.Length; 139723"];
3726 [label="FullWidth 139724"];
3727 [label="this.AdjustFlagsAndWidth(trailing); 139725"];
3728 [label="return 'unsafe'; 139726"];
3729 [label="FullWidth = this.Text.Length; 139727"];
3730 [label="FullWidth 139728"];
3731 [label="return 'unsafe'; 139729"];
3732 [label="FullWidth = this.Text.Length; 139730"];
3733 [label="FullWidth 139731"];
3734 [label="this.AdjustFlagsAndWidth(leading); 139732"];
3735 [label="return 'unsafe'; 139733"];
3736 [label="FullWidth = this.Text.Length; 139734"];
3737 [label="FullWidth 139735"];
3738 [label="this.AdjustFlagsAndWidth(trailing); 139736"];
3739 [label="return 'unsafe'; 139737"];
3740 [label="FullWidth = this.Text.Length; 139738"];
3741 [label="FullWidth 139739"];
3742 [label="this.AdjustFlagsAndWidth(trailing); 139740"];
3743 [label="return 'operator'; 139741"];
3744 [label="FullWidth = this.Text.Length; 139742"];
3745 [label="FullWidth 139743"];
3746 [label="return 'operator'; 139744"];
3747 [label="FullWidth = this.Text.Length; 139745"];
3748 [label="FullWidth 139746"];
3749 [label="this.AdjustFlagsAndWidth(leading); 139747"];
3750 [label="return 'operator'; 139748"];
3751 [label="FullWidth = this.Text.Length; 139749"];
3752 [label="FullWidth 139750"];
3753 [label="this.AdjustFlagsAndWidth(trailing); 139751"];
3754 [label="return 'operator'; 139752"];
3755 [label="FullWidth = this.Text.Length; 139753"];
3756 [label="FullWidth 139754"];
3757 [label="this.AdjustFlagsAndWidth(trailing); 139755"];
3758 [label="return 'explicit'; 139756"];
3759 [label="FullWidth = this.Text.Length; 139757"];
3760 [label="FullWidth 139758"];
3761 [label="return 'explicit'; 139759"];
3762 [label="FullWidth = this.Text.Length; 139760"];
3763 [label="FullWidth 139761"];
3764 [label="this.AdjustFlagsAndWidth(leading); 139762"];
3765 [label="return 'explicit'; 139763"];
3766 [label="FullWidth = this.Text.Length; 139764"];
3767 [label="FullWidth 139765"];
3768 [label="this.AdjustFlagsAndWidth(trailing); 139766"];
3769 [label="return 'explicit'; 139767"];
3770 [label="FullWidth = this.Text.Length; 139768"];
3771 [label="FullWidth 139769"];
3772 [label="this.AdjustFlagsAndWidth(trailing); 139770"];
3773 [label="return 'implicit'; 139771"];
3774 [label="FullWidth = this.Text.Length; 139772"];
3775 [label="FullWidth 139773"];
3776 [label="return 'implicit'; 139774"];
3777 [label="FullWidth = this.Text.Length; 139775"];
3778 [label="FullWidth 139776"];
3779 [label="this.AdjustFlagsAndWidth(leading); 139777"];
3780 [label="return 'implicit'; 139778"];
3781 [label="FullWidth = this.Text.Length; 139779"];
3782 [label="FullWidth 139780"];
3783 [label="this.AdjustFlagsAndWidth(trailing); 139781"];
3784 [label="return 'implicit'; 139782"];
3785 [label="FullWidth = this.Text.Length; 139783"];
3786 [label="FullWidth 139784"];
3787 [label="this.AdjustFlagsAndWidth(trailing); 139785"];
3788 [label="return 'yield'; 139786"];
3789 [label="FullWidth = this.Text.Length; 139787"];
3790 [label="FullWidth 139788"];
3791 [label="return 'yield'; 139789"];
3792 [label="FullWidth = this.Text.Length; 139790"];
3793 [label="FullWidth 139791"];
3794 [label="this.AdjustFlagsAndWidth(leading); 139792"];
3795 [label="return 'yield'; 139793"];
3796 [label="FullWidth = this.Text.Length; 139794"];
3797 [label="FullWidth 139795"];
3798 [label="this.AdjustFlagsAndWidth(trailing); 139796"];
3799 [label="return 'yield'; 139797"];
3800 [label="FullWidth = this.Text.Length; 139798"];
3801 [label="FullWidth 139799"];
3802 [label="this.AdjustFlagsAndWidth(trailing); 139800"];
3803 [label="return 'partial'; 139801"];
3804 [label="FullWidth = this.Text.Length; 139802"];
3805 [label="FullWidth 139803"];
3806 [label="return 'partial'; 139804"];
3807 [label="FullWidth = this.Text.Length; 139805"];
3808 [label="FullWidth 139806"];
3809 [label="this.AdjustFlagsAndWidth(leading); 139807"];
3810 [label="return 'partial'; 139808"];
3811 [label="FullWidth = this.Text.Length; 139809"];
3812 [label="FullWidth 139810"];
3813 [label="this.AdjustFlagsAndWidth(trailing); 139811"];
3814 [label="return 'partial'; 139812"];
3815 [label="FullWidth = this.Text.Length; 139813"];
3816 [label="FullWidth 139814"];
3817 [label="this.AdjustFlagsAndWidth(trailing); 139815"];
3818 [label="return 'alias'; 139816"];
3819 [label="FullWidth = this.Text.Length; 139817"];
3820 [label="FullWidth 139818"];
3821 [label="return 'alias'; 139819"];
3822 [label="FullWidth = this.Text.Length; 139820"];
3823 [label="FullWidth 139821"];
3824 [label="this.AdjustFlagsAndWidth(leading); 139822"];
3825 [label="return 'alias'; 139823"];
3826 [label="FullWidth = this.Text.Length; 139824"];
3827 [label="FullWidth 139825"];
3828 [label="this.AdjustFlagsAndWidth(trailing); 139826"];
3829 [label="return 'alias'; 139827"];
3830 [label="FullWidth = this.Text.Length; 139828"];
3831 [label="FullWidth 139829"];
3832 [label="this.AdjustFlagsAndWidth(trailing); 139830"];
3833 [label="return 'global'; 139831"];
3834 [label="FullWidth = this.Text.Length; 139832"];
3835 [label="FullWidth 139833"];
3836 [label="return 'global'; 139834"];
3837 [label="FullWidth = this.Text.Length; 139835"];
3838 [label="FullWidth 139836"];
3839 [label="this.AdjustFlagsAndWidth(leading); 139837"];
3840 [label="return 'global'; 139838"];
3841 [label="FullWidth = this.Text.Length; 139839"];
3842 [label="FullWidth 139840"];
3843 [label="this.AdjustFlagsAndWidth(trailing); 139841"];
3844 [label="return 'global'; 139842"];
3845 [label="FullWidth = this.Text.Length; 139843"];
3846 [label="FullWidth 139844"];
3847 [label="this.AdjustFlagsAndWidth(trailing); 139845"];
3848 [label="return 'assembly'; 139846"];
3849 [label="FullWidth = this.Text.Length; 139847"];
3850 [label="FullWidth 139848"];
3851 [label="return 'assembly'; 139849"];
3852 [label="FullWidth = this.Text.Length; 139850"];
3853 [label="FullWidth 139851"];
3854 [label="this.AdjustFlagsAndWidth(leading); 139852"];
3855 [label="return 'assembly'; 139853"];
3856 [label="FullWidth = this.Text.Length; 139854"];
3857 [label="FullWidth 139855"];
3858 [label="this.AdjustFlagsAndWidth(trailing); 139856"];
3859 [label="return 'assembly'; 139857"];
3860 [label="FullWidth = this.Text.Length; 139858"];
3861 [label="FullWidth 139859"];
3862 [label="this.AdjustFlagsAndWidth(trailing); 139860"];
3863 [label="return 'module'; 139861"];
3864 [label="FullWidth = this.Text.Length; 139862"];
3865 [label="FullWidth 139863"];
3866 [label="return 'module'; 139864"];
3867 [label="FullWidth = this.Text.Length; 139865"];
3868 [label="FullWidth 139866"];
3869 [label="this.AdjustFlagsAndWidth(leading); 139867"];
3870 [label="return 'module'; 139868"];
3871 [label="FullWidth = this.Text.Length; 139869"];
3872 [label="FullWidth 139870"];
3873 [label="this.AdjustFlagsAndWidth(trailing); 139871"];
3874 [label="return 'module'; 139872"];
3875 [label="FullWidth = this.Text.Length; 139873"];
3876 [label="FullWidth 139874"];
3877 [label="this.AdjustFlagsAndWidth(trailing); 139875"];
3878 [label="return 'type'; 139876"];
3879 [label="FullWidth = this.Text.Length; 139877"];
3880 [label="FullWidth 139878"];
3881 [label="return 'type'; 139879"];
3882 [label="FullWidth = this.Text.Length; 139880"];
3883 [label="FullWidth 139881"];
3884 [label="this.AdjustFlagsAndWidth(leading); 139882"];
3885 [label="return 'type'; 139883"];
3886 [label="FullWidth = this.Text.Length; 139884"];
3887 [label="FullWidth 139885"];
3888 [label="this.AdjustFlagsAndWidth(trailing); 139886"];
3889 [label="return 'type'; 139887"];
3890 [label="FullWidth = this.Text.Length; 139888"];
3891 [label="FullWidth 139889"];
3892 [label="this.AdjustFlagsAndWidth(trailing); 139890"];
3893 [label="return 'field'; 139891"];
3894 [label="FullWidth = this.Text.Length; 139892"];
3895 [label="FullWidth 139893"];
3896 [label="return 'field'; 139894"];
3897 [label="FullWidth = this.Text.Length; 139895"];
3898 [label="FullWidth 139896"];
3899 [label="this.AdjustFlagsAndWidth(leading); 139897"];
3900 [label="return 'field'; 139898"];
3901 [label="FullWidth = this.Text.Length; 139899"];
3902 [label="FullWidth 139900"];
3903 [label="this.AdjustFlagsAndWidth(trailing); 139901"];
3904 [label="return 'field'; 139902"];
3905 [label="FullWidth = this.Text.Length; 139903"];
3906 [label="FullWidth 139904"];
3907 [label="this.AdjustFlagsAndWidth(trailing); 139905"];
3908 [label="return 'method'; 139906"];
3909 [label="FullWidth = this.Text.Length; 139907"];
3910 [label="FullWidth 139908"];
3911 [label="return 'method'; 139909"];
3912 [label="FullWidth = this.Text.Length; 139910"];
3913 [label="FullWidth 139911"];
3914 [label="this.AdjustFlagsAndWidth(leading); 139912"];
3915 [label="return 'method'; 139913"];
3916 [label="FullWidth = this.Text.Length; 139914"];
3917 [label="FullWidth 139915"];
3918 [label="this.AdjustFlagsAndWidth(trailing); 139916"];
3919 [label="return 'method'; 139917"];
3920 [label="FullWidth = this.Text.Length; 139918"];
3921 [label="FullWidth 139919"];
3922 [label="this.AdjustFlagsAndWidth(trailing); 139920"];
3923 [label="return 'param'; 139921"];
3924 [label="FullWidth = this.Text.Length; 139922"];
3925 [label="FullWidth 139923"];
3926 [label="return 'param'; 139924"];
3927 [label="FullWidth = this.Text.Length; 139925"];
3928 [label="FullWidth 139926"];
3929 [label="this.AdjustFlagsAndWidth(leading); 139927"];
3930 [label="return 'param'; 139928"];
3931 [label="FullWidth = this.Text.Length; 139929"];
3932 [label="FullWidth 139930"];
3933 [label="this.AdjustFlagsAndWidth(trailing); 139931"];
3934 [label="return 'param'; 139932"];
3935 [label="FullWidth = this.Text.Length; 139933"];
3936 [label="FullWidth 139934"];
3937 [label="this.AdjustFlagsAndWidth(trailing); 139935"];
3938 [label="return 'property'; 139936"];
3939 [label="FullWidth = this.Text.Length; 139937"];
3940 [label="FullWidth 139938"];
3941 [label="return 'property'; 139939"];
3942 [label="FullWidth = this.Text.Length; 139940"];
3943 [label="FullWidth 139941"];
3944 [label="this.AdjustFlagsAndWidth(leading); 139942"];
3945 [label="return 'property'; 139943"];
3946 [label="FullWidth = this.Text.Length; 139944"];
3947 [label="FullWidth 139945"];
3948 [label="this.AdjustFlagsAndWidth(trailing); 139946"];
3949 [label="return 'property'; 139947"];
3950 [label="FullWidth = this.Text.Length; 139948"];
3951 [label="FullWidth 139949"];
3952 [label="this.AdjustFlagsAndWidth(trailing); 139950"];
3953 [label="return 'typevar'; 139951"];
3954 [label="FullWidth = this.Text.Length; 139952"];
3955 [label="FullWidth 139953"];
3956 [label="return 'typevar'; 139954"];
3957 [label="FullWidth = this.Text.Length; 139955"];
3958 [label="FullWidth 139956"];
3959 [label="this.AdjustFlagsAndWidth(leading); 139957"];
3960 [label="return 'typevar'; 139958"];
3961 [label="FullWidth = this.Text.Length; 139959"];
3962 [label="FullWidth 139960"];
3963 [label="this.AdjustFlagsAndWidth(trailing); 139961"];
3964 [label="return 'typevar'; 139962"];
3965 [label="FullWidth = this.Text.Length; 139963"];
3966 [label="FullWidth 139964"];
3967 [label="this.AdjustFlagsAndWidth(trailing); 139965"];
3968 [label="return 'get'; 139966"];
3969 [label="FullWidth = this.Text.Length; 139967"];
3970 [label="FullWidth 139968"];
3971 [label="return 'get'; 139969"];
3972 [label="FullWidth = this.Text.Length; 139970"];
3973 [label="FullWidth 139971"];
3974 [label="this.AdjustFlagsAndWidth(leading); 139972"];
3975 [label="return 'get'; 139973"];
3976 [label="FullWidth = this.Text.Length; 139974"];
3977 [label="FullWidth 139975"];
3978 [label="this.AdjustFlagsAndWidth(trailing); 139976"];
3979 [label="return 'get'; 139977"];
3980 [label="FullWidth = this.Text.Length; 139978"];
3981 [label="FullWidth 139979"];
3982 [label="this.AdjustFlagsAndWidth(trailing); 139980"];
3983 [label="return 'set'; 139981"];
3984 [label="FullWidth = this.Text.Length; 139982"];
3985 [label="FullWidth 139983"];
3986 [label="return 'set'; 139984"];
3987 [label="FullWidth = this.Text.Length; 139985"];
3988 [label="FullWidth 139986"];
3989 [label="this.AdjustFlagsAndWidth(leading); 139987"];
3990 [label="return 'set'; 139988"];
3991 [label="FullWidth = this.Text.Length; 139989"];
3992 [label="FullWidth 139990"];
3993 [label="this.AdjustFlagsAndWidth(trailing); 139991"];
3994 [label="return 'set'; 139992"];
3995 [label="FullWidth = this.Text.Length; 139993"];
3996 [label="FullWidth 139994"];
3997 [label="this.AdjustFlagsAndWidth(trailing); 139995"];
3998 [label="return 'add'; 139996"];
3999 [label="FullWidth = this.Text.Length; 139997"];
4000 [label="FullWidth 139998"];
4001 [label="return 'add'; 139999"];
4002 [label="FullWidth = this.Text.Length; 140000"];
4003 [label="FullWidth 140001"];
4004 [label="this.AdjustFlagsAndWidth(leading); 140002"];
4005 [label="return 'add'; 140003"];
4006 [label="FullWidth = this.Text.Length; 140004"];
4007 [label="FullWidth 140005"];
4008 [label="this.AdjustFlagsAndWidth(trailing); 140006"];
4009 [label="return 'add'; 140007"];
4010 [label="FullWidth = this.Text.Length; 140008"];
4011 [label="FullWidth 140009"];
4012 [label="this.AdjustFlagsAndWidth(trailing); 140010"];
4013 [label="return 'remove'; 140011"];
4014 [label="FullWidth = this.Text.Length; 140012"];
4015 [label="FullWidth 140013"];
4016 [label="return 'remove'; 140014"];
4017 [label="FullWidth = this.Text.Length; 140015"];
4018 [label="FullWidth 140016"];
4019 [label="this.AdjustFlagsAndWidth(leading); 140017"];
4020 [label="return 'remove'; 140018"];
4021 [label="FullWidth = this.Text.Length; 140019"];
4022 [label="FullWidth 140020"];
4023 [label="this.AdjustFlagsAndWidth(trailing); 140021"];
4024 [label="return 'remove'; 140022"];
4025 [label="FullWidth = this.Text.Length; 140023"];
4026 [label="FullWidth 140024"];
4027 [label="this.AdjustFlagsAndWidth(trailing); 140025"];
4028 [label="return 'where'; 140026"];
4029 [label="FullWidth = this.Text.Length; 140027"];
4030 [label="FullWidth 140028"];
4031 [label="return 'where'; 140029"];
4032 [label="FullWidth = this.Text.Length; 140030"];
4033 [label="FullWidth 140031"];
4034 [label="this.AdjustFlagsAndWidth(leading); 140032"];
4035 [label="return 'where'; 140033"];
4036 [label="FullWidth = this.Text.Length; 140034"];
4037 [label="FullWidth 140035"];
4038 [label="this.AdjustFlagsAndWidth(trailing); 140036"];
4039 [label="return 'where'; 140037"];
4040 [label="FullWidth = this.Text.Length; 140038"];
4041 [label="FullWidth 140039"];
4042 [label="this.AdjustFlagsAndWidth(trailing); 140040"];
4043 [label="return 'from'; 140041"];
4044 [label="FullWidth = this.Text.Length; 140042"];
4045 [label="FullWidth 140043"];
4046 [label="return 'from'; 140044"];
4047 [label="FullWidth = this.Text.Length; 140045"];
4048 [label="FullWidth 140046"];
4049 [label="this.AdjustFlagsAndWidth(leading); 140047"];
4050 [label="return 'from'; 140048"];
4051 [label="FullWidth = this.Text.Length; 140049"];
4052 [label="FullWidth 140050"];
4053 [label="this.AdjustFlagsAndWidth(trailing); 140051"];
4054 [label="return 'from'; 140052"];
4055 [label="FullWidth = this.Text.Length; 140053"];
4056 [label="FullWidth 140054"];
4057 [label="this.AdjustFlagsAndWidth(trailing); 140055"];
4058 [label="return 'group'; 140056"];
4059 [label="FullWidth = this.Text.Length; 140057"];
4060 [label="FullWidth 140058"];
4061 [label="return 'group'; 140059"];
4062 [label="FullWidth = this.Text.Length; 140060"];
4063 [label="FullWidth 140061"];
4064 [label="this.AdjustFlagsAndWidth(leading); 140062"];
4065 [label="return 'group'; 140063"];
4066 [label="FullWidth = this.Text.Length; 140064"];
4067 [label="FullWidth 140065"];
4068 [label="this.AdjustFlagsAndWidth(trailing); 140066"];
4069 [label="return 'group'; 140067"];
4070 [label="FullWidth = this.Text.Length; 140068"];
4071 [label="FullWidth 140069"];
4072 [label="this.AdjustFlagsAndWidth(trailing); 140070"];
4073 [label="return 'join'; 140071"];
4074 [label="FullWidth = this.Text.Length; 140072"];
4075 [label="FullWidth 140073"];
4076 [label="return 'join'; 140074"];
4077 [label="FullWidth = this.Text.Length; 140075"];
4078 [label="FullWidth 140076"];
4079 [label="this.AdjustFlagsAndWidth(leading); 140077"];
4080 [label="return 'join'; 140078"];
4081 [label="FullWidth = this.Text.Length; 140079"];
4082 [label="FullWidth 140080"];
4083 [label="this.AdjustFlagsAndWidth(trailing); 140081"];
4084 [label="return 'join'; 140082"];
4085 [label="FullWidth = this.Text.Length; 140083"];
4086 [label="FullWidth 140084"];
4087 [label="this.AdjustFlagsAndWidth(trailing); 140085"];
4088 [label="return 'into'; 140086"];
4089 [label="FullWidth = this.Text.Length; 140087"];
4090 [label="FullWidth 140088"];
4091 [label="return 'into'; 140089"];
4092 [label="FullWidth = this.Text.Length; 140090"];
4093 [label="FullWidth 140091"];
4094 [label="this.AdjustFlagsAndWidth(leading); 140092"];
4095 [label="return 'into'; 140093"];
4096 [label="FullWidth = this.Text.Length; 140094"];
4097 [label="FullWidth 140095"];
4098 [label="this.AdjustFlagsAndWidth(trailing); 140096"];
4099 [label="return 'into'; 140097"];
4100 [label="FullWidth = this.Text.Length; 140098"];
4101 [label="FullWidth 140099"];
4102 [label="this.AdjustFlagsAndWidth(trailing); 140100"];
4103 [label="return 'let'; 140101"];
4104 [label="FullWidth = this.Text.Length; 140102"];
4105 [label="FullWidth 140103"];
4106 [label="return 'let'; 140104"];
4107 [label="FullWidth = this.Text.Length; 140105"];
4108 [label="FullWidth 140106"];
4109 [label="this.AdjustFlagsAndWidth(leading); 140107"];
4110 [label="return 'let'; 140108"];
4111 [label="FullWidth = this.Text.Length; 140109"];
4112 [label="FullWidth 140110"];
4113 [label="this.AdjustFlagsAndWidth(trailing); 140111"];
4114 [label="return 'let'; 140112"];
4115 [label="FullWidth = this.Text.Length; 140113"];
4116 [label="FullWidth 140114"];
4117 [label="this.AdjustFlagsAndWidth(trailing); 140115"];
4118 [label="return 'by'; 140116"];
4119 [label="FullWidth = this.Text.Length; 140117"];
4120 [label="FullWidth 140118"];
4121 [label="return 'by'; 140119"];
4122 [label="FullWidth = this.Text.Length; 140120"];
4123 [label="FullWidth 140121"];
4124 [label="this.AdjustFlagsAndWidth(leading); 140122"];
4125 [label="return 'by'; 140123"];
4126 [label="FullWidth = this.Text.Length; 140124"];
4127 [label="FullWidth 140125"];
4128 [label="this.AdjustFlagsAndWidth(trailing); 140126"];
4129 [label="return 'by'; 140127"];
4130 [label="FullWidth = this.Text.Length; 140128"];
4131 [label="FullWidth 140129"];
4132 [label="this.AdjustFlagsAndWidth(trailing); 140130"];
4133 [label="return 'select'; 140131"];
4134 [label="FullWidth = this.Text.Length; 140132"];
4135 [label="FullWidth 140133"];
4136 [label="return 'select'; 140134"];
4137 [label="FullWidth = this.Text.Length; 140135"];
4138 [label="FullWidth 140136"];
4139 [label="this.AdjustFlagsAndWidth(leading); 140137"];
4140 [label="return 'select'; 140138"];
4141 [label="FullWidth = this.Text.Length; 140139"];
4142 [label="FullWidth 140140"];
4143 [label="this.AdjustFlagsAndWidth(trailing); 140141"];
4144 [label="return 'select'; 140142"];
4145 [label="FullWidth = this.Text.Length; 140143"];
4146 [label="FullWidth 140144"];
4147 [label="this.AdjustFlagsAndWidth(trailing); 140145"];
4148 [label="return 'orderby'; 140146"];
4149 [label="FullWidth = this.Text.Length; 140147"];
4150 [label="FullWidth 140148"];
4151 [label="return 'orderby'; 140149"];
4152 [label="FullWidth = this.Text.Length; 140150"];
4153 [label="FullWidth 140151"];
4154 [label="this.AdjustFlagsAndWidth(leading); 140152"];
4155 [label="return 'orderby'; 140153"];
4156 [label="FullWidth = this.Text.Length; 140154"];
4157 [label="FullWidth 140155"];
4158 [label="this.AdjustFlagsAndWidth(trailing); 140156"];
4159 [label="return 'orderby'; 140157"];
4160 [label="FullWidth = this.Text.Length; 140158"];
4161 [label="FullWidth 140159"];
4162 [label="this.AdjustFlagsAndWidth(trailing); 140160"];
4163 [label="return 'on'; 140161"];
4164 [label="FullWidth = this.Text.Length; 140162"];
4165 [label="FullWidth 140163"];
4166 [label="return 'on'; 140164"];
4167 [label="FullWidth = this.Text.Length; 140165"];
4168 [label="FullWidth 140166"];
4169 [label="this.AdjustFlagsAndWidth(leading); 140167"];
4170 [label="return 'on'; 140168"];
4171 [label="FullWidth = this.Text.Length; 140169"];
4172 [label="FullWidth 140170"];
4173 [label="this.AdjustFlagsAndWidth(trailing); 140171"];
4174 [label="return 'on'; 140172"];
4175 [label="FullWidth = this.Text.Length; 140173"];
4176 [label="FullWidth 140174"];
4177 [label="this.AdjustFlagsAndWidth(trailing); 140175"];
4178 [label="return 'equals'; 140176"];
4179 [label="FullWidth = this.Text.Length; 140177"];
4180 [label="FullWidth 140178"];
4181 [label="return 'equals'; 140179"];
4182 [label="FullWidth = this.Text.Length; 140180"];
4183 [label="FullWidth 140181"];
4184 [label="this.AdjustFlagsAndWidth(leading); 140182"];
4185 [label="return 'equals'; 140183"];
4186 [label="FullWidth = this.Text.Length; 140184"];
4187 [label="FullWidth 140185"];
4188 [label="this.AdjustFlagsAndWidth(trailing); 140186"];
4189 [label="return 'equals'; 140187"];
4190 [label="FullWidth = this.Text.Length; 140188"];
4191 [label="FullWidth 140189"];
4192 [label="this.AdjustFlagsAndWidth(trailing); 140190"];
4193 [label="return 'ascending'; 140191"];
4194 [label="FullWidth = this.Text.Length; 140192"];
4195 [label="FullWidth 140193"];
4196 [label="return 'ascending'; 140194"];
4197 [label="FullWidth = this.Text.Length; 140195"];
4198 [label="FullWidth 140196"];
4199 [label="this.AdjustFlagsAndWidth(leading); 140197"];
4200 [label="return 'ascending'; 140198"];
4201 [label="FullWidth = this.Text.Length; 140199"];
4202 [label="FullWidth 140200"];
4203 [label="this.AdjustFlagsAndWidth(trailing); 140201"];
4204 [label="return 'ascending'; 140202"];
4205 [label="FullWidth = this.Text.Length; 140203"];
4206 [label="FullWidth 140204"];
4207 [label="this.AdjustFlagsAndWidth(trailing); 140205"];
4208 [label="return 'descending'; 140206"];
4209 [label="FullWidth = this.Text.Length; 140207"];
4210 [label="FullWidth 140208"];
4211 [label="return 'descending'; 140209"];
4212 [label="FullWidth = this.Text.Length; 140210"];
4213 [label="FullWidth 140211"];
4214 [label="this.AdjustFlagsAndWidth(leading); 140212"];
4215 [label="return 'descending'; 140213"];
4216 [label="FullWidth = this.Text.Length; 140214"];
4217 [label="FullWidth 140215"];
4218 [label="this.AdjustFlagsAndWidth(trailing); 140216"];
4219 [label="return 'descending'; 140217"];
4220 [label="FullWidth = this.Text.Length; 140218"];
4221 [label="FullWidth 140219"];
4222 [label="this.AdjustFlagsAndWidth(trailing); 140220"];
4223 [label="return 'nameof'; 140221"];
4224 [label="FullWidth = this.Text.Length; 140222"];
4225 [label="FullWidth 140223"];
4226 [label="return 'nameof'; 140224"];
4227 [label="FullWidth = this.Text.Length; 140225"];
4228 [label="FullWidth 140226"];
4229 [label="this.AdjustFlagsAndWidth(leading); 140227"];
4230 [label="return 'nameof'; 140228"];
4231 [label="FullWidth = this.Text.Length; 140229"];
4232 [label="FullWidth 140230"];
4233 [label="this.AdjustFlagsAndWidth(trailing); 140231"];
4234 [label="return 'nameof'; 140232"];
4235 [label="FullWidth = this.Text.Length; 140233"];
4236 [label="FullWidth 140234"];
4237 [label="this.AdjustFlagsAndWidth(trailing); 140235"];
4238 [label="return 'async'; 140236"];
4239 [label="FullWidth = this.Text.Length; 140237"];
4240 [label="FullWidth 140238"];
4241 [label="return 'async'; 140239"];
4242 [label="FullWidth = this.Text.Length; 140240"];
4243 [label="FullWidth 140241"];
4244 [label="this.AdjustFlagsAndWidth(leading); 140242"];
4245 [label="return 'async'; 140243"];
4246 [label="FullWidth = this.Text.Length; 140244"];
4247 [label="FullWidth 140245"];
4248 [label="this.AdjustFlagsAndWidth(trailing); 140246"];
4249 [label="return 'async'; 140247"];
4250 [label="FullWidth = this.Text.Length; 140248"];
4251 [label="FullWidth 140249"];
4252 [label="this.AdjustFlagsAndWidth(trailing); 140250"];
4253 [label="return 'await'; 140251"];
4254 [label="FullWidth = this.Text.Length; 140252"];
4255 [label="FullWidth 140253"];
4256 [label="return 'await'; 140254"];
4257 [label="FullWidth = this.Text.Length; 140255"];
4258 [label="FullWidth 140256"];
4259 [label="this.AdjustFlagsAndWidth(leading); 140257"];
4260 [label="return 'await'; 140258"];
4261 [label="FullWidth = this.Text.Length; 140259"];
4262 [label="FullWidth 140260"];
4263 [label="this.AdjustFlagsAndWidth(trailing); 140261"];
4264 [label="return 'await'; 140262"];
4265 [label="FullWidth = this.Text.Length; 140263"];
4266 [label="FullWidth 140264"];
4267 [label="this.AdjustFlagsAndWidth(trailing); 140265"];
4268 [label="return 'when'; 140266"];
4269 [label="FullWidth = this.Text.Length; 140267"];
4270 [label="FullWidth 140268"];
4271 [label="return 'when'; 140269"];
4272 [label="FullWidth = this.Text.Length; 140270"];
4273 [label="FullWidth 140271"];
4274 [label="this.AdjustFlagsAndWidth(leading); 140272"];
4275 [label="return 'when'; 140273"];
4276 [label="FullWidth = this.Text.Length; 140274"];
4277 [label="FullWidth 140275"];
4278 [label="this.AdjustFlagsAndWidth(trailing); 140276"];
4279 [label="return 'when'; 140277"];
4280 [label="FullWidth = this.Text.Length; 140278"];
4281 [label="FullWidth 140279"];
4282 [label="this.AdjustFlagsAndWidth(trailing); 140280"];
4283 [label="return 'or'; 140281"];
4284 [label="FullWidth = this.Text.Length; 140282"];
4285 [label="FullWidth 140283"];
4286 [label="return 'or'; 140284"];
4287 [label="FullWidth = this.Text.Length; 140285"];
4288 [label="FullWidth 140286"];
4289 [label="this.AdjustFlagsAndWidth(leading); 140287"];
4290 [label="return 'or'; 140288"];
4291 [label="FullWidth = this.Text.Length; 140289"];
4292 [label="FullWidth 140290"];
4293 [label="this.AdjustFlagsAndWidth(trailing); 140291"];
4294 [label="return 'or'; 140292"];
4295 [label="FullWidth = this.Text.Length; 140293"];
4296 [label="FullWidth 140294"];
4297 [label="this.AdjustFlagsAndWidth(trailing); 140295"];
4298 [label="return 'and'; 140296"];
4299 [label="FullWidth = this.Text.Length; 140297"];
4300 [label="FullWidth 140298"];
4301 [label="return 'and'; 140299"];
4302 [label="FullWidth = this.Text.Length; 140300"];
4303 [label="FullWidth 140301"];
4304 [label="this.AdjustFlagsAndWidth(leading); 140302"];
4305 [label="return 'and'; 140303"];
4306 [label="FullWidth = this.Text.Length; 140304"];
4307 [label="FullWidth 140305"];
4308 [label="this.AdjustFlagsAndWidth(trailing); 140306"];
4309 [label="return 'and'; 140307"];
4310 [label="FullWidth = this.Text.Length; 140308"];
4311 [label="FullWidth 140309"];
4312 [label="this.AdjustFlagsAndWidth(trailing); 140310"];
4313 [label="return 'not'; 140311"];
4314 [label="FullWidth = this.Text.Length; 140312"];
4315 [label="FullWidth 140313"];
4316 [label="return 'not'; 140314"];
4317 [label="FullWidth = this.Text.Length; 140315"];
4318 [label="FullWidth 140316"];
4319 [label="this.AdjustFlagsAndWidth(leading); 140317"];
4320 [label="return 'not'; 140318"];
4321 [label="FullWidth = this.Text.Length; 140319"];
4322 [label="FullWidth 140320"];
4323 [label="this.AdjustFlagsAndWidth(trailing); 140321"];
4324 [label="return 'not'; 140322"];
4325 [label="FullWidth = this.Text.Length; 140323"];
4326 [label="FullWidth 140324"];
4327 [label="this.AdjustFlagsAndWidth(trailing); 140325"];
4328 [label="return 'data'; 140326"];
4329 [label="FullWidth = this.Text.Length; 140327"];
4330 [label="FullWidth 140328"];
4331 [label="return 'data'; 140329"];
4332 [label="FullWidth = this.Text.Length; 140330"];
4333 [label="FullWidth 140331"];
4334 [label="this.AdjustFlagsAndWidth(leading); 140332"];
4335 [label="return 'data'; 140333"];
4336 [label="FullWidth = this.Text.Length; 140334"];
4337 [label="FullWidth 140335"];
4338 [label="this.AdjustFlagsAndWidth(trailing); 140336"];
4339 [label="return 'data'; 140337"];
4340 [label="FullWidth = this.Text.Length; 140338"];
4341 [label="FullWidth 140339"];
4342 [label="this.AdjustFlagsAndWidth(trailing); 140340"];
4343 [label="return 'with'; 140341"];
4344 [label="FullWidth = this.Text.Length; 140342"];
4345 [label="FullWidth 140343"];
4346 [label="return 'with'; 140344"];
4347 [label="FullWidth = this.Text.Length; 140345"];
4348 [label="FullWidth 140346"];
4349 [label="this.AdjustFlagsAndWidth(leading); 140347"];
4350 [label="return 'with'; 140348"];
4351 [label="FullWidth = this.Text.Length; 140349"];
4352 [label="FullWidth 140350"];
4353 [label="this.AdjustFlagsAndWidth(trailing); 140351"];
4354 [label="return 'with'; 140352"];
4355 [label="FullWidth = this.Text.Length; 140353"];
4356 [label="FullWidth 140354"];
4357 [label="this.AdjustFlagsAndWidth(trailing); 140355"];
4358 [label="return 'init'; 140356"];
4359 [label="FullWidth = this.Text.Length; 140357"];
4360 [label="FullWidth 140358"];
4361 [label="return 'init'; 140359"];
4362 [label="FullWidth = this.Text.Length; 140360"];
4363 [label="FullWidth 140361"];
4364 [label="this.AdjustFlagsAndWidth(leading); 140362"];
4365 [label="return 'init'; 140363"];
4366 [label="FullWidth = this.Text.Length; 140364"];
4367 [label="FullWidth 140365"];
4368 [label="this.AdjustFlagsAndWidth(trailing); 140366"];
4369 [label="return 'init'; 140367"];
4370 [label="FullWidth = this.Text.Length; 140368"];
4371 [label="FullWidth 140369"];
4372 [label="this.AdjustFlagsAndWidth(trailing); 140370"];
4373 [label="return 'record'; 140371"];
4374 [label="FullWidth = this.Text.Length; 140372"];
4375 [label="FullWidth 140373"];
4376 [label="return 'record'; 140374"];
4377 [label="FullWidth = this.Text.Length; 140375"];
4378 [label="FullWidth 140376"];
4379 [label="this.AdjustFlagsAndWidth(leading); 140377"];
4380 [label="return 'record'; 140378"];
4381 [label="FullWidth = this.Text.Length; 140379"];
4382 [label="FullWidth 140380"];
4383 [label="this.AdjustFlagsAndWidth(trailing); 140381"];
4384 [label="return 'record'; 140382"];
4385 [label="FullWidth = this.Text.Length; 140383"];
4386 [label="FullWidth 140384"];
4387 [label="this.AdjustFlagsAndWidth(trailing); 140385"];
4388 [label="return 'managed'; 140386"];
4389 [label="FullWidth = this.Text.Length; 140387"];
4390 [label="FullWidth 140388"];
4391 [label="return 'managed'; 140389"];
4392 [label="FullWidth = this.Text.Length; 140390"];
4393 [label="FullWidth 140391"];
4394 [label="this.AdjustFlagsAndWidth(leading); 140392"];
4395 [label="return 'managed'; 140393"];
4396 [label="FullWidth = this.Text.Length; 140394"];
4397 [label="FullWidth 140395"];
4398 [label="this.AdjustFlagsAndWidth(trailing); 140396"];
4399 [label="return 'managed'; 140397"];
4400 [label="FullWidth = this.Text.Length; 140398"];
4401 [label="FullWidth 140399"];
4402 [label="this.AdjustFlagsAndWidth(trailing); 140400"];
4403 [label="return 'unmanaged'; 140401"];
4404 [label="FullWidth = this.Text.Length; 140402"];
4405 [label="FullWidth 140403"];
4406 [label="return 'unmanaged'; 140404"];
4407 [label="FullWidth = this.Text.Length; 140405"];
4408 [label="FullWidth 140406"];
4409 [label="this.AdjustFlagsAndWidth(leading); 140407"];
4410 [label="return 'unmanaged'; 140408"];
4411 [label="FullWidth = this.Text.Length; 140409"];
4412 [label="FullWidth 140410"];
4413 [label="this.AdjustFlagsAndWidth(trailing); 140411"];
4414 [label="return 'unmanaged'; 140412"];
4415 [label="FullWidth = this.Text.Length; 140413"];
4416 [label="FullWidth 140414"];
4417 [label="this.AdjustFlagsAndWidth(trailing); 140415"];
4418 [label="return 'elif'; 140416"];
4419 [label="FullWidth = this.Text.Length; 140417"];
4420 [label="FullWidth 140418"];
4421 [label="return 'elif'; 140419"];
4422 [label="FullWidth = this.Text.Length; 140420"];
4423 [label="FullWidth 140421"];
4424 [label="this.AdjustFlagsAndWidth(leading); 140422"];
4425 [label="return 'elif'; 140423"];
4426 [label="FullWidth = this.Text.Length; 140424"];
4427 [label="FullWidth 140425"];
4428 [label="this.AdjustFlagsAndWidth(trailing); 140426"];
4429 [label="return 'elif'; 140427"];
4430 [label="FullWidth = this.Text.Length; 140428"];
4431 [label="FullWidth 140429"];
4432 [label="this.AdjustFlagsAndWidth(trailing); 140430"];
4433 [label="return 'endif'; 140431"];
4434 [label="FullWidth = this.Text.Length; 140432"];
4435 [label="FullWidth 140433"];
4436 [label="return 'endif'; 140434"];
4437 [label="FullWidth = this.Text.Length; 140435"];
4438 [label="FullWidth 140436"];
4439 [label="this.AdjustFlagsAndWidth(leading); 140437"];
4440 [label="return 'endif'; 140438"];
4441 [label="FullWidth = this.Text.Length; 140439"];
4442 [label="FullWidth 140440"];
4443 [label="this.AdjustFlagsAndWidth(trailing); 140441"];
4444 [label="return 'endif'; 140442"];
4445 [label="FullWidth = this.Text.Length; 140443"];
4446 [label="FullWidth 140444"];
4447 [label="this.AdjustFlagsAndWidth(trailing); 140445"];
4448 [label="return 'region'; 140446"];
4449 [label="FullWidth = this.Text.Length; 140447"];
4450 [label="FullWidth 140448"];
4451 [label="return 'region'; 140449"];
4452 [label="FullWidth = this.Text.Length; 140450"];
4453 [label="FullWidth 140451"];
4454 [label="this.AdjustFlagsAndWidth(leading); 140452"];
4455 [label="return 'region'; 140453"];
4456 [label="FullWidth = this.Text.Length; 140454"];
4457 [label="FullWidth 140455"];
4458 [label="this.AdjustFlagsAndWidth(trailing); 140456"];
4459 [label="return 'region'; 140457"];
4460 [label="FullWidth = this.Text.Length; 140458"];
4461 [label="FullWidth 140459"];
4462 [label="this.AdjustFlagsAndWidth(trailing); 140460"];
4463 [label="return 'endregion'; 140461"];
4464 [label="FullWidth = this.Text.Length; 140462"];
4465 [label="FullWidth 140463"];
4466 [label="return 'endregion'; 140464"];
4467 [label="FullWidth = this.Text.Length; 140465"];
4468 [label="FullWidth 140466"];
4469 [label="this.AdjustFlagsAndWidth(leading); 140467"];
4470 [label="return 'endregion'; 140468"];
4471 [label="FullWidth = this.Text.Length; 140469"];
4472 [label="FullWidth 140470"];
4473 [label="this.AdjustFlagsAndWidth(trailing); 140471"];
4474 [label="return 'endregion'; 140472"];
4475 [label="FullWidth = this.Text.Length; 140473"];
4476 [label="FullWidth 140474"];
4477 [label="this.AdjustFlagsAndWidth(trailing); 140475"];
4478 [label="return 'define'; 140476"];
4479 [label="FullWidth = this.Text.Length; 140477"];
4480 [label="FullWidth 140478"];
4481 [label="return 'define'; 140479"];
4482 [label="FullWidth = this.Text.Length; 140480"];
4483 [label="FullWidth 140481"];
4484 [label="this.AdjustFlagsAndWidth(leading); 140482"];
4485 [label="return 'define'; 140483"];
4486 [label="FullWidth = this.Text.Length; 140484"];
4487 [label="FullWidth 140485"];
4488 [label="this.AdjustFlagsAndWidth(trailing); 140486"];
4489 [label="return 'define'; 140487"];
4490 [label="FullWidth = this.Text.Length; 140488"];
4491 [label="FullWidth 140489"];
4492 [label="this.AdjustFlagsAndWidth(trailing); 140490"];
4493 [label="return 'undef'; 140491"];
4494 [label="FullWidth = this.Text.Length; 140492"];
4495 [label="FullWidth 140493"];
4496 [label="return 'undef'; 140494"];
4497 [label="FullWidth = this.Text.Length; 140495"];
4498 [label="FullWidth 140496"];
4499 [label="this.AdjustFlagsAndWidth(leading); 140497"];
4500 [label="return 'undef'; 140498"];
4501 [label="FullWidth = this.Text.Length; 140499"];
4502 [label="FullWidth 140500"];
4503 [label="this.AdjustFlagsAndWidth(trailing); 140501"];
4504 [label="return 'undef'; 140502"];
4505 [label="FullWidth = this.Text.Length; 140503"];
4506 [label="FullWidth 140504"];
4507 [label="this.AdjustFlagsAndWidth(trailing); 140505"];
4508 [label="return 'warning'; 140506"];
4509 [label="FullWidth = this.Text.Length; 140507"];
4510 [label="FullWidth 140508"];
4511 [label="return 'warning'; 140509"];
4512 [label="FullWidth = this.Text.Length; 140510"];
4513 [label="FullWidth 140511"];
4514 [label="this.AdjustFlagsAndWidth(leading); 140512"];
4515 [label="return 'warning'; 140513"];
4516 [label="FullWidth = this.Text.Length; 140514"];
4517 [label="FullWidth 140515"];
4518 [label="this.AdjustFlagsAndWidth(trailing); 140516"];
4519 [label="return 'warning'; 140517"];
4520 [label="FullWidth = this.Text.Length; 140518"];
4521 [label="FullWidth 140519"];
4522 [label="this.AdjustFlagsAndWidth(trailing); 140520"];
4523 [label="return 'error'; 140521"];
4524 [label="FullWidth = this.Text.Length; 140522"];
4525 [label="FullWidth 140523"];
4526 [label="return 'error'; 140524"];
4527 [label="FullWidth = this.Text.Length; 140525"];
4528 [label="FullWidth 140526"];
4529 [label="this.AdjustFlagsAndWidth(leading); 140527"];
4530 [label="return 'error'; 140528"];
4531 [label="FullWidth = this.Text.Length; 140529"];
4532 [label="FullWidth 140530"];
4533 [label="this.AdjustFlagsAndWidth(trailing); 140531"];
4534 [label="return 'error'; 140532"];
4535 [label="FullWidth = this.Text.Length; 140533"];
4536 [label="FullWidth 140534"];
4537 [label="this.AdjustFlagsAndWidth(trailing); 140535"];
4538 [label="return 'line'; 140536"];
4539 [label="FullWidth = this.Text.Length; 140537"];
4540 [label="FullWidth 140538"];
4541 [label="return 'line'; 140539"];
4542 [label="FullWidth = this.Text.Length; 140540"];
4543 [label="FullWidth 140541"];
4544 [label="this.AdjustFlagsAndWidth(leading); 140542"];
4545 [label="return 'line'; 140543"];
4546 [label="FullWidth = this.Text.Length; 140544"];
4547 [label="FullWidth 140545"];
4548 [label="this.AdjustFlagsAndWidth(trailing); 140546"];
4549 [label="return 'line'; 140547"];
4550 [label="FullWidth = this.Text.Length; 140548"];
4551 [label="FullWidth 140549"];
4552 [label="this.AdjustFlagsAndWidth(trailing); 140550"];
4553 [label="return 'pragma'; 140551"];
4554 [label="FullWidth = this.Text.Length; 140552"];
4555 [label="FullWidth 140553"];
4556 [label="return 'pragma'; 140554"];
4557 [label="FullWidth = this.Text.Length; 140555"];
4558 [label="FullWidth 140556"];
4559 [label="this.AdjustFlagsAndWidth(leading); 140557"];
4560 [label="return 'pragma'; 140558"];
4561 [label="FullWidth = this.Text.Length; 140559"];
4562 [label="FullWidth 140560"];
4563 [label="this.AdjustFlagsAndWidth(trailing); 140561"];
4564 [label="return 'pragma'; 140562"];
4565 [label="FullWidth = this.Text.Length; 140563"];
4566 [label="FullWidth 140564"];
4567 [label="this.AdjustFlagsAndWidth(trailing); 140565"];
4568 [label="return 'hidden'; 140566"];
4569 [label="FullWidth = this.Text.Length; 140567"];
4570 [label="FullWidth 140568"];
4571 [label="return 'hidden'; 140569"];
4572 [label="FullWidth = this.Text.Length; 140570"];
4573 [label="FullWidth 140571"];
4574 [label="this.AdjustFlagsAndWidth(leading); 140572"];
4575 [label="return 'hidden'; 140573"];
4576 [label="FullWidth = this.Text.Length; 140574"];
4577 [label="FullWidth 140575"];
4578 [label="this.AdjustFlagsAndWidth(trailing); 140576"];
4579 [label="return 'hidden'; 140577"];
4580 [label="FullWidth = this.Text.Length; 140578"];
4581 [label="FullWidth 140579"];
4582 [label="this.AdjustFlagsAndWidth(trailing); 140580"];
4583 [label="return 'checksum'; 140581"];
4584 [label="FullWidth = this.Text.Length; 140582"];
4585 [label="FullWidth 140583"];
4586 [label="return 'checksum'; 140584"];
4587 [label="FullWidth = this.Text.Length; 140585"];
4588 [label="FullWidth 140586"];
4589 [label="this.AdjustFlagsAndWidth(leading); 140587"];
4590 [label="return 'checksum'; 140588"];
4591 [label="FullWidth = this.Text.Length; 140589"];
4592 [label="FullWidth 140590"];
4593 [label="this.AdjustFlagsAndWidth(trailing); 140591"];
4594 [label="return 'checksum'; 140592"];
4595 [label="FullWidth = this.Text.Length; 140593"];
4596 [label="FullWidth 140594"];
4597 [label="this.AdjustFlagsAndWidth(trailing); 140595"];
4598 [label="return 'disable'; 140596"];
4599 [label="FullWidth = this.Text.Length; 140597"];
4600 [label="FullWidth 140598"];
4601 [label="return 'disable'; 140599"];
4602 [label="FullWidth = this.Text.Length; 140600"];
4603 [label="FullWidth 140601"];
4604 [label="this.AdjustFlagsAndWidth(leading); 140602"];
4605 [label="return 'disable'; 140603"];
4606 [label="FullWidth = this.Text.Length; 140604"];
4607 [label="FullWidth 140605"];
4608 [label="this.AdjustFlagsAndWidth(trailing); 140606"];
4609 [label="return 'disable'; 140607"];
4610 [label="FullWidth = this.Text.Length; 140608"];
4611 [label="FullWidth 140609"];
4612 [label="this.AdjustFlagsAndWidth(trailing); 140610"];
4613 [label="return 'restore'; 140611"];
4614 [label="FullWidth = this.Text.Length; 140612"];
4615 [label="FullWidth 140613"];
4616 [label="return 'restore'; 140614"];
4617 [label="FullWidth = this.Text.Length; 140615"];
4618 [label="FullWidth 140616"];
4619 [label="this.AdjustFlagsAndWidth(leading); 140617"];
4620 [label="return 'restore'; 140618"];
4621 [label="FullWidth = this.Text.Length; 140619"];
4622 [label="FullWidth 140620"];
4623 [label="this.AdjustFlagsAndWidth(trailing); 140621"];
4624 [label="return 'restore'; 140622"];
4625 [label="FullWidth = this.Text.Length; 140623"];
4626 [label="FullWidth 140624"];
4627 [label="this.AdjustFlagsAndWidth(trailing); 140625"];
4628 [label="return 'r'; 140626"];
4629 [label="FullWidth = this.Text.Length; 140627"];
4630 [label="FullWidth 140628"];
4631 [label="return 'r'; 140629"];
4632 [label="FullWidth = this.Text.Length; 140630"];
4633 [label="FullWidth 140631"];
4634 [label="this.AdjustFlagsAndWidth(leading); 140632"];
4635 [label="return 'r'; 140633"];
4636 [label="FullWidth = this.Text.Length; 140634"];
4637 [label="FullWidth 140635"];
4638 [label="this.AdjustFlagsAndWidth(trailing); 140636"];
4639 [label="return 'r'; 140637"];
4640 [label="FullWidth = this.Text.Length; 140638"];
4641 [label="FullWidth 140639"];
4642 [label="this.AdjustFlagsAndWidth(trailing); 140640"];
4643 [label="return '$\\''; 140641"];
4644 [label="FullWidth = this.Text.Length; 140642"];
4645 [label="FullWidth 140643"];
4646 [label="return '$\\''; 140644"];
4647 [label="FullWidth = this.Text.Length; 140645"];
4648 [label="FullWidth 140646"];
4649 [label="this.AdjustFlagsAndWidth(leading); 140647"];
4650 [label="return '$\\''; 140648"];
4651 [label="FullWidth = this.Text.Length; 140649"];
4652 [label="FullWidth 140650"];
4653 [label="this.AdjustFlagsAndWidth(trailing); 140651"];
4654 [label="return '$\\''; 140652"];
4655 [label="FullWidth = this.Text.Length; 140653"];
4656 [label="FullWidth 140654"];
4657 [label="this.AdjustFlagsAndWidth(trailing); 140655"];
4658 [label="return '\\''; 140656"];
4659 [label="FullWidth = this.Text.Length; 140657"];
4660 [label="FullWidth 140658"];
4661 [label="return '\\''; 140659"];
4662 [label="FullWidth = this.Text.Length; 140660"];
4663 [label="FullWidth 140661"];
4664 [label="this.AdjustFlagsAndWidth(leading); 140662"];
4665 [label="return '\\''; 140663"];
4666 [label="FullWidth = this.Text.Length; 140664"];
4667 [label="FullWidth 140665"];
4668 [label="this.AdjustFlagsAndWidth(trailing); 140666"];
4669 [label="return '\\''; 140667"];
4670 [label="FullWidth = this.Text.Length; 140668"];
4671 [label="FullWidth 140669"];
4672 [label="this.AdjustFlagsAndWidth(trailing); 140670"];
4673 [label="return '$@\\''; 140671"];
4674 [label="FullWidth = this.Text.Length; 140672"];
4675 [label="FullWidth 140673"];
4676 [label="return '$@\\''; 140674"];
4677 [label="FullWidth = this.Text.Length; 140675"];
4678 [label="FullWidth 140676"];
4679 [label="this.AdjustFlagsAndWidth(leading); 140677"];
4680 [label="return '$@\\''; 140678"];
4681 [label="FullWidth = this.Text.Length; 140679"];
4682 [label="FullWidth 140680"];
4683 [label="this.AdjustFlagsAndWidth(trailing); 140681"];
4684 [label="return '$@\\''; 140682"];
4685 [label="FullWidth = this.Text.Length; 140683"];
4686 [label="FullWidth 140684"];
4687 [label="this.AdjustFlagsAndWidth(trailing); 140685"];
4688 [label="return 'load'; 140686"];
4689 [label="FullWidth = this.Text.Length; 140687"];
4690 [label="FullWidth 140688"];
4691 [label="return 'load'; 140689"];
4692 [label="FullWidth = this.Text.Length; 140690"];
4693 [label="FullWidth 140691"];
4694 [label="this.AdjustFlagsAndWidth(leading); 140692"];
4695 [label="return 'load'; 140693"];
4696 [label="FullWidth = this.Text.Length; 140694"];
4697 [label="FullWidth 140695"];
4698 [label="this.AdjustFlagsAndWidth(trailing); 140696"];
4699 [label="return 'load'; 140697"];
4700 [label="FullWidth = this.Text.Length; 140698"];
4701 [label="FullWidth 140699"];
4702 [label="this.AdjustFlagsAndWidth(trailing); 140700"];
4703 [label="return 'nullable'; 140701"];
4704 [label="FullWidth = this.Text.Length; 140702"];
4705 [label="FullWidth 140703"];
4706 [label="return 'nullable'; 140704"];
4707 [label="FullWidth = this.Text.Length; 140705"];
4708 [label="FullWidth 140706"];
4709 [label="this.AdjustFlagsAndWidth(leading); 140707"];
4710 [label="return 'nullable'; 140708"];
4711 [label="FullWidth = this.Text.Length; 140709"];
4712 [label="FullWidth 140710"];
4713 [label="this.AdjustFlagsAndWidth(trailing); 140711"];
4714 [label="return 'nullable'; 140712"];
4715 [label="FullWidth = this.Text.Length; 140713"];
4716 [label="FullWidth 140714"];
4717 [label="this.AdjustFlagsAndWidth(trailing); 140715"];
4718 [label="return 'enable'; 140716"];
4719 [label="FullWidth = this.Text.Length; 140717"];
4720 [label="FullWidth 140718"];
4721 [label="return 'enable'; 140719"];
4722 [label="FullWidth = this.Text.Length; 140720"];
4723 [label="FullWidth 140721"];
4724 [label="this.AdjustFlagsAndWidth(leading); 140722"];
4725 [label="return 'enable'; 140723"];
4726 [label="FullWidth = this.Text.Length; 140724"];
4727 [label="FullWidth 140725"];
4728 [label="this.AdjustFlagsAndWidth(trailing); 140726"];
4729 [label="return 'enable'; 140727"];
4730 [label="FullWidth = this.Text.Length; 140728"];
4731 [label="FullWidth 140729"];
4732 [label="this.AdjustFlagsAndWidth(trailing); 140730"];
4733 [label="return 'warnings'; 140731"];
4734 [label="FullWidth = this.Text.Length; 140732"];
4735 [label="FullWidth 140733"];
4736 [label="return 'warnings'; 140734"];
4737 [label="FullWidth = this.Text.Length; 140735"];
4738 [label="FullWidth 140736"];
4739 [label="this.AdjustFlagsAndWidth(leading); 140737"];
4740 [label="return 'warnings'; 140738"];
4741 [label="FullWidth = this.Text.Length; 140739"];
4742 [label="FullWidth 140740"];
4743 [label="this.AdjustFlagsAndWidth(trailing); 140741"];
4744 [label="return 'warnings'; 140742"];
4745 [label="FullWidth = this.Text.Length; 140743"];
4746 [label="FullWidth 140744"];
4747 [label="this.AdjustFlagsAndWidth(trailing); 140745"];
4748 [label="return 'annotations'; 140746"];
4749 [label="FullWidth = this.Text.Length; 140747"];
4750 [label="FullWidth 140748"];
4751 [label="return 'annotations'; 140749"];
4752 [label="FullWidth = this.Text.Length; 140750"];
4753 [label="FullWidth 140751"];
4754 [label="this.AdjustFlagsAndWidth(leading); 140752"];
4755 [label="return 'annotations'; 140753"];
4756 [label="FullWidth = this.Text.Length; 140754"];
4757 [label="FullWidth 140755"];
4758 [label="this.AdjustFlagsAndWidth(trailing); 140756"];
4759 [label="return 'annotations'; 140757"];
4760 [label="FullWidth = this.Text.Length; 140758"];
4761 [label="FullWidth 140759"];
4762 [label="this.AdjustFlagsAndWidth(trailing); 140760"];
4763 [label="return 'var'; 140761"];
4764 [label="FullWidth = this.Text.Length; 140762"];
4765 [label="FullWidth 140763"];
4766 [label="return 'var'; 140764"];
4767 [label="FullWidth = this.Text.Length; 140765"];
4768 [label="FullWidth 140766"];
4769 [label="this.AdjustFlagsAndWidth(leading); 140767"];
4770 [label="return 'var'; 140768"];
4771 [label="FullWidth = this.Text.Length; 140769"];
4772 [label="FullWidth 140770"];
4773 [label="this.AdjustFlagsAndWidth(trailing); 140771"];
4774 [label="return 'var'; 140772"];
4775 [label="FullWidth = this.Text.Length; 140773"];
4776 [label="FullWidth 140774"];
4777 [label="this.AdjustFlagsAndWidth(trailing); 140775"];
4778 [label="return '_'; 140776"];
4779 [label="FullWidth = this.Text.Length; 140777"];
4780 [label="FullWidth 140778"];
4781 [label="return '_'; 140779"];
4782 [label="FullWidth = this.Text.Length; 140780"];
4783 [label="FullWidth 140781"];
4784 [label="this.AdjustFlagsAndWidth(leading); 140782"];
4785 [label="return '_'; 140783"];
4786 [label="FullWidth = this.Text.Length; 140784"];
4787 [label="FullWidth 140785"];
4788 [label="this.AdjustFlagsAndWidth(trailing); 140786"];
4789 [label="return '_'; 140787"];
4790 [label="FullWidth = this.Text.Length; 140788"];
4791 [label="FullWidth 140789"];
4792 [label="this.AdjustFlagsAndWidth(trailing); 140790"];
4793 [label="return SyntaxToken.Create(kind, leading, trailing); 140791"];
4794 [label="return SyntaxToken.Create(kind, leading, trailing); 140792"];
4795 [label="return SyntaxToken.Create(kind, leading, trailing); 140793"];
4796 [label="SyntaxToken.Create(kind, leading, trailing) 140794"];
4797 [label="param Create(SyntaxKind kind) 140795"];
4798 [label="param Create(GreenNode leading) 140796"];
4799 [label="param Create(GreenNode trailing) 140797"];
4800 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 140798"];
4801 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 140799"];
4802 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 140800"];
4803 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 140801"];
4804 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 140802"];
4805 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 140803"];
4806 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 140804"];
4807 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 140805"];
4808 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 140806"];
4809 [label="return token; 140807"];
4810 [label="this.AddLexedToken(token); 140808"];
4811 [label="this.AddLexedToken(token) 140809"];
4812 [label="param AddLexedToken(SyntaxToken token) 140810"];
4813 [label="param AddLexedToken(this) 140811"];
4814 [label="Debug.Assert(token != null); 140812"];
4815 [label="Debug.Assert(token != null); 140813"];
4816 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 140814"];
4817 [label="_lexedTokens[_tokenCount].Value = token; 140815"];
4818 [label="_lexedTokens[_tokenCount].Value 140816"];
4819 [label="_tokenCount 140817"];
4820 [label="this.AddLexedToken(token); 140818"];
4821 [label="token.Kind 140819"];
4822 [label="get { return (SyntaxKind)this.RawKind; } 140820"];
4823 [label="return (SyntaxKind)this.RawKind; 140821"];
4824 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 140822"];
4825 [label="TextWindow.Start(); 140823"];
4826 [label="get\n            {\n                return _lexemeStart;\n            } 140824"];
4827 [label="return _lexemeStart; 140825"];
4828 [label="param LookupToken(char[] textBuffer) 140826"];
4829 [label="param LookupToken(int keyStart) 140827"];
4830 [label="param LookupToken(int keyLength) 140828"];
4831 [label="param LookupToken(int hashCode) 140829"];
4832 [label="param LookupToken(Func<SyntaxToken> createTokenFunction) 140830"];
4833 [label="param LookupToken(this) 140831"];
4834 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 140832"];
4835 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 140833"];
4836 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 140834"];
4837 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 140835"];
4838 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 140836"];
4839 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 140837"];
4840 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 140838"];
4841 [label="value = createTokenFunction(); 140839"];
4842 [label="value = createTokenFunction(); 140840"];
4843 [label="param CreateQuickToken(this) 140841"];
4844 [label="TextWindow.Width 140842"];
4845 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 140843"];
4846 [label="var quickWidth = TextWindow.Width; 140844"];
4847 [label="TextWindow.LexemeStartPosition 140845"];
4848 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 140846"];
4849 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 140847"];
4850 [label="TextWindow.Reset(TextWindow.LexemeStartPosition) 140848"];
4851 [label="param Reset(int position) 140849"];
4852 [label="param Reset(this) 140850"];
4853 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 140851"];
4854 [label="this.LexSyntaxToken() 140852"];
4855 [label="param LexSyntaxToken(this) 140853"];
4856 [label="_leadingTriviaCache.Clear(); 140854"];
4857 [label="TextWindow.Position 140855"];
4858 [label="get\n            {\n                return _basis + _offset;\n            } 140856"];
4859 [label="param LexSyntaxTrivia(bool afterFirstToken) 140857"];
4860 [label="param LexSyntaxTrivia(bool isTrailing) 140858"];
4861 [label="bool onlyWhitespaceOnLine = !isTrailing; 140859"];
4862 [label="TextWindow.Start(); 140860"];
4863 [label="this.Start(); 140861"];
4864 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 140862"];
4865 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 140863"];
4866 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 140864"];
4867 [label="return; 140865"];
4868 [label="this.Start(); 140866"];
4869 [label="var errors = this.GetErrors(GetFullWidth(leading)); 140867"];
4870 [label="GetFullWidth(leading) 140868"];
4871 [label="param GetFullWidth(SyntaxListBuilder builder) 140869"];
4872 [label="int width = 0; 140870"];
4873 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 140871"];
4874 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 140872"];
4875 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 140873"];
4876 [label="return width; 140874"];
4877 [label="var errors = this.GetErrors(GetFullWidth(leading)); 140875"];
4878 [label="this.GetErrors(GetFullWidth(leading)) 140876"];
4879 [label="param GetErrors(int leadingTriviaWidth) 140877"];
4880 [label="param GetErrors(this) 140878"];
4881 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 140879"];
4882 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 140880"];
4883 [label="return null; 140881"];
4884 [label="var errors = this.GetErrors(GetFullWidth(leading)); 140882"];
4885 [label="param LexSyntaxTrivia(bool afterFirstToken) 140883"];
4886 [label="param Create(ref TokenInfo info) 140884"];
4887 [label="param Create(SyntaxDiagnosticInfo[] errors) 140885"];
4888 [label="param Create(this) 140886"];
4889 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 140887"];
4890 [label="SyntaxToken token; 140888"];
4891 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 140889"];
4892 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 140890"];
4893 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 140891"];
4894 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 140892"];
4895 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 140893"];
4896 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 140894"];
4897 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 140895"];
4898 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 140896"];
4899 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 140897"];
4900 [label="param Token(GreenNode leading) 140898"];
4901 [label="param Token(SyntaxKind kind) 140899"];
4902 [label="param Token(GreenNode trailing) 140900"];
4903 [label="return SyntaxToken.Create(kind, leading, trailing); 140901"];
4904 [label="return SyntaxToken.Create(kind, leading, trailing); 140902"];
4905 [label="return SyntaxToken.Create(kind, leading, trailing); 140903"];
4906 [label="SyntaxToken.Create(kind, leading, trailing) 140904"];
4907 [label="param Create(SyntaxKind kind) 140905"];
4908 [label="param Create(GreenNode leading) 140906"];
4909 [label="param Create(GreenNode trailing) 140907"];
4910 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 140908"];
4911 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 140909"];
4912 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 140910"];
4913 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 140911"];
4914 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 140912"];
4915 [label="return s_tokensWithNoTrivia[(int)kind].Value; 140913"];
4916 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 140914"];
4917 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 140915"];
4918 [label="return token; 140916"];
4919 [label="var token = this.LexSyntaxToken(); 140917"];
4920 [label="Debug.Assert(quickWidth == token.FullWidth); 140918"];
4921 [label="return token; 140919"];
4922 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 140920"];
4923 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 140921"];
4924 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 140922"];
4925 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 140923"];
4926 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 140924"];
4927 [label="return value; 140925"];
4928 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 140926"];
4929 [label="this.AddLexedToken(token); 140927"];
4930 [label="param AddLexedToken(SyntaxToken token) 140928"];
4931 [label="Debug.Assert(token != null); 140929"];
4932 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 140930"];
4933 [label="_lexedTokens[_tokenCount].Value = token; 140931"];
4934 [label="_lexedTokens[_tokenCount].Value 140932"];
4935 [label="get { return (SyntaxKind)this.RawKind; } 140933"];
4936 [label="return (SyntaxKind)this.RawKind; 140934"];
4937 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 140935"];
4938 [label="TextWindow.Start(); 140936"];
4939 [label="TextWindow.Width 140937"];
4940 [label="var quickWidth = TextWindow.Width; 140938"];
4941 [label="TextWindow.Position 140939"];
4942 [label="param LexSyntaxTrivia(bool afterFirstToken) 140940"];
4943 [label="param LexSyntaxTrivia(bool isTrailing) 140941"];
4944 [label="bool onlyWhitespaceOnLine = !isTrailing; 140942"];
4945 [label="this.Start(); 140943"];
4946 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 140944"];
4947 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 140945"];
4948 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 140946"];
4949 [label="return; 140947"];
4950 [label="this.Start(); 140948"];
4951 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 140949"];
4952 [label="param TryGetKeywordKind(out SyntaxKind kind) 140950"];
4953 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 140951"];
4954 [label="return SyntaxKind.None; 140952"];
4955 [label="param GetContextualKeywordKind(string text) 140953"];
4956 [label="switch (text)\n            {\n                case 'yield':\n                    return SyntaxKind.YieldKeyword;\n                case 'partial':\n                    return SyntaxKind.PartialKeyword;\n                case 'from':\n                    return SyntaxKind.FromKeyword;\n                case 'group':\n                    return SyntaxKind.GroupKeyword;\n                case 'join':\n                    return SyntaxKind.JoinKeyword;\n                case 'into':\n                    return SyntaxKind.IntoKeyword;\n                case 'let':\n                    return SyntaxKind.LetKeyword;\n                case 'by':\n                    return SyntaxKind.ByKeyword;\n                case 'where':\n                    return SyntaxKind.WhereKeyword;\n                case 'select':\n                    return SyntaxKind.SelectKeyword;\n                case 'get':\n                    return SyntaxKind.GetKeyword;\n                case 'set':\n                    return SyntaxKind.SetKeyword;\n                case 'add':\n                    return SyntaxKind.AddKeyword;\n                case 'remove':\n                    return SyntaxKind.RemoveKeyword;\n                case 'orderby':\n                    return SyntaxKind.OrderByKeyword;\n                case 'alias':\n                    return SyntaxKind.AliasKeyword;\n                case 'on':\n                    return SyntaxKind.OnKeyword;\n                case 'equals':\n                    return SyntaxKind.EqualsKeyword;\n                case 'ascending':\n                    return SyntaxKind.AscendingKeyword;\n                case 'descending':\n                    return SyntaxKind.DescendingKeyword;\n                case 'assembly':\n                    return SyntaxKind.AssemblyKeyword;\n                case 'module':\n                    return SyntaxKind.ModuleKeyword;\n                case 'type':\n                    return SyntaxKind.TypeKeyword;\n                case 'field':\n                    return SyntaxKind.FieldKeyword;\n                case 'method':\n                    return SyntaxKind.MethodKeyword;\n                case 'param':\n                    return SyntaxKind.ParamKeyword;\n                case 'property':\n                    return SyntaxKind.PropertyKeyword;\n                case 'typevar':\n                    return SyntaxKind.TypeVarKeyword;\n                case 'global':\n                    return SyntaxKind.GlobalKeyword;\n                case 'async':\n                    return SyntaxKind.AsyncKeyword;\n                case 'await':\n                    return SyntaxKind.AwaitKeyword;\n                case 'when':\n                    return SyntaxKind.WhenKeyword;\n                case 'nameof':\n                    return SyntaxKind.NameOfKeyword;\n                case '_':\n                    return SyntaxKind.UnderscoreToken;\n                case 'var':\n                    return SyntaxKind.VarKeyword;\n                case 'and':\n                    return SyntaxKind.AndKeyword;\n                case 'or':\n                    return SyntaxKind.OrKeyword;\n                case 'not':\n                    return SyntaxKind.NotKeyword;\n                case 'data':\n                    return SyntaxKind.DataKeyword;\n                case 'with':\n                    return SyntaxKind.WithKeyword;\n                case 'init':\n                    return SyntaxKind.InitKeyword;\n                case 'record':\n                    return SyntaxKind.RecordKeyword;\n                case 'managed':\n                    return SyntaxKind.ManagedKeyword;\n                case 'unmanaged':\n                    return SyntaxKind.UnmanagedKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 140954"];
4957 [label="return SyntaxKind.None; 140955"];
4958 [label="kind = _keywordKindMap.GetOrMakeValue(key); 140956"];
4959 [label="return kind != SyntaxKind.None; 140957"];
4960 [label="info.Kind 140958"];
4961 [label="info.ContextualKind 140959"];
4962 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 140960"];
4963 [label="this.ScanSyntaxToken(ref tokenInfo); 140961"];
4964 [label="var errors = this.GetErrors(GetFullWidth(leading)); 140962"];
4965 [label="GetFullWidth(leading) 140963"];
4966 [label="param GetFullWidth(SyntaxListBuilder builder) 140964"];
4967 [label="int width = 0; 140965"];
4968 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 140966"];
4969 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 140967"];
4970 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 140968"];
4971 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 140969"];
4972 [label="return width; 140970"];
4973 [label="var errors = this.GetErrors(GetFullWidth(leading)); 140971"];
4974 [label="this.GetErrors(GetFullWidth(leading)) 140972"];
4975 [label="param GetErrors(int leadingTriviaWidth) 140973"];
4976 [label="param GetErrors(this) 140974"];
4977 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 140975"];
4978 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 140976"];
4979 [label="return null; 140977"];
4980 [label="var errors = this.GetErrors(GetFullWidth(leading)); 140978"];
4981 [label="param LexSyntaxTrivia(bool afterFirstToken) 140979"];
4982 [label="param LexSyntaxTrivia(bool isTrailing) 140980"];
4983 [label="bool onlyWhitespaceOnLine = !isTrailing; 140981"];
4984 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 140982"];
4985 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 140983"];
4986 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 140984"];
4987 [label="return; 140985"];
4988 [label="param Create(SyntaxDiagnosticInfo[] errors) 140986"];
4989 [label="param Create(this) 140987"];
4990 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 140988"];
4991 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 140989"];
4992 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 140990"];
4993 [label="SyntaxToken token; 140991"];
4994 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 140992"];
4995 [label="SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode) 140993"];
4996 [label="param Identifier(SyntaxKind contextualKind) 140994"];
4997 [label="param Identifier(GreenNode leading) 140995"];
4998 [label="param Identifier(string text) 140996"];
4999 [label="param Identifier(string valueText) 140997"];
5000 [label="param Identifier(GreenNode trailing) 140998"];
5001 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 140999"];
5002 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 141000"];
5003 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 141001"];
5004 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 141002"];
5005 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 141003"];
5006 [label="SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing) 141004"];
5007 [label="param Identifier(SyntaxKind contextualKind) 141005"];
5008 [label="param Identifier(GreenNode leading) 141006"];
5009 [label="param Identifier(string text) 141007"];
5010 [label="param Identifier(string valueText) 141008"];
5011 [label="param Identifier(GreenNode trailing) 141009"];
5012 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 141010"];
5013 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 141011"];
5014 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 141012"];
5015 [label="return Identifier(leading, text, trailing); 141013"];
5016 [label="return Identifier(leading, text, trailing); 141014"];
5017 [label="return Identifier(leading, text, trailing); 141015"];
5018 [label="Identifier(leading, text, trailing) 141016"];
5019 [label="param Identifier(GreenNode leading) 141017"];
5020 [label="param Identifier(string text) 141018"];
5021 [label="param Identifier(GreenNode trailing) 141019"];
5022 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 141020"];
5023 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 141021"];
5024 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 141022"];
5025 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 141023"];
5026 [label="return Identifier(text); 141024"];
5027 [label="Identifier(text) 141025"];
5028 [label="param Identifier(string text) 141026"];
5029 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifier), r => new SyntaxIdentifier(r)); 141027"];
5030 [label="return new SyntaxIdentifier(text); 141028"];
5031 [label="return new SyntaxIdentifier(text); 141029"];
5032 [label="new SyntaxIdentifier(text) 141030"];
5033 [label="param SyntaxIdentifier(string text) 141031"];
5034 [label="param SyntaxIdentifier(this) 141032"];
5035 [label="SyntaxKind.IdentifierToken 141033"];
5036 [label="text 141034"];
5037 [label="param SyntaxIdentifier(this) 141035"];
5038 [label="param SyntaxToken(SyntaxKind kind) 141036"];
5039 [label="param SyntaxToken(int fullWidth) 141037"];
5040 [label="param SyntaxToken(this) 141038"];
5041 [label="kind 141039"];
5042 [label="fullWidth 141040"];
5043 [label="param SyntaxToken(this) 141041"];
5044 [label="param CSharpSyntaxNode(SyntaxKind kind) 141042"];
5045 [label="param CSharpSyntaxNode(int fullWidth) 141043"];
5046 [label="param CSharpSyntaxNode(this) 141044"];
5047 [label="kind 141045"];
5048 [label="fullWidth 141046"];
5049 [label="param CSharpSyntaxNode(this) 141047"];
5050 [label="param CSharpSyntaxNode(this) 141048"];
5051 [label="GreenStats.NoteGreen(this); 141049"];
5052 [label="GreenStats.NoteGreen(this); 141050"];
5053 [label="this.flags |= NodeFlags.IsNotMissing; 141051"];
5054 [label="this.flags 141052"];
5055 [label="TextField 141053"];
5056 [label="this.TextField 141054"];
5057 [label="return Identifier(text); 141055"];
5058 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 141056"];
5059 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 141057"];
5060 [label="Debug.Assert(quickWidth == token.FullWidth); 141058"];
5061 [label="value = createTokenFunction(); 141059"];
5062 [label="this.AddLexedToken(token); 141060"];
5063 [label="param AddLexedToken(SyntaxToken token) 141061"];
5064 [label="Debug.Assert(token != null); 141062"];
5065 [label="_lexedTokens[_tokenCount].Value 141063"];
5066 [label="get { return (SyntaxKind)this.RawKind; } 141064"];
5067 [label="return (SyntaxKind)this.RawKind; 141065"];
5068 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 141066"];
5069 [label="TextWindow.Start(); 141067"];
5070 [label="TextWindow.Width 141068"];
5071 [label="var quickWidth = TextWindow.Width; 141069"];
5072 [label="param LexSyntaxTrivia(bool afterFirstToken) 141070"];
5073 [label="param LexSyntaxTrivia(bool isTrailing) 141071"];
5074 [label="bool onlyWhitespaceOnLine = !isTrailing; 141072"];
5075 [label="this.Start(); 141073"];
5076 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 141074"];
5077 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 141075"];
5078 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 141076"];
5079 [label="return; 141077"];
5080 [label="this.Start(); 141078"];
5081 [label="var errors = this.GetErrors(GetFullWidth(leading)); 141079"];
5082 [label="GetFullWidth(leading) 141080"];
5083 [label="param GetFullWidth(SyntaxListBuilder builder) 141081"];
5084 [label="int width = 0; 141082"];
5085 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 141083"];
5086 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 141084"];
5087 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 141085"];
5088 [label="return width; 141086"];
5089 [label="var errors = this.GetErrors(GetFullWidth(leading)); 141087"];
5090 [label="this.GetErrors(GetFullWidth(leading)) 141088"];
5091 [label="param GetErrors(int leadingTriviaWidth) 141089"];
5092 [label="param GetErrors(this) 141090"];
5093 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 141091"];
5094 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 141092"];
5095 [label="return null; 141093"];
5096 [label="var errors = this.GetErrors(GetFullWidth(leading)); 141094"];
5097 [label="param AddTrivia(this) 141095"];
5098 [label="this.HasErrors 141096"];
5099 [label="get { return _errors != null; } 141097"];
5100 [label="return _errors != null; 141098"];
5101 [label="return _errors != null; 141099"];
5102 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 141100"];
5103 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 141101"];
5104 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 141102"];
5105 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 141103"];
5106 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 141104"];
5107 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 141105"];
5108 [label="return; 141106"];
5109 [label="param Create(SyntaxDiagnosticInfo[] errors) 141107"];
5110 [label="param Create(this) 141108"];
5111 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 141109"];
5112 [label="SyntaxToken token; 141110"];
5113 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 141111"];
5114 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 141112"];
5115 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 141113"];
5116 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 141114"];
5117 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 141115"];
5118 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 141116"];
5119 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 141117"];
5120 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 141118"];
5121 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 141119"];
5122 [label="Debug.Assert(quickWidth == token.FullWidth); 141120"];
5123 [label="this.AddLexedToken(token); 141121"];
5124 [label="param AddLexedToken(SyntaxToken token) 141122"];
5125 [label="Debug.Assert(token != null); 141123"];
5126 [label="_lexedTokens[_tokenCount].Value 141124"];
5127 [label="get { return (SyntaxKind)this.RawKind; } 141125"];
5128 [label="return (SyntaxKind)this.RawKind; 141126"];
5129 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 141127"];
5130 [label="TextWindow.Start(); 141128"];
5131 [label="var quickWidth = TextWindow.Width; 141129"];
5132 [label="param LexSyntaxTrivia(bool afterFirstToken) 141130"];
5133 [label="param LexSyntaxTrivia(bool isTrailing) 141131"];
5134 [label="bool onlyWhitespaceOnLine = !isTrailing; 141132"];
5135 [label="this.Start(); 141133"];
5136 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 141134"];
5137 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 141135"];
5138 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 141136"];
5139 [label="return; 141137"];
5140 [label="this.Start(); 141138"];
5141 [label="var errors = this.GetErrors(GetFullWidth(leading)); 141139"];
5142 [label="GetFullWidth(leading) 141140"];
5143 [label="param GetFullWidth(SyntaxListBuilder builder) 141141"];
5144 [label="int width = 0; 141142"];
5145 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 141143"];
5146 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 141144"];
5147 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 141145"];
5148 [label="return width; 141146"];
5149 [label="var errors = this.GetErrors(GetFullWidth(leading)); 141147"];
5150 [label="this.GetErrors(GetFullWidth(leading)) 141148"];
5151 [label="param GetErrors(int leadingTriviaWidth) 141149"];
5152 [label="param GetErrors(this) 141150"];
5153 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 141151"];
5154 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 141152"];
5155 [label="return null; 141153"];
5156 [label="var errors = this.GetErrors(GetFullWidth(leading)); 141154"];
5157 [label="param AddTrivia(this) 141155"];
5158 [label="this.HasErrors 141156"];
5159 [label="get { return _errors != null; } 141157"];
5160 [label="return _errors != null; 141158"];
5161 [label="return _errors != null; 141159"];
5162 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 141160"];
5163 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 141161"];
5164 [label="param Create(SyntaxDiagnosticInfo[] errors) 141162"];
5165 [label="param Create(this) 141163"];
5166 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 141164"];
5167 [label="SyntaxToken token; 141165"];
5168 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 141166"];
5169 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 141167"];
5170 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 141168"];
5171 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 141169"];
5172 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 141170"];
5173 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 141171"];
5174 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 141172"];
5175 [label="Debug.Assert(quickWidth == token.FullWidth); 141173"];
5176 [label="param TryGetKeywordKind(out SyntaxKind kind) 141174"];
5177 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 141175"];
5178 [label="return SyntaxKind.CaseKeyword; 141176"];
5179 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 141177"];
5180 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 141178"];
5181 [label="param IsContextualKeyword(SyntaxKind kind) 141179"];
5182 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 141180"];
5183 [label="return false; 141181"];
5184 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 141182"];
5185 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 141183"];
5186 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 141184"];
5187 [label="return null; 141185"];
5188 [label="var errors = this.GetErrors(GetFullWidth(leading)); 141186"];
5189 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 141187"];
5190 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 141188"];
5191 [label="param AddTrivia(this) 141189"];
5192 [label="this.HasErrors 141190"];
5193 [label="get { return _errors != null; } 141191"];
5194 [label="return _errors != null; 141192"];
5195 [label="return _errors != null; 141193"];
5196 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 141194"];
5197 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 141195"];
5198 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 141196"];
5199 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 141197"];
5200 [label="return; 141198"];
5201 [label="param Create(SyntaxDiagnosticInfo[] errors) 141199"];
5202 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 141200"];
5203 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 141201"];
5204 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 141202"];
5205 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 141203"];
5206 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 141204"];
5207 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 141205"];
5208 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 141206"];
5209 [label="Debug.Assert(quickWidth == token.FullWidth); 141207"];
5210 [label="this.AddLexedToken(token); 141208"];
5211 [label="param AddLexedToken(SyntaxToken token) 141209"];
5212 [label="Debug.Assert(token != null); 141210"];
5213 [label="_lexedTokens[_tokenCount].Value 141211"];
5214 [label="get { return (SyntaxKind)this.RawKind; } 141212"];
5215 [label="return (SyntaxKind)this.RawKind; 141213"];
5216 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 141214"];
5217 [label="TextWindow.Start(); 141215"];
5218 [label="var quickWidth = TextWindow.Width; 141216"];
5219 [label="param LexSyntaxTrivia(bool afterFirstToken) 141217"];
5220 [label="param LexSyntaxTrivia(bool isTrailing) 141218"];
5221 [label="bool onlyWhitespaceOnLine = !isTrailing; 141219"];
5222 [label="this.Start(); 141220"];
5223 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 141221"];
5224 [label="return; 141222"];
5225 [label="this.Start(); 141223"];
5226 [label="param TryGetKeywordKind(out SyntaxKind kind) 141224"];
5227 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 141225"];
5228 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 141226"];
5229 [label="var errors = this.GetErrors(GetFullWidth(leading)); 141227"];
5230 [label="GetFullWidth(leading) 141228"];
5231 [label="param GetFullWidth(SyntaxListBuilder builder) 141229"];
5232 [label="int width = 0; 141230"];
5233 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 141231"];
5234 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 141232"];
5235 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 141233"];
5236 [label="return width; 141234"];
5237 [label="var errors = this.GetErrors(GetFullWidth(leading)); 141235"];
5238 [label="this.GetErrors(GetFullWidth(leading)) 141236"];
5239 [label="param GetErrors(int leadingTriviaWidth) 141237"];
5240 [label="param GetErrors(this) 141238"];
5241 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 141239"];
5242 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 141240"];
5243 [label="return null; 141241"];
5244 [label="var errors = this.GetErrors(GetFullWidth(leading)); 141242"];
5245 [label="param Create(SyntaxDiagnosticInfo[] errors) 141243"];
5246 [label="param Create(this) 141244"];
5247 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 141245"];
5248 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 141246"];
5249 [label="SyntaxToken token; 141247"];
5250 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 141248"];
5251 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 141249"];
5252 [label="Debug.Assert(quickWidth == token.FullWidth); 141250"];
5253 [label="return (SyntaxKind)this.RawKind; 141251"];
5254 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 141252"];
5255 [label="param AddTrivia(this) 141253"];
5256 [label="get { return _errors != null; } 141254"];
5257 [label="return _errors != null; 141255"];
5258 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 141256"];
5259 [label="this.Position 141257"];
5260 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 141258"];
5261 [label="return false; 141259"];
5262 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 141260"];
5263 [label="return InvalidCharacter; 141261"];
5264 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 141262"];
5265 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 141263"];
5266 [label="SyntaxFacts.IsWhitespace(ch) 141264"];
5267 [label="param IsWhitespace(char ch) 141265"];
5268 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 141266"];
5269 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 141267"];
5270 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 141268"];
5271 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 141269"];
5272 [label="SyntaxFacts.IsNewLine(ch) 141270"];
5273 [label="param IsNewLine(char ch) 141271"];
5274 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 141272"];
5275 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 141273"];
5276 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 141274"];
5277 [label="return; 141275"];
5278 [label="param LexSyntaxTrivia(bool afterFirstToken) 141276"];
5279 [label="param LexSyntaxTrivia(bool isTrailing) 141277"];
5280 [label="bool onlyWhitespaceOnLine = !isTrailing; 141278"];
5281 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 141279"];
5282 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 141280"];
5283 [label="return false; 141281"];
5284 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 141282"];
5285 [label="return InvalidCharacter; 141283"];
5286 [label="param IsReallyAtEnd(this) 141284"];
5287 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 141285"];
5288 [label="Position 141286"];
5289 [label="get\n            {\n                return _basis + _offset;\n            } 141287"];
5290 [label="return _basis + _offset; 141288"];
5291 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 141289"];
5292 [label="ConsList<Directive>.Empty 141290"];
5293 [label="new DirectiveStack(ConsList<Directive>.Empty) 141291"];
5294 [label="param DirectiveStack(ConsList<Directive> directives) 141292"];
5295 [label="param DirectiveStack(this) 141293"];
5296 [label="_directives 141294"];
5297 [label="Empty = new DirectiveStack(ConsList<Directive>.Empty) 141295"];
5298 [label="null 141296"];
5299 [label="new DirectiveStack(null) 141297"];
5300 [label="param DirectiveStack(ConsList<Directive> directives) 141298"];
5301 [label="param DirectiveStack(this) 141299"];
5302 [label="_directives 141300"];
5303 [label="Null = new DirectiveStack(null) 141301"];
5304 [label="param HasUnfinishedIf(this) 141302"];
5305 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 141303"];
5306 [label="GetPreviousIfElifElseOrRegion(_directives) 141304"];
5307 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 141305"];
5308 [label="var current = directives; 141306"];
5309 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 141307"];
5310 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 141308"];
5311 [label="return current; 141309"];
5312 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 141310"];
5313 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 141311"];
5314 [label="param HasUnfinishedRegion(this) 141312"];
5315 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 141313"];
5316 [label="GetPreviousIfElifElseOrRegion(_directives) 141314"];
5317 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 141315"];
5318 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 141316"];
5319 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 141317"];
5320 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 141318"];
5321 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 141319"];
5322 [label="var errors = this.GetErrors(GetFullWidth(leading)); 141320"];
5323 [label="param GetFullWidth(SyntaxListBuilder builder) 141321"];
5324 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 141322"];
5325 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 141323"];
5326 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 141324"];
5327 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 141325"];
5328 [label="return null; 141326"];
5329 [label="var errors = this.GetErrors(GetFullWidth(leading)); 141327"];
5330 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 141328"];
5331 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 141329"];
5332 [label="SyntaxFacts.IsWhitespace(ch) 141330"];
5333 [label="param IsWhitespace(char ch) 141331"];
5334 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 141332"];
5335 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 141333"];
5336 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 141334"];
5337 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 141335"];
5338 [label="SyntaxFacts.IsNewLine(ch) 141336"];
5339 [label="param IsNewLine(char ch) 141337"];
5340 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 141338"];
5341 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 141339"];
5342 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 141340"];
5343 [label="return; 141341"];
5344 [label="param Create(SyntaxDiagnosticInfo[] errors) 141342"];
5345 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 141343"];
5346 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 141344"];
5347 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 141345"];
5348 [label="param Token(GreenNode leading) 141346"];
5349 [label="param Token(SyntaxKind kind) 141347"];
5350 [label="param Token(GreenNode trailing) 141348"];
5351 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 141349"];
5352 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 141350"];
5353 [label="this.AddLexedToken(token); 141351"];
5354 [label="param AddLexedToken(SyntaxToken token) 141352"];
5355 [label="Debug.Assert(token != null); 141353"];
5356 [label="_lexedTokens[_tokenCount].Value 141354"];
5357 [label="get { return (SyntaxKind)this.RawKind; } 141355"];
5358 [label="return (SyntaxKind)this.RawKind; 141356"];
5359 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 141357"];
5360 [label="this.PreLex(); 141358"];
5361 [label="new SyntaxListPool() 141359"];
5362 [label="_pool = new SyntaxListPool() 141360"];
5363 [label="_syntaxFactoryContext 141361"];
5364 [label="_syntaxFactory 141362"];
5365 [label="_recursionDepth 141363"];
5366 [label="_termState 141364"];
5367 [label="_isInTry 141365"];
5368 [label="_checkedTopLevelStatementsFeatureAvailability 141366"];
5369 [label="_syntaxFactoryContext = new SyntaxFactoryContext(); 141367"];
5370 [label="_syntaxFactoryContext 141368"];
5371 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 141369"];
5372 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 141370"];
5373 [label="_syntaxFactory 141371"];
5374 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 141372"];
5375 [label="parser.ParseStatement() 141373"];
5376 [label="param ParseStatement(this) 141374"];
5377 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 141375"];
5378 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 141376"];
5379 [label="ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))) 141377"];
5380 [label="param ParseWithStackGuard(Func<TNode> parseFunc) 141378"];
5381 [label="param ParseWithStackGuard(Func<TNode> createEmptyNodeFunc) 141379"];
5382 [label="param ParseWithStackGuard(this) 141380"];
5383 [label="Debug.Assert(_recursionDepth == 0); 141381"];
5384 [label="Debug.Assert(_recursionDepth == 0); 141382"];
5385 [label="return parseFunc(); 141383"];
5386 [label="return parseFunc(); 141384"];
5387 [label="=> ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 141385"];
5388 [label="ParseAttributeDeclarations() 141386"];
5389 [label="param ParseAttributeDeclarations(this) 141387"];
5390 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 141388"];
5391 [label="var saveTerm = _termState; 141389"];
5392 [label="_termState |= TerminatorState.IsAttributeDeclarationTerminator; 141390"];
5393 [label="_termState 141391"];
5394 [label="this.IsPossibleAttributeDeclaration() 141392"];
5395 [label="param IsPossibleAttributeDeclaration(this) 141393"];
5396 [label="this.CurrentToken 141394"];
5397 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141395"];
5398 [label="this.FetchCurrentToken() 141396"];
5399 [label="param FetchCurrentToken(this) 141397"];
5400 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141398"];
5401 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 141399"];
5402 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 141400"];
5403 [label="return _lexedTokens[_tokenOffset]; 141401"];
5404 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 141402"];
5405 [label="_currentToken 141403"];
5406 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 141404"];
5407 [label="this.CurrentToken.Kind 141405"];
5408 [label="get { return (SyntaxKind)this.RawKind; } 141406"];
5409 [label="return (SyntaxKind)this.RawKind; 141407"];
5410 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 141408"];
5411 [label="_termState 141409"];
5412 [label="return attributes.ToList(); 141410"];
5413 [label="_pool.Free(attributes); 141411"];
5414 [label="_pool.Free(attributes); 141412"];
5415 [label="false 141413"];
5416 [label="isGlobal: false 141414"];
5417 [label="ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 141415"];
5418 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 141416"];
5419 [label="param ParseStatementCore(bool isGlobal) 141417"];
5420 [label="param ParseStatementCore(this) 141418"];
5421 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 141419"];
5422 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 141420"];
5423 [label="canReuseStatement(attributes, isGlobal) 141421"];
5424 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 141422"];
5425 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 141423"];
5426 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 141424"];
5427 [label="this.IsIncrementalAndFactoryContextMatches 141425"];
5428 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 141426"];
5429 [label="base.IsIncremental 141427"];
5430 [label="get\n            {\n                return _isIncremental;\n            } 141428"];
5431 [label="return _isIncremental; 141429"];
5432 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 141430"];
5433 [label="return false; 141431"];
5434 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 141432"];
5435 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 141433"];
5436 [label="this.GetResetPoint() 141434"];
5437 [label="param GetResetPoint(this) 141435"];
5438 [label="base.GetResetPoint() 141436"];
5439 [label="param GetResetPoint(this) 141437"];
5440 [label="CurrentTokenPosition 141438"];
5441 [label="=> _firstToken + _tokenOffset 141439"];
5442 [label="_firstToken + _tokenOffset 141440"];
5443 [label="var pos = CurrentTokenPosition; 141441"];
5444 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 141442"];
5445 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 141443"];
5446 [label="_resetStart 141444"];
5447 [label="_resetCount 141445"];
5448 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 141446"];
5449 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 141447"];
5450 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 141448"];
5451 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 141449"];
5452 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 141450"];
5453 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 141451"];
5454 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 141452"];
5455 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 141453"];
5456 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 141454"];
5457 [label="param ResetPoint(TerminatorState terminatorState) 141455"];
5458 [label="param ResetPoint(bool isInTry) 141456"];
5459 [label="param ResetPoint(bool isInAsync) 141457"];
5460 [label="param ResetPoint(int queryDepth) 141458"];
5461 [label="param ResetPoint(this) 141459"];
5462 [label="this.BaseResetPoint 141460"];
5463 [label="this.TerminatorState 141461"];
5464 [label="this.IsInTry 141462"];
5465 [label="this.IsInAsync 141463"];
5466 [label="this.QueryDepth 141464"];
5467 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 141465"];
5468 [label="_recursionDepth 141466"];
5469 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 141467"];
5470 [label="StatementSyntax result; 141468"];
5471 [label="this.CurrentToken 141469"];
5472 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141470"];
5473 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 141471"];
5474 [label="switch (this.CurrentToken.Kind)\n                {\n                    case SyntaxKind.FixedKeyword:\n                        return this.ParseFixedStatement(attributes);\n                    case SyntaxKind.BreakKeyword:\n                        return this.ParseBreakStatement(attributes);\n                    case SyntaxKind.ContinueKeyword:\n                        return this.ParseContinueStatement(attributes);\n                    case SyntaxKind.TryKeyword:\n                    case SyntaxKind.CatchKeyword:\n                    case SyntaxKind.FinallyKeyword:\n                        return this.ParseTryStatement(attributes);\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                        return this.ParseCheckedStatement(attributes);\n                    case SyntaxKind.DoKeyword:\n                        return this.ParseDoStatement(attributes);\n                    case SyntaxKind.ForKeyword:\n                        return this.ParseForOrForEachStatement(attributes);\n                    case SyntaxKind.ForEachKeyword:\n                        return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                    case SyntaxKind.GotoKeyword:\n                        return this.ParseGotoStatement(attributes);\n                    case SyntaxKind.IfKeyword:\n                        return this.ParseIfStatement(attributes);\n                    case SyntaxKind.ElseKeyword:\n                        // Including 'else' keyword to handle 'else without if' error cases \n                        return this.ParseMisplacedElse(attributes);\n                    case SyntaxKind.LockKeyword:\n                        return this.ParseLockStatement(attributes);\n                    case SyntaxKind.ReturnKeyword:\n                        return this.ParseReturnStatement(attributes);\n                    case SyntaxKind.SwitchKeyword:\n                        return this.ParseSwitchStatement(attributes);\n                    case SyntaxKind.ThrowKeyword:\n                        return this.ParseThrowStatement(attributes);\n                    case SyntaxKind.UnsafeKeyword:\n                        result = TryParseStatementStartingWithUnsafe(attributes);\n                        if (result != null)\n                            return result;\n                        break;\n                    case SyntaxKind.UsingKeyword:\n                        return ParseStatementStartingWithUsing(attributes);\n                    case SyntaxKind.WhileKeyword:\n                        return this.ParseWhileStatement(attributes);\n                    case SyntaxKind.OpenBraceToken:\n                        return this.ParseBlock(attributes);\n                    case SyntaxKind.SemicolonToken:\n                        return _syntaxFactory.EmptyStatement(attributes, this.EatToken());\n                    case SyntaxKind.IdentifierToken:\n                        result = TryParseStatementStartingWithIdentifier(attributes, isGlobal);\n                        if (result != null)\n                            return result;\n                        break;\n                } 141472"];
5475 [label="this.CurrentToken.Kind 141473"];
5476 [label="get { return (SyntaxKind)this.RawKind; } 141474"];
5477 [label="return (SyntaxKind)this.RawKind; 141475"];
5478 [label="return this.ParseSwitchStatement(attributes); 141476"];
5479 [label="this.ParseSwitchStatement(attributes) 141477"];
5480 [label="param ParseSwitchStatement(SyntaxList<AttributeListSyntax> attributes) 141478"];
5481 [label="param ParseSwitchStatement(this) 141479"];
5482 [label="this.CurrentToken 141480"];
5483 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141481"];
5484 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.SwitchKeyword); 141482"];
5485 [label="this.CurrentToken.Kind 141483"];
5486 [label="get { return (SyntaxKind)this.RawKind; } 141484"];
5487 [label="var @switch = this.EatToken(SyntaxKind.SwitchKeyword); 141485"];
5488 [label="this.EatToken(SyntaxKind.SwitchKeyword) 141486"];
5489 [label="param EatToken(SyntaxKind kind) 141487"];
5490 [label="param EatToken(this) 141488"];
5491 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 141489"];
5492 [label="SyntaxFacts.IsAnyToken(kind) 141490"];
5493 [label="param IsAnyToken(SyntaxKind kind) 141491"];
5494 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 141492"];
5495 [label="return true; 141493"];
5496 [label="this.CurrentToken 141494"];
5497 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141495"];
5498 [label="var ct = this.CurrentToken; 141496"];
5499 [label="ct.Kind 141497"];
5500 [label="get { return (SyntaxKind)this.RawKind; } 141498"];
5501 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 141499"];
5502 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 141500"];
5503 [label="MoveToNextToken() 141501"];
5504 [label="param MoveToNextToken(this) 141502"];
5505 [label="_currentToken.GetTrailingTrivia() 141503"];
5506 [label="param GetTrailingTrivia(this) 141504"];
5507 [label="return this.TrailingField; 141505"];
5508 [label="_prevTokenTrailingTrivia = _currentToken.GetTrailingTrivia(); 141506"];
5509 [label="_prevTokenTrailingTrivia 141507"];
5510 [label="_currentToken = null; 141508"];
5511 [label="_currentToken 141509"];
5512 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 141510"];
5513 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 141511"];
5514 [label="_tokenOffset 141512"];
5515 [label="MoveToNextToken(); 141513"];
5516 [label="return ct; 141514"];
5517 [label="this.ParseExpressionCore() 141515"];
5518 [label="param ParseExpressionCore(this) 141516"];
5519 [label="return this.ParseSubExpression(Precedence.Expression); 141517"];
5520 [label="this.ParseSubExpression(Precedence.Expression) 141518"];
5521 [label="param ParseSubExpression(Precedence precedence) 141519"];
5522 [label="param ParseSubExpression(this) 141520"];
5523 [label="_recursionDepth 141521"];
5524 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 141522"];
5525 [label="var result = ParseSubExpressionCore(precedence); 141523"];
5526 [label="ParseSubExpressionCore(precedence) 141524"];
5527 [label="param ParseSubExpressionCore(Precedence precedence) 141525"];
5528 [label="param ParseSubExpressionCore(this) 141526"];
5529 [label="ExpressionSyntax leftOperand; 141527"];
5530 [label="Precedence newPrecedence = 0; 141528"];
5531 [label="this.CurrentToken 141529"];
5532 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141530"];
5533 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141531"];
5534 [label="return _lexedTokens[_tokenOffset]; 141532"];
5535 [label="var tk = this.CurrentToken.Kind; 141533"];
5536 [label="this.CurrentToken.Kind 141534"];
5537 [label="get { return (SyntaxKind)this.RawKind; } 141535"];
5538 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 141536"];
5539 [label="IsInvalidSubExpression(tk) 141537"];
5540 [label="param IsInvalidSubExpression(SyntaxKind kind) 141538"];
5541 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 141539"];
5542 [label="return false; 141540"];
5543 [label="if (IsExpectedPrefixUnaryOperator(tk))\n            {\n                var opKind = SyntaxFacts.GetPrefixUnaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n                var opToken = this.EatToken();\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.PrefixUnaryExpression(opKind, opToken, operand);\n            }\n            else if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 141541"];
5544 [label="IsExpectedPrefixUnaryOperator(tk) 141542"];
5545 [label="param IsExpectedPrefixUnaryOperator(SyntaxKind kind) 141543"];
5546 [label="return SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword; 141544"];
5547 [label="SyntaxFacts.IsPrefixUnaryExpression(kind) 141545"];
5548 [label="param IsPrefixUnaryExpression(SyntaxKind token) 141546"];
5549 [label="return GetPrefixUnaryExpression(token) != SyntaxKind.None; 141547"];
5550 [label="GetPrefixUnaryExpression(token) 141548"];
5551 [label="param GetPrefixUnaryExpression(SyntaxKind token) 141549"];
5552 [label="switch (token)\n            {\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.UnaryPlusExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.UnaryMinusExpression;\n                case SyntaxKind.TildeToken:\n                    return SyntaxKind.BitwiseNotExpression;\n                case SyntaxKind.ExclamationToken:\n                    return SyntaxKind.LogicalNotExpression;\n                case SyntaxKind.PlusPlusToken:\n                    return SyntaxKind.PreIncrementExpression;\n                case SyntaxKind.MinusMinusToken:\n                    return SyntaxKind.PreDecrementExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.AddressOfExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.PointerIndirectionExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.IndexExpression;\n                default:\n                    return SyntaxKind.None;\n            } 141550"];
5553 [label="return SyntaxKind.None; 141551"];
5554 [label="if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 141552"];
5555 [label="IsAwaitExpression() 141553"];
5556 [label="param IsAwaitExpression(this) 141554"];
5557 [label="this.CurrentToken 141555"];
5558 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141556"];
5559 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 141557"];
5560 [label="this.CurrentToken.ContextualKind 141558"];
5561 [label="get\n            {\n                return this.Kind;\n            } 141559"];
5562 [label="this.Kind 141560"];
5563 [label="get { return (SyntaxKind)this.RawKind; } 141561"];
5564 [label="return this.Kind; 141562"];
5565 [label="return false; 141563"];
5566 [label="if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 141564"];
5567 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 141565"];
5568 [label="this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false) 141566"];
5569 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 141567"];
5570 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 141568"];
5571 [label="param IsQueryExpression(this) 141569"];
5572 [label="this.CurrentToken 141570"];
5573 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141571"];
5574 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 141572"];
5575 [label="this.CurrentToken.ContextualKind 141573"];
5576 [label="get\n            {\n                return this.Kind;\n            } 141574"];
5577 [label="this.Kind 141575"];
5578 [label="get { return (SyntaxKind)this.RawKind; } 141576"];
5579 [label="return this.Kind; 141577"];
5580 [label="return false; 141578"];
5581 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 141579"];
5582 [label="this.CurrentToken 141580"];
5583 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 141581"];
5584 [label="this.CurrentToken.ContextualKind 141582"];
5585 [label="get\n            {\n                return this.Kind;\n            } 141583"];
5586 [label="this.Kind 141584"];
5587 [label="get { return (SyntaxKind)this.RawKind; } 141585"];
5588 [label="return this.Kind; 141586"];
5589 [label="if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 141587"];
5590 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 141588"];
5591 [label="this.IsPossibleDeconstructionLeft(precedence) 141589"];
5592 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 141590"];
5593 [label="param IsPossibleDeconstructionLeft(this) 141591"];
5594 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 141592"];
5595 [label="this.CurrentToken 141593"];
5596 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141594"];
5597 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 141595"];
5598 [label="this.CurrentToken.IsIdentifierVar() 141596"];
5599 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 141597"];
5600 [label="node.ContextualKind 141598"];
5601 [label="get\n            {\n                return this.Kind;\n            } 141599"];
5602 [label="return node.ContextualKind == SyntaxKind.VarKeyword; 141600"];
5603 [label="this.CurrentToken 141601"];
5604 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141602"];
5605 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 141603"];
5606 [label="this.CurrentToken.Kind 141604"];
5607 [label="get { return (SyntaxKind)this.RawKind; } 141605"];
5608 [label="IsPredefinedType(this.CurrentToken.Kind) 141606"];
5609 [label="param IsPredefinedType(SyntaxKind keyword) 141607"];
5610 [label="return SyntaxFacts.IsPredefinedType(keyword); 141608"];
5611 [label="SyntaxFacts.IsPredefinedType(keyword) 141609"];
5612 [label="param IsPredefinedType(SyntaxKind kind) 141610"];
5613 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 141611"];
5614 [label="return false; 141612"];
5615 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 141613"];
5616 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 141614"];
5617 [label="return false; 141615"];
5618 [label="leftOperand = this.ParseTerm(precedence); 141616"];
5619 [label="this.ParseTerm(precedence) 141617"];
5620 [label="param ParseTerm(Precedence precedence) 141618"];
5621 [label="=> this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 141619"];
5622 [label="precedence 141620"];
5623 [label="ParseTermWithoutPostfix(precedence) 141621"];
5624 [label="param ParseTermWithoutPostfix(Precedence precedence) 141622"];
5625 [label="param ParseTermWithoutPostfix(this) 141623"];
5626 [label="this.CurrentToken 141624"];
5627 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141625"];
5628 [label="var tk = this.CurrentToken.Kind; 141626"];
5629 [label="this.CurrentToken.Kind 141627"];
5630 [label="get { return (SyntaxKind)this.RawKind; } 141628"];
5631 [label="switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                    return this.ParseTypeOfExpression();\n                case SyntaxKind.DefaultKeyword:\n                    return this.ParseDefaultExpression();\n                case SyntaxKind.SizeOfKeyword:\n                    return this.ParseSizeOfExpression();\n                case SyntaxKind.MakeRefKeyword:\n                    return this.ParseMakeRefExpression();\n                case SyntaxKind.RefTypeKeyword:\n                    return this.ParseRefTypeExpression();\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    return this.ParseCheckedOrUncheckedExpression();\n                case SyntaxKind.RefValueKeyword:\n                    return this.ParseRefValueExpression();\n                case SyntaxKind.ColonColonToken:\n                    // misplaced ::\n                    // Calling ParseAliasQualifiedName will cause us to create a missing identifier node that then\n                    // properly consumes the :: and the reset of the alias name afterwards.\n                    return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return this.ParseLambdaExpression();\n                case SyntaxKind.StaticKeyword:\n                    if (this.IsPossibleAnonymousMethodExpression())\n                    {\n                        return this.ParseAnonymousMethodExpression();\n                    }\n                    else if (this.IsPossibleLambdaExpression(precedence))\n                    {\n                        return this.ParseLambdaExpression();\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.ThisKeyword:\n                    return _syntaxFactory.ThisExpression(this.EatToken());\n                case SyntaxKind.BaseKeyword:\n                    return ParseBaseExpression();\n\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                    return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken());\n                case SyntaxKind.InterpolatedStringStartToken:\n                    throw new NotImplementedException(); // this should not occur because these tokens are produced and parsed immediately\n                case SyntaxKind.InterpolatedStringToken:\n                    return this.ParseInterpolatedStringToken();\n                case SyntaxKind.OpenParenToken:\n                    return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence);\n                case SyntaxKind.NewKeyword:\n                    return this.ParseNewExpression();\n                case SyntaxKind.StackAllocKeyword:\n                    return this.ParseStackAllocExpression();\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseAnonymousMethodExpression();\n                case SyntaxKind.RefKeyword:\n                    // ref is not expected to appear in this position.\n                    return this.AddError(ParsePossibleRefExpression(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                default:\n                    // check for intrinsic type followed by '.'\n                    if (IsPredefinedType(tk))\n                    {\n                        var expr = _syntaxFactory.PredefinedType(this.EatToken());\n\n                        if (this.CurrentToken.Kind != SyntaxKind.DotToken || tk == SyntaxKind.VoidKeyword)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n                    else\n                    {\n                        var expr = this.CreateMissingIdentifierName();\n\n                        if (tk == SyntaxKind.EndOfFileToken)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_ExpressionExpected);\n                        }\n                        else\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n            } 141629"];
5632 [label="return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence); 141630"];
5633 [label="this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence) 141631"];
5634 [label="param ParseCastOrParenExpressionOrLambdaOrTuple(Precedence precedence) 141632"];
5635 [label="param ParseCastOrParenExpressionOrLambdaOrTuple(this) 141633"];
5636 [label="this.CurrentToken 141634"];
5637 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141635"];
5638 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.OpenParenToken); 141636"];
5639 [label="this.CurrentToken.Kind 141637"];
5640 [label="get { return (SyntaxKind)this.RawKind; } 141638"];
5641 [label="this.GetResetPoint() 141639"];
5642 [label="param GetResetPoint(this) 141640"];
5643 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 141641"];
5644 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 141642"];
5645 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 141643"];
5646 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 141644"];
5647 [label="param ResetPoint(TerminatorState terminatorState) 141645"];
5648 [label="param ResetPoint(bool isInTry) 141646"];
5649 [label="param ResetPoint(bool isInAsync) 141647"];
5650 [label="param ResetPoint(int queryDepth) 141648"];
5651 [label="param ResetPoint(this) 141649"];
5652 [label="this.BaseResetPoint 141650"];
5653 [label="this.TerminatorState 141651"];
5654 [label="this.IsInTry 141652"];
5655 [label="this.IsInAsync 141653"];
5656 [label="this.QueryDepth 141654"];
5657 [label="var resetPoint = this.GetResetPoint(); 141655"];
5658 [label="if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 141656"];
5659 [label="ScanParenthesizedImplicitlyTypedLambda(precedence) 141657"];
5660 [label="param ScanParenthesizedImplicitlyTypedLambda(Precedence precedence) 141658"];
5661 [label="param ScanParenthesizedImplicitlyTypedLambda(this) 141659"];
5662 [label="if (!(precedence <= Precedence.Lambda))\n            {\n                return false;\n            } 141660"];
5663 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 141661"];
5664 [label="this.PeekToken(1) 141662"];
5665 [label="param PeekToken(int n) 141663"];
5666 [label="param PeekToken(this) 141664"];
5667 [label="Debug.Assert(n >= 0); 141665"];
5668 [label="Debug.Assert(n >= 0); 141666"];
5669 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141667"];
5670 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141668"];
5671 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141669"];
5672 [label="return _lexedTokens[_tokenOffset + n]; 141670"];
5673 [label="this.PeekToken(1).Kind 141671"];
5674 [label="get { return (SyntaxKind)this.RawKind; } 141672"];
5675 [label="this.IsInQuery 141673"];
5676 [label="get { return _syntaxFactoryContext.IsInQuery; } 141674"];
5677 [label="return _syntaxFactoryContext.IsInQuery; 141675"];
5678 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 141676"];
5679 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 141677"];
5680 [label="this.PeekToken(2) 141678"];
5681 [label="param PeekToken(int n) 141679"];
5682 [label="param PeekToken(this) 141680"];
5683 [label="Debug.Assert(n >= 0); 141681"];
5684 [label="Debug.Assert(n >= 0); 141682"];
5685 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141683"];
5686 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141684"];
5687 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141685"];
5688 [label="return _lexedTokens[_tokenOffset + n]; 141686"];
5689 [label="this.PeekToken(2).Kind 141687"];
5690 [label="get { return (SyntaxKind)this.RawKind; } 141688"];
5691 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 141689"];
5692 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 141690"];
5693 [label="this.PeekToken(1) 141691"];
5694 [label="param PeekToken(int n) 141692"];
5695 [label="param PeekToken(this) 141693"];
5696 [label="Debug.Assert(n >= 0); 141694"];
5697 [label="Debug.Assert(n >= 0); 141695"];
5698 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141696"];
5699 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141697"];
5700 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141698"];
5701 [label="return _lexedTokens[_tokenOffset + n]; 141699"];
5702 [label="IsTrueIdentifier(this.PeekToken(1)) 141700"];
5703 [label="param IsTrueIdentifier(SyntaxToken token) 141701"];
5704 [label="param IsTrueIdentifier(this) 141702"];
5705 [label="token.Kind 141703"];
5706 [label="get { return (SyntaxKind)this.RawKind; } 141704"];
5707 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 141705"];
5708 [label="this.IsInQuery 141706"];
5709 [label="get { return _syntaxFactoryContext.IsInQuery; } 141707"];
5710 [label="return _syntaxFactoryContext.IsInQuery; 141708"];
5711 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 141709"];
5712 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 141710"];
5713 [label="this.PeekToken(2) 141711"];
5714 [label="param PeekToken(int n) 141712"];
5715 [label="param PeekToken(this) 141713"];
5716 [label="Debug.Assert(n >= 0); 141714"];
5717 [label="Debug.Assert(n >= 0); 141715"];
5718 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141716"];
5719 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141717"];
5720 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141718"];
5721 [label="return _lexedTokens[_tokenOffset + n]; 141719"];
5722 [label="this.PeekToken(2).Kind 141720"];
5723 [label="get { return (SyntaxKind)this.RawKind; } 141721"];
5724 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 141722"];
5725 [label="this.PeekToken(3) 141723"];
5726 [label="param PeekToken(int n) 141724"];
5727 [label="param PeekToken(this) 141725"];
5728 [label="Debug.Assert(n >= 0); 141726"];
5729 [label="Debug.Assert(n >= 0); 141727"];
5730 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141728"];
5731 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141729"];
5732 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141730"];
5733 [label="return _lexedTokens[_tokenOffset + n]; 141731"];
5734 [label="this.PeekToken(3).Kind 141732"];
5735 [label="get { return (SyntaxKind)this.RawKind; } 141733"];
5736 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 141734"];
5737 [label="if (this.PeekToken(1).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 141735"];
5738 [label="this.PeekToken(1) 141736"];
5739 [label="param PeekToken(int n) 141737"];
5740 [label="param PeekToken(this) 141738"];
5741 [label="Debug.Assert(n >= 0); 141739"];
5742 [label="Debug.Assert(n >= 0); 141740"];
5743 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141741"];
5744 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141742"];
5745 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141743"];
5746 [label="return _lexedTokens[_tokenOffset + n]; 141744"];
5747 [label="this.PeekToken(1).Kind 141745"];
5748 [label="get { return (SyntaxKind)this.RawKind; } 141746"];
5749 [label="if (this.PeekToken(1).Kind == SyntaxKind.ParamsKeyword)\n            {\n                return true;\n            } 141747"];
5750 [label="this.PeekToken(1) 141748"];
5751 [label="param PeekToken(int n) 141749"];
5752 [label="param PeekToken(this) 141750"];
5753 [label="Debug.Assert(n >= 0); 141751"];
5754 [label="Debug.Assert(n >= 0); 141752"];
5755 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141753"];
5756 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141754"];
5757 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141755"];
5758 [label="return _lexedTokens[_tokenOffset + n]; 141756"];
5759 [label="this.PeekToken(1).Kind 141757"];
5760 [label="get { return (SyntaxKind)this.RawKind; } 141758"];
5761 [label="return false; 141759"];
5762 [label="if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 141760"];
5763 [label="if (this.ScanCast())\n                {\n                    if (!IsCurrentTokenQueryKeywordInQuery())\n                    {\n                        // Looks like a cast, so parse it as one.\n                        this.Reset(ref resetPoint);\n                        var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                        var type = this.ParseType();\n                        var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                        var expr = this.ParseSubExpression(Precedence.Cast);\n                        return _syntaxFactory.CastExpression(openParen, type, closeParen, expr);\n                    }\n                } 141761"];
5764 [label="this.ScanCast() 141762"];
5765 [label="param ScanCast(bool forPattern = false) 141763"];
5766 [label="param ScanCast(this) 141764"];
5767 [label="this.CurrentToken 141765"];
5768 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141766"];
5769 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 141767"];
5770 [label="if (this.CurrentToken.Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            } 141768"];
5771 [label="this.CurrentToken.Kind 141769"];
5772 [label="get { return (SyntaxKind)this.RawKind; } 141770"];
5773 [label="this.EatToken() 141771"];
5774 [label="param EatToken(this) 141772"];
5775 [label="this.CurrentToken 141773"];
5776 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141774"];
5777 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 141775"];
5778 [label="var ct = this.CurrentToken; 141776"];
5779 [label="MoveToNextToken() 141777"];
5780 [label="param MoveToNextToken(this) 141778"];
5781 [label="param GetTrailingTrivia(this) 141779"];
5782 [label="return null; 141780"];
5783 [label="_prevTokenTrailingTrivia 141781"];
5784 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 141782"];
5785 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 141783"];
5786 [label="_tokenOffset 141784"];
5787 [label="MoveToNextToken(); 141785"];
5788 [label="return ct; 141786"];
5789 [label="this.EatToken(); 141787"];
5790 [label="var type = this.ScanType(forPattern: forPattern); 141788"];
5791 [label="this.ScanType(forPattern: forPattern) 141789"];
5792 [label="param ScanType(bool forPattern = false) 141790"];
5793 [label="param ScanType(this) 141791"];
5794 [label="return ScanType(out _, forPattern); 141792"];
5795 [label="return ScanType(out _, forPattern); 141793"];
5796 [label="ScanType(out _, forPattern) 141794"];
5797 [label="param ScanType(out SyntaxToken lastTokenOfType) 141795"];
5798 [label="param ScanType(bool forPattern = false) 141796"];
5799 [label="param ScanType(this) 141797"];
5800 [label="forPattern 141798"];
5801 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 141799"];
5802 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 141800"];
5803 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 141801"];
5804 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 141802"];
5805 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141803"];
5806 [label="param PeekToken(int n) 141804"];
5807 [label="param PeekToken(this) 141805"];
5808 [label="Debug.Assert(n >= 0); 141806"];
5809 [label="Debug.Assert(n >= 0); 141807"];
5810 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141808"];
5811 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141809"];
5812 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 141810"];
5813 [label="return _lexedTokens[_tokenOffset + n]; 141811"];
5814 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 141812"];
5815 [label="param ScanNamedTypePart(this) 141813"];
5816 [label="this.CurrentToken 141814"];
5817 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141815"];
5818 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 141816"];
5819 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 141817"];
5820 [label="this.CurrentToken.Kind 141818"];
5821 [label="get { return (SyntaxKind)this.RawKind; } 141819"];
5822 [label="this.IsTrueIdentifier() 141820"];
5823 [label="param IsTrueIdentifier(this) 141821"];
5824 [label="this.CurrentToken 141822"];
5825 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141823"];
5826 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 141824"];
5827 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 141825"];
5828 [label="this.CurrentToken.Kind 141826"];
5829 [label="get { return (SyntaxKind)this.RawKind; } 141827"];
5830 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 141828"];
5831 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 141829"];
5832 [label="this.CurrentToken 141830"];
5833 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141831"];
5834 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 141832"];
5835 [label="this.CurrentToken.ContextualKind 141833"];
5836 [label="get\n            {\n                return this.Kind;\n            } 141834"];
5837 [label="return false; 141835"];
5838 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 141836"];
5839 [label="IsCurrentTokenQueryKeywordInQuery() 141837"];
5840 [label="param IsCurrentTokenQueryKeywordInQuery(this) 141838"];
5841 [label="this.IsInQuery 141839"];
5842 [label="get { return _syntaxFactoryContext.IsInQuery; } 141840"];
5843 [label="return _syntaxFactoryContext.IsInQuery; 141841"];
5844 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 141842"];
5845 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 141843"];
5846 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 141844"];
5847 [label="IsCurrentTokenWhereOfConstraintClause() 141845"];
5848 [label="param IsCurrentTokenWhereOfConstraintClause(this) 141846"];
5849 [label="this.CurrentToken 141847"];
5850 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141848"];
5851 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 141849"];
5852 [label="this.CurrentToken.ContextualKind 141850"];
5853 [label="get\n            {\n                return this.Kind;\n            } 141851"];
5854 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 141852"];
5855 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 141853"];
5856 [label="return true; 141854"];
5857 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 141855"];
5858 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 141856"];
5859 [label="this.EatToken() 141857"];
5860 [label="param EatToken(this) 141858"];
5861 [label="this.CurrentToken 141859"];
5862 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141860"];
5863 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 141861"];
5864 [label="var ct = this.CurrentToken; 141862"];
5865 [label="MoveToNextToken() 141863"];
5866 [label="param GetTrailingTrivia(this) 141864"];
5867 [label="return null; 141865"];
5868 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 141866"];
5869 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 141867"];
5870 [label="_tokenOffset 141868"];
5871 [label="MoveToNextToken(); 141869"];
5872 [label="return ct; 141870"];
5873 [label="lastTokenOfType = this.EatToken(); 141871"];
5874 [label="this.CurrentToken 141872"];
5875 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141873"];
5876 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141874"];
5877 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 141875"];
5878 [label="return _lexedTokens[_tokenOffset]; 141876"];
5879 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                return this.ScanPossibleTypeArgumentList(ref lastTokenOfType, out _);\n            }\n            else\n            {\n                return ScanTypeFlags.NonGenericTypeOrExpression;\n            } 141877"];
5880 [label="this.CurrentToken.Kind 141878"];
5881 [label="get { return (SyntaxKind)this.RawKind; } 141879"];
5882 [label="return ScanTypeFlags.NonGenericTypeOrExpression; 141880"];
5883 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 141881"];
5884 [label="param IsDotOrColonColon(this) 141882"];
5885 [label="this.CurrentToken 141883"];
5886 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141884"];
5887 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 141885"];
5888 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 141886"];
5889 [label="this.CurrentToken.Kind 141887"];
5890 [label="get { return (SyntaxKind)this.RawKind; } 141888"];
5891 [label="this.CurrentToken 141889"];
5892 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141890"];
5893 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 141891"];
5894 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 141892"];
5895 [label="this.CurrentToken.Kind 141893"];
5896 [label="get { return (SyntaxKind)this.RawKind; } 141894"];
5897 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 141895"];
5898 [label="param IsMakingProgress(ref int lastTokenPosition) 141896"];
5899 [label="param IsMakingProgress(bool assertIfFalse = true) 141897"];
5900 [label="param IsMakingProgress(this) 141898"];
5901 [label="CurrentTokenPosition 141899"];
5902 [label="=> _firstToken + _tokenOffset 141900"];
5903 [label="_firstToken + _tokenOffset 141901"];
5904 [label="var pos = CurrentTokenPosition; 141902"];
5905 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 141903"];
5906 [label="lastTokenPosition = pos; 141904"];
5907 [label="return true; 141905"];
5908 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 141906"];
5909 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 141907"];
5910 [label="if (type == ScanTypeFlags.NotType)\n            {\n                return false;\n            } 141908"];
5911 [label="this.CurrentToken 141909"];
5912 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141910"];
5913 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 141911"];
5914 [label="if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n            {\n                return false;\n            } 141912"];
5915 [label="this.CurrentToken.Kind 141913"];
5916 [label="get { return (SyntaxKind)this.RawKind; } 141914"];
5917 [label="this.EatToken() 141915"];
5918 [label="param EatToken(this) 141916"];
5919 [label="this.CurrentToken 141917"];
5920 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141918"];
5921 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 141919"];
5922 [label="MoveToNextToken() 141920"];
5923 [label="param MoveToNextToken(this) 141921"];
5924 [label="param GetTrailingTrivia(this) 141922"];
5925 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 141923"];
5926 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 141924"];
5927 [label="_tokenOffset 141925"];
5928 [label="MoveToNextToken(); 141926"];
5929 [label="this.EatToken(); 141927"];
5930 [label="switch (type)\n            {\n                // If we have any of the following, we know it must be a cast:\n                // 1) (Goo*)bar;\n                // 2) (Goo?)bar;\n                // 3) '(int)bar' or '(int[])bar'\n                // 4) (G::Goo)bar\n                case ScanTypeFlags.PointerOrMultiplication:\n                case ScanTypeFlags.NullableType:\n                case ScanTypeFlags.MustBeType:\n                case ScanTypeFlags.AliasQualifiedName:\n                    // The thing between parens is unambiguously a type.\n                    // In a pattern, we need more lookahead to confirm it is a cast and not\n                    // a parenthesized type pattern.  In this case the tokens that\n                    // have both unary and binary operator forms may appear in their unary form\n                    // following a cast.\n                    return !forPattern || this.CurrentToken.Kind switch\n                    {\n                        SyntaxKind.PlusToken => true,\n                        SyntaxKind.MinusToken => true,\n                        SyntaxKind.AmpersandToken => true,\n                        SyntaxKind.AsteriskToken => true,\n                        SyntaxKind.DotDotToken => true,\n                        _ => CanFollowCast(this.CurrentToken.Kind)\n                    };\n\n                case ScanTypeFlags.GenericTypeOrMethod:\n                case ScanTypeFlags.GenericTypeOrExpression:\n                case ScanTypeFlags.NonGenericTypeOrExpression:\n                case ScanTypeFlags.TupleType:\n                    // check for ambiguous type or expression followed by disambiguating token.  i.e.\n                    //\n                    // '(A)b' is a cast.  But '(A)+b' is not a cast.  \n                    return CanFollowCast(this.CurrentToken.Kind);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(type);\n            } 141928"];
5931 [label="this.CurrentToken 141929"];
5932 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141930"];
5933 [label="return _lexedTokens[_tokenOffset]; 141931"];
5934 [label="return CanFollowCast(this.CurrentToken.Kind); 141932"];
5935 [label="this.CurrentToken.Kind 141933"];
5936 [label="get { return (SyntaxKind)this.RawKind; } 141934"];
5937 [label="CanFollowCast(this.CurrentToken.Kind) 141935"];
5938 [label="param CanFollowCast(SyntaxKind kind) 141936"];
5939 [label="switch (kind)\n            {\n                case SyntaxKind.AsKeyword:\n                case SyntaxKind.IsKeyword:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.EqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.QuestionToken:\n                case SyntaxKind.ColonToken:\n                case SyntaxKind.BarBarToken:\n                case SyntaxKind.AmpersandAmpersandToken:\n                case SyntaxKind.BarToken:\n                case SyntaxKind.CaretToken:\n                case SyntaxKind.AmpersandToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.LessThanLessThanToken:\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                case SyntaxKind.PlusToken:\n                case SyntaxKind.MinusToken:\n                case SyntaxKind.AsteriskToken:\n                case SyntaxKind.SlashToken:\n                case SyntaxKind.PercentToken:\n                case SyntaxKind.PlusPlusToken:\n                case SyntaxKind.MinusMinusToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                case SyntaxKind.QuestionQuestionToken:\n                case SyntaxKind.EndOfFileToken:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.EqualsGreaterThanToken:\n                case SyntaxKind.DotDotToken:\n                    return false;\n                default:\n                    return true;\n            } 141937"];
5940 [label="return false; 141938"];
5941 [label="this.Reset(ref resetPoint); 141939"];
5942 [label="this.Reset(ref resetPoint) 141940"];
5943 [label="param Reset(ref ResetPoint state) 141941"];
5944 [label="param Reset(this) 141942"];
5945 [label="_termState 141943"];
5946 [label="_isInTry 141944"];
5947 [label="_syntaxFactoryContext.IsInAsync 141945"];
5948 [label="_syntaxFactoryContext.QueryDepth 141946"];
5949 [label="base.Reset(ref state.BaseResetPoint); 141947"];
5950 [label="base.Reset(ref state.BaseResetPoint) 141948"];
5951 [label="param Reset(ref ResetPoint point) 141949"];
5952 [label="param Reset(this) 141950"];
5953 [label="var offset = point.Position - _firstToken; 141951"];
5954 [label="Debug.Assert(offset >= 0); 141952"];
5955 [label="Debug.Assert(offset >= 0); 141953"];
5956 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 141954"];
5957 [label="_mode 141955"];
5958 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 141956"];
5959 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 141957"];
5960 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 141958"];
5961 [label="_tokenOffset 141959"];
5962 [label="_currentToken = null; 141960"];
5963 [label="_currentToken 141961"];
5964 [label="_currentNode = default(BlendedNode); 141962"];
5965 [label="_currentNode 141963"];
5966 [label="_prevTokenTrailingTrivia 141964"];
5967 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 141965"];
5968 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 141966"];
5969 [label="base.Reset(ref state.BaseResetPoint); 141967"];
5970 [label="this.Reset(ref resetPoint); 141968"];
5971 [label="if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 141969"];
5972 [label="this.ScanExplicitlyTypedLambda(precedence) 141970"];
5973 [label="param ScanExplicitlyTypedLambda(Precedence precedence) 141971"];
5974 [label="param ScanExplicitlyTypedLambda(this) 141972"];
5975 [label="if (!(precedence <= Precedence.Lambda))\n            {\n                return false;\n            } 141973"];
5976 [label="this.GetResetPoint() 141974"];
5977 [label="param GetResetPoint(this) 141975"];
5978 [label="_firstToken + _tokenOffset 141976"];
5979 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 141977"];
5980 [label="_resetCount 141978"];
5981 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 141979"];
5982 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 141980"];
5983 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 141981"];
5984 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 141982"];
5985 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 141983"];
5986 [label="param ResetPoint(this) 141984"];
5987 [label="var resetPoint = this.GetResetPoint(); 141985"];
5988 [label="bool foundParameterModifier = false; 141986"];
5989 [label="while (true)\n                {\n                    // Advance past the open paren or comma.\n                    this.EatToken();\n\n                    // Eat 'out' or 'ref' for cases [3, 6]. Even though not allowed in a lambda,\n                    // we treat `params` similarly for better error recovery.\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.RefKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                            {\n                                this.EatToken();\n                            }\n                            break;\n                        case SyntaxKind.OutKeyword:\n                        case SyntaxKind.InKeyword:\n                        case SyntaxKind.ParamsKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            break;\n                    }\n\n                    if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        return foundParameterModifier;\n                    }\n\n                    // NOTE: advances CurrentToken\n                    if (this.ScanType() == ScanTypeFlags.NotType)\n                    {\n                        return false;\n                    }\n\n                    if (this.IsTrueIdentifier())\n                    {\n                        // eat the identifier\n                        this.EatToken();\n                    }\n\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.EndOfFileToken:\n                            return foundParameterModifier;\n\n                        case SyntaxKind.CommaToken:\n                            if (foundParameterModifier)\n                            {\n                                return true;\n                            }\n\n                            continue;\n\n                        case SyntaxKind.CloseParenToken:\n                            return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken;\n\n                        default:\n                            return false;\n                    }\n                } 141987"];
5990 [label="this.EatToken() 141988"];
5991 [label="param EatToken(this) 141989"];
5992 [label="this.CurrentToken 141990"];
5993 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 141991"];
5994 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 141992"];
5995 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 141993"];
5996 [label="MoveToNextToken() 141994"];
5997 [label="param MoveToNextToken(this) 141995"];
5998 [label="param GetTrailingTrivia(this) 141996"];
5999 [label="return null; 141997"];
6000 [label="_prevTokenTrailingTrivia 141998"];
6001 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 141999"];
6002 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 142000"];
6003 [label="_tokenOffset 142001"];
6004 [label="MoveToNextToken(); 142002"];
6005 [label="this.EatToken(); 142003"];
6006 [label="this.CurrentToken 142004"];
6007 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142005"];
6008 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142006"];
6009 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 142007"];
6010 [label="return _lexedTokens[_tokenOffset]; 142008"];
6011 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.RefKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                            {\n                                this.EatToken();\n                            }\n                            break;\n                        case SyntaxKind.OutKeyword:\n                        case SyntaxKind.InKeyword:\n                        case SyntaxKind.ParamsKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            break;\n                    } 142009"];
6012 [label="this.CurrentToken.Kind 142010"];
6013 [label="get { return (SyntaxKind)this.RawKind; } 142011"];
6014 [label="this.CurrentToken 142012"];
6015 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142013"];
6016 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142014"];
6017 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        return foundParameterModifier;\n                    } 142015"];
6018 [label="this.CurrentToken.Kind 142016"];
6019 [label="get { return (SyntaxKind)this.RawKind; } 142017"];
6020 [label="if (this.ScanType() == ScanTypeFlags.NotType)\n                    {\n                        return false;\n                    } 142018"];
6021 [label="this.ScanType() 142019"];
6022 [label="param ScanType(bool forPattern = false) 142020"];
6023 [label="param ScanType(this) 142021"];
6024 [label="return ScanType(out _, forPattern); 142022"];
6025 [label="return ScanType(out _, forPattern); 142023"];
6026 [label="ScanType(out _, forPattern) 142024"];
6027 [label="param ScanType(out SyntaxToken lastTokenOfType) 142025"];
6028 [label="param ScanType(bool forPattern = false) 142026"];
6029 [label="param ScanType(this) 142027"];
6030 [label="forPattern 142028"];
6031 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 142029"];
6032 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 142030"];
6033 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 142031"];
6034 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 142032"];
6035 [label="Debug.Assert(n >= 0); 142033"];
6036 [label="Debug.Assert(n >= 0); 142034"];
6037 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142035"];
6038 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 142036"];
6039 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 142037"];
6040 [label="this.CurrentToken 142038"];
6041 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142039"];
6042 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 142040"];
6043 [label="this.CurrentToken.Kind 142041"];
6044 [label="get { return (SyntaxKind)this.RawKind; } 142042"];
6045 [label="this.IsTrueIdentifier() 142043"];
6046 [label="param IsTrueIdentifier(this) 142044"];
6047 [label="this.CurrentToken 142045"];
6048 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142046"];
6049 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 142047"];
6050 [label="this.CurrentToken.Kind 142048"];
6051 [label="get { return (SyntaxKind)this.RawKind; } 142049"];
6052 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 142050"];
6053 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 142051"];
6054 [label="this.CurrentToken 142052"];
6055 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142053"];
6056 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 142054"];
6057 [label="this.CurrentToken.ContextualKind 142055"];
6058 [label="get\n            {\n                return this.Kind;\n            } 142056"];
6059 [label="return false; 142057"];
6060 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142058"];
6061 [label="IsCurrentTokenQueryKeywordInQuery() 142059"];
6062 [label="param IsCurrentTokenQueryKeywordInQuery(this) 142060"];
6063 [label="this.IsInQuery 142061"];
6064 [label="get { return _syntaxFactoryContext.IsInQuery; } 142062"];
6065 [label="return _syntaxFactoryContext.IsInQuery; 142063"];
6066 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 142064"];
6067 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142065"];
6068 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142066"];
6069 [label="IsCurrentTokenWhereOfConstraintClause() 142067"];
6070 [label="param IsCurrentTokenWhereOfConstraintClause(this) 142068"];
6071 [label="this.CurrentToken 142069"];
6072 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142070"];
6073 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 142071"];
6074 [label="this.CurrentToken.ContextualKind 142072"];
6075 [label="get\n            {\n                return this.Kind;\n            } 142073"];
6076 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142074"];
6077 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142075"];
6078 [label="return true; 142076"];
6079 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 142077"];
6080 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 142078"];
6081 [label="this.EatToken() 142079"];
6082 [label="this.CurrentToken 142080"];
6083 [label="MoveToNextToken() 142081"];
6084 [label="param GetTrailingTrivia(this) 142082"];
6085 [label="return null; 142083"];
6086 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 142084"];
6087 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 142085"];
6088 [label="MoveToNextToken(); 142086"];
6089 [label="this.CurrentToken 142087"];
6090 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142088"];
6091 [label="this.CurrentToken.Kind 142089"];
6092 [label="this.CurrentToken 142090"];
6093 [label="this.CurrentToken.Kind 142091"];
6094 [label="this.CurrentToken 142092"];
6095 [label="this.CurrentToken.Kind 142093"];
6096 [label="param IsMakingProgress(bool assertIfFalse = true) 142094"];
6097 [label="CurrentTokenPosition 142095"];
6098 [label="this.IsTrueIdentifier() 142096"];
6099 [label="param IsTrueIdentifier(this) 142097"];
6100 [label="this.CurrentToken 142098"];
6101 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142099"];
6102 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142100"];
6103 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 142101"];
6104 [label="this.CurrentToken.Kind 142102"];
6105 [label="get { return (SyntaxKind)this.RawKind; } 142103"];
6106 [label="return false; 142104"];
6107 [label="if (this.IsTrueIdentifier())\n                    {\n                        // eat the identifier\n                        this.EatToken();\n                    } 142105"];
6108 [label="this.CurrentToken 142106"];
6109 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142107"];
6110 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142108"];
6111 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.EndOfFileToken:\n                            return foundParameterModifier;\n\n                        case SyntaxKind.CommaToken:\n                            if (foundParameterModifier)\n                            {\n                                return true;\n                            }\n\n                            continue;\n\n                        case SyntaxKind.CloseParenToken:\n                            return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken;\n\n                        default:\n                            return false;\n                    } 142109"];
6112 [label="this.CurrentToken.Kind 142110"];
6113 [label="get { return (SyntaxKind)this.RawKind; } 142111"];
6114 [label="return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken; 142112"];
6115 [label="this.PeekToken(1) 142113"];
6116 [label="param PeekToken(int n) 142114"];
6117 [label="Debug.Assert(n >= 0); 142115"];
6118 [label="Debug.Assert(n >= 0); 142116"];
6119 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142117"];
6120 [label="this.PeekToken(1).Kind 142118"];
6121 [label="get { return (SyntaxKind)this.RawKind; } 142119"];
6122 [label="this.Reset(ref resetPoint); 142120"];
6123 [label="this.Reset(ref resetPoint) 142121"];
6124 [label="param Reset(ref ResetPoint state) 142122"];
6125 [label="Debug.Assert(offset >= 0); 142123"];
6126 [label="Debug.Assert(offset >= 0); 142124"];
6127 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 142125"];
6128 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 142126"];
6129 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 142127"];
6130 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 142128"];
6131 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 142129"];
6132 [label="this.Reset(ref resetPoint); 142130"];
6133 [label="this.Release(ref resetPoint); 142131"];
6134 [label="this.Release(ref resetPoint) 142132"];
6135 [label="param Release(ref ResetPoint state) 142133"];
6136 [label="param Release(this) 142134"];
6137 [label="base.Release(ref state.BaseResetPoint); 142135"];
6138 [label="base.Release(ref state.BaseResetPoint) 142136"];
6139 [label="param Release(ref ResetPoint point) 142137"];
6140 [label="param Release(this) 142138"];
6141 [label="Debug.Assert(_resetCount == point.ResetCount); 142139"];
6142 [label="_resetCount 142140"];
6143 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 142141"];
6144 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 142142"];
6145 [label="base.Release(ref state.BaseResetPoint); 142143"];
6146 [label="this.Release(ref resetPoint); 142144"];
6147 [label="if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 142145"];
6148 [label="this.Reset(ref resetPoint); 142146"];
6149 [label="this.Reset(ref resetPoint) 142147"];
6150 [label="param Reset(ref ResetPoint state) 142148"];
6151 [label="param Reset(this) 142149"];
6152 [label="_termState 142150"];
6153 [label="_isInTry 142151"];
6154 [label="_syntaxFactoryContext.IsInAsync 142152"];
6155 [label="_syntaxFactoryContext.QueryDepth 142153"];
6156 [label="base.Reset(ref state.BaseResetPoint); 142154"];
6157 [label="base.Reset(ref state.BaseResetPoint) 142155"];
6158 [label="param Reset(this) 142156"];
6159 [label="var offset = point.Position - _firstToken; 142157"];
6160 [label="Debug.Assert(offset >= 0); 142158"];
6161 [label="Debug.Assert(offset >= 0); 142159"];
6162 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 142160"];
6163 [label="_mode 142161"];
6164 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 142162"];
6165 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 142163"];
6166 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 142164"];
6167 [label="_currentToken = null; 142165"];
6168 [label="_currentToken 142166"];
6169 [label="_currentNode = default(BlendedNode); 142167"];
6170 [label="_currentNode 142168"];
6171 [label="_prevTokenTrailingTrivia 142169"];
6172 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 142170"];
6173 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 142171"];
6174 [label="base.Reset(ref state.BaseResetPoint); 142172"];
6175 [label="this.Reset(ref resetPoint); 142173"];
6176 [label="var openParen = this.EatToken(SyntaxKind.OpenParenToken); 142174"];
6177 [label="this.EatToken(SyntaxKind.OpenParenToken) 142175"];
6178 [label="param EatToken(SyntaxKind kind) 142176"];
6179 [label="param EatToken(this) 142177"];
6180 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 142178"];
6181 [label="SyntaxFacts.IsAnyToken(kind) 142179"];
6182 [label="param IsAnyToken(SyntaxKind kind) 142180"];
6183 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 142181"];
6184 [label="return true; 142182"];
6185 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142183"];
6186 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 142184"];
6187 [label="return _lexedTokens[_tokenOffset]; 142185"];
6188 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 142186"];
6189 [label="param GetTrailingTrivia(this) 142187"];
6190 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 142188"];
6191 [label="MoveToNextToken(); 142189"];
6192 [label="return ct; 142190"];
6193 [label="var expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true); 142191"];
6194 [label="var expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true); 142192"];
6195 [label="this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true) 142193"];
6196 [label="param ParseExpressionOrDeclaration(ParseTypeMode mode) 142194"];
6197 [label="param ParseExpressionOrDeclaration(MessageID feature) 142195"];
6198 [label="param ParseExpressionOrDeclaration(bool permitTupleDesignation) 142196"];
6199 [label="param ParseExpressionOrDeclaration(this) 142197"];
6200 [label="return IsPossibleDeclarationExpression(mode, permitTupleDesignation)\n                ? this.ParseDeclarationExpression(mode, feature)\n                : this.ParseSubExpression(Precedence.Expression); 142198"];
6201 [label="return IsPossibleDeclarationExpression(mode, permitTupleDesignation)\n                ? this.ParseDeclarationExpression(mode, feature)\n                : this.ParseSubExpression(Precedence.Expression); 142199"];
6202 [label="IsPossibleDeclarationExpression(mode, permitTupleDesignation) 142200"];
6203 [label="param IsPossibleDeclarationExpression(ParseTypeMode mode) 142201"];
6204 [label="param IsPossibleDeclarationExpression(bool permitTupleDesignation) 142202"];
6205 [label="param IsPossibleDeclarationExpression(this) 142203"];
6206 [label="this.IsInAsync 142204"];
6207 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 142205"];
6208 [label="return _syntaxFactoryContext.IsInAsync; 142206"];
6209 [label="if (this.IsInAsync && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                // can't be a declaration expression.\n                return false;\n            } 142207"];
6210 [label="this.GetResetPoint() 142208"];
6211 [label="param GetResetPoint(this) 142209"];
6212 [label="_firstToken + _tokenOffset 142210"];
6213 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 142211"];
6214 [label="_resetCount 142212"];
6215 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 142213"];
6216 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 142214"];
6217 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 142215"];
6218 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 142216"];
6219 [label="param ResetPoint(this) 142217"];
6220 [label="var resetPoint = this.GetResetPoint(); 142218"];
6221 [label="IsVarType() 142219"];
6222 [label="param IsVarType(this) 142220"];
6223 [label="this.CurrentToken 142221"];
6224 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142222"];
6225 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142223"];
6226 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 142224"];
6227 [label="if (!this.CurrentToken.IsIdentifierVar())\n            {\n                return false;\n            } 142225"];
6228 [label="this.CurrentToken.IsIdentifierVar() 142226"];
6229 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 142227"];
6230 [label="return false; 142228"];
6231 [label="bool typeIsVar = IsVarType(); 142229"];
6232 [label="SyntaxToken lastTokenOfType; 142230"];
6233 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 142231"];
6234 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 142232"];
6235 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 142233"];
6236 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 142234"];
6237 [label="Debug.Assert(n >= 0); 142235"];
6238 [label="Debug.Assert(n >= 0); 142236"];
6239 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142237"];
6240 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 142238"];
6241 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 142239"];
6242 [label="this.CurrentToken 142240"];
6243 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142241"];
6244 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 142242"];
6245 [label="this.CurrentToken.Kind 142243"];
6246 [label="get { return (SyntaxKind)this.RawKind; } 142244"];
6247 [label="this.IsTrueIdentifier() 142245"];
6248 [label="param IsTrueIdentifier(this) 142246"];
6249 [label="this.CurrentToken 142247"];
6250 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142248"];
6251 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 142249"];
6252 [label="this.CurrentToken.Kind 142250"];
6253 [label="get { return (SyntaxKind)this.RawKind; } 142251"];
6254 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 142252"];
6255 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 142253"];
6256 [label="this.CurrentToken 142254"];
6257 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142255"];
6258 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 142256"];
6259 [label="this.CurrentToken.ContextualKind 142257"];
6260 [label="get\n            {\n                return this.Kind;\n            } 142258"];
6261 [label="return false; 142259"];
6262 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142260"];
6263 [label="IsCurrentTokenQueryKeywordInQuery() 142261"];
6264 [label="param IsCurrentTokenQueryKeywordInQuery(this) 142262"];
6265 [label="this.IsInQuery 142263"];
6266 [label="get { return _syntaxFactoryContext.IsInQuery; } 142264"];
6267 [label="return _syntaxFactoryContext.IsInQuery; 142265"];
6268 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 142266"];
6269 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142267"];
6270 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142268"];
6271 [label="IsCurrentTokenWhereOfConstraintClause() 142269"];
6272 [label="param IsCurrentTokenWhereOfConstraintClause(this) 142270"];
6273 [label="this.CurrentToken 142271"];
6274 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142272"];
6275 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 142273"];
6276 [label="this.CurrentToken.ContextualKind 142274"];
6277 [label="get\n            {\n                return this.Kind;\n            } 142275"];
6278 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142276"];
6279 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142277"];
6280 [label="return true; 142278"];
6281 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 142279"];
6282 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 142280"];
6283 [label="this.EatToken() 142281"];
6284 [label="this.CurrentToken 142282"];
6285 [label="MoveToNextToken() 142283"];
6286 [label="param GetTrailingTrivia(this) 142284"];
6287 [label="return null; 142285"];
6288 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 142286"];
6289 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 142287"];
6290 [label="MoveToNextToken(); 142288"];
6291 [label="this.CurrentToken 142289"];
6292 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142290"];
6293 [label="this.CurrentToken.Kind 142291"];
6294 [label="this.CurrentToken 142292"];
6295 [label="this.CurrentToken.Kind 142293"];
6296 [label="this.CurrentToken 142294"];
6297 [label="this.CurrentToken.Kind 142295"];
6298 [label="param IsMakingProgress(bool assertIfFalse = true) 142296"];
6299 [label="CurrentTokenPosition 142297"];
6300 [label="lastTokenOfType.Kind 142298"];
6301 [label="get { return (SyntaxKind)this.RawKind; } 142299"];
6302 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 142300"];
6303 [label="IsPredefinedType(lastTokenOfType.Kind) 142301"];
6304 [label="param IsPredefinedType(SyntaxKind keyword) 142302"];
6305 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 142303"];
6306 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 142304"];
6307 [label="ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))) 142305"];
6308 [label="param ScanDesignation(bool permitTuple) 142306"];
6309 [label="param ScanDesignation(this) 142307"];
6310 [label="this.CurrentToken 142308"];
6311 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142309"];
6312 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142310"];
6313 [label="switch (this.CurrentToken.Kind)\n            {\n                default:\n                    return false;\n                case SyntaxKind.IdentifierToken:\n                    bool result = this.IsTrueIdentifier();\n                    this.EatToken();\n                    return result;\n                case SyntaxKind.OpenParenToken:\n                    if (!permitTuple)\n                    {\n                        return false;\n                    }\n\n                    bool sawComma = false;\n                    while (true)\n                    {\n                        this.EatToken(); // consume the `(` or `,`\n                        if (!ScanDesignation(permitTuple: true))\n                        {\n                            return false;\n                        }\n                        switch (this.CurrentToken.Kind)\n                        {\n                            case SyntaxKind.CloseParenToken:\n                                this.EatToken();\n                                return sawComma;\n                            case SyntaxKind.CommaToken:\n                                sawComma = true;\n                                continue;\n                            default:\n                                return false;\n                        }\n                    }\n            } 142311"];
6314 [label="this.CurrentToken.Kind 142312"];
6315 [label="get { return (SyntaxKind)this.RawKind; } 142313"];
6316 [label="return false; 142314"];
6317 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 142315"];
6318 [label="return false; 142316"];
6319 [label="this.Reset(ref resetPoint); 142317"];
6320 [label="this.Reset(ref resetPoint) 142318"];
6321 [label="param Reset(ref ResetPoint state) 142319"];
6322 [label="Debug.Assert(offset >= 0); 142320"];
6323 [label="Debug.Assert(offset >= 0); 142321"];
6324 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 142322"];
6325 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 142323"];
6326 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 142324"];
6327 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 142325"];
6328 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 142326"];
6329 [label="this.Reset(ref resetPoint); 142327"];
6330 [label="this.Release(ref resetPoint); 142328"];
6331 [label="this.Release(ref resetPoint) 142329"];
6332 [label="param Release(ref ResetPoint state) 142330"];
6333 [label="base.Release(ref state.BaseResetPoint); 142331"];
6334 [label="param Release(ref ResetPoint point) 142332"];
6335 [label="Debug.Assert(_resetCount == point.ResetCount); 142333"];
6336 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 142334"];
6337 [label="base.Release(ref state.BaseResetPoint); 142335"];
6338 [label="this.Release(ref resetPoint); 142336"];
6339 [label="this.ParseSubExpression(Precedence.Expression) 142337"];
6340 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 142338"];
6341 [label="ExpressionSyntax leftOperand; 142339"];
6342 [label="Precedence newPrecedence = 0; 142340"];
6343 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142341"];
6344 [label="return _lexedTokens[_tokenOffset]; 142342"];
6345 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 142343"];
6346 [label="IsInvalidSubExpression(tk) 142344"];
6347 [label="param IsInvalidSubExpression(SyntaxKind kind) 142345"];
6348 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 142346"];
6349 [label="return false; 142347"];
6350 [label="param IsAwaitExpression(this) 142348"];
6351 [label="this.CurrentToken 142349"];
6352 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142350"];
6353 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 142351"];
6354 [label="this.CurrentToken.ContextualKind 142352"];
6355 [label="get\n            {\n                return this.Kind;\n            } 142353"];
6356 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 142354"];
6357 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 142355"];
6358 [label="param IsQueryExpression(this) 142356"];
6359 [label="this.CurrentToken 142357"];
6360 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142358"];
6361 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 142359"];
6362 [label="this.CurrentToken.ContextualKind 142360"];
6363 [label="get\n            {\n                return this.Kind;\n            } 142361"];
6364 [label="leftOperand = this.ParseTerm(precedence); 142362"];
6365 [label="param ParseTerm(Precedence precedence) 142363"];
6366 [label="precedence 142364"];
6367 [label="param ParseTermWithoutPostfix(Precedence precedence) 142365"];
6368 [label="this.IsTrueIdentifier() 142366"];
6369 [label="param IsTrueIdentifier(this) 142367"];
6370 [label="this.CurrentToken 142368"];
6371 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142369"];
6372 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 142370"];
6373 [label="this.CurrentToken.Kind 142371"];
6374 [label="get { return (SyntaxKind)this.RawKind; } 142372"];
6375 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 142373"];
6376 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 142374"];
6377 [label="this.CurrentToken 142375"];
6378 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142376"];
6379 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 142377"];
6380 [label="this.CurrentToken.ContextualKind 142378"];
6381 [label="get\n            {\n                return this.Kind;\n            } 142379"];
6382 [label="return false; 142380"];
6383 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142381"];
6384 [label="IsCurrentTokenQueryKeywordInQuery() 142382"];
6385 [label="param IsCurrentTokenQueryKeywordInQuery(this) 142383"];
6386 [label="this.IsInQuery 142384"];
6387 [label="get { return _syntaxFactoryContext.IsInQuery; } 142385"];
6388 [label="return _syntaxFactoryContext.IsInQuery; 142386"];
6389 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 142387"];
6390 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142388"];
6391 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142389"];
6392 [label="IsCurrentTokenWhereOfConstraintClause() 142390"];
6393 [label="param IsCurrentTokenWhereOfConstraintClause(this) 142391"];
6394 [label="this.CurrentToken 142392"];
6395 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142393"];
6396 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 142394"];
6397 [label="this.CurrentToken.ContextualKind 142395"];
6398 [label="get\n            {\n                return this.Kind;\n            } 142396"];
6399 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142397"];
6400 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 142398"];
6401 [label="return true; 142399"];
6402 [label="if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    } 142400"];
6403 [label="this.IsPossibleAnonymousMethodExpression() 142401"];
6404 [label="param IsPossibleAnonymousMethodExpression(this) 142402"];
6405 [label="var tokenIndex = 0; 142403"];
6406 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 142404"];
6407 [label="this.PeekToken(tokenIndex) 142405"];
6408 [label="param PeekToken(int n) 142406"];
6409 [label="param PeekToken(this) 142407"];
6410 [label="Debug.Assert(n >= 0); 142408"];
6411 [label="Debug.Assert(n >= 0); 142409"];
6412 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142410"];
6413 [label="return _lexedTokens[_tokenOffset + n]; 142411"];
6414 [label="this.PeekToken(tokenIndex).Kind 142412"];
6415 [label="get { return (SyntaxKind)this.RawKind; } 142413"];
6416 [label="this.PeekToken(tokenIndex) 142414"];
6417 [label="param PeekToken(int n) 142415"];
6418 [label="param PeekToken(this) 142416"];
6419 [label="Debug.Assert(n >= 0); 142417"];
6420 [label="Debug.Assert(n >= 0); 142418"];
6421 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142419"];
6422 [label="return _lexedTokens[_tokenOffset + n]; 142420"];
6423 [label="this.PeekToken(tokenIndex).ContextualKind 142421"];
6424 [label="get\n            {\n                return this.Kind;\n            } 142422"];
6425 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 142423"];
6426 [label="return this.PeekToken(tokenIndex).Kind == SyntaxKind.DelegateKeyword; 142424"];
6427 [label="this.PeekToken(tokenIndex) 142425"];
6428 [label="param PeekToken(int n) 142426"];
6429 [label="param PeekToken(this) 142427"];
6430 [label="Debug.Assert(n >= 0); 142428"];
6431 [label="Debug.Assert(n >= 0); 142429"];
6432 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142430"];
6433 [label="return _lexedTokens[_tokenOffset + n]; 142431"];
6434 [label="this.PeekToken(tokenIndex).Kind 142432"];
6435 [label="get { return (SyntaxKind)this.RawKind; } 142433"];
6436 [label="if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 142434"];
6437 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 142435"];
6438 [label="this.IsPossibleLambdaExpression(precedence) 142436"];
6439 [label="param IsPossibleLambdaExpression(Precedence precedence) 142437"];
6440 [label="param IsPossibleLambdaExpression(this) 142438"];
6441 [label="this.CurrentToken 142439"];
6442 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142440"];
6443 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 142441"];
6444 [label="this.CurrentToken.Kind 142442"];
6445 [label="get { return (SyntaxKind)this.RawKind; } 142443"];
6446 [label="this.CurrentToken 142444"];
6447 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142445"];
6448 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 142446"];
6449 [label="this.IsTrueIdentifier(this.CurrentToken) 142447"];
6450 [label="param IsTrueIdentifier(SyntaxToken token) 142448"];
6451 [label="param IsTrueIdentifier(this) 142449"];
6452 [label="token.Kind 142450"];
6453 [label="get { return (SyntaxKind)this.RawKind; } 142451"];
6454 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 142452"];
6455 [label="this.IsInQuery 142453"];
6456 [label="get { return _syntaxFactoryContext.IsInQuery; } 142454"];
6457 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 142455"];
6458 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 142456"];
6459 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 142457"];
6460 [label="if (precedence > Precedence.Lambda)\n            {\n                return false;\n            } 142458"];
6461 [label="int peekIndex; 142459"];
6462 [label="bool seenStatic; 142460"];
6463 [label="this.CurrentToken 142461"];
6464 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142462"];
6465 [label="if (this.CurrentToken.Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 1;\n                seenStatic = true;\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 142463"];
6466 [label="this.CurrentToken.Kind 142464"];
6467 [label="get { return (SyntaxKind)this.RawKind; } 142465"];
6468 [label="this.CurrentToken 142466"];
6469 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 142467"];
6470 [label="this.CurrentToken.ContextualKind 142468"];
6471 [label="get\n            {\n                return this.Kind;\n            } 142469"];
6472 [label="peekIndex = 0; 142470"];
6473 [label="seenStatic = false; 142471"];
6474 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on => then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static =>`\n                // 2. `async static =>`\n\n                // This is an error case, but we have enough code in front of us to be certain\n                // the user was trying to write a static lambda.\n                return true;\n            } 142472"];
6475 [label="this.PeekToken(peekIndex) 142473"];
6476 [label="param PeekToken(int n) 142474"];
6477 [label="param PeekToken(this) 142475"];
6478 [label="Debug.Assert(n >= 0); 142476"];
6479 [label="Debug.Assert(n >= 0); 142477"];
6480 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142478"];
6481 [label="this.PeekToken(peekIndex).Kind 142479"];
6482 [label="get { return (SyntaxKind)this.RawKind; } 142480"];
6483 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 142481"];
6484 [label="this.PeekToken(peekIndex) 142482"];
6485 [label="param PeekToken(int n) 142483"];
6486 [label="param PeekToken(this) 142484"];
6487 [label="Debug.Assert(n >= 0); 142485"];
6488 [label="Debug.Assert(n >= 0); 142486"];
6489 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142487"];
6490 [label="this.PeekToken(peekIndex).Kind 142488"];
6491 [label="get { return (SyntaxKind)this.RawKind; } 142489"];
6492 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 142490"];
6493 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 142491"];
6494 [label="this.PeekToken(peekIndex + 1) 142492"];
6495 [label="param PeekToken(int n) 142493"];
6496 [label="param PeekToken(this) 142494"];
6497 [label="Debug.Assert(n >= 0); 142495"];
6498 [label="Debug.Assert(n >= 0); 142496"];
6499 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142497"];
6500 [label="this.PeekToken(peekIndex + 1).Kind 142498"];
6501 [label="get { return (SyntaxKind)this.RawKind; } 142499"];
6502 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 142500"];
6503 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on ( then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static (...\n                // 2. `async static (...\n                return true;\n            } 142501"];
6504 [label="this.PeekToken(peekIndex) 142502"];
6505 [label="param PeekToken(int n) 142503"];
6506 [label="param PeekToken(this) 142504"];
6507 [label="Debug.Assert(n >= 0); 142505"];
6508 [label="Debug.Assert(n >= 0); 142506"];
6509 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142507"];
6510 [label="this.PeekToken(peekIndex).Kind 142508"];
6511 [label="get { return (SyntaxKind)this.RawKind; } 142509"];
6512 [label="if (this.PeekToken(peekIndex).ContextualKind != SyntaxKind.AsyncKeyword)\n            {\n                return false;\n            } 142510"];
6513 [label="this.PeekToken(peekIndex) 142511"];
6514 [label="param PeekToken(int n) 142512"];
6515 [label="param PeekToken(this) 142513"];
6516 [label="Debug.Assert(n >= 0); 142514"];
6517 [label="Debug.Assert(n >= 0); 142515"];
6518 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142516"];
6519 [label="this.PeekToken(peekIndex).ContextualKind 142517"];
6520 [label="get\n            {\n                return this.Kind;\n            } 142518"];
6521 [label="return false; 142519"];
6522 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 142520"];
6523 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 142521"];
6524 [label="this.IsPossibleDeconstructionLeft(precedence) 142522"];
6525 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 142523"];
6526 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 142524"];
6527 [label="this.ParseAliasQualifiedName(NameOptions.InExpression) 142525"];
6528 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 142526"];
6529 [label="param ParseAliasQualifiedName(this) 142527"];
6530 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 142528"];
6531 [label="this.ParseSimpleName(allowedParts) 142529"];
6532 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 142530"];
6533 [label="param ParseSimpleName(this) 142531"];
6534 [label="var id = this.ParseIdentifierName(); 142532"];
6535 [label="this.ParseIdentifierName() 142533"];
6536 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 142534"];
6537 [label="param ParseIdentifierName(this) 142535"];
6538 [label="this.IsIncrementalAndFactoryContextMatches 142536"];
6539 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 142537"];
6540 [label="base.IsIncremental 142538"];
6541 [label="get\n            {\n                return _isIncremental;\n            } 142539"];
6542 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 142540"];
6543 [label="return false; 142541"];
6544 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 142542"];
6545 [label="var tk = ParseIdentifierToken(code); 142543"];
6546 [label="ParseIdentifierToken(code) 142544"];
6547 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 142545"];
6548 [label="param ParseIdentifierToken(this) 142546"];
6549 [label="this.CurrentToken 142547"];
6550 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142548"];
6551 [label="var ctk = this.CurrentToken.Kind; 142549"];
6552 [label="this.CurrentToken.Kind 142550"];
6553 [label="get { return (SyntaxKind)this.RawKind; } 142551"];
6554 [label="if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Goo {\n                // } Because we're parsing an attribute argument we'll end up consuming the 'partial' identifier and\n                // we'll eventually end up in a pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see 'partial' we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, code);\n                return name;\n            } 142552"];
6555 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 142553"];
6556 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 142554"];
6557 [label="this.CurrentToken 142555"];
6558 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142556"];
6559 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 142557"];
6560 [label="this.CurrentToken.ContextualKind 142558"];
6561 [label="get\n            {\n                return this.Kind;\n            } 142559"];
6562 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 142560"];
6563 [label="IsCurrentTokenQueryKeywordInQuery() 142561"];
6564 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 142562"];
6565 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 142563"];
6566 [label="this.EatToken() 142564"];
6567 [label="param GetTrailingTrivia(this) 142565"];
6568 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 142566"];
6569 [label="MoveToNextToken(); 142567"];
6570 [label="SyntaxToken identifierToken = this.EatToken(); 142568"];
6571 [label="this.IsInAsync 142569"];
6572 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 142570"];
6573 [label="return _syntaxFactoryContext.IsInAsync; 142571"];
6574 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 142572"];
6575 [label="return identifierToken; 142573"];
6576 [label="var tk = ParseIdentifierToken(code); 142574"];
6577 [label="return SyntaxFactory.IdentifierName(tk); 142575"];
6578 [label="return SyntaxFactory.IdentifierName(tk); 142576"];
6579 [label="param CSharpSyntaxNode(SyntaxKind kind) 142577"];
6580 [label="param CSharpSyntaxNode(this) 142578"];
6581 [label="kind 142579"];
6582 [label="param CSharpSyntaxNode(this) 142580"];
6583 [label="param CSharpSyntaxNode(this) 142581"];
6584 [label="GreenStats.NoteGreen(this); 142582"];
6585 [label="GreenStats.NoteGreen(this); 142583"];
6586 [label="var id = this.ParseIdentifierName(); 142584"];
6587 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 142585"];
6588 [label="SimpleNameSyntax name = id; 142586"];
6589 [label="this.CurrentToken 142587"];
6590 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142588"];
6591 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142589"];
6592 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 142590"];
6593 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 142591"];
6594 [label="this.CurrentToken.Kind 142592"];
6595 [label="get { return (SyntaxKind)this.RawKind; } 142593"];
6596 [label="return name; 142594"];
6597 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 142595"];
6598 [label="this.CurrentToken 142596"];
6599 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142597"];
6600 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142598"];
6601 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 142599"];
6602 [label="this.CurrentToken.Kind 142600"];
6603 [label="get { return (SyntaxKind)this.RawKind; } 142601"];
6604 [label="return name; 142602"];
6605 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 142603"];
6606 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 142604"];
6607 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 142605"];
6608 [label="return ParseExpressionContinued(leftOperand, precedence); 142606"];
6609 [label="return ParseExpressionContinued(leftOperand, precedence); 142607"];
6610 [label="ParseExpressionContinued(leftOperand, precedence) 142608"];
6611 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 142609"];
6612 [label="param ParseExpressionContinued(Precedence precedence) 142610"];
6613 [label="param ParseExpressionContinued(this) 142611"];
6614 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 142612"];
6615 [label="this.CurrentToken 142613"];
6616 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142614"];
6617 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142615"];
6618 [label="var tk = this.CurrentToken.ContextualKind; 142616"];
6619 [label="this.CurrentToken.ContextualKind 142617"];
6620 [label="get\n            {\n                return this.Kind;\n            } 142618"];
6621 [label="bool isAssignmentOperator = false; 142619"];
6622 [label="SyntaxKind opKind; 142620"];
6623 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 142621"];
6624 [label="IsExpectedBinaryOperator(tk) 142622"];
6625 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 142623"];
6626 [label="return SyntaxFacts.IsBinaryExpression(kind); 142624"];
6627 [label="SyntaxFacts.IsBinaryExpression(kind) 142625"];
6628 [label="param IsBinaryExpression(SyntaxKind token) 142626"];
6629 [label="return GetBinaryExpression(token) != SyntaxKind.None; 142627"];
6630 [label="GetBinaryExpression(token) 142628"];
6631 [label="param GetBinaryExpression(SyntaxKind token) 142629"];
6632 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 142630"];
6633 [label="return SyntaxKind.None; 142631"];
6634 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 142632"];
6635 [label="IsExpectedAssignmentOperator(tk) 142633"];
6636 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 142634"];
6637 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 142635"];
6638 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 142636"];
6639 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 142637"];
6640 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 142638"];
6641 [label="return false; 142639"];
6642 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 142640"];
6643 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 142641"];
6644 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 142642"];
6645 [label="CurrentToken 142643"];
6646 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142644"];
6647 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142645"];
6648 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 142646"];
6649 [label="CurrentToken.Kind 142647"];
6650 [label="get { return (SyntaxKind)this.RawKind; } 142648"];
6651 [label="return leftOperand; 142649"];
6652 [label="_ = GetPrecedence(result.Kind); 142650"];
6653 [label="result.Kind 142651"];
6654 [label="get { return (SyntaxKind)this.RawKind; } 142652"];
6655 [label="_ = GetPrecedence(result.Kind); 142653"];
6656 [label="GetPrecedence(result.Kind) 142654"];
6657 [label="param GetPrecedence(SyntaxKind op) 142655"];
6658 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 142656"];
6659 [label="return Precedence.Primary; 142657"];
6660 [label="_recursionDepth 142658"];
6661 [label="return result; 142659"];
6662 [label="this.CurrentToken 142660"];
6663 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142661"];
6664 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142662"];
6665 [label="if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        var firstArg = _syntaxFactory.Argument(nameColon: null, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 142663"];
6666 [label="this.CurrentToken.Kind 142664"];
6667 [label="get { return (SyntaxKind)this.RawKind; } 142665"];
6668 [label="expression.Kind 142666"];
6669 [label="get { return (SyntaxKind)this.RawKind; } 142667"];
6670 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 142668"];
6671 [label="this.CurrentToken 142669"];
6672 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142670"];
6673 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142671"];
6674 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 142672"];
6675 [label="this.CurrentToken.Kind 142673"];
6676 [label="get { return (SyntaxKind)this.RawKind; } 142674"];
6677 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 142675"];
6678 [label="var closeParen = this.EatToken(SyntaxKind.CloseParenToken); 142676"];
6679 [label="this.EatToken(SyntaxKind.CloseParenToken) 142677"];
6680 [label="param EatToken(SyntaxKind kind) 142678"];
6681 [label="param EatToken(this) 142679"];
6682 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 142680"];
6683 [label="SyntaxFacts.IsAnyToken(kind) 142681"];
6684 [label="param IsAnyToken(SyntaxKind kind) 142682"];
6685 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 142683"];
6686 [label="return true; 142684"];
6687 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142685"];
6688 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 142686"];
6689 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 142687"];
6690 [label="MoveToNextToken(); 142688"];
6691 [label="return ct; 142689"];
6692 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 142690"];
6693 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 142691"];
6694 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 142692"];
6695 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 142693"];
6696 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 142694"];
6697 [label="param TryGetNode(int kind) 142695"];
6698 [label="param TryGetNode(GreenNode child1) 142696"];
6699 [label="param TryGetNode(GreenNode child2) 142697"];
6700 [label="param TryGetNode(GreenNode child3) 142698"];
6701 [label="param TryGetNode(SyntaxFactoryContext context) 142699"];
6702 [label="param TryGetNode(out int hash) 142700"];
6703 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 142701"];
6704 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 142702"];
6705 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 142703"];
6706 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 142704"];
6707 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 142705"];
6708 [label="GetNodeFlags(context) 142706"];
6709 [label="param GetNodeFlags(SyntaxFactoryContext context) 142707"];
6710 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 142708"];
6711 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 142709"];
6712 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 142710"];
6713 [label="return flags; 142711"];
6714 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 142712"];
6715 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 142713"];
6716 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 142714"];
6717 [label="param CSharpSyntaxNode(this) 142715"];
6718 [label="GreenStats.NoteGreen(this); 142716"];
6719 [label="param SetFactoryContext(SyntaxFactoryContext context) 142717"];
6720 [label="param SetFactoryContext(this) 142718"];
6721 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 142719"];
6722 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 142720"];
6723 [label="this.Release(ref resetPoint); 142721"];
6724 [label="this.Release(ref resetPoint) 142722"];
6725 [label="param Release(ref ResetPoint state) 142723"];
6726 [label="param Release(this) 142724"];
6727 [label="base.Release(ref state.BaseResetPoint); 142725"];
6728 [label="base.Release(ref state.BaseResetPoint) 142726"];
6729 [label="param Release(ref ResetPoint point) 142727"];
6730 [label="param Release(this) 142728"];
6731 [label="Debug.Assert(_resetCount == point.ResetCount); 142729"];
6732 [label="_resetCount 142730"];
6733 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 142731"];
6734 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 142732"];
6735 [label="base.Release(ref state.BaseResetPoint); 142733"];
6736 [label="this.Release(ref resetPoint); 142734"];
6737 [label="return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence); 142735"];
6738 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 142736"];
6739 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 142737"];
6740 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142738"];
6741 [label="return ParseExpressionContinued(leftOperand, precedence); 142739"];
6742 [label="ParseExpressionContinued(leftOperand, precedence) 142740"];
6743 [label="param ParseExpressionContinued(Precedence precedence) 142741"];
6744 [label="param ParseExpressionContinued(this) 142742"];
6745 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 142743"];
6746 [label="this.CurrentToken 142744"];
6747 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142745"];
6748 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142746"];
6749 [label="var tk = this.CurrentToken.ContextualKind; 142747"];
6750 [label="this.CurrentToken.ContextualKind 142748"];
6751 [label="get\n            {\n                return this.Kind;\n            } 142749"];
6752 [label="this.Kind 142750"];
6753 [label="bool isAssignmentOperator = false; 142751"];
6754 [label="SyntaxKind opKind; 142752"];
6755 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 142753"];
6756 [label="IsExpectedBinaryOperator(tk) 142754"];
6757 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 142755"];
6758 [label="return SyntaxFacts.IsBinaryExpression(kind); 142756"];
6759 [label="SyntaxFacts.IsBinaryExpression(kind) 142757"];
6760 [label="param IsBinaryExpression(SyntaxKind token) 142758"];
6761 [label="return GetBinaryExpression(token) != SyntaxKind.None; 142759"];
6762 [label="GetBinaryExpression(token) 142760"];
6763 [label="param GetBinaryExpression(SyntaxKind token) 142761"];
6764 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 142762"];
6765 [label="return SyntaxKind.None; 142763"];
6766 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 142764"];
6767 [label="IsExpectedAssignmentOperator(tk) 142765"];
6768 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 142766"];
6769 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 142767"];
6770 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 142768"];
6771 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 142769"];
6772 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 142770"];
6773 [label="return false; 142771"];
6774 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 142772"];
6775 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 142773"];
6776 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 142774"];
6777 [label="CurrentToken 142775"];
6778 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142776"];
6779 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142777"];
6780 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 142778"];
6781 [label="CurrentToken.Kind 142779"];
6782 [label="get { return (SyntaxKind)this.RawKind; } 142780"];
6783 [label="_ = GetPrecedence(result.Kind); 142781"];
6784 [label="result.Kind 142782"];
6785 [label="get { return (SyntaxKind)this.RawKind; } 142783"];
6786 [label="_ = GetPrecedence(result.Kind); 142784"];
6787 [label="GetPrecedence(result.Kind) 142785"];
6788 [label="param GetPrecedence(SyntaxKind op) 142786"];
6789 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 142787"];
6790 [label="return Precedence.Primary; 142788"];
6791 [label="var expression = this.ParseExpressionCore(); 142789"];
6792 [label="SyntaxToken openParen; 142790"];
6793 [label="SyntaxToken closeParen; 142791"];
6794 [label="expression.Kind 142792"];
6795 [label="get { return (SyntaxKind)this.RawKind; } 142793"];
6796 [label="if (expression.Kind == SyntaxKind.ParenthesizedExpression)\n            {\n                var parenExpression = (ParenthesizedExpressionSyntax)expression;\n                openParen = parenExpression.OpenParenToken;\n                expression = parenExpression.Expression;\n                closeParen = parenExpression.CloseParenToken;\n\n                Debug.Assert(parenExpression.GetDiagnostics().Length == 0);\n            }\n            else if (expression.Kind == SyntaxKind.TupleExpression)\n            {\n                // As a special case, when a tuple literal is the governing expression of\n                // a switch statement we permit the switch statement's own parentheses to be omitted.\n                // LDM 2018-04-04.\n                openParen = closeParen = null;\n            }\n            else\n            {\n                // Some other expression has appeared without parens. Give a syntax error.\n                openParen = SyntaxFactory.MissingToken(SyntaxKind.OpenParenToken);\n                expression = this.AddError(expression, ErrorCode.ERR_SwitchGoverningExpressionRequiresParens);\n                closeParen = SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken);\n            } 142794"];
6797 [label="var parenExpression = (ParenthesizedExpressionSyntax)expression; 142795"];
6798 [label="openParen = parenExpression.OpenParenToken; 142796"];
6799 [label="expression = parenExpression.Expression; 142797"];
6800 [label="closeParen = parenExpression.CloseParenToken; 142798"];
6801 [label="Debug.Assert(parenExpression.GetDiagnostics().Length == 0); 142799"];
6802 [label="Debug.Assert(parenExpression.GetDiagnostics().Length == 0); 142800"];
6803 [label="var openBrace = this.EatToken(SyntaxKind.OpenBraceToken); 142801"];
6804 [label="this.EatToken(SyntaxKind.OpenBraceToken) 142802"];
6805 [label="param EatToken(SyntaxKind kind) 142803"];
6806 [label="param EatToken(this) 142804"];
6807 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 142805"];
6808 [label="SyntaxFacts.IsAnyToken(kind) 142806"];
6809 [label="param IsAnyToken(SyntaxKind kind) 142807"];
6810 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 142808"];
6811 [label="return true; 142809"];
6812 [label="this.CurrentToken 142810"];
6813 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142811"];
6814 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142812"];
6815 [label="ct.Kind 142813"];
6816 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 142814"];
6817 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 142815"];
6818 [label="MoveToNextToken(); 142816"];
6819 [label="var sections = _pool.Allocate<SwitchSectionSyntax>(); 142817"];
6820 [label="this.IsPossibleSwitchSection() 142818"];
6821 [label="param IsPossibleSwitchSection(this) 142819"];
6822 [label="this.CurrentToken 142820"];
6823 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142821"];
6824 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142822"];
6825 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 142823"];
6826 [label="return (this.CurrentToken.Kind == SyntaxKind.CaseKeyword) ||\n                   (this.CurrentToken.Kind == SyntaxKind.DefaultKeyword && this.PeekToken(1).Kind != SyntaxKind.OpenParenToken); 142824"];
6827 [label="this.CurrentToken.Kind 142825"];
6828 [label="get { return (SyntaxKind)this.RawKind; } 142826"];
6829 [label="while (this.IsPossibleSwitchSection())\n                {\n                    var swcase = this.ParseSwitchSection();\n                    sections.Add(swcase);\n                } 142827"];
6830 [label="this.ParseSwitchSection() 142828"];
6831 [label="param ParseSwitchSection(this) 142829"];
6832 [label="this.IsPossibleSwitchSection() 142830"];
6833 [label="param IsPossibleSwitchSection(this) 142831"];
6834 [label="Debug.Assert(this.IsPossibleSwitchSection()); 142832"];
6835 [label="var labels = _pool.Allocate<SwitchLabelSyntax>(); 142833"];
6836 [label="var statements = _pool.Allocate<StatementSyntax>(); 142834"];
6837 [label="SyntaxToken specifier; 142835"];
6838 [label="SwitchLabelSyntax label; 142836"];
6839 [label="SyntaxToken colon; 142837"];
6840 [label="this.CurrentToken 142838"];
6841 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142839"];
6842 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142840"];
6843 [label="if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    } 142841"];
6844 [label="this.CurrentToken.Kind 142842"];
6845 [label="get { return (SyntaxKind)this.RawKind; } 142843"];
6846 [label="ExpressionSyntax expression; 142844"];
6847 [label="this.EatToken() 142845"];
6848 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 142846"];
6849 [label="MoveToNextToken(); 142847"];
6850 [label="specifier = this.EatToken(); 142848"];
6851 [label="this.CurrentToken 142849"];
6852 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 142850"];
6853 [label="return _lexedTokens[_tokenOffset]; 142851"];
6854 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        } 142852"];
6855 [label="this.CurrentToken.Kind 142853"];
6856 [label="get { return (SyntaxKind)this.RawKind; } 142854"];
6857 [label="ParseExpressionOrPatternForSwitchStatement() 142855"];
6858 [label="param ParseExpressionOrPatternForSwitchStatement(this) 142856"];
6859 [label="ParseExpressionOrPatternForSwitchStatementCore() 142857"];
6860 [label="param ParseExpressionOrPatternForSwitchStatementCore(this) 142858"];
6861 [label="var pattern = ParsePattern(Precedence.Conditional, whenIsKeyword: true); 142859"];
6862 [label="var pattern = ParsePattern(Precedence.Conditional, whenIsKeyword: true); 142860"];
6863 [label="ParsePattern(Precedence.Conditional, whenIsKeyword: true) 142861"];
6864 [label="param ParsePattern(Precedence precedence) 142862"];
6865 [label="param ParsePattern(bool afterIs = false) 142863"];
6866 [label="param ParsePattern(bool whenIsKeyword = false) 142864"];
6867 [label="param ParsePattern(this) 142865"];
6868 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 142866"];
6869 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 142867"];
6870 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 142868"];
6871 [label="ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword) 142869"];
6872 [label="param ParseDisjunctivePattern(Precedence precedence) 142870"];
6873 [label="param ParseDisjunctivePattern(bool afterIs) 142871"];
6874 [label="param ParseDisjunctivePattern(bool whenIsKeyword) 142872"];
6875 [label="param ParseDisjunctivePattern(this) 142873"];
6876 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 142874"];
6877 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 142875"];
6878 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 142876"];
6879 [label="ParseConjunctivePattern(precedence, afterIs, whenIsKeyword) 142877"];
6880 [label="param ParseConjunctivePattern(Precedence precedence) 142878"];
6881 [label="param ParseConjunctivePattern(bool afterIs) 142879"];
6882 [label="param ParseConjunctivePattern(bool whenIsKeyword) 142880"];
6883 [label="param ParseConjunctivePattern(this) 142881"];
6884 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 142882"];
6885 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 142883"];
6886 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 142884"];
6887 [label="ParseNegatedPattern(precedence, afterIs, whenIsKeyword) 142885"];
6888 [label="param ParseNegatedPattern(Precedence precedence) 142886"];
6889 [label="param ParseNegatedPattern(bool afterIs) 142887"];
6890 [label="param ParseNegatedPattern(bool whenIsKeyword) 142888"];
6891 [label="param ParseNegatedPattern(this) 142889"];
6892 [label="this.CurrentToken 142890"];
6893 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142891"];
6894 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.NotKeyword)\n            {\n                var notToken = ConvertToKeyword(this.EatToken());\n                var pattern = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                var result = _syntaxFactory.UnaryPattern(notToken, pattern);\n                return CheckFeatureAvailability(result, MessageID.IDS_FeatureNotPattern);\n            }\n            else\n            {\n                return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword);\n            } 142892"];
6895 [label="this.CurrentToken.ContextualKind 142893"];
6896 [label="get\n            {\n                return this.Kind;\n            } 142894"];
6897 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 142895"];
6898 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 142896"];
6899 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 142897"];
6900 [label="ParsePrimaryPattern(precedence, afterIs, whenIsKeyword) 142898"];
6901 [label="param ParsePrimaryPattern(Precedence precedence) 142899"];
6902 [label="param ParsePrimaryPattern(bool afterIs) 142900"];
6903 [label="param ParsePrimaryPattern(bool whenIsKeyword) 142901"];
6904 [label="param ParsePrimaryPattern(this) 142902"];
6905 [label="this.CurrentToken 142903"];
6906 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142904"];
6907 [label="var tk = this.CurrentToken.Kind; 142905"];
6908 [label="this.CurrentToken.Kind 142906"];
6909 [label="get { return (SyntaxKind)this.RawKind; } 142907"];
6910 [label="switch (tk)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return _syntaxFactory.ConstantPattern(this.ParseIdentifierName(ErrorCode.ERR_MissingPattern));\n            } 142908"];
6911 [label="CurrentToken 142909"];
6912 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142910"];
6913 [label="if (CurrentToken.ContextualKind == SyntaxKind.UnderscoreToken)\n            {\n                return _syntaxFactory.DiscardPattern(this.EatContextualToken(SyntaxKind.UnderscoreToken));\n            } 142911"];
6914 [label="CurrentToken.ContextualKind 142912"];
6915 [label="get\n            {\n                return this.Kind;\n            } 142913"];
6916 [label="CurrentToken 142914"];
6917 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142915"];
6918 [label="switch (CurrentToken.Kind)\n            {\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                    // this is a relational pattern.\n                    var relationalToken = this.EatToken();\n                    Debug.Assert(precedence < Precedence.Shift);\n                    var expression = this.ParseSubExpression(Precedence.Relational);\n                    var result = _syntaxFactory.RelationalPattern(relationalToken, expression);\n                    return CheckFeatureAvailability(result, MessageID.IDS_FeatureRelationalPattern);\n            } 142916"];
6919 [label="CurrentToken.Kind 142917"];
6920 [label="get { return (SyntaxKind)this.RawKind; } 142918"];
6921 [label="this.GetResetPoint() 142919"];
6922 [label="param GetResetPoint(this) 142920"];
6923 [label="var resetPoint = this.GetResetPoint(); 142921"];
6924 [label="TypeSyntax type = null; 142922"];
6925 [label="LooksLikeTypeOfPattern() 142923"];
6926 [label="param LooksLikeTypeOfPattern(this) 142924"];
6927 [label="CurrentToken 142925"];
6928 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142926"];
6929 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142927"];
6930 [label="var tk = CurrentToken.Kind; 142928"];
6931 [label="CurrentToken.Kind 142929"];
6932 [label="get { return (SyntaxKind)this.RawKind; } 142930"];
6933 [label="if (SyntaxFacts.IsPredefinedType(tk))\n            {\n                return true;\n            } 142931"];
6934 [label="SyntaxFacts.IsPredefinedType(tk) 142932"];
6935 [label="param IsPredefinedType(SyntaxKind kind) 142933"];
6936 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 142934"];
6937 [label="this.CurrentToken 142935"];
6938 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142936"];
6939 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142937"];
6940 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 142938"];
6941 [label="this.CurrentToken.ContextualKind 142939"];
6942 [label="get\n            {\n                return this.Kind;\n            } 142940"];
6943 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 142941"];
6944 [label="this.CurrentToken 142942"];
6945 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142943"];
6946 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 142944"];
6947 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 142945"];
6948 [label="this.CurrentToken.ContextualKind 142946"];
6949 [label="get\n            {\n                return this.Kind;\n            } 142947"];
6950 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 142948"];
6951 [label="return true; 142949"];
6952 [label="if (LooksLikeTypeOfPattern())\n                {\n                    type = this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern);\n                    if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    }\n                } 142950"];
6953 [label="afterIs 142951"];
6954 [label="type = this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern); 142952"];
6955 [label="this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern) 142953"];
6956 [label="param ParseType(ParseTypeMode mode = ParseTypeMode.Normal) 142954"];
6957 [label="param ParseType(this) 142955"];
6958 [label="this.CurrentToken 142956"];
6959 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142957"];
6960 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 142958"];
6961 [label="this.CurrentToken.Kind 142959"];
6962 [label="get { return (SyntaxKind)this.RawKind; } 142960"];
6963 [label="return ParseTypeCore(mode); 142961"];
6964 [label="return ParseTypeCore(mode); 142962"];
6965 [label="return ParseTypeCore(mode); 142963"];
6966 [label="param ParseUnderlyingType(ParseTypeMode mode) 142964"];
6967 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 142965"];
6968 [label="param ParseUnderlyingType(this) 142966"];
6969 [label="this.CurrentToken 142967"];
6970 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142968"];
6971 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 142969"];
6972 [label="this.CurrentToken.Kind 142970"];
6973 [label="get { return (SyntaxKind)this.RawKind; } 142971"];
6974 [label="IsPredefinedType(this.CurrentToken.Kind) 142972"];
6975 [label="param IsPredefinedType(SyntaxKind keyword) 142973"];
6976 [label="IsTrueIdentifier() 142974"];
6977 [label="param IsTrueIdentifier(this) 142975"];
6978 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 142976"];
6979 [label="this.CurrentToken 142977"];
6980 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 142978"];
6981 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 142979"];
6982 [label="this.CurrentToken.ContextualKind 142980"];
6983 [label="get\n            {\n                return this.Kind;\n            } 142981"];
6984 [label="if (IsTrueIdentifier() || this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                return this.ParseQualifiedName(options);\n            } 142982"];
6985 [label="return this.ParseQualifiedName(options); 142983"];
6986 [label="this.ParseQualifiedName(options) 142984"];
6987 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 142985"];
6988 [label="param ParseQualifiedName(this) 142986"];
6989 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 142987"];
6990 [label="this.ParseAliasQualifiedName(options) 142988"];
6991 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 142989"];
6992 [label="param ParseAliasQualifiedName(this) 142990"];
6993 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 142991"];
6994 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 142992"];
6995 [label="this.IsIncrementalAndFactoryContextMatches 142993"];
6996 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 142994"];
6997 [label="base.IsIncremental 142995"];
6998 [label="get\n            {\n                return _isIncremental;\n            } 142996"];
6999 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 142997"];
7000 [label="return false; 142998"];
7001 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 142999"];
7002 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 143000"];
7003 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 143001"];
7004 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 143002"];
7005 [label="this.CurrentToken 143003"];
7006 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143004"];
7007 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 143005"];
7008 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 143006"];
7009 [label="IsCurrentTokenQueryKeywordInQuery() 143007"];
7010 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 143008"];
7011 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 143009"];
7012 [label="param GetTrailingTrivia(this) 143010"];
7013 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 143011"];
7014 [label="MoveToNextToken(); 143012"];
7015 [label="this.IsInAsync 143013"];
7016 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 143014"];
7017 [label="return _syntaxFactoryContext.IsInAsync; 143015"];
7018 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 143016"];
7019 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 143017"];
7020 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 143018"];
7021 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 143019"];
7022 [label="this.CurrentToken.Kind 143020"];
7023 [label="get { return (SyntaxKind)this.RawKind; } 143021"];
7024 [label="this.CurrentToken 143022"];
7025 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143023"];
7026 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 143024"];
7027 [label="this.CurrentToken.Kind 143025"];
7028 [label="get { return (SyntaxKind)this.RawKind; } 143026"];
7029 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 143027"];
7030 [label="this.IsDotOrColonColon() 143028"];
7031 [label="param IsDotOrColonColon(this) 143029"];
7032 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143030"];
7033 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 143031"];
7034 [label="this.CurrentToken 143032"];
7035 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143033"];
7036 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143034"];
7037 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 143035"];
7038 [label="this.CurrentToken.Kind 143036"];
7039 [label="get { return (SyntaxKind)this.RawKind; } 143037"];
7040 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 143038"];
7041 [label="return name; 143039"];
7042 [label="return this.ParseQualifiedName(options); 143040"];
7043 [label="param IsMakingProgress(bool assertIfFalse = true) 143041"];
7044 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 143042"];
7045 [label="CanTokenFollowTypeInPattern(precedence) 143043"];
7046 [label="param CanTokenFollowTypeInPattern(Precedence precedence) 143044"];
7047 [label="param CanTokenFollowTypeInPattern(this) 143045"];
7048 [label="this.CurrentToken 143046"];
7049 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143047"];
7050 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143048"];
7051 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.CloseBraceToken:   // for efficiency, test some tokens that can follow a type pattern\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                case SyntaxKind.DotToken:\n                    // int.MaxValue is an expression, not a type.\n                    return false;\n                case var kind:\n                    // If we find what looks like a continuation of an expression, it is not a type.\n                    return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence;\n            } 143049"];
7052 [label="this.CurrentToken.Kind 143050"];
7053 [label="get { return (SyntaxKind)this.RawKind; } 143051"];
7054 [label="return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence; 143052"];
7055 [label="SyntaxFacts.IsBinaryExpressionOperatorToken(kind) 143053"];
7056 [label="param IsBinaryExpressionOperatorToken(SyntaxKind token) 143054"];
7057 [label="return GetBinaryExpression(token) != SyntaxKind.None; 143055"];
7058 [label="GetBinaryExpression(token) 143056"];
7059 [label="param GetBinaryExpression(SyntaxKind token) 143057"];
7060 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 143058"];
7061 [label="return SyntaxKind.None; 143059"];
7062 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 143060"];
7063 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 143061"];
7064 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 143062"];
7065 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 143063"];
7066 [label="ParsePatternContinued(type, precedence, whenIsKeyword) 143064"];
7067 [label="param ParsePatternContinued(TypeSyntax type) 143065"];
7068 [label="param ParsePatternContinued(Precedence precedence) 143066"];
7069 [label="param ParsePatternContinued(bool whenIsKeyword) 143067"];
7070 [label="param ParsePatternContinued(this) 143068"];
7071 [label=".Kind 143069"];
7072 [label="get { return (SyntaxKind)this.RawKind; } 143070"];
7073 [label="if (type?.Kind == SyntaxKind.IdentifierName)\n            {\n                var typeIdentifier = (IdentifierNameSyntax)type;\n                var typeIdentifierToken = typeIdentifier.Identifier;\n                if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                }\n            } 143071"];
7074 [label="var typeIdentifier = (IdentifierNameSyntax)type; 143072"];
7075 [label="var typeIdentifierToken = typeIdentifier.Identifier; 143073"];
7076 [label="typeIdentifierToken.ContextualKind 143074"];
7077 [label="get\n            {\n                return this.Kind;\n            } 143075"];
7078 [label="if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                } 143076"];
7079 [label="this.CurrentToken 143077"];
7080 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143078"];
7081 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143079"];
7082 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken && (type != null || !looksLikeCast()))\n            {\n                // It is possible this is a parenthesized (constant) expression.\n                // We normalize later.\n                ParseSubpatternList(\n                    openToken: out SyntaxToken openParenToken,\n                    subPatterns: out SeparatedSyntaxList<SubpatternSyntax> subPatterns,\n                    closeToken: out SyntaxToken closeParenToken,\n                    openKind: SyntaxKind.OpenParenToken,\n                    closeKind: SyntaxKind.CloseParenToken);\n\n                parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause0);\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n\n                if (type == null &&\n                    propertyPatternClause0 == null &&\n                    designation0 == null &&\n                    subPatterns.Count == 1 &&\n                    subPatterns.SeparatorCount == 0 &&\n                    subPatterns[0].NameColon == null)\n                {\n                    var subpattern = subPatterns[0].Pattern;\n                    switch (subpattern)\n                    {\n                        case ConstantPatternSyntax cp:\n                            // There is an ambiguity between a positional pattern `(` pattern `)`\n                            // and a constant expression pattern that happens to be parenthesized.\n                            // Per 2017-11-20 LDM we treat such syntax as a parenthesized expression always.\n                            ExpressionSyntax expression = _syntaxFactory.ParenthesizedExpression(openParenToken, cp.Expression, closeParenToken);\n                            expression = ParseExpressionContinued(expression, precedence);\n                            return _syntaxFactory.ConstantPattern(expression);\n                        default:\n                            var parenthesizedPattern = _syntaxFactory.ParenthesizedPattern(openParenToken, subPatterns[0].Pattern, closeParenToken);\n                            return CheckFeatureAvailability(parenthesizedPattern, MessageID.IDS_FeatureParenthesizedPattern);\n                    }\n                }\n\n                var positionalPatternClause = _syntaxFactory.PositionalPatternClause(openParenToken, subPatterns, closeParenToken);\n                var result = _syntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause0, designation0);\n                return result;\n            } 143080"];
7083 [label="this.CurrentToken.Kind 143081"];
7084 [label="get { return (SyntaxKind)this.RawKind; } 143082"];
7085 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 143083"];
7086 [label="parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause) 143084"];
7087 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 143085"];
7088 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 143086"];
7089 [label="propertyPatternClauseResult = null; 143087"];
7090 [label="this.CurrentToken 143088"];
7091 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143089"];
7092 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143090"];
7093 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                } 143091"];
7094 [label="this.CurrentToken.Kind 143092"];
7095 [label="get { return (SyntaxKind)this.RawKind; } 143093"];
7096 [label="return false; 143094"];
7097 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 143095"];
7098 [label="if (type != null)\n            {\n                if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                }\n            } 143096"];
7099 [label="if (type != null)\n            {\n                if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                }\n            } 143097"];
7100 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 143098"];
7101 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 143099"];
7102 [label="parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation) 143100"];
7103 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 143101"];
7104 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 143102"];
7105 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 143103"];
7106 [label="designationResult = null; 143104"];
7107 [label="this.IsTrueIdentifier() 143105"];
7108 [label="param IsTrueIdentifier(this) 143106"];
7109 [label="return false; 143107"];
7110 [label="if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                } 143108"];
7111 [label="return false; 143109"];
7112 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 143110"];
7113 [label="if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    } 143111"];
7114 [label="if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    } 143112"];
7115 [label="ConvertTypeToExpression(type, out var expression) 143113"];
7116 [label="param ConvertTypeToExpression(TypeSyntax type) 143114"];
7117 [label="param ConvertTypeToExpression(out ExpressionSyntax expr) 143115"];
7118 [label="param ConvertTypeToExpression(bool permitTypeArguments = false) 143116"];
7119 [label="param ConvertTypeToExpression(this) 143117"];
7120 [label="expr = null; 143118"];
7121 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 143119"];
7122 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 143120"];
7123 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 143121"];
7124 [label="expr = s; 143122"];
7125 [label="return true; 143123"];
7126 [label="expression = ParseExpressionContinued(expression, precedence); 143124"];
7127 [label="expression = ParseExpressionContinued(expression, precedence); 143125"];
7128 [label="ParseExpressionContinued(expression, precedence) 143126"];
7129 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 143127"];
7130 [label="param ParseExpressionContinued(Precedence precedence) 143128"];
7131 [label="param ParseExpressionContinued(this) 143129"];
7132 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 143130"];
7133 [label="this.CurrentToken 143131"];
7134 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143132"];
7135 [label="var tk = this.CurrentToken.ContextualKind; 143133"];
7136 [label="this.CurrentToken.ContextualKind 143134"];
7137 [label="get\n            {\n                return this.Kind;\n            } 143135"];
7138 [label="bool isAssignmentOperator = false; 143136"];
7139 [label="SyntaxKind opKind; 143137"];
7140 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 143138"];
7141 [label="IsExpectedBinaryOperator(tk) 143139"];
7142 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 143140"];
7143 [label="return SyntaxFacts.IsBinaryExpression(kind); 143141"];
7144 [label="SyntaxFacts.IsBinaryExpression(kind) 143142"];
7145 [label="param IsBinaryExpression(SyntaxKind token) 143143"];
7146 [label="return GetBinaryExpression(token) != SyntaxKind.None; 143144"];
7147 [label="GetBinaryExpression(token) 143145"];
7148 [label="param GetBinaryExpression(SyntaxKind token) 143146"];
7149 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 143147"];
7150 [label="return SyntaxKind.None; 143148"];
7151 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 143149"];
7152 [label="IsExpectedAssignmentOperator(tk) 143150"];
7153 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 143151"];
7154 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 143152"];
7155 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 143153"];
7156 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 143154"];
7157 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 143155"];
7158 [label="return false; 143156"];
7159 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 143157"];
7160 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 143158"];
7161 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 143159"];
7162 [label="CurrentToken 143160"];
7163 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143161"];
7164 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 143162"];
7165 [label="CurrentToken.Kind 143163"];
7166 [label="get { return (SyntaxKind)this.RawKind; } 143164"];
7167 [label="return _syntaxFactory.ConstantPattern(expression); 143165"];
7168 [label="return _syntaxFactory.ConstantPattern(expression); 143166"];
7169 [label="return _syntaxFactory.ConstantPattern(expression); 143167"];
7170 [label="param TryGetNode(int kind) 143168"];
7171 [label="param TryGetNode(GreenNode child1) 143169"];
7172 [label="param TryGetNode(SyntaxFactoryContext context) 143170"];
7173 [label="param TryGetNode(out int hash) 143171"];
7174 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 143172"];
7175 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 143173"];
7176 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 143174"];
7177 [label="GetNodeFlags(context) 143175"];
7178 [label="param GetNodeFlags(SyntaxFactoryContext context) 143176"];
7179 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 143177"];
7180 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 143178"];
7181 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 143179"];
7182 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 143180"];
7183 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 143181"];
7184 [label="param SetFactoryContext(SyntaxFactoryContext context) 143182"];
7185 [label="param SetFactoryContext(this) 143183"];
7186 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 143184"];
7187 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 143185"];
7188 [label="if (p != null)\n                    return p; 143186"];
7189 [label="if (p != null)\n                    return p; 143187"];
7190 [label="return p; 143188"];
7191 [label="this.Release(ref resetPoint); 143189"];
7192 [label="this.Release(ref resetPoint) 143190"];
7193 [label="param Release(ref ResetPoint state) 143191"];
7194 [label="base.Release(ref state.BaseResetPoint); 143192"];
7195 [label="param Release(ref ResetPoint point) 143193"];
7196 [label="Debug.Assert(_resetCount == point.ResetCount); 143194"];
7197 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 143195"];
7198 [label="base.Release(ref state.BaseResetPoint); 143196"];
7199 [label="this.Release(ref resetPoint); 143197"];
7200 [label="this.CurrentToken 143198"];
7201 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143199"];
7202 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143200"];
7203 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.AndKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.AndPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureAndPattern);\n            } 143201"];
7204 [label="this.CurrentToken.ContextualKind 143202"];
7205 [label="get\n            {\n                return this.Kind;\n            } 143203"];
7206 [label="return result; 143204"];
7207 [label="this.CurrentToken 143205"];
7208 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143206"];
7209 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143207"];
7210 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.OrKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.OrPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureOrPattern);\n            } 143208"];
7211 [label="this.CurrentToken.ContextualKind 143209"];
7212 [label="get\n            {\n                return this.Kind;\n            } 143210"];
7213 [label="return result; 143211"];
7214 [label="pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            } 143212"];
7215 [label="return pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            }; 143213"];
7216 [label="return CheckRecursivePatternFeature(ParseExpressionOrPatternForSwitchStatementCore()); 143214"];
7217 [label="CheckRecursivePatternFeature(ParseExpressionOrPatternForSwitchStatementCore()) 143215"];
7218 [label="param CheckRecursivePatternFeature(CSharpSyntaxNode node) 143216"];
7219 [label="param CheckRecursivePatternFeature(this) 143217"];
7220 [label="node.Kind 143218"];
7221 [label="get { return (SyntaxKind)this.RawKind; } 143219"];
7222 [label="switch (node.Kind)\n            {\n                case SyntaxKind.RecursivePattern:\n                case SyntaxKind.DiscardPattern:\n                case SyntaxKind.VarPattern when ((VarPatternSyntax)node).Designation.Kind == SyntaxKind.ParenthesizedVariableDesignation:\n                    return this.CheckFeatureAvailability(node, MessageID.IDS_FeatureRecursivePatterns);\n                default:\n                    return node;\n            } 143220"];
7223 [label="return node; 143221"];
7224 [label="var node = ParseExpressionOrPatternForSwitchStatement(); 143222"];
7225 [label="this.CurrentToken 143223"];
7226 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143224"];
7227 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex); 143225"];
7228 [label="this.CurrentToken.ContextualKind 143226"];
7229 [label="get\n            {\n                return this.Kind;\n            } 143227"];
7230 [label="node.Kind 143228"];
7231 [label="get { return (SyntaxKind)this.RawKind; } 143229"];
7232 [label="if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement); 143230"];
7233 [label="if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            } 143231"];
7234 [label="colon = this.EatToken(SyntaxKind.ColonToken); 143232"];
7235 [label="this.EatToken(SyntaxKind.ColonToken) 143233"];
7236 [label="param EatToken(SyntaxKind kind) 143234"];
7237 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 143235"];
7238 [label="SyntaxFacts.IsAnyToken(kind) 143236"];
7239 [label="param IsAnyToken(SyntaxKind kind) 143237"];
7240 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 143238"];
7241 [label="return true; 143239"];
7242 [label="param GetTrailingTrivia(this) 143240"];
7243 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 143241"];
7244 [label="MoveToNextToken(); 143242"];
7245 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 143243"];
7246 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 143244"];
7247 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 143245"];
7248 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 143246"];
7249 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 143247"];
7250 [label="param TryGetNode(SyntaxFactoryContext context) 143248"];
7251 [label="param GetNodeFlags(SyntaxFactoryContext context) 143249"];
7252 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 143250"];
7253 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 143251"];
7254 [label="param SetFactoryContext(SyntaxFactoryContext context) 143252"];
7255 [label="param SetFactoryContext(this) 143253"];
7256 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 143254"];
7257 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 143255"];
7258 [label="labels.Add(label); 143256"];
7259 [label="IsPossibleSwitchSection() 143257"];
7260 [label="param IsPossibleSwitchSection(this) 143258"];
7261 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 143259"];
7262 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 143260"];
7263 [label="this.CurrentToken 143261"];
7264 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143262"];
7265 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143263"];
7266 [label="this.CurrentToken.Kind 143264"];
7267 [label="get { return (SyntaxKind)this.RawKind; } 143265"];
7268 [label="do\n                {\n                    SyntaxToken specifier;\n                    SwitchLabelSyntax label;\n                    SyntaxToken colon;\n                    if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    }\n\n                    labels.Add(label);\n                }\n                while (IsPossibleSwitchSection()); 143266"];
7269 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 143267"];
7270 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 143268"];
7271 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 143269"];
7272 [label="this.ParseStatements(ref tmp, statements, true); 143270"];
7273 [label="this.ParseStatements(ref tmp, statements, true); 143271"];
7274 [label="this.ParseStatements(ref tmp, statements, true); 143272"];
7275 [label="this.ParseStatements(ref tmp, statements, true) 143273"];
7276 [label="param ParseStatements(ref CSharpSyntaxNode previousNode) 143274"];
7277 [label="param ParseStatements(SyntaxListBuilder<StatementSyntax> statements) 143275"];
7278 [label="param ParseStatements(bool stopOnSwitchSections) 143276"];
7279 [label="param ParseStatements(this) 143277"];
7280 [label="var saveTerm = _termState; 143278"];
7281 [label="_termState |= TerminatorState.IsPossibleStatementStartOrStop; 143279"];
7282 [label="_termState 143280"];
7283 [label="if (stopOnSwitchSections)\n            {\n                _termState |= TerminatorState.IsSwitchSectionStart;\n            } 143281"];
7284 [label="_termState |= TerminatorState.IsSwitchSectionStart; 143282"];
7285 [label="_termState 143283"];
7286 [label="int lastTokenPosition = -1; 143284"];
7287 [label="this.CurrentToken 143285"];
7288 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143286"];
7289 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143287"];
7290 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 143288"];
7291 [label="this.CurrentToken.Kind 143289"];
7292 [label="get { return (SyntaxKind)this.RawKind; } 143290"];
7293 [label="this.CurrentToken 143291"];
7294 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143292"];
7295 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143293"];
7296 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 143294"];
7297 [label="this.CurrentToken.Kind 143295"];
7298 [label="get { return (SyntaxKind)this.RawKind; } 143296"];
7299 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 143297"];
7300 [label="this.IsPossibleSwitchSection() 143298"];
7301 [label="param IsPossibleSwitchSection(this) 143299"];
7302 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143300"];
7303 [label="this.CurrentToken 143301"];
7304 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143302"];
7305 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143303"];
7306 [label="this.CurrentToken.Kind 143304"];
7307 [label="get { return (SyntaxKind)this.RawKind; } 143305"];
7308 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 143306"];
7309 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 143307"];
7310 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 143308"];
7311 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 143309"];
7312 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 143310"];
7313 [label="IsMakingProgress(ref lastTokenPosition) 143311"];
7314 [label="param IsMakingProgress(ref int lastTokenPosition) 143312"];
7315 [label="param IsMakingProgress(bool assertIfFalse = true) 143313"];
7316 [label="param IsMakingProgress(this) 143314"];
7317 [label="_firstToken + _tokenOffset 143315"];
7318 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 143316"];
7319 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 143317"];
7320 [label="if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                } 143318"];
7321 [label="this.IsPossibleStatement(acceptAccessibilityMods: true) 143319"];
7322 [label="param IsPossibleStatement(bool acceptAccessibilityMods) 143320"];
7323 [label="param IsPossibleStatement(this) 143321"];
7324 [label="this.CurrentToken 143322"];
7325 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143323"];
7326 [label="var tk = this.CurrentToken.Kind; 143324"];
7327 [label="this.CurrentToken.Kind 143325"];
7328 [label="get { return (SyntaxKind)this.RawKind; } 143326"];
7329 [label="switch (tk)\n            {\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.ThrowKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.OpenBracketToken:\n                    return true;\n\n                case SyntaxKind.IdentifierToken:\n                    return IsTrueIdentifier();\n\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.FinallyKeyword:\n                    return !_isInTry;\n\n                // Accessibility modifiers are not legal in a statement,\n                // but a common mistake for local functions. Parse to give a\n                // better error message.\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PrivateKeyword:\n                    return acceptAccessibilityMods;\n                default:\n                    return IsPredefinedType(tk)\n                        || IsPossibleExpression();\n            } 143327"];
7330 [label="return true; 143328"];
7331 [label="if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                } 143329"];
7332 [label="this.ParsePossiblyAttributedStatement() 143330"];
7333 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 143331"];
7334 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 143332"];
7335 [label="this.CurrentToken.Kind 143333"];
7336 [label="get { return (SyntaxKind)this.RawKind; } 143334"];
7337 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 143335"];
7338 [label="false 143336"];
7339 [label="isGlobal: false 143337"];
7340 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 143338"];
7341 [label="param ParseStatementCore(bool isGlobal) 143339"];
7342 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 143340"];
7343 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 143341"];
7344 [label="canReuseStatement(attributes, isGlobal) 143342"];
7345 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 143343"];
7346 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 143344"];
7347 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 143345"];
7348 [label="this.IsIncrementalAndFactoryContextMatches 143346"];
7349 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 143347"];
7350 [label="base.IsIncremental 143348"];
7351 [label="get\n            {\n                return _isIncremental;\n            } 143349"];
7352 [label="return _isIncremental; 143350"];
7353 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 143351"];
7354 [label="return false; 143352"];
7355 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 143353"];
7356 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 143354"];
7357 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 143355"];
7358 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 143356"];
7359 [label="StatementSyntax result; 143357"];
7360 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 143358"];
7361 [label="this.EatToken() 143359"];
7362 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 143360"];
7363 [label="MoveToNextToken(); 143361"];
7364 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 143362"];
7365 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 143363"];
7366 [label="return _syntaxFactory.EmptyStatement(attributes, this.EatToken()); 143364"];
7367 [label="param TryGetNode(int kind) 143365"];
7368 [label="param TryGetNode(GreenNode child1) 143366"];
7369 [label="param TryGetNode(GreenNode child2) 143367"];
7370 [label="param TryGetNode(SyntaxFactoryContext context) 143368"];
7371 [label="param TryGetNode(out int hash) 143369"];
7372 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 143370"];
7373 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 143371"];
7374 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 143372"];
7375 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 143373"];
7376 [label="GetNodeFlags(context) 143374"];
7377 [label="param GetNodeFlags(SyntaxFactoryContext context) 143375"];
7378 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 143376"];
7379 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 143377"];
7380 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 143378"];
7381 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 143379"];
7382 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 143380"];
7383 [label="param SetFactoryContext(SyntaxFactoryContext context) 143381"];
7384 [label="param SetFactoryContext(this) 143382"];
7385 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 143383"];
7386 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 143384"];
7387 [label="_recursionDepth 143385"];
7388 [label="this.Release(ref resetPointBeforeStatement); 143386"];
7389 [label="this.Release(ref resetPointBeforeStatement) 143387"];
7390 [label="param Release(ref ResetPoint state) 143388"];
7391 [label="base.Release(ref state.BaseResetPoint); 143389"];
7392 [label="param Release(ref ResetPoint point) 143390"];
7393 [label="Debug.Assert(_resetCount == point.ResetCount); 143391"];
7394 [label="_resetCount 143392"];
7395 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 143393"];
7396 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 143394"];
7397 [label="base.Release(ref state.BaseResetPoint); 143395"];
7398 [label="this.Release(ref resetPointBeforeStatement); 143396"];
7399 [label="var statement = this.ParsePossiblyAttributedStatement(); 143397"];
7400 [label="if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    } 143398"];
7401 [label="if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    } 143399"];
7402 [label="statements.Add(statement); 143400"];
7403 [label="statements.Add(statement); 143401"];
7404 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 143402"];
7405 [label="_termState 143403"];
7406 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 143404"];
7407 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 143405"];
7408 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 143406"];
7409 [label="return _syntaxFactory.SwitchSection(labels, statements); 143407"];
7410 [label="return _syntaxFactory.SwitchSection(labels, statements); 143408"];
7411 [label="return _syntaxFactory.SwitchSection(labels, statements); 143409"];
7412 [label="return _syntaxFactory.SwitchSection(labels, statements); 143410"];
7413 [label="param TryGetNode(SyntaxFactoryContext context) 143411"];
7414 [label="GetNodeFlags(context) 143412"];
7415 [label="param GetNodeFlags(SyntaxFactoryContext context) 143413"];
7416 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 143414"];
7417 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 143415"];
7418 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 143416"];
7419 [label="param SetFactoryContext(SyntaxFactoryContext context) 143417"];
7420 [label="param SetFactoryContext(this) 143418"];
7421 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 143419"];
7422 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 143420"];
7423 [label="_pool.Free(statements); 143421"];
7424 [label="_pool.Free(statements); 143422"];
7425 [label="_pool.Free(labels); 143423"];
7426 [label="_pool.Free(labels); 143424"];
7427 [label="var swcase = this.ParseSwitchSection(); 143425"];
7428 [label="sections.Add(swcase); 143426"];
7429 [label="sections.Add(swcase); 143427"];
7430 [label="this.IsPossibleSwitchSection() 143428"];
7431 [label="Debug.Assert(this.IsPossibleSwitchSection()); 143429"];
7432 [label="SyntaxToken specifier; 143430"];
7433 [label="SwitchLabelSyntax label; 143431"];
7434 [label="SyntaxToken colon; 143432"];
7435 [label="ExpressionSyntax expression; 143433"];
7436 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 143434"];
7437 [label="MoveToNextToken(); 143435"];
7438 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 143436"];
7439 [label="param ParsePattern(Precedence precedence) 143437"];
7440 [label="param ParsePattern(bool whenIsKeyword = false) 143438"];
7441 [label="param ParseDisjunctivePattern(Precedence precedence) 143439"];
7442 [label="param ParseDisjunctivePattern(bool whenIsKeyword) 143440"];
7443 [label="param ParseConjunctivePattern(Precedence precedence) 143441"];
7444 [label="param ParseConjunctivePattern(bool whenIsKeyword) 143442"];
7445 [label="param ParseNegatedPattern(Precedence precedence) 143443"];
7446 [label="param ParseNegatedPattern(bool whenIsKeyword) 143444"];
7447 [label="param ParsePrimaryPattern(Precedence precedence) 143445"];
7448 [label="param ParsePrimaryPattern(bool whenIsKeyword) 143446"];
7449 [label="this.CurrentToken 143447"];
7450 [label="var tk = this.CurrentToken.Kind; 143448"];
7451 [label="this.CurrentToken.Kind 143449"];
7452 [label="get { return (SyntaxKind)this.RawKind; } 143450"];
7453 [label="switch (tk)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return _syntaxFactory.ConstantPattern(this.ParseIdentifierName(ErrorCode.ERR_MissingPattern));\n            } 143451"];
7454 [label="CurrentToken 143452"];
7455 [label="if (CurrentToken.ContextualKind == SyntaxKind.UnderscoreToken)\n            {\n                return _syntaxFactory.DiscardPattern(this.EatContextualToken(SyntaxKind.UnderscoreToken));\n            } 143453"];
7456 [label="CurrentToken.ContextualKind 143454"];
7457 [label="get\n            {\n                return this.Kind;\n            } 143455"];
7458 [label="CurrentToken 143456"];
7459 [label="switch (CurrentToken.Kind)\n            {\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                    // this is a relational pattern.\n                    var relationalToken = this.EatToken();\n                    Debug.Assert(precedence < Precedence.Shift);\n                    var expression = this.ParseSubExpression(Precedence.Relational);\n                    var result = _syntaxFactory.RelationalPattern(relationalToken, expression);\n                    return CheckFeatureAvailability(result, MessageID.IDS_FeatureRelationalPattern);\n            } 143457"];
7460 [label="CurrentToken.Kind 143458"];
7461 [label="get { return (SyntaxKind)this.RawKind; } 143459"];
7462 [label="var resetPoint = this.GetResetPoint(); 143460"];
7463 [label="TypeSyntax type = null; 143461"];
7464 [label="if (SyntaxFacts.IsPredefinedType(tk))\n            {\n                return true;\n            } 143462"];
7465 [label="SyntaxFacts.IsPredefinedType(tk) 143463"];
7466 [label="param IsPredefinedType(SyntaxKind kind) 143464"];
7467 [label="get { return (SyntaxKind)this.RawKind; } 143465"];
7468 [label="afterIs 143466"];
7469 [label="this.CurrentToken 143467"];
7470 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 143468"];
7471 [label="this.CurrentToken.Kind 143469"];
7472 [label="get { return (SyntaxKind)this.RawKind; } 143470"];
7473 [label="param ParseUnderlyingType(ParseTypeMode mode) 143471"];
7474 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 143472"];
7475 [label="this.CurrentToken 143473"];
7476 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143474"];
7477 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 143475"];
7478 [label="this.CurrentToken.Kind 143476"];
7479 [label="get { return (SyntaxKind)this.RawKind; } 143477"];
7480 [label="IsPredefinedType(this.CurrentToken.Kind) 143478"];
7481 [label="param IsPredefinedType(SyntaxKind keyword) 143479"];
7482 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 143480"];
7483 [label="this.CurrentToken 143481"];
7484 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143482"];
7485 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 143483"];
7486 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 143484"];
7487 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 143485"];
7488 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 143486"];
7489 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 143487"];
7490 [label="this.IsIncrementalAndFactoryContextMatches 143488"];
7491 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 143489"];
7492 [label="base.IsIncremental 143490"];
7493 [label="get\n            {\n                return _isIncremental;\n            } 143491"];
7494 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 143492"];
7495 [label="return false; 143493"];
7496 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 143494"];
7497 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 143495"];
7498 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 143496"];
7499 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 143497"];
7500 [label="this.CurrentToken 143498"];
7501 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143499"];
7502 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 143500"];
7503 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 143501"];
7504 [label="IsCurrentTokenQueryKeywordInQuery() 143502"];
7505 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 143503"];
7506 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 143504"];
7507 [label="param GetTrailingTrivia(this) 143505"];
7508 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 143506"];
7509 [label="MoveToNextToken(); 143507"];
7510 [label="this.IsInAsync 143508"];
7511 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 143509"];
7512 [label="return _syntaxFactoryContext.IsInAsync; 143510"];
7513 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 143511"];
7514 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 143512"];
7515 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 143513"];
7516 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 143514"];
7517 [label="this.CurrentToken.Kind 143515"];
7518 [label="get { return (SyntaxKind)this.RawKind; } 143516"];
7519 [label="this.CurrentToken 143517"];
7520 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143518"];
7521 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 143519"];
7522 [label="this.CurrentToken.Kind 143520"];
7523 [label="get { return (SyntaxKind)this.RawKind; } 143521"];
7524 [label="this.IsDotOrColonColon() 143522"];
7525 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143523"];
7526 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 143524"];
7527 [label="this.CurrentToken 143525"];
7528 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143526"];
7529 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 143527"];
7530 [label="this.CurrentToken.Kind 143528"];
7531 [label="get { return (SyntaxKind)this.RawKind; } 143529"];
7532 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 143530"];
7533 [label="param IsMakingProgress(bool assertIfFalse = true) 143531"];
7534 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 143532"];
7535 [label="CanTokenFollowTypeInPattern(precedence) 143533"];
7536 [label="param CanTokenFollowTypeInPattern(Precedence precedence) 143534"];
7537 [label="param CanTokenFollowTypeInPattern(this) 143535"];
7538 [label="this.CurrentToken 143536"];
7539 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143537"];
7540 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143538"];
7541 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.CloseBraceToken:   // for efficiency, test some tokens that can follow a type pattern\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                case SyntaxKind.DotToken:\n                    // int.MaxValue is an expression, not a type.\n                    return false;\n                case var kind:\n                    // If we find what looks like a continuation of an expression, it is not a type.\n                    return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence;\n            } 143539"];
7542 [label="this.CurrentToken.Kind 143540"];
7543 [label="get { return (SyntaxKind)this.RawKind; } 143541"];
7544 [label="return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence; 143542"];
7545 [label="SyntaxFacts.IsBinaryExpressionOperatorToken(kind) 143543"];
7546 [label="param IsBinaryExpressionOperatorToken(SyntaxKind token) 143544"];
7547 [label="return GetBinaryExpression(token) != SyntaxKind.None; 143545"];
7548 [label="GetBinaryExpression(token) 143546"];
7549 [label="param GetBinaryExpression(SyntaxKind token) 143547"];
7550 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 143548"];
7551 [label="return SyntaxKind.None; 143549"];
7552 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 143550"];
7553 [label="param ParsePatternContinued(Precedence precedence) 143551"];
7554 [label="param ParsePatternContinued(bool whenIsKeyword) 143552"];
7555 [label=".Kind 143553"];
7556 [label="get { return (SyntaxKind)this.RawKind; } 143554"];
7557 [label="if (type?.Kind == SyntaxKind.IdentifierName)\n            {\n                var typeIdentifier = (IdentifierNameSyntax)type;\n                var typeIdentifierToken = typeIdentifier.Identifier;\n                if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                }\n            } 143555"];
7558 [label="var typeIdentifier = (IdentifierNameSyntax)type; 143556"];
7559 [label="var typeIdentifierToken = typeIdentifier.Identifier; 143557"];
7560 [label="typeIdentifierToken.ContextualKind 143558"];
7561 [label="get\n            {\n                return this.Kind;\n            } 143559"];
7562 [label="if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                } 143560"];
7563 [label="this.CurrentToken 143561"];
7564 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143562"];
7565 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken && (type != null || !looksLikeCast()))\n            {\n                // It is possible this is a parenthesized (constant) expression.\n                // We normalize later.\n                ParseSubpatternList(\n                    openToken: out SyntaxToken openParenToken,\n                    subPatterns: out SeparatedSyntaxList<SubpatternSyntax> subPatterns,\n                    closeToken: out SyntaxToken closeParenToken,\n                    openKind: SyntaxKind.OpenParenToken,\n                    closeKind: SyntaxKind.CloseParenToken);\n\n                parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause0);\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n\n                if (type == null &&\n                    propertyPatternClause0 == null &&\n                    designation0 == null &&\n                    subPatterns.Count == 1 &&\n                    subPatterns.SeparatorCount == 0 &&\n                    subPatterns[0].NameColon == null)\n                {\n                    var subpattern = subPatterns[0].Pattern;\n                    switch (subpattern)\n                    {\n                        case ConstantPatternSyntax cp:\n                            // There is an ambiguity between a positional pattern `(` pattern `)`\n                            // and a constant expression pattern that happens to be parenthesized.\n                            // Per 2017-11-20 LDM we treat such syntax as a parenthesized expression always.\n                            ExpressionSyntax expression = _syntaxFactory.ParenthesizedExpression(openParenToken, cp.Expression, closeParenToken);\n                            expression = ParseExpressionContinued(expression, precedence);\n                            return _syntaxFactory.ConstantPattern(expression);\n                        default:\n                            var parenthesizedPattern = _syntaxFactory.ParenthesizedPattern(openParenToken, subPatterns[0].Pattern, closeParenToken);\n                            return CheckFeatureAvailability(parenthesizedPattern, MessageID.IDS_FeatureParenthesizedPattern);\n                    }\n                }\n\n                var positionalPatternClause = _syntaxFactory.PositionalPatternClause(openParenToken, subPatterns, closeParenToken);\n                var result = _syntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause0, designation0);\n                return result;\n            } 143563"];
7566 [label="this.CurrentToken.Kind 143564"];
7567 [label="get { return (SyntaxKind)this.RawKind; } 143565"];
7568 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 143566"];
7569 [label="parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause) 143567"];
7570 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 143568"];
7571 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 143569"];
7572 [label="propertyPatternClauseResult = null; 143570"];
7573 [label="this.CurrentToken 143571"];
7574 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143572"];
7575 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143573"];
7576 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                } 143574"];
7577 [label="this.CurrentToken.Kind 143575"];
7578 [label="get { return (SyntaxKind)this.RawKind; } 143576"];
7579 [label="return false; 143577"];
7580 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 143578"];
7581 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 143579"];
7582 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 143580"];
7583 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 143581"];
7584 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 143582"];
7585 [label="designationResult = null; 143583"];
7586 [label="this.IsTrueIdentifier() 143584"];
7587 [label="param IsTrueIdentifier(this) 143585"];
7588 [label="return false; 143586"];
7589 [label="if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                } 143587"];
7590 [label="param ConvertTypeToExpression(out ExpressionSyntax expr) 143588"];
7591 [label="param ConvertTypeToExpression(bool permitTypeArguments = false) 143589"];
7592 [label="param ConvertTypeToExpression(this) 143590"];
7593 [label="expr = null; 143591"];
7594 [label="expression = ParseExpressionContinued(expression, precedence); 143592"];
7595 [label="param ParseExpressionContinued(Precedence precedence) 143593"];
7596 [label="param ParseExpressionContinued(this) 143594"];
7597 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 143595"];
7598 [label="this.CurrentToken 143596"];
7599 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143597"];
7600 [label="var tk = this.CurrentToken.ContextualKind; 143598"];
7601 [label="this.CurrentToken.ContextualKind 143599"];
7602 [label="get\n            {\n                return this.Kind;\n            } 143600"];
7603 [label="bool isAssignmentOperator = false; 143601"];
7604 [label="SyntaxKind opKind; 143602"];
7605 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 143603"];
7606 [label="IsExpectedBinaryOperator(tk) 143604"];
7607 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 143605"];
7608 [label="return SyntaxFacts.IsBinaryExpression(kind); 143606"];
7609 [label="SyntaxFacts.IsBinaryExpression(kind) 143607"];
7610 [label="param IsBinaryExpression(SyntaxKind token) 143608"];
7611 [label="return GetBinaryExpression(token) != SyntaxKind.None; 143609"];
7612 [label="GetBinaryExpression(token) 143610"];
7613 [label="param GetBinaryExpression(SyntaxKind token) 143611"];
7614 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 143612"];
7615 [label="return SyntaxKind.None; 143613"];
7616 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 143614"];
7617 [label="IsExpectedAssignmentOperator(tk) 143615"];
7618 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 143616"];
7619 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 143617"];
7620 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 143618"];
7621 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 143619"];
7622 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 143620"];
7623 [label="return false; 143621"];
7624 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 143622"];
7625 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 143623"];
7626 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 143624"];
7627 [label="CurrentToken 143625"];
7628 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143626"];
7629 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 143627"];
7630 [label="CurrentToken.Kind 143628"];
7631 [label="get { return (SyntaxKind)this.RawKind; } 143629"];
7632 [label="param TryGetNode(SyntaxFactoryContext context) 143630"];
7633 [label="param GetNodeFlags(SyntaxFactoryContext context) 143631"];
7634 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 143632"];
7635 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 143633"];
7636 [label="param SetFactoryContext(SyntaxFactoryContext context) 143634"];
7637 [label="param SetFactoryContext(this) 143635"];
7638 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 143636"];
7639 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 143637"];
7640 [label="this.Release(ref resetPoint); 143638"];
7641 [label="param Release(ref ResetPoint state) 143639"];
7642 [label="base.Release(ref state.BaseResetPoint); 143640"];
7643 [label="param Release(ref ResetPoint point) 143641"];
7644 [label="Debug.Assert(_resetCount == point.ResetCount); 143642"];
7645 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 143643"];
7646 [label="base.Release(ref state.BaseResetPoint); 143644"];
7647 [label="this.Release(ref resetPoint); 143645"];
7648 [label="this.CurrentToken 143646"];
7649 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143647"];
7650 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.AndKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.AndPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureAndPattern);\n            } 143648"];
7651 [label="this.CurrentToken.ContextualKind 143649"];
7652 [label="get\n            {\n                return this.Kind;\n            } 143650"];
7653 [label="this.CurrentToken 143651"];
7654 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143652"];
7655 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.OrKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.OrPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureOrPattern);\n            } 143653"];
7656 [label="this.CurrentToken.ContextualKind 143654"];
7657 [label="get\n            {\n                return this.Kind;\n            } 143655"];
7658 [label="pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            } 143656"];
7659 [label="param CheckRecursivePatternFeature(this) 143657"];
7660 [label="this.CurrentToken 143658"];
7661 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143659"];
7662 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex); 143660"];
7663 [label="this.CurrentToken.ContextualKind 143661"];
7664 [label="get\n            {\n                return this.Kind;\n            } 143662"];
7665 [label="node.Kind 143663"];
7666 [label="get { return (SyntaxKind)this.RawKind; } 143664"];
7667 [label="if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement); 143665"];
7668 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 143666"];
7669 [label="SyntaxFacts.IsAnyToken(kind) 143667"];
7670 [label="param IsAnyToken(SyntaxKind kind) 143668"];
7671 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 143669"];
7672 [label="return true; 143670"];
7673 [label="param GetTrailingTrivia(this) 143671"];
7674 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 143672"];
7675 [label="MoveToNextToken(); 143673"];
7676 [label="param GetNodeFlags(SyntaxFactoryContext context) 143674"];
7677 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 143675"];
7678 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 143676"];
7679 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 143677"];
7680 [label="do\n                {\n                    SyntaxToken specifier;\n                    SwitchLabelSyntax label;\n                    SyntaxToken colon;\n                    if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    }\n\n                    labels.Add(label);\n                }\n                while (IsPossibleSwitchSection()); 143678"];
7681 [label="param IsMakingProgress(bool assertIfFalse = true) 143679"];
7682 [label="param IsPossibleStatement(bool acceptAccessibilityMods) 143680"];
7683 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 143681"];
7684 [label="this.CurrentToken.Kind 143682"];
7685 [label="get { return (SyntaxKind)this.RawKind; } 143683"];
7686 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 143684"];
7687 [label="false 143685"];
7688 [label="isGlobal: false 143686"];
7689 [label="param ParseStatementCore(bool isGlobal) 143687"];
7690 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 143688"];
7691 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 143689"];
7692 [label="canReuseStatement(attributes, isGlobal) 143690"];
7693 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 143691"];
7694 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 143692"];
7695 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 143693"];
7696 [label="this.IsIncrementalAndFactoryContextMatches 143694"];
7697 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 143695"];
7698 [label="base.IsIncremental 143696"];
7699 [label="get\n            {\n                return _isIncremental;\n            } 143697"];
7700 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 143698"];
7701 [label="return false; 143699"];
7702 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 143700"];
7703 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 143701"];
7704 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 143702"];
7705 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 143703"];
7706 [label="StatementSyntax result; 143704"];
7707 [label="MoveToNextToken(); 143705"];
7708 [label="this.Release(ref resetPointBeforeStatement); 143706"];
7709 [label="param Release(ref ResetPoint state) 143707"];
7710 [label="base.Release(ref state.BaseResetPoint); 143708"];
7711 [label="param Release(ref ResetPoint point) 143709"];
7712 [label="Debug.Assert(_resetCount == point.ResetCount); 143710"];
7713 [label="this.Release(ref resetPointBeforeStatement); 143711"];
7714 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 143712"];
7715 [label="param GetNodeFlags(SyntaxFactoryContext context) 143713"];
7716 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 143714"];
7717 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 143715"];
7718 [label="param SetFactoryContext(SyntaxFactoryContext context) 143716"];
7719 [label="param SetFactoryContext(this) 143717"];
7720 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 143718"];
7721 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 143719"];
7722 [label="this.CurrentToken 143720"];
7723 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143721"];
7724 [label="this.CurrentToken.Kind 143722"];
7725 [label="var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken); 143723"];
7726 [label="this.EatToken(SyntaxKind.CloseBraceToken) 143724"];
7727 [label="param EatToken(SyntaxKind kind) 143725"];
7728 [label="param EatToken(this) 143726"];
7729 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 143727"];
7730 [label="SyntaxFacts.IsAnyToken(kind) 143728"];
7731 [label="param IsAnyToken(SyntaxKind kind) 143729"];
7732 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 143730"];
7733 [label="return true; 143731"];
7734 [label="this.CurrentToken 143732"];
7735 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143733"];
7736 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 143734"];
7737 [label="ct.Kind 143735"];
7738 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 143736"];
7739 [label="param GetTrailingTrivia(this) 143737"];
7740 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 143738"];
7741 [label="MoveToNextToken(); 143739"];
7742 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 143740"];
7743 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 143741"];
7744 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 143742"];
7745 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 143743"];
7746 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 143744"];
7747 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 143745"];
7748 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 143746"];
7749 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 143747"];
7750 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 143748"];
7751 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 143749"];
7752 [label="param CSharpSyntaxNode(this) 143750"];
7753 [label="GreenStats.NoteGreen(this); 143751"];
7754 [label="param SetFactoryContext(SyntaxFactoryContext context) 143752"];
7755 [label="param SetFactoryContext(this) 143753"];
7756 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 143754"];
7757 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 143755"];
7758 [label="_pool.Free(sections); 143756"];
7759 [label="_pool.Free(sections); 143757"];
7760 [label="this.Release(ref resetPointBeforeStatement); 143758"];
7761 [label="this.Release(ref resetPointBeforeStatement) 143759"];
7762 [label="param Release(ref ResetPoint state) 143760"];
7763 [label="param Release(this) 143761"];
7764 [label="base.Release(ref state.BaseResetPoint); 143762"];
7765 [label="base.Release(ref state.BaseResetPoint) 143763"];
7766 [label="param Release(ref ResetPoint point) 143764"];
7767 [label="param Release(this) 143765"];
7768 [label="Debug.Assert(_resetCount == point.ResetCount); 143766"];
7769 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 143767"];
7770 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 143768"];
7771 [label="_resetStart = -1; 143769"];
7772 [label="_resetStart 143770"];
7773 [label="base.Release(ref state.BaseResetPoint); 143771"];
7774 [label="this.Release(ref resetPointBeforeStatement); 143772"];
7775 [label="var node = parser.ParseStatement(); 143773"];
7776 [label="if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node); 143774"];
7777 [label="node = parser.ConsumeUnexpectedTokens(node); 143775"];
7778 [label="parser.ConsumeUnexpectedTokens(node) 143776"];
7779 [label="param ConsumeUnexpectedTokens(TNode node) 143777"];
7780 [label="param ConsumeUnexpectedTokens(this) 143778"];
7781 [label="this.CurrentToken 143779"];
7782 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 143780"];
7783 [label="this.FetchCurrentToken() 143781"];
7784 [label="param FetchCurrentToken(this) 143782"];
7785 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 143783"];
7786 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 143784"];
7787 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 143785"];
7788 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken) return node; 143786"];
7789 [label="this.CurrentToken.Kind 143787"];
7790 [label="get { return (SyntaxKind)this.RawKind; } 143788"];
7791 [label="return node; 143789"];
7792 [label="return (StatementSyntax)node.CreateRed(); 143790"];
7793 [label="return (StatementSyntax)node.CreateRed(); 143791"];
7794 [label="return (StatementSyntax)node.CreateRed(); 143792"];
7795 [label="param CSharpSyntaxNode(GreenNode green) 143793"];
7796 [label="param CSharpSyntaxNode(SyntaxNode? parent) 143794"];
7797 [label="param CSharpSyntaxNode(int position) 143795"];
7798 [label="param CSharpSyntaxNode(this) 143796"];
7799 [label="green 143797"];
7800 [label="parent 143798"];
7801 [label="position 143799"];
7802 [label="param CSharpSyntaxNode(this) 143800"];
7803 [label="param CSharpSyntaxNode(this) 143801"];
7804 [label="CustomAssert.NotNull(statement); 143802"];
7805 [label="CustomAssert.Equal(SyntaxKind.SwitchStatement, statement.Kind()); 143803"];
7806 [label="statement.Kind() 143804"];
7807 [label="param Kind(this) 143805"];
7808 [label="return (SyntaxKind)this.Green.RawKind; 143806"];
7809 [label="CustomAssert.Equal(SyntaxKind.SwitchStatement, statement.Kind()); 143807"];
7810 [label="CustomAssert.Equal(text, statement.ToString()); 143808"];
7811 [label="CustomAssert.Equal(text, statement.ToString()); 143809"];
7812 [label="CustomAssert.Equal(text, statement.ToString()); 143810"];
7813 [label="=> true 143811"];
7814 [label="true 143812"];
7815 [label="CustomAssert.Equal(text, statement.ToString()); 143813"];
7816 [label="param WriteTokenTo(System.IO.TextWriter writer) 143814"];
7817 [label="param WriteTokenTo(bool leading) 143815"];
7818 [label="param WriteTokenTo(bool trailing) 143816"];
7819 [label="param WriteTokenTo(this) 143817"];
7820 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 143818"];
7821 [label="this.Text 143819"];
7822 [label="get { return SyntaxFacts.GetText(this.Kind); } 143820"];
7823 [label="this.Kind 143821"];
7824 [label="get { return (SyntaxKind)this.RawKind; } 143822"];
7825 [label="return (SyntaxKind)this.RawKind; 143823"];
7826 [label="return SyntaxFacts.GetText(this.Kind); 143824"];
7827 [label="SyntaxFacts.GetText(this.Kind) 143825"];
7828 [label="param GetText(SyntaxKind kind) 143826"];
7829 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 143827"];
7830 [label="return 'switch'; 143828"];
7831 [label="writer.Write(this.Text); 143829"];
7832 [label="writer.Write(this.Text); 143830"];
7833 [label="if (trailing)\n            {\n                var trivia = this.GetTrailingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 143831"];
7834 [label="this.GetTrailingTrivia() 143832"];
7835 [label="param GetTrailingTrivia(this) 143833"];
7836 [label="return this.TrailingField; 143834"];
7837 [label="var trivia = this.GetTrailingTrivia(); 143835"];
7838 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 143836"];
7839 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 143837"];
7840 [label="trivia.WriteTo(writer, true, true); 143838"];
7841 [label="trivia.WriteTo(writer, true, true); 143839"];
7842 [label="=> true 143840"];
7843 [label="true 143841"];
7844 [label="param WriteTriviaTo(System.IO.TextWriter writer) 143842"];
7845 [label="param WriteTriviaTo(this) 143843"];
7846 [label="writer.Write(Text); 143844"];
7847 [label="writer.Write(Text); 143845"];
7848 [label="this.GetLeadingTrivia() 143846"];
7849 [label="param GetLeadingTrivia(this) 143847"];
7850 [label="return null; 143848"];
7851 [label="var trivia = this.GetLeadingTrivia(); 143849"];
7852 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 143850"];
7853 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 143851"];
7854 [label="return '('; 143852"];
7855 [label="param GetTrailingTrivia(this) 143853"];
7856 [label="var trivia = this.GetTrailingTrivia(); 143854"];
7857 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 143855"];
7858 [label="get { return this.TextField; } 143856"];
7859 [label="return this.TextField; 143857"];
7860 [label="param GetLeadingTrivia(this) 143858"];
7861 [label="return this.LeadingField; 143859"];
7862 [label="var trivia = this.GetLeadingTrivia(); 143860"];
7863 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 143861"];
7864 [label="return ')'; 143862"];
7865 [label="=> true 143863"];
7866 [label="return this.LeadingField; 143864"];
7867 [label="var trivia = this.GetLeadingTrivia(); 143865"];
7868 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 143866"];
7869 [label="return '{'; 143867"];
7870 [label="=> true 143868"];
7871 [label="return this.LeadingField; 143869"];
7872 [label="var trivia = this.GetLeadingTrivia(); 143870"];
7873 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 143871"];
7874 [label="return 'case'; 143872"];
7875 [label="=> true 143873"];
7876 [label="return ':'; 143874"];
7877 [label="return this.LeadingField; 143875"];
7878 [label="var trivia = this.GetLeadingTrivia(); 143876"];
7879 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 143877"];
7880 [label="return ';'; 143878"];
7881 [label="=> true 143879"];
7882 [label="return this.LeadingField; 143880"];
7883 [label="var trivia = this.GetLeadingTrivia(); 143881"];
7884 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 143882"];
7885 [label="return '}'; 143883"];
7886 [label="CustomAssert.Equal(0, statement.Errors().Length); 143884"];
7887 [label="CustomAssert.Equal(0, statement.Errors().Length); 143885"];
7888 [label="statement.Errors() 143886"];
7889 [label="param Errors(this SyntaxNode node) 143887"];
7890 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 143888"];
7891 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 143889"];
7892 [label="node.Green.ErrorsOrWarnings(errorsOnly: true) 143890"];
7893 [label="param ErrorsOrWarnings(this GreenNode node) 143891"];
7894 [label="param ErrorsOrWarnings(bool errorsOnly) 143892"];
7895 [label="ArrayBuilder<DiagnosticInfo> b = ArrayBuilder<DiagnosticInfo>.GetInstance(); 143893"];
7896 [label="var l = new SyntaxDiagnosticInfoList(node); 143894"];
7897 [label="foreach (var item in l)\n            {\n                if (item.Severity == (errorsOnly ? DiagnosticSeverity.Error : DiagnosticSeverity.Warning))\n                    b.Add(item);\n            } 143895"];
7898 [label="return b.ToImmutableAndFree(); 143896"];
7899 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 143897"];
7900 [label="CustomAssert.Equal(0, statement.Errors().Length); 143898"];
7901 [label="var ss = (SwitchStatementSyntax)statement; 143899"];
7902 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 143900"];
7903 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 143901"];
7904 [label="ss.SwitchKeyword 143902"];
7905 [label="=> true 143903"];
7906 [label="true 143904"];
7907 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 143905"];
7908 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 143906"];
7909 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 143907"];
7910 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 143908"];
7911 [label="ss.SwitchKeyword 143909"];
7912 [label="=> true 143910"];
7913 [label="true 143911"];
7914 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 143912"];
7915 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 143913"];
7916 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 143914"];
7917 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 143915"];
7918 [label="ss.OpenParenToken 143916"];
7919 [label="=> true 143917"];
7920 [label="true 143918"];
7921 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 143919"];
7922 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 143920"];
7923 [label="CustomAssert.NotNull(ss.Expression); 143921"];
7924 [label="ss.Expression 143922"];
7925 [label="param CSharpSyntaxNode(GreenNode green) 143923"];
7926 [label="param CSharpSyntaxNode(SyntaxNode? parent) 143924"];
7927 [label="param CSharpSyntaxNode(int position) 143925"];
7928 [label="param CSharpSyntaxNode(this) 143926"];
7929 [label="param CSharpSyntaxNode(this) 143927"];
7930 [label="CustomAssert.Equal('a', ss.Expression.ToString()); 143928"];
7931 [label="ss.Expression.ToString() 143929"];
7932 [label="param ToString(this) 143930"];
7933 [label="this.Identifier.Text 143931"];
7934 [label="get { return this.TextField; } 143932"];
7935 [label="return this.Identifier.Text; 143933"];
7936 [label="CustomAssert.Equal('a', ss.Expression.ToString()); 143934"];
7937 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 143935"];
7938 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 143936"];
7939 [label="ss.CloseParenToken 143937"];
7940 [label="=> true 143938"];
7941 [label="true 143939"];
7942 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 143940"];
7943 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 143941"];
7944 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 143942"];
7945 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 143943"];
7946 [label="ss.OpenBraceToken 143944"];
7947 [label="=> true 143945"];
7948 [label="true 143946"];
7949 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 143947"];
7950 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 143948"];
7951 [label="CustomAssert.Equal(2, ss.Sections.Count); 143949"];
7952 [label="CustomAssert.Equal(2, ss.Sections.Count); 143950"];
7953 [label="CustomAssert.Equal(1, ss.Sections[0].Labels.Count); 143951"];
7954 [label="CustomAssert.Equal(1, ss.Sections[0].Labels.Count); 143952"];
7955 [label="ss.Sections[0].Labels 143953"];
7956 [label="param CSharpSyntaxNode(GreenNode green) 143954"];
7957 [label="param CSharpSyntaxNode(SyntaxNode? parent) 143955"];
7958 [label="param CSharpSyntaxNode(int position) 143956"];
7959 [label="param CSharpSyntaxNode(this) 143957"];
7960 [label="param CSharpSyntaxNode(this) 143958"];
7961 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 143959"];
7962 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 143960"];
7963 [label="ss.Sections[0].Labels[0].Keyword 143961"];
7964 [label="=> true 143962"];
7965 [label="true 143963"];
7966 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 143964"];
7967 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 143965"];
7968 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 143966"];
7969 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 143967"];
7970 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 143968"];
7971 [label="ss.Sections[0].Labels[0].Keyword 143969"];
7972 [label="=> true 143970"];
7973 [label="true 143971"];
7974 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 143972"];
7975 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 143973"];
7976 [label="var caseLabelSyntax = ss.Sections[0].Labels[0] as CaseSwitchLabelSyntax; 143974"];
7977 [label="var caseLabelSyntax = ss.Sections[0].Labels[0] as CaseSwitchLabelSyntax; 143975"];
7978 [label="CustomAssert.NotNull(caseLabelSyntax); 143976"];
7979 [label="CustomAssert.NotNull(caseLabelSyntax.Value); 143977"];
7980 [label="caseLabelSyntax.Value 143978"];
7981 [label="param CSharpSyntaxNode(GreenNode green) 143979"];
7982 [label="param CSharpSyntaxNode(SyntaxNode? parent) 143980"];
7983 [label="param CSharpSyntaxNode(int position) 143981"];
7984 [label="param CSharpSyntaxNode(this) 143982"];
7985 [label="param CSharpSyntaxNode(this) 143983"];
7986 [label="CustomAssert.Equal('b', caseLabelSyntax.Value.ToString()); 143984"];
7987 [label="caseLabelSyntax.Value.ToString() 143985"];
7988 [label="param ToString(this) 143986"];
7989 [label="this.Identifier.Text 143987"];
7990 [label="get { return this.TextField; } 143988"];
7991 [label="return this.Identifier.Text; 143989"];
7992 [label="CustomAssert.Equal('b', caseLabelSyntax.Value.ToString()); 143990"];
7993 [label="CustomAssert.NotEqual(default, caseLabelSyntax.ColonToken); 143991"];
7994 [label="CustomAssert.NotEqual(default, caseLabelSyntax.ColonToken); 143992"];
7995 [label="caseLabelSyntax.ColonToken 143993"];
7996 [label="=> true 143994"];
7997 [label="true 143995"];
7998 [label="CustomAssert.NotEqual(default, caseLabelSyntax.ColonToken); 143996"];
7999 [label="CustomAssert.NotEqual(default, caseLabelSyntax.ColonToken); 143997"];
8000 [label="CustomAssert.Equal(1, ss.Sections[0].Statements.Count); 143998"];
8001 [label="CustomAssert.Equal(1, ss.Sections[0].Statements.Count); 143999"];
8002 [label="ss.Sections[0].Statements 144000"];
8003 [label="param CSharpSyntaxNode(GreenNode green) 144001"];
8004 [label="param CSharpSyntaxNode(SyntaxNode? parent) 144002"];
8005 [label="param CSharpSyntaxNode(int position) 144003"];
8006 [label="param CSharpSyntaxNode(this) 144004"];
8007 [label="param CSharpSyntaxNode(this) 144005"];
8008 [label="CustomAssert.Equal(';', ss.Sections[0].Statements[0].ToString()); 144006"];
8009 [label="CustomAssert.Equal(';', ss.Sections[0].Statements[0].ToString()); 144007"];
8010 [label="=> true 144008"];
8011 [label="true 144009"];
8012 [label="param WriteTokenTo(bool leading) 144010"];
8013 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 144011"];
8014 [label="this.Text 144012"];
8015 [label="this.Kind 144013"];
8016 [label="SyntaxFacts.GetText(this.Kind) 144014"];
8017 [label="CustomAssert.Equal(1, ss.Sections[1].Labels.Count); 144015"];
8018 [label="CustomAssert.Equal(1, ss.Sections[1].Labels.Count); 144016"];
8019 [label="ss.Sections[1].Labels 144017"];
8020 [label="param CSharpSyntaxNode(GreenNode green) 144018"];
8021 [label="param CSharpSyntaxNode(SyntaxNode? parent) 144019"];
8022 [label="param CSharpSyntaxNode(int position) 144020"];
8023 [label="param CSharpSyntaxNode(this) 144021"];
8024 [label="param CSharpSyntaxNode(this) 144022"];
8025 [label="CustomAssert.NotEqual(default, ss.Sections[1].Labels[0].Keyword); 144023"];
8026 [label="CustomAssert.NotEqual(default, ss.Sections[1].Labels[0].Keyword); 144024"];
8027 [label="ss.Sections[1].Labels[0].Keyword 144025"];
8028 [label="=> true 144026"];
8029 [label="true 144027"];
8030 [label="CustomAssert.NotEqual(default, ss.Sections[1].Labels[0].Keyword); 144028"];
8031 [label="CustomAssert.NotEqual(default, ss.Sections[1].Labels[0].Keyword); 144029"];
8032 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[1].Labels[0].Keyword.Kind()); 144030"];
8033 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[1].Labels[0].Keyword.Kind()); 144031"];
8034 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[1].Labels[0].Keyword.Kind()); 144032"];
8035 [label="ss.Sections[1].Labels[0].Keyword 144033"];
8036 [label="=> true 144034"];
8037 [label="true 144035"];
8038 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[1].Labels[0].Keyword.Kind()); 144036"];
8039 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[1].Labels[0].Keyword.Kind()); 144037"];
8040 [label="var caseLabelSyntax2 = ss.Sections[1].Labels[0] as CaseSwitchLabelSyntax; 144038"];
8041 [label="var caseLabelSyntax2 = ss.Sections[1].Labels[0] as CaseSwitchLabelSyntax; 144039"];
8042 [label="CustomAssert.NotNull(caseLabelSyntax2); 144040"];
8043 [label="CustomAssert.NotNull(caseLabelSyntax2.Value); 144041"];
8044 [label="caseLabelSyntax2.Value 144042"];
8045 [label="param CSharpSyntaxNode(GreenNode green) 144043"];
8046 [label="param CSharpSyntaxNode(SyntaxNode? parent) 144044"];
8047 [label="param CSharpSyntaxNode(int position) 144045"];
8048 [label="param CSharpSyntaxNode(this) 144046"];
8049 [label="param CSharpSyntaxNode(this) 144047"];
8050 [label="CustomAssert.Equal('c', caseLabelSyntax2.Value.ToString()); 144048"];
8051 [label="caseLabelSyntax2.Value.ToString() 144049"];
8052 [label="param ToString(this) 144050"];
8053 [label="this.Identifier.Text 144051"];
8054 [label="get { return this.TextField; } 144052"];
8055 [label="return this.Identifier.Text; 144053"];
8056 [label="CustomAssert.Equal('c', caseLabelSyntax2.Value.ToString()); 144054"];
8057 [label="CustomAssert.NotEqual(default, caseLabelSyntax2.ColonToken); 144055"];
8058 [label="CustomAssert.NotEqual(default, caseLabelSyntax2.ColonToken); 144056"];
8059 [label="caseLabelSyntax2.ColonToken 144057"];
8060 [label="=> true 144058"];
8061 [label="true 144059"];
8062 [label="CustomAssert.NotEqual(default, caseLabelSyntax2.ColonToken); 144060"];
8063 [label="CustomAssert.NotEqual(default, caseLabelSyntax2.ColonToken); 144061"];
8064 [label="CustomAssert.Equal(1, ss.Sections[1].Statements.Count); 144062"];
8065 [label="CustomAssert.Equal(1, ss.Sections[1].Statements.Count); 144063"];
8066 [label="ss.Sections[1].Statements 144064"];
8067 [label="param CSharpSyntaxNode(GreenNode green) 144065"];
8068 [label="param CSharpSyntaxNode(SyntaxNode? parent) 144066"];
8069 [label="param CSharpSyntaxNode(int position) 144067"];
8070 [label="param CSharpSyntaxNode(this) 144068"];
8071 [label="param CSharpSyntaxNode(this) 144069"];
8072 [label="CustomAssert.Equal(';', ss.Sections[0].Statements[0].ToString()); 144070"];
8073 [label="CustomAssert.Equal(';', ss.Sections[0].Statements[0].ToString()); 144071"];
8074 [label="=> true 144072"];
8075 [label="true 144073"];
8076 [label="param WriteTokenTo(bool leading) 144074"];
8077 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 144075"];
8078 [label="this.Text 144076"];
8079 [label="this.Kind 144077"];
8080 [label="SyntaxFacts.GetText(this.Kind) 144078"];
8081 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 144079"];
8082 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 144080"];
8083 [label="ss.CloseBraceToken 144081"];
8084 [label="=> true 144082"];
8085 [label="true 144083"];
8086 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 144084"];
8087 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 144085"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 1;
192 -> 1;
193 -> 191;
193 -> 1;
194 -> 193;
194 -> 192;
195 -> 192;
196 -> 195;
197 -> 196;
198 -> 197;
199 -> 198;
199 -> 197;
200 -> 195;
200 -> 192;
201 -> 195;
201 -> 192;
202 -> 195;
202 -> 192;
203 -> 194;
203 -> 195;
203 -> 192;
204 -> 1;
204 -> 2;
204 -> 199;
204 -> 200;
204 -> 201;
204 -> 203;
205 -> 1;
206 -> 1;
207 -> 206;
207 -> 1;
208 -> 1;
209 -> 1;
210 -> 207;
210 -> 209;
211 -> 208;
211 -> 209;
212 -> 208;
212 -> 209;
213 -> 205;
213 -> 209;
215 -> 214;
216 -> 215;
218 -> 216;
218 -> 217;
219 -> 217;
220 -> 217;
221 -> 218;
221 -> 217;
222 -> 219;
222 -> 221;
223 -> 0;
223 -> 222;
224 -> 217;
225 -> 223;
225 -> 224;
225 -> 217;
227 -> 0;
227 -> 217;
228 -> 218;
228 -> 217;
229 -> 217;
230 -> 227;
230 -> 229;
231 -> 228;
231 -> 229;
232 -> 230;
232 -> 229;
233 -> 231;
233 -> 229;
234 -> 229;
235 -> 229;
236 -> 232;
236 -> 235;
237 -> 233;
237 -> 235;
238 -> 234;
238 -> 235;
239 -> 234;
239 -> 235;
240 -> 234;
240 -> 235;
241 -> 236;
241 -> 235;
242 -> 238;
242 -> 235;
243 -> 239;
243 -> 235;
245 -> 244;
246 -> 237;
246 -> 235;
247 -> 235;
248 -> 241;
248 -> 247;
249 -> 242;
249 -> 247;
250 -> 243;
250 -> 247;
251 -> 246;
251 -> 247;
252 -> 240;
252 -> 247;
253 -> 248;
253 -> 247;
254 -> 249;
254 -> 247;
255 -> 250;
255 -> 247;
256 -> 251;
256 -> 247;
257 -> 247;
258 -> 257;
258 -> 253;
258 -> 254;
258 -> 255;
258 -> 256;
258 -> 247;
259 -> 257;
259 -> 247;
260 -> 259;
260 -> 258;
260 -> 247;
261 -> 240;
261 -> 235;
262 -> 237;
262 -> 240;
262 -> 235;
263 -> 236;
263 -> 0;
263 -> 235;
264 -> 234;
264 -> 217;
265 -> 219;
265 -> 217;
266 -> 264;
266 -> 265;
267 -> 266;
270 -> 268;
270 -> 269;
271 -> 269;
272 -> 269;
273 -> 270;
273 -> 269;
274 -> 271;
274 -> 273;
275 -> 0;
275 -> 274;
276 -> 269;
277 -> 275;
277 -> 276;
277 -> 269;
278 -> 0;
278 -> 269;
279 -> 270;
279 -> 269;
280 -> 269;
281 -> 278;
281 -> 280;
282 -> 279;
282 -> 280;
283 -> 281;
283 -> 280;
284 -> 282;
284 -> 280;
285 -> 280;
286 -> 280;
287 -> 283;
287 -> 286;
288 -> 284;
288 -> 286;
289 -> 285;
289 -> 286;
290 -> 285;
290 -> 286;
291 -> 285;
291 -> 286;
292 -> 287;
292 -> 286;
293 -> 289;
293 -> 286;
294 -> 290;
294 -> 286;
295 -> 288;
295 -> 286;
296 -> 286;
297 -> 292;
297 -> 296;
298 -> 293;
298 -> 296;
299 -> 294;
299 -> 296;
300 -> 295;
300 -> 296;
301 -> 291;
301 -> 296;
302 -> 297;
302 -> 296;
303 -> 298;
303 -> 296;
304 -> 299;
304 -> 296;
305 -> 300;
305 -> 296;
306 -> 296;
307 -> 306;
307 -> 302;
307 -> 303;
307 -> 304;
307 -> 305;
307 -> 296;
308 -> 306;
308 -> 296;
309 -> 308;
309 -> 307;
309 -> 296;
310 -> 291;
310 -> 286;
311 -> 288;
311 -> 291;
311 -> 286;
312 -> 287;
312 -> 0;
312 -> 286;
313 -> 285;
313 -> 269;
314 -> 271;
314 -> 269;
315 -> 313;
315 -> 314;
316 -> 315;
319 -> 317;
319 -> 318;
320 -> 318;
321 -> 318;
322 -> 319;
322 -> 318;
323 -> 320;
323 -> 322;
324 -> 0;
324 -> 323;
325 -> 318;
326 -> 324;
326 -> 325;
326 -> 318;
327 -> 0;
327 -> 318;
328 -> 319;
328 -> 318;
329 -> 318;
330 -> 327;
330 -> 329;
331 -> 328;
331 -> 329;
332 -> 330;
332 -> 329;
333 -> 331;
333 -> 329;
334 -> 329;
335 -> 329;
336 -> 332;
336 -> 335;
337 -> 333;
337 -> 335;
338 -> 334;
338 -> 335;
339 -> 334;
339 -> 335;
340 -> 334;
340 -> 335;
341 -> 336;
341 -> 335;
342 -> 338;
342 -> 335;
343 -> 339;
343 -> 335;
344 -> 337;
344 -> 335;
345 -> 335;
346 -> 341;
346 -> 345;
347 -> 342;
347 -> 345;
348 -> 343;
348 -> 345;
349 -> 344;
349 -> 345;
350 -> 340;
350 -> 345;
351 -> 346;
351 -> 345;
352 -> 347;
352 -> 345;
353 -> 348;
353 -> 345;
354 -> 349;
354 -> 345;
355 -> 345;
356 -> 355;
356 -> 351;
356 -> 352;
356 -> 353;
356 -> 354;
356 -> 345;
357 -> 355;
357 -> 345;
358 -> 357;
358 -> 356;
358 -> 345;
359 -> 340;
359 -> 335;
360 -> 337;
360 -> 340;
360 -> 335;
361 -> 336;
361 -> 0;
361 -> 335;
362 -> 334;
362 -> 318;
363 -> 320;
363 -> 318;
364 -> 362;
364 -> 363;
365 -> 364;
368 -> 366;
368 -> 367;
369 -> 367;
370 -> 0;
370 -> 367;
371 -> 368;
371 -> 367;
372 -> 367;
373 -> 370;
373 -> 372;
374 -> 371;
374 -> 372;
375 -> 373;
375 -> 372;
376 -> 374;
376 -> 372;
377 -> 372;
378 -> 372;
379 -> 375;
379 -> 378;
380 -> 376;
380 -> 378;
381 -> 377;
381 -> 378;
382 -> 377;
382 -> 378;
383 -> 377;
383 -> 378;
384 -> 379;
384 -> 378;
385 -> 381;
385 -> 378;
386 -> 382;
386 -> 378;
387 -> 380;
387 -> 378;
388 -> 378;
389 -> 384;
389 -> 388;
390 -> 385;
390 -> 388;
391 -> 386;
391 -> 388;
392 -> 387;
392 -> 388;
393 -> 383;
393 -> 388;
394 -> 389;
394 -> 388;
395 -> 390;
395 -> 388;
396 -> 391;
396 -> 388;
397 -> 392;
397 -> 388;
398 -> 388;
399 -> 398;
399 -> 394;
399 -> 395;
399 -> 396;
399 -> 397;
399 -> 388;
400 -> 398;
400 -> 388;
401 -> 400;
401 -> 399;
401 -> 388;
402 -> 383;
402 -> 378;
403 -> 380;
403 -> 383;
403 -> 378;
404 -> 379;
404 -> 0;
404 -> 378;
405 -> 377;
405 -> 367;
406 -> 369;
406 -> 367;
407 -> 405;
407 -> 406;
408 -> 407;
411 -> 409;
411 -> 410;
412 -> 410;
413 -> 0;
413 -> 410;
414 -> 411;
414 -> 410;
415 -> 410;
416 -> 413;
416 -> 415;
417 -> 414;
417 -> 415;
418 -> 416;
418 -> 415;
419 -> 417;
419 -> 415;
420 -> 415;
421 -> 415;
422 -> 418;
422 -> 421;
423 -> 419;
423 -> 421;
424 -> 420;
424 -> 421;
425 -> 420;
425 -> 421;
426 -> 420;
426 -> 421;
427 -> 422;
427 -> 421;
428 -> 424;
428 -> 421;
429 -> 425;
429 -> 421;
430 -> 423;
430 -> 421;
431 -> 421;
432 -> 427;
432 -> 431;
433 -> 428;
433 -> 431;
434 -> 429;
434 -> 431;
435 -> 430;
435 -> 431;
436 -> 426;
436 -> 431;
437 -> 432;
437 -> 431;
438 -> 433;
438 -> 431;
439 -> 434;
439 -> 431;
440 -> 435;
440 -> 431;
441 -> 431;
442 -> 441;
442 -> 437;
442 -> 438;
442 -> 439;
442 -> 440;
442 -> 431;
443 -> 441;
443 -> 431;
444 -> 443;
444 -> 442;
444 -> 431;
445 -> 426;
445 -> 421;
446 -> 423;
446 -> 426;
446 -> 421;
447 -> 422;
447 -> 0;
447 -> 421;
448 -> 420;
448 -> 410;
449 -> 412;
449 -> 410;
450 -> 448;
450 -> 449;
451 -> 450;
452 -> 215;
454 -> 453;
456 -> 452;
456 -> 455;
457 -> 454;
457 -> 455;
458 -> 455;
459 -> 456;
459 -> 455;
460 -> 457;
460 -> 459;
461 -> 0;
461 -> 460;
462 -> 455;
463 -> 461;
463 -> 462;
463 -> 455;
464 -> 0;
464 -> 455;
465 -> 456;
465 -> 455;
466 -> 455;
467 -> 464;
467 -> 466;
468 -> 465;
468 -> 466;
469 -> 467;
469 -> 466;
470 -> 468;
470 -> 466;
471 -> 466;
472 -> 466;
473 -> 469;
473 -> 472;
474 -> 470;
474 -> 472;
475 -> 471;
475 -> 472;
476 -> 471;
476 -> 472;
477 -> 471;
477 -> 472;
478 -> 473;
478 -> 472;
479 -> 475;
479 -> 472;
480 -> 476;
480 -> 472;
481 -> 474;
481 -> 472;
482 -> 472;
483 -> 478;
483 -> 482;
484 -> 479;
484 -> 482;
485 -> 480;
485 -> 482;
486 -> 481;
486 -> 482;
487 -> 477;
487 -> 482;
488 -> 483;
488 -> 482;
489 -> 484;
489 -> 482;
490 -> 485;
490 -> 482;
491 -> 486;
491 -> 482;
492 -> 482;
493 -> 492;
493 -> 488;
493 -> 489;
493 -> 490;
493 -> 491;
493 -> 482;
494 -> 492;
494 -> 482;
495 -> 494;
495 -> 493;
495 -> 482;
496 -> 477;
496 -> 472;
497 -> 474;
497 -> 477;
497 -> 472;
498 -> 473;
498 -> 0;
498 -> 472;
499 -> 471;
499 -> 455;
500 -> 457;
500 -> 455;
501 -> 499;
501 -> 455;
502 -> 455;
503 -> 0;
503 -> 502;
503 -> 455;
504 -> 501;
504 -> 502;
504 -> 495;
504 -> 496;
504 -> 497;
504 -> 503;
504 -> 0;
504 -> 455;
505 -> 504;
505 -> 502;
506 -> 504;
506 -> 502;
507 -> 502;
508 -> 506;
508 -> 507;
509 -> 508;
509 -> 504;
509 -> 507;
510 -> 509;
510 -> 502;
511 -> 506;
511 -> 504;
511 -> 502;
512 -> 505;
512 -> 502;
513 -> 502;
514 -> 502;
515 -> 510;
515 -> 514;
516 -> 511;
516 -> 514;
517 -> 511;
517 -> 514;
518 -> 512;
518 -> 514;
519 -> 513;
519 -> 514;
520 -> 514;
521 -> 519;
521 -> 520;
522 -> 520;
523 -> 522;
523 -> 515;
523 -> 517;
523 -> 518;
523 -> 516;
523 -> 511;
523 -> 520;
524 -> 522;
524 -> 520;
525 -> 519;
525 -> 514;
526 -> 515;
526 -> 0;
526 -> 514;
527 -> 523;
530 -> 529;
532 -> 528;
532 -> 531;
533 -> 530;
533 -> 531;
534 -> 531;
535 -> 532;
535 -> 531;
536 -> 533;
536 -> 535;
537 -> 0;
537 -> 536;
538 -> 531;
539 -> 537;
539 -> 538;
539 -> 531;
540 -> 0;
540 -> 531;
541 -> 532;
541 -> 531;
542 -> 531;
543 -> 540;
543 -> 542;
544 -> 541;
544 -> 542;
545 -> 543;
545 -> 542;
546 -> 544;
546 -> 542;
547 -> 542;
548 -> 542;
549 -> 545;
549 -> 548;
550 -> 546;
550 -> 548;
551 -> 547;
551 -> 548;
552 -> 547;
552 -> 548;
553 -> 547;
553 -> 548;
554 -> 549;
554 -> 548;
555 -> 551;
555 -> 548;
556 -> 552;
556 -> 548;
557 -> 550;
557 -> 548;
558 -> 548;
559 -> 554;
559 -> 558;
560 -> 555;
560 -> 558;
561 -> 556;
561 -> 558;
562 -> 557;
562 -> 558;
563 -> 553;
563 -> 558;
564 -> 559;
564 -> 558;
565 -> 560;
565 -> 558;
566 -> 561;
566 -> 558;
567 -> 562;
567 -> 558;
568 -> 558;
569 -> 568;
569 -> 564;
569 -> 565;
569 -> 566;
569 -> 567;
569 -> 558;
570 -> 568;
570 -> 558;
571 -> 570;
571 -> 569;
571 -> 558;
572 -> 553;
572 -> 548;
573 -> 550;
573 -> 553;
573 -> 548;
574 -> 549;
574 -> 0;
574 -> 548;
575 -> 547;
575 -> 531;
576 -> 533;
576 -> 531;
577 -> 575;
577 -> 531;
578 -> 531;
579 -> 0;
579 -> 578;
579 -> 531;
580 -> 577;
580 -> 578;
580 -> 571;
580 -> 572;
580 -> 573;
580 -> 579;
580 -> 523;
580 -> 531;
581 -> 578;
582 -> 578;
583 -> 578;
584 -> 582;
584 -> 583;
585 -> 583;
586 -> 584;
586 -> 585;
587 -> 585;
588 -> 587;
588 -> 585;
589 -> 584;
589 -> 583;
590 -> 580;
590 -> 0;
590 -> 583;
591 -> 580;
594 -> 593;
596 -> 592;
596 -> 595;
597 -> 594;
597 -> 595;
598 -> 595;
599 -> 596;
599 -> 595;
600 -> 597;
600 -> 599;
601 -> 0;
601 -> 600;
602 -> 595;
603 -> 601;
603 -> 602;
603 -> 595;
604 -> 0;
604 -> 595;
605 -> 596;
605 -> 595;
606 -> 595;
607 -> 604;
607 -> 606;
608 -> 605;
608 -> 606;
609 -> 607;
609 -> 606;
610 -> 608;
610 -> 606;
611 -> 606;
612 -> 606;
613 -> 609;
613 -> 612;
614 -> 610;
614 -> 612;
615 -> 611;
615 -> 612;
616 -> 611;
616 -> 612;
617 -> 611;
617 -> 612;
618 -> 613;
618 -> 612;
619 -> 615;
619 -> 612;
620 -> 616;
620 -> 612;
621 -> 614;
621 -> 612;
622 -> 612;
623 -> 618;
623 -> 622;
624 -> 619;
624 -> 622;
625 -> 620;
625 -> 622;
626 -> 621;
626 -> 622;
627 -> 617;
627 -> 622;
628 -> 623;
628 -> 622;
629 -> 624;
629 -> 622;
630 -> 625;
630 -> 622;
631 -> 626;
631 -> 622;
632 -> 622;
633 -> 632;
633 -> 628;
633 -> 629;
633 -> 630;
633 -> 631;
633 -> 622;
634 -> 632;
634 -> 622;
635 -> 634;
635 -> 633;
635 -> 622;
636 -> 617;
636 -> 612;
637 -> 614;
637 -> 617;
637 -> 612;
638 -> 613;
638 -> 0;
638 -> 612;
639 -> 611;
639 -> 595;
640 -> 597;
640 -> 595;
641 -> 639;
641 -> 595;
642 -> 595;
643 -> 0;
643 -> 642;
643 -> 595;
644 -> 641;
644 -> 642;
644 -> 635;
644 -> 636;
644 -> 637;
644 -> 643;
644 -> 580;
644 -> 595;
645 -> 642;
646 -> 642;
647 -> 642;
648 -> 646;
648 -> 647;
649 -> 647;
650 -> 648;
650 -> 649;
651 -> 649;
652 -> 651;
652 -> 649;
653 -> 648;
653 -> 647;
654 -> 644;
654 -> 0;
654 -> 647;
655 -> 644;
658 -> 657;
660 -> 656;
660 -> 659;
661 -> 658;
661 -> 659;
662 -> 0;
662 -> 659;
663 -> 660;
663 -> 659;
664 -> 659;
665 -> 662;
665 -> 664;
666 -> 663;
666 -> 664;
667 -> 665;
667 -> 664;
668 -> 666;
668 -> 664;
669 -> 664;
670 -> 664;
671 -> 667;
671 -> 670;
672 -> 668;
672 -> 670;
673 -> 669;
673 -> 670;
674 -> 669;
674 -> 670;
675 -> 669;
675 -> 670;
676 -> 671;
676 -> 670;
677 -> 673;
677 -> 670;
678 -> 674;
678 -> 670;
679 -> 672;
679 -> 670;
680 -> 670;
681 -> 676;
681 -> 680;
682 -> 677;
682 -> 680;
683 -> 678;
683 -> 680;
684 -> 679;
684 -> 680;
685 -> 675;
685 -> 680;
686 -> 681;
686 -> 680;
687 -> 682;
687 -> 680;
688 -> 683;
688 -> 680;
689 -> 684;
689 -> 680;
690 -> 680;
691 -> 690;
691 -> 686;
691 -> 687;
691 -> 688;
691 -> 689;
691 -> 680;
692 -> 690;
692 -> 680;
693 -> 692;
693 -> 691;
693 -> 680;
694 -> 675;
694 -> 670;
695 -> 672;
695 -> 675;
695 -> 670;
696 -> 671;
696 -> 0;
696 -> 670;
697 -> 669;
697 -> 659;
698 -> 661;
698 -> 659;
699 -> 697;
699 -> 659;
700 -> 659;
701 -> 0;
701 -> 700;
701 -> 659;
702 -> 699;
702 -> 700;
702 -> 693;
702 -> 694;
702 -> 695;
702 -> 701;
702 -> 644;
702 -> 659;
703 -> 700;
704 -> 700;
705 -> 700;
706 -> 704;
706 -> 705;
707 -> 705;
708 -> 706;
708 -> 707;
709 -> 707;
710 -> 709;
710 -> 707;
711 -> 706;
711 -> 705;
712 -> 702;
712 -> 0;
712 -> 705;
713 -> 702;
716 -> 715;
718 -> 714;
718 -> 717;
719 -> 716;
719 -> 717;
720 -> 0;
720 -> 717;
721 -> 718;
721 -> 717;
722 -> 717;
723 -> 720;
723 -> 722;
724 -> 721;
724 -> 722;
725 -> 723;
725 -> 722;
726 -> 724;
726 -> 722;
727 -> 722;
728 -> 722;
729 -> 725;
729 -> 728;
730 -> 726;
730 -> 728;
731 -> 727;
731 -> 728;
732 -> 727;
732 -> 728;
733 -> 727;
733 -> 728;
734 -> 729;
734 -> 728;
735 -> 731;
735 -> 728;
736 -> 732;
736 -> 728;
737 -> 730;
737 -> 728;
738 -> 728;
739 -> 734;
739 -> 738;
740 -> 735;
740 -> 738;
741 -> 736;
741 -> 738;
742 -> 737;
742 -> 738;
743 -> 733;
743 -> 738;
744 -> 739;
744 -> 738;
745 -> 740;
745 -> 738;
746 -> 741;
746 -> 738;
747 -> 742;
747 -> 738;
748 -> 738;
749 -> 748;
749 -> 744;
749 -> 745;
749 -> 746;
749 -> 747;
749 -> 738;
750 -> 748;
750 -> 738;
751 -> 750;
751 -> 749;
751 -> 738;
752 -> 733;
752 -> 728;
753 -> 730;
753 -> 733;
753 -> 728;
754 -> 729;
754 -> 0;
754 -> 728;
755 -> 727;
755 -> 717;
756 -> 719;
756 -> 717;
757 -> 755;
757 -> 717;
758 -> 717;
759 -> 0;
759 -> 758;
759 -> 717;
760 -> 757;
760 -> 758;
760 -> 751;
760 -> 752;
760 -> 753;
760 -> 759;
760 -> 702;
760 -> 717;
761 -> 758;
762 -> 758;
763 -> 758;
764 -> 762;
764 -> 763;
765 -> 763;
766 -> 764;
766 -> 765;
767 -> 765;
768 -> 767;
768 -> 765;
769 -> 764;
769 -> 763;
770 -> 760;
770 -> 0;
770 -> 763;
771 -> 760;
772 -> 0;
774 -> 773;
776 -> 772;
776 -> 775;
777 -> 774;
777 -> 775;
778 -> 0;
778 -> 775;
779 -> 776;
779 -> 775;
780 -> 775;
781 -> 778;
781 -> 780;
782 -> 779;
782 -> 780;
783 -> 781;
783 -> 780;
784 -> 782;
784 -> 780;
785 -> 780;
786 -> 780;
787 -> 783;
787 -> 786;
788 -> 784;
788 -> 786;
789 -> 785;
789 -> 786;
790 -> 785;
790 -> 786;
791 -> 785;
791 -> 786;
792 -> 787;
792 -> 786;
793 -> 789;
793 -> 786;
794 -> 790;
794 -> 786;
795 -> 788;
795 -> 786;
796 -> 786;
797 -> 792;
797 -> 796;
798 -> 793;
798 -> 796;
799 -> 794;
799 -> 796;
800 -> 795;
800 -> 796;
801 -> 791;
801 -> 796;
802 -> 797;
802 -> 796;
803 -> 798;
803 -> 796;
804 -> 799;
804 -> 796;
805 -> 800;
805 -> 796;
806 -> 796;
807 -> 806;
807 -> 802;
807 -> 803;
807 -> 804;
807 -> 805;
807 -> 796;
808 -> 806;
808 -> 796;
809 -> 808;
809 -> 807;
809 -> 796;
810 -> 791;
810 -> 786;
811 -> 788;
811 -> 791;
811 -> 786;
812 -> 787;
812 -> 0;
812 -> 786;
813 -> 785;
813 -> 775;
814 -> 777;
814 -> 775;
815 -> 813;
815 -> 775;
816 -> 775;
817 -> 0;
817 -> 816;
817 -> 775;
818 -> 815;
818 -> 816;
818 -> 809;
818 -> 810;
818 -> 811;
818 -> 817;
818 -> 760;
818 -> 775;
819 -> 816;
820 -> 816;
821 -> 816;
822 -> 820;
822 -> 821;
823 -> 821;
824 -> 822;
824 -> 823;
825 -> 823;
826 -> 825;
826 -> 823;
827 -> 822;
827 -> 821;
828 -> 818;
828 -> 0;
828 -> 821;
829 -> 818;
832 -> 267;
832 -> 831;
833 -> 831;
834 -> 832;
834 -> 831;
835 -> 833;
835 -> 834;
835 -> 260;
835 -> 261;
835 -> 262;
835 -> 831;
837 -> 316;
837 -> 836;
838 -> 836;
839 -> 837;
839 -> 836;
840 -> 838;
840 -> 839;
840 -> 309;
840 -> 310;
840 -> 311;
840 -> 836;
842 -> 365;
842 -> 841;
843 -> 841;
844 -> 842;
844 -> 841;
845 -> 843;
845 -> 844;
845 -> 358;
845 -> 359;
845 -> 360;
845 -> 841;
847 -> 408;
847 -> 846;
848 -> 846;
849 -> 847;
849 -> 846;
850 -> 848;
850 -> 849;
850 -> 401;
850 -> 402;
850 -> 403;
850 -> 846;
852 -> 451;
852 -> 851;
853 -> 851;
854 -> 852;
854 -> 851;
855 -> 853;
855 -> 854;
855 -> 444;
855 -> 445;
855 -> 446;
855 -> 851;
857 -> 527;
857 -> 856;
858 -> 856;
859 -> 857;
859 -> 856;
860 -> 858;
860 -> 859;
860 -> 818;
860 -> 856;
862 -> 591;
862 -> 861;
863 -> 861;
864 -> 862;
864 -> 861;
865 -> 863;
865 -> 864;
865 -> 860;
865 -> 861;
867 -> 655;
867 -> 866;
868 -> 866;
869 -> 867;
869 -> 866;
870 -> 868;
870 -> 869;
870 -> 865;
870 -> 866;
872 -> 713;
872 -> 871;
873 -> 871;
874 -> 872;
874 -> 871;
875 -> 873;
875 -> 874;
875 -> 870;
875 -> 871;
877 -> 771;
877 -> 876;
878 -> 876;
879 -> 877;
879 -> 876;
880 -> 878;
880 -> 879;
880 -> 875;
880 -> 876;
882 -> 829;
882 -> 881;
883 -> 881;
884 -> 882;
884 -> 881;
885 -> 883;
885 -> 884;
885 -> 880;
885 -> 881;
886 -> 210;
886 -> 209;
887 -> 211;
887 -> 209;
888 -> 212;
888 -> 209;
889 -> 209;
890 -> 209;
891 -> 886;
891 -> 890;
892 -> 887;
892 -> 890;
893 -> 888;
893 -> 890;
894 -> 889;
894 -> 890;
895 -> 891;
895 -> 890;
896 -> 892;
896 -> 890;
897 -> 893;
897 -> 890;
898 -> 890;
899 -> 895;
899 -> 898;
900 -> 896;
900 -> 898;
901 -> 897;
901 -> 898;
902 -> 899;
902 -> 898;
903 -> 900;
903 -> 898;
904 -> 898;
905 -> 902;
905 -> 904;
906 -> 903;
906 -> 904;
907 -> 905;
907 -> 904;
908 -> 0;
908 -> 904;
909 -> 904;
910 -> 906;
910 -> 904;
911 -> 907;
911 -> 910;
911 -> 904;
913 -> 912;
916 -> 915;
918 -> 917;
929 -> 920;
929 -> 919;
930 -> 921;
930 -> 919;
931 -> 922;
931 -> 919;
932 -> 923;
932 -> 919;
933 -> 924;
933 -> 919;
934 -> 925;
934 -> 919;
935 -> 926;
935 -> 919;
936 -> 927;
936 -> 919;
937 -> 928;
937 -> 919;
938 -> 919;
940 -> 939;
941 -> 0;
941 -> 898;
942 -> 941;
942 -> 901;
942 -> 898;
943 -> 898;
944 -> 898;
945 -> 911;
945 -> 944;
946 -> 942;
946 -> 944;
947 -> 943;
947 -> 944;
948 -> 943;
948 -> 944;
949 -> 943;
949 -> 944;
950 -> 945;
950 -> 944;
951 -> 944;
952 -> 950;
952 -> 951;
953 -> 949;
953 -> 951;
954 -> 953;
954 -> 951;
955 -> 953;
955 -> 951;
956 -> 0;
958 -> 957;
960 -> 959;
961 -> 960;
962 -> 952;
962 -> 951;
963 -> 951;
964 -> 951;
965 -> 962;
965 -> 964;
966 -> 963;
966 -> 964;
967 -> 966;
967 -> 964;
968 -> 966;
968 -> 964;
969 -> 966;
969 -> 964;
970 -> 966;
970 -> 964;
971 -> 966;
971 -> 964;
972 -> 966;
972 -> 964;
973 -> 966;
973 -> 964;
974 -> 966;
974 -> 964;
975 -> 965;
975 -> 966;
975 -> 964;
976 -> 964;
977 -> 976;
977 -> 966;
977 -> 964;
978 -> 964;
979 -> 978;
979 -> 966;
979 -> 964;
980 -> 965;
980 -> 911;
980 -> 966;
980 -> 964;
981 -> 964;
982 -> 981;
982 -> 966;
982 -> 964;
983 -> 961;
983 -> 960;
983 -> 964;
984 -> 983;
984 -> 966;
984 -> 964;
985 -> 964;
986 -> 985;
986 -> 966;
986 -> 964;
987 -> 963;
987 -> 953;
987 -> 951;
988 -> 949;
988 -> 944;
989 -> 949;
989 -> 944;
990 -> 949;
990 -> 944;
991 -> 949;
991 -> 944;
992 -> 949;
992 -> 944;
993 -> 949;
993 -> 944;
994 -> 949;
994 -> 944;
995 -> 949;
995 -> 944;
996 -> 949;
996 -> 944;
997 -> 949;
997 -> 944;
998 -> 944;
999 -> 998;
999 -> 944;
1000 -> 999;
1000 -> 949;
1000 -> 944;
1001 -> 944;
1002 -> 1001;
1002 -> 944;
1003 -> 1002;
1003 -> 949;
1003 -> 944;
1004 -> 949;
1004 -> 944;
1005 -> 949;
1005 -> 944;
1006 -> 944;
1007 -> 946;
1007 -> 1006;
1007 -> 944;
1008 -> 946;
1008 -> 949;
1008 -> 944;
1009 -> 944;
1010 -> 1009;
1010 -> 949;
1010 -> 944;
1011 -> 944;
1012 -> 1011;
1012 -> 949;
1012 -> 944;
1015 -> 1013;
1015 -> 1014;
1016 -> 1015;
1018 -> 1017;
1019 -> 944;
1020 -> 944;
1021 -> 1019;
1021 -> 1020;
1022 -> 1021;
1022 -> 1020;
1023 -> 1021;
1023 -> 1020;
1024 -> 1021;
1024 -> 1020;
1025 -> 1020;
1026 -> 1025;
1026 -> 1021;
1026 -> 1020;
1027 -> 1020;
1028 -> 1027;
1028 -> 1021;
1028 -> 1020;
1029 -> 1016;
1029 -> 1015;
1029 -> 1020;
1030 -> 1029;
1030 -> 1021;
1030 -> 1020;
1031 -> 1019;
1031 -> 949;
1031 -> 944;
1032 -> 949;
1032 -> 944;
1033 -> 947;
1033 -> 949;
1033 -> 944;
1034 -> 948;
1034 -> 949;
1034 -> 944;
1035 -> 943;
1035 -> 890;
1036 -> 1035;
1036 -> 890;
1037 -> 890;
1038 -> 1036;
1038 -> 1037;
1039 -> 0;
1040 -> 1038;
1040 -> 1037;
1041 -> 1037;
1042 -> 1037;
1043 -> 1040;
1043 -> 1042;
1044 -> 1041;
1044 -> 1042;
1045 -> 1041;
1045 -> 1042;
1046 -> 1041;
1046 -> 1042;
1047 -> 1041;
1047 -> 1042;
1048 -> 1041;
1048 -> 1042;
1051 -> 1049;
1051 -> 1050;
1052 -> 1051;
1053 -> 1043;
1053 -> 1042;
1054 -> 1046;
1054 -> 1042;
1055 -> 1044;
1055 -> 1042;
1056 -> 1045;
1056 -> 1042;
1057 -> 1042;
1058 -> 1042;
1059 -> 1047;
1059 -> 1042;
1060 -> 1042;
1061 -> 1053;
1061 -> 1060;
1062 -> 1054;
1062 -> 1060;
1063 -> 1055;
1063 -> 1060;
1064 -> 1056;
1064 -> 1060;
1065 -> 1057;
1065 -> 1060;
1066 -> 1058;
1066 -> 1060;
1067 -> 1059;
1067 -> 1060;
1068 -> 1048;
1068 -> 1060;
1069 -> 1068;
1069 -> 1060;
1070 -> 1068;
1070 -> 1060;
1071 -> 1068;
1071 -> 1060;
1072 -> 1068;
1072 -> 1060;
1073 -> 1068;
1073 -> 1060;
1074 -> 1068;
1074 -> 1060;
1075 -> 1068;
1075 -> 1060;
1076 -> 1068;
1076 -> 1060;
1077 -> 1068;
1077 -> 1060;
1078 -> 1068;
1078 -> 1060;
1079 -> 1068;
1079 -> 1060;
1080 -> 1068;
1080 -> 1060;
1081 -> 1068;
1081 -> 1060;
1082 -> 1061;
1082 -> 1068;
1082 -> 1060;
1083 -> 1062;
1083 -> 1068;
1083 -> 1060;
1084 -> 1065;
1084 -> 1068;
1084 -> 1060;
1085 -> 1067;
1085 -> 1068;
1085 -> 1060;
1086 -> 1060;
1087 -> 1086;
1087 -> 1068;
1087 -> 1060;
1088 -> 1060;
1089 -> 1063;
1089 -> 1088;
1089 -> 1060;
1090 -> 1089;
1090 -> 1068;
1090 -> 1060;
1091 -> 1060;
1092 -> 1068;
1092 -> 1091;
1093 -> 1092;
1093 -> 1090;
1093 -> 1091;
1094 -> 1093;
1094 -> 1060;
1095 -> 1094;
1095 -> 1065;
1095 -> 1060;
1096 -> 1095;
1097 -> 1096;
1097 -> 1068;
1097 -> 1095;
1098 -> 1095;
1099 -> 1098;
1099 -> 1068;
1099 -> 1095;
1100 -> 1060;
1101 -> 1068;
1101 -> 1100;
1102 -> 1101;
1102 -> 1090;
1102 -> 1100;
1103 -> 1102;
1103 -> 1060;
1104 -> 1066;
1104 -> 1103;
1104 -> 1060;
1105 -> 1104;
1105 -> 1067;
1105 -> 1041;
1105 -> 1060;
1106 -> 1105;
1107 -> 1068;
1107 -> 1106;
1108 -> 1106;
1109 -> 1106;
1110 -> 1107;
1110 -> 1082;
1110 -> 987;
1110 -> 1109;
1111 -> 1110;
1111 -> 975;
1111 -> 1109;
1112 -> 1111;
1112 -> 1106;
1113 -> 1112;
1113 -> 1106;
1114 -> 1113;
1114 -> 1107;
1114 -> 1106;
1115 -> 1107;
1115 -> 1082;
1115 -> 1106;
1116 -> 1107;
1116 -> 1083;
1116 -> 1106;
1117 -> 1106;
1118 -> 1117;
1118 -> 1112;
1118 -> 1106;
1119 -> 1116;
1119 -> 1118;
1120 -> 1118;
1121 -> 1119;
1121 -> 1120;
1122 -> 1115;
1122 -> 1120;
1123 -> 914;
1123 -> 1120;
1124 -> 1121;
1124 -> 1122;
1124 -> 1120;
1125 -> 1122;
1125 -> 1124;
1125 -> 1120;
1126 -> 1122;
1126 -> 987;
1126 -> 955;
1126 -> 1008;
1126 -> 1124;
1126 -> 1010;
1126 -> 1012;
1126 -> 992;
1126 -> 1031;
1126 -> 1033;
1126 -> 1034;
1126 -> 996;
1126 -> 997;
1126 -> 1000;
1126 -> 1003;
1126 -> 1004;
1126 -> 1032;
1126 -> 975;
1126 -> 977;
1126 -> 979;
1126 -> 980;
1126 -> 984;
1126 -> 972;
1126 -> 986;
1126 -> 982;
1126 -> 911;
1126 -> 999;
1126 -> 1002;
1126 -> 0;
1126 -> 1009;
1126 -> 1011;
1126 -> 1026;
1126 -> 1028;
1126 -> 1030;
1126 -> 1029;
1126 -> 1027;
1126 -> 1025;
1126 -> 981;
1126 -> 983;
1126 -> 1125;
1127 -> 1125;
1128 -> 1126;
1128 -> 1127;
1129 -> 1127;
1130 -> 1128;
1130 -> 1126;
1130 -> 1129;
1131 -> 1130;
1131 -> 1126;
1131 -> 1129;
1132 -> 1127;
1133 -> 1127;
1134 -> 1133;
1134 -> 1128;
1134 -> 1127;
1135 -> 1126;
1135 -> 1127;
1136 -> 1135;
1136 -> 1126;
1136 -> 1127;
1137 -> 1126;
1137 -> 1136;
1137 -> 1131;
1137 -> 1134;
1137 -> 1125;
1138 -> 1126;
1138 -> 1127;
1139 -> 1138;
1139 -> 1137;
1139 -> 1127;
1140 -> 1126;
1140 -> 1127;
1141 -> 1140;
1141 -> 1139;
1141 -> 1127;
1142 -> 1126;
1142 -> 1127;
1143 -> 1126;
1143 -> 1127;
1144 -> 1143;
1144 -> 1141;
1144 -> 1142;
1144 -> 1127;
1145 -> 1144;
1145 -> 1143;
1145 -> 1127;
1146 -> 1126;
1146 -> 1127;
1147 -> 1146;
1147 -> 1141;
1147 -> 1127;
1148 -> 1126;
1148 -> 1147;
1148 -> 1141;
1148 -> 1145;
1148 -> 1125;
1149 -> 1126;
1149 -> 1127;
1150 -> 1126;
1150 -> 1127;
1151 -> 1149;
1151 -> 1150;
1151 -> 1148;
1151 -> 1127;
1152 -> 1127;
1153 -> 1151;
1153 -> 1152;
1153 -> 1127;
1154 -> 1151;
1154 -> 1150;
1154 -> 1148;
1154 -> 1127;
1155 -> 1151;
1155 -> 1150;
1155 -> 1153;
1156 -> 1125;
1157 -> 1122;
1157 -> 1156;
1158 -> 1157;
1158 -> 1155;
1158 -> 1156;
1159 -> 1156;
1160 -> 1157;
1160 -> 1158;
1160 -> 1159;
1161 -> 1160;
1161 -> 1158;
1161 -> 1159;
1162 -> 1161;
1162 -> 1156;
1163 -> 1156;
1164 -> 1157;
1164 -> 1158;
1164 -> 1156;
1165 -> 1156;
1166 -> 1162;
1166 -> 1165;
1167 -> 1163;
1167 -> 1165;
1168 -> 1164;
1168 -> 1165;
1169 -> 1157;
1169 -> 1165;
1170 -> 1167;
1170 -> 1165;
1171 -> 1165;
1172 -> 1171;
1173 -> 1169;
1173 -> 1172;
1174 -> 1172;
1175 -> 1173;
1175 -> 1158;
1175 -> 1174;
1176 -> 1172;
1177 -> 1172;
1178 -> 1177;
1178 -> 1173;
1178 -> 1172;
1179 -> 1171;
1180 -> 1171;
1181 -> 1169;
1181 -> 1158;
1181 -> 1180;
1182 -> 1181;
1182 -> 1158;
1182 -> 1180;
1183 -> 1180;
1184 -> 1181;
1184 -> 1183;
1185 -> 1184;
1185 -> 1158;
1185 -> 1183;
1186 -> 1185;
1187 -> 1184;
1187 -> 1186;
1188 -> 1187;
1188 -> 1158;
1188 -> 1186;
1189 -> 1188;
1189 -> 1185;
1190 -> 1185;
1191 -> 1184;
1191 -> 1158;
1191 -> 1175;
1191 -> 1190;
1191 -> 1185;
1192 -> 1184;
1192 -> 1158;
1192 -> 1175;
1192 -> 1178;
1192 -> 1185;
1193 -> 1184;
1193 -> 1158;
1193 -> 1185;
1194 -> 1184;
1194 -> 1158;
1194 -> 1175;
1194 -> 1178;
1194 -> 1185;
1195 -> 1184;
1195 -> 1158;
1195 -> 1185;
1196 -> 1194;
1196 -> 1185;
1197 -> 1184;
1197 -> 1196;
1197 -> 1194;
1197 -> 1185;
1198 -> 1197;
1198 -> 1184;
1198 -> 1185;
1199 -> 1185;
1200 -> 1194;
1200 -> 1199;
1200 -> 1185;
1201 -> 1200;
1201 -> 1180;
1202 -> 1181;
1202 -> 1196;
1202 -> 1198;
1202 -> 1180;
1203 -> 1202;
1203 -> 1171;
1204 -> 1171;
1205 -> 1203;
1205 -> 1204;
1205 -> 1171;
1206 -> 1205;
1207 -> 1203;
1207 -> 1171;
1208 -> 1207;
1209 -> 1157;
1209 -> 1196;
1209 -> 1168;
1209 -> 1156;
1210 -> 1156;
1211 -> 1156;
1212 -> 1157;
1212 -> 1211;
1213 -> 1211;
1214 -> 1212;
1214 -> 1196;
1214 -> 1213;
1215 -> 1211;
1216 -> 1211;
1217 -> 1216;
1217 -> 1212;
1217 -> 1211;
1218 -> 1156;
1219 -> 1210;
1219 -> 1156;
1220 -> 1219;
1220 -> 1157;
1220 -> 1196;
1220 -> 1198;
1220 -> 1168;
1220 -> 1214;
1220 -> 1217;
1220 -> 1210;
1220 -> 1156;
1221 -> 1156;
1222 -> 1220;
1222 -> 1221;
1223 -> 1222;
1223 -> 1220;
1223 -> 1221;
1224 -> 1220;
1224 -> 1223;
1224 -> 1221;
1225 -> 1220;
1225 -> 1223;
1225 -> 1221;
1226 -> 1220;
1226 -> 1221;
1227 -> 1220;
1227 -> 1221;
1228 -> 0;
1228 -> 1226;
1228 -> 1221;
1229 -> 1226;
1229 -> 1221;
1230 -> 1221;
1231 -> 1229;
1231 -> 1230;
1232 -> 1227;
1232 -> 1230;
1233 -> 1231;
1233 -> 1230;
1234 -> 1233;
1234 -> 1232;
1234 -> 1225;
1234 -> 1228;
1234 -> 1230;
1235 -> 1230;
1236 -> 1234;
1236 -> 1235;
1237 -> 1234;
1237 -> 1235;
1238 -> 1234;
1238 -> 1235;
1239 -> 1234;
1239 -> 1235;
1240 -> 1236;
1240 -> 1235;
1241 -> 1237;
1241 -> 1235;
1242 -> 1238;
1242 -> 1235;
1243 -> 1239;
1243 -> 1234;
1243 -> 1240;
1243 -> 1241;
1243 -> 1242;
1243 -> 1235;
1244 -> 1243;
1245 -> 0;
1245 -> 1244;
1246 -> 1244;
1247 -> 1245;
1247 -> 1246;
1248 -> 1227;
1248 -> 1246;
1249 -> 1248;
1249 -> 1243;
1249 -> 1246;
1250 -> 1246;
1251 -> 1249;
1251 -> 1250;
1252 -> 1251;
1252 -> 0;
1252 -> 1250;
1253 -> 1252;
1253 -> 1247;
1253 -> 1246;
1254 -> 1243;
1254 -> 1253;
1255 -> 1253;
1256 -> 1254;
1256 -> 1255;
1257 -> 1254;
1257 -> 1255;
1258 -> 1227;
1258 -> 1243;
1258 -> 1255;
1259 -> 1256;
1259 -> 1018;
1259 -> 1255;
1261 -> 1260;
1262 -> 1260;
1263 -> 1256;
1263 -> 1255;
1264 -> 1263;
1264 -> 1258;
1264 -> 1243;
1264 -> 1255;
1265 -> 1255;
1266 -> 1264;
1266 -> 1265;
1267 -> 1266;
1267 -> 1265;
1268 -> 0;
1268 -> 1267;
1269 -> 1268;
1269 -> 0;
1269 -> 1255;
1270 -> 1243;
1270 -> 1268;
1270 -> 1269;
1271 -> 1269;
1272 -> 1270;
1272 -> 1271;
1273 -> 1272;
1273 -> 1271;
1274 -> 1273;
1275 -> 1243;
1275 -> 1268;
1275 -> 0;
1275 -> 1244;
1276 -> 1243;
1277 -> 1243;
1277 -> 1276;
1277 -> 1268;
1277 -> 1156;
1278 -> 1209;
1278 -> 1156;
1279 -> 1156;
1280 -> 1278;
1280 -> 1279;
1281 -> 1279;
1282 -> 1279;
1283 -> 1280;
1283 -> 1282;
1283 -> 1279;
1284 -> 1283;
1285 -> 1284;
1285 -> 1280;
1285 -> 1277;
1285 -> 1283;
1286 -> 1281;
1286 -> 1279;
1287 -> 1286;
1287 -> 1156;
1288 -> 1156;
1289 -> 1287;
1289 -> 1288;
1290 -> 1157;
1290 -> 1288;
1291 -> 1288;
1292 -> 1290;
1292 -> 1277;
1292 -> 1291;
1292 -> 1288;
1293 -> 1292;
1294 -> 1293;
1294 -> 1156;
1295 -> 1157;
1295 -> 1277;
1295 -> 1156;
1296 -> 1156;
1297 -> 1157;
1297 -> 1295;
1297 -> 1156;
1298 -> 1156;
1299 -> 1296;
1299 -> 1298;
1300 -> 1296;
1300 -> 1298;
1301 -> 1297;
1301 -> 1298;
1302 -> 1157;
1302 -> 1298;
1303 -> 1300;
1303 -> 1298;
1304 -> 1298;
1305 -> 1304;
1306 -> 1302;
1306 -> 1305;
1307 -> 1305;
1308 -> 1306;
1308 -> 1295;
1308 -> 1307;
1309 -> 1305;
1310 -> 1305;
1311 -> 1310;
1311 -> 1306;
1311 -> 1305;
1312 -> 1304;
1313 -> 1304;
1314 -> 1302;
1314 -> 1295;
1314 -> 1313;
1315 -> 1314;
1315 -> 1295;
1315 -> 1313;
1316 -> 1314;
1316 -> 1304;
1317 -> 1304;
1318 -> 1316;
1318 -> 1317;
1318 -> 1304;
1319 -> 1302;
1319 -> 1295;
1319 -> 1308;
1319 -> 1311;
1319 -> 1318;
1320 -> 1318;
1321 -> 1319;
1321 -> 1320;
1322 -> 1319;
1322 -> 1320;
1323 -> 1322;
1323 -> 1319;
1323 -> 1320;
1324 -> 1319;
1324 -> 1323;
1324 -> 1320;
1325 -> 1319;
1325 -> 1320;
1326 -> 1325;
1326 -> 1323;
1326 -> 1320;
1327 -> 1301;
1327 -> 1318;
1328 -> 1318;
1329 -> 1326;
1329 -> 1328;
1330 -> 1327;
1330 -> 1328;
1331 -> 1302;
1331 -> 1328;
1332 -> 1328;
1333 -> 1331;
1333 -> 1332;
1334 -> 1332;
1335 -> 1333;
1335 -> 1326;
1335 -> 1334;
1335 -> 1332;
1336 -> 1335;
1336 -> 1328;
1337 -> 1328;
1338 -> 1330;
1338 -> 1337;
1338 -> 1328;
1339 -> 1329;
1339 -> 1328;
1340 -> 1330;
1340 -> 1339;
1340 -> 1326;
1340 -> 1328;
1341 -> 1340;
1341 -> 1313;
1342 -> 1340;
1343 -> 1340;
1343 -> 1304;
1344 -> 1343;
1345 -> 1157;
1345 -> 1340;
1345 -> 1330;
1345 -> 1156;
1346 -> 1277;
1346 -> 1156;
1347 -> 1209;
1347 -> 1156;
1348 -> 1345;
1348 -> 1156;
1349 -> 1294;
1349 -> 1156;
1350 -> 1156;
1351 -> 1346;
1351 -> 1350;
1352 -> 1347;
1352 -> 1350;
1353 -> 1348;
1353 -> 1350;
1354 -> 1349;
1354 -> 1350;
1355 -> 1157;
1355 -> 1350;
1356 -> 1351;
1356 -> 1277;
1356 -> 0;
1356 -> 1350;
1357 -> 1352;
1357 -> 1340;
1357 -> 1311;
1357 -> 1330;
1357 -> 1350;
1358 -> 1353;
1358 -> 1357;
1358 -> 1350;
1359 -> 1350;
1360 -> 1351;
1360 -> 1277;
1360 -> 1350;
1361 -> 1351;
1361 -> 1277;
1361 -> 1360;
1362 -> 1351;
1362 -> 1277;
1362 -> 1361;
1363 -> 1361;
1364 -> 1362;
1364 -> 1363;
1365 -> 1364;
1365 -> 0;
1365 -> 1363;
1366 -> 1357;
1366 -> 1361;
1367 -> 1351;
1367 -> 1277;
1367 -> 1361;
1368 -> 1358;
1368 -> 1361;
1369 -> 1361;
1370 -> 1366;
1370 -> 1369;
1371 -> 1367;
1371 -> 1369;
1372 -> 1368;
1372 -> 1369;
1373 -> 0;
1374 -> 0;
1376 -> 1374;
1376 -> 1375;
1377 -> 1376;
1378 -> 1377;
1380 -> 1374;
1380 -> 1379;
1381 -> 1380;
1382 -> 1381;
1384 -> 1374;
1384 -> 1383;
1385 -> 1384;
1386 -> 1385;
1388 -> 1374;
1388 -> 1387;
1389 -> 1388;
1390 -> 1389;
1392 -> 1373;
1393 -> 1392;
1393 -> 1374;
1394 -> 1378;
1394 -> 1377;
1394 -> 1392;
1394 -> 1393;
1395 -> 1392;
1395 -> 1393;
1396 -> 1393;
1397 -> 1393;
1398 -> 1395;
1398 -> 1397;
1399 -> 1396;
1399 -> 1397;
1400 -> 1398;
1400 -> 1397;
1401 -> 1397;
1402 -> 1400;
1402 -> 1401;
1403 -> 1399;
1403 -> 1401;
1404 -> 1402;
1404 -> 1401;
1405 -> 1401;
1406 -> 1405;
1406 -> 1404;
1406 -> 1401;
1407 -> 1405;
1407 -> 1401;
1408 -> 1407;
1408 -> 1406;
1408 -> 1401;
1409 -> 1397;
1410 -> 1399;
1410 -> 1409;
1411 -> 1409;
1412 -> 1410;
1412 -> 1411;
1413 -> 1412;
1413 -> 1408;
1413 -> 1411;
1414 -> 1413;
1414 -> 1409;
1415 -> 1409;
1416 -> 1414;
1416 -> 1415;
1417 -> 1416;
1417 -> 1415;
1418 -> 1417;
1419 -> 1418;
1419 -> 1397;
1420 -> 1419;
1420 -> 1399;
1420 -> 1397;
1421 -> 1399;
1421 -> 1408;
1421 -> 0;
1421 -> 1397;
1422 -> 1421;
1422 -> 1399;
1422 -> 1397;
1423 -> 1396;
1423 -> 1394;
1423 -> 1393;
1425 -> 1382;
1425 -> 1381;
1425 -> 1392;
1425 -> 1393;
1426 -> 1392;
1426 -> 1393;
1427 -> 829;
1427 -> 1393;
1428 -> 1393;
1429 -> 1393;
1430 -> 1426;
1430 -> 1429;
1431 -> 1427;
1431 -> 1429;
1432 -> 1427;
1432 -> 1429;
1433 -> 1428;
1433 -> 1429;
1434 -> 1430;
1434 -> 1429;
1435 -> 1429;
1436 -> 1434;
1436 -> 1435;
1437 -> 1433;
1437 -> 1435;
1438 -> 1436;
1438 -> 1435;
1439 -> 1435;
1440 -> 1438;
1440 -> 1439;
1441 -> 1437;
1441 -> 1439;
1442 -> 1440;
1442 -> 1439;
1443 -> 1439;
1444 -> 1443;
1444 -> 1442;
1444 -> 1439;
1445 -> 1443;
1445 -> 1439;
1446 -> 1445;
1446 -> 1444;
1446 -> 1439;
1447 -> 1435;
1448 -> 1437;
1448 -> 1447;
1449 -> 1447;
1450 -> 1448;
1450 -> 1449;
1451 -> 1450;
1451 -> 1446;
1451 -> 1449;
1452 -> 1451;
1452 -> 1447;
1453 -> 1447;
1454 -> 1452;
1454 -> 1453;
1455 -> 1454;
1455 -> 1453;
1456 -> 1455;
1457 -> 1456;
1457 -> 1435;
1458 -> 1457;
1458 -> 1437;
1458 -> 1435;
1459 -> 1437;
1459 -> 1446;
1459 -> 0;
1459 -> 1435;
1460 -> 1459;
1460 -> 1437;
1460 -> 1435;
1461 -> 1433;
1461 -> 1429;
1462 -> 1433;
1462 -> 1429;
1463 -> 1429;
1464 -> 1431;
1464 -> 1463;
1464 -> 1429;
1465 -> 1431;
1465 -> 1464;
1466 -> 1433;
1466 -> 1465;
1466 -> 1446;
1466 -> 1458;
1466 -> 1460;
1466 -> 1461;
1466 -> 1462;
1466 -> 885;
1466 -> 1464;
1467 -> 1431;
1467 -> 1433;
1467 -> 1464;
1468 -> 1429;
1469 -> 1432;
1469 -> 1468;
1469 -> 1429;
1470 -> 1432;
1470 -> 1469;
1471 -> 1433;
1471 -> 1470;
1471 -> 1466;
1471 -> 1467;
1471 -> 1469;
1472 -> 1432;
1472 -> 1433;
1472 -> 1469;
1473 -> 1428;
1473 -> 1425;
1473 -> 1393;
1474 -> 1386;
1474 -> 1385;
1474 -> 1392;
1474 -> 1393;
1475 -> 1392;
1475 -> 1393;
1476 -> 1393;
1477 -> 408;
1477 -> 1393;
1478 -> 1393;
1479 -> 1475;
1479 -> 1478;
1480 -> 1476;
1480 -> 1478;
1481 -> 1477;
1481 -> 1478;
1482 -> 1476;
1482 -> 1478;
1483 -> 1479;
1483 -> 1478;
1484 -> 1478;
1485 -> 1483;
1485 -> 1484;
1486 -> 1482;
1486 -> 1484;
1487 -> 1485;
1487 -> 1484;
1488 -> 1484;
1489 -> 1487;
1489 -> 1488;
1490 -> 1486;
1490 -> 1488;
1491 -> 1489;
1491 -> 1488;
1492 -> 1488;
1493 -> 1492;
1493 -> 1491;
1493 -> 1488;
1494 -> 1492;
1494 -> 1488;
1495 -> 1494;
1495 -> 1493;
1495 -> 1488;
1496 -> 1484;
1497 -> 1486;
1497 -> 1496;
1498 -> 1496;
1499 -> 1497;
1499 -> 1498;
1500 -> 1499;
1500 -> 1495;
1500 -> 1498;
1501 -> 1500;
1501 -> 1496;
1502 -> 1496;
1503 -> 1501;
1503 -> 1502;
1504 -> 1503;
1504 -> 1502;
1505 -> 1504;
1506 -> 1505;
1506 -> 1484;
1507 -> 1506;
1507 -> 1486;
1507 -> 1484;
1508 -> 1486;
1508 -> 1495;
1508 -> 0;
1508 -> 1484;
1509 -> 1508;
1509 -> 1486;
1509 -> 1484;
1510 -> 1482;
1510 -> 1478;
1511 -> 1482;
1511 -> 1478;
1512 -> 1478;
1513 -> 1480;
1513 -> 1512;
1513 -> 1478;
1514 -> 1478;
1515 -> 1481;
1515 -> 1514;
1515 -> 1478;
1516 -> 1481;
1516 -> 1515;
1517 -> 1482;
1517 -> 1516;
1517 -> 1495;
1517 -> 1507;
1517 -> 1509;
1517 -> 1510;
1517 -> 1511;
1517 -> 850;
1517 -> 1515;
1518 -> 1481;
1518 -> 1482;
1518 -> 1515;
1519 -> 1476;
1519 -> 1474;
1519 -> 1393;
1520 -> 1390;
1520 -> 1389;
1520 -> 1392;
1520 -> 1393;
1521 -> 1392;
1521 -> 1393;
1522 -> 1393;
1523 -> 267;
1523 -> 1393;
1524 -> 1393;
1525 -> 1521;
1525 -> 1524;
1526 -> 1522;
1526 -> 1524;
1527 -> 1523;
1527 -> 1524;
1528 -> 1522;
1528 -> 1524;
1529 -> 1525;
1529 -> 1524;
1530 -> 1524;
1531 -> 1529;
1531 -> 1530;
1532 -> 1528;
1532 -> 1530;
1533 -> 1531;
1533 -> 1530;
1534 -> 1530;
1535 -> 1533;
1535 -> 1534;
1536 -> 1532;
1536 -> 1534;
1537 -> 1535;
1537 -> 1534;
1538 -> 1534;
1539 -> 1538;
1539 -> 1537;
1539 -> 1534;
1540 -> 1538;
1540 -> 1534;
1541 -> 1540;
1541 -> 1539;
1541 -> 1534;
1542 -> 1530;
1543 -> 1532;
1543 -> 1542;
1544 -> 1542;
1545 -> 1543;
1545 -> 1544;
1546 -> 1545;
1546 -> 1541;
1546 -> 1544;
1547 -> 1546;
1547 -> 1542;
1548 -> 1542;
1549 -> 1547;
1549 -> 1548;
1550 -> 1549;
1550 -> 1548;
1551 -> 1550;
1552 -> 1551;
1552 -> 1530;
1553 -> 1552;
1553 -> 1532;
1553 -> 1530;
1554 -> 1532;
1554 -> 1541;
1554 -> 0;
1554 -> 1530;
1555 -> 1554;
1555 -> 1532;
1555 -> 1530;
1556 -> 1528;
1556 -> 1524;
1557 -> 1528;
1557 -> 1524;
1558 -> 1524;
1559 -> 1526;
1559 -> 1558;
1559 -> 1524;
1560 -> 1524;
1561 -> 1527;
1561 -> 1560;
1561 -> 1524;
1562 -> 1527;
1562 -> 1561;
1563 -> 1528;
1563 -> 1562;
1563 -> 1541;
1563 -> 1553;
1563 -> 1555;
1563 -> 1556;
1563 -> 1557;
1563 -> 835;
1563 -> 1561;
1564 -> 1527;
1564 -> 1528;
1564 -> 1561;
1565 -> 1522;
1565 -> 1520;
1565 -> 1393;
1566 -> 1378;
1566 -> 1377;
1566 -> 1393;
1567 -> 1396;
1567 -> 1397;
1568 -> 1567;
1568 -> 1397;
1569 -> 1568;
1569 -> 1401;
1570 -> 1569;
1570 -> 1401;
1571 -> 1405;
1571 -> 1570;
1571 -> 1401;
1572 -> 1407;
1572 -> 1571;
1572 -> 1401;
1573 -> 1412;
1573 -> 1572;
1573 -> 1411;
1574 -> 1573;
1574 -> 1409;
1575 -> 1574;
1575 -> 1415;
1576 -> 1575;
1576 -> 1415;
1577 -> 1576;
1578 -> 1577;
1578 -> 1397;
1579 -> 1578;
1579 -> 1399;
1579 -> 1397;
1580 -> 1399;
1580 -> 1572;
1580 -> 0;
1580 -> 1397;
1581 -> 1580;
1581 -> 1399;
1581 -> 1397;
1582 -> 1396;
1582 -> 1566;
1582 -> 1393;
1583 -> 1382;
1583 -> 1381;
1583 -> 1393;
1584 -> 1428;
1584 -> 1429;
1585 -> 1584;
1585 -> 1429;
1586 -> 1585;
1586 -> 1435;
1587 -> 1586;
1587 -> 1435;
1588 -> 1587;
1588 -> 1439;
1589 -> 1588;
1589 -> 1439;
1590 -> 1443;
1590 -> 1589;
1590 -> 1439;
1591 -> 1445;
1591 -> 1590;
1591 -> 1439;
1592 -> 1450;
1592 -> 1591;
1592 -> 1449;
1593 -> 1592;
1593 -> 1447;
1594 -> 1593;
1594 -> 1453;
1595 -> 1594;
1595 -> 1453;
1596 -> 1595;
1597 -> 1596;
1597 -> 1435;
1598 -> 1597;
1598 -> 1437;
1598 -> 1435;
1599 -> 1437;
1599 -> 1591;
1599 -> 0;
1599 -> 1435;
1600 -> 1599;
1600 -> 1437;
1600 -> 1435;
1601 -> 1433;
1601 -> 1465;
1601 -> 1591;
1601 -> 1598;
1601 -> 1600;
1601 -> 1461;
1601 -> 1462;
1601 -> 1471;
1601 -> 1472;
1601 -> 1464;
1602 -> 1428;
1602 -> 1583;
1602 -> 1393;
1603 -> 1386;
1603 -> 1385;
1603 -> 1393;
1604 -> 1476;
1604 -> 1478;
1605 -> 1604;
1605 -> 1478;
1606 -> 1605;
1606 -> 1484;
1607 -> 1606;
1607 -> 1484;
1608 -> 1607;
1608 -> 1488;
1609 -> 1608;
1609 -> 1488;
1610 -> 1492;
1610 -> 1609;
1610 -> 1488;
1611 -> 1494;
1611 -> 1610;
1611 -> 1488;
1612 -> 1499;
1612 -> 1611;
1612 -> 1498;
1613 -> 1612;
1613 -> 1496;
1614 -> 1613;
1614 -> 1502;
1615 -> 1614;
1615 -> 1502;
1616 -> 1615;
1617 -> 1616;
1617 -> 1484;
1618 -> 1617;
1618 -> 1486;
1618 -> 1484;
1619 -> 1486;
1619 -> 1611;
1619 -> 0;
1619 -> 1484;
1620 -> 1619;
1620 -> 1486;
1620 -> 1484;
1621 -> 1482;
1621 -> 1516;
1621 -> 1611;
1621 -> 1618;
1621 -> 1620;
1621 -> 1510;
1621 -> 1511;
1621 -> 1517;
1621 -> 1518;
1621 -> 1515;
1622 -> 1476;
1622 -> 1603;
1622 -> 1393;
1623 -> 1390;
1623 -> 1389;
1623 -> 1393;
1624 -> 1522;
1624 -> 1524;
1625 -> 1624;
1625 -> 1524;
1626 -> 1625;
1626 -> 1530;
1627 -> 1626;
1627 -> 1530;
1628 -> 1627;
1628 -> 1534;
1629 -> 1628;
1629 -> 1534;
1630 -> 1538;
1630 -> 1629;
1630 -> 1534;
1631 -> 1540;
1631 -> 1630;
1631 -> 1534;
1632 -> 1545;
1632 -> 1631;
1632 -> 1544;
1633 -> 1632;
1633 -> 1542;
1634 -> 1633;
1634 -> 1548;
1635 -> 1634;
1635 -> 1548;
1636 -> 1635;
1637 -> 1636;
1637 -> 1530;
1638 -> 1637;
1638 -> 1532;
1638 -> 1530;
1639 -> 1532;
1639 -> 1631;
1639 -> 0;
1639 -> 1530;
1640 -> 1639;
1640 -> 1532;
1640 -> 1530;
1641 -> 1528;
1641 -> 1562;
1641 -> 1631;
1641 -> 1638;
1641 -> 1640;
1641 -> 1556;
1641 -> 1557;
1641 -> 1563;
1641 -> 1564;
1641 -> 1561;
1642 -> 1522;
1642 -> 1623;
1642 -> 1393;
1643 -> 1576;
1644 -> 1643;
1644 -> 1397;
1645 -> 1644;
1645 -> 1399;
1645 -> 1397;
1646 -> 1595;
1647 -> 1646;
1647 -> 1435;
1648 -> 1647;
1648 -> 1437;
1648 -> 1435;
1649 -> 1433;
1649 -> 1465;
1649 -> 1591;
1649 -> 1648;
1649 -> 1600;
1649 -> 1461;
1649 -> 1462;
1649 -> 1601;
1649 -> 1472;
1649 -> 1464;
1650 -> 1615;
1651 -> 1650;
1651 -> 1484;
1652 -> 1651;
1652 -> 1486;
1652 -> 1484;
1653 -> 1482;
1653 -> 1516;
1653 -> 1611;
1653 -> 1652;
1653 -> 1620;
1653 -> 1510;
1653 -> 1511;
1653 -> 1621;
1653 -> 1518;
1653 -> 1515;
1654 -> 1635;
1655 -> 1654;
1655 -> 1530;
1656 -> 1655;
1656 -> 1532;
1656 -> 1530;
1657 -> 1528;
1657 -> 1562;
1657 -> 1631;
1657 -> 1656;
1657 -> 1640;
1657 -> 1556;
1657 -> 1557;
1657 -> 1641;
1657 -> 1564;
1657 -> 1561;
1658 -> 1576;
1659 -> 1658;
1659 -> 1397;
1660 -> 1659;
1660 -> 1399;
1660 -> 1397;
1661 -> 1595;
1662 -> 1661;
1662 -> 1435;
1663 -> 1662;
1663 -> 1437;
1663 -> 1435;
1664 -> 1433;
1664 -> 1465;
1664 -> 1591;
1664 -> 1663;
1664 -> 1600;
1664 -> 1461;
1664 -> 1462;
1664 -> 1649;
1664 -> 1472;
1664 -> 1464;
1665 -> 1615;
1666 -> 1665;
1666 -> 1484;
1667 -> 1666;
1667 -> 1486;
1667 -> 1484;
1668 -> 1482;
1668 -> 1516;
1668 -> 1611;
1668 -> 1667;
1668 -> 1620;
1668 -> 1510;
1668 -> 1511;
1668 -> 1653;
1668 -> 1518;
1668 -> 1515;
1669 -> 1635;
1670 -> 1669;
1670 -> 1530;
1671 -> 1670;
1671 -> 1532;
1671 -> 1530;
1672 -> 1528;
1672 -> 1562;
1672 -> 1631;
1672 -> 1671;
1672 -> 1640;
1672 -> 1556;
1672 -> 1557;
1672 -> 1657;
1672 -> 1564;
1672 -> 1561;
1673 -> 1576;
1674 -> 1673;
1674 -> 1397;
1675 -> 1674;
1675 -> 1399;
1675 -> 1397;
1676 -> 1595;
1677 -> 1676;
1677 -> 1435;
1678 -> 1677;
1678 -> 1437;
1678 -> 1435;
1679 -> 1433;
1679 -> 1465;
1679 -> 1591;
1679 -> 1678;
1679 -> 1600;
1679 -> 1461;
1679 -> 1462;
1679 -> 1664;
1679 -> 1472;
1679 -> 1464;
1680 -> 1615;
1681 -> 1680;
1681 -> 1484;
1682 -> 1681;
1682 -> 1486;
1682 -> 1484;
1683 -> 1482;
1683 -> 1516;
1683 -> 1611;
1683 -> 1682;
1683 -> 1620;
1683 -> 1510;
1683 -> 1511;
1683 -> 1668;
1683 -> 1518;
1683 -> 1515;
1684 -> 1635;
1685 -> 1684;
1685 -> 1530;
1686 -> 1685;
1686 -> 1532;
1686 -> 1530;
1687 -> 1528;
1687 -> 1562;
1687 -> 1631;
1687 -> 1686;
1687 -> 1640;
1687 -> 1556;
1687 -> 1557;
1687 -> 1672;
1687 -> 1564;
1687 -> 1561;
1688 -> 1576;
1689 -> 1688;
1689 -> 1397;
1690 -> 1689;
1690 -> 1399;
1690 -> 1397;
1691 -> 1595;
1692 -> 1691;
1692 -> 1435;
1693 -> 1692;
1693 -> 1437;
1693 -> 1435;
1694 -> 1433;
1694 -> 1465;
1694 -> 1591;
1694 -> 1693;
1694 -> 1600;
1694 -> 1461;
1694 -> 1462;
1694 -> 1679;
1694 -> 1472;
1694 -> 1464;
1695 -> 1615;
1696 -> 1695;
1696 -> 1484;
1697 -> 1696;
1697 -> 1486;
1697 -> 1484;
1698 -> 1482;
1698 -> 1516;
1698 -> 1611;
1698 -> 1697;
1698 -> 1620;
1698 -> 1510;
1698 -> 1511;
1698 -> 1683;
1698 -> 1518;
1698 -> 1515;
1699 -> 1635;
1700 -> 1699;
1700 -> 1530;
1701 -> 1700;
1701 -> 1532;
1701 -> 1530;
1702 -> 1528;
1702 -> 1562;
1702 -> 1631;
1702 -> 1701;
1702 -> 1640;
1702 -> 1556;
1702 -> 1557;
1702 -> 1687;
1702 -> 1564;
1702 -> 1561;
1703 -> 1576;
1704 -> 1703;
1704 -> 1397;
1705 -> 1704;
1705 -> 1399;
1705 -> 1397;
1706 -> 1595;
1707 -> 1706;
1707 -> 1435;
1708 -> 1707;
1708 -> 1437;
1708 -> 1435;
1709 -> 1433;
1709 -> 1465;
1709 -> 1591;
1709 -> 1708;
1709 -> 1600;
1709 -> 1461;
1709 -> 1462;
1709 -> 1694;
1709 -> 1472;
1709 -> 1464;
1710 -> 1615;
1711 -> 1710;
1711 -> 1484;
1712 -> 1711;
1712 -> 1486;
1712 -> 1484;
1713 -> 1482;
1713 -> 1516;
1713 -> 1611;
1713 -> 1712;
1713 -> 1620;
1713 -> 1510;
1713 -> 1511;
1713 -> 1698;
1713 -> 1518;
1713 -> 1515;
1714 -> 1635;
1715 -> 1714;
1715 -> 1530;
1716 -> 1715;
1716 -> 1532;
1716 -> 1530;
1717 -> 1528;
1717 -> 1562;
1717 -> 1631;
1717 -> 1716;
1717 -> 1640;
1717 -> 1556;
1717 -> 1557;
1717 -> 1702;
1717 -> 1564;
1717 -> 1561;
1718 -> 1576;
1719 -> 1718;
1719 -> 1397;
1720 -> 1719;
1720 -> 1399;
1720 -> 1397;
1721 -> 1595;
1722 -> 1721;
1722 -> 1435;
1723 -> 1722;
1723 -> 1437;
1723 -> 1435;
1724 -> 1433;
1724 -> 1465;
1724 -> 1591;
1724 -> 1723;
1724 -> 1600;
1724 -> 1461;
1724 -> 1462;
1724 -> 1709;
1724 -> 1472;
1724 -> 1464;
1725 -> 1615;
1726 -> 1725;
1726 -> 1484;
1727 -> 1726;
1727 -> 1486;
1727 -> 1484;
1728 -> 1482;
1728 -> 1516;
1728 -> 1611;
1728 -> 1727;
1728 -> 1620;
1728 -> 1510;
1728 -> 1511;
1728 -> 1713;
1728 -> 1518;
1728 -> 1515;
1729 -> 1635;
1730 -> 1729;
1730 -> 1530;
1731 -> 1730;
1731 -> 1532;
1731 -> 1530;
1732 -> 1528;
1732 -> 1562;
1732 -> 1631;
1732 -> 1731;
1732 -> 1640;
1732 -> 1556;
1732 -> 1557;
1732 -> 1717;
1732 -> 1564;
1732 -> 1561;
1733 -> 1576;
1734 -> 1733;
1734 -> 1397;
1735 -> 1734;
1735 -> 1399;
1735 -> 1397;
1736 -> 1595;
1737 -> 1736;
1737 -> 1435;
1738 -> 1737;
1738 -> 1437;
1738 -> 1435;
1739 -> 1433;
1739 -> 1465;
1739 -> 1591;
1739 -> 1738;
1739 -> 1600;
1739 -> 1461;
1739 -> 1462;
1739 -> 1724;
1739 -> 1472;
1739 -> 1464;
1740 -> 1615;
1741 -> 1740;
1741 -> 1484;
1742 -> 1741;
1742 -> 1486;
1742 -> 1484;
1743 -> 1482;
1743 -> 1516;
1743 -> 1611;
1743 -> 1742;
1743 -> 1620;
1743 -> 1510;
1743 -> 1511;
1743 -> 1728;
1743 -> 1518;
1743 -> 1515;
1744 -> 1635;
1745 -> 1744;
1745 -> 1530;
1746 -> 1745;
1746 -> 1532;
1746 -> 1530;
1747 -> 1528;
1747 -> 1562;
1747 -> 1631;
1747 -> 1746;
1747 -> 1640;
1747 -> 1556;
1747 -> 1557;
1747 -> 1732;
1747 -> 1564;
1747 -> 1561;
1748 -> 1576;
1749 -> 1748;
1749 -> 1397;
1750 -> 1749;
1750 -> 1399;
1750 -> 1397;
1751 -> 1595;
1752 -> 1751;
1752 -> 1435;
1753 -> 1752;
1753 -> 1437;
1753 -> 1435;
1754 -> 1433;
1754 -> 1465;
1754 -> 1591;
1754 -> 1753;
1754 -> 1600;
1754 -> 1461;
1754 -> 1462;
1754 -> 1739;
1754 -> 1472;
1754 -> 1464;
1755 -> 1615;
1756 -> 1755;
1756 -> 1484;
1757 -> 1756;
1757 -> 1486;
1757 -> 1484;
1758 -> 1482;
1758 -> 1516;
1758 -> 1611;
1758 -> 1757;
1758 -> 1620;
1758 -> 1510;
1758 -> 1511;
1758 -> 1743;
1758 -> 1518;
1758 -> 1515;
1759 -> 1635;
1760 -> 1759;
1760 -> 1530;
1761 -> 1760;
1761 -> 1532;
1761 -> 1530;
1762 -> 1528;
1762 -> 1562;
1762 -> 1631;
1762 -> 1761;
1762 -> 1640;
1762 -> 1556;
1762 -> 1557;
1762 -> 1747;
1762 -> 1564;
1762 -> 1561;
1763 -> 1576;
1764 -> 1763;
1764 -> 1397;
1765 -> 1764;
1765 -> 1399;
1765 -> 1397;
1766 -> 1595;
1767 -> 1766;
1767 -> 1435;
1768 -> 1767;
1768 -> 1437;
1768 -> 1435;
1769 -> 1433;
1769 -> 1465;
1769 -> 1591;
1769 -> 1768;
1769 -> 1600;
1769 -> 1461;
1769 -> 1462;
1769 -> 1754;
1769 -> 1472;
1769 -> 1464;
1770 -> 1615;
1771 -> 1770;
1771 -> 1484;
1772 -> 1771;
1772 -> 1486;
1772 -> 1484;
1773 -> 1482;
1773 -> 1516;
1773 -> 1611;
1773 -> 1772;
1773 -> 1620;
1773 -> 1510;
1773 -> 1511;
1773 -> 1758;
1773 -> 1518;
1773 -> 1515;
1774 -> 1635;
1775 -> 1774;
1775 -> 1530;
1776 -> 1775;
1776 -> 1532;
1776 -> 1530;
1777 -> 1528;
1777 -> 1562;
1777 -> 1631;
1777 -> 1776;
1777 -> 1640;
1777 -> 1556;
1777 -> 1557;
1777 -> 1762;
1777 -> 1564;
1777 -> 1561;
1778 -> 1576;
1779 -> 1778;
1779 -> 1397;
1780 -> 1779;
1780 -> 1399;
1780 -> 1397;
1781 -> 1595;
1782 -> 1781;
1782 -> 1435;
1783 -> 1782;
1783 -> 1437;
1783 -> 1435;
1784 -> 1433;
1784 -> 1465;
1784 -> 1591;
1784 -> 1783;
1784 -> 1600;
1784 -> 1461;
1784 -> 1462;
1784 -> 1769;
1784 -> 1472;
1784 -> 1464;
1785 -> 1615;
1786 -> 1785;
1786 -> 1484;
1787 -> 1786;
1787 -> 1486;
1787 -> 1484;
1788 -> 1482;
1788 -> 1516;
1788 -> 1611;
1788 -> 1787;
1788 -> 1620;
1788 -> 1510;
1788 -> 1511;
1788 -> 1773;
1788 -> 1518;
1788 -> 1515;
1789 -> 1635;
1790 -> 1789;
1790 -> 1530;
1791 -> 1790;
1791 -> 1532;
1791 -> 1530;
1792 -> 1528;
1792 -> 1562;
1792 -> 1631;
1792 -> 1791;
1792 -> 1640;
1792 -> 1556;
1792 -> 1557;
1792 -> 1777;
1792 -> 1564;
1792 -> 1561;
1793 -> 1576;
1794 -> 1793;
1794 -> 1397;
1795 -> 1794;
1795 -> 1399;
1795 -> 1397;
1796 -> 1595;
1797 -> 1796;
1797 -> 1435;
1798 -> 1797;
1798 -> 1437;
1798 -> 1435;
1799 -> 1433;
1799 -> 1465;
1799 -> 1591;
1799 -> 1798;
1799 -> 1600;
1799 -> 1461;
1799 -> 1462;
1799 -> 1784;
1799 -> 1472;
1799 -> 1464;
1800 -> 1615;
1801 -> 1800;
1801 -> 1484;
1802 -> 1801;
1802 -> 1486;
1802 -> 1484;
1803 -> 1482;
1803 -> 1516;
1803 -> 1611;
1803 -> 1802;
1803 -> 1620;
1803 -> 1510;
1803 -> 1511;
1803 -> 1788;
1803 -> 1518;
1803 -> 1515;
1804 -> 1635;
1805 -> 1804;
1805 -> 1530;
1806 -> 1805;
1806 -> 1532;
1806 -> 1530;
1807 -> 1528;
1807 -> 1562;
1807 -> 1631;
1807 -> 1806;
1807 -> 1640;
1807 -> 1556;
1807 -> 1557;
1807 -> 1792;
1807 -> 1564;
1807 -> 1561;
1808 -> 1576;
1809 -> 1808;
1809 -> 1397;
1810 -> 1809;
1810 -> 1399;
1810 -> 1397;
1811 -> 1595;
1812 -> 1811;
1812 -> 1435;
1813 -> 1812;
1813 -> 1437;
1813 -> 1435;
1814 -> 1433;
1814 -> 1465;
1814 -> 1591;
1814 -> 1813;
1814 -> 1600;
1814 -> 1461;
1814 -> 1462;
1814 -> 1799;
1814 -> 1472;
1814 -> 1464;
1815 -> 1615;
1816 -> 1815;
1816 -> 1484;
1817 -> 1816;
1817 -> 1486;
1817 -> 1484;
1818 -> 1482;
1818 -> 1516;
1818 -> 1611;
1818 -> 1817;
1818 -> 1620;
1818 -> 1510;
1818 -> 1511;
1818 -> 1803;
1818 -> 1518;
1818 -> 1515;
1819 -> 1635;
1820 -> 1819;
1820 -> 1530;
1821 -> 1820;
1821 -> 1532;
1821 -> 1530;
1822 -> 1528;
1822 -> 1562;
1822 -> 1631;
1822 -> 1821;
1822 -> 1640;
1822 -> 1556;
1822 -> 1557;
1822 -> 1807;
1822 -> 1564;
1822 -> 1561;
1823 -> 1576;
1824 -> 1823;
1824 -> 1397;
1825 -> 1824;
1825 -> 1399;
1825 -> 1397;
1826 -> 1595;
1827 -> 1826;
1827 -> 1435;
1828 -> 1827;
1828 -> 1437;
1828 -> 1435;
1829 -> 1433;
1829 -> 1465;
1829 -> 1591;
1829 -> 1828;
1829 -> 1600;
1829 -> 1461;
1829 -> 1462;
1829 -> 1814;
1829 -> 1472;
1829 -> 1464;
1830 -> 1615;
1831 -> 1830;
1831 -> 1484;
1832 -> 1831;
1832 -> 1486;
1832 -> 1484;
1833 -> 1482;
1833 -> 1516;
1833 -> 1611;
1833 -> 1832;
1833 -> 1620;
1833 -> 1510;
1833 -> 1511;
1833 -> 1818;
1833 -> 1518;
1833 -> 1515;
1834 -> 1635;
1835 -> 1834;
1835 -> 1530;
1836 -> 1835;
1836 -> 1532;
1836 -> 1530;
1837 -> 1528;
1837 -> 1562;
1837 -> 1631;
1837 -> 1836;
1837 -> 1640;
1837 -> 1556;
1837 -> 1557;
1837 -> 1822;
1837 -> 1564;
1837 -> 1561;
1838 -> 1576;
1839 -> 1838;
1839 -> 1397;
1840 -> 1839;
1840 -> 1399;
1840 -> 1397;
1841 -> 1595;
1842 -> 1841;
1842 -> 1435;
1843 -> 1842;
1843 -> 1437;
1843 -> 1435;
1844 -> 1433;
1844 -> 1465;
1844 -> 1591;
1844 -> 1843;
1844 -> 1600;
1844 -> 1461;
1844 -> 1462;
1844 -> 1829;
1844 -> 1472;
1844 -> 1464;
1845 -> 1615;
1846 -> 1845;
1846 -> 1484;
1847 -> 1846;
1847 -> 1486;
1847 -> 1484;
1848 -> 1482;
1848 -> 1516;
1848 -> 1611;
1848 -> 1847;
1848 -> 1620;
1848 -> 1510;
1848 -> 1511;
1848 -> 1833;
1848 -> 1518;
1848 -> 1515;
1849 -> 1635;
1850 -> 1849;
1850 -> 1530;
1851 -> 1850;
1851 -> 1532;
1851 -> 1530;
1852 -> 1528;
1852 -> 1562;
1852 -> 1631;
1852 -> 1851;
1852 -> 1640;
1852 -> 1556;
1852 -> 1557;
1852 -> 1837;
1852 -> 1564;
1852 -> 1561;
1853 -> 1576;
1854 -> 1853;
1854 -> 1397;
1855 -> 1854;
1855 -> 1399;
1855 -> 1397;
1856 -> 1595;
1857 -> 1856;
1857 -> 1435;
1858 -> 1857;
1858 -> 1437;
1858 -> 1435;
1859 -> 1433;
1859 -> 1465;
1859 -> 1591;
1859 -> 1858;
1859 -> 1600;
1859 -> 1461;
1859 -> 1462;
1859 -> 1844;
1859 -> 1472;
1859 -> 1464;
1860 -> 1615;
1861 -> 1860;
1861 -> 1484;
1862 -> 1861;
1862 -> 1486;
1862 -> 1484;
1863 -> 1482;
1863 -> 1516;
1863 -> 1611;
1863 -> 1862;
1863 -> 1620;
1863 -> 1510;
1863 -> 1511;
1863 -> 1848;
1863 -> 1518;
1863 -> 1515;
1864 -> 1635;
1865 -> 1864;
1865 -> 1530;
1866 -> 1865;
1866 -> 1532;
1866 -> 1530;
1867 -> 1528;
1867 -> 1562;
1867 -> 1631;
1867 -> 1866;
1867 -> 1640;
1867 -> 1556;
1867 -> 1557;
1867 -> 1852;
1867 -> 1564;
1867 -> 1561;
1868 -> 1576;
1869 -> 1868;
1869 -> 1397;
1870 -> 1869;
1870 -> 1399;
1870 -> 1397;
1871 -> 1595;
1872 -> 1871;
1872 -> 1435;
1873 -> 1872;
1873 -> 1437;
1873 -> 1435;
1874 -> 1433;
1874 -> 1465;
1874 -> 1591;
1874 -> 1873;
1874 -> 1600;
1874 -> 1461;
1874 -> 1462;
1874 -> 1859;
1874 -> 1472;
1874 -> 1464;
1875 -> 1615;
1876 -> 1875;
1876 -> 1484;
1877 -> 1876;
1877 -> 1486;
1877 -> 1484;
1878 -> 1482;
1878 -> 1516;
1878 -> 1611;
1878 -> 1877;
1878 -> 1620;
1878 -> 1510;
1878 -> 1511;
1878 -> 1863;
1878 -> 1518;
1878 -> 1515;
1879 -> 1635;
1880 -> 1879;
1880 -> 1530;
1881 -> 1880;
1881 -> 1532;
1881 -> 1530;
1882 -> 1528;
1882 -> 1562;
1882 -> 1631;
1882 -> 1881;
1882 -> 1640;
1882 -> 1556;
1882 -> 1557;
1882 -> 1867;
1882 -> 1564;
1882 -> 1561;
1883 -> 1576;
1884 -> 1883;
1884 -> 1397;
1885 -> 1884;
1885 -> 1399;
1885 -> 1397;
1886 -> 1595;
1887 -> 1886;
1887 -> 1435;
1888 -> 1887;
1888 -> 1437;
1888 -> 1435;
1889 -> 1433;
1889 -> 1465;
1889 -> 1591;
1889 -> 1888;
1889 -> 1600;
1889 -> 1461;
1889 -> 1462;
1889 -> 1874;
1889 -> 1472;
1889 -> 1464;
1890 -> 1615;
1891 -> 1890;
1891 -> 1484;
1892 -> 1891;
1892 -> 1486;
1892 -> 1484;
1893 -> 1482;
1893 -> 1516;
1893 -> 1611;
1893 -> 1892;
1893 -> 1620;
1893 -> 1510;
1893 -> 1511;
1893 -> 1878;
1893 -> 1518;
1893 -> 1515;
1894 -> 1635;
1895 -> 1894;
1895 -> 1530;
1896 -> 1895;
1896 -> 1532;
1896 -> 1530;
1897 -> 1528;
1897 -> 1562;
1897 -> 1631;
1897 -> 1896;
1897 -> 1640;
1897 -> 1556;
1897 -> 1557;
1897 -> 1882;
1897 -> 1564;
1897 -> 1561;
1898 -> 1576;
1899 -> 1898;
1899 -> 1397;
1900 -> 1899;
1900 -> 1399;
1900 -> 1397;
1901 -> 1595;
1902 -> 1901;
1902 -> 1435;
1903 -> 1902;
1903 -> 1437;
1903 -> 1435;
1904 -> 1433;
1904 -> 1465;
1904 -> 1591;
1904 -> 1903;
1904 -> 1600;
1904 -> 1461;
1904 -> 1462;
1904 -> 1889;
1904 -> 1472;
1904 -> 1464;
1905 -> 1615;
1906 -> 1905;
1906 -> 1484;
1907 -> 1906;
1907 -> 1486;
1907 -> 1484;
1908 -> 1482;
1908 -> 1516;
1908 -> 1611;
1908 -> 1907;
1908 -> 1620;
1908 -> 1510;
1908 -> 1511;
1908 -> 1893;
1908 -> 1518;
1908 -> 1515;
1909 -> 1635;
1910 -> 1909;
1910 -> 1530;
1911 -> 1910;
1911 -> 1532;
1911 -> 1530;
1912 -> 1528;
1912 -> 1562;
1912 -> 1631;
1912 -> 1911;
1912 -> 1640;
1912 -> 1556;
1912 -> 1557;
1912 -> 1897;
1912 -> 1564;
1912 -> 1561;
1913 -> 1576;
1914 -> 1913;
1914 -> 1397;
1915 -> 1914;
1915 -> 1399;
1915 -> 1397;
1916 -> 1595;
1917 -> 1916;
1917 -> 1435;
1918 -> 1917;
1918 -> 1437;
1918 -> 1435;
1919 -> 1433;
1919 -> 1465;
1919 -> 1591;
1919 -> 1918;
1919 -> 1600;
1919 -> 1461;
1919 -> 1462;
1919 -> 1904;
1919 -> 1472;
1919 -> 1464;
1920 -> 1615;
1921 -> 1920;
1921 -> 1484;
1922 -> 1921;
1922 -> 1486;
1922 -> 1484;
1923 -> 1482;
1923 -> 1516;
1923 -> 1611;
1923 -> 1922;
1923 -> 1620;
1923 -> 1510;
1923 -> 1511;
1923 -> 1908;
1923 -> 1518;
1923 -> 1515;
1924 -> 1635;
1925 -> 1924;
1925 -> 1530;
1926 -> 1925;
1926 -> 1532;
1926 -> 1530;
1927 -> 1528;
1927 -> 1562;
1927 -> 1631;
1927 -> 1926;
1927 -> 1640;
1927 -> 1556;
1927 -> 1557;
1927 -> 1912;
1927 -> 1564;
1927 -> 1561;
1928 -> 1576;
1929 -> 1928;
1929 -> 1397;
1930 -> 1929;
1930 -> 1399;
1930 -> 1397;
1931 -> 1595;
1932 -> 1931;
1932 -> 1435;
1933 -> 1932;
1933 -> 1437;
1933 -> 1435;
1934 -> 1433;
1934 -> 1465;
1934 -> 1591;
1934 -> 1933;
1934 -> 1600;
1934 -> 1461;
1934 -> 1462;
1934 -> 1919;
1934 -> 1472;
1934 -> 1464;
1935 -> 1615;
1936 -> 1935;
1936 -> 1484;
1937 -> 1936;
1937 -> 1486;
1937 -> 1484;
1938 -> 1482;
1938 -> 1516;
1938 -> 1611;
1938 -> 1937;
1938 -> 1620;
1938 -> 1510;
1938 -> 1511;
1938 -> 1923;
1938 -> 1518;
1938 -> 1515;
1939 -> 1635;
1940 -> 1939;
1940 -> 1530;
1941 -> 1940;
1941 -> 1532;
1941 -> 1530;
1942 -> 1528;
1942 -> 1562;
1942 -> 1631;
1942 -> 1941;
1942 -> 1640;
1942 -> 1556;
1942 -> 1557;
1942 -> 1927;
1942 -> 1564;
1942 -> 1561;
1943 -> 1576;
1944 -> 1943;
1944 -> 1397;
1945 -> 1944;
1945 -> 1399;
1945 -> 1397;
1946 -> 1595;
1947 -> 1946;
1947 -> 1435;
1948 -> 1947;
1948 -> 1437;
1948 -> 1435;
1949 -> 1433;
1949 -> 1465;
1949 -> 1591;
1949 -> 1948;
1949 -> 1600;
1949 -> 1461;
1949 -> 1462;
1949 -> 1934;
1949 -> 1472;
1949 -> 1464;
1950 -> 1615;
1951 -> 1950;
1951 -> 1484;
1952 -> 1951;
1952 -> 1486;
1952 -> 1484;
1953 -> 1482;
1953 -> 1516;
1953 -> 1611;
1953 -> 1952;
1953 -> 1620;
1953 -> 1510;
1953 -> 1511;
1953 -> 1938;
1953 -> 1518;
1953 -> 1515;
1954 -> 1635;
1955 -> 1954;
1955 -> 1530;
1956 -> 1955;
1956 -> 1532;
1956 -> 1530;
1957 -> 1528;
1957 -> 1562;
1957 -> 1631;
1957 -> 1956;
1957 -> 1640;
1957 -> 1556;
1957 -> 1557;
1957 -> 1942;
1957 -> 1564;
1957 -> 1561;
1958 -> 1576;
1959 -> 1958;
1959 -> 1397;
1960 -> 1959;
1960 -> 1399;
1960 -> 1397;
1961 -> 1595;
1962 -> 1961;
1962 -> 1435;
1963 -> 1962;
1963 -> 1437;
1963 -> 1435;
1964 -> 1433;
1964 -> 1465;
1964 -> 1591;
1964 -> 1963;
1964 -> 1600;
1964 -> 1461;
1964 -> 1462;
1964 -> 1949;
1964 -> 1472;
1964 -> 1464;
1965 -> 1615;
1966 -> 1965;
1966 -> 1484;
1967 -> 1966;
1967 -> 1486;
1967 -> 1484;
1968 -> 1482;
1968 -> 1516;
1968 -> 1611;
1968 -> 1967;
1968 -> 1620;
1968 -> 1510;
1968 -> 1511;
1968 -> 1953;
1968 -> 1518;
1968 -> 1515;
1969 -> 1635;
1970 -> 1969;
1970 -> 1530;
1971 -> 1970;
1971 -> 1532;
1971 -> 1530;
1972 -> 1528;
1972 -> 1562;
1972 -> 1631;
1972 -> 1971;
1972 -> 1640;
1972 -> 1556;
1972 -> 1557;
1972 -> 1957;
1972 -> 1564;
1972 -> 1561;
1973 -> 1576;
1974 -> 1973;
1974 -> 1397;
1975 -> 1974;
1975 -> 1399;
1975 -> 1397;
1976 -> 1595;
1977 -> 1976;
1977 -> 1435;
1978 -> 1977;
1978 -> 1437;
1978 -> 1435;
1979 -> 1433;
1979 -> 1465;
1979 -> 1591;
1979 -> 1978;
1979 -> 1600;
1979 -> 1461;
1979 -> 1462;
1979 -> 1964;
1979 -> 1472;
1979 -> 1464;
1980 -> 1615;
1981 -> 1980;
1981 -> 1484;
1982 -> 1981;
1982 -> 1486;
1982 -> 1484;
1983 -> 1482;
1983 -> 1516;
1983 -> 1611;
1983 -> 1982;
1983 -> 1620;
1983 -> 1510;
1983 -> 1511;
1983 -> 1968;
1983 -> 1518;
1983 -> 1515;
1984 -> 1635;
1985 -> 1984;
1985 -> 1530;
1986 -> 1985;
1986 -> 1532;
1986 -> 1530;
1987 -> 1528;
1987 -> 1562;
1987 -> 1631;
1987 -> 1986;
1987 -> 1640;
1987 -> 1556;
1987 -> 1557;
1987 -> 1972;
1987 -> 1564;
1987 -> 1561;
1988 -> 1576;
1989 -> 1988;
1989 -> 1397;
1990 -> 1989;
1990 -> 1399;
1990 -> 1397;
1991 -> 1595;
1992 -> 1991;
1992 -> 1435;
1993 -> 1992;
1993 -> 1437;
1993 -> 1435;
1994 -> 1433;
1994 -> 1465;
1994 -> 1591;
1994 -> 1993;
1994 -> 1600;
1994 -> 1461;
1994 -> 1462;
1994 -> 1979;
1994 -> 1472;
1994 -> 1464;
1995 -> 1615;
1996 -> 1995;
1996 -> 1484;
1997 -> 1996;
1997 -> 1486;
1997 -> 1484;
1998 -> 1482;
1998 -> 1516;
1998 -> 1611;
1998 -> 1997;
1998 -> 1620;
1998 -> 1510;
1998 -> 1511;
1998 -> 1983;
1998 -> 1518;
1998 -> 1515;
1999 -> 1635;
2000 -> 1999;
2000 -> 1530;
2001 -> 2000;
2001 -> 1532;
2001 -> 1530;
2002 -> 1528;
2002 -> 1562;
2002 -> 1631;
2002 -> 2001;
2002 -> 1640;
2002 -> 1556;
2002 -> 1557;
2002 -> 1987;
2002 -> 1564;
2002 -> 1561;
2003 -> 1576;
2004 -> 2003;
2004 -> 1397;
2005 -> 2004;
2005 -> 1399;
2005 -> 1397;
2006 -> 1595;
2007 -> 2006;
2007 -> 1435;
2008 -> 2007;
2008 -> 1437;
2008 -> 1435;
2009 -> 1433;
2009 -> 1465;
2009 -> 1591;
2009 -> 2008;
2009 -> 1600;
2009 -> 1461;
2009 -> 1462;
2009 -> 1994;
2009 -> 1472;
2009 -> 1464;
2010 -> 1615;
2011 -> 2010;
2011 -> 1484;
2012 -> 2011;
2012 -> 1486;
2012 -> 1484;
2013 -> 1482;
2013 -> 1516;
2013 -> 1611;
2013 -> 2012;
2013 -> 1620;
2013 -> 1510;
2013 -> 1511;
2013 -> 1998;
2013 -> 1518;
2013 -> 1515;
2014 -> 1635;
2015 -> 2014;
2015 -> 1530;
2016 -> 2015;
2016 -> 1532;
2016 -> 1530;
2017 -> 1528;
2017 -> 1562;
2017 -> 1631;
2017 -> 2016;
2017 -> 1640;
2017 -> 1556;
2017 -> 1557;
2017 -> 2002;
2017 -> 1564;
2017 -> 1561;
2018 -> 1576;
2019 -> 2018;
2019 -> 1397;
2020 -> 2019;
2020 -> 1399;
2020 -> 1397;
2021 -> 1595;
2022 -> 2021;
2022 -> 1435;
2023 -> 2022;
2023 -> 1437;
2023 -> 1435;
2024 -> 1433;
2024 -> 1465;
2024 -> 1591;
2024 -> 2023;
2024 -> 1600;
2024 -> 1461;
2024 -> 1462;
2024 -> 2009;
2024 -> 1472;
2024 -> 1464;
2025 -> 1615;
2026 -> 2025;
2026 -> 1484;
2027 -> 2026;
2027 -> 1486;
2027 -> 1484;
2028 -> 1482;
2028 -> 1516;
2028 -> 1611;
2028 -> 2027;
2028 -> 1620;
2028 -> 1510;
2028 -> 1511;
2028 -> 2013;
2028 -> 1518;
2028 -> 1515;
2029 -> 1635;
2030 -> 2029;
2030 -> 1530;
2031 -> 2030;
2031 -> 1532;
2031 -> 1530;
2032 -> 1528;
2032 -> 1562;
2032 -> 1631;
2032 -> 2031;
2032 -> 1640;
2032 -> 1556;
2032 -> 1557;
2032 -> 2017;
2032 -> 1564;
2032 -> 1561;
2033 -> 1576;
2034 -> 2033;
2034 -> 1397;
2035 -> 2034;
2035 -> 1399;
2035 -> 1397;
2036 -> 1595;
2037 -> 2036;
2037 -> 1435;
2038 -> 2037;
2038 -> 1437;
2038 -> 1435;
2039 -> 1433;
2039 -> 1465;
2039 -> 1591;
2039 -> 2038;
2039 -> 1600;
2039 -> 1461;
2039 -> 1462;
2039 -> 2024;
2039 -> 1472;
2039 -> 1464;
2040 -> 1615;
2041 -> 2040;
2041 -> 1484;
2042 -> 2041;
2042 -> 1486;
2042 -> 1484;
2043 -> 1482;
2043 -> 1516;
2043 -> 1611;
2043 -> 2042;
2043 -> 1620;
2043 -> 1510;
2043 -> 1511;
2043 -> 2028;
2043 -> 1518;
2043 -> 1515;
2044 -> 1635;
2045 -> 2044;
2045 -> 1530;
2046 -> 2045;
2046 -> 1532;
2046 -> 1530;
2047 -> 1528;
2047 -> 1562;
2047 -> 1631;
2047 -> 2046;
2047 -> 1640;
2047 -> 1556;
2047 -> 1557;
2047 -> 2032;
2047 -> 1564;
2047 -> 1561;
2048 -> 1576;
2049 -> 2048;
2049 -> 1397;
2050 -> 2049;
2050 -> 1399;
2050 -> 1397;
2051 -> 1595;
2052 -> 2051;
2052 -> 1435;
2053 -> 2052;
2053 -> 1437;
2053 -> 1435;
2054 -> 1433;
2054 -> 1465;
2054 -> 1591;
2054 -> 2053;
2054 -> 1600;
2054 -> 1461;
2054 -> 1462;
2054 -> 2039;
2054 -> 1472;
2054 -> 1464;
2055 -> 1615;
2056 -> 2055;
2056 -> 1484;
2057 -> 2056;
2057 -> 1486;
2057 -> 1484;
2058 -> 1482;
2058 -> 1516;
2058 -> 1611;
2058 -> 2057;
2058 -> 1620;
2058 -> 1510;
2058 -> 1511;
2058 -> 2043;
2058 -> 1518;
2058 -> 1515;
2059 -> 1635;
2060 -> 2059;
2060 -> 1530;
2061 -> 2060;
2061 -> 1532;
2061 -> 1530;
2062 -> 1528;
2062 -> 1562;
2062 -> 1631;
2062 -> 2061;
2062 -> 1640;
2062 -> 1556;
2062 -> 1557;
2062 -> 2047;
2062 -> 1564;
2062 -> 1561;
2063 -> 0;
2063 -> 1576;
2064 -> 2063;
2064 -> 1397;
2065 -> 2064;
2065 -> 1399;
2065 -> 1397;
2066 -> 0;
2066 -> 1595;
2067 -> 2066;
2067 -> 1435;
2068 -> 2067;
2068 -> 1437;
2068 -> 1435;
2069 -> 1433;
2069 -> 1465;
2069 -> 1591;
2069 -> 2068;
2069 -> 1600;
2069 -> 1461;
2069 -> 1462;
2069 -> 2054;
2069 -> 1472;
2069 -> 1464;
2070 -> 0;
2070 -> 1615;
2071 -> 2070;
2071 -> 1484;
2072 -> 2071;
2072 -> 1486;
2072 -> 1484;
2073 -> 1482;
2073 -> 1516;
2073 -> 1611;
2073 -> 2072;
2073 -> 1620;
2073 -> 1510;
2073 -> 1511;
2073 -> 2058;
2073 -> 1518;
2073 -> 1515;
2074 -> 0;
2074 -> 1635;
2075 -> 2074;
2075 -> 1530;
2076 -> 2075;
2076 -> 1532;
2076 -> 1530;
2077 -> 1528;
2077 -> 1562;
2077 -> 1631;
2077 -> 2076;
2077 -> 1640;
2077 -> 1556;
2077 -> 1557;
2077 -> 2062;
2077 -> 1564;
2077 -> 1561;
2078 -> 1576;
2079 -> 2078;
2079 -> 1397;
2080 -> 2079;
2080 -> 1399;
2080 -> 1397;
2081 -> 1595;
2082 -> 2081;
2082 -> 1435;
2083 -> 2082;
2083 -> 1437;
2083 -> 1435;
2084 -> 1433;
2084 -> 1465;
2084 -> 1591;
2084 -> 2083;
2084 -> 1600;
2084 -> 1461;
2084 -> 1462;
2084 -> 2069;
2084 -> 1472;
2084 -> 1464;
2085 -> 1615;
2086 -> 2085;
2086 -> 1484;
2087 -> 2086;
2087 -> 1486;
2087 -> 1484;
2088 -> 1482;
2088 -> 1516;
2088 -> 1611;
2088 -> 2087;
2088 -> 1620;
2088 -> 1510;
2088 -> 1511;
2088 -> 2073;
2088 -> 1518;
2088 -> 1515;
2089 -> 1635;
2090 -> 2089;
2090 -> 1530;
2091 -> 2090;
2091 -> 1532;
2091 -> 1530;
2092 -> 1528;
2092 -> 1562;
2092 -> 1631;
2092 -> 2091;
2092 -> 1640;
2092 -> 1556;
2092 -> 1557;
2092 -> 2077;
2092 -> 1564;
2092 -> 1561;
2093 -> 1576;
2094 -> 2093;
2094 -> 1397;
2095 -> 2094;
2095 -> 1399;
2095 -> 1397;
2096 -> 1595;
2097 -> 2096;
2097 -> 1435;
2098 -> 2097;
2098 -> 1437;
2098 -> 1435;
2099 -> 1433;
2099 -> 1465;
2099 -> 1591;
2099 -> 2098;
2099 -> 1600;
2099 -> 1461;
2099 -> 1462;
2099 -> 2084;
2099 -> 1472;
2099 -> 1464;
2100 -> 1615;
2101 -> 2100;
2101 -> 1484;
2102 -> 2101;
2102 -> 1486;
2102 -> 1484;
2103 -> 1482;
2103 -> 1516;
2103 -> 1611;
2103 -> 2102;
2103 -> 1620;
2103 -> 1510;
2103 -> 1511;
2103 -> 2088;
2103 -> 1518;
2103 -> 1515;
2104 -> 1635;
2105 -> 2104;
2105 -> 1530;
2106 -> 2105;
2106 -> 1532;
2106 -> 1530;
2107 -> 1528;
2107 -> 1562;
2107 -> 1631;
2107 -> 2106;
2107 -> 1640;
2107 -> 1556;
2107 -> 1557;
2107 -> 2092;
2107 -> 1564;
2107 -> 1561;
2108 -> 1576;
2109 -> 2108;
2109 -> 1397;
2110 -> 2109;
2110 -> 1399;
2110 -> 1397;
2111 -> 1595;
2112 -> 2111;
2112 -> 1435;
2113 -> 2112;
2113 -> 1437;
2113 -> 1435;
2114 -> 1433;
2114 -> 1465;
2114 -> 1591;
2114 -> 2113;
2114 -> 1600;
2114 -> 1461;
2114 -> 1462;
2114 -> 2099;
2114 -> 1472;
2114 -> 1464;
2115 -> 1615;
2116 -> 2115;
2116 -> 1484;
2117 -> 2116;
2117 -> 1486;
2117 -> 1484;
2118 -> 1482;
2118 -> 1516;
2118 -> 1611;
2118 -> 2117;
2118 -> 1620;
2118 -> 1510;
2118 -> 1511;
2118 -> 2103;
2118 -> 1518;
2118 -> 1515;
2119 -> 1635;
2120 -> 2119;
2120 -> 1530;
2121 -> 2120;
2121 -> 1532;
2121 -> 1530;
2122 -> 1528;
2122 -> 1562;
2122 -> 1631;
2122 -> 2121;
2122 -> 1640;
2122 -> 1556;
2122 -> 1557;
2122 -> 2107;
2122 -> 1564;
2122 -> 1561;
2123 -> 1576;
2124 -> 2123;
2124 -> 1397;
2125 -> 2124;
2125 -> 1399;
2125 -> 1397;
2126 -> 1595;
2127 -> 2126;
2127 -> 1435;
2128 -> 2127;
2128 -> 1437;
2128 -> 1435;
2129 -> 1433;
2129 -> 1465;
2129 -> 1591;
2129 -> 2128;
2129 -> 1600;
2129 -> 1461;
2129 -> 1462;
2129 -> 2114;
2129 -> 1472;
2129 -> 1464;
2130 -> 1615;
2131 -> 2130;
2131 -> 1484;
2132 -> 2131;
2132 -> 1486;
2132 -> 1484;
2133 -> 1482;
2133 -> 1516;
2133 -> 1611;
2133 -> 2132;
2133 -> 1620;
2133 -> 1510;
2133 -> 1511;
2133 -> 2118;
2133 -> 1518;
2133 -> 1515;
2134 -> 1635;
2135 -> 2134;
2135 -> 1530;
2136 -> 2135;
2136 -> 1532;
2136 -> 1530;
2137 -> 1528;
2137 -> 1562;
2137 -> 1631;
2137 -> 2136;
2137 -> 1640;
2137 -> 1556;
2137 -> 1557;
2137 -> 2122;
2137 -> 1564;
2137 -> 1561;
2138 -> 1576;
2139 -> 2138;
2139 -> 1397;
2140 -> 2139;
2140 -> 1399;
2140 -> 1397;
2141 -> 1595;
2142 -> 2141;
2142 -> 1435;
2143 -> 2142;
2143 -> 1437;
2143 -> 1435;
2144 -> 1433;
2144 -> 1465;
2144 -> 1591;
2144 -> 2143;
2144 -> 1600;
2144 -> 1461;
2144 -> 1462;
2144 -> 2129;
2144 -> 1472;
2144 -> 1464;
2145 -> 1615;
2146 -> 2145;
2146 -> 1484;
2147 -> 2146;
2147 -> 1486;
2147 -> 1484;
2148 -> 1482;
2148 -> 1516;
2148 -> 1611;
2148 -> 2147;
2148 -> 1620;
2148 -> 1510;
2148 -> 1511;
2148 -> 2133;
2148 -> 1518;
2148 -> 1515;
2149 -> 1635;
2150 -> 2149;
2150 -> 1530;
2151 -> 2150;
2151 -> 1532;
2151 -> 1530;
2152 -> 1528;
2152 -> 1562;
2152 -> 1631;
2152 -> 2151;
2152 -> 1640;
2152 -> 1556;
2152 -> 1557;
2152 -> 2137;
2152 -> 1564;
2152 -> 1561;
2153 -> 1576;
2154 -> 2153;
2154 -> 1397;
2155 -> 2154;
2155 -> 1399;
2155 -> 1397;
2156 -> 1595;
2157 -> 2156;
2157 -> 1435;
2158 -> 2157;
2158 -> 1437;
2158 -> 1435;
2159 -> 1433;
2159 -> 1465;
2159 -> 1591;
2159 -> 2158;
2159 -> 1600;
2159 -> 1461;
2159 -> 1462;
2159 -> 2144;
2159 -> 1472;
2159 -> 1464;
2160 -> 1615;
2161 -> 2160;
2161 -> 1484;
2162 -> 2161;
2162 -> 1486;
2162 -> 1484;
2163 -> 1482;
2163 -> 1516;
2163 -> 1611;
2163 -> 2162;
2163 -> 1620;
2163 -> 1510;
2163 -> 1511;
2163 -> 2148;
2163 -> 1518;
2163 -> 1515;
2164 -> 1635;
2165 -> 2164;
2165 -> 1530;
2166 -> 2165;
2166 -> 1532;
2166 -> 1530;
2167 -> 1528;
2167 -> 1562;
2167 -> 1631;
2167 -> 2166;
2167 -> 1640;
2167 -> 1556;
2167 -> 1557;
2167 -> 2152;
2167 -> 1564;
2167 -> 1561;
2168 -> 1576;
2169 -> 2168;
2169 -> 1397;
2170 -> 2169;
2170 -> 1399;
2170 -> 1397;
2171 -> 1595;
2172 -> 2171;
2172 -> 1435;
2173 -> 2172;
2173 -> 1437;
2173 -> 1435;
2174 -> 1433;
2174 -> 1465;
2174 -> 1591;
2174 -> 2173;
2174 -> 1600;
2174 -> 1461;
2174 -> 1462;
2174 -> 2159;
2174 -> 1472;
2174 -> 1464;
2175 -> 1615;
2176 -> 2175;
2176 -> 1484;
2177 -> 2176;
2177 -> 1486;
2177 -> 1484;
2178 -> 1482;
2178 -> 1516;
2178 -> 1611;
2178 -> 2177;
2178 -> 1620;
2178 -> 1510;
2178 -> 1511;
2178 -> 2163;
2178 -> 1518;
2178 -> 1515;
2179 -> 1635;
2180 -> 2179;
2180 -> 1530;
2181 -> 2180;
2181 -> 1532;
2181 -> 1530;
2182 -> 1528;
2182 -> 1562;
2182 -> 1631;
2182 -> 2181;
2182 -> 1640;
2182 -> 1556;
2182 -> 1557;
2182 -> 2167;
2182 -> 1564;
2182 -> 1561;
2183 -> 1576;
2184 -> 2183;
2184 -> 1397;
2185 -> 2184;
2185 -> 1399;
2185 -> 1397;
2186 -> 1595;
2187 -> 2186;
2187 -> 1435;
2188 -> 2187;
2188 -> 1437;
2188 -> 1435;
2189 -> 1433;
2189 -> 1465;
2189 -> 1591;
2189 -> 2188;
2189 -> 1600;
2189 -> 1461;
2189 -> 1462;
2189 -> 2174;
2189 -> 1472;
2189 -> 1464;
2190 -> 1615;
2191 -> 2190;
2191 -> 1484;
2192 -> 2191;
2192 -> 1486;
2192 -> 1484;
2193 -> 1482;
2193 -> 1516;
2193 -> 1611;
2193 -> 2192;
2193 -> 1620;
2193 -> 1510;
2193 -> 1511;
2193 -> 2178;
2193 -> 1518;
2193 -> 1515;
2194 -> 1635;
2195 -> 2194;
2195 -> 1530;
2196 -> 2195;
2196 -> 1532;
2196 -> 1530;
2197 -> 1528;
2197 -> 1562;
2197 -> 1631;
2197 -> 2196;
2197 -> 1640;
2197 -> 1556;
2197 -> 1557;
2197 -> 2182;
2197 -> 1564;
2197 -> 1561;
2198 -> 1576;
2199 -> 2198;
2199 -> 1397;
2200 -> 2199;
2200 -> 1399;
2200 -> 1397;
2201 -> 1595;
2202 -> 2201;
2202 -> 1435;
2203 -> 2202;
2203 -> 1437;
2203 -> 1435;
2204 -> 1433;
2204 -> 1465;
2204 -> 1591;
2204 -> 2203;
2204 -> 1600;
2204 -> 1461;
2204 -> 1462;
2204 -> 2189;
2204 -> 1472;
2204 -> 1464;
2205 -> 1615;
2206 -> 2205;
2206 -> 1484;
2207 -> 2206;
2207 -> 1486;
2207 -> 1484;
2208 -> 1482;
2208 -> 1516;
2208 -> 1611;
2208 -> 2207;
2208 -> 1620;
2208 -> 1510;
2208 -> 1511;
2208 -> 2193;
2208 -> 1518;
2208 -> 1515;
2209 -> 1635;
2210 -> 2209;
2210 -> 1530;
2211 -> 2210;
2211 -> 1532;
2211 -> 1530;
2212 -> 1528;
2212 -> 1562;
2212 -> 1631;
2212 -> 2211;
2212 -> 1640;
2212 -> 1556;
2212 -> 1557;
2212 -> 2197;
2212 -> 1564;
2212 -> 1561;
2213 -> 1576;
2214 -> 2213;
2214 -> 1397;
2215 -> 2214;
2215 -> 1399;
2215 -> 1397;
2216 -> 1595;
2217 -> 2216;
2217 -> 1435;
2218 -> 2217;
2218 -> 1437;
2218 -> 1435;
2219 -> 1433;
2219 -> 1465;
2219 -> 1591;
2219 -> 2218;
2219 -> 1600;
2219 -> 1461;
2219 -> 1462;
2219 -> 2204;
2219 -> 1472;
2219 -> 1464;
2220 -> 1615;
2221 -> 2220;
2221 -> 1484;
2222 -> 2221;
2222 -> 1486;
2222 -> 1484;
2223 -> 1482;
2223 -> 1516;
2223 -> 1611;
2223 -> 2222;
2223 -> 1620;
2223 -> 1510;
2223 -> 1511;
2223 -> 2208;
2223 -> 1518;
2223 -> 1515;
2224 -> 1635;
2225 -> 2224;
2225 -> 1530;
2226 -> 2225;
2226 -> 1532;
2226 -> 1530;
2227 -> 1528;
2227 -> 1562;
2227 -> 1631;
2227 -> 2226;
2227 -> 1640;
2227 -> 1556;
2227 -> 1557;
2227 -> 2212;
2227 -> 1564;
2227 -> 1561;
2228 -> 1576;
2229 -> 2228;
2229 -> 1397;
2230 -> 2229;
2230 -> 1399;
2230 -> 1397;
2231 -> 1595;
2232 -> 2231;
2232 -> 1435;
2233 -> 2232;
2233 -> 1437;
2233 -> 1435;
2234 -> 1433;
2234 -> 1465;
2234 -> 1591;
2234 -> 2233;
2234 -> 1600;
2234 -> 1461;
2234 -> 1462;
2234 -> 2219;
2234 -> 1472;
2234 -> 1464;
2235 -> 1615;
2236 -> 2235;
2236 -> 1484;
2237 -> 2236;
2237 -> 1486;
2237 -> 1484;
2238 -> 1482;
2238 -> 1516;
2238 -> 1611;
2238 -> 2237;
2238 -> 1620;
2238 -> 1510;
2238 -> 1511;
2238 -> 2223;
2238 -> 1518;
2238 -> 1515;
2239 -> 1635;
2240 -> 2239;
2240 -> 1530;
2241 -> 2240;
2241 -> 1532;
2241 -> 1530;
2242 -> 1528;
2242 -> 1562;
2242 -> 1631;
2242 -> 2241;
2242 -> 1640;
2242 -> 1556;
2242 -> 1557;
2242 -> 2227;
2242 -> 1564;
2242 -> 1561;
2243 -> 1576;
2244 -> 2243;
2244 -> 1397;
2245 -> 2244;
2245 -> 1399;
2245 -> 1397;
2246 -> 1595;
2247 -> 2246;
2247 -> 1435;
2248 -> 2247;
2248 -> 1437;
2248 -> 1435;
2249 -> 1433;
2249 -> 1465;
2249 -> 1591;
2249 -> 2248;
2249 -> 1600;
2249 -> 1461;
2249 -> 1462;
2249 -> 2234;
2249 -> 1472;
2249 -> 1464;
2250 -> 1615;
2251 -> 2250;
2251 -> 1484;
2252 -> 2251;
2252 -> 1486;
2252 -> 1484;
2253 -> 1482;
2253 -> 1516;
2253 -> 1611;
2253 -> 2252;
2253 -> 1620;
2253 -> 1510;
2253 -> 1511;
2253 -> 2238;
2253 -> 1518;
2253 -> 1515;
2254 -> 1635;
2255 -> 2254;
2255 -> 1530;
2256 -> 2255;
2256 -> 1532;
2256 -> 1530;
2257 -> 1528;
2257 -> 1562;
2257 -> 1631;
2257 -> 2256;
2257 -> 1640;
2257 -> 1556;
2257 -> 1557;
2257 -> 2242;
2257 -> 1564;
2257 -> 1561;
2258 -> 1576;
2259 -> 2258;
2259 -> 1397;
2260 -> 2259;
2260 -> 1399;
2260 -> 1397;
2261 -> 1595;
2262 -> 2261;
2262 -> 1435;
2263 -> 2262;
2263 -> 1437;
2263 -> 1435;
2264 -> 1433;
2264 -> 1465;
2264 -> 1591;
2264 -> 2263;
2264 -> 1600;
2264 -> 1461;
2264 -> 1462;
2264 -> 2249;
2264 -> 1472;
2264 -> 1464;
2265 -> 1615;
2266 -> 2265;
2266 -> 1484;
2267 -> 2266;
2267 -> 1486;
2267 -> 1484;
2268 -> 1482;
2268 -> 1516;
2268 -> 1611;
2268 -> 2267;
2268 -> 1620;
2268 -> 1510;
2268 -> 1511;
2268 -> 2253;
2268 -> 1518;
2268 -> 1515;
2269 -> 1635;
2270 -> 2269;
2270 -> 1530;
2271 -> 2270;
2271 -> 1532;
2271 -> 1530;
2272 -> 1528;
2272 -> 1562;
2272 -> 1631;
2272 -> 2271;
2272 -> 1640;
2272 -> 1556;
2272 -> 1557;
2272 -> 2257;
2272 -> 1564;
2272 -> 1561;
2273 -> 1576;
2274 -> 2273;
2274 -> 1397;
2275 -> 2274;
2275 -> 1399;
2275 -> 1397;
2276 -> 1595;
2277 -> 2276;
2277 -> 1435;
2278 -> 2277;
2278 -> 1437;
2278 -> 1435;
2279 -> 1433;
2279 -> 1465;
2279 -> 1591;
2279 -> 2278;
2279 -> 1600;
2279 -> 1461;
2279 -> 1462;
2279 -> 2264;
2279 -> 1472;
2279 -> 1464;
2280 -> 1615;
2281 -> 2280;
2281 -> 1484;
2282 -> 2281;
2282 -> 1486;
2282 -> 1484;
2283 -> 1482;
2283 -> 1516;
2283 -> 1611;
2283 -> 2282;
2283 -> 1620;
2283 -> 1510;
2283 -> 1511;
2283 -> 2268;
2283 -> 1518;
2283 -> 1515;
2284 -> 1635;
2285 -> 2284;
2285 -> 1530;
2286 -> 2285;
2286 -> 1532;
2286 -> 1530;
2287 -> 1528;
2287 -> 1562;
2287 -> 1631;
2287 -> 2286;
2287 -> 1640;
2287 -> 1556;
2287 -> 1557;
2287 -> 2272;
2287 -> 1564;
2287 -> 1561;
2288 -> 1576;
2289 -> 2288;
2289 -> 1397;
2290 -> 2289;
2290 -> 1399;
2290 -> 1397;
2291 -> 1595;
2292 -> 2291;
2292 -> 1435;
2293 -> 2292;
2293 -> 1437;
2293 -> 1435;
2294 -> 1433;
2294 -> 1465;
2294 -> 1591;
2294 -> 2293;
2294 -> 1600;
2294 -> 1461;
2294 -> 1462;
2294 -> 2279;
2294 -> 1472;
2294 -> 1464;
2295 -> 1615;
2296 -> 2295;
2296 -> 1484;
2297 -> 2296;
2297 -> 1486;
2297 -> 1484;
2298 -> 1482;
2298 -> 1516;
2298 -> 1611;
2298 -> 2297;
2298 -> 1620;
2298 -> 1510;
2298 -> 1511;
2298 -> 2283;
2298 -> 1518;
2298 -> 1515;
2299 -> 1635;
2300 -> 2299;
2300 -> 1530;
2301 -> 2300;
2301 -> 1532;
2301 -> 1530;
2302 -> 1528;
2302 -> 1562;
2302 -> 1631;
2302 -> 2301;
2302 -> 1640;
2302 -> 1556;
2302 -> 1557;
2302 -> 2287;
2302 -> 1564;
2302 -> 1561;
2303 -> 1576;
2304 -> 2303;
2304 -> 1397;
2305 -> 2304;
2305 -> 1399;
2305 -> 1397;
2306 -> 1595;
2307 -> 2306;
2307 -> 1435;
2308 -> 2307;
2308 -> 1437;
2308 -> 1435;
2309 -> 1433;
2309 -> 1465;
2309 -> 1591;
2309 -> 2308;
2309 -> 1600;
2309 -> 1461;
2309 -> 1462;
2309 -> 2294;
2309 -> 1472;
2309 -> 1464;
2310 -> 1615;
2311 -> 2310;
2311 -> 1484;
2312 -> 2311;
2312 -> 1486;
2312 -> 1484;
2313 -> 1482;
2313 -> 1516;
2313 -> 1611;
2313 -> 2312;
2313 -> 1620;
2313 -> 1510;
2313 -> 1511;
2313 -> 2298;
2313 -> 1518;
2313 -> 1515;
2314 -> 1635;
2315 -> 2314;
2315 -> 1530;
2316 -> 2315;
2316 -> 1532;
2316 -> 1530;
2317 -> 1528;
2317 -> 1562;
2317 -> 1631;
2317 -> 2316;
2317 -> 1640;
2317 -> 1556;
2317 -> 1557;
2317 -> 2302;
2317 -> 1564;
2317 -> 1561;
2318 -> 1576;
2319 -> 2318;
2319 -> 1397;
2320 -> 2319;
2320 -> 1399;
2320 -> 1397;
2321 -> 1595;
2322 -> 2321;
2322 -> 1435;
2323 -> 2322;
2323 -> 1437;
2323 -> 1435;
2324 -> 1433;
2324 -> 1465;
2324 -> 1591;
2324 -> 2323;
2324 -> 1600;
2324 -> 1461;
2324 -> 1462;
2324 -> 2309;
2324 -> 1472;
2324 -> 1464;
2325 -> 1615;
2326 -> 2325;
2326 -> 1484;
2327 -> 2326;
2327 -> 1486;
2327 -> 1484;
2328 -> 1482;
2328 -> 1516;
2328 -> 1611;
2328 -> 2327;
2328 -> 1620;
2328 -> 1510;
2328 -> 1511;
2328 -> 2313;
2328 -> 1518;
2328 -> 1515;
2329 -> 1635;
2330 -> 2329;
2330 -> 1530;
2331 -> 2330;
2331 -> 1532;
2331 -> 1530;
2332 -> 1528;
2332 -> 1562;
2332 -> 1631;
2332 -> 2331;
2332 -> 1640;
2332 -> 1556;
2332 -> 1557;
2332 -> 2317;
2332 -> 1564;
2332 -> 1561;
2333 -> 1576;
2334 -> 2333;
2334 -> 1397;
2335 -> 2334;
2335 -> 1399;
2335 -> 1397;
2336 -> 1595;
2337 -> 2336;
2337 -> 1435;
2338 -> 2337;
2338 -> 1437;
2338 -> 1435;
2339 -> 1433;
2339 -> 1465;
2339 -> 1591;
2339 -> 2338;
2339 -> 1600;
2339 -> 1461;
2339 -> 1462;
2339 -> 2324;
2339 -> 1472;
2339 -> 1464;
2340 -> 1615;
2341 -> 2340;
2341 -> 1484;
2342 -> 2341;
2342 -> 1486;
2342 -> 1484;
2343 -> 1482;
2343 -> 1516;
2343 -> 1611;
2343 -> 2342;
2343 -> 1620;
2343 -> 1510;
2343 -> 1511;
2343 -> 2328;
2343 -> 1518;
2343 -> 1515;
2344 -> 1635;
2345 -> 2344;
2345 -> 1530;
2346 -> 2345;
2346 -> 1532;
2346 -> 1530;
2347 -> 1528;
2347 -> 1562;
2347 -> 1631;
2347 -> 2346;
2347 -> 1640;
2347 -> 1556;
2347 -> 1557;
2347 -> 2332;
2347 -> 1564;
2347 -> 1561;
2348 -> 1576;
2349 -> 2348;
2349 -> 1397;
2350 -> 2349;
2350 -> 1399;
2350 -> 1397;
2351 -> 1595;
2352 -> 2351;
2352 -> 1435;
2353 -> 2352;
2353 -> 1437;
2353 -> 1435;
2354 -> 1433;
2354 -> 1465;
2354 -> 1591;
2354 -> 2353;
2354 -> 1600;
2354 -> 1461;
2354 -> 1462;
2354 -> 2339;
2354 -> 1472;
2354 -> 1464;
2355 -> 1615;
2356 -> 2355;
2356 -> 1484;
2357 -> 2356;
2357 -> 1486;
2357 -> 1484;
2358 -> 1482;
2358 -> 1516;
2358 -> 1611;
2358 -> 2357;
2358 -> 1620;
2358 -> 1510;
2358 -> 1511;
2358 -> 2343;
2358 -> 1518;
2358 -> 1515;
2359 -> 1635;
2360 -> 2359;
2360 -> 1530;
2361 -> 2360;
2361 -> 1532;
2361 -> 1530;
2362 -> 1528;
2362 -> 1562;
2362 -> 1631;
2362 -> 2361;
2362 -> 1640;
2362 -> 1556;
2362 -> 1557;
2362 -> 2347;
2362 -> 1564;
2362 -> 1561;
2363 -> 1576;
2364 -> 2363;
2364 -> 1397;
2365 -> 2364;
2365 -> 1399;
2365 -> 1397;
2366 -> 1595;
2367 -> 2366;
2367 -> 1435;
2368 -> 2367;
2368 -> 1437;
2368 -> 1435;
2369 -> 1433;
2369 -> 1465;
2369 -> 1591;
2369 -> 2368;
2369 -> 1600;
2369 -> 1461;
2369 -> 1462;
2369 -> 2354;
2369 -> 1472;
2369 -> 1464;
2370 -> 1615;
2371 -> 2370;
2371 -> 1484;
2372 -> 2371;
2372 -> 1486;
2372 -> 1484;
2373 -> 1482;
2373 -> 1516;
2373 -> 1611;
2373 -> 2372;
2373 -> 1620;
2373 -> 1510;
2373 -> 1511;
2373 -> 2358;
2373 -> 1518;
2373 -> 1515;
2374 -> 1635;
2375 -> 2374;
2375 -> 1530;
2376 -> 2375;
2376 -> 1532;
2376 -> 1530;
2377 -> 1528;
2377 -> 1562;
2377 -> 1631;
2377 -> 2376;
2377 -> 1640;
2377 -> 1556;
2377 -> 1557;
2377 -> 2362;
2377 -> 1564;
2377 -> 1561;
2378 -> 1576;
2379 -> 2378;
2379 -> 1397;
2380 -> 2379;
2380 -> 1399;
2380 -> 1397;
2381 -> 1595;
2382 -> 2381;
2382 -> 1435;
2383 -> 2382;
2383 -> 1437;
2383 -> 1435;
2384 -> 1433;
2384 -> 1465;
2384 -> 1591;
2384 -> 2383;
2384 -> 1600;
2384 -> 1461;
2384 -> 1462;
2384 -> 2369;
2384 -> 1472;
2384 -> 1464;
2385 -> 1615;
2386 -> 2385;
2386 -> 1484;
2387 -> 2386;
2387 -> 1486;
2387 -> 1484;
2388 -> 1482;
2388 -> 1516;
2388 -> 1611;
2388 -> 2387;
2388 -> 1620;
2388 -> 1510;
2388 -> 1511;
2388 -> 2373;
2388 -> 1518;
2388 -> 1515;
2389 -> 1635;
2390 -> 2389;
2390 -> 1530;
2391 -> 2390;
2391 -> 1532;
2391 -> 1530;
2392 -> 1528;
2392 -> 1562;
2392 -> 1631;
2392 -> 2391;
2392 -> 1640;
2392 -> 1556;
2392 -> 1557;
2392 -> 2377;
2392 -> 1564;
2392 -> 1561;
2393 -> 1576;
2394 -> 2393;
2394 -> 1397;
2395 -> 2394;
2395 -> 1399;
2395 -> 1397;
2396 -> 1595;
2397 -> 2396;
2397 -> 1435;
2398 -> 2397;
2398 -> 1437;
2398 -> 1435;
2399 -> 1433;
2399 -> 1465;
2399 -> 1591;
2399 -> 2398;
2399 -> 1600;
2399 -> 1461;
2399 -> 1462;
2399 -> 2384;
2399 -> 1472;
2399 -> 1464;
2400 -> 1615;
2401 -> 2400;
2401 -> 1484;
2402 -> 2401;
2402 -> 1486;
2402 -> 1484;
2403 -> 1482;
2403 -> 1516;
2403 -> 1611;
2403 -> 2402;
2403 -> 1620;
2403 -> 1510;
2403 -> 1511;
2403 -> 2388;
2403 -> 1518;
2403 -> 1515;
2404 -> 1635;
2405 -> 2404;
2405 -> 1530;
2406 -> 2405;
2406 -> 1532;
2406 -> 1530;
2407 -> 1528;
2407 -> 1562;
2407 -> 1631;
2407 -> 2406;
2407 -> 1640;
2407 -> 1556;
2407 -> 1557;
2407 -> 2392;
2407 -> 1564;
2407 -> 1561;
2408 -> 1576;
2409 -> 2408;
2409 -> 1397;
2410 -> 2409;
2410 -> 1399;
2410 -> 1397;
2411 -> 1595;
2412 -> 2411;
2412 -> 1435;
2413 -> 2412;
2413 -> 1437;
2413 -> 1435;
2414 -> 1433;
2414 -> 1465;
2414 -> 1591;
2414 -> 2413;
2414 -> 1600;
2414 -> 1461;
2414 -> 1462;
2414 -> 2399;
2414 -> 1472;
2414 -> 1464;
2415 -> 1615;
2416 -> 2415;
2416 -> 1484;
2417 -> 2416;
2417 -> 1486;
2417 -> 1484;
2418 -> 1482;
2418 -> 1516;
2418 -> 1611;
2418 -> 2417;
2418 -> 1620;
2418 -> 1510;
2418 -> 1511;
2418 -> 2403;
2418 -> 1518;
2418 -> 1515;
2419 -> 1635;
2420 -> 2419;
2420 -> 1530;
2421 -> 2420;
2421 -> 1532;
2421 -> 1530;
2422 -> 1528;
2422 -> 1562;
2422 -> 1631;
2422 -> 2421;
2422 -> 1640;
2422 -> 1556;
2422 -> 1557;
2422 -> 2407;
2422 -> 1564;
2422 -> 1561;
2423 -> 1576;
2424 -> 2423;
2424 -> 1397;
2425 -> 2424;
2425 -> 1399;
2425 -> 1397;
2426 -> 1595;
2427 -> 2426;
2427 -> 1435;
2428 -> 2427;
2428 -> 1437;
2428 -> 1435;
2429 -> 1433;
2429 -> 1465;
2429 -> 1591;
2429 -> 2428;
2429 -> 1600;
2429 -> 1461;
2429 -> 1462;
2429 -> 2414;
2429 -> 1472;
2429 -> 1464;
2430 -> 1615;
2431 -> 2430;
2431 -> 1484;
2432 -> 2431;
2432 -> 1486;
2432 -> 1484;
2433 -> 1482;
2433 -> 1516;
2433 -> 1611;
2433 -> 2432;
2433 -> 1620;
2433 -> 1510;
2433 -> 1511;
2433 -> 2418;
2433 -> 1518;
2433 -> 1515;
2434 -> 1635;
2435 -> 2434;
2435 -> 1530;
2436 -> 2435;
2436 -> 1532;
2436 -> 1530;
2437 -> 1528;
2437 -> 1562;
2437 -> 1631;
2437 -> 2436;
2437 -> 1640;
2437 -> 1556;
2437 -> 1557;
2437 -> 2422;
2437 -> 1564;
2437 -> 1561;
2438 -> 1576;
2439 -> 2438;
2439 -> 1397;
2440 -> 2439;
2440 -> 1399;
2440 -> 1397;
2441 -> 1595;
2442 -> 2441;
2442 -> 1435;
2443 -> 2442;
2443 -> 1437;
2443 -> 1435;
2444 -> 1433;
2444 -> 1465;
2444 -> 1591;
2444 -> 2443;
2444 -> 1600;
2444 -> 1461;
2444 -> 1462;
2444 -> 2429;
2444 -> 1472;
2444 -> 1464;
2445 -> 1615;
2446 -> 2445;
2446 -> 1484;
2447 -> 2446;
2447 -> 1486;
2447 -> 1484;
2448 -> 1482;
2448 -> 1516;
2448 -> 1611;
2448 -> 2447;
2448 -> 1620;
2448 -> 1510;
2448 -> 1511;
2448 -> 2433;
2448 -> 1518;
2448 -> 1515;
2449 -> 1635;
2450 -> 2449;
2450 -> 1530;
2451 -> 2450;
2451 -> 1532;
2451 -> 1530;
2452 -> 1528;
2452 -> 1562;
2452 -> 1631;
2452 -> 2451;
2452 -> 1640;
2452 -> 1556;
2452 -> 1557;
2452 -> 2437;
2452 -> 1564;
2452 -> 1561;
2453 -> 1576;
2454 -> 2453;
2454 -> 1397;
2455 -> 2454;
2455 -> 1399;
2455 -> 1397;
2456 -> 1595;
2457 -> 2456;
2457 -> 1435;
2458 -> 2457;
2458 -> 1437;
2458 -> 1435;
2459 -> 1433;
2459 -> 1465;
2459 -> 1591;
2459 -> 2458;
2459 -> 1600;
2459 -> 1461;
2459 -> 1462;
2459 -> 2444;
2459 -> 1472;
2459 -> 1464;
2460 -> 1615;
2461 -> 2460;
2461 -> 1484;
2462 -> 2461;
2462 -> 1486;
2462 -> 1484;
2463 -> 1482;
2463 -> 1516;
2463 -> 1611;
2463 -> 2462;
2463 -> 1620;
2463 -> 1510;
2463 -> 1511;
2463 -> 2448;
2463 -> 1518;
2463 -> 1515;
2464 -> 1635;
2465 -> 2464;
2465 -> 1530;
2466 -> 2465;
2466 -> 1532;
2466 -> 1530;
2467 -> 1528;
2467 -> 1562;
2467 -> 1631;
2467 -> 2466;
2467 -> 1640;
2467 -> 1556;
2467 -> 1557;
2467 -> 2452;
2467 -> 1564;
2467 -> 1561;
2468 -> 1576;
2469 -> 2468;
2469 -> 1397;
2470 -> 2469;
2470 -> 1399;
2470 -> 1397;
2471 -> 1595;
2472 -> 2471;
2472 -> 1435;
2473 -> 2472;
2473 -> 1437;
2473 -> 1435;
2474 -> 1433;
2474 -> 1465;
2474 -> 1591;
2474 -> 2473;
2474 -> 1600;
2474 -> 1461;
2474 -> 1462;
2474 -> 2459;
2474 -> 1472;
2474 -> 1464;
2475 -> 1615;
2476 -> 2475;
2476 -> 1484;
2477 -> 2476;
2477 -> 1486;
2477 -> 1484;
2478 -> 1482;
2478 -> 1516;
2478 -> 1611;
2478 -> 2477;
2478 -> 1620;
2478 -> 1510;
2478 -> 1511;
2478 -> 2463;
2478 -> 1518;
2478 -> 1515;
2479 -> 1635;
2480 -> 2479;
2480 -> 1530;
2481 -> 2480;
2481 -> 1532;
2481 -> 1530;
2482 -> 1528;
2482 -> 1562;
2482 -> 1631;
2482 -> 2481;
2482 -> 1640;
2482 -> 1556;
2482 -> 1557;
2482 -> 2467;
2482 -> 1564;
2482 -> 1561;
2483 -> 1576;
2484 -> 2483;
2484 -> 1397;
2485 -> 2484;
2485 -> 1399;
2485 -> 1397;
2486 -> 1595;
2487 -> 2486;
2487 -> 1435;
2488 -> 2487;
2488 -> 1437;
2488 -> 1435;
2489 -> 1433;
2489 -> 1465;
2489 -> 1591;
2489 -> 2488;
2489 -> 1600;
2489 -> 1461;
2489 -> 1462;
2489 -> 2474;
2489 -> 1472;
2489 -> 1464;
2490 -> 1615;
2491 -> 2490;
2491 -> 1484;
2492 -> 2491;
2492 -> 1486;
2492 -> 1484;
2493 -> 1482;
2493 -> 1516;
2493 -> 1611;
2493 -> 2492;
2493 -> 1620;
2493 -> 1510;
2493 -> 1511;
2493 -> 2478;
2493 -> 1518;
2493 -> 1515;
2494 -> 1635;
2495 -> 2494;
2495 -> 1530;
2496 -> 2495;
2496 -> 1532;
2496 -> 1530;
2497 -> 1528;
2497 -> 1562;
2497 -> 1631;
2497 -> 2496;
2497 -> 1640;
2497 -> 1556;
2497 -> 1557;
2497 -> 2482;
2497 -> 1564;
2497 -> 1561;
2498 -> 1576;
2499 -> 2498;
2499 -> 1397;
2500 -> 2499;
2500 -> 1399;
2500 -> 1397;
2501 -> 1595;
2502 -> 2501;
2502 -> 1435;
2503 -> 2502;
2503 -> 1437;
2503 -> 1435;
2504 -> 1433;
2504 -> 1465;
2504 -> 1591;
2504 -> 2503;
2504 -> 1600;
2504 -> 1461;
2504 -> 1462;
2504 -> 2489;
2504 -> 1472;
2504 -> 1464;
2505 -> 1615;
2506 -> 2505;
2506 -> 1484;
2507 -> 2506;
2507 -> 1486;
2507 -> 1484;
2508 -> 1482;
2508 -> 1516;
2508 -> 1611;
2508 -> 2507;
2508 -> 1620;
2508 -> 1510;
2508 -> 1511;
2508 -> 2493;
2508 -> 1518;
2508 -> 1515;
2509 -> 1635;
2510 -> 2509;
2510 -> 1530;
2511 -> 2510;
2511 -> 1532;
2511 -> 1530;
2512 -> 1528;
2512 -> 1562;
2512 -> 1631;
2512 -> 2511;
2512 -> 1640;
2512 -> 1556;
2512 -> 1557;
2512 -> 2497;
2512 -> 1564;
2512 -> 1561;
2513 -> 1576;
2514 -> 2513;
2514 -> 1397;
2515 -> 2514;
2515 -> 1399;
2515 -> 1397;
2516 -> 1595;
2517 -> 2516;
2517 -> 1435;
2518 -> 2517;
2518 -> 1437;
2518 -> 1435;
2519 -> 1433;
2519 -> 1465;
2519 -> 1591;
2519 -> 2518;
2519 -> 1600;
2519 -> 1461;
2519 -> 1462;
2519 -> 2504;
2519 -> 1472;
2519 -> 1464;
2520 -> 1615;
2521 -> 2520;
2521 -> 1484;
2522 -> 2521;
2522 -> 1486;
2522 -> 1484;
2523 -> 1482;
2523 -> 1516;
2523 -> 1611;
2523 -> 2522;
2523 -> 1620;
2523 -> 1510;
2523 -> 1511;
2523 -> 2508;
2523 -> 1518;
2523 -> 1515;
2524 -> 1635;
2525 -> 2524;
2525 -> 1530;
2526 -> 2525;
2526 -> 1532;
2526 -> 1530;
2527 -> 1528;
2527 -> 1562;
2527 -> 1631;
2527 -> 2526;
2527 -> 1640;
2527 -> 1556;
2527 -> 1557;
2527 -> 2512;
2527 -> 1564;
2527 -> 1561;
2528 -> 1576;
2529 -> 2528;
2529 -> 1397;
2530 -> 2529;
2530 -> 1399;
2530 -> 1397;
2531 -> 1595;
2532 -> 2531;
2532 -> 1435;
2533 -> 2532;
2533 -> 1437;
2533 -> 1435;
2534 -> 1433;
2534 -> 1465;
2534 -> 1591;
2534 -> 2533;
2534 -> 1600;
2534 -> 1461;
2534 -> 1462;
2534 -> 2519;
2534 -> 1472;
2534 -> 1464;
2535 -> 1615;
2536 -> 2535;
2536 -> 1484;
2537 -> 2536;
2537 -> 1486;
2537 -> 1484;
2538 -> 1482;
2538 -> 1516;
2538 -> 1611;
2538 -> 2537;
2538 -> 1620;
2538 -> 1510;
2538 -> 1511;
2538 -> 2523;
2538 -> 1518;
2538 -> 1515;
2539 -> 1635;
2540 -> 2539;
2540 -> 1530;
2541 -> 2540;
2541 -> 1532;
2541 -> 1530;
2542 -> 1528;
2542 -> 1562;
2542 -> 1631;
2542 -> 2541;
2542 -> 1640;
2542 -> 1556;
2542 -> 1557;
2542 -> 2527;
2542 -> 1564;
2542 -> 1561;
2543 -> 1576;
2544 -> 2543;
2544 -> 1397;
2545 -> 2544;
2545 -> 1399;
2545 -> 1397;
2546 -> 1595;
2547 -> 2546;
2547 -> 1435;
2548 -> 2547;
2548 -> 1437;
2548 -> 1435;
2549 -> 1433;
2549 -> 1465;
2549 -> 1591;
2549 -> 2548;
2549 -> 1600;
2549 -> 1461;
2549 -> 1462;
2549 -> 2534;
2549 -> 1472;
2549 -> 1464;
2550 -> 1615;
2551 -> 2550;
2551 -> 1484;
2552 -> 2551;
2552 -> 1486;
2552 -> 1484;
2553 -> 1482;
2553 -> 1516;
2553 -> 1611;
2553 -> 2552;
2553 -> 1620;
2553 -> 1510;
2553 -> 1511;
2553 -> 2538;
2553 -> 1518;
2553 -> 1515;
2554 -> 1635;
2555 -> 2554;
2555 -> 1530;
2556 -> 2555;
2556 -> 1532;
2556 -> 1530;
2557 -> 1528;
2557 -> 1562;
2557 -> 1631;
2557 -> 2556;
2557 -> 1640;
2557 -> 1556;
2557 -> 1557;
2557 -> 2542;
2557 -> 1564;
2557 -> 1561;
2558 -> 1576;
2559 -> 2558;
2559 -> 1397;
2560 -> 2559;
2560 -> 1399;
2560 -> 1397;
2561 -> 1595;
2562 -> 2561;
2562 -> 1435;
2563 -> 2562;
2563 -> 1437;
2563 -> 1435;
2564 -> 1433;
2564 -> 1465;
2564 -> 1591;
2564 -> 2563;
2564 -> 1600;
2564 -> 1461;
2564 -> 1462;
2564 -> 2549;
2564 -> 1472;
2564 -> 1464;
2565 -> 1615;
2566 -> 2565;
2566 -> 1484;
2567 -> 2566;
2567 -> 1486;
2567 -> 1484;
2568 -> 1482;
2568 -> 1516;
2568 -> 1611;
2568 -> 2567;
2568 -> 1620;
2568 -> 1510;
2568 -> 1511;
2568 -> 2553;
2568 -> 1518;
2568 -> 1515;
2569 -> 1635;
2570 -> 2569;
2570 -> 1530;
2571 -> 2570;
2571 -> 1532;
2571 -> 1530;
2572 -> 1528;
2572 -> 1562;
2572 -> 1631;
2572 -> 2571;
2572 -> 1640;
2572 -> 1556;
2572 -> 1557;
2572 -> 2557;
2572 -> 1564;
2572 -> 1561;
2573 -> 1576;
2574 -> 2573;
2574 -> 1397;
2575 -> 2574;
2575 -> 1399;
2575 -> 1397;
2576 -> 1595;
2577 -> 2576;
2577 -> 1435;
2578 -> 2577;
2578 -> 1437;
2578 -> 1435;
2579 -> 1433;
2579 -> 1465;
2579 -> 1591;
2579 -> 2578;
2579 -> 1600;
2579 -> 1461;
2579 -> 1462;
2579 -> 2564;
2579 -> 1472;
2579 -> 1464;
2580 -> 1615;
2581 -> 2580;
2581 -> 1484;
2582 -> 2581;
2582 -> 1486;
2582 -> 1484;
2583 -> 1482;
2583 -> 1516;
2583 -> 1611;
2583 -> 2582;
2583 -> 1620;
2583 -> 1510;
2583 -> 1511;
2583 -> 2568;
2583 -> 1518;
2583 -> 1515;
2584 -> 1635;
2585 -> 2584;
2585 -> 1530;
2586 -> 2585;
2586 -> 1532;
2586 -> 1530;
2587 -> 1528;
2587 -> 1562;
2587 -> 1631;
2587 -> 2586;
2587 -> 1640;
2587 -> 1556;
2587 -> 1557;
2587 -> 2572;
2587 -> 1564;
2587 -> 1561;
2588 -> 1576;
2589 -> 2588;
2589 -> 1397;
2590 -> 2589;
2590 -> 1399;
2590 -> 1397;
2591 -> 1595;
2592 -> 2591;
2592 -> 1435;
2593 -> 2592;
2593 -> 1437;
2593 -> 1435;
2594 -> 1433;
2594 -> 1465;
2594 -> 1591;
2594 -> 2593;
2594 -> 1600;
2594 -> 1461;
2594 -> 1462;
2594 -> 2579;
2594 -> 1472;
2594 -> 1464;
2595 -> 1615;
2596 -> 2595;
2596 -> 1484;
2597 -> 2596;
2597 -> 1486;
2597 -> 1484;
2598 -> 1482;
2598 -> 1516;
2598 -> 1611;
2598 -> 2597;
2598 -> 1620;
2598 -> 1510;
2598 -> 1511;
2598 -> 2583;
2598 -> 1518;
2598 -> 1515;
2599 -> 1635;
2600 -> 2599;
2600 -> 1530;
2601 -> 2600;
2601 -> 1532;
2601 -> 1530;
2602 -> 1528;
2602 -> 1562;
2602 -> 1631;
2602 -> 2601;
2602 -> 1640;
2602 -> 1556;
2602 -> 1557;
2602 -> 2587;
2602 -> 1564;
2602 -> 1561;
2603 -> 1576;
2604 -> 2603;
2604 -> 1397;
2605 -> 2604;
2605 -> 1399;
2605 -> 1397;
2606 -> 1595;
2607 -> 2606;
2607 -> 1435;
2608 -> 2607;
2608 -> 1437;
2608 -> 1435;
2609 -> 1433;
2609 -> 1465;
2609 -> 1591;
2609 -> 2608;
2609 -> 1600;
2609 -> 1461;
2609 -> 1462;
2609 -> 2594;
2609 -> 1472;
2609 -> 1464;
2610 -> 1615;
2611 -> 2610;
2611 -> 1484;
2612 -> 2611;
2612 -> 1486;
2612 -> 1484;
2613 -> 1482;
2613 -> 1516;
2613 -> 1611;
2613 -> 2612;
2613 -> 1620;
2613 -> 1510;
2613 -> 1511;
2613 -> 2598;
2613 -> 1518;
2613 -> 1515;
2614 -> 1635;
2615 -> 2614;
2615 -> 1530;
2616 -> 2615;
2616 -> 1532;
2616 -> 1530;
2617 -> 1528;
2617 -> 1562;
2617 -> 1631;
2617 -> 2616;
2617 -> 1640;
2617 -> 1556;
2617 -> 1557;
2617 -> 2602;
2617 -> 1564;
2617 -> 1561;
2618 -> 1576;
2619 -> 2618;
2619 -> 1397;
2620 -> 2619;
2620 -> 1399;
2620 -> 1397;
2621 -> 1595;
2622 -> 2621;
2622 -> 1435;
2623 -> 2622;
2623 -> 1437;
2623 -> 1435;
2624 -> 1433;
2624 -> 1465;
2624 -> 1591;
2624 -> 2623;
2624 -> 1600;
2624 -> 1461;
2624 -> 1462;
2624 -> 2609;
2624 -> 1472;
2624 -> 1464;
2625 -> 1615;
2626 -> 2625;
2626 -> 1484;
2627 -> 2626;
2627 -> 1486;
2627 -> 1484;
2628 -> 1482;
2628 -> 1516;
2628 -> 1611;
2628 -> 2627;
2628 -> 1620;
2628 -> 1510;
2628 -> 1511;
2628 -> 2613;
2628 -> 1518;
2628 -> 1515;
2629 -> 1635;
2630 -> 2629;
2630 -> 1530;
2631 -> 2630;
2631 -> 1532;
2631 -> 1530;
2632 -> 1528;
2632 -> 1562;
2632 -> 1631;
2632 -> 2631;
2632 -> 1640;
2632 -> 1556;
2632 -> 1557;
2632 -> 2617;
2632 -> 1564;
2632 -> 1561;
2633 -> 1576;
2634 -> 2633;
2634 -> 1397;
2635 -> 2634;
2635 -> 1399;
2635 -> 1397;
2636 -> 1595;
2637 -> 2636;
2637 -> 1435;
2638 -> 2637;
2638 -> 1437;
2638 -> 1435;
2639 -> 1433;
2639 -> 1465;
2639 -> 1591;
2639 -> 2638;
2639 -> 1600;
2639 -> 1461;
2639 -> 1462;
2639 -> 2624;
2639 -> 1472;
2639 -> 1464;
2640 -> 1615;
2641 -> 2640;
2641 -> 1484;
2642 -> 2641;
2642 -> 1486;
2642 -> 1484;
2643 -> 1482;
2643 -> 1516;
2643 -> 1611;
2643 -> 2642;
2643 -> 1620;
2643 -> 1510;
2643 -> 1511;
2643 -> 2628;
2643 -> 1518;
2643 -> 1515;
2644 -> 1635;
2645 -> 2644;
2645 -> 1530;
2646 -> 2645;
2646 -> 1532;
2646 -> 1530;
2647 -> 1528;
2647 -> 1562;
2647 -> 1631;
2647 -> 2646;
2647 -> 1640;
2647 -> 1556;
2647 -> 1557;
2647 -> 2632;
2647 -> 1564;
2647 -> 1561;
2648 -> 1576;
2649 -> 2648;
2649 -> 1397;
2650 -> 2649;
2650 -> 1399;
2650 -> 1397;
2651 -> 1595;
2652 -> 2651;
2652 -> 1435;
2653 -> 2652;
2653 -> 1437;
2653 -> 1435;
2654 -> 1433;
2654 -> 1465;
2654 -> 1591;
2654 -> 2653;
2654 -> 1600;
2654 -> 1461;
2654 -> 1462;
2654 -> 2639;
2654 -> 1472;
2654 -> 1464;
2655 -> 1615;
2656 -> 2655;
2656 -> 1484;
2657 -> 2656;
2657 -> 1486;
2657 -> 1484;
2658 -> 1482;
2658 -> 1516;
2658 -> 1611;
2658 -> 2657;
2658 -> 1620;
2658 -> 1510;
2658 -> 1511;
2658 -> 2643;
2658 -> 1518;
2658 -> 1515;
2659 -> 1635;
2660 -> 2659;
2660 -> 1530;
2661 -> 2660;
2661 -> 1532;
2661 -> 1530;
2662 -> 1528;
2662 -> 1562;
2662 -> 1631;
2662 -> 2661;
2662 -> 1640;
2662 -> 1556;
2662 -> 1557;
2662 -> 2647;
2662 -> 1564;
2662 -> 1561;
2663 -> 1576;
2664 -> 2663;
2664 -> 1397;
2665 -> 2664;
2665 -> 1399;
2665 -> 1397;
2666 -> 1595;
2667 -> 2666;
2667 -> 1435;
2668 -> 2667;
2668 -> 1437;
2668 -> 1435;
2669 -> 1433;
2669 -> 1465;
2669 -> 1591;
2669 -> 2668;
2669 -> 1600;
2669 -> 1461;
2669 -> 1462;
2669 -> 2654;
2669 -> 1472;
2669 -> 1464;
2670 -> 1615;
2671 -> 2670;
2671 -> 1484;
2672 -> 2671;
2672 -> 1486;
2672 -> 1484;
2673 -> 1482;
2673 -> 1516;
2673 -> 1611;
2673 -> 2672;
2673 -> 1620;
2673 -> 1510;
2673 -> 1511;
2673 -> 2658;
2673 -> 1518;
2673 -> 1515;
2674 -> 1635;
2675 -> 2674;
2675 -> 1530;
2676 -> 2675;
2676 -> 1532;
2676 -> 1530;
2677 -> 1528;
2677 -> 1562;
2677 -> 1631;
2677 -> 2676;
2677 -> 1640;
2677 -> 1556;
2677 -> 1557;
2677 -> 2662;
2677 -> 1564;
2677 -> 1561;
2678 -> 1576;
2679 -> 2678;
2679 -> 1397;
2680 -> 2679;
2680 -> 1399;
2680 -> 1397;
2681 -> 1595;
2682 -> 2681;
2682 -> 1435;
2683 -> 2682;
2683 -> 1437;
2683 -> 1435;
2684 -> 1433;
2684 -> 1465;
2684 -> 1591;
2684 -> 2683;
2684 -> 1600;
2684 -> 1461;
2684 -> 1462;
2684 -> 2669;
2684 -> 1472;
2684 -> 1464;
2685 -> 1615;
2686 -> 2685;
2686 -> 1484;
2687 -> 2686;
2687 -> 1486;
2687 -> 1484;
2688 -> 1482;
2688 -> 1516;
2688 -> 1611;
2688 -> 2687;
2688 -> 1620;
2688 -> 1510;
2688 -> 1511;
2688 -> 2673;
2688 -> 1518;
2688 -> 1515;
2689 -> 1635;
2690 -> 2689;
2690 -> 1530;
2691 -> 2690;
2691 -> 1532;
2691 -> 1530;
2692 -> 1528;
2692 -> 1562;
2692 -> 1631;
2692 -> 2691;
2692 -> 1640;
2692 -> 1556;
2692 -> 1557;
2692 -> 2677;
2692 -> 1564;
2692 -> 1561;
2693 -> 1576;
2694 -> 2693;
2694 -> 1397;
2695 -> 2694;
2695 -> 1399;
2695 -> 1397;
2696 -> 1595;
2697 -> 2696;
2697 -> 1435;
2698 -> 2697;
2698 -> 1437;
2698 -> 1435;
2699 -> 1433;
2699 -> 1465;
2699 -> 1591;
2699 -> 2698;
2699 -> 1600;
2699 -> 1461;
2699 -> 1462;
2699 -> 2684;
2699 -> 1472;
2699 -> 1464;
2700 -> 1615;
2701 -> 2700;
2701 -> 1484;
2702 -> 2701;
2702 -> 1486;
2702 -> 1484;
2703 -> 1482;
2703 -> 1516;
2703 -> 1611;
2703 -> 2702;
2703 -> 1620;
2703 -> 1510;
2703 -> 1511;
2703 -> 2688;
2703 -> 1518;
2703 -> 1515;
2704 -> 1635;
2705 -> 2704;
2705 -> 1530;
2706 -> 2705;
2706 -> 1532;
2706 -> 1530;
2707 -> 1528;
2707 -> 1562;
2707 -> 1631;
2707 -> 2706;
2707 -> 1640;
2707 -> 1556;
2707 -> 1557;
2707 -> 2692;
2707 -> 1564;
2707 -> 1561;
2708 -> 1576;
2709 -> 2708;
2709 -> 1397;
2710 -> 2709;
2710 -> 1399;
2710 -> 1397;
2711 -> 1595;
2712 -> 2711;
2712 -> 1435;
2713 -> 2712;
2713 -> 1437;
2713 -> 1435;
2714 -> 1433;
2714 -> 1465;
2714 -> 1591;
2714 -> 2713;
2714 -> 1600;
2714 -> 1461;
2714 -> 1462;
2714 -> 2699;
2714 -> 1472;
2714 -> 1464;
2715 -> 1615;
2716 -> 2715;
2716 -> 1484;
2717 -> 2716;
2717 -> 1486;
2717 -> 1484;
2718 -> 1482;
2718 -> 1516;
2718 -> 1611;
2718 -> 2717;
2718 -> 1620;
2718 -> 1510;
2718 -> 1511;
2718 -> 2703;
2718 -> 1518;
2718 -> 1515;
2719 -> 1635;
2720 -> 2719;
2720 -> 1530;
2721 -> 2720;
2721 -> 1532;
2721 -> 1530;
2722 -> 1528;
2722 -> 1562;
2722 -> 1631;
2722 -> 2721;
2722 -> 1640;
2722 -> 1556;
2722 -> 1557;
2722 -> 2707;
2722 -> 1564;
2722 -> 1561;
2723 -> 1576;
2724 -> 2723;
2724 -> 1397;
2725 -> 2724;
2725 -> 1399;
2725 -> 1397;
2726 -> 1595;
2727 -> 2726;
2727 -> 1435;
2728 -> 2727;
2728 -> 1437;
2728 -> 1435;
2729 -> 1433;
2729 -> 1465;
2729 -> 1591;
2729 -> 2728;
2729 -> 1600;
2729 -> 1461;
2729 -> 1462;
2729 -> 2714;
2729 -> 1472;
2729 -> 1464;
2730 -> 1615;
2731 -> 2730;
2731 -> 1484;
2732 -> 2731;
2732 -> 1486;
2732 -> 1484;
2733 -> 1482;
2733 -> 1516;
2733 -> 1611;
2733 -> 2732;
2733 -> 1620;
2733 -> 1510;
2733 -> 1511;
2733 -> 2718;
2733 -> 1518;
2733 -> 1515;
2734 -> 1635;
2735 -> 2734;
2735 -> 1530;
2736 -> 2735;
2736 -> 1532;
2736 -> 1530;
2737 -> 1528;
2737 -> 1562;
2737 -> 1631;
2737 -> 2736;
2737 -> 1640;
2737 -> 1556;
2737 -> 1557;
2737 -> 2722;
2737 -> 1564;
2737 -> 1561;
2738 -> 1576;
2739 -> 2738;
2739 -> 1397;
2740 -> 2739;
2740 -> 1399;
2740 -> 1397;
2741 -> 1595;
2742 -> 2741;
2742 -> 1435;
2743 -> 2742;
2743 -> 1437;
2743 -> 1435;
2744 -> 1433;
2744 -> 1465;
2744 -> 1591;
2744 -> 2743;
2744 -> 1600;
2744 -> 1461;
2744 -> 1462;
2744 -> 2729;
2744 -> 1472;
2744 -> 1464;
2745 -> 1615;
2746 -> 2745;
2746 -> 1484;
2747 -> 2746;
2747 -> 1486;
2747 -> 1484;
2748 -> 1482;
2748 -> 1516;
2748 -> 1611;
2748 -> 2747;
2748 -> 1620;
2748 -> 1510;
2748 -> 1511;
2748 -> 2733;
2748 -> 1518;
2748 -> 1515;
2749 -> 1635;
2750 -> 2749;
2750 -> 1530;
2751 -> 2750;
2751 -> 1532;
2751 -> 1530;
2752 -> 1528;
2752 -> 1562;
2752 -> 1631;
2752 -> 2751;
2752 -> 1640;
2752 -> 1556;
2752 -> 1557;
2752 -> 2737;
2752 -> 1564;
2752 -> 1561;
2753 -> 1576;
2754 -> 2753;
2754 -> 1397;
2755 -> 2754;
2755 -> 1399;
2755 -> 1397;
2756 -> 1595;
2757 -> 2756;
2757 -> 1435;
2758 -> 2757;
2758 -> 1437;
2758 -> 1435;
2759 -> 1433;
2759 -> 1465;
2759 -> 1591;
2759 -> 2758;
2759 -> 1600;
2759 -> 1461;
2759 -> 1462;
2759 -> 2744;
2759 -> 1472;
2759 -> 1464;
2760 -> 1615;
2761 -> 2760;
2761 -> 1484;
2762 -> 2761;
2762 -> 1486;
2762 -> 1484;
2763 -> 1482;
2763 -> 1516;
2763 -> 1611;
2763 -> 2762;
2763 -> 1620;
2763 -> 1510;
2763 -> 1511;
2763 -> 2748;
2763 -> 1518;
2763 -> 1515;
2764 -> 1635;
2765 -> 2764;
2765 -> 1530;
2766 -> 2765;
2766 -> 1532;
2766 -> 1530;
2767 -> 1528;
2767 -> 1562;
2767 -> 1631;
2767 -> 2766;
2767 -> 1640;
2767 -> 1556;
2767 -> 1557;
2767 -> 2752;
2767 -> 1564;
2767 -> 1561;
2768 -> 1576;
2769 -> 2768;
2769 -> 1397;
2770 -> 2769;
2770 -> 1399;
2770 -> 1397;
2771 -> 1595;
2772 -> 2771;
2772 -> 1435;
2773 -> 2772;
2773 -> 1437;
2773 -> 1435;
2774 -> 1433;
2774 -> 1465;
2774 -> 1591;
2774 -> 2773;
2774 -> 1600;
2774 -> 1461;
2774 -> 1462;
2774 -> 2759;
2774 -> 1472;
2774 -> 1464;
2775 -> 1615;
2776 -> 2775;
2776 -> 1484;
2777 -> 2776;
2777 -> 1486;
2777 -> 1484;
2778 -> 1482;
2778 -> 1516;
2778 -> 1611;
2778 -> 2777;
2778 -> 1620;
2778 -> 1510;
2778 -> 1511;
2778 -> 2763;
2778 -> 1518;
2778 -> 1515;
2779 -> 1635;
2780 -> 2779;
2780 -> 1530;
2781 -> 2780;
2781 -> 1532;
2781 -> 1530;
2782 -> 1528;
2782 -> 1562;
2782 -> 1631;
2782 -> 2781;
2782 -> 1640;
2782 -> 1556;
2782 -> 1557;
2782 -> 2767;
2782 -> 1564;
2782 -> 1561;
2783 -> 1576;
2784 -> 2783;
2784 -> 1397;
2785 -> 2784;
2785 -> 1399;
2785 -> 1397;
2786 -> 1595;
2787 -> 2786;
2787 -> 1435;
2788 -> 2787;
2788 -> 1437;
2788 -> 1435;
2789 -> 1433;
2789 -> 1465;
2789 -> 1591;
2789 -> 2788;
2789 -> 1600;
2789 -> 1461;
2789 -> 1462;
2789 -> 2774;
2789 -> 1472;
2789 -> 1464;
2790 -> 1615;
2791 -> 2790;
2791 -> 1484;
2792 -> 2791;
2792 -> 1486;
2792 -> 1484;
2793 -> 1482;
2793 -> 1516;
2793 -> 1611;
2793 -> 2792;
2793 -> 1620;
2793 -> 1510;
2793 -> 1511;
2793 -> 2778;
2793 -> 1518;
2793 -> 1515;
2794 -> 1635;
2795 -> 2794;
2795 -> 1530;
2796 -> 2795;
2796 -> 1532;
2796 -> 1530;
2797 -> 1528;
2797 -> 1562;
2797 -> 1631;
2797 -> 2796;
2797 -> 1640;
2797 -> 1556;
2797 -> 1557;
2797 -> 2782;
2797 -> 1564;
2797 -> 1561;
2798 -> 1576;
2799 -> 2798;
2799 -> 1397;
2800 -> 2799;
2800 -> 1399;
2800 -> 1397;
2801 -> 1595;
2802 -> 2801;
2802 -> 1435;
2803 -> 2802;
2803 -> 1437;
2803 -> 1435;
2804 -> 1433;
2804 -> 1465;
2804 -> 1591;
2804 -> 2803;
2804 -> 1600;
2804 -> 1461;
2804 -> 1462;
2804 -> 2789;
2804 -> 1472;
2804 -> 1464;
2805 -> 1615;
2806 -> 2805;
2806 -> 1484;
2807 -> 2806;
2807 -> 1486;
2807 -> 1484;
2808 -> 1482;
2808 -> 1516;
2808 -> 1611;
2808 -> 2807;
2808 -> 1620;
2808 -> 1510;
2808 -> 1511;
2808 -> 2793;
2808 -> 1518;
2808 -> 1515;
2809 -> 1635;
2810 -> 2809;
2810 -> 1530;
2811 -> 2810;
2811 -> 1532;
2811 -> 1530;
2812 -> 1528;
2812 -> 1562;
2812 -> 1631;
2812 -> 2811;
2812 -> 1640;
2812 -> 1556;
2812 -> 1557;
2812 -> 2797;
2812 -> 1564;
2812 -> 1561;
2813 -> 1576;
2814 -> 2813;
2814 -> 1397;
2815 -> 2814;
2815 -> 1399;
2815 -> 1397;
2816 -> 1595;
2817 -> 2816;
2817 -> 1435;
2818 -> 2817;
2818 -> 1437;
2818 -> 1435;
2819 -> 1433;
2819 -> 1465;
2819 -> 1591;
2819 -> 2818;
2819 -> 1600;
2819 -> 1461;
2819 -> 1462;
2819 -> 2804;
2819 -> 1472;
2819 -> 1464;
2820 -> 1615;
2821 -> 2820;
2821 -> 1484;
2822 -> 2821;
2822 -> 1486;
2822 -> 1484;
2823 -> 1482;
2823 -> 1516;
2823 -> 1611;
2823 -> 2822;
2823 -> 1620;
2823 -> 1510;
2823 -> 1511;
2823 -> 2808;
2823 -> 1518;
2823 -> 1515;
2824 -> 1635;
2825 -> 2824;
2825 -> 1530;
2826 -> 2825;
2826 -> 1532;
2826 -> 1530;
2827 -> 1528;
2827 -> 1562;
2827 -> 1631;
2827 -> 2826;
2827 -> 1640;
2827 -> 1556;
2827 -> 1557;
2827 -> 2812;
2827 -> 1564;
2827 -> 1561;
2828 -> 1576;
2829 -> 2828;
2829 -> 1397;
2830 -> 2829;
2830 -> 1399;
2830 -> 1397;
2831 -> 1595;
2832 -> 2831;
2832 -> 1435;
2833 -> 2832;
2833 -> 1437;
2833 -> 1435;
2834 -> 1433;
2834 -> 1465;
2834 -> 1591;
2834 -> 2833;
2834 -> 1600;
2834 -> 1461;
2834 -> 1462;
2834 -> 2819;
2834 -> 1472;
2834 -> 1464;
2835 -> 1615;
2836 -> 2835;
2836 -> 1484;
2837 -> 2836;
2837 -> 1486;
2837 -> 1484;
2838 -> 1482;
2838 -> 1516;
2838 -> 1611;
2838 -> 2837;
2838 -> 1620;
2838 -> 1510;
2838 -> 1511;
2838 -> 2823;
2838 -> 1518;
2838 -> 1515;
2839 -> 1635;
2840 -> 2839;
2840 -> 1530;
2841 -> 2840;
2841 -> 1532;
2841 -> 1530;
2842 -> 1528;
2842 -> 1562;
2842 -> 1631;
2842 -> 2841;
2842 -> 1640;
2842 -> 1556;
2842 -> 1557;
2842 -> 2827;
2842 -> 1564;
2842 -> 1561;
2843 -> 1576;
2844 -> 2843;
2844 -> 1397;
2845 -> 2844;
2845 -> 1399;
2845 -> 1397;
2846 -> 1595;
2847 -> 2846;
2847 -> 1435;
2848 -> 2847;
2848 -> 1437;
2848 -> 1435;
2849 -> 1433;
2849 -> 1465;
2849 -> 1591;
2849 -> 2848;
2849 -> 1600;
2849 -> 1461;
2849 -> 1462;
2849 -> 2834;
2849 -> 1472;
2849 -> 1464;
2850 -> 1615;
2851 -> 2850;
2851 -> 1484;
2852 -> 2851;
2852 -> 1486;
2852 -> 1484;
2853 -> 1482;
2853 -> 1516;
2853 -> 1611;
2853 -> 2852;
2853 -> 1620;
2853 -> 1510;
2853 -> 1511;
2853 -> 2838;
2853 -> 1518;
2853 -> 1515;
2854 -> 1635;
2855 -> 2854;
2855 -> 1530;
2856 -> 2855;
2856 -> 1532;
2856 -> 1530;
2857 -> 1528;
2857 -> 1562;
2857 -> 1631;
2857 -> 2856;
2857 -> 1640;
2857 -> 1556;
2857 -> 1557;
2857 -> 2842;
2857 -> 1564;
2857 -> 1561;
2858 -> 1576;
2859 -> 2858;
2859 -> 1397;
2860 -> 2859;
2860 -> 1399;
2860 -> 1397;
2861 -> 1595;
2862 -> 2861;
2862 -> 1435;
2863 -> 2862;
2863 -> 1437;
2863 -> 1435;
2864 -> 1433;
2864 -> 1465;
2864 -> 1591;
2864 -> 2863;
2864 -> 1600;
2864 -> 1461;
2864 -> 1462;
2864 -> 2849;
2864 -> 1472;
2864 -> 1464;
2865 -> 1615;
2866 -> 2865;
2866 -> 1484;
2867 -> 2866;
2867 -> 1486;
2867 -> 1484;
2868 -> 1482;
2868 -> 1516;
2868 -> 1611;
2868 -> 2867;
2868 -> 1620;
2868 -> 1510;
2868 -> 1511;
2868 -> 2853;
2868 -> 1518;
2868 -> 1515;
2869 -> 1635;
2870 -> 2869;
2870 -> 1530;
2871 -> 2870;
2871 -> 1532;
2871 -> 1530;
2872 -> 1528;
2872 -> 1562;
2872 -> 1631;
2872 -> 2871;
2872 -> 1640;
2872 -> 1556;
2872 -> 1557;
2872 -> 2857;
2872 -> 1564;
2872 -> 1561;
2873 -> 1576;
2874 -> 2873;
2874 -> 1397;
2875 -> 2874;
2875 -> 1399;
2875 -> 1397;
2876 -> 1595;
2877 -> 2876;
2877 -> 1435;
2878 -> 2877;
2878 -> 1437;
2878 -> 1435;
2879 -> 1433;
2879 -> 1465;
2879 -> 1591;
2879 -> 2878;
2879 -> 1600;
2879 -> 1461;
2879 -> 1462;
2879 -> 2864;
2879 -> 1472;
2879 -> 1464;
2880 -> 1615;
2881 -> 2880;
2881 -> 1484;
2882 -> 2881;
2882 -> 1486;
2882 -> 1484;
2883 -> 1482;
2883 -> 1516;
2883 -> 1611;
2883 -> 2882;
2883 -> 1620;
2883 -> 1510;
2883 -> 1511;
2883 -> 2868;
2883 -> 1518;
2883 -> 1515;
2884 -> 1635;
2885 -> 2884;
2885 -> 1530;
2886 -> 2885;
2886 -> 1532;
2886 -> 1530;
2887 -> 1528;
2887 -> 1562;
2887 -> 1631;
2887 -> 2886;
2887 -> 1640;
2887 -> 1556;
2887 -> 1557;
2887 -> 2872;
2887 -> 1564;
2887 -> 1561;
2888 -> 1576;
2889 -> 2888;
2889 -> 1397;
2890 -> 2889;
2890 -> 1399;
2890 -> 1397;
2891 -> 1595;
2892 -> 2891;
2892 -> 1435;
2893 -> 2892;
2893 -> 1437;
2893 -> 1435;
2894 -> 1433;
2894 -> 1465;
2894 -> 1591;
2894 -> 2893;
2894 -> 1600;
2894 -> 1461;
2894 -> 1462;
2894 -> 2879;
2894 -> 1472;
2894 -> 1464;
2895 -> 1615;
2896 -> 2895;
2896 -> 1484;
2897 -> 2896;
2897 -> 1486;
2897 -> 1484;
2898 -> 1482;
2898 -> 1516;
2898 -> 1611;
2898 -> 2897;
2898 -> 1620;
2898 -> 1510;
2898 -> 1511;
2898 -> 2883;
2898 -> 1518;
2898 -> 1515;
2899 -> 1635;
2900 -> 2899;
2900 -> 1530;
2901 -> 2900;
2901 -> 1532;
2901 -> 1530;
2902 -> 1528;
2902 -> 1562;
2902 -> 1631;
2902 -> 2901;
2902 -> 1640;
2902 -> 1556;
2902 -> 1557;
2902 -> 2887;
2902 -> 1564;
2902 -> 1561;
2903 -> 1576;
2904 -> 2903;
2904 -> 1397;
2905 -> 2904;
2905 -> 1399;
2905 -> 1397;
2906 -> 1595;
2907 -> 2906;
2907 -> 1435;
2908 -> 2907;
2908 -> 1437;
2908 -> 1435;
2909 -> 1433;
2909 -> 1465;
2909 -> 1591;
2909 -> 2908;
2909 -> 1600;
2909 -> 1461;
2909 -> 1462;
2909 -> 2894;
2909 -> 1472;
2909 -> 1464;
2910 -> 1615;
2911 -> 2910;
2911 -> 1484;
2912 -> 2911;
2912 -> 1486;
2912 -> 1484;
2913 -> 1482;
2913 -> 1516;
2913 -> 1611;
2913 -> 2912;
2913 -> 1620;
2913 -> 1510;
2913 -> 1511;
2913 -> 2898;
2913 -> 1518;
2913 -> 1515;
2914 -> 1635;
2915 -> 2914;
2915 -> 1530;
2916 -> 2915;
2916 -> 1532;
2916 -> 1530;
2917 -> 1528;
2917 -> 1562;
2917 -> 1631;
2917 -> 2916;
2917 -> 1640;
2917 -> 1556;
2917 -> 1557;
2917 -> 2902;
2917 -> 1564;
2917 -> 1561;
2918 -> 1576;
2919 -> 2918;
2919 -> 1397;
2920 -> 2919;
2920 -> 1399;
2920 -> 1397;
2921 -> 1595;
2922 -> 2921;
2922 -> 1435;
2923 -> 2922;
2923 -> 1437;
2923 -> 1435;
2924 -> 1433;
2924 -> 1465;
2924 -> 1591;
2924 -> 2923;
2924 -> 1600;
2924 -> 1461;
2924 -> 1462;
2924 -> 2909;
2924 -> 1472;
2924 -> 1464;
2925 -> 1615;
2926 -> 2925;
2926 -> 1484;
2927 -> 2926;
2927 -> 1486;
2927 -> 1484;
2928 -> 1482;
2928 -> 1516;
2928 -> 1611;
2928 -> 2927;
2928 -> 1620;
2928 -> 1510;
2928 -> 1511;
2928 -> 2913;
2928 -> 1518;
2928 -> 1515;
2929 -> 1635;
2930 -> 2929;
2930 -> 1530;
2931 -> 2930;
2931 -> 1532;
2931 -> 1530;
2932 -> 1528;
2932 -> 1562;
2932 -> 1631;
2932 -> 2931;
2932 -> 1640;
2932 -> 1556;
2932 -> 1557;
2932 -> 2917;
2932 -> 1564;
2932 -> 1561;
2933 -> 1576;
2934 -> 2933;
2934 -> 1397;
2935 -> 2934;
2935 -> 1399;
2935 -> 1397;
2936 -> 1595;
2937 -> 2936;
2937 -> 1435;
2938 -> 2937;
2938 -> 1437;
2938 -> 1435;
2939 -> 1433;
2939 -> 1465;
2939 -> 1591;
2939 -> 2938;
2939 -> 1600;
2939 -> 1461;
2939 -> 1462;
2939 -> 2924;
2939 -> 1472;
2939 -> 1464;
2940 -> 1615;
2941 -> 2940;
2941 -> 1484;
2942 -> 2941;
2942 -> 1486;
2942 -> 1484;
2943 -> 1482;
2943 -> 1516;
2943 -> 1611;
2943 -> 2942;
2943 -> 1620;
2943 -> 1510;
2943 -> 1511;
2943 -> 2928;
2943 -> 1518;
2943 -> 1515;
2944 -> 1635;
2945 -> 2944;
2945 -> 1530;
2946 -> 2945;
2946 -> 1532;
2946 -> 1530;
2947 -> 1528;
2947 -> 1562;
2947 -> 1631;
2947 -> 2946;
2947 -> 1640;
2947 -> 1556;
2947 -> 1557;
2947 -> 2932;
2947 -> 1564;
2947 -> 1561;
2948 -> 1576;
2949 -> 2948;
2949 -> 1397;
2950 -> 2949;
2950 -> 1399;
2950 -> 1397;
2951 -> 1595;
2952 -> 2951;
2952 -> 1435;
2953 -> 2952;
2953 -> 1437;
2953 -> 1435;
2954 -> 1433;
2954 -> 1465;
2954 -> 1591;
2954 -> 2953;
2954 -> 1600;
2954 -> 1461;
2954 -> 1462;
2954 -> 2939;
2954 -> 1472;
2954 -> 1464;
2955 -> 1615;
2956 -> 2955;
2956 -> 1484;
2957 -> 2956;
2957 -> 1486;
2957 -> 1484;
2958 -> 1482;
2958 -> 1516;
2958 -> 1611;
2958 -> 2957;
2958 -> 1620;
2958 -> 1510;
2958 -> 1511;
2958 -> 2943;
2958 -> 1518;
2958 -> 1515;
2959 -> 1635;
2960 -> 2959;
2960 -> 1530;
2961 -> 2960;
2961 -> 1532;
2961 -> 1530;
2962 -> 1528;
2962 -> 1562;
2962 -> 1631;
2962 -> 2961;
2962 -> 1640;
2962 -> 1556;
2962 -> 1557;
2962 -> 2947;
2962 -> 1564;
2962 -> 1561;
2963 -> 1576;
2964 -> 2963;
2964 -> 1397;
2965 -> 2964;
2965 -> 1399;
2965 -> 1397;
2966 -> 1595;
2967 -> 2966;
2967 -> 1435;
2968 -> 2967;
2968 -> 1437;
2968 -> 1435;
2969 -> 1433;
2969 -> 1465;
2969 -> 1591;
2969 -> 2968;
2969 -> 1600;
2969 -> 1461;
2969 -> 1462;
2969 -> 2954;
2969 -> 1472;
2969 -> 1464;
2970 -> 1615;
2971 -> 2970;
2971 -> 1484;
2972 -> 2971;
2972 -> 1486;
2972 -> 1484;
2973 -> 1482;
2973 -> 1516;
2973 -> 1611;
2973 -> 2972;
2973 -> 1620;
2973 -> 1510;
2973 -> 1511;
2973 -> 2958;
2973 -> 1518;
2973 -> 1515;
2974 -> 1635;
2975 -> 2974;
2975 -> 1530;
2976 -> 2975;
2976 -> 1532;
2976 -> 1530;
2977 -> 1528;
2977 -> 1562;
2977 -> 1631;
2977 -> 2976;
2977 -> 1640;
2977 -> 1556;
2977 -> 1557;
2977 -> 2962;
2977 -> 1564;
2977 -> 1561;
2978 -> 1576;
2979 -> 2978;
2979 -> 1397;
2980 -> 2979;
2980 -> 1399;
2980 -> 1397;
2981 -> 1595;
2982 -> 2981;
2982 -> 1435;
2983 -> 2982;
2983 -> 1437;
2983 -> 1435;
2984 -> 1433;
2984 -> 1465;
2984 -> 1591;
2984 -> 2983;
2984 -> 1600;
2984 -> 1461;
2984 -> 1462;
2984 -> 2969;
2984 -> 1472;
2984 -> 1464;
2985 -> 1615;
2986 -> 2985;
2986 -> 1484;
2987 -> 2986;
2987 -> 1486;
2987 -> 1484;
2988 -> 1482;
2988 -> 1516;
2988 -> 1611;
2988 -> 2987;
2988 -> 1620;
2988 -> 1510;
2988 -> 1511;
2988 -> 2973;
2988 -> 1518;
2988 -> 1515;
2989 -> 1635;
2990 -> 2989;
2990 -> 1530;
2991 -> 2990;
2991 -> 1532;
2991 -> 1530;
2992 -> 1528;
2992 -> 1562;
2992 -> 1631;
2992 -> 2991;
2992 -> 1640;
2992 -> 1556;
2992 -> 1557;
2992 -> 2977;
2992 -> 1564;
2992 -> 1561;
2993 -> 1576;
2994 -> 2993;
2994 -> 1397;
2995 -> 2994;
2995 -> 1399;
2995 -> 1397;
2996 -> 1595;
2997 -> 2996;
2997 -> 1435;
2998 -> 2997;
2998 -> 1437;
2998 -> 1435;
2999 -> 1433;
2999 -> 1465;
2999 -> 1591;
2999 -> 2998;
2999 -> 1600;
2999 -> 1461;
2999 -> 1462;
2999 -> 2984;
2999 -> 1472;
2999 -> 1464;
3000 -> 1615;
3001 -> 3000;
3001 -> 1484;
3002 -> 3001;
3002 -> 1486;
3002 -> 1484;
3003 -> 1482;
3003 -> 1516;
3003 -> 1611;
3003 -> 3002;
3003 -> 1620;
3003 -> 1510;
3003 -> 1511;
3003 -> 2988;
3003 -> 1518;
3003 -> 1515;
3004 -> 1635;
3005 -> 3004;
3005 -> 1530;
3006 -> 3005;
3006 -> 1532;
3006 -> 1530;
3007 -> 1528;
3007 -> 1562;
3007 -> 1631;
3007 -> 3006;
3007 -> 1640;
3007 -> 1556;
3007 -> 1557;
3007 -> 2992;
3007 -> 1564;
3007 -> 1561;
3008 -> 1576;
3009 -> 3008;
3009 -> 1397;
3010 -> 3009;
3010 -> 1399;
3010 -> 1397;
3011 -> 1595;
3012 -> 3011;
3012 -> 1435;
3013 -> 3012;
3013 -> 1437;
3013 -> 1435;
3014 -> 1433;
3014 -> 1465;
3014 -> 1591;
3014 -> 3013;
3014 -> 1600;
3014 -> 1461;
3014 -> 1462;
3014 -> 2999;
3014 -> 1472;
3014 -> 1464;
3015 -> 1615;
3016 -> 3015;
3016 -> 1484;
3017 -> 3016;
3017 -> 1486;
3017 -> 1484;
3018 -> 1482;
3018 -> 1516;
3018 -> 1611;
3018 -> 3017;
3018 -> 1620;
3018 -> 1510;
3018 -> 1511;
3018 -> 3003;
3018 -> 1518;
3018 -> 1515;
3019 -> 1635;
3020 -> 3019;
3020 -> 1530;
3021 -> 3020;
3021 -> 1532;
3021 -> 1530;
3022 -> 1528;
3022 -> 1562;
3022 -> 1631;
3022 -> 3021;
3022 -> 1640;
3022 -> 1556;
3022 -> 1557;
3022 -> 3007;
3022 -> 1564;
3022 -> 1561;
3023 -> 1576;
3024 -> 3023;
3024 -> 1397;
3025 -> 3024;
3025 -> 1399;
3025 -> 1397;
3026 -> 1595;
3027 -> 3026;
3027 -> 1435;
3028 -> 3027;
3028 -> 1437;
3028 -> 1435;
3029 -> 1433;
3029 -> 1465;
3029 -> 1591;
3029 -> 3028;
3029 -> 1600;
3029 -> 1461;
3029 -> 1462;
3029 -> 3014;
3029 -> 1472;
3029 -> 1464;
3030 -> 1615;
3031 -> 3030;
3031 -> 1484;
3032 -> 3031;
3032 -> 1486;
3032 -> 1484;
3033 -> 1482;
3033 -> 1516;
3033 -> 1611;
3033 -> 3032;
3033 -> 1620;
3033 -> 1510;
3033 -> 1511;
3033 -> 3018;
3033 -> 1518;
3033 -> 1515;
3034 -> 1635;
3035 -> 3034;
3035 -> 1530;
3036 -> 3035;
3036 -> 1532;
3036 -> 1530;
3037 -> 1528;
3037 -> 1562;
3037 -> 1631;
3037 -> 3036;
3037 -> 1640;
3037 -> 1556;
3037 -> 1557;
3037 -> 3022;
3037 -> 1564;
3037 -> 1561;
3038 -> 1576;
3039 -> 3038;
3039 -> 1397;
3040 -> 3039;
3040 -> 1399;
3040 -> 1397;
3041 -> 1595;
3042 -> 3041;
3042 -> 1435;
3043 -> 3042;
3043 -> 1437;
3043 -> 1435;
3044 -> 1433;
3044 -> 1465;
3044 -> 1591;
3044 -> 3043;
3044 -> 1600;
3044 -> 1461;
3044 -> 1462;
3044 -> 3029;
3044 -> 1472;
3044 -> 1464;
3045 -> 1615;
3046 -> 3045;
3046 -> 1484;
3047 -> 3046;
3047 -> 1486;
3047 -> 1484;
3048 -> 1482;
3048 -> 1516;
3048 -> 1611;
3048 -> 3047;
3048 -> 1620;
3048 -> 1510;
3048 -> 1511;
3048 -> 3033;
3048 -> 1518;
3048 -> 1515;
3049 -> 1635;
3050 -> 3049;
3050 -> 1530;
3051 -> 3050;
3051 -> 1532;
3051 -> 1530;
3052 -> 1528;
3052 -> 1562;
3052 -> 1631;
3052 -> 3051;
3052 -> 1640;
3052 -> 1556;
3052 -> 1557;
3052 -> 3037;
3052 -> 1564;
3052 -> 1561;
3053 -> 1576;
3054 -> 3053;
3054 -> 1397;
3055 -> 3054;
3055 -> 1399;
3055 -> 1397;
3056 -> 1595;
3057 -> 3056;
3057 -> 1435;
3058 -> 3057;
3058 -> 1437;
3058 -> 1435;
3059 -> 1433;
3059 -> 1465;
3059 -> 1591;
3059 -> 3058;
3059 -> 1600;
3059 -> 1461;
3059 -> 1462;
3059 -> 3044;
3059 -> 1472;
3059 -> 1464;
3060 -> 1615;
3061 -> 3060;
3061 -> 1484;
3062 -> 3061;
3062 -> 1486;
3062 -> 1484;
3063 -> 1482;
3063 -> 1516;
3063 -> 1611;
3063 -> 3062;
3063 -> 1620;
3063 -> 1510;
3063 -> 1511;
3063 -> 3048;
3063 -> 1518;
3063 -> 1515;
3064 -> 1635;
3065 -> 3064;
3065 -> 1530;
3066 -> 3065;
3066 -> 1532;
3066 -> 1530;
3067 -> 1528;
3067 -> 1562;
3067 -> 1631;
3067 -> 3066;
3067 -> 1640;
3067 -> 1556;
3067 -> 1557;
3067 -> 3052;
3067 -> 1564;
3067 -> 1561;
3068 -> 1576;
3069 -> 3068;
3069 -> 1397;
3070 -> 3069;
3070 -> 1399;
3070 -> 1397;
3071 -> 1595;
3072 -> 3071;
3072 -> 1435;
3073 -> 3072;
3073 -> 1437;
3073 -> 1435;
3074 -> 1433;
3074 -> 1465;
3074 -> 1591;
3074 -> 3073;
3074 -> 1600;
3074 -> 1461;
3074 -> 1462;
3074 -> 3059;
3074 -> 1472;
3074 -> 1464;
3075 -> 1615;
3076 -> 3075;
3076 -> 1484;
3077 -> 3076;
3077 -> 1486;
3077 -> 1484;
3078 -> 1482;
3078 -> 1516;
3078 -> 1611;
3078 -> 3077;
3078 -> 1620;
3078 -> 1510;
3078 -> 1511;
3078 -> 3063;
3078 -> 1518;
3078 -> 1515;
3079 -> 1635;
3080 -> 3079;
3080 -> 1530;
3081 -> 3080;
3081 -> 1532;
3081 -> 1530;
3082 -> 1528;
3082 -> 1562;
3082 -> 1631;
3082 -> 3081;
3082 -> 1640;
3082 -> 1556;
3082 -> 1557;
3082 -> 3067;
3082 -> 1564;
3082 -> 1561;
3083 -> 1576;
3084 -> 3083;
3084 -> 1397;
3085 -> 3084;
3085 -> 1399;
3085 -> 1397;
3086 -> 1595;
3087 -> 3086;
3087 -> 1435;
3088 -> 3087;
3088 -> 1437;
3088 -> 1435;
3089 -> 1433;
3089 -> 1465;
3089 -> 1591;
3089 -> 3088;
3089 -> 1600;
3089 -> 1461;
3089 -> 1462;
3089 -> 3074;
3089 -> 1472;
3089 -> 1464;
3090 -> 1615;
3091 -> 3090;
3091 -> 1484;
3092 -> 3091;
3092 -> 1486;
3092 -> 1484;
3093 -> 1482;
3093 -> 1516;
3093 -> 1611;
3093 -> 3092;
3093 -> 1620;
3093 -> 1510;
3093 -> 1511;
3093 -> 3078;
3093 -> 1518;
3093 -> 1515;
3094 -> 1635;
3095 -> 3094;
3095 -> 1530;
3096 -> 3095;
3096 -> 1532;
3096 -> 1530;
3097 -> 1528;
3097 -> 1562;
3097 -> 1631;
3097 -> 3096;
3097 -> 1640;
3097 -> 1556;
3097 -> 1557;
3097 -> 3082;
3097 -> 1564;
3097 -> 1561;
3098 -> 1576;
3099 -> 3098;
3099 -> 1397;
3100 -> 3099;
3100 -> 1399;
3100 -> 1397;
3101 -> 1595;
3102 -> 3101;
3102 -> 1435;
3103 -> 3102;
3103 -> 1437;
3103 -> 1435;
3104 -> 1433;
3104 -> 1465;
3104 -> 1591;
3104 -> 3103;
3104 -> 1600;
3104 -> 1461;
3104 -> 1462;
3104 -> 3089;
3104 -> 1472;
3104 -> 1464;
3105 -> 1615;
3106 -> 3105;
3106 -> 1484;
3107 -> 3106;
3107 -> 1486;
3107 -> 1484;
3108 -> 1482;
3108 -> 1516;
3108 -> 1611;
3108 -> 3107;
3108 -> 1620;
3108 -> 1510;
3108 -> 1511;
3108 -> 3093;
3108 -> 1518;
3108 -> 1515;
3109 -> 1635;
3110 -> 3109;
3110 -> 1530;
3111 -> 3110;
3111 -> 1532;
3111 -> 1530;
3112 -> 1528;
3112 -> 1562;
3112 -> 1631;
3112 -> 3111;
3112 -> 1640;
3112 -> 1556;
3112 -> 1557;
3112 -> 3097;
3112 -> 1564;
3112 -> 1561;
3113 -> 1576;
3114 -> 3113;
3114 -> 1397;
3115 -> 3114;
3115 -> 1399;
3115 -> 1397;
3116 -> 1595;
3117 -> 3116;
3117 -> 1435;
3118 -> 3117;
3118 -> 1437;
3118 -> 1435;
3119 -> 1433;
3119 -> 1465;
3119 -> 1591;
3119 -> 3118;
3119 -> 1600;
3119 -> 1461;
3119 -> 1462;
3119 -> 3104;
3119 -> 1472;
3119 -> 1464;
3120 -> 1615;
3121 -> 3120;
3121 -> 1484;
3122 -> 3121;
3122 -> 1486;
3122 -> 1484;
3123 -> 1482;
3123 -> 1516;
3123 -> 1611;
3123 -> 3122;
3123 -> 1620;
3123 -> 1510;
3123 -> 1511;
3123 -> 3108;
3123 -> 1518;
3123 -> 1515;
3124 -> 1635;
3125 -> 3124;
3125 -> 1530;
3126 -> 3125;
3126 -> 1532;
3126 -> 1530;
3127 -> 1528;
3127 -> 1562;
3127 -> 1631;
3127 -> 3126;
3127 -> 1640;
3127 -> 1556;
3127 -> 1557;
3127 -> 3112;
3127 -> 1564;
3127 -> 1561;
3128 -> 1576;
3129 -> 3128;
3129 -> 1397;
3130 -> 3129;
3130 -> 1399;
3130 -> 1397;
3131 -> 1595;
3132 -> 3131;
3132 -> 1435;
3133 -> 3132;
3133 -> 1437;
3133 -> 1435;
3134 -> 1433;
3134 -> 1465;
3134 -> 1591;
3134 -> 3133;
3134 -> 1600;
3134 -> 1461;
3134 -> 1462;
3134 -> 3119;
3134 -> 1472;
3134 -> 1464;
3135 -> 1615;
3136 -> 3135;
3136 -> 1484;
3137 -> 3136;
3137 -> 1486;
3137 -> 1484;
3138 -> 1482;
3138 -> 1516;
3138 -> 1611;
3138 -> 3137;
3138 -> 1620;
3138 -> 1510;
3138 -> 1511;
3138 -> 3123;
3138 -> 1518;
3138 -> 1515;
3139 -> 1635;
3140 -> 3139;
3140 -> 1530;
3141 -> 3140;
3141 -> 1532;
3141 -> 1530;
3142 -> 1528;
3142 -> 1562;
3142 -> 1631;
3142 -> 3141;
3142 -> 1640;
3142 -> 1556;
3142 -> 1557;
3142 -> 3127;
3142 -> 1564;
3142 -> 1561;
3143 -> 1576;
3144 -> 3143;
3144 -> 1397;
3145 -> 3144;
3145 -> 1399;
3145 -> 1397;
3146 -> 1595;
3147 -> 3146;
3147 -> 1435;
3148 -> 3147;
3148 -> 1437;
3148 -> 1435;
3149 -> 1433;
3149 -> 1465;
3149 -> 1591;
3149 -> 3148;
3149 -> 1600;
3149 -> 1461;
3149 -> 1462;
3149 -> 3134;
3149 -> 1472;
3149 -> 1464;
3150 -> 1615;
3151 -> 3150;
3151 -> 1484;
3152 -> 3151;
3152 -> 1486;
3152 -> 1484;
3153 -> 1482;
3153 -> 1516;
3153 -> 1611;
3153 -> 3152;
3153 -> 1620;
3153 -> 1510;
3153 -> 1511;
3153 -> 3138;
3153 -> 1518;
3153 -> 1515;
3154 -> 1635;
3155 -> 3154;
3155 -> 1530;
3156 -> 3155;
3156 -> 1532;
3156 -> 1530;
3157 -> 1528;
3157 -> 1562;
3157 -> 1631;
3157 -> 3156;
3157 -> 1640;
3157 -> 1556;
3157 -> 1557;
3157 -> 3142;
3157 -> 1564;
3157 -> 1561;
3158 -> 1576;
3159 -> 3158;
3159 -> 1397;
3160 -> 3159;
3160 -> 1399;
3160 -> 1397;
3161 -> 1595;
3162 -> 3161;
3162 -> 1435;
3163 -> 3162;
3163 -> 1437;
3163 -> 1435;
3164 -> 1433;
3164 -> 1465;
3164 -> 1591;
3164 -> 3163;
3164 -> 1600;
3164 -> 1461;
3164 -> 1462;
3164 -> 3149;
3164 -> 1472;
3164 -> 1464;
3165 -> 1615;
3166 -> 3165;
3166 -> 1484;
3167 -> 3166;
3167 -> 1486;
3167 -> 1484;
3168 -> 1482;
3168 -> 1516;
3168 -> 1611;
3168 -> 3167;
3168 -> 1620;
3168 -> 1510;
3168 -> 1511;
3168 -> 3153;
3168 -> 1518;
3168 -> 1515;
3169 -> 1635;
3170 -> 3169;
3170 -> 1530;
3171 -> 3170;
3171 -> 1532;
3171 -> 1530;
3172 -> 1528;
3172 -> 1562;
3172 -> 1631;
3172 -> 3171;
3172 -> 1640;
3172 -> 1556;
3172 -> 1557;
3172 -> 3157;
3172 -> 1564;
3172 -> 1561;
3173 -> 1576;
3174 -> 3173;
3174 -> 1397;
3175 -> 3174;
3175 -> 1399;
3175 -> 1397;
3176 -> 1595;
3177 -> 3176;
3177 -> 1435;
3178 -> 3177;
3178 -> 1437;
3178 -> 1435;
3179 -> 1433;
3179 -> 1465;
3179 -> 1591;
3179 -> 3178;
3179 -> 1600;
3179 -> 1461;
3179 -> 1462;
3179 -> 3164;
3179 -> 1472;
3179 -> 1464;
3180 -> 1615;
3181 -> 3180;
3181 -> 1484;
3182 -> 3181;
3182 -> 1486;
3182 -> 1484;
3183 -> 1482;
3183 -> 1516;
3183 -> 1611;
3183 -> 3182;
3183 -> 1620;
3183 -> 1510;
3183 -> 1511;
3183 -> 3168;
3183 -> 1518;
3183 -> 1515;
3184 -> 1635;
3185 -> 3184;
3185 -> 1530;
3186 -> 3185;
3186 -> 1532;
3186 -> 1530;
3187 -> 1528;
3187 -> 1562;
3187 -> 1631;
3187 -> 3186;
3187 -> 1640;
3187 -> 1556;
3187 -> 1557;
3187 -> 3172;
3187 -> 1564;
3187 -> 1561;
3188 -> 1576;
3189 -> 3188;
3189 -> 1397;
3190 -> 3189;
3190 -> 1399;
3190 -> 1397;
3191 -> 1595;
3192 -> 3191;
3192 -> 1435;
3193 -> 3192;
3193 -> 1437;
3193 -> 1435;
3194 -> 1433;
3194 -> 1465;
3194 -> 1591;
3194 -> 3193;
3194 -> 1600;
3194 -> 1461;
3194 -> 1462;
3194 -> 3179;
3194 -> 1472;
3194 -> 1464;
3195 -> 1615;
3196 -> 3195;
3196 -> 1484;
3197 -> 3196;
3197 -> 1486;
3197 -> 1484;
3198 -> 1482;
3198 -> 1516;
3198 -> 1611;
3198 -> 3197;
3198 -> 1620;
3198 -> 1510;
3198 -> 1511;
3198 -> 3183;
3198 -> 1518;
3198 -> 1515;
3199 -> 1635;
3200 -> 3199;
3200 -> 1530;
3201 -> 3200;
3201 -> 1532;
3201 -> 1530;
3202 -> 1528;
3202 -> 1562;
3202 -> 1631;
3202 -> 3201;
3202 -> 1640;
3202 -> 1556;
3202 -> 1557;
3202 -> 3187;
3202 -> 1564;
3202 -> 1561;
3203 -> 1576;
3204 -> 3203;
3204 -> 1397;
3205 -> 3204;
3205 -> 1399;
3205 -> 1397;
3206 -> 1595;
3207 -> 3206;
3207 -> 1435;
3208 -> 3207;
3208 -> 1437;
3208 -> 1435;
3209 -> 1433;
3209 -> 1465;
3209 -> 1591;
3209 -> 3208;
3209 -> 1600;
3209 -> 1461;
3209 -> 1462;
3209 -> 3194;
3209 -> 1472;
3209 -> 1464;
3210 -> 1615;
3211 -> 3210;
3211 -> 1484;
3212 -> 3211;
3212 -> 1486;
3212 -> 1484;
3213 -> 1482;
3213 -> 1516;
3213 -> 1611;
3213 -> 3212;
3213 -> 1620;
3213 -> 1510;
3213 -> 1511;
3213 -> 3198;
3213 -> 1518;
3213 -> 1515;
3214 -> 1635;
3215 -> 3214;
3215 -> 1530;
3216 -> 3215;
3216 -> 1532;
3216 -> 1530;
3217 -> 1528;
3217 -> 1562;
3217 -> 1631;
3217 -> 3216;
3217 -> 1640;
3217 -> 1556;
3217 -> 1557;
3217 -> 3202;
3217 -> 1564;
3217 -> 1561;
3218 -> 1576;
3219 -> 3218;
3219 -> 1397;
3220 -> 3219;
3220 -> 1399;
3220 -> 1397;
3221 -> 1595;
3222 -> 3221;
3222 -> 1435;
3223 -> 3222;
3223 -> 1437;
3223 -> 1435;
3224 -> 1433;
3224 -> 1465;
3224 -> 1591;
3224 -> 3223;
3224 -> 1600;
3224 -> 1461;
3224 -> 1462;
3224 -> 3209;
3224 -> 1472;
3224 -> 1464;
3225 -> 1615;
3226 -> 3225;
3226 -> 1484;
3227 -> 3226;
3227 -> 1486;
3227 -> 1484;
3228 -> 1482;
3228 -> 1516;
3228 -> 1611;
3228 -> 3227;
3228 -> 1620;
3228 -> 1510;
3228 -> 1511;
3228 -> 3213;
3228 -> 1518;
3228 -> 1515;
3229 -> 1635;
3230 -> 3229;
3230 -> 1530;
3231 -> 3230;
3231 -> 1532;
3231 -> 1530;
3232 -> 1528;
3232 -> 1562;
3232 -> 1631;
3232 -> 3231;
3232 -> 1640;
3232 -> 1556;
3232 -> 1557;
3232 -> 3217;
3232 -> 1564;
3232 -> 1561;
3233 -> 1576;
3234 -> 3233;
3234 -> 1397;
3235 -> 3234;
3235 -> 1399;
3235 -> 1397;
3236 -> 1595;
3237 -> 3236;
3237 -> 1435;
3238 -> 3237;
3238 -> 1437;
3238 -> 1435;
3239 -> 1433;
3239 -> 1465;
3239 -> 1591;
3239 -> 3238;
3239 -> 1600;
3239 -> 1461;
3239 -> 1462;
3239 -> 3224;
3239 -> 1472;
3239 -> 1464;
3240 -> 1615;
3241 -> 3240;
3241 -> 1484;
3242 -> 3241;
3242 -> 1486;
3242 -> 1484;
3243 -> 1482;
3243 -> 1516;
3243 -> 1611;
3243 -> 3242;
3243 -> 1620;
3243 -> 1510;
3243 -> 1511;
3243 -> 3228;
3243 -> 1518;
3243 -> 1515;
3244 -> 1635;
3245 -> 3244;
3245 -> 1530;
3246 -> 3245;
3246 -> 1532;
3246 -> 1530;
3247 -> 1528;
3247 -> 1562;
3247 -> 1631;
3247 -> 3246;
3247 -> 1640;
3247 -> 1556;
3247 -> 1557;
3247 -> 3232;
3247 -> 1564;
3247 -> 1561;
3248 -> 1576;
3249 -> 3248;
3249 -> 1397;
3250 -> 3249;
3250 -> 1399;
3250 -> 1397;
3251 -> 1595;
3252 -> 3251;
3252 -> 1435;
3253 -> 3252;
3253 -> 1437;
3253 -> 1435;
3254 -> 1433;
3254 -> 1465;
3254 -> 1591;
3254 -> 3253;
3254 -> 1600;
3254 -> 1461;
3254 -> 1462;
3254 -> 3239;
3254 -> 1472;
3254 -> 1464;
3255 -> 1615;
3256 -> 3255;
3256 -> 1484;
3257 -> 3256;
3257 -> 1486;
3257 -> 1484;
3258 -> 1482;
3258 -> 1516;
3258 -> 1611;
3258 -> 3257;
3258 -> 1620;
3258 -> 1510;
3258 -> 1511;
3258 -> 3243;
3258 -> 1518;
3258 -> 1515;
3259 -> 1635;
3260 -> 3259;
3260 -> 1530;
3261 -> 3260;
3261 -> 1532;
3261 -> 1530;
3262 -> 1528;
3262 -> 1562;
3262 -> 1631;
3262 -> 3261;
3262 -> 1640;
3262 -> 1556;
3262 -> 1557;
3262 -> 3247;
3262 -> 1564;
3262 -> 1561;
3263 -> 1576;
3264 -> 3263;
3264 -> 1397;
3265 -> 3264;
3265 -> 1399;
3265 -> 1397;
3266 -> 1595;
3267 -> 3266;
3267 -> 1435;
3268 -> 3267;
3268 -> 1437;
3268 -> 1435;
3269 -> 1433;
3269 -> 1465;
3269 -> 1591;
3269 -> 3268;
3269 -> 1600;
3269 -> 1461;
3269 -> 1462;
3269 -> 3254;
3269 -> 1472;
3269 -> 1464;
3270 -> 1615;
3271 -> 3270;
3271 -> 1484;
3272 -> 3271;
3272 -> 1486;
3272 -> 1484;
3273 -> 1482;
3273 -> 1516;
3273 -> 1611;
3273 -> 3272;
3273 -> 1620;
3273 -> 1510;
3273 -> 1511;
3273 -> 3258;
3273 -> 1518;
3273 -> 1515;
3274 -> 1635;
3275 -> 3274;
3275 -> 1530;
3276 -> 3275;
3276 -> 1532;
3276 -> 1530;
3277 -> 1528;
3277 -> 1562;
3277 -> 1631;
3277 -> 3276;
3277 -> 1640;
3277 -> 1556;
3277 -> 1557;
3277 -> 3262;
3277 -> 1564;
3277 -> 1561;
3278 -> 1576;
3279 -> 3278;
3279 -> 1397;
3280 -> 3279;
3280 -> 1399;
3280 -> 1397;
3281 -> 1595;
3282 -> 3281;
3282 -> 1435;
3283 -> 3282;
3283 -> 1437;
3283 -> 1435;
3284 -> 1433;
3284 -> 1465;
3284 -> 1591;
3284 -> 3283;
3284 -> 1600;
3284 -> 1461;
3284 -> 1462;
3284 -> 3269;
3284 -> 1472;
3284 -> 1464;
3285 -> 1615;
3286 -> 3285;
3286 -> 1484;
3287 -> 3286;
3287 -> 1486;
3287 -> 1484;
3288 -> 1482;
3288 -> 1516;
3288 -> 1611;
3288 -> 3287;
3288 -> 1620;
3288 -> 1510;
3288 -> 1511;
3288 -> 3273;
3288 -> 1518;
3288 -> 1515;
3289 -> 1635;
3290 -> 3289;
3290 -> 1530;
3291 -> 3290;
3291 -> 1532;
3291 -> 1530;
3292 -> 1528;
3292 -> 1562;
3292 -> 1631;
3292 -> 3291;
3292 -> 1640;
3292 -> 1556;
3292 -> 1557;
3292 -> 3277;
3292 -> 1564;
3292 -> 1561;
3293 -> 1576;
3294 -> 3293;
3294 -> 1397;
3295 -> 3294;
3295 -> 1399;
3295 -> 1397;
3296 -> 1595;
3297 -> 3296;
3297 -> 1435;
3298 -> 3297;
3298 -> 1437;
3298 -> 1435;
3299 -> 1433;
3299 -> 1465;
3299 -> 1591;
3299 -> 3298;
3299 -> 1600;
3299 -> 1461;
3299 -> 1462;
3299 -> 3284;
3299 -> 1472;
3299 -> 1464;
3300 -> 1615;
3301 -> 3300;
3301 -> 1484;
3302 -> 3301;
3302 -> 1486;
3302 -> 1484;
3303 -> 1482;
3303 -> 1516;
3303 -> 1611;
3303 -> 3302;
3303 -> 1620;
3303 -> 1510;
3303 -> 1511;
3303 -> 3288;
3303 -> 1518;
3303 -> 1515;
3304 -> 1635;
3305 -> 3304;
3305 -> 1530;
3306 -> 3305;
3306 -> 1532;
3306 -> 1530;
3307 -> 1528;
3307 -> 1562;
3307 -> 1631;
3307 -> 3306;
3307 -> 1640;
3307 -> 1556;
3307 -> 1557;
3307 -> 3292;
3307 -> 1564;
3307 -> 1561;
3308 -> 1576;
3309 -> 3308;
3309 -> 1397;
3310 -> 3309;
3310 -> 1399;
3310 -> 1397;
3311 -> 1595;
3312 -> 3311;
3312 -> 1435;
3313 -> 3312;
3313 -> 1437;
3313 -> 1435;
3314 -> 1433;
3314 -> 1465;
3314 -> 1591;
3314 -> 3313;
3314 -> 1600;
3314 -> 1461;
3314 -> 1462;
3314 -> 3299;
3314 -> 1472;
3314 -> 1464;
3315 -> 1615;
3316 -> 3315;
3316 -> 1484;
3317 -> 3316;
3317 -> 1486;
3317 -> 1484;
3318 -> 1482;
3318 -> 1516;
3318 -> 1611;
3318 -> 3317;
3318 -> 1620;
3318 -> 1510;
3318 -> 1511;
3318 -> 3303;
3318 -> 1518;
3318 -> 1515;
3319 -> 1635;
3320 -> 3319;
3320 -> 1530;
3321 -> 3320;
3321 -> 1532;
3321 -> 1530;
3322 -> 1528;
3322 -> 1562;
3322 -> 1631;
3322 -> 3321;
3322 -> 1640;
3322 -> 1556;
3322 -> 1557;
3322 -> 3307;
3322 -> 1564;
3322 -> 1561;
3323 -> 1576;
3324 -> 3323;
3324 -> 1397;
3325 -> 3324;
3325 -> 1399;
3325 -> 1397;
3326 -> 1595;
3327 -> 3326;
3327 -> 1435;
3328 -> 3327;
3328 -> 1437;
3328 -> 1435;
3329 -> 1433;
3329 -> 1465;
3329 -> 1591;
3329 -> 3328;
3329 -> 1600;
3329 -> 1461;
3329 -> 1462;
3329 -> 3314;
3329 -> 1472;
3329 -> 1464;
3330 -> 1615;
3331 -> 3330;
3331 -> 1484;
3332 -> 3331;
3332 -> 1486;
3332 -> 1484;
3333 -> 1482;
3333 -> 1516;
3333 -> 1611;
3333 -> 3332;
3333 -> 1620;
3333 -> 1510;
3333 -> 1511;
3333 -> 3318;
3333 -> 1518;
3333 -> 1515;
3334 -> 1635;
3335 -> 3334;
3335 -> 1530;
3336 -> 3335;
3336 -> 1532;
3336 -> 1530;
3337 -> 1528;
3337 -> 1562;
3337 -> 1631;
3337 -> 3336;
3337 -> 1640;
3337 -> 1556;
3337 -> 1557;
3337 -> 3322;
3337 -> 1564;
3337 -> 1561;
3338 -> 1576;
3339 -> 3338;
3339 -> 1397;
3340 -> 3339;
3340 -> 1399;
3340 -> 1397;
3341 -> 1595;
3342 -> 3341;
3342 -> 1435;
3343 -> 3342;
3343 -> 1437;
3343 -> 1435;
3344 -> 1433;
3344 -> 1465;
3344 -> 1591;
3344 -> 3343;
3344 -> 1600;
3344 -> 1461;
3344 -> 1462;
3344 -> 3329;
3344 -> 1472;
3344 -> 1464;
3345 -> 1615;
3346 -> 3345;
3346 -> 1484;
3347 -> 3346;
3347 -> 1486;
3347 -> 1484;
3348 -> 1482;
3348 -> 1516;
3348 -> 1611;
3348 -> 3347;
3348 -> 1620;
3348 -> 1510;
3348 -> 1511;
3348 -> 3333;
3348 -> 1518;
3348 -> 1515;
3349 -> 1635;
3350 -> 3349;
3350 -> 1530;
3351 -> 3350;
3351 -> 1532;
3351 -> 1530;
3352 -> 1528;
3352 -> 1562;
3352 -> 1631;
3352 -> 3351;
3352 -> 1640;
3352 -> 1556;
3352 -> 1557;
3352 -> 3337;
3352 -> 1564;
3352 -> 1561;
3353 -> 1576;
3354 -> 3353;
3354 -> 1397;
3355 -> 3354;
3355 -> 1399;
3355 -> 1397;
3356 -> 1595;
3357 -> 3356;
3357 -> 1435;
3358 -> 3357;
3358 -> 1437;
3358 -> 1435;
3359 -> 1433;
3359 -> 1465;
3359 -> 1591;
3359 -> 3358;
3359 -> 1600;
3359 -> 1461;
3359 -> 1462;
3359 -> 3344;
3359 -> 1472;
3359 -> 1464;
3360 -> 1615;
3361 -> 3360;
3361 -> 1484;
3362 -> 3361;
3362 -> 1486;
3362 -> 1484;
3363 -> 1482;
3363 -> 1516;
3363 -> 1611;
3363 -> 3362;
3363 -> 1620;
3363 -> 1510;
3363 -> 1511;
3363 -> 3348;
3363 -> 1518;
3363 -> 1515;
3364 -> 1635;
3365 -> 3364;
3365 -> 1530;
3366 -> 3365;
3366 -> 1532;
3366 -> 1530;
3367 -> 1528;
3367 -> 1562;
3367 -> 1631;
3367 -> 3366;
3367 -> 1640;
3367 -> 1556;
3367 -> 1557;
3367 -> 3352;
3367 -> 1564;
3367 -> 1561;
3368 -> 1576;
3369 -> 3368;
3369 -> 1397;
3370 -> 3369;
3370 -> 1399;
3370 -> 1397;
3371 -> 1595;
3372 -> 3371;
3372 -> 1435;
3373 -> 3372;
3373 -> 1437;
3373 -> 1435;
3374 -> 1433;
3374 -> 1465;
3374 -> 1591;
3374 -> 3373;
3374 -> 1600;
3374 -> 1461;
3374 -> 1462;
3374 -> 3359;
3374 -> 1472;
3374 -> 1464;
3375 -> 1615;
3376 -> 3375;
3376 -> 1484;
3377 -> 3376;
3377 -> 1486;
3377 -> 1484;
3378 -> 1482;
3378 -> 1516;
3378 -> 1611;
3378 -> 3377;
3378 -> 1620;
3378 -> 1510;
3378 -> 1511;
3378 -> 3363;
3378 -> 1518;
3378 -> 1515;
3379 -> 1635;
3380 -> 3379;
3380 -> 1530;
3381 -> 3380;
3381 -> 1532;
3381 -> 1530;
3382 -> 1528;
3382 -> 1562;
3382 -> 1631;
3382 -> 3381;
3382 -> 1640;
3382 -> 1556;
3382 -> 1557;
3382 -> 3367;
3382 -> 1564;
3382 -> 1561;
3383 -> 1576;
3384 -> 3383;
3384 -> 1397;
3385 -> 3384;
3385 -> 1399;
3385 -> 1397;
3386 -> 1595;
3387 -> 3386;
3387 -> 1435;
3388 -> 3387;
3388 -> 1437;
3388 -> 1435;
3389 -> 1433;
3389 -> 1465;
3389 -> 1591;
3389 -> 3388;
3389 -> 1600;
3389 -> 1461;
3389 -> 1462;
3389 -> 3374;
3389 -> 1472;
3389 -> 1464;
3390 -> 1615;
3391 -> 3390;
3391 -> 1484;
3392 -> 3391;
3392 -> 1486;
3392 -> 1484;
3393 -> 1482;
3393 -> 1516;
3393 -> 1611;
3393 -> 3392;
3393 -> 1620;
3393 -> 1510;
3393 -> 1511;
3393 -> 3378;
3393 -> 1518;
3393 -> 1515;
3394 -> 1635;
3395 -> 3394;
3395 -> 1530;
3396 -> 3395;
3396 -> 1532;
3396 -> 1530;
3397 -> 1528;
3397 -> 1562;
3397 -> 1631;
3397 -> 3396;
3397 -> 1640;
3397 -> 1556;
3397 -> 1557;
3397 -> 3382;
3397 -> 1564;
3397 -> 1561;
3398 -> 1576;
3399 -> 3398;
3399 -> 1397;
3400 -> 3399;
3400 -> 1399;
3400 -> 1397;
3401 -> 1595;
3402 -> 3401;
3402 -> 1435;
3403 -> 3402;
3403 -> 1437;
3403 -> 1435;
3404 -> 1433;
3404 -> 1465;
3404 -> 1591;
3404 -> 3403;
3404 -> 1600;
3404 -> 1461;
3404 -> 1462;
3404 -> 3389;
3404 -> 1472;
3404 -> 1464;
3405 -> 1615;
3406 -> 3405;
3406 -> 1484;
3407 -> 3406;
3407 -> 1486;
3407 -> 1484;
3408 -> 1482;
3408 -> 1516;
3408 -> 1611;
3408 -> 3407;
3408 -> 1620;
3408 -> 1510;
3408 -> 1511;
3408 -> 3393;
3408 -> 1518;
3408 -> 1515;
3409 -> 1635;
3410 -> 3409;
3410 -> 1530;
3411 -> 3410;
3411 -> 1532;
3411 -> 1530;
3412 -> 1528;
3412 -> 1562;
3412 -> 1631;
3412 -> 3411;
3412 -> 1640;
3412 -> 1556;
3412 -> 1557;
3412 -> 3397;
3412 -> 1564;
3412 -> 1561;
3413 -> 1576;
3414 -> 3413;
3414 -> 1397;
3415 -> 3414;
3415 -> 1399;
3415 -> 1397;
3416 -> 1595;
3417 -> 3416;
3417 -> 1435;
3418 -> 3417;
3418 -> 1437;
3418 -> 1435;
3419 -> 1433;
3419 -> 1465;
3419 -> 1591;
3419 -> 3418;
3419 -> 1600;
3419 -> 1461;
3419 -> 1462;
3419 -> 3404;
3419 -> 1472;
3419 -> 1464;
3420 -> 1615;
3421 -> 3420;
3421 -> 1484;
3422 -> 3421;
3422 -> 1486;
3422 -> 1484;
3423 -> 1482;
3423 -> 1516;
3423 -> 1611;
3423 -> 3422;
3423 -> 1620;
3423 -> 1510;
3423 -> 1511;
3423 -> 3408;
3423 -> 1518;
3423 -> 1515;
3424 -> 1635;
3425 -> 3424;
3425 -> 1530;
3426 -> 3425;
3426 -> 1532;
3426 -> 1530;
3427 -> 1528;
3427 -> 1562;
3427 -> 1631;
3427 -> 3426;
3427 -> 1640;
3427 -> 1556;
3427 -> 1557;
3427 -> 3412;
3427 -> 1564;
3427 -> 1561;
3428 -> 1576;
3429 -> 3428;
3429 -> 1397;
3430 -> 3429;
3430 -> 1399;
3430 -> 1397;
3431 -> 1595;
3432 -> 3431;
3432 -> 1435;
3433 -> 3432;
3433 -> 1437;
3433 -> 1435;
3434 -> 1433;
3434 -> 1465;
3434 -> 1591;
3434 -> 3433;
3434 -> 1600;
3434 -> 1461;
3434 -> 1462;
3434 -> 3419;
3434 -> 1472;
3434 -> 1464;
3435 -> 1615;
3436 -> 3435;
3436 -> 1484;
3437 -> 3436;
3437 -> 1486;
3437 -> 1484;
3438 -> 1482;
3438 -> 1516;
3438 -> 1611;
3438 -> 3437;
3438 -> 1620;
3438 -> 1510;
3438 -> 1511;
3438 -> 3423;
3438 -> 1518;
3438 -> 1515;
3439 -> 1635;
3440 -> 3439;
3440 -> 1530;
3441 -> 3440;
3441 -> 1532;
3441 -> 1530;
3442 -> 1528;
3442 -> 1562;
3442 -> 1631;
3442 -> 3441;
3442 -> 1640;
3442 -> 1556;
3442 -> 1557;
3442 -> 3427;
3442 -> 1564;
3442 -> 1561;
3443 -> 1576;
3444 -> 3443;
3444 -> 1397;
3445 -> 3444;
3445 -> 1399;
3445 -> 1397;
3446 -> 1595;
3447 -> 3446;
3447 -> 1435;
3448 -> 3447;
3448 -> 1437;
3448 -> 1435;
3449 -> 1433;
3449 -> 1465;
3449 -> 1591;
3449 -> 3448;
3449 -> 1600;
3449 -> 1461;
3449 -> 1462;
3449 -> 3434;
3449 -> 1472;
3449 -> 1464;
3450 -> 1615;
3451 -> 3450;
3451 -> 1484;
3452 -> 3451;
3452 -> 1486;
3452 -> 1484;
3453 -> 1482;
3453 -> 1516;
3453 -> 1611;
3453 -> 3452;
3453 -> 1620;
3453 -> 1510;
3453 -> 1511;
3453 -> 3438;
3453 -> 1518;
3453 -> 1515;
3454 -> 1635;
3455 -> 3454;
3455 -> 1530;
3456 -> 3455;
3456 -> 1532;
3456 -> 1530;
3457 -> 1528;
3457 -> 1562;
3457 -> 1631;
3457 -> 3456;
3457 -> 1640;
3457 -> 1556;
3457 -> 1557;
3457 -> 3442;
3457 -> 1564;
3457 -> 1561;
3458 -> 1576;
3459 -> 3458;
3459 -> 1397;
3460 -> 3459;
3460 -> 1399;
3460 -> 1397;
3461 -> 1595;
3462 -> 3461;
3462 -> 1435;
3463 -> 3462;
3463 -> 1437;
3463 -> 1435;
3464 -> 1433;
3464 -> 1465;
3464 -> 1591;
3464 -> 3463;
3464 -> 1600;
3464 -> 1461;
3464 -> 1462;
3464 -> 3449;
3464 -> 1472;
3464 -> 1464;
3465 -> 1615;
3466 -> 3465;
3466 -> 1484;
3467 -> 3466;
3467 -> 1486;
3467 -> 1484;
3468 -> 1482;
3468 -> 1516;
3468 -> 1611;
3468 -> 3467;
3468 -> 1620;
3468 -> 1510;
3468 -> 1511;
3468 -> 3453;
3468 -> 1518;
3468 -> 1515;
3469 -> 1635;
3470 -> 3469;
3470 -> 1530;
3471 -> 3470;
3471 -> 1532;
3471 -> 1530;
3472 -> 1528;
3472 -> 1562;
3472 -> 1631;
3472 -> 3471;
3472 -> 1640;
3472 -> 1556;
3472 -> 1557;
3472 -> 3457;
3472 -> 1564;
3472 -> 1561;
3473 -> 1576;
3474 -> 3473;
3474 -> 1397;
3475 -> 3474;
3475 -> 1399;
3475 -> 1397;
3476 -> 1595;
3477 -> 3476;
3477 -> 1435;
3478 -> 3477;
3478 -> 1437;
3478 -> 1435;
3479 -> 1433;
3479 -> 1465;
3479 -> 1591;
3479 -> 3478;
3479 -> 1600;
3479 -> 1461;
3479 -> 1462;
3479 -> 3464;
3479 -> 1472;
3479 -> 1464;
3480 -> 1615;
3481 -> 3480;
3481 -> 1484;
3482 -> 3481;
3482 -> 1486;
3482 -> 1484;
3483 -> 1482;
3483 -> 1516;
3483 -> 1611;
3483 -> 3482;
3483 -> 1620;
3483 -> 1510;
3483 -> 1511;
3483 -> 3468;
3483 -> 1518;
3483 -> 1515;
3484 -> 1635;
3485 -> 3484;
3485 -> 1530;
3486 -> 3485;
3486 -> 1532;
3486 -> 1530;
3487 -> 1528;
3487 -> 1562;
3487 -> 1631;
3487 -> 3486;
3487 -> 1640;
3487 -> 1556;
3487 -> 1557;
3487 -> 3472;
3487 -> 1564;
3487 -> 1561;
3488 -> 1576;
3489 -> 3488;
3489 -> 1397;
3490 -> 3489;
3490 -> 1399;
3490 -> 1397;
3491 -> 1595;
3492 -> 3491;
3492 -> 1435;
3493 -> 3492;
3493 -> 1437;
3493 -> 1435;
3494 -> 1433;
3494 -> 1465;
3494 -> 1591;
3494 -> 3493;
3494 -> 1600;
3494 -> 1461;
3494 -> 1462;
3494 -> 3479;
3494 -> 1472;
3494 -> 1464;
3495 -> 1615;
3496 -> 3495;
3496 -> 1484;
3497 -> 3496;
3497 -> 1486;
3497 -> 1484;
3498 -> 1482;
3498 -> 1516;
3498 -> 1611;
3498 -> 3497;
3498 -> 1620;
3498 -> 1510;
3498 -> 1511;
3498 -> 3483;
3498 -> 1518;
3498 -> 1515;
3499 -> 1635;
3500 -> 3499;
3500 -> 1530;
3501 -> 3500;
3501 -> 1532;
3501 -> 1530;
3502 -> 1528;
3502 -> 1562;
3502 -> 1631;
3502 -> 3501;
3502 -> 1640;
3502 -> 1556;
3502 -> 1557;
3502 -> 3487;
3502 -> 1564;
3502 -> 1561;
3503 -> 1576;
3504 -> 3503;
3504 -> 1397;
3505 -> 3504;
3505 -> 1399;
3505 -> 1397;
3506 -> 1595;
3507 -> 3506;
3507 -> 1435;
3508 -> 3507;
3508 -> 1437;
3508 -> 1435;
3509 -> 1433;
3509 -> 1465;
3509 -> 1591;
3509 -> 3508;
3509 -> 1600;
3509 -> 1461;
3509 -> 1462;
3509 -> 3494;
3509 -> 1472;
3509 -> 1464;
3510 -> 1615;
3511 -> 3510;
3511 -> 1484;
3512 -> 3511;
3512 -> 1486;
3512 -> 1484;
3513 -> 1482;
3513 -> 1516;
3513 -> 1611;
3513 -> 3512;
3513 -> 1620;
3513 -> 1510;
3513 -> 1511;
3513 -> 3498;
3513 -> 1518;
3513 -> 1515;
3514 -> 1635;
3515 -> 3514;
3515 -> 1530;
3516 -> 3515;
3516 -> 1532;
3516 -> 1530;
3517 -> 1528;
3517 -> 1562;
3517 -> 1631;
3517 -> 3516;
3517 -> 1640;
3517 -> 1556;
3517 -> 1557;
3517 -> 3502;
3517 -> 1564;
3517 -> 1561;
3518 -> 1576;
3519 -> 3518;
3519 -> 1397;
3520 -> 3519;
3520 -> 1399;
3520 -> 1397;
3521 -> 1595;
3522 -> 3521;
3522 -> 1435;
3523 -> 3522;
3523 -> 1437;
3523 -> 1435;
3524 -> 1433;
3524 -> 1465;
3524 -> 1591;
3524 -> 3523;
3524 -> 1600;
3524 -> 1461;
3524 -> 1462;
3524 -> 3509;
3524 -> 1472;
3524 -> 1464;
3525 -> 1615;
3526 -> 3525;
3526 -> 1484;
3527 -> 3526;
3527 -> 1486;
3527 -> 1484;
3528 -> 1482;
3528 -> 1516;
3528 -> 1611;
3528 -> 3527;
3528 -> 1620;
3528 -> 1510;
3528 -> 1511;
3528 -> 3513;
3528 -> 1518;
3528 -> 1515;
3529 -> 1635;
3530 -> 3529;
3530 -> 1530;
3531 -> 3530;
3531 -> 1532;
3531 -> 1530;
3532 -> 1528;
3532 -> 1562;
3532 -> 1631;
3532 -> 3531;
3532 -> 1640;
3532 -> 1556;
3532 -> 1557;
3532 -> 3517;
3532 -> 1564;
3532 -> 1561;
3533 -> 1576;
3534 -> 3533;
3534 -> 1397;
3535 -> 3534;
3535 -> 1399;
3535 -> 1397;
3536 -> 1595;
3537 -> 3536;
3537 -> 1435;
3538 -> 3537;
3538 -> 1437;
3538 -> 1435;
3539 -> 1433;
3539 -> 1465;
3539 -> 1591;
3539 -> 3538;
3539 -> 1600;
3539 -> 1461;
3539 -> 1462;
3539 -> 3524;
3539 -> 1472;
3539 -> 1464;
3540 -> 1615;
3541 -> 3540;
3541 -> 1484;
3542 -> 3541;
3542 -> 1486;
3542 -> 1484;
3543 -> 1482;
3543 -> 1516;
3543 -> 1611;
3543 -> 3542;
3543 -> 1620;
3543 -> 1510;
3543 -> 1511;
3543 -> 3528;
3543 -> 1518;
3543 -> 1515;
3544 -> 1635;
3545 -> 3544;
3545 -> 1530;
3546 -> 3545;
3546 -> 1532;
3546 -> 1530;
3547 -> 1528;
3547 -> 1562;
3547 -> 1631;
3547 -> 3546;
3547 -> 1640;
3547 -> 1556;
3547 -> 1557;
3547 -> 3532;
3547 -> 1564;
3547 -> 1561;
3548 -> 1576;
3549 -> 3548;
3549 -> 1397;
3550 -> 3549;
3550 -> 1399;
3550 -> 1397;
3551 -> 1595;
3552 -> 3551;
3552 -> 1435;
3553 -> 3552;
3553 -> 1437;
3553 -> 1435;
3554 -> 1433;
3554 -> 1465;
3554 -> 1591;
3554 -> 3553;
3554 -> 1600;
3554 -> 1461;
3554 -> 1462;
3554 -> 3539;
3554 -> 1472;
3554 -> 1464;
3555 -> 1615;
3556 -> 3555;
3556 -> 1484;
3557 -> 3556;
3557 -> 1486;
3557 -> 1484;
3558 -> 1482;
3558 -> 1516;
3558 -> 1611;
3558 -> 3557;
3558 -> 1620;
3558 -> 1510;
3558 -> 1511;
3558 -> 3543;
3558 -> 1518;
3558 -> 1515;
3559 -> 1635;
3560 -> 3559;
3560 -> 1530;
3561 -> 3560;
3561 -> 1532;
3561 -> 1530;
3562 -> 1528;
3562 -> 1562;
3562 -> 1631;
3562 -> 3561;
3562 -> 1640;
3562 -> 1556;
3562 -> 1557;
3562 -> 3547;
3562 -> 1564;
3562 -> 1561;
3563 -> 1576;
3564 -> 3563;
3564 -> 1397;
3565 -> 3564;
3565 -> 1399;
3565 -> 1397;
3566 -> 1595;
3567 -> 3566;
3567 -> 1435;
3568 -> 3567;
3568 -> 1437;
3568 -> 1435;
3569 -> 1433;
3569 -> 1465;
3569 -> 1591;
3569 -> 3568;
3569 -> 1600;
3569 -> 1461;
3569 -> 1462;
3569 -> 3554;
3569 -> 1472;
3569 -> 1464;
3570 -> 1615;
3571 -> 3570;
3571 -> 1484;
3572 -> 3571;
3572 -> 1486;
3572 -> 1484;
3573 -> 1482;
3573 -> 1516;
3573 -> 1611;
3573 -> 3572;
3573 -> 1620;
3573 -> 1510;
3573 -> 1511;
3573 -> 3558;
3573 -> 1518;
3573 -> 1515;
3574 -> 1635;
3575 -> 3574;
3575 -> 1530;
3576 -> 3575;
3576 -> 1532;
3576 -> 1530;
3577 -> 1528;
3577 -> 1562;
3577 -> 1631;
3577 -> 3576;
3577 -> 1640;
3577 -> 1556;
3577 -> 1557;
3577 -> 3562;
3577 -> 1564;
3577 -> 1561;
3578 -> 1576;
3579 -> 3578;
3579 -> 1397;
3580 -> 3579;
3580 -> 1399;
3580 -> 1397;
3581 -> 1595;
3582 -> 3581;
3582 -> 1435;
3583 -> 3582;
3583 -> 1437;
3583 -> 1435;
3584 -> 1433;
3584 -> 1465;
3584 -> 1591;
3584 -> 3583;
3584 -> 1600;
3584 -> 1461;
3584 -> 1462;
3584 -> 3569;
3584 -> 1472;
3584 -> 1464;
3585 -> 1615;
3586 -> 3585;
3586 -> 1484;
3587 -> 3586;
3587 -> 1486;
3587 -> 1484;
3588 -> 1482;
3588 -> 1516;
3588 -> 1611;
3588 -> 3587;
3588 -> 1620;
3588 -> 1510;
3588 -> 1511;
3588 -> 3573;
3588 -> 1518;
3588 -> 1515;
3589 -> 1635;
3590 -> 3589;
3590 -> 1530;
3591 -> 3590;
3591 -> 1532;
3591 -> 1530;
3592 -> 1528;
3592 -> 1562;
3592 -> 1631;
3592 -> 3591;
3592 -> 1640;
3592 -> 1556;
3592 -> 1557;
3592 -> 3577;
3592 -> 1564;
3592 -> 1561;
3593 -> 1576;
3594 -> 3593;
3594 -> 1397;
3595 -> 3594;
3595 -> 1399;
3595 -> 1397;
3596 -> 1595;
3597 -> 3596;
3597 -> 1435;
3598 -> 3597;
3598 -> 1437;
3598 -> 1435;
3599 -> 1433;
3599 -> 1465;
3599 -> 1591;
3599 -> 3598;
3599 -> 1600;
3599 -> 1461;
3599 -> 1462;
3599 -> 3584;
3599 -> 1472;
3599 -> 1464;
3600 -> 1615;
3601 -> 3600;
3601 -> 1484;
3602 -> 3601;
3602 -> 1486;
3602 -> 1484;
3603 -> 1482;
3603 -> 1516;
3603 -> 1611;
3603 -> 3602;
3603 -> 1620;
3603 -> 1510;
3603 -> 1511;
3603 -> 3588;
3603 -> 1518;
3603 -> 1515;
3604 -> 1635;
3605 -> 3604;
3605 -> 1530;
3606 -> 3605;
3606 -> 1532;
3606 -> 1530;
3607 -> 1528;
3607 -> 1562;
3607 -> 1631;
3607 -> 3606;
3607 -> 1640;
3607 -> 1556;
3607 -> 1557;
3607 -> 3592;
3607 -> 1564;
3607 -> 1561;
3608 -> 1576;
3609 -> 3608;
3609 -> 1397;
3610 -> 3609;
3610 -> 1399;
3610 -> 1397;
3611 -> 1595;
3612 -> 3611;
3612 -> 1435;
3613 -> 3612;
3613 -> 1437;
3613 -> 1435;
3614 -> 1433;
3614 -> 1465;
3614 -> 1591;
3614 -> 3613;
3614 -> 1600;
3614 -> 1461;
3614 -> 1462;
3614 -> 3599;
3614 -> 1472;
3614 -> 1464;
3615 -> 1615;
3616 -> 3615;
3616 -> 1484;
3617 -> 3616;
3617 -> 1486;
3617 -> 1484;
3618 -> 1482;
3618 -> 1516;
3618 -> 1611;
3618 -> 3617;
3618 -> 1620;
3618 -> 1510;
3618 -> 1511;
3618 -> 3603;
3618 -> 1518;
3618 -> 1515;
3619 -> 1635;
3620 -> 3619;
3620 -> 1530;
3621 -> 3620;
3621 -> 1532;
3621 -> 1530;
3622 -> 1528;
3622 -> 1562;
3622 -> 1631;
3622 -> 3621;
3622 -> 1640;
3622 -> 1556;
3622 -> 1557;
3622 -> 3607;
3622 -> 1564;
3622 -> 1561;
3623 -> 1576;
3624 -> 3623;
3624 -> 1397;
3625 -> 3624;
3625 -> 1399;
3625 -> 1397;
3626 -> 1595;
3627 -> 3626;
3627 -> 1435;
3628 -> 3627;
3628 -> 1437;
3628 -> 1435;
3629 -> 1433;
3629 -> 1465;
3629 -> 1591;
3629 -> 3628;
3629 -> 1600;
3629 -> 1461;
3629 -> 1462;
3629 -> 3614;
3629 -> 1472;
3629 -> 1464;
3630 -> 1615;
3631 -> 3630;
3631 -> 1484;
3632 -> 3631;
3632 -> 1486;
3632 -> 1484;
3633 -> 1482;
3633 -> 1516;
3633 -> 1611;
3633 -> 3632;
3633 -> 1620;
3633 -> 1510;
3633 -> 1511;
3633 -> 3618;
3633 -> 1518;
3633 -> 1515;
3634 -> 1635;
3635 -> 3634;
3635 -> 1530;
3636 -> 3635;
3636 -> 1532;
3636 -> 1530;
3637 -> 1528;
3637 -> 1562;
3637 -> 1631;
3637 -> 3636;
3637 -> 1640;
3637 -> 1556;
3637 -> 1557;
3637 -> 3622;
3637 -> 1564;
3637 -> 1561;
3638 -> 1576;
3639 -> 3638;
3639 -> 1397;
3640 -> 3639;
3640 -> 1399;
3640 -> 1397;
3641 -> 1595;
3642 -> 3641;
3642 -> 1435;
3643 -> 3642;
3643 -> 1437;
3643 -> 1435;
3644 -> 1433;
3644 -> 1465;
3644 -> 1591;
3644 -> 3643;
3644 -> 1600;
3644 -> 1461;
3644 -> 1462;
3644 -> 3629;
3644 -> 1472;
3644 -> 1464;
3645 -> 1615;
3646 -> 3645;
3646 -> 1484;
3647 -> 3646;
3647 -> 1486;
3647 -> 1484;
3648 -> 1482;
3648 -> 1516;
3648 -> 1611;
3648 -> 3647;
3648 -> 1620;
3648 -> 1510;
3648 -> 1511;
3648 -> 3633;
3648 -> 1518;
3648 -> 1515;
3649 -> 1635;
3650 -> 3649;
3650 -> 1530;
3651 -> 3650;
3651 -> 1532;
3651 -> 1530;
3652 -> 1528;
3652 -> 1562;
3652 -> 1631;
3652 -> 3651;
3652 -> 1640;
3652 -> 1556;
3652 -> 1557;
3652 -> 3637;
3652 -> 1564;
3652 -> 1561;
3653 -> 1576;
3654 -> 3653;
3654 -> 1397;
3655 -> 3654;
3655 -> 1399;
3655 -> 1397;
3656 -> 1595;
3657 -> 3656;
3657 -> 1435;
3658 -> 3657;
3658 -> 1437;
3658 -> 1435;
3659 -> 1433;
3659 -> 1465;
3659 -> 1591;
3659 -> 3658;
3659 -> 1600;
3659 -> 1461;
3659 -> 1462;
3659 -> 3644;
3659 -> 1472;
3659 -> 1464;
3660 -> 1615;
3661 -> 3660;
3661 -> 1484;
3662 -> 3661;
3662 -> 1486;
3662 -> 1484;
3663 -> 1482;
3663 -> 1516;
3663 -> 1611;
3663 -> 3662;
3663 -> 1620;
3663 -> 1510;
3663 -> 1511;
3663 -> 3648;
3663 -> 1518;
3663 -> 1515;
3664 -> 1635;
3665 -> 3664;
3665 -> 1530;
3666 -> 3665;
3666 -> 1532;
3666 -> 1530;
3667 -> 1528;
3667 -> 1562;
3667 -> 1631;
3667 -> 3666;
3667 -> 1640;
3667 -> 1556;
3667 -> 1557;
3667 -> 3652;
3667 -> 1564;
3667 -> 1561;
3668 -> 1576;
3669 -> 3668;
3669 -> 1397;
3670 -> 3669;
3670 -> 1399;
3670 -> 1397;
3671 -> 1595;
3672 -> 3671;
3672 -> 1435;
3673 -> 3672;
3673 -> 1437;
3673 -> 1435;
3674 -> 1433;
3674 -> 1465;
3674 -> 1591;
3674 -> 3673;
3674 -> 1600;
3674 -> 1461;
3674 -> 1462;
3674 -> 3659;
3674 -> 1472;
3674 -> 1464;
3675 -> 1615;
3676 -> 3675;
3676 -> 1484;
3677 -> 3676;
3677 -> 1486;
3677 -> 1484;
3678 -> 1482;
3678 -> 1516;
3678 -> 1611;
3678 -> 3677;
3678 -> 1620;
3678 -> 1510;
3678 -> 1511;
3678 -> 3663;
3678 -> 1518;
3678 -> 1515;
3679 -> 1635;
3680 -> 3679;
3680 -> 1530;
3681 -> 3680;
3681 -> 1532;
3681 -> 1530;
3682 -> 1528;
3682 -> 1562;
3682 -> 1631;
3682 -> 3681;
3682 -> 1640;
3682 -> 1556;
3682 -> 1557;
3682 -> 3667;
3682 -> 1564;
3682 -> 1561;
3683 -> 1576;
3684 -> 3683;
3684 -> 1397;
3685 -> 3684;
3685 -> 1399;
3685 -> 1397;
3686 -> 1595;
3687 -> 3686;
3687 -> 1435;
3688 -> 3687;
3688 -> 1437;
3688 -> 1435;
3689 -> 1433;
3689 -> 1465;
3689 -> 1591;
3689 -> 3688;
3689 -> 1600;
3689 -> 1461;
3689 -> 1462;
3689 -> 3674;
3689 -> 1472;
3689 -> 1464;
3690 -> 1615;
3691 -> 3690;
3691 -> 1484;
3692 -> 3691;
3692 -> 1486;
3692 -> 1484;
3693 -> 1482;
3693 -> 1516;
3693 -> 1611;
3693 -> 3692;
3693 -> 1620;
3693 -> 1510;
3693 -> 1511;
3693 -> 3678;
3693 -> 1518;
3693 -> 1515;
3694 -> 1635;
3695 -> 3694;
3695 -> 1530;
3696 -> 3695;
3696 -> 1532;
3696 -> 1530;
3697 -> 1528;
3697 -> 1562;
3697 -> 1631;
3697 -> 3696;
3697 -> 1640;
3697 -> 1556;
3697 -> 1557;
3697 -> 3682;
3697 -> 1564;
3697 -> 1561;
3698 -> 1576;
3699 -> 3698;
3699 -> 1397;
3700 -> 3699;
3700 -> 1399;
3700 -> 1397;
3701 -> 1595;
3702 -> 3701;
3702 -> 1435;
3703 -> 3702;
3703 -> 1437;
3703 -> 1435;
3704 -> 1433;
3704 -> 1465;
3704 -> 1591;
3704 -> 3703;
3704 -> 1600;
3704 -> 1461;
3704 -> 1462;
3704 -> 3689;
3704 -> 1472;
3704 -> 1464;
3705 -> 1615;
3706 -> 3705;
3706 -> 1484;
3707 -> 3706;
3707 -> 1486;
3707 -> 1484;
3708 -> 1482;
3708 -> 1516;
3708 -> 1611;
3708 -> 3707;
3708 -> 1620;
3708 -> 1510;
3708 -> 1511;
3708 -> 3693;
3708 -> 1518;
3708 -> 1515;
3709 -> 1635;
3710 -> 3709;
3710 -> 1530;
3711 -> 3710;
3711 -> 1532;
3711 -> 1530;
3712 -> 1528;
3712 -> 1562;
3712 -> 1631;
3712 -> 3711;
3712 -> 1640;
3712 -> 1556;
3712 -> 1557;
3712 -> 3697;
3712 -> 1564;
3712 -> 1561;
3713 -> 1576;
3714 -> 3713;
3714 -> 1397;
3715 -> 3714;
3715 -> 1399;
3715 -> 1397;
3716 -> 1595;
3717 -> 3716;
3717 -> 1435;
3718 -> 3717;
3718 -> 1437;
3718 -> 1435;
3719 -> 1433;
3719 -> 1465;
3719 -> 1591;
3719 -> 3718;
3719 -> 1600;
3719 -> 1461;
3719 -> 1462;
3719 -> 3704;
3719 -> 1472;
3719 -> 1464;
3720 -> 1615;
3721 -> 3720;
3721 -> 1484;
3722 -> 3721;
3722 -> 1486;
3722 -> 1484;
3723 -> 1482;
3723 -> 1516;
3723 -> 1611;
3723 -> 3722;
3723 -> 1620;
3723 -> 1510;
3723 -> 1511;
3723 -> 3708;
3723 -> 1518;
3723 -> 1515;
3724 -> 1635;
3725 -> 3724;
3725 -> 1530;
3726 -> 3725;
3726 -> 1532;
3726 -> 1530;
3727 -> 1528;
3727 -> 1562;
3727 -> 1631;
3727 -> 3726;
3727 -> 1640;
3727 -> 1556;
3727 -> 1557;
3727 -> 3712;
3727 -> 1564;
3727 -> 1561;
3728 -> 1576;
3729 -> 3728;
3729 -> 1397;
3730 -> 3729;
3730 -> 1399;
3730 -> 1397;
3731 -> 1595;
3732 -> 3731;
3732 -> 1435;
3733 -> 3732;
3733 -> 1437;
3733 -> 1435;
3734 -> 1433;
3734 -> 1465;
3734 -> 1591;
3734 -> 3733;
3734 -> 1600;
3734 -> 1461;
3734 -> 1462;
3734 -> 3719;
3734 -> 1472;
3734 -> 1464;
3735 -> 1615;
3736 -> 3735;
3736 -> 1484;
3737 -> 3736;
3737 -> 1486;
3737 -> 1484;
3738 -> 1482;
3738 -> 1516;
3738 -> 1611;
3738 -> 3737;
3738 -> 1620;
3738 -> 1510;
3738 -> 1511;
3738 -> 3723;
3738 -> 1518;
3738 -> 1515;
3739 -> 1635;
3740 -> 3739;
3740 -> 1530;
3741 -> 3740;
3741 -> 1532;
3741 -> 1530;
3742 -> 1528;
3742 -> 1562;
3742 -> 1631;
3742 -> 3741;
3742 -> 1640;
3742 -> 1556;
3742 -> 1557;
3742 -> 3727;
3742 -> 1564;
3742 -> 1561;
3743 -> 1576;
3744 -> 3743;
3744 -> 1397;
3745 -> 3744;
3745 -> 1399;
3745 -> 1397;
3746 -> 1595;
3747 -> 3746;
3747 -> 1435;
3748 -> 3747;
3748 -> 1437;
3748 -> 1435;
3749 -> 1433;
3749 -> 1465;
3749 -> 1591;
3749 -> 3748;
3749 -> 1600;
3749 -> 1461;
3749 -> 1462;
3749 -> 3734;
3749 -> 1472;
3749 -> 1464;
3750 -> 1615;
3751 -> 3750;
3751 -> 1484;
3752 -> 3751;
3752 -> 1486;
3752 -> 1484;
3753 -> 1482;
3753 -> 1516;
3753 -> 1611;
3753 -> 3752;
3753 -> 1620;
3753 -> 1510;
3753 -> 1511;
3753 -> 3738;
3753 -> 1518;
3753 -> 1515;
3754 -> 1635;
3755 -> 3754;
3755 -> 1530;
3756 -> 3755;
3756 -> 1532;
3756 -> 1530;
3757 -> 1528;
3757 -> 1562;
3757 -> 1631;
3757 -> 3756;
3757 -> 1640;
3757 -> 1556;
3757 -> 1557;
3757 -> 3742;
3757 -> 1564;
3757 -> 1561;
3758 -> 1576;
3759 -> 3758;
3759 -> 1397;
3760 -> 3759;
3760 -> 1399;
3760 -> 1397;
3761 -> 1595;
3762 -> 3761;
3762 -> 1435;
3763 -> 3762;
3763 -> 1437;
3763 -> 1435;
3764 -> 1433;
3764 -> 1465;
3764 -> 1591;
3764 -> 3763;
3764 -> 1600;
3764 -> 1461;
3764 -> 1462;
3764 -> 3749;
3764 -> 1472;
3764 -> 1464;
3765 -> 1615;
3766 -> 3765;
3766 -> 1484;
3767 -> 3766;
3767 -> 1486;
3767 -> 1484;
3768 -> 1482;
3768 -> 1516;
3768 -> 1611;
3768 -> 3767;
3768 -> 1620;
3768 -> 1510;
3768 -> 1511;
3768 -> 3753;
3768 -> 1518;
3768 -> 1515;
3769 -> 1635;
3770 -> 3769;
3770 -> 1530;
3771 -> 3770;
3771 -> 1532;
3771 -> 1530;
3772 -> 1528;
3772 -> 1562;
3772 -> 1631;
3772 -> 3771;
3772 -> 1640;
3772 -> 1556;
3772 -> 1557;
3772 -> 3757;
3772 -> 1564;
3772 -> 1561;
3773 -> 1576;
3774 -> 3773;
3774 -> 1397;
3775 -> 3774;
3775 -> 1399;
3775 -> 1397;
3776 -> 1595;
3777 -> 3776;
3777 -> 1435;
3778 -> 3777;
3778 -> 1437;
3778 -> 1435;
3779 -> 1433;
3779 -> 1465;
3779 -> 1591;
3779 -> 3778;
3779 -> 1600;
3779 -> 1461;
3779 -> 1462;
3779 -> 3764;
3779 -> 1472;
3779 -> 1464;
3780 -> 1615;
3781 -> 3780;
3781 -> 1484;
3782 -> 3781;
3782 -> 1486;
3782 -> 1484;
3783 -> 1482;
3783 -> 1516;
3783 -> 1611;
3783 -> 3782;
3783 -> 1620;
3783 -> 1510;
3783 -> 1511;
3783 -> 3768;
3783 -> 1518;
3783 -> 1515;
3784 -> 1635;
3785 -> 3784;
3785 -> 1530;
3786 -> 3785;
3786 -> 1532;
3786 -> 1530;
3787 -> 1528;
3787 -> 1562;
3787 -> 1631;
3787 -> 3786;
3787 -> 1640;
3787 -> 1556;
3787 -> 1557;
3787 -> 3772;
3787 -> 1564;
3787 -> 1561;
3788 -> 1576;
3789 -> 3788;
3789 -> 1397;
3790 -> 3789;
3790 -> 1399;
3790 -> 1397;
3791 -> 1595;
3792 -> 3791;
3792 -> 1435;
3793 -> 3792;
3793 -> 1437;
3793 -> 1435;
3794 -> 1433;
3794 -> 1465;
3794 -> 1591;
3794 -> 3793;
3794 -> 1600;
3794 -> 1461;
3794 -> 1462;
3794 -> 3779;
3794 -> 1472;
3794 -> 1464;
3795 -> 1615;
3796 -> 3795;
3796 -> 1484;
3797 -> 3796;
3797 -> 1486;
3797 -> 1484;
3798 -> 1482;
3798 -> 1516;
3798 -> 1611;
3798 -> 3797;
3798 -> 1620;
3798 -> 1510;
3798 -> 1511;
3798 -> 3783;
3798 -> 1518;
3798 -> 1515;
3799 -> 1635;
3800 -> 3799;
3800 -> 1530;
3801 -> 3800;
3801 -> 1532;
3801 -> 1530;
3802 -> 1528;
3802 -> 1562;
3802 -> 1631;
3802 -> 3801;
3802 -> 1640;
3802 -> 1556;
3802 -> 1557;
3802 -> 3787;
3802 -> 1564;
3802 -> 1561;
3803 -> 1576;
3804 -> 3803;
3804 -> 1397;
3805 -> 3804;
3805 -> 1399;
3805 -> 1397;
3806 -> 1595;
3807 -> 3806;
3807 -> 1435;
3808 -> 3807;
3808 -> 1437;
3808 -> 1435;
3809 -> 1433;
3809 -> 1465;
3809 -> 1591;
3809 -> 3808;
3809 -> 1600;
3809 -> 1461;
3809 -> 1462;
3809 -> 3794;
3809 -> 1472;
3809 -> 1464;
3810 -> 1615;
3811 -> 3810;
3811 -> 1484;
3812 -> 3811;
3812 -> 1486;
3812 -> 1484;
3813 -> 1482;
3813 -> 1516;
3813 -> 1611;
3813 -> 3812;
3813 -> 1620;
3813 -> 1510;
3813 -> 1511;
3813 -> 3798;
3813 -> 1518;
3813 -> 1515;
3814 -> 1635;
3815 -> 3814;
3815 -> 1530;
3816 -> 3815;
3816 -> 1532;
3816 -> 1530;
3817 -> 1528;
3817 -> 1562;
3817 -> 1631;
3817 -> 3816;
3817 -> 1640;
3817 -> 1556;
3817 -> 1557;
3817 -> 3802;
3817 -> 1564;
3817 -> 1561;
3818 -> 1576;
3819 -> 3818;
3819 -> 1397;
3820 -> 3819;
3820 -> 1399;
3820 -> 1397;
3821 -> 1595;
3822 -> 3821;
3822 -> 1435;
3823 -> 3822;
3823 -> 1437;
3823 -> 1435;
3824 -> 1433;
3824 -> 1465;
3824 -> 1591;
3824 -> 3823;
3824 -> 1600;
3824 -> 1461;
3824 -> 1462;
3824 -> 3809;
3824 -> 1472;
3824 -> 1464;
3825 -> 1615;
3826 -> 3825;
3826 -> 1484;
3827 -> 3826;
3827 -> 1486;
3827 -> 1484;
3828 -> 1482;
3828 -> 1516;
3828 -> 1611;
3828 -> 3827;
3828 -> 1620;
3828 -> 1510;
3828 -> 1511;
3828 -> 3813;
3828 -> 1518;
3828 -> 1515;
3829 -> 1635;
3830 -> 3829;
3830 -> 1530;
3831 -> 3830;
3831 -> 1532;
3831 -> 1530;
3832 -> 1528;
3832 -> 1562;
3832 -> 1631;
3832 -> 3831;
3832 -> 1640;
3832 -> 1556;
3832 -> 1557;
3832 -> 3817;
3832 -> 1564;
3832 -> 1561;
3833 -> 1576;
3834 -> 3833;
3834 -> 1397;
3835 -> 3834;
3835 -> 1399;
3835 -> 1397;
3836 -> 1595;
3837 -> 3836;
3837 -> 1435;
3838 -> 3837;
3838 -> 1437;
3838 -> 1435;
3839 -> 1433;
3839 -> 1465;
3839 -> 1591;
3839 -> 3838;
3839 -> 1600;
3839 -> 1461;
3839 -> 1462;
3839 -> 3824;
3839 -> 1472;
3839 -> 1464;
3840 -> 1615;
3841 -> 3840;
3841 -> 1484;
3842 -> 3841;
3842 -> 1486;
3842 -> 1484;
3843 -> 1482;
3843 -> 1516;
3843 -> 1611;
3843 -> 3842;
3843 -> 1620;
3843 -> 1510;
3843 -> 1511;
3843 -> 3828;
3843 -> 1518;
3843 -> 1515;
3844 -> 1635;
3845 -> 3844;
3845 -> 1530;
3846 -> 3845;
3846 -> 1532;
3846 -> 1530;
3847 -> 1528;
3847 -> 1562;
3847 -> 1631;
3847 -> 3846;
3847 -> 1640;
3847 -> 1556;
3847 -> 1557;
3847 -> 3832;
3847 -> 1564;
3847 -> 1561;
3848 -> 1576;
3849 -> 3848;
3849 -> 1397;
3850 -> 3849;
3850 -> 1399;
3850 -> 1397;
3851 -> 1595;
3852 -> 3851;
3852 -> 1435;
3853 -> 3852;
3853 -> 1437;
3853 -> 1435;
3854 -> 1433;
3854 -> 1465;
3854 -> 1591;
3854 -> 3853;
3854 -> 1600;
3854 -> 1461;
3854 -> 1462;
3854 -> 3839;
3854 -> 1472;
3854 -> 1464;
3855 -> 1615;
3856 -> 3855;
3856 -> 1484;
3857 -> 3856;
3857 -> 1486;
3857 -> 1484;
3858 -> 1482;
3858 -> 1516;
3858 -> 1611;
3858 -> 3857;
3858 -> 1620;
3858 -> 1510;
3858 -> 1511;
3858 -> 3843;
3858 -> 1518;
3858 -> 1515;
3859 -> 1635;
3860 -> 3859;
3860 -> 1530;
3861 -> 3860;
3861 -> 1532;
3861 -> 1530;
3862 -> 1528;
3862 -> 1562;
3862 -> 1631;
3862 -> 3861;
3862 -> 1640;
3862 -> 1556;
3862 -> 1557;
3862 -> 3847;
3862 -> 1564;
3862 -> 1561;
3863 -> 1576;
3864 -> 3863;
3864 -> 1397;
3865 -> 3864;
3865 -> 1399;
3865 -> 1397;
3866 -> 1595;
3867 -> 3866;
3867 -> 1435;
3868 -> 3867;
3868 -> 1437;
3868 -> 1435;
3869 -> 1433;
3869 -> 1465;
3869 -> 1591;
3869 -> 3868;
3869 -> 1600;
3869 -> 1461;
3869 -> 1462;
3869 -> 3854;
3869 -> 1472;
3869 -> 1464;
3870 -> 1615;
3871 -> 3870;
3871 -> 1484;
3872 -> 3871;
3872 -> 1486;
3872 -> 1484;
3873 -> 1482;
3873 -> 1516;
3873 -> 1611;
3873 -> 3872;
3873 -> 1620;
3873 -> 1510;
3873 -> 1511;
3873 -> 3858;
3873 -> 1518;
3873 -> 1515;
3874 -> 1635;
3875 -> 3874;
3875 -> 1530;
3876 -> 3875;
3876 -> 1532;
3876 -> 1530;
3877 -> 1528;
3877 -> 1562;
3877 -> 1631;
3877 -> 3876;
3877 -> 1640;
3877 -> 1556;
3877 -> 1557;
3877 -> 3862;
3877 -> 1564;
3877 -> 1561;
3878 -> 1576;
3879 -> 3878;
3879 -> 1397;
3880 -> 3879;
3880 -> 1399;
3880 -> 1397;
3881 -> 1595;
3882 -> 3881;
3882 -> 1435;
3883 -> 3882;
3883 -> 1437;
3883 -> 1435;
3884 -> 1433;
3884 -> 1465;
3884 -> 1591;
3884 -> 3883;
3884 -> 1600;
3884 -> 1461;
3884 -> 1462;
3884 -> 3869;
3884 -> 1472;
3884 -> 1464;
3885 -> 1615;
3886 -> 3885;
3886 -> 1484;
3887 -> 3886;
3887 -> 1486;
3887 -> 1484;
3888 -> 1482;
3888 -> 1516;
3888 -> 1611;
3888 -> 3887;
3888 -> 1620;
3888 -> 1510;
3888 -> 1511;
3888 -> 3873;
3888 -> 1518;
3888 -> 1515;
3889 -> 1635;
3890 -> 3889;
3890 -> 1530;
3891 -> 3890;
3891 -> 1532;
3891 -> 1530;
3892 -> 1528;
3892 -> 1562;
3892 -> 1631;
3892 -> 3891;
3892 -> 1640;
3892 -> 1556;
3892 -> 1557;
3892 -> 3877;
3892 -> 1564;
3892 -> 1561;
3893 -> 1576;
3894 -> 3893;
3894 -> 1397;
3895 -> 3894;
3895 -> 1399;
3895 -> 1397;
3896 -> 1595;
3897 -> 3896;
3897 -> 1435;
3898 -> 3897;
3898 -> 1437;
3898 -> 1435;
3899 -> 1433;
3899 -> 1465;
3899 -> 1591;
3899 -> 3898;
3899 -> 1600;
3899 -> 1461;
3899 -> 1462;
3899 -> 3884;
3899 -> 1472;
3899 -> 1464;
3900 -> 1615;
3901 -> 3900;
3901 -> 1484;
3902 -> 3901;
3902 -> 1486;
3902 -> 1484;
3903 -> 1482;
3903 -> 1516;
3903 -> 1611;
3903 -> 3902;
3903 -> 1620;
3903 -> 1510;
3903 -> 1511;
3903 -> 3888;
3903 -> 1518;
3903 -> 1515;
3904 -> 1635;
3905 -> 3904;
3905 -> 1530;
3906 -> 3905;
3906 -> 1532;
3906 -> 1530;
3907 -> 1528;
3907 -> 1562;
3907 -> 1631;
3907 -> 3906;
3907 -> 1640;
3907 -> 1556;
3907 -> 1557;
3907 -> 3892;
3907 -> 1564;
3907 -> 1561;
3908 -> 1576;
3909 -> 3908;
3909 -> 1397;
3910 -> 3909;
3910 -> 1399;
3910 -> 1397;
3911 -> 1595;
3912 -> 3911;
3912 -> 1435;
3913 -> 3912;
3913 -> 1437;
3913 -> 1435;
3914 -> 1433;
3914 -> 1465;
3914 -> 1591;
3914 -> 3913;
3914 -> 1600;
3914 -> 1461;
3914 -> 1462;
3914 -> 3899;
3914 -> 1472;
3914 -> 1464;
3915 -> 1615;
3916 -> 3915;
3916 -> 1484;
3917 -> 3916;
3917 -> 1486;
3917 -> 1484;
3918 -> 1482;
3918 -> 1516;
3918 -> 1611;
3918 -> 3917;
3918 -> 1620;
3918 -> 1510;
3918 -> 1511;
3918 -> 3903;
3918 -> 1518;
3918 -> 1515;
3919 -> 1635;
3920 -> 3919;
3920 -> 1530;
3921 -> 3920;
3921 -> 1532;
3921 -> 1530;
3922 -> 1528;
3922 -> 1562;
3922 -> 1631;
3922 -> 3921;
3922 -> 1640;
3922 -> 1556;
3922 -> 1557;
3922 -> 3907;
3922 -> 1564;
3922 -> 1561;
3923 -> 1576;
3924 -> 3923;
3924 -> 1397;
3925 -> 3924;
3925 -> 1399;
3925 -> 1397;
3926 -> 1595;
3927 -> 3926;
3927 -> 1435;
3928 -> 3927;
3928 -> 1437;
3928 -> 1435;
3929 -> 1433;
3929 -> 1465;
3929 -> 1591;
3929 -> 3928;
3929 -> 1600;
3929 -> 1461;
3929 -> 1462;
3929 -> 3914;
3929 -> 1472;
3929 -> 1464;
3930 -> 1615;
3931 -> 3930;
3931 -> 1484;
3932 -> 3931;
3932 -> 1486;
3932 -> 1484;
3933 -> 1482;
3933 -> 1516;
3933 -> 1611;
3933 -> 3932;
3933 -> 1620;
3933 -> 1510;
3933 -> 1511;
3933 -> 3918;
3933 -> 1518;
3933 -> 1515;
3934 -> 1635;
3935 -> 3934;
3935 -> 1530;
3936 -> 3935;
3936 -> 1532;
3936 -> 1530;
3937 -> 1528;
3937 -> 1562;
3937 -> 1631;
3937 -> 3936;
3937 -> 1640;
3937 -> 1556;
3937 -> 1557;
3937 -> 3922;
3937 -> 1564;
3937 -> 1561;
3938 -> 1576;
3939 -> 3938;
3939 -> 1397;
3940 -> 3939;
3940 -> 1399;
3940 -> 1397;
3941 -> 1595;
3942 -> 3941;
3942 -> 1435;
3943 -> 3942;
3943 -> 1437;
3943 -> 1435;
3944 -> 1433;
3944 -> 1465;
3944 -> 1591;
3944 -> 3943;
3944 -> 1600;
3944 -> 1461;
3944 -> 1462;
3944 -> 3929;
3944 -> 1472;
3944 -> 1464;
3945 -> 1615;
3946 -> 3945;
3946 -> 1484;
3947 -> 3946;
3947 -> 1486;
3947 -> 1484;
3948 -> 1482;
3948 -> 1516;
3948 -> 1611;
3948 -> 3947;
3948 -> 1620;
3948 -> 1510;
3948 -> 1511;
3948 -> 3933;
3948 -> 1518;
3948 -> 1515;
3949 -> 1635;
3950 -> 3949;
3950 -> 1530;
3951 -> 3950;
3951 -> 1532;
3951 -> 1530;
3952 -> 1528;
3952 -> 1562;
3952 -> 1631;
3952 -> 3951;
3952 -> 1640;
3952 -> 1556;
3952 -> 1557;
3952 -> 3937;
3952 -> 1564;
3952 -> 1561;
3953 -> 1576;
3954 -> 3953;
3954 -> 1397;
3955 -> 3954;
3955 -> 1399;
3955 -> 1397;
3956 -> 1595;
3957 -> 3956;
3957 -> 1435;
3958 -> 3957;
3958 -> 1437;
3958 -> 1435;
3959 -> 1433;
3959 -> 1465;
3959 -> 1591;
3959 -> 3958;
3959 -> 1600;
3959 -> 1461;
3959 -> 1462;
3959 -> 3944;
3959 -> 1472;
3959 -> 1464;
3960 -> 1615;
3961 -> 3960;
3961 -> 1484;
3962 -> 3961;
3962 -> 1486;
3962 -> 1484;
3963 -> 1482;
3963 -> 1516;
3963 -> 1611;
3963 -> 3962;
3963 -> 1620;
3963 -> 1510;
3963 -> 1511;
3963 -> 3948;
3963 -> 1518;
3963 -> 1515;
3964 -> 1635;
3965 -> 3964;
3965 -> 1530;
3966 -> 3965;
3966 -> 1532;
3966 -> 1530;
3967 -> 1528;
3967 -> 1562;
3967 -> 1631;
3967 -> 3966;
3967 -> 1640;
3967 -> 1556;
3967 -> 1557;
3967 -> 3952;
3967 -> 1564;
3967 -> 1561;
3968 -> 1576;
3969 -> 3968;
3969 -> 1397;
3970 -> 3969;
3970 -> 1399;
3970 -> 1397;
3971 -> 1595;
3972 -> 3971;
3972 -> 1435;
3973 -> 3972;
3973 -> 1437;
3973 -> 1435;
3974 -> 1433;
3974 -> 1465;
3974 -> 1591;
3974 -> 3973;
3974 -> 1600;
3974 -> 1461;
3974 -> 1462;
3974 -> 3959;
3974 -> 1472;
3974 -> 1464;
3975 -> 1615;
3976 -> 3975;
3976 -> 1484;
3977 -> 3976;
3977 -> 1486;
3977 -> 1484;
3978 -> 1482;
3978 -> 1516;
3978 -> 1611;
3978 -> 3977;
3978 -> 1620;
3978 -> 1510;
3978 -> 1511;
3978 -> 3963;
3978 -> 1518;
3978 -> 1515;
3979 -> 1635;
3980 -> 3979;
3980 -> 1530;
3981 -> 3980;
3981 -> 1532;
3981 -> 1530;
3982 -> 1528;
3982 -> 1562;
3982 -> 1631;
3982 -> 3981;
3982 -> 1640;
3982 -> 1556;
3982 -> 1557;
3982 -> 3967;
3982 -> 1564;
3982 -> 1561;
3983 -> 1576;
3984 -> 3983;
3984 -> 1397;
3985 -> 3984;
3985 -> 1399;
3985 -> 1397;
3986 -> 1595;
3987 -> 3986;
3987 -> 1435;
3988 -> 3987;
3988 -> 1437;
3988 -> 1435;
3989 -> 1433;
3989 -> 1465;
3989 -> 1591;
3989 -> 3988;
3989 -> 1600;
3989 -> 1461;
3989 -> 1462;
3989 -> 3974;
3989 -> 1472;
3989 -> 1464;
3990 -> 1615;
3991 -> 3990;
3991 -> 1484;
3992 -> 3991;
3992 -> 1486;
3992 -> 1484;
3993 -> 1482;
3993 -> 1516;
3993 -> 1611;
3993 -> 3992;
3993 -> 1620;
3993 -> 1510;
3993 -> 1511;
3993 -> 3978;
3993 -> 1518;
3993 -> 1515;
3994 -> 1635;
3995 -> 3994;
3995 -> 1530;
3996 -> 3995;
3996 -> 1532;
3996 -> 1530;
3997 -> 1528;
3997 -> 1562;
3997 -> 1631;
3997 -> 3996;
3997 -> 1640;
3997 -> 1556;
3997 -> 1557;
3997 -> 3982;
3997 -> 1564;
3997 -> 1561;
3998 -> 1576;
3999 -> 3998;
3999 -> 1397;
4000 -> 3999;
4000 -> 1399;
4000 -> 1397;
4001 -> 1595;
4002 -> 4001;
4002 -> 1435;
4003 -> 4002;
4003 -> 1437;
4003 -> 1435;
4004 -> 1433;
4004 -> 1465;
4004 -> 1591;
4004 -> 4003;
4004 -> 1600;
4004 -> 1461;
4004 -> 1462;
4004 -> 3989;
4004 -> 1472;
4004 -> 1464;
4005 -> 1615;
4006 -> 4005;
4006 -> 1484;
4007 -> 4006;
4007 -> 1486;
4007 -> 1484;
4008 -> 1482;
4008 -> 1516;
4008 -> 1611;
4008 -> 4007;
4008 -> 1620;
4008 -> 1510;
4008 -> 1511;
4008 -> 3993;
4008 -> 1518;
4008 -> 1515;
4009 -> 1635;
4010 -> 4009;
4010 -> 1530;
4011 -> 4010;
4011 -> 1532;
4011 -> 1530;
4012 -> 1528;
4012 -> 1562;
4012 -> 1631;
4012 -> 4011;
4012 -> 1640;
4012 -> 1556;
4012 -> 1557;
4012 -> 3997;
4012 -> 1564;
4012 -> 1561;
4013 -> 1576;
4014 -> 4013;
4014 -> 1397;
4015 -> 4014;
4015 -> 1399;
4015 -> 1397;
4016 -> 1595;
4017 -> 4016;
4017 -> 1435;
4018 -> 4017;
4018 -> 1437;
4018 -> 1435;
4019 -> 1433;
4019 -> 1465;
4019 -> 1591;
4019 -> 4018;
4019 -> 1600;
4019 -> 1461;
4019 -> 1462;
4019 -> 4004;
4019 -> 1472;
4019 -> 1464;
4020 -> 1615;
4021 -> 4020;
4021 -> 1484;
4022 -> 4021;
4022 -> 1486;
4022 -> 1484;
4023 -> 1482;
4023 -> 1516;
4023 -> 1611;
4023 -> 4022;
4023 -> 1620;
4023 -> 1510;
4023 -> 1511;
4023 -> 4008;
4023 -> 1518;
4023 -> 1515;
4024 -> 1635;
4025 -> 4024;
4025 -> 1530;
4026 -> 4025;
4026 -> 1532;
4026 -> 1530;
4027 -> 1528;
4027 -> 1562;
4027 -> 1631;
4027 -> 4026;
4027 -> 1640;
4027 -> 1556;
4027 -> 1557;
4027 -> 4012;
4027 -> 1564;
4027 -> 1561;
4028 -> 1576;
4029 -> 4028;
4029 -> 1397;
4030 -> 4029;
4030 -> 1399;
4030 -> 1397;
4031 -> 1595;
4032 -> 4031;
4032 -> 1435;
4033 -> 4032;
4033 -> 1437;
4033 -> 1435;
4034 -> 1433;
4034 -> 1465;
4034 -> 1591;
4034 -> 4033;
4034 -> 1600;
4034 -> 1461;
4034 -> 1462;
4034 -> 4019;
4034 -> 1472;
4034 -> 1464;
4035 -> 1615;
4036 -> 4035;
4036 -> 1484;
4037 -> 4036;
4037 -> 1486;
4037 -> 1484;
4038 -> 1482;
4038 -> 1516;
4038 -> 1611;
4038 -> 4037;
4038 -> 1620;
4038 -> 1510;
4038 -> 1511;
4038 -> 4023;
4038 -> 1518;
4038 -> 1515;
4039 -> 1635;
4040 -> 4039;
4040 -> 1530;
4041 -> 4040;
4041 -> 1532;
4041 -> 1530;
4042 -> 1528;
4042 -> 1562;
4042 -> 1631;
4042 -> 4041;
4042 -> 1640;
4042 -> 1556;
4042 -> 1557;
4042 -> 4027;
4042 -> 1564;
4042 -> 1561;
4043 -> 1576;
4044 -> 4043;
4044 -> 1397;
4045 -> 4044;
4045 -> 1399;
4045 -> 1397;
4046 -> 1595;
4047 -> 4046;
4047 -> 1435;
4048 -> 4047;
4048 -> 1437;
4048 -> 1435;
4049 -> 1433;
4049 -> 1465;
4049 -> 1591;
4049 -> 4048;
4049 -> 1600;
4049 -> 1461;
4049 -> 1462;
4049 -> 4034;
4049 -> 1472;
4049 -> 1464;
4050 -> 1615;
4051 -> 4050;
4051 -> 1484;
4052 -> 4051;
4052 -> 1486;
4052 -> 1484;
4053 -> 1482;
4053 -> 1516;
4053 -> 1611;
4053 -> 4052;
4053 -> 1620;
4053 -> 1510;
4053 -> 1511;
4053 -> 4038;
4053 -> 1518;
4053 -> 1515;
4054 -> 1635;
4055 -> 4054;
4055 -> 1530;
4056 -> 4055;
4056 -> 1532;
4056 -> 1530;
4057 -> 1528;
4057 -> 1562;
4057 -> 1631;
4057 -> 4056;
4057 -> 1640;
4057 -> 1556;
4057 -> 1557;
4057 -> 4042;
4057 -> 1564;
4057 -> 1561;
4058 -> 1576;
4059 -> 4058;
4059 -> 1397;
4060 -> 4059;
4060 -> 1399;
4060 -> 1397;
4061 -> 1595;
4062 -> 4061;
4062 -> 1435;
4063 -> 4062;
4063 -> 1437;
4063 -> 1435;
4064 -> 1433;
4064 -> 1465;
4064 -> 1591;
4064 -> 4063;
4064 -> 1600;
4064 -> 1461;
4064 -> 1462;
4064 -> 4049;
4064 -> 1472;
4064 -> 1464;
4065 -> 1615;
4066 -> 4065;
4066 -> 1484;
4067 -> 4066;
4067 -> 1486;
4067 -> 1484;
4068 -> 1482;
4068 -> 1516;
4068 -> 1611;
4068 -> 4067;
4068 -> 1620;
4068 -> 1510;
4068 -> 1511;
4068 -> 4053;
4068 -> 1518;
4068 -> 1515;
4069 -> 1635;
4070 -> 4069;
4070 -> 1530;
4071 -> 4070;
4071 -> 1532;
4071 -> 1530;
4072 -> 1528;
4072 -> 1562;
4072 -> 1631;
4072 -> 4071;
4072 -> 1640;
4072 -> 1556;
4072 -> 1557;
4072 -> 4057;
4072 -> 1564;
4072 -> 1561;
4073 -> 1576;
4074 -> 4073;
4074 -> 1397;
4075 -> 4074;
4075 -> 1399;
4075 -> 1397;
4076 -> 1595;
4077 -> 4076;
4077 -> 1435;
4078 -> 4077;
4078 -> 1437;
4078 -> 1435;
4079 -> 1433;
4079 -> 1465;
4079 -> 1591;
4079 -> 4078;
4079 -> 1600;
4079 -> 1461;
4079 -> 1462;
4079 -> 4064;
4079 -> 1472;
4079 -> 1464;
4080 -> 1615;
4081 -> 4080;
4081 -> 1484;
4082 -> 4081;
4082 -> 1486;
4082 -> 1484;
4083 -> 1482;
4083 -> 1516;
4083 -> 1611;
4083 -> 4082;
4083 -> 1620;
4083 -> 1510;
4083 -> 1511;
4083 -> 4068;
4083 -> 1518;
4083 -> 1515;
4084 -> 1635;
4085 -> 4084;
4085 -> 1530;
4086 -> 4085;
4086 -> 1532;
4086 -> 1530;
4087 -> 1528;
4087 -> 1562;
4087 -> 1631;
4087 -> 4086;
4087 -> 1640;
4087 -> 1556;
4087 -> 1557;
4087 -> 4072;
4087 -> 1564;
4087 -> 1561;
4088 -> 1576;
4089 -> 4088;
4089 -> 1397;
4090 -> 4089;
4090 -> 1399;
4090 -> 1397;
4091 -> 1595;
4092 -> 4091;
4092 -> 1435;
4093 -> 4092;
4093 -> 1437;
4093 -> 1435;
4094 -> 1433;
4094 -> 1465;
4094 -> 1591;
4094 -> 4093;
4094 -> 1600;
4094 -> 1461;
4094 -> 1462;
4094 -> 4079;
4094 -> 1472;
4094 -> 1464;
4095 -> 1615;
4096 -> 4095;
4096 -> 1484;
4097 -> 4096;
4097 -> 1486;
4097 -> 1484;
4098 -> 1482;
4098 -> 1516;
4098 -> 1611;
4098 -> 4097;
4098 -> 1620;
4098 -> 1510;
4098 -> 1511;
4098 -> 4083;
4098 -> 1518;
4098 -> 1515;
4099 -> 1635;
4100 -> 4099;
4100 -> 1530;
4101 -> 4100;
4101 -> 1532;
4101 -> 1530;
4102 -> 1528;
4102 -> 1562;
4102 -> 1631;
4102 -> 4101;
4102 -> 1640;
4102 -> 1556;
4102 -> 1557;
4102 -> 4087;
4102 -> 1564;
4102 -> 1561;
4103 -> 1576;
4104 -> 4103;
4104 -> 1397;
4105 -> 4104;
4105 -> 1399;
4105 -> 1397;
4106 -> 1595;
4107 -> 4106;
4107 -> 1435;
4108 -> 4107;
4108 -> 1437;
4108 -> 1435;
4109 -> 1433;
4109 -> 1465;
4109 -> 1591;
4109 -> 4108;
4109 -> 1600;
4109 -> 1461;
4109 -> 1462;
4109 -> 4094;
4109 -> 1472;
4109 -> 1464;
4110 -> 1615;
4111 -> 4110;
4111 -> 1484;
4112 -> 4111;
4112 -> 1486;
4112 -> 1484;
4113 -> 1482;
4113 -> 1516;
4113 -> 1611;
4113 -> 4112;
4113 -> 1620;
4113 -> 1510;
4113 -> 1511;
4113 -> 4098;
4113 -> 1518;
4113 -> 1515;
4114 -> 1635;
4115 -> 4114;
4115 -> 1530;
4116 -> 4115;
4116 -> 1532;
4116 -> 1530;
4117 -> 1528;
4117 -> 1562;
4117 -> 1631;
4117 -> 4116;
4117 -> 1640;
4117 -> 1556;
4117 -> 1557;
4117 -> 4102;
4117 -> 1564;
4117 -> 1561;
4118 -> 1576;
4119 -> 4118;
4119 -> 1397;
4120 -> 4119;
4120 -> 1399;
4120 -> 1397;
4121 -> 1595;
4122 -> 4121;
4122 -> 1435;
4123 -> 4122;
4123 -> 1437;
4123 -> 1435;
4124 -> 1433;
4124 -> 1465;
4124 -> 1591;
4124 -> 4123;
4124 -> 1600;
4124 -> 1461;
4124 -> 1462;
4124 -> 4109;
4124 -> 1472;
4124 -> 1464;
4125 -> 1615;
4126 -> 4125;
4126 -> 1484;
4127 -> 4126;
4127 -> 1486;
4127 -> 1484;
4128 -> 1482;
4128 -> 1516;
4128 -> 1611;
4128 -> 4127;
4128 -> 1620;
4128 -> 1510;
4128 -> 1511;
4128 -> 4113;
4128 -> 1518;
4128 -> 1515;
4129 -> 1635;
4130 -> 4129;
4130 -> 1530;
4131 -> 4130;
4131 -> 1532;
4131 -> 1530;
4132 -> 1528;
4132 -> 1562;
4132 -> 1631;
4132 -> 4131;
4132 -> 1640;
4132 -> 1556;
4132 -> 1557;
4132 -> 4117;
4132 -> 1564;
4132 -> 1561;
4133 -> 1576;
4134 -> 4133;
4134 -> 1397;
4135 -> 4134;
4135 -> 1399;
4135 -> 1397;
4136 -> 1595;
4137 -> 4136;
4137 -> 1435;
4138 -> 4137;
4138 -> 1437;
4138 -> 1435;
4139 -> 1433;
4139 -> 1465;
4139 -> 1591;
4139 -> 4138;
4139 -> 1600;
4139 -> 1461;
4139 -> 1462;
4139 -> 4124;
4139 -> 1472;
4139 -> 1464;
4140 -> 1615;
4141 -> 4140;
4141 -> 1484;
4142 -> 4141;
4142 -> 1486;
4142 -> 1484;
4143 -> 1482;
4143 -> 1516;
4143 -> 1611;
4143 -> 4142;
4143 -> 1620;
4143 -> 1510;
4143 -> 1511;
4143 -> 4128;
4143 -> 1518;
4143 -> 1515;
4144 -> 1635;
4145 -> 4144;
4145 -> 1530;
4146 -> 4145;
4146 -> 1532;
4146 -> 1530;
4147 -> 1528;
4147 -> 1562;
4147 -> 1631;
4147 -> 4146;
4147 -> 1640;
4147 -> 1556;
4147 -> 1557;
4147 -> 4132;
4147 -> 1564;
4147 -> 1561;
4148 -> 1576;
4149 -> 4148;
4149 -> 1397;
4150 -> 4149;
4150 -> 1399;
4150 -> 1397;
4151 -> 1595;
4152 -> 4151;
4152 -> 1435;
4153 -> 4152;
4153 -> 1437;
4153 -> 1435;
4154 -> 1433;
4154 -> 1465;
4154 -> 1591;
4154 -> 4153;
4154 -> 1600;
4154 -> 1461;
4154 -> 1462;
4154 -> 4139;
4154 -> 1472;
4154 -> 1464;
4155 -> 1615;
4156 -> 4155;
4156 -> 1484;
4157 -> 4156;
4157 -> 1486;
4157 -> 1484;
4158 -> 1482;
4158 -> 1516;
4158 -> 1611;
4158 -> 4157;
4158 -> 1620;
4158 -> 1510;
4158 -> 1511;
4158 -> 4143;
4158 -> 1518;
4158 -> 1515;
4159 -> 1635;
4160 -> 4159;
4160 -> 1530;
4161 -> 4160;
4161 -> 1532;
4161 -> 1530;
4162 -> 1528;
4162 -> 1562;
4162 -> 1631;
4162 -> 4161;
4162 -> 1640;
4162 -> 1556;
4162 -> 1557;
4162 -> 4147;
4162 -> 1564;
4162 -> 1561;
4163 -> 1576;
4164 -> 4163;
4164 -> 1397;
4165 -> 4164;
4165 -> 1399;
4165 -> 1397;
4166 -> 1595;
4167 -> 4166;
4167 -> 1435;
4168 -> 4167;
4168 -> 1437;
4168 -> 1435;
4169 -> 1433;
4169 -> 1465;
4169 -> 1591;
4169 -> 4168;
4169 -> 1600;
4169 -> 1461;
4169 -> 1462;
4169 -> 4154;
4169 -> 1472;
4169 -> 1464;
4170 -> 1615;
4171 -> 4170;
4171 -> 1484;
4172 -> 4171;
4172 -> 1486;
4172 -> 1484;
4173 -> 1482;
4173 -> 1516;
4173 -> 1611;
4173 -> 4172;
4173 -> 1620;
4173 -> 1510;
4173 -> 1511;
4173 -> 4158;
4173 -> 1518;
4173 -> 1515;
4174 -> 1635;
4175 -> 4174;
4175 -> 1530;
4176 -> 4175;
4176 -> 1532;
4176 -> 1530;
4177 -> 1528;
4177 -> 1562;
4177 -> 1631;
4177 -> 4176;
4177 -> 1640;
4177 -> 1556;
4177 -> 1557;
4177 -> 4162;
4177 -> 1564;
4177 -> 1561;
4178 -> 1576;
4179 -> 4178;
4179 -> 1397;
4180 -> 4179;
4180 -> 1399;
4180 -> 1397;
4181 -> 1595;
4182 -> 4181;
4182 -> 1435;
4183 -> 4182;
4183 -> 1437;
4183 -> 1435;
4184 -> 1433;
4184 -> 1465;
4184 -> 1591;
4184 -> 4183;
4184 -> 1600;
4184 -> 1461;
4184 -> 1462;
4184 -> 4169;
4184 -> 1472;
4184 -> 1464;
4185 -> 1615;
4186 -> 4185;
4186 -> 1484;
4187 -> 4186;
4187 -> 1486;
4187 -> 1484;
4188 -> 1482;
4188 -> 1516;
4188 -> 1611;
4188 -> 4187;
4188 -> 1620;
4188 -> 1510;
4188 -> 1511;
4188 -> 4173;
4188 -> 1518;
4188 -> 1515;
4189 -> 1635;
4190 -> 4189;
4190 -> 1530;
4191 -> 4190;
4191 -> 1532;
4191 -> 1530;
4192 -> 1528;
4192 -> 1562;
4192 -> 1631;
4192 -> 4191;
4192 -> 1640;
4192 -> 1556;
4192 -> 1557;
4192 -> 4177;
4192 -> 1564;
4192 -> 1561;
4193 -> 1576;
4194 -> 4193;
4194 -> 1397;
4195 -> 4194;
4195 -> 1399;
4195 -> 1397;
4196 -> 1595;
4197 -> 4196;
4197 -> 1435;
4198 -> 4197;
4198 -> 1437;
4198 -> 1435;
4199 -> 1433;
4199 -> 1465;
4199 -> 1591;
4199 -> 4198;
4199 -> 1600;
4199 -> 1461;
4199 -> 1462;
4199 -> 4184;
4199 -> 1472;
4199 -> 1464;
4200 -> 1615;
4201 -> 4200;
4201 -> 1484;
4202 -> 4201;
4202 -> 1486;
4202 -> 1484;
4203 -> 1482;
4203 -> 1516;
4203 -> 1611;
4203 -> 4202;
4203 -> 1620;
4203 -> 1510;
4203 -> 1511;
4203 -> 4188;
4203 -> 1518;
4203 -> 1515;
4204 -> 1635;
4205 -> 4204;
4205 -> 1530;
4206 -> 4205;
4206 -> 1532;
4206 -> 1530;
4207 -> 1528;
4207 -> 1562;
4207 -> 1631;
4207 -> 4206;
4207 -> 1640;
4207 -> 1556;
4207 -> 1557;
4207 -> 4192;
4207 -> 1564;
4207 -> 1561;
4208 -> 1576;
4209 -> 4208;
4209 -> 1397;
4210 -> 4209;
4210 -> 1399;
4210 -> 1397;
4211 -> 1595;
4212 -> 4211;
4212 -> 1435;
4213 -> 4212;
4213 -> 1437;
4213 -> 1435;
4214 -> 1433;
4214 -> 1465;
4214 -> 1591;
4214 -> 4213;
4214 -> 1600;
4214 -> 1461;
4214 -> 1462;
4214 -> 4199;
4214 -> 1472;
4214 -> 1464;
4215 -> 1615;
4216 -> 4215;
4216 -> 1484;
4217 -> 4216;
4217 -> 1486;
4217 -> 1484;
4218 -> 1482;
4218 -> 1516;
4218 -> 1611;
4218 -> 4217;
4218 -> 1620;
4218 -> 1510;
4218 -> 1511;
4218 -> 4203;
4218 -> 1518;
4218 -> 1515;
4219 -> 1635;
4220 -> 4219;
4220 -> 1530;
4221 -> 4220;
4221 -> 1532;
4221 -> 1530;
4222 -> 1528;
4222 -> 1562;
4222 -> 1631;
4222 -> 4221;
4222 -> 1640;
4222 -> 1556;
4222 -> 1557;
4222 -> 4207;
4222 -> 1564;
4222 -> 1561;
4223 -> 1576;
4224 -> 4223;
4224 -> 1397;
4225 -> 4224;
4225 -> 1399;
4225 -> 1397;
4226 -> 1595;
4227 -> 4226;
4227 -> 1435;
4228 -> 4227;
4228 -> 1437;
4228 -> 1435;
4229 -> 1433;
4229 -> 1465;
4229 -> 1591;
4229 -> 4228;
4229 -> 1600;
4229 -> 1461;
4229 -> 1462;
4229 -> 4214;
4229 -> 1472;
4229 -> 1464;
4230 -> 1615;
4231 -> 4230;
4231 -> 1484;
4232 -> 4231;
4232 -> 1486;
4232 -> 1484;
4233 -> 1482;
4233 -> 1516;
4233 -> 1611;
4233 -> 4232;
4233 -> 1620;
4233 -> 1510;
4233 -> 1511;
4233 -> 4218;
4233 -> 1518;
4233 -> 1515;
4234 -> 1635;
4235 -> 4234;
4235 -> 1530;
4236 -> 4235;
4236 -> 1532;
4236 -> 1530;
4237 -> 1528;
4237 -> 1562;
4237 -> 1631;
4237 -> 4236;
4237 -> 1640;
4237 -> 1556;
4237 -> 1557;
4237 -> 4222;
4237 -> 1564;
4237 -> 1561;
4238 -> 1576;
4239 -> 4238;
4239 -> 1397;
4240 -> 4239;
4240 -> 1399;
4240 -> 1397;
4241 -> 1595;
4242 -> 4241;
4242 -> 1435;
4243 -> 4242;
4243 -> 1437;
4243 -> 1435;
4244 -> 1433;
4244 -> 1465;
4244 -> 1591;
4244 -> 4243;
4244 -> 1600;
4244 -> 1461;
4244 -> 1462;
4244 -> 4229;
4244 -> 1472;
4244 -> 1464;
4245 -> 1615;
4246 -> 4245;
4246 -> 1484;
4247 -> 4246;
4247 -> 1486;
4247 -> 1484;
4248 -> 1482;
4248 -> 1516;
4248 -> 1611;
4248 -> 4247;
4248 -> 1620;
4248 -> 1510;
4248 -> 1511;
4248 -> 4233;
4248 -> 1518;
4248 -> 1515;
4249 -> 1635;
4250 -> 4249;
4250 -> 1530;
4251 -> 4250;
4251 -> 1532;
4251 -> 1530;
4252 -> 1528;
4252 -> 1562;
4252 -> 1631;
4252 -> 4251;
4252 -> 1640;
4252 -> 1556;
4252 -> 1557;
4252 -> 4237;
4252 -> 1564;
4252 -> 1561;
4253 -> 1576;
4254 -> 4253;
4254 -> 1397;
4255 -> 4254;
4255 -> 1399;
4255 -> 1397;
4256 -> 1595;
4257 -> 4256;
4257 -> 1435;
4258 -> 4257;
4258 -> 1437;
4258 -> 1435;
4259 -> 1433;
4259 -> 1465;
4259 -> 1591;
4259 -> 4258;
4259 -> 1600;
4259 -> 1461;
4259 -> 1462;
4259 -> 4244;
4259 -> 1472;
4259 -> 1464;
4260 -> 1615;
4261 -> 4260;
4261 -> 1484;
4262 -> 4261;
4262 -> 1486;
4262 -> 1484;
4263 -> 1482;
4263 -> 1516;
4263 -> 1611;
4263 -> 4262;
4263 -> 1620;
4263 -> 1510;
4263 -> 1511;
4263 -> 4248;
4263 -> 1518;
4263 -> 1515;
4264 -> 1635;
4265 -> 4264;
4265 -> 1530;
4266 -> 4265;
4266 -> 1532;
4266 -> 1530;
4267 -> 1528;
4267 -> 1562;
4267 -> 1631;
4267 -> 4266;
4267 -> 1640;
4267 -> 1556;
4267 -> 1557;
4267 -> 4252;
4267 -> 1564;
4267 -> 1561;
4268 -> 1576;
4269 -> 4268;
4269 -> 1397;
4270 -> 4269;
4270 -> 1399;
4270 -> 1397;
4271 -> 1595;
4272 -> 4271;
4272 -> 1435;
4273 -> 4272;
4273 -> 1437;
4273 -> 1435;
4274 -> 1433;
4274 -> 1465;
4274 -> 1591;
4274 -> 4273;
4274 -> 1600;
4274 -> 1461;
4274 -> 1462;
4274 -> 4259;
4274 -> 1472;
4274 -> 1464;
4275 -> 1615;
4276 -> 4275;
4276 -> 1484;
4277 -> 4276;
4277 -> 1486;
4277 -> 1484;
4278 -> 1482;
4278 -> 1516;
4278 -> 1611;
4278 -> 4277;
4278 -> 1620;
4278 -> 1510;
4278 -> 1511;
4278 -> 4263;
4278 -> 1518;
4278 -> 1515;
4279 -> 1635;
4280 -> 4279;
4280 -> 1530;
4281 -> 4280;
4281 -> 1532;
4281 -> 1530;
4282 -> 1528;
4282 -> 1562;
4282 -> 1631;
4282 -> 4281;
4282 -> 1640;
4282 -> 1556;
4282 -> 1557;
4282 -> 4267;
4282 -> 1564;
4282 -> 1561;
4283 -> 1576;
4284 -> 4283;
4284 -> 1397;
4285 -> 4284;
4285 -> 1399;
4285 -> 1397;
4286 -> 1595;
4287 -> 4286;
4287 -> 1435;
4288 -> 4287;
4288 -> 1437;
4288 -> 1435;
4289 -> 1433;
4289 -> 1465;
4289 -> 1591;
4289 -> 4288;
4289 -> 1600;
4289 -> 1461;
4289 -> 1462;
4289 -> 4274;
4289 -> 1472;
4289 -> 1464;
4290 -> 1615;
4291 -> 4290;
4291 -> 1484;
4292 -> 4291;
4292 -> 1486;
4292 -> 1484;
4293 -> 1482;
4293 -> 1516;
4293 -> 1611;
4293 -> 4292;
4293 -> 1620;
4293 -> 1510;
4293 -> 1511;
4293 -> 4278;
4293 -> 1518;
4293 -> 1515;
4294 -> 1635;
4295 -> 4294;
4295 -> 1530;
4296 -> 4295;
4296 -> 1532;
4296 -> 1530;
4297 -> 1528;
4297 -> 1562;
4297 -> 1631;
4297 -> 4296;
4297 -> 1640;
4297 -> 1556;
4297 -> 1557;
4297 -> 4282;
4297 -> 1564;
4297 -> 1561;
4298 -> 1576;
4299 -> 4298;
4299 -> 1397;
4300 -> 4299;
4300 -> 1399;
4300 -> 1397;
4301 -> 1595;
4302 -> 4301;
4302 -> 1435;
4303 -> 4302;
4303 -> 1437;
4303 -> 1435;
4304 -> 1433;
4304 -> 1465;
4304 -> 1591;
4304 -> 4303;
4304 -> 1600;
4304 -> 1461;
4304 -> 1462;
4304 -> 4289;
4304 -> 1472;
4304 -> 1464;
4305 -> 1615;
4306 -> 4305;
4306 -> 1484;
4307 -> 4306;
4307 -> 1486;
4307 -> 1484;
4308 -> 1482;
4308 -> 1516;
4308 -> 1611;
4308 -> 4307;
4308 -> 1620;
4308 -> 1510;
4308 -> 1511;
4308 -> 4293;
4308 -> 1518;
4308 -> 1515;
4309 -> 1635;
4310 -> 4309;
4310 -> 1530;
4311 -> 4310;
4311 -> 1532;
4311 -> 1530;
4312 -> 1528;
4312 -> 1562;
4312 -> 1631;
4312 -> 4311;
4312 -> 1640;
4312 -> 1556;
4312 -> 1557;
4312 -> 4297;
4312 -> 1564;
4312 -> 1561;
4313 -> 1576;
4314 -> 4313;
4314 -> 1397;
4315 -> 4314;
4315 -> 1399;
4315 -> 1397;
4316 -> 1595;
4317 -> 4316;
4317 -> 1435;
4318 -> 4317;
4318 -> 1437;
4318 -> 1435;
4319 -> 1433;
4319 -> 1465;
4319 -> 1591;
4319 -> 4318;
4319 -> 1600;
4319 -> 1461;
4319 -> 1462;
4319 -> 4304;
4319 -> 1472;
4319 -> 1464;
4320 -> 1615;
4321 -> 4320;
4321 -> 1484;
4322 -> 4321;
4322 -> 1486;
4322 -> 1484;
4323 -> 1482;
4323 -> 1516;
4323 -> 1611;
4323 -> 4322;
4323 -> 1620;
4323 -> 1510;
4323 -> 1511;
4323 -> 4308;
4323 -> 1518;
4323 -> 1515;
4324 -> 1635;
4325 -> 4324;
4325 -> 1530;
4326 -> 4325;
4326 -> 1532;
4326 -> 1530;
4327 -> 1528;
4327 -> 1562;
4327 -> 1631;
4327 -> 4326;
4327 -> 1640;
4327 -> 1556;
4327 -> 1557;
4327 -> 4312;
4327 -> 1564;
4327 -> 1561;
4328 -> 1576;
4329 -> 4328;
4329 -> 1397;
4330 -> 4329;
4330 -> 1399;
4330 -> 1397;
4331 -> 1595;
4332 -> 4331;
4332 -> 1435;
4333 -> 4332;
4333 -> 1437;
4333 -> 1435;
4334 -> 1433;
4334 -> 1465;
4334 -> 1591;
4334 -> 4333;
4334 -> 1600;
4334 -> 1461;
4334 -> 1462;
4334 -> 4319;
4334 -> 1472;
4334 -> 1464;
4335 -> 1615;
4336 -> 4335;
4336 -> 1484;
4337 -> 4336;
4337 -> 1486;
4337 -> 1484;
4338 -> 1482;
4338 -> 1516;
4338 -> 1611;
4338 -> 4337;
4338 -> 1620;
4338 -> 1510;
4338 -> 1511;
4338 -> 4323;
4338 -> 1518;
4338 -> 1515;
4339 -> 1635;
4340 -> 4339;
4340 -> 1530;
4341 -> 4340;
4341 -> 1532;
4341 -> 1530;
4342 -> 1528;
4342 -> 1562;
4342 -> 1631;
4342 -> 4341;
4342 -> 1640;
4342 -> 1556;
4342 -> 1557;
4342 -> 4327;
4342 -> 1564;
4342 -> 1561;
4343 -> 1576;
4344 -> 4343;
4344 -> 1397;
4345 -> 4344;
4345 -> 1399;
4345 -> 1397;
4346 -> 1595;
4347 -> 4346;
4347 -> 1435;
4348 -> 4347;
4348 -> 1437;
4348 -> 1435;
4349 -> 1433;
4349 -> 1465;
4349 -> 1591;
4349 -> 4348;
4349 -> 1600;
4349 -> 1461;
4349 -> 1462;
4349 -> 4334;
4349 -> 1472;
4349 -> 1464;
4350 -> 1615;
4351 -> 4350;
4351 -> 1484;
4352 -> 4351;
4352 -> 1486;
4352 -> 1484;
4353 -> 1482;
4353 -> 1516;
4353 -> 1611;
4353 -> 4352;
4353 -> 1620;
4353 -> 1510;
4353 -> 1511;
4353 -> 4338;
4353 -> 1518;
4353 -> 1515;
4354 -> 1635;
4355 -> 4354;
4355 -> 1530;
4356 -> 4355;
4356 -> 1532;
4356 -> 1530;
4357 -> 1528;
4357 -> 1562;
4357 -> 1631;
4357 -> 4356;
4357 -> 1640;
4357 -> 1556;
4357 -> 1557;
4357 -> 4342;
4357 -> 1564;
4357 -> 1561;
4358 -> 1576;
4359 -> 4358;
4359 -> 1397;
4360 -> 4359;
4360 -> 1399;
4360 -> 1397;
4361 -> 1595;
4362 -> 4361;
4362 -> 1435;
4363 -> 4362;
4363 -> 1437;
4363 -> 1435;
4364 -> 1433;
4364 -> 1465;
4364 -> 1591;
4364 -> 4363;
4364 -> 1600;
4364 -> 1461;
4364 -> 1462;
4364 -> 4349;
4364 -> 1472;
4364 -> 1464;
4365 -> 1615;
4366 -> 4365;
4366 -> 1484;
4367 -> 4366;
4367 -> 1486;
4367 -> 1484;
4368 -> 1482;
4368 -> 1516;
4368 -> 1611;
4368 -> 4367;
4368 -> 1620;
4368 -> 1510;
4368 -> 1511;
4368 -> 4353;
4368 -> 1518;
4368 -> 1515;
4369 -> 1635;
4370 -> 4369;
4370 -> 1530;
4371 -> 4370;
4371 -> 1532;
4371 -> 1530;
4372 -> 1528;
4372 -> 1562;
4372 -> 1631;
4372 -> 4371;
4372 -> 1640;
4372 -> 1556;
4372 -> 1557;
4372 -> 4357;
4372 -> 1564;
4372 -> 1561;
4373 -> 1576;
4374 -> 4373;
4374 -> 1397;
4375 -> 4374;
4375 -> 1399;
4375 -> 1397;
4376 -> 1595;
4377 -> 4376;
4377 -> 1435;
4378 -> 4377;
4378 -> 1437;
4378 -> 1435;
4379 -> 1433;
4379 -> 1465;
4379 -> 1591;
4379 -> 4378;
4379 -> 1600;
4379 -> 1461;
4379 -> 1462;
4379 -> 4364;
4379 -> 1472;
4379 -> 1464;
4380 -> 1615;
4381 -> 4380;
4381 -> 1484;
4382 -> 4381;
4382 -> 1486;
4382 -> 1484;
4383 -> 1482;
4383 -> 1516;
4383 -> 1611;
4383 -> 4382;
4383 -> 1620;
4383 -> 1510;
4383 -> 1511;
4383 -> 4368;
4383 -> 1518;
4383 -> 1515;
4384 -> 1635;
4385 -> 4384;
4385 -> 1530;
4386 -> 4385;
4386 -> 1532;
4386 -> 1530;
4387 -> 1528;
4387 -> 1562;
4387 -> 1631;
4387 -> 4386;
4387 -> 1640;
4387 -> 1556;
4387 -> 1557;
4387 -> 4372;
4387 -> 1564;
4387 -> 1561;
4388 -> 1576;
4389 -> 4388;
4389 -> 1397;
4390 -> 4389;
4390 -> 1399;
4390 -> 1397;
4391 -> 1595;
4392 -> 4391;
4392 -> 1435;
4393 -> 4392;
4393 -> 1437;
4393 -> 1435;
4394 -> 1433;
4394 -> 1465;
4394 -> 1591;
4394 -> 4393;
4394 -> 1600;
4394 -> 1461;
4394 -> 1462;
4394 -> 4379;
4394 -> 1472;
4394 -> 1464;
4395 -> 1615;
4396 -> 4395;
4396 -> 1484;
4397 -> 4396;
4397 -> 1486;
4397 -> 1484;
4398 -> 1482;
4398 -> 1516;
4398 -> 1611;
4398 -> 4397;
4398 -> 1620;
4398 -> 1510;
4398 -> 1511;
4398 -> 4383;
4398 -> 1518;
4398 -> 1515;
4399 -> 1635;
4400 -> 4399;
4400 -> 1530;
4401 -> 4400;
4401 -> 1532;
4401 -> 1530;
4402 -> 1528;
4402 -> 1562;
4402 -> 1631;
4402 -> 4401;
4402 -> 1640;
4402 -> 1556;
4402 -> 1557;
4402 -> 4387;
4402 -> 1564;
4402 -> 1561;
4403 -> 1576;
4404 -> 4403;
4404 -> 1397;
4405 -> 4404;
4405 -> 1399;
4405 -> 1397;
4406 -> 1595;
4407 -> 4406;
4407 -> 1435;
4408 -> 4407;
4408 -> 1437;
4408 -> 1435;
4409 -> 1433;
4409 -> 1465;
4409 -> 1591;
4409 -> 4408;
4409 -> 1600;
4409 -> 1461;
4409 -> 1462;
4409 -> 4394;
4409 -> 1472;
4409 -> 1464;
4410 -> 1615;
4411 -> 4410;
4411 -> 1484;
4412 -> 4411;
4412 -> 1486;
4412 -> 1484;
4413 -> 1482;
4413 -> 1516;
4413 -> 1611;
4413 -> 4412;
4413 -> 1620;
4413 -> 1510;
4413 -> 1511;
4413 -> 4398;
4413 -> 1518;
4413 -> 1515;
4414 -> 1635;
4415 -> 4414;
4415 -> 1530;
4416 -> 4415;
4416 -> 1532;
4416 -> 1530;
4417 -> 1528;
4417 -> 1562;
4417 -> 1631;
4417 -> 4416;
4417 -> 1640;
4417 -> 1556;
4417 -> 1557;
4417 -> 4402;
4417 -> 1564;
4417 -> 1561;
4418 -> 1576;
4419 -> 4418;
4419 -> 1397;
4420 -> 4419;
4420 -> 1399;
4420 -> 1397;
4421 -> 1595;
4422 -> 4421;
4422 -> 1435;
4423 -> 4422;
4423 -> 1437;
4423 -> 1435;
4424 -> 1433;
4424 -> 1465;
4424 -> 1591;
4424 -> 4423;
4424 -> 1600;
4424 -> 1461;
4424 -> 1462;
4424 -> 4409;
4424 -> 1472;
4424 -> 1464;
4425 -> 1615;
4426 -> 4425;
4426 -> 1484;
4427 -> 4426;
4427 -> 1486;
4427 -> 1484;
4428 -> 1482;
4428 -> 1516;
4428 -> 1611;
4428 -> 4427;
4428 -> 1620;
4428 -> 1510;
4428 -> 1511;
4428 -> 4413;
4428 -> 1518;
4428 -> 1515;
4429 -> 1635;
4430 -> 4429;
4430 -> 1530;
4431 -> 4430;
4431 -> 1532;
4431 -> 1530;
4432 -> 1528;
4432 -> 1562;
4432 -> 1631;
4432 -> 4431;
4432 -> 1640;
4432 -> 1556;
4432 -> 1557;
4432 -> 4417;
4432 -> 1564;
4432 -> 1561;
4433 -> 1576;
4434 -> 4433;
4434 -> 1397;
4435 -> 4434;
4435 -> 1399;
4435 -> 1397;
4436 -> 1595;
4437 -> 4436;
4437 -> 1435;
4438 -> 4437;
4438 -> 1437;
4438 -> 1435;
4439 -> 1433;
4439 -> 1465;
4439 -> 1591;
4439 -> 4438;
4439 -> 1600;
4439 -> 1461;
4439 -> 1462;
4439 -> 4424;
4439 -> 1472;
4439 -> 1464;
4440 -> 1615;
4441 -> 4440;
4441 -> 1484;
4442 -> 4441;
4442 -> 1486;
4442 -> 1484;
4443 -> 1482;
4443 -> 1516;
4443 -> 1611;
4443 -> 4442;
4443 -> 1620;
4443 -> 1510;
4443 -> 1511;
4443 -> 4428;
4443 -> 1518;
4443 -> 1515;
4444 -> 1635;
4445 -> 4444;
4445 -> 1530;
4446 -> 4445;
4446 -> 1532;
4446 -> 1530;
4447 -> 1528;
4447 -> 1562;
4447 -> 1631;
4447 -> 4446;
4447 -> 1640;
4447 -> 1556;
4447 -> 1557;
4447 -> 4432;
4447 -> 1564;
4447 -> 1561;
4448 -> 1576;
4449 -> 4448;
4449 -> 1397;
4450 -> 4449;
4450 -> 1399;
4450 -> 1397;
4451 -> 1595;
4452 -> 4451;
4452 -> 1435;
4453 -> 4452;
4453 -> 1437;
4453 -> 1435;
4454 -> 1433;
4454 -> 1465;
4454 -> 1591;
4454 -> 4453;
4454 -> 1600;
4454 -> 1461;
4454 -> 1462;
4454 -> 4439;
4454 -> 1472;
4454 -> 1464;
4455 -> 1615;
4456 -> 4455;
4456 -> 1484;
4457 -> 4456;
4457 -> 1486;
4457 -> 1484;
4458 -> 1482;
4458 -> 1516;
4458 -> 1611;
4458 -> 4457;
4458 -> 1620;
4458 -> 1510;
4458 -> 1511;
4458 -> 4443;
4458 -> 1518;
4458 -> 1515;
4459 -> 1635;
4460 -> 4459;
4460 -> 1530;
4461 -> 4460;
4461 -> 1532;
4461 -> 1530;
4462 -> 1528;
4462 -> 1562;
4462 -> 1631;
4462 -> 4461;
4462 -> 1640;
4462 -> 1556;
4462 -> 1557;
4462 -> 4447;
4462 -> 1564;
4462 -> 1561;
4463 -> 1576;
4464 -> 4463;
4464 -> 1397;
4465 -> 4464;
4465 -> 1399;
4465 -> 1397;
4466 -> 1595;
4467 -> 4466;
4467 -> 1435;
4468 -> 4467;
4468 -> 1437;
4468 -> 1435;
4469 -> 1433;
4469 -> 1465;
4469 -> 1591;
4469 -> 4468;
4469 -> 1600;
4469 -> 1461;
4469 -> 1462;
4469 -> 4454;
4469 -> 1472;
4469 -> 1464;
4470 -> 1615;
4471 -> 4470;
4471 -> 1484;
4472 -> 4471;
4472 -> 1486;
4472 -> 1484;
4473 -> 1482;
4473 -> 1516;
4473 -> 1611;
4473 -> 4472;
4473 -> 1620;
4473 -> 1510;
4473 -> 1511;
4473 -> 4458;
4473 -> 1518;
4473 -> 1515;
4474 -> 1635;
4475 -> 4474;
4475 -> 1530;
4476 -> 4475;
4476 -> 1532;
4476 -> 1530;
4477 -> 1528;
4477 -> 1562;
4477 -> 1631;
4477 -> 4476;
4477 -> 1640;
4477 -> 1556;
4477 -> 1557;
4477 -> 4462;
4477 -> 1564;
4477 -> 1561;
4478 -> 1576;
4479 -> 4478;
4479 -> 1397;
4480 -> 4479;
4480 -> 1399;
4480 -> 1397;
4481 -> 1595;
4482 -> 4481;
4482 -> 1435;
4483 -> 4482;
4483 -> 1437;
4483 -> 1435;
4484 -> 1433;
4484 -> 1465;
4484 -> 1591;
4484 -> 4483;
4484 -> 1600;
4484 -> 1461;
4484 -> 1462;
4484 -> 4469;
4484 -> 1472;
4484 -> 1464;
4485 -> 1615;
4486 -> 4485;
4486 -> 1484;
4487 -> 4486;
4487 -> 1486;
4487 -> 1484;
4488 -> 1482;
4488 -> 1516;
4488 -> 1611;
4488 -> 4487;
4488 -> 1620;
4488 -> 1510;
4488 -> 1511;
4488 -> 4473;
4488 -> 1518;
4488 -> 1515;
4489 -> 1635;
4490 -> 4489;
4490 -> 1530;
4491 -> 4490;
4491 -> 1532;
4491 -> 1530;
4492 -> 1528;
4492 -> 1562;
4492 -> 1631;
4492 -> 4491;
4492 -> 1640;
4492 -> 1556;
4492 -> 1557;
4492 -> 4477;
4492 -> 1564;
4492 -> 1561;
4493 -> 1576;
4494 -> 4493;
4494 -> 1397;
4495 -> 4494;
4495 -> 1399;
4495 -> 1397;
4496 -> 1595;
4497 -> 4496;
4497 -> 1435;
4498 -> 4497;
4498 -> 1437;
4498 -> 1435;
4499 -> 1433;
4499 -> 1465;
4499 -> 1591;
4499 -> 4498;
4499 -> 1600;
4499 -> 1461;
4499 -> 1462;
4499 -> 4484;
4499 -> 1472;
4499 -> 1464;
4500 -> 1615;
4501 -> 4500;
4501 -> 1484;
4502 -> 4501;
4502 -> 1486;
4502 -> 1484;
4503 -> 1482;
4503 -> 1516;
4503 -> 1611;
4503 -> 4502;
4503 -> 1620;
4503 -> 1510;
4503 -> 1511;
4503 -> 4488;
4503 -> 1518;
4503 -> 1515;
4504 -> 1635;
4505 -> 4504;
4505 -> 1530;
4506 -> 4505;
4506 -> 1532;
4506 -> 1530;
4507 -> 1528;
4507 -> 1562;
4507 -> 1631;
4507 -> 4506;
4507 -> 1640;
4507 -> 1556;
4507 -> 1557;
4507 -> 4492;
4507 -> 1564;
4507 -> 1561;
4508 -> 1576;
4509 -> 4508;
4509 -> 1397;
4510 -> 4509;
4510 -> 1399;
4510 -> 1397;
4511 -> 1595;
4512 -> 4511;
4512 -> 1435;
4513 -> 4512;
4513 -> 1437;
4513 -> 1435;
4514 -> 1433;
4514 -> 1465;
4514 -> 1591;
4514 -> 4513;
4514 -> 1600;
4514 -> 1461;
4514 -> 1462;
4514 -> 4499;
4514 -> 1472;
4514 -> 1464;
4515 -> 1615;
4516 -> 4515;
4516 -> 1484;
4517 -> 4516;
4517 -> 1486;
4517 -> 1484;
4518 -> 1482;
4518 -> 1516;
4518 -> 1611;
4518 -> 4517;
4518 -> 1620;
4518 -> 1510;
4518 -> 1511;
4518 -> 4503;
4518 -> 1518;
4518 -> 1515;
4519 -> 1635;
4520 -> 4519;
4520 -> 1530;
4521 -> 4520;
4521 -> 1532;
4521 -> 1530;
4522 -> 1528;
4522 -> 1562;
4522 -> 1631;
4522 -> 4521;
4522 -> 1640;
4522 -> 1556;
4522 -> 1557;
4522 -> 4507;
4522 -> 1564;
4522 -> 1561;
4523 -> 1576;
4524 -> 4523;
4524 -> 1397;
4525 -> 4524;
4525 -> 1399;
4525 -> 1397;
4526 -> 1595;
4527 -> 4526;
4527 -> 1435;
4528 -> 4527;
4528 -> 1437;
4528 -> 1435;
4529 -> 1433;
4529 -> 1465;
4529 -> 1591;
4529 -> 4528;
4529 -> 1600;
4529 -> 1461;
4529 -> 1462;
4529 -> 4514;
4529 -> 1472;
4529 -> 1464;
4530 -> 1615;
4531 -> 4530;
4531 -> 1484;
4532 -> 4531;
4532 -> 1486;
4532 -> 1484;
4533 -> 1482;
4533 -> 1516;
4533 -> 1611;
4533 -> 4532;
4533 -> 1620;
4533 -> 1510;
4533 -> 1511;
4533 -> 4518;
4533 -> 1518;
4533 -> 1515;
4534 -> 1635;
4535 -> 4534;
4535 -> 1530;
4536 -> 4535;
4536 -> 1532;
4536 -> 1530;
4537 -> 1528;
4537 -> 1562;
4537 -> 1631;
4537 -> 4536;
4537 -> 1640;
4537 -> 1556;
4537 -> 1557;
4537 -> 4522;
4537 -> 1564;
4537 -> 1561;
4538 -> 1576;
4539 -> 4538;
4539 -> 1397;
4540 -> 4539;
4540 -> 1399;
4540 -> 1397;
4541 -> 1595;
4542 -> 4541;
4542 -> 1435;
4543 -> 4542;
4543 -> 1437;
4543 -> 1435;
4544 -> 1433;
4544 -> 1465;
4544 -> 1591;
4544 -> 4543;
4544 -> 1600;
4544 -> 1461;
4544 -> 1462;
4544 -> 4529;
4544 -> 1472;
4544 -> 1464;
4545 -> 1615;
4546 -> 4545;
4546 -> 1484;
4547 -> 4546;
4547 -> 1486;
4547 -> 1484;
4548 -> 1482;
4548 -> 1516;
4548 -> 1611;
4548 -> 4547;
4548 -> 1620;
4548 -> 1510;
4548 -> 1511;
4548 -> 4533;
4548 -> 1518;
4548 -> 1515;
4549 -> 1635;
4550 -> 4549;
4550 -> 1530;
4551 -> 4550;
4551 -> 1532;
4551 -> 1530;
4552 -> 1528;
4552 -> 1562;
4552 -> 1631;
4552 -> 4551;
4552 -> 1640;
4552 -> 1556;
4552 -> 1557;
4552 -> 4537;
4552 -> 1564;
4552 -> 1561;
4553 -> 1576;
4554 -> 4553;
4554 -> 1397;
4555 -> 4554;
4555 -> 1399;
4555 -> 1397;
4556 -> 1595;
4557 -> 4556;
4557 -> 1435;
4558 -> 4557;
4558 -> 1437;
4558 -> 1435;
4559 -> 1433;
4559 -> 1465;
4559 -> 1591;
4559 -> 4558;
4559 -> 1600;
4559 -> 1461;
4559 -> 1462;
4559 -> 4544;
4559 -> 1472;
4559 -> 1464;
4560 -> 1615;
4561 -> 4560;
4561 -> 1484;
4562 -> 4561;
4562 -> 1486;
4562 -> 1484;
4563 -> 1482;
4563 -> 1516;
4563 -> 1611;
4563 -> 4562;
4563 -> 1620;
4563 -> 1510;
4563 -> 1511;
4563 -> 4548;
4563 -> 1518;
4563 -> 1515;
4564 -> 1635;
4565 -> 4564;
4565 -> 1530;
4566 -> 4565;
4566 -> 1532;
4566 -> 1530;
4567 -> 1528;
4567 -> 1562;
4567 -> 1631;
4567 -> 4566;
4567 -> 1640;
4567 -> 1556;
4567 -> 1557;
4567 -> 4552;
4567 -> 1564;
4567 -> 1561;
4568 -> 1576;
4569 -> 4568;
4569 -> 1397;
4570 -> 4569;
4570 -> 1399;
4570 -> 1397;
4571 -> 1595;
4572 -> 4571;
4572 -> 1435;
4573 -> 4572;
4573 -> 1437;
4573 -> 1435;
4574 -> 1433;
4574 -> 1465;
4574 -> 1591;
4574 -> 4573;
4574 -> 1600;
4574 -> 1461;
4574 -> 1462;
4574 -> 4559;
4574 -> 1472;
4574 -> 1464;
4575 -> 1615;
4576 -> 4575;
4576 -> 1484;
4577 -> 4576;
4577 -> 1486;
4577 -> 1484;
4578 -> 1482;
4578 -> 1516;
4578 -> 1611;
4578 -> 4577;
4578 -> 1620;
4578 -> 1510;
4578 -> 1511;
4578 -> 4563;
4578 -> 1518;
4578 -> 1515;
4579 -> 1635;
4580 -> 4579;
4580 -> 1530;
4581 -> 4580;
4581 -> 1532;
4581 -> 1530;
4582 -> 1528;
4582 -> 1562;
4582 -> 1631;
4582 -> 4581;
4582 -> 1640;
4582 -> 1556;
4582 -> 1557;
4582 -> 4567;
4582 -> 1564;
4582 -> 1561;
4583 -> 1576;
4584 -> 4583;
4584 -> 1397;
4585 -> 4584;
4585 -> 1399;
4585 -> 1397;
4586 -> 1595;
4587 -> 4586;
4587 -> 1435;
4588 -> 4587;
4588 -> 1437;
4588 -> 1435;
4589 -> 1433;
4589 -> 1465;
4589 -> 1591;
4589 -> 4588;
4589 -> 1600;
4589 -> 1461;
4589 -> 1462;
4589 -> 4574;
4589 -> 1472;
4589 -> 1464;
4590 -> 1615;
4591 -> 4590;
4591 -> 1484;
4592 -> 4591;
4592 -> 1486;
4592 -> 1484;
4593 -> 1482;
4593 -> 1516;
4593 -> 1611;
4593 -> 4592;
4593 -> 1620;
4593 -> 1510;
4593 -> 1511;
4593 -> 4578;
4593 -> 1518;
4593 -> 1515;
4594 -> 1635;
4595 -> 4594;
4595 -> 1530;
4596 -> 4595;
4596 -> 1532;
4596 -> 1530;
4597 -> 1528;
4597 -> 1562;
4597 -> 1631;
4597 -> 4596;
4597 -> 1640;
4597 -> 1556;
4597 -> 1557;
4597 -> 4582;
4597 -> 1564;
4597 -> 1561;
4598 -> 1576;
4599 -> 4598;
4599 -> 1397;
4600 -> 4599;
4600 -> 1399;
4600 -> 1397;
4601 -> 1595;
4602 -> 4601;
4602 -> 1435;
4603 -> 4602;
4603 -> 1437;
4603 -> 1435;
4604 -> 1433;
4604 -> 1465;
4604 -> 1591;
4604 -> 4603;
4604 -> 1600;
4604 -> 1461;
4604 -> 1462;
4604 -> 4589;
4604 -> 1472;
4604 -> 1464;
4605 -> 1615;
4606 -> 4605;
4606 -> 1484;
4607 -> 4606;
4607 -> 1486;
4607 -> 1484;
4608 -> 1482;
4608 -> 1516;
4608 -> 1611;
4608 -> 4607;
4608 -> 1620;
4608 -> 1510;
4608 -> 1511;
4608 -> 4593;
4608 -> 1518;
4608 -> 1515;
4609 -> 1635;
4610 -> 4609;
4610 -> 1530;
4611 -> 4610;
4611 -> 1532;
4611 -> 1530;
4612 -> 1528;
4612 -> 1562;
4612 -> 1631;
4612 -> 4611;
4612 -> 1640;
4612 -> 1556;
4612 -> 1557;
4612 -> 4597;
4612 -> 1564;
4612 -> 1561;
4613 -> 1576;
4614 -> 4613;
4614 -> 1397;
4615 -> 4614;
4615 -> 1399;
4615 -> 1397;
4616 -> 1595;
4617 -> 4616;
4617 -> 1435;
4618 -> 4617;
4618 -> 1437;
4618 -> 1435;
4619 -> 1433;
4619 -> 1465;
4619 -> 1591;
4619 -> 4618;
4619 -> 1600;
4619 -> 1461;
4619 -> 1462;
4619 -> 4604;
4619 -> 1472;
4619 -> 1464;
4620 -> 1615;
4621 -> 4620;
4621 -> 1484;
4622 -> 4621;
4622 -> 1486;
4622 -> 1484;
4623 -> 1482;
4623 -> 1516;
4623 -> 1611;
4623 -> 4622;
4623 -> 1620;
4623 -> 1510;
4623 -> 1511;
4623 -> 4608;
4623 -> 1518;
4623 -> 1515;
4624 -> 1635;
4625 -> 4624;
4625 -> 1530;
4626 -> 4625;
4626 -> 1532;
4626 -> 1530;
4627 -> 1528;
4627 -> 1562;
4627 -> 1631;
4627 -> 4626;
4627 -> 1640;
4627 -> 1556;
4627 -> 1557;
4627 -> 4612;
4627 -> 1564;
4627 -> 1561;
4628 -> 1576;
4629 -> 4628;
4629 -> 1397;
4630 -> 4629;
4630 -> 1399;
4630 -> 1397;
4631 -> 1595;
4632 -> 4631;
4632 -> 1435;
4633 -> 4632;
4633 -> 1437;
4633 -> 1435;
4634 -> 1433;
4634 -> 1465;
4634 -> 1591;
4634 -> 4633;
4634 -> 1600;
4634 -> 1461;
4634 -> 1462;
4634 -> 4619;
4634 -> 1472;
4634 -> 1464;
4635 -> 1615;
4636 -> 4635;
4636 -> 1484;
4637 -> 4636;
4637 -> 1486;
4637 -> 1484;
4638 -> 1482;
4638 -> 1516;
4638 -> 1611;
4638 -> 4637;
4638 -> 1620;
4638 -> 1510;
4638 -> 1511;
4638 -> 4623;
4638 -> 1518;
4638 -> 1515;
4639 -> 1635;
4640 -> 4639;
4640 -> 1530;
4641 -> 4640;
4641 -> 1532;
4641 -> 1530;
4642 -> 1528;
4642 -> 1562;
4642 -> 1631;
4642 -> 4641;
4642 -> 1640;
4642 -> 1556;
4642 -> 1557;
4642 -> 4627;
4642 -> 1564;
4642 -> 1561;
4643 -> 1576;
4644 -> 4643;
4644 -> 1397;
4645 -> 4644;
4645 -> 1399;
4645 -> 1397;
4646 -> 1595;
4647 -> 4646;
4647 -> 1435;
4648 -> 4647;
4648 -> 1437;
4648 -> 1435;
4649 -> 1433;
4649 -> 1465;
4649 -> 1591;
4649 -> 4648;
4649 -> 1600;
4649 -> 1461;
4649 -> 1462;
4649 -> 4634;
4649 -> 1472;
4649 -> 1464;
4650 -> 1615;
4651 -> 4650;
4651 -> 1484;
4652 -> 4651;
4652 -> 1486;
4652 -> 1484;
4653 -> 1482;
4653 -> 1516;
4653 -> 1611;
4653 -> 4652;
4653 -> 1620;
4653 -> 1510;
4653 -> 1511;
4653 -> 4638;
4653 -> 1518;
4653 -> 1515;
4654 -> 1635;
4655 -> 4654;
4655 -> 1530;
4656 -> 4655;
4656 -> 1532;
4656 -> 1530;
4657 -> 1528;
4657 -> 1562;
4657 -> 1631;
4657 -> 4656;
4657 -> 1640;
4657 -> 1556;
4657 -> 1557;
4657 -> 4642;
4657 -> 1564;
4657 -> 1561;
4658 -> 1576;
4659 -> 4658;
4659 -> 1397;
4660 -> 4659;
4660 -> 1399;
4660 -> 1397;
4661 -> 1595;
4662 -> 4661;
4662 -> 1435;
4663 -> 4662;
4663 -> 1437;
4663 -> 1435;
4664 -> 1433;
4664 -> 1465;
4664 -> 1591;
4664 -> 4663;
4664 -> 1600;
4664 -> 1461;
4664 -> 1462;
4664 -> 4649;
4664 -> 1472;
4664 -> 1464;
4665 -> 1615;
4666 -> 4665;
4666 -> 1484;
4667 -> 4666;
4667 -> 1486;
4667 -> 1484;
4668 -> 1482;
4668 -> 1516;
4668 -> 1611;
4668 -> 4667;
4668 -> 1620;
4668 -> 1510;
4668 -> 1511;
4668 -> 4653;
4668 -> 1518;
4668 -> 1515;
4669 -> 1635;
4670 -> 4669;
4670 -> 1530;
4671 -> 4670;
4671 -> 1532;
4671 -> 1530;
4672 -> 1528;
4672 -> 1562;
4672 -> 1631;
4672 -> 4671;
4672 -> 1640;
4672 -> 1556;
4672 -> 1557;
4672 -> 4657;
4672 -> 1564;
4672 -> 1561;
4673 -> 1576;
4674 -> 4673;
4674 -> 1397;
4675 -> 4674;
4675 -> 1399;
4675 -> 1397;
4676 -> 1595;
4677 -> 4676;
4677 -> 1435;
4678 -> 4677;
4678 -> 1437;
4678 -> 1435;
4679 -> 1433;
4679 -> 1465;
4679 -> 1591;
4679 -> 4678;
4679 -> 1600;
4679 -> 1461;
4679 -> 1462;
4679 -> 4664;
4679 -> 1472;
4679 -> 1464;
4680 -> 1615;
4681 -> 4680;
4681 -> 1484;
4682 -> 4681;
4682 -> 1486;
4682 -> 1484;
4683 -> 1482;
4683 -> 1516;
4683 -> 1611;
4683 -> 4682;
4683 -> 1620;
4683 -> 1510;
4683 -> 1511;
4683 -> 4668;
4683 -> 1518;
4683 -> 1515;
4684 -> 1635;
4685 -> 4684;
4685 -> 1530;
4686 -> 4685;
4686 -> 1532;
4686 -> 1530;
4687 -> 1528;
4687 -> 1562;
4687 -> 1631;
4687 -> 4686;
4687 -> 1640;
4687 -> 1556;
4687 -> 1557;
4687 -> 4672;
4687 -> 1564;
4687 -> 1561;
4688 -> 1576;
4689 -> 4688;
4689 -> 1397;
4690 -> 4689;
4690 -> 1399;
4690 -> 1397;
4691 -> 1595;
4692 -> 4691;
4692 -> 1435;
4693 -> 4692;
4693 -> 1437;
4693 -> 1435;
4694 -> 1433;
4694 -> 1465;
4694 -> 1591;
4694 -> 4693;
4694 -> 1600;
4694 -> 1461;
4694 -> 1462;
4694 -> 4679;
4694 -> 1472;
4694 -> 1464;
4695 -> 1615;
4696 -> 4695;
4696 -> 1484;
4697 -> 4696;
4697 -> 1486;
4697 -> 1484;
4698 -> 1482;
4698 -> 1516;
4698 -> 1611;
4698 -> 4697;
4698 -> 1620;
4698 -> 1510;
4698 -> 1511;
4698 -> 4683;
4698 -> 1518;
4698 -> 1515;
4699 -> 1635;
4700 -> 4699;
4700 -> 1530;
4701 -> 4700;
4701 -> 1532;
4701 -> 1530;
4702 -> 1528;
4702 -> 1562;
4702 -> 1631;
4702 -> 4701;
4702 -> 1640;
4702 -> 1556;
4702 -> 1557;
4702 -> 4687;
4702 -> 1564;
4702 -> 1561;
4703 -> 1576;
4704 -> 4703;
4704 -> 1397;
4705 -> 4704;
4705 -> 1399;
4705 -> 1397;
4706 -> 1595;
4707 -> 4706;
4707 -> 1435;
4708 -> 4707;
4708 -> 1437;
4708 -> 1435;
4709 -> 1433;
4709 -> 1465;
4709 -> 1591;
4709 -> 4708;
4709 -> 1600;
4709 -> 1461;
4709 -> 1462;
4709 -> 4694;
4709 -> 1472;
4709 -> 1464;
4710 -> 1615;
4711 -> 4710;
4711 -> 1484;
4712 -> 4711;
4712 -> 1486;
4712 -> 1484;
4713 -> 1482;
4713 -> 1516;
4713 -> 1611;
4713 -> 4712;
4713 -> 1620;
4713 -> 1510;
4713 -> 1511;
4713 -> 4698;
4713 -> 1518;
4713 -> 1515;
4714 -> 1635;
4715 -> 4714;
4715 -> 1530;
4716 -> 4715;
4716 -> 1532;
4716 -> 1530;
4717 -> 1528;
4717 -> 1562;
4717 -> 1631;
4717 -> 4716;
4717 -> 1640;
4717 -> 1556;
4717 -> 1557;
4717 -> 4702;
4717 -> 1564;
4717 -> 1561;
4718 -> 1576;
4719 -> 4718;
4719 -> 1397;
4720 -> 4719;
4720 -> 1399;
4720 -> 1397;
4721 -> 1595;
4722 -> 4721;
4722 -> 1435;
4723 -> 4722;
4723 -> 1437;
4723 -> 1435;
4724 -> 1433;
4724 -> 1465;
4724 -> 1591;
4724 -> 4723;
4724 -> 1600;
4724 -> 1461;
4724 -> 1462;
4724 -> 4709;
4724 -> 1472;
4724 -> 1464;
4725 -> 1615;
4726 -> 4725;
4726 -> 1484;
4727 -> 4726;
4727 -> 1486;
4727 -> 1484;
4728 -> 1482;
4728 -> 1516;
4728 -> 1611;
4728 -> 4727;
4728 -> 1620;
4728 -> 1510;
4728 -> 1511;
4728 -> 4713;
4728 -> 1518;
4728 -> 1515;
4729 -> 1635;
4730 -> 4729;
4730 -> 1530;
4731 -> 4730;
4731 -> 1532;
4731 -> 1530;
4732 -> 1528;
4732 -> 1562;
4732 -> 1631;
4732 -> 4731;
4732 -> 1640;
4732 -> 1556;
4732 -> 1557;
4732 -> 4717;
4732 -> 1564;
4732 -> 1561;
4733 -> 1576;
4734 -> 4733;
4734 -> 1397;
4735 -> 4734;
4735 -> 1399;
4735 -> 1397;
4736 -> 1595;
4737 -> 4736;
4737 -> 1435;
4738 -> 4737;
4738 -> 1437;
4738 -> 1435;
4739 -> 1433;
4739 -> 1465;
4739 -> 1591;
4739 -> 4738;
4739 -> 1600;
4739 -> 1461;
4739 -> 1462;
4739 -> 4724;
4739 -> 1472;
4739 -> 1464;
4740 -> 1615;
4741 -> 4740;
4741 -> 1484;
4742 -> 4741;
4742 -> 1486;
4742 -> 1484;
4743 -> 1482;
4743 -> 1516;
4743 -> 1611;
4743 -> 4742;
4743 -> 1620;
4743 -> 1510;
4743 -> 1511;
4743 -> 4728;
4743 -> 1518;
4743 -> 1515;
4744 -> 1635;
4745 -> 4744;
4745 -> 1530;
4746 -> 4745;
4746 -> 1532;
4746 -> 1530;
4747 -> 1528;
4747 -> 1562;
4747 -> 1631;
4747 -> 4746;
4747 -> 1640;
4747 -> 1556;
4747 -> 1557;
4747 -> 4732;
4747 -> 1564;
4747 -> 1561;
4748 -> 1576;
4749 -> 4748;
4749 -> 1397;
4750 -> 4749;
4750 -> 1399;
4750 -> 1397;
4751 -> 1595;
4752 -> 4751;
4752 -> 1435;
4753 -> 4752;
4753 -> 1437;
4753 -> 1435;
4754 -> 1433;
4754 -> 1465;
4754 -> 1591;
4754 -> 4753;
4754 -> 1600;
4754 -> 1461;
4754 -> 1462;
4754 -> 4739;
4754 -> 1472;
4754 -> 1464;
4755 -> 1615;
4756 -> 4755;
4756 -> 1484;
4757 -> 4756;
4757 -> 1486;
4757 -> 1484;
4758 -> 1482;
4758 -> 1516;
4758 -> 1611;
4758 -> 4757;
4758 -> 1620;
4758 -> 1510;
4758 -> 1511;
4758 -> 4743;
4758 -> 1518;
4758 -> 1515;
4759 -> 1635;
4760 -> 4759;
4760 -> 1530;
4761 -> 4760;
4761 -> 1532;
4761 -> 1530;
4762 -> 1528;
4762 -> 1562;
4762 -> 1631;
4762 -> 4761;
4762 -> 1640;
4762 -> 1556;
4762 -> 1557;
4762 -> 4747;
4762 -> 1564;
4762 -> 1561;
4763 -> 1576;
4764 -> 4763;
4764 -> 1397;
4765 -> 4764;
4765 -> 1399;
4765 -> 1397;
4766 -> 1595;
4767 -> 4766;
4767 -> 1435;
4768 -> 4767;
4768 -> 1437;
4768 -> 1435;
4769 -> 1433;
4769 -> 1465;
4769 -> 1591;
4769 -> 4768;
4769 -> 1600;
4769 -> 1461;
4769 -> 1462;
4769 -> 4754;
4769 -> 1472;
4769 -> 1464;
4770 -> 1615;
4771 -> 4770;
4771 -> 1484;
4772 -> 4771;
4772 -> 1486;
4772 -> 1484;
4773 -> 1482;
4773 -> 1516;
4773 -> 1611;
4773 -> 4772;
4773 -> 1620;
4773 -> 1510;
4773 -> 1511;
4773 -> 4758;
4773 -> 1518;
4773 -> 1515;
4774 -> 1635;
4775 -> 4774;
4775 -> 1530;
4776 -> 4775;
4776 -> 1532;
4776 -> 1530;
4777 -> 1528;
4777 -> 1562;
4777 -> 1631;
4777 -> 4776;
4777 -> 1640;
4777 -> 1556;
4777 -> 1557;
4777 -> 4762;
4777 -> 1564;
4777 -> 1561;
4778 -> 1576;
4779 -> 4778;
4779 -> 1397;
4780 -> 4779;
4780 -> 1399;
4780 -> 1397;
4781 -> 1595;
4782 -> 4781;
4782 -> 1435;
4783 -> 4782;
4783 -> 1437;
4783 -> 1435;
4784 -> 1433;
4784 -> 1465;
4784 -> 1591;
4784 -> 4783;
4784 -> 1600;
4784 -> 1461;
4784 -> 1462;
4784 -> 4769;
4784 -> 1472;
4784 -> 1464;
4785 -> 1615;
4786 -> 4785;
4786 -> 1484;
4787 -> 4786;
4787 -> 1486;
4787 -> 1484;
4788 -> 1482;
4788 -> 1516;
4788 -> 1611;
4788 -> 4787;
4788 -> 1620;
4788 -> 1510;
4788 -> 1511;
4788 -> 4773;
4788 -> 1518;
4788 -> 1515;
4789 -> 1635;
4790 -> 4789;
4790 -> 1530;
4791 -> 4790;
4791 -> 1532;
4791 -> 1530;
4792 -> 1528;
4792 -> 1562;
4792 -> 1631;
4792 -> 4791;
4792 -> 1640;
4792 -> 1556;
4792 -> 1557;
4792 -> 4777;
4792 -> 1564;
4792 -> 1561;
4793 -> 1371;
4793 -> 1369;
4794 -> 1370;
4794 -> 1369;
4795 -> 1372;
4795 -> 1369;
4796 -> 1369;
4797 -> 4793;
4797 -> 4796;
4798 -> 4794;
4798 -> 4796;
4799 -> 4795;
4799 -> 4796;
4800 -> 4797;
4800 -> 1374;
4800 -> 4796;
4801 -> 4796;
4802 -> 4798;
4802 -> 4801;
4802 -> 4796;
4803 -> 4802;
4804 -> 4799;
4804 -> 4803;
4804 -> 4802;
4805 -> 4799;
4805 -> 408;
4805 -> 4804;
4806 -> 1386;
4806 -> 1385;
4806 -> 4797;
4806 -> 4805;
4807 -> 1350;
4808 -> 1354;
4808 -> 4807;
4808 -> 1350;
4809 -> 4806;
4809 -> 1350;
4810 -> 4809;
4810 -> 1118;
4811 -> 1118;
4812 -> 4810;
4812 -> 4811;
4813 -> 1107;
4813 -> 4811;
4814 -> 4811;
4815 -> 4812;
4815 -> 4814;
4815 -> 4811;
4816 -> 4813;
4816 -> 1078;
4816 -> 1114;
4816 -> 1113;
4816 -> 4811;
4817 -> 4813;
4817 -> 1114;
4817 -> 1113;
4817 -> 1078;
4817 -> 4811;
4818 -> 4812;
4818 -> 4817;
4818 -> 4811;
4819 -> 4813;
4819 -> 1078;
4819 -> 4811;
4820 -> 1118;
4821 -> 1118;
4822 -> 4809;
4822 -> 4821;
4823 -> 4822;
4823 -> 4821;
4824 -> 4823;
4824 -> 1118;
4825 -> 1358;
4826 -> 1358;
4827 -> 4826;
4827 -> 1358;
4828 -> 1358;
4829 -> 1358;
4830 -> 1358;
4831 -> 1358;
4832 -> 1358;
4833 -> 1358;
4834 -> 4828;
4834 -> 1358;
4835 -> 4829;
4835 -> 1358;
4836 -> 4830;
4836 -> 1358;
4837 -> 4831;
4837 -> 1358;
4838 -> 4833;
4838 -> 4827;
4838 -> 4834;
4838 -> 4835;
4838 -> 4836;
4838 -> 4837;
4838 -> 1358;
4839 -> 1358;
4840 -> 4838;
4840 -> 4839;
4840 -> 1358;
4841 -> 4832;
4841 -> 4838;
4841 -> 4840;
4842 -> 4840;
4843 -> 4841;
4843 -> 4842;
4844 -> 4842;
4845 -> 4843;
4845 -> 4841;
4845 -> 4844;
4846 -> 4845;
4846 -> 4842;
4847 -> 4842;
4848 -> 4843;
4848 -> 4841;
4848 -> 4847;
4849 -> 4848;
4849 -> 4842;
4850 -> 4842;
4851 -> 4849;
4851 -> 4850;
4852 -> 4843;
4852 -> 4841;
4852 -> 4850;
4853 -> 4842;
4854 -> 4842;
4855 -> 4843;
4855 -> 4854;
4856 -> 4855;
4856 -> 4841;
4856 -> 4851;
4856 -> 4854;
4857 -> 4854;
4858 -> 4855;
4858 -> 4856;
4858 -> 4857;
4859 -> 4858;
4859 -> 4854;
4860 -> 4854;
4861 -> 4860;
4861 -> 4854;
4862 -> 4854;
4863 -> 4854;
4864 -> 4856;
4864 -> 4854;
4865 -> 4856;
4866 -> 4856;
4866 -> 4854;
4867 -> 4866;
4868 -> 4854;
4869 -> 4856;
4869 -> 4854;
4870 -> 4854;
4871 -> 4869;
4871 -> 4870;
4872 -> 4870;
4873 -> 4870;
4874 -> 4871;
4874 -> 4873;
4874 -> 4870;
4875 -> 4874;
4876 -> 4872;
4876 -> 4870;
4877 -> 4876;
4877 -> 4854;
4878 -> 4854;
4879 -> 4877;
4879 -> 4878;
4880 -> 4855;
4880 -> 4878;
4881 -> 4878;
4882 -> 4880;
4882 -> 4856;
4882 -> 4881;
4882 -> 4878;
4883 -> 4882;
4884 -> 4883;
4884 -> 4854;
4885 -> 4854;
4886 -> 4856;
4886 -> 4854;
4887 -> 4884;
4887 -> 4854;
4888 -> 4855;
4888 -> 4854;
4889 -> 4886;
4889 -> 4856;
4889 -> 0;
4889 -> 4854;
4890 -> 4854;
4891 -> 4886;
4891 -> 4856;
4891 -> 4854;
4892 -> 4886;
4892 -> 4856;
4892 -> 4891;
4893 -> 4886;
4893 -> 4856;
4893 -> 4892;
4894 -> 4892;
4895 -> 4893;
4895 -> 4894;
4896 -> 4895;
4896 -> 0;
4896 -> 4894;
4897 -> 4856;
4897 -> 4892;
4898 -> 4886;
4898 -> 4856;
4898 -> 4892;
4899 -> 4892;
4900 -> 4897;
4900 -> 4899;
4901 -> 4898;
4901 -> 4899;
4902 -> 4897;
4902 -> 4899;
4903 -> 4901;
4903 -> 4899;
4904 -> 4900;
4904 -> 4899;
4905 -> 4902;
4905 -> 4899;
4906 -> 4899;
4907 -> 4903;
4907 -> 4906;
4908 -> 4904;
4908 -> 4906;
4909 -> 4905;
4909 -> 4906;
4910 -> 4907;
4910 -> 1374;
4910 -> 4906;
4911 -> 4906;
4912 -> 4908;
4912 -> 4911;
4912 -> 4906;
4913 -> 4912;
4914 -> 4909;
4914 -> 4913;
4914 -> 4912;
4915 -> 1378;
4915 -> 1377;
4915 -> 4907;
4915 -> 4914;
4916 -> 4854;
4917 -> 4887;
4917 -> 4916;
4917 -> 4854;
4918 -> 4915;
4918 -> 4854;
4919 -> 4918;
4919 -> 4842;
4920 -> 4846;
4920 -> 4919;
4920 -> 4842;
4921 -> 4919;
4921 -> 4842;
4922 -> 4828;
4922 -> 4840;
4923 -> 4829;
4923 -> 4840;
4924 -> 4830;
4924 -> 4840;
4925 -> 4831;
4925 -> 4840;
4926 -> 4921;
4926 -> 4840;
4927 -> 4921;
4927 -> 1358;
4928 -> 1358;
4928 -> 4927;
4928 -> 4926;
4929 -> 4928;
4929 -> 1118;
4930 -> 4929;
4930 -> 4811;
4931 -> 4930;
4931 -> 4814;
4931 -> 4811;
4932 -> 4813;
4932 -> 4819;
4932 -> 1114;
4932 -> 1113;
4932 -> 4811;
4933 -> 4813;
4933 -> 1114;
4933 -> 1113;
4933 -> 4819;
4933 -> 4811;
4934 -> 4930;
4934 -> 4933;
4934 -> 4811;
4935 -> 4928;
4935 -> 4821;
4936 -> 4935;
4936 -> 4928;
4936 -> 4821;
4937 -> 4936;
4937 -> 1118;
4938 -> 4928;
4939 -> 4928;
4940 -> 4939;
4940 -> 4928;
4941 -> 4928;
4942 -> 4941;
4942 -> 4928;
4943 -> 4941;
4943 -> 4928;
4944 -> 4943;
4944 -> 4928;
4945 -> 4928;
4946 -> 4928;
4947 -> 4928;
4948 -> 4928;
4949 -> 4948;
4950 -> 4928;
4951 -> 4941;
4952 -> 4941;
4953 -> 4941;
4953 -> 1018;
4954 -> 0;
4954 -> 4941;
4955 -> 4941;
4956 -> 4955;
4956 -> 4941;
4957 -> 0;
4957 -> 4956;
4958 -> 4941;
4958 -> 4957;
4958 -> 4954;
4959 -> 4958;
4959 -> 0;
4959 -> 4941;
4960 -> 0;
4960 -> 4941;
4960 -> 4959;
4961 -> 0;
4961 -> 4941;
4961 -> 4959;
4962 -> 4941;
4962 -> 4958;
4962 -> 4960;
4962 -> 0;
4963 -> 4941;
4963 -> 4958;
4963 -> 4960;
4963 -> 4961;
4963 -> 4928;
4964 -> 4941;
4964 -> 4928;
4965 -> 4928;
4966 -> 4964;
4966 -> 4965;
4967 -> 4965;
4968 -> 4965;
4969 -> 4966;
4969 -> 4968;
4969 -> 4965;
4970 -> 4969;
4971 -> 4970;
4971 -> 4966;
4971 -> 4963;
4971 -> 4969;
4972 -> 4967;
4972 -> 4965;
4973 -> 4972;
4973 -> 4928;
4974 -> 4928;
4975 -> 4973;
4975 -> 4974;
4976 -> 4928;
4976 -> 4974;
4977 -> 4974;
4978 -> 4976;
4978 -> 4963;
4978 -> 4977;
4978 -> 4974;
4979 -> 4978;
4980 -> 4979;
4980 -> 4928;
4981 -> 4928;
4982 -> 4928;
4983 -> 4982;
4983 -> 4928;
4984 -> 4963;
4984 -> 4928;
4985 -> 4963;
4986 -> 4963;
4986 -> 4928;
4987 -> 4986;
4988 -> 4980;
4988 -> 4928;
4989 -> 4928;
4990 -> 4963;
4990 -> 0;
4990 -> 4928;
4991 -> 4928;
4992 -> 4963;
4992 -> 4991;
4992 -> 4928;
4993 -> 4928;
4994 -> 4963;
4995 -> 4963;
4996 -> 4994;
4996 -> 4995;
4997 -> 4994;
4997 -> 4995;
4998 -> 4994;
4998 -> 4995;
4999 -> 4994;
4999 -> 4995;
5000 -> 4994;
5000 -> 4995;
5001 -> 4996;
5001 -> 4995;
5002 -> 4997;
5002 -> 4995;
5003 -> 4998;
5003 -> 4995;
5004 -> 4999;
5004 -> 4995;
5005 -> 5000;
5005 -> 4995;
5006 -> 4995;
5007 -> 5001;
5007 -> 5006;
5008 -> 5002;
5008 -> 5006;
5009 -> 5003;
5009 -> 5006;
5010 -> 5004;
5010 -> 5006;
5011 -> 5005;
5011 -> 5006;
5012 -> 5007;
5012 -> 0;
5012 -> 5006;
5013 -> 5010;
5013 -> 5009;
5013 -> 5006;
5014 -> 5012;
5014 -> 5013;
5014 -> 5006;
5015 -> 5008;
5015 -> 5014;
5016 -> 5009;
5016 -> 5014;
5017 -> 5011;
5017 -> 5014;
5018 -> 5014;
5019 -> 5015;
5019 -> 5018;
5020 -> 5016;
5020 -> 5018;
5021 -> 5017;
5021 -> 5018;
5022 -> 5018;
5023 -> 5019;
5023 -> 5022;
5023 -> 5018;
5024 -> 5023;
5025 -> 5021;
5025 -> 5024;
5025 -> 5023;
5026 -> 5020;
5026 -> 5025;
5027 -> 5025;
5028 -> 5026;
5028 -> 5027;
5030 -> 5028;
5030 -> 5027;
5031 -> 5027;
5032 -> 5027;
5033 -> 5030;
5033 -> 5032;
5034 -> 5031;
5034 -> 5032;
5035 -> 0;
5035 -> 5032;
5036 -> 5033;
5036 -> 5032;
5037 -> 5032;
5038 -> 5035;
5038 -> 5037;
5039 -> 5036;
5039 -> 5037;
5040 -> 5034;
5040 -> 5037;
5041 -> 5038;
5041 -> 5037;
5042 -> 5039;
5042 -> 5037;
5043 -> 5037;
5044 -> 5041;
5044 -> 5043;
5045 -> 5042;
5045 -> 5043;
5046 -> 5040;
5046 -> 5043;
5047 -> 5044;
5047 -> 5043;
5048 -> 5045;
5048 -> 5043;
5049 -> 5043;
5050 -> 5049;
5050 -> 5047;
5050 -> 5048;
5050 -> 5043;
5051 -> 5049;
5051 -> 5043;
5052 -> 5051;
5052 -> 5050;
5052 -> 5043;
5053 -> 5040;
5053 -> 5052;
5053 -> 0;
5053 -> 5037;
5054 -> 5053;
5054 -> 5040;
5054 -> 5037;
5055 -> 5034;
5055 -> 5032;
5056 -> 5033;
5056 -> 5034;
5056 -> 5032;
5057 -> 5031;
5057 -> 5025;
5058 -> 4928;
5059 -> 4988;
5059 -> 5058;
5059 -> 4928;
5060 -> 4940;
5060 -> 5057;
5060 -> 5052;
5060 -> 4928;
5061 -> 4928;
5061 -> 5057;
5061 -> 4963;
5061 -> 5052;
5061 -> 5054;
5061 -> 5055;
5061 -> 5056;
5062 -> 5061;
5062 -> 1118;
5063 -> 5062;
5063 -> 4811;
5064 -> 5063;
5064 -> 4814;
5064 -> 4811;
5065 -> 5063;
5065 -> 4933;
5065 -> 4811;
5066 -> 5061;
5066 -> 4821;
5067 -> 5066;
5067 -> 5061;
5067 -> 4821;
5068 -> 5067;
5068 -> 1118;
5069 -> 5061;
5070 -> 5061;
5071 -> 5070;
5071 -> 5061;
5072 -> 5061;
5073 -> 5061;
5074 -> 5073;
5074 -> 5061;
5075 -> 5061;
5076 -> 5061;
5077 -> 5061;
5078 -> 5061;
5079 -> 5078;
5080 -> 5061;
5081 -> 5061;
5082 -> 5061;
5083 -> 5081;
5083 -> 5082;
5084 -> 5082;
5085 -> 5082;
5086 -> 5083;
5086 -> 5085;
5086 -> 5082;
5087 -> 5086;
5088 -> 5084;
5088 -> 5082;
5089 -> 5088;
5089 -> 5061;
5090 -> 5061;
5091 -> 5089;
5091 -> 5090;
5092 -> 5061;
5092 -> 5090;
5093 -> 5090;
5094 -> 5092;
5094 -> 5061;
5094 -> 5093;
5094 -> 5090;
5095 -> 5094;
5096 -> 5095;
5096 -> 5061;
5097 -> 5061;
5098 -> 5061;
5099 -> 5097;
5099 -> 5098;
5100 -> 5098;
5101 -> 5099;
5101 -> 5070;
5101 -> 5100;
5101 -> 5098;
5102 -> 5101;
5102 -> 5061;
5103 -> 5061;
5104 -> 5070;
5104 -> 5103;
5104 -> 5061;
5105 -> 5070;
5105 -> 5061;
5106 -> 5070;
5107 -> 5070;
5107 -> 5061;
5108 -> 5107;
5109 -> 5096;
5109 -> 5061;
5110 -> 5061;
5111 -> 5061;
5111 -> 0;
5112 -> 5061;
5113 -> 5061;
5114 -> 5061;
5115 -> 5113;
5115 -> 5114;
5116 -> 5115;
5116 -> 0;
5116 -> 5114;
5117 -> 5070;
5117 -> 1374;
5117 -> 5061;
5118 -> 5070;
5118 -> 408;
5119 -> 1386;
5119 -> 1385;
5119 -> 5070;
5119 -> 5118;
5120 -> 5061;
5121 -> 5109;
5121 -> 5120;
5121 -> 5061;
5122 -> 5071;
5122 -> 5119;
5122 -> 5061;
5123 -> 5119;
5123 -> 1118;
5124 -> 5123;
5124 -> 4811;
5125 -> 5124;
5125 -> 4814;
5125 -> 4811;
5126 -> 5124;
5126 -> 4933;
5126 -> 4811;
5127 -> 5119;
5127 -> 4821;
5128 -> 5127;
5128 -> 5119;
5128 -> 4821;
5129 -> 5128;
5129 -> 1118;
5130 -> 5119;
5131 -> 5119;
5132 -> 5119;
5133 -> 5119;
5134 -> 5133;
5134 -> 5119;
5135 -> 5119;
5136 -> 5119;
5137 -> 5119;
5138 -> 5119;
5139 -> 5138;
5140 -> 5119;
5141 -> 5119;
5142 -> 5119;
5143 -> 5141;
5143 -> 5142;
5144 -> 5142;
5145 -> 5142;
5146 -> 5143;
5146 -> 5145;
5146 -> 5142;
5147 -> 5146;
5148 -> 5144;
5148 -> 5142;
5149 -> 5148;
5149 -> 5119;
5150 -> 5119;
5151 -> 5149;
5151 -> 5150;
5152 -> 5119;
5152 -> 5150;
5153 -> 5150;
5154 -> 5152;
5154 -> 5119;
5154 -> 5153;
5154 -> 5150;
5155 -> 5154;
5156 -> 5155;
5156 -> 5119;
5157 -> 5119;
5158 -> 5119;
5159 -> 5157;
5159 -> 5158;
5160 -> 5158;
5161 -> 5159;
5161 -> 5119;
5161 -> 5160;
5161 -> 5158;
5162 -> 5161;
5162 -> 5119;
5163 -> 5119;
5164 -> 5156;
5164 -> 5119;
5165 -> 5119;
5166 -> 5119;
5166 -> 0;
5167 -> 5119;
5168 -> 5119;
5169 -> 5119;
5170 -> 5168;
5170 -> 5169;
5171 -> 5170;
5171 -> 0;
5171 -> 5169;
5172 -> 5119;
5172 -> 1374;
5173 -> 5119;
5174 -> 5164;
5174 -> 5173;
5174 -> 5119;
5175 -> 5131;
5175 -> 5119;
5176 -> 5119;
5177 -> 5119;
5177 -> 1018;
5178 -> 0;
5178 -> 5119;
5179 -> 5119;
5179 -> 5178;
5180 -> 5178;
5181 -> 5179;
5181 -> 5180;
5182 -> 5181;
5182 -> 5180;
5183 -> 5182;
5184 -> 5119;
5184 -> 5178;
5184 -> 0;
5185 -> 5147;
5185 -> 5143;
5185 -> 5178;
5185 -> 5146;
5186 -> 5152;
5186 -> 5178;
5186 -> 5153;
5186 -> 5150;
5187 -> 5186;
5188 -> 5187;
5188 -> 5119;
5189 -> 5178;
5189 -> 5119;
5190 -> 5178;
5191 -> 5119;
5191 -> 5178;
5192 -> 5178;
5193 -> 5191;
5193 -> 5192;
5194 -> 5192;
5195 -> 5193;
5195 -> 5178;
5195 -> 5194;
5195 -> 5192;
5196 -> 5195;
5196 -> 5178;
5197 -> 5178;
5198 -> 5178;
5199 -> 5178;
5199 -> 5119;
5200 -> 5199;
5201 -> 5188;
5201 -> 5119;
5202 -> 5178;
5202 -> 0;
5202 -> 5119;
5203 -> 5178;
5204 -> 5178;
5205 -> 5203;
5205 -> 5204;
5206 -> 5205;
5206 -> 0;
5206 -> 5204;
5207 -> 5178;
5207 -> 1374;
5208 -> 5201;
5208 -> 5173;
5208 -> 5119;
5209 -> 5131;
5209 -> 5178;
5209 -> 5119;
5210 -> 5178;
5210 -> 1118;
5211 -> 5210;
5211 -> 4811;
5212 -> 5211;
5212 -> 4814;
5212 -> 4811;
5213 -> 5211;
5213 -> 4933;
5213 -> 4811;
5214 -> 5178;
5214 -> 4821;
5215 -> 5214;
5215 -> 5178;
5215 -> 4821;
5216 -> 5215;
5216 -> 1118;
5217 -> 5178;
5218 -> 5178;
5219 -> 5178;
5220 -> 5178;
5221 -> 5220;
5221 -> 5178;
5222 -> 5178;
5223 -> 5178;
5224 -> 5223;
5225 -> 5178;
5226 -> 5178;
5227 -> 5178;
5227 -> 1018;
5228 -> 5178;
5228 -> 0;
5229 -> 5178;
5230 -> 5178;
5231 -> 5229;
5231 -> 5230;
5232 -> 5230;
5233 -> 5230;
5234 -> 5231;
5234 -> 5233;
5234 -> 5230;
5235 -> 5234;
5236 -> 5232;
5236 -> 5230;
5237 -> 5236;
5237 -> 5178;
5238 -> 5178;
5239 -> 5237;
5239 -> 5238;
5240 -> 5178;
5240 -> 5238;
5241 -> 5238;
5242 -> 5240;
5242 -> 5178;
5242 -> 5241;
5242 -> 5238;
5243 -> 5242;
5244 -> 5243;
5244 -> 5178;
5245 -> 5244;
5245 -> 5178;
5246 -> 5178;
5247 -> 5178;
5247 -> 0;
5248 -> 5178;
5249 -> 5178;
5250 -> 5178;
5251 -> 5245;
5251 -> 5250;
5251 -> 5178;
5252 -> 5218;
5252 -> 5178;
5253 -> 5214;
5253 -> 4821;
5254 -> 5253;
5254 -> 1118;
5255 -> 5178;
5256 -> 5255;
5256 -> 5192;
5257 -> 5256;
5257 -> 5178;
5257 -> 5194;
5257 -> 5192;
5258 -> 5257;
5258 -> 5178;
5259 -> 5178;
5260 -> 5259;
5260 -> 5178;
5261 -> 5260;
5262 -> 5261;
5262 -> 5178;
5263 -> 956;
5263 -> 5262;
5264 -> 5263;
5265 -> 5263;
5265 -> 5264;
5266 -> 5264;
5267 -> 5265;
5267 -> 5266;
5268 -> 5266;
5269 -> 5267;
5269 -> 5268;
5269 -> 5266;
5270 -> 5267;
5270 -> 5266;
5271 -> 5263;
5271 -> 5269;
5272 -> 5269;
5273 -> 5271;
5273 -> 5272;
5274 -> 5272;
5275 -> 5273;
5275 -> 5274;
5275 -> 5272;
5276 -> 5263;
5276 -> 5178;
5277 -> 5276;
5278 -> 5259;
5278 -> 5178;
5279 -> 5259;
5279 -> 5178;
5280 -> 5279;
5280 -> 5178;
5281 -> 5259;
5282 -> 5259;
5283 -> 5282;
5284 -> 5283;
5284 -> 5259;
5285 -> 956;
5285 -> 5284;
5286 -> 5259;
5287 -> 5286;
5287 -> 5285;
5287 -> 5259;
5288 -> 5259;
5289 -> 5286;
5289 -> 5288;
5290 -> 5289;
5290 -> 5285;
5290 -> 5288;
5291 -> 5290;
5291 -> 5259;
5292 -> 0;
5294 -> 5292;
5294 -> 5293;
5295 -> 5293;
5296 -> 5294;
5296 -> 5295;
5296 -> 5293;
5297 -> 5293;
5300 -> 5298;
5300 -> 5299;
5301 -> 5299;
5302 -> 5300;
5302 -> 5301;
5302 -> 5299;
5303 -> 5299;
5304 -> 5259;
5305 -> 5304;
5305 -> 5291;
5305 -> 5259;
5306 -> 5259;
5307 -> 5305;
5307 -> 5306;
5308 -> 5307;
5308 -> 5306;
5309 -> 5306;
5310 -> 5308;
5310 -> 5309;
5310 -> 5306;
5311 -> 5308;
5311 -> 5306;
5312 -> 5259;
5313 -> 5311;
5313 -> 5312;
5313 -> 5259;
5314 -> 5259;
5315 -> 5314;
5315 -> 5313;
5315 -> 5259;
5316 -> 5259;
5317 -> 5315;
5317 -> 5316;
5318 -> 5316;
5319 -> 5317;
5319 -> 5318;
5319 -> 5316;
5320 -> 5259;
5321 -> 5317;
5321 -> 5320;
5321 -> 5259;
5322 -> 5259;
5322 -> 5178;
5323 -> 5322;
5323 -> 5230;
5324 -> 5323;
5324 -> 5233;
5324 -> 5230;
5325 -> 5324;
5326 -> 5325;
5326 -> 5323;
5326 -> 5321;
5326 -> 5324;
5327 -> 5240;
5327 -> 5321;
5327 -> 5241;
5327 -> 5238;
5328 -> 5327;
5329 -> 5328;
5329 -> 5178;
5330 -> 5321;
5331 -> 5321;
5331 -> 5330;
5332 -> 5330;
5333 -> 5331;
5333 -> 5332;
5334 -> 5332;
5335 -> 5333;
5335 -> 5334;
5335 -> 5332;
5336 -> 5333;
5336 -> 5332;
5337 -> 5321;
5337 -> 5335;
5338 -> 5335;
5339 -> 5337;
5339 -> 5338;
5340 -> 5338;
5341 -> 5339;
5341 -> 5340;
5341 -> 5338;
5342 -> 5321;
5342 -> 5178;
5343 -> 5342;
5344 -> 5329;
5344 -> 5178;
5345 -> 5321;
5345 -> 0;
5345 -> 5178;
5346 -> 5321;
5347 -> 5321;
5348 -> 5346;
5348 -> 5347;
5349 -> 5346;
5349 -> 5347;
5350 -> 5346;
5350 -> 5347;
5351 -> 5349;
5351 -> 1374;
5351 -> 5347;
5352 -> 5344;
5352 -> 5250;
5352 -> 5178;
5353 -> 5349;
5353 -> 1118;
5354 -> 5353;
5354 -> 4811;
5355 -> 5354;
5355 -> 4814;
5355 -> 4811;
5356 -> 5354;
5356 -> 4933;
5356 -> 4811;
5357 -> 5349;
5357 -> 4821;
5358 -> 5357;
5358 -> 4821;
5359 -> 5358;
5359 -> 1118;
5360 -> 1105;
5361 -> 1042;
5362 -> 5361;
5362 -> 1048;
5362 -> 1042;
5363 -> 1048;
5363 -> 1042;
5364 -> 1048;
5364 -> 1042;
5365 -> 1048;
5365 -> 1042;
5366 -> 1048;
5366 -> 1042;
5367 -> 1048;
5367 -> 1042;
5368 -> 1048;
5368 -> 1042;
5369 -> 1042;
5370 -> 5369;
5370 -> 1048;
5370 -> 1042;
5371 -> 1048;
5371 -> 5370;
5371 -> 1042;
5372 -> 1042;
5373 -> 5372;
5373 -> 1048;
5373 -> 1042;
5374 -> 1041;
5374 -> 890;
5375 -> 890;
5376 -> 5374;
5376 -> 5375;
5377 -> 5376;
5377 -> 5375;
5378 -> 0;
5378 -> 5375;
5379 -> 5375;
5380 -> 5377;
5380 -> 5379;
5381 -> 5378;
5381 -> 5379;
5382 -> 5376;
5382 -> 5379;
5383 -> 5379;
5384 -> 5382;
5384 -> 5365;
5384 -> 5383;
5384 -> 5379;
5385 -> 5380;
5385 -> 5377;
5385 -> 1082;
5385 -> 1090;
5385 -> 1084;
5385 -> 1083;
5385 -> 1073;
5385 -> 1114;
5385 -> 1075;
5385 -> 1076;
5385 -> 1077;
5385 -> 4819;
5385 -> 1079;
5385 -> 1080;
5385 -> 1081;
5385 -> 1085;
5385 -> 1087;
5385 -> 1097;
5385 -> 5362;
5385 -> 5370;
5385 -> 5373;
5385 -> 5365;
5385 -> 5366;
5385 -> 5367;
5385 -> 5368;
5385 -> 5321;
5385 -> 1041;
5385 -> 1086;
5385 -> 1096;
5385 -> 1113;
5385 -> 5361;
5385 -> 5371;
5385 -> 5379;
5386 -> 5379;
5387 -> 5385;
5387 -> 5386;
5388 -> 5386;
5389 -> 5387;
5389 -> 5388;
5390 -> 5389;
5390 -> 5385;
5390 -> 5388;
5391 -> 5389;
5391 -> 5390;
5391 -> 5388;
5392 -> 5389;
5392 -> 5390;
5392 -> 0;
5392 -> 5388;
5393 -> 5392;
5393 -> 5389;
5393 -> 5388;
5394 -> 5388;
5395 -> 5389;
5395 -> 5394;
5396 -> 5394;
5397 -> 5395;
5397 -> 5396;
5398 -> 5396;
5399 -> 5397;
5399 -> 5398;
5400 -> 5399;
5400 -> 5390;
5400 -> 5398;
5401 -> 5398;
5402 -> 5399;
5402 -> 5390;
5402 -> 5401;
5402 -> 5398;
5403 -> 5399;
5403 -> 5390;
5403 -> 5393;
5403 -> 5402;
5404 -> 5403;
5404 -> 5396;
5405 -> 5404;
5405 -> 5397;
5405 -> 5396;
5406 -> 5405;
5406 -> 5394;
5407 -> 5394;
5408 -> 5406;
5408 -> 5407;
5409 -> 5408;
5409 -> 5390;
5409 -> 5407;
5410 -> 5409;
5410 -> 5388;
5411 -> 5391;
5411 -> 5389;
5411 -> 5388;
5412 -> 5390;
5412 -> 5393;
5412 -> 5411;
5412 -> 5405;
5412 -> 5388;
5413 -> 5390;
5413 -> 5388;
5414 -> 5389;
5414 -> 5412;
5414 -> 5413;
5414 -> 5388;
5415 -> 5386;
5416 -> 5415;
5416 -> 5386;
5417 -> 5386;
5418 -> 5412;
5418 -> 5417;
5419 -> 5416;
5419 -> 5417;
5420 -> 5387;
5420 -> 5417;
5421 -> 5418;
5421 -> 5417;
5422 -> 5419;
5422 -> 5417;
5423 -> 5417;
5424 -> 5421;
5424 -> 5423;
5425 -> 5422;
5425 -> 5423;
5426 -> 5420;
5426 -> 5423;
5427 -> 5423;
5428 -> 5426;
5428 -> 5427;
5429 -> 5427;
5430 -> 5428;
5430 -> 5429;
5431 -> 5430;
5431 -> 5414;
5431 -> 5429;
5432 -> 5431;
5432 -> 5427;
5433 -> 5432;
5434 -> 5433;
5434 -> 5423;
5435 -> 5434;
5435 -> 5417;
5436 -> 5417;
5437 -> 5420;
5437 -> 5436;
5438 -> 5436;
5439 -> 5437;
5439 -> 5438;
5440 -> 5438;
5441 -> 5439;
5441 -> 5440;
5442 -> 5441;
5442 -> 5414;
5442 -> 5440;
5443 -> 5442;
5443 -> 5438;
5444 -> 5438;
5445 -> 5439;
5445 -> 5414;
5445 -> 5444;
5445 -> 5438;
5446 -> 5443;
5446 -> 5439;
5446 -> 5445;
5447 -> 5439;
5447 -> 5414;
5447 -> 5438;
5448 -> 5439;
5448 -> 5414;
5448 -> 5447;
5448 -> 5438;
5449 -> 5439;
5449 -> 5414;
5449 -> 5438;
5450 -> 5443;
5450 -> 5438;
5451 -> 5448;
5451 -> 5449;
5451 -> 5450;
5451 -> 5414;
5451 -> 5446;
5451 -> 5447;
5451 -> 5438;
5452 -> 5451;
5452 -> 5436;
5453 -> 5437;
5453 -> 5451;
5453 -> 5436;
5454 -> 5436;
5455 -> 5436;
5456 -> 5452;
5456 -> 5455;
5457 -> 5453;
5457 -> 5455;
5458 -> 5453;
5458 -> 5455;
5459 -> 5453;
5459 -> 5455;
5460 -> 5453;
5460 -> 5455;
5461 -> 5454;
5461 -> 5455;
5462 -> 5456;
5462 -> 5461;
5462 -> 5455;
5463 -> 5457;
5463 -> 5461;
5463 -> 5455;
5464 -> 5458;
5464 -> 5461;
5464 -> 5455;
5465 -> 5459;
5465 -> 5461;
5465 -> 5455;
5466 -> 5460;
5466 -> 5461;
5466 -> 5455;
5467 -> 5454;
5467 -> 5417;
5468 -> 5420;
5468 -> 5451;
5468 -> 5417;
5469 -> 5420;
5469 -> 5451;
5469 -> 5468;
5469 -> 5417;
5470 -> 5417;
5471 -> 5417;
5472 -> 5420;
5472 -> 5471;
5473 -> 5472;
5473 -> 5451;
5473 -> 5471;
5474 -> 5473;
5474 -> 5417;
5475 -> 5417;
5476 -> 5474;
5476 -> 5475;
5477 -> 5476;
5477 -> 5451;
5477 -> 5475;
5478 -> 5418;
5478 -> 5477;
5479 -> 5477;
5480 -> 5478;
5480 -> 5479;
5481 -> 5420;
5481 -> 5479;
5482 -> 5479;
5483 -> 5481;
5483 -> 5482;
5484 -> 5483;
5484 -> 5479;
5485 -> 5479;
5486 -> 5484;
5486 -> 5485;
5487 -> 0;
5487 -> 5479;
5488 -> 5479;
5489 -> 5487;
5489 -> 5488;
5490 -> 5481;
5490 -> 5488;
5491 -> 5489;
5491 -> 5488;
5492 -> 5488;
5493 -> 5491;
5493 -> 5492;
5494 -> 5493;
5494 -> 0;
5494 -> 5492;
5495 -> 5494;
5496 -> 5488;
5497 -> 5490;
5497 -> 5496;
5498 -> 5497;
5498 -> 5488;
5499 -> 5488;
5500 -> 5498;
5500 -> 5499;
5501 -> 5500;
5501 -> 5488;
5502 -> 5501;
5502 -> 5489;
5502 -> 5488;
5503 -> 5502;
5504 -> 5490;
5504 -> 5503;
5505 -> 5503;
5506 -> 5504;
5506 -> 5451;
5506 -> 5505;
5507 -> 5506;
5507 -> 5451;
5507 -> 5505;
5508 -> 5507;
5508 -> 5503;
5509 -> 5508;
5509 -> 5504;
5509 -> 5503;
5510 -> 5503;
5511 -> 5510;
5511 -> 5504;
5511 -> 5503;
5512 -> 5503;
5513 -> 5504;
5513 -> 5451;
5513 -> 5512;
5513 -> 5503;
5514 -> 5504;
5514 -> 5451;
5514 -> 5503;
5515 -> 5502;
5516 -> 5498;
5516 -> 5502;
5517 -> 5479;
5518 -> 5481;
5518 -> 5517;
5519 -> 0;
5519 -> 5517;
5520 -> 5517;
5521 -> 5519;
5521 -> 5520;
5522 -> 5518;
5522 -> 5520;
5523 -> 5522;
5523 -> 5451;
5523 -> 5468;
5523 -> 5520;
5524 -> 5522;
5524 -> 5451;
5524 -> 5468;
5524 -> 5523;
5524 -> 5520;
5525 -> 5521;
5525 -> 5520;
5526 -> 5520;
5527 -> 5525;
5527 -> 5526;
5528 -> 5522;
5528 -> 5526;
5529 -> 5526;
5530 -> 5526;
5531 -> 5526;
5532 -> 5528;
5532 -> 5531;
5533 -> 5532;
5533 -> 5451;
5533 -> 5514;
5533 -> 5531;
5534 -> 5532;
5534 -> 5451;
5534 -> 5468;
5534 -> 5523;
5534 -> 5509;
5534 -> 5511;
5534 -> 5514;
5535 -> 5534;
5535 -> 5526;
5536 -> 5526;
5537 -> 5535;
5537 -> 5536;
5538 -> 5537;
5538 -> 5526;
5539 -> 5526;
5540 -> 5538;
5540 -> 5539;
5541 -> 5540;
5541 -> 5539;
5542 -> 5541;
5543 -> 5537;
5543 -> 5526;
5544 -> 5526;
5545 -> 5543;
5545 -> 5544;
5546 -> 5545;
5546 -> 5544;
5547 -> 5544;
5548 -> 5546;
5548 -> 5547;
5549 -> 5548;
5549 -> 5547;
5550 -> 5547;
5551 -> 5549;
5551 -> 5550;
5552 -> 5551;
5552 -> 5550;
5553 -> 0;
5553 -> 5552;
5554 -> 5537;
5554 -> 0;
5554 -> 5553;
5555 -> 5554;
5556 -> 5528;
5556 -> 5555;
5557 -> 5555;
5558 -> 5556;
5558 -> 5557;
5559 -> 5558;
5559 -> 5555;
5560 -> 5555;
5561 -> 5559;
5561 -> 5560;
5562 -> 5560;
5563 -> 5561;
5563 -> 5562;
5564 -> 5563;
5564 -> 5560;
5565 -> 5555;
5566 -> 5565;
5566 -> 5554;
5567 -> 5566;
5568 -> 5566;
5569 -> 5567;
5569 -> 5568;
5570 -> 5567;
5570 -> 5568;
5571 -> 5528;
5571 -> 5568;
5572 -> 5568;
5573 -> 5571;
5573 -> 5572;
5574 -> 5573;
5574 -> 5568;
5575 -> 5568;
5576 -> 5574;
5576 -> 5575;
5577 -> 5575;
5578 -> 5576;
5578 -> 5577;
5579 -> 5578;
5579 -> 5575;
5580 -> 5568;
5581 -> 5580;
5581 -> 5566;
5582 -> 5581;
5583 -> 5582;
5583 -> 5581;
5584 -> 5581;
5585 -> 5583;
5585 -> 5584;
5586 -> 5584;
5587 -> 5585;
5587 -> 5586;
5588 -> 5587;
5588 -> 5584;
5589 -> 5537;
5589 -> 0;
5589 -> 5588;
5590 -> 5527;
5590 -> 5589;
5591 -> 5589;
5592 -> 5590;
5592 -> 5591;
5593 -> 5528;
5593 -> 5591;
5594 -> 5592;
5594 -> 0;
5594 -> 5591;
5595 -> 5591;
5596 -> 5593;
5596 -> 5595;
5597 -> 5596;
5597 -> 5591;
5598 -> 5591;
5599 -> 5597;
5599 -> 5598;
5600 -> 5598;
5601 -> 5599;
5601 -> 5600;
5602 -> 5601;
5602 -> 5598;
5603 -> 5591;
5604 -> 5593;
5604 -> 5603;
5605 -> 5604;
5605 -> 5591;
5606 -> 5591;
5607 -> 5605;
5607 -> 5606;
5608 -> 5591;
5609 -> 5607;
5609 -> 5608;
5610 -> 5609;
5610 -> 5608;
5611 -> 5608;
5612 -> 5610;
5612 -> 5611;
5613 -> 5612;
5613 -> 5611;
5614 -> 5613;
5615 -> 5602;
5615 -> 5614;
5615 -> 5591;
5616 -> 5594;
5616 -> 5615;
5616 -> 5591;
5617 -> 5616;
5618 -> 5527;
5618 -> 5617;
5619 -> 5617;
5620 -> 5618;
5620 -> 5619;
5621 -> 5528;
5621 -> 5619;
5622 -> 5620;
5622 -> 5619;
5623 -> 5619;
5624 -> 5622;
5624 -> 5623;
5625 -> 5621;
5625 -> 5623;
5626 -> 5623;
5627 -> 5625;
5627 -> 5626;
5628 -> 5627;
5628 -> 5623;
5629 -> 5623;
5630 -> 5628;
5630 -> 5629;
5631 -> 5630;
5631 -> 5623;
5632 -> 5624;
5632 -> 5631;
5633 -> 5631;
5634 -> 5632;
5634 -> 5633;
5635 -> 5625;
5635 -> 5633;
5636 -> 5633;
5637 -> 5635;
5637 -> 5636;
5638 -> 5637;
5638 -> 5633;
5639 -> 5633;
5640 -> 5638;
5640 -> 5639;
5641 -> 5633;
5642 -> 5635;
5642 -> 5641;
5643 -> 5642;
5643 -> 5641;
5644 -> 5641;
5645 -> 5641;
5646 -> 5643;
5646 -> 5645;
5647 -> 5643;
5647 -> 5645;
5648 -> 5643;
5648 -> 5645;
5649 -> 5643;
5649 -> 5645;
5650 -> 5643;
5650 -> 5645;
5651 -> 5644;
5651 -> 5645;
5652 -> 5646;
5652 -> 5651;
5652 -> 5645;
5653 -> 5647;
5653 -> 5651;
5653 -> 5645;
5654 -> 5648;
5654 -> 5651;
5654 -> 5645;
5655 -> 5649;
5655 -> 5651;
5655 -> 5645;
5656 -> 5650;
5656 -> 5651;
5656 -> 5645;
5657 -> 5644;
5657 -> 5633;
5658 -> 5634;
5658 -> 5633;
5659 -> 5633;
5660 -> 5658;
5660 -> 5659;
5661 -> 5635;
5661 -> 5659;
5662 -> 5660;
5662 -> 0;
5662 -> 5659;
5663 -> 5659;
5664 -> 5659;
5665 -> 5663;
5665 -> 5664;
5666 -> 5661;
5666 -> 5664;
5667 -> 5664;
5668 -> 5665;
5668 -> 5667;
5668 -> 5664;
5669 -> 5666;
5669 -> 5642;
5669 -> 5665;
5669 -> 5664;
5670 -> 5664;
5671 -> 5666;
5671 -> 5642;
5671 -> 5670;
5671 -> 5664;
5672 -> 5666;
5672 -> 5642;
5672 -> 5665;
5672 -> 5671;
5673 -> 5659;
5674 -> 5672;
5674 -> 5673;
5675 -> 5659;
5676 -> 5661;
5676 -> 5675;
5677 -> 5676;
5677 -> 5642;
5677 -> 5675;
5678 -> 5677;
5678 -> 5659;
5679 -> 5674;
5679 -> 5678;
5679 -> 5659;
5680 -> 5659;
5681 -> 5663;
5681 -> 5680;
5682 -> 5661;
5682 -> 5680;
5683 -> 5680;
5684 -> 5681;
5684 -> 5683;
5684 -> 5680;
5685 -> 5682;
5685 -> 5642;
5685 -> 5681;
5685 -> 5680;
5686 -> 5680;
5687 -> 5682;
5687 -> 5642;
5687 -> 5686;
5687 -> 5680;
5688 -> 5682;
5688 -> 5642;
5688 -> 5681;
5688 -> 5687;
5689 -> 5659;
5690 -> 5688;
5690 -> 5689;
5691 -> 5679;
5691 -> 5690;
5691 -> 5659;
5692 -> 5659;
5693 -> 5659;
5694 -> 5692;
5694 -> 5693;
5695 -> 5661;
5695 -> 5693;
5696 -> 5693;
5697 -> 5694;
5697 -> 5696;
5697 -> 5693;
5698 -> 5695;
5698 -> 5642;
5698 -> 5694;
5698 -> 5693;
5699 -> 5693;
5700 -> 5695;
5700 -> 5642;
5700 -> 5699;
5700 -> 5693;
5701 -> 5695;
5701 -> 5642;
5701 -> 5694;
5701 -> 5700;
5702 -> 5659;
5703 -> 5701;
5703 -> 5702;
5704 -> 5661;
5704 -> 5702;
5705 -> 5702;
5706 -> 5703;
5706 -> 5705;
5707 -> 5706;
5707 -> 5702;
5708 -> 5702;
5709 -> 5704;
5709 -> 5708;
5710 -> 5709;
5710 -> 5642;
5710 -> 5708;
5711 -> 5710;
5711 -> 5702;
5712 -> 5707;
5712 -> 5711;
5712 -> 5702;
5713 -> 5659;
5714 -> 5692;
5714 -> 5713;
5715 -> 5661;
5715 -> 5713;
5716 -> 5713;
5717 -> 5714;
5717 -> 5716;
5717 -> 5713;
5718 -> 5715;
5718 -> 5642;
5718 -> 5714;
5718 -> 5713;
5719 -> 5713;
5720 -> 5715;
5720 -> 5642;
5720 -> 5719;
5720 -> 5713;
5721 -> 5715;
5721 -> 5642;
5721 -> 5714;
5721 -> 5720;
5722 -> 5659;
5723 -> 5721;
5723 -> 5722;
5724 -> 5712;
5724 -> 5723;
5724 -> 5659;
5725 -> 5659;
5726 -> 5692;
5726 -> 5725;
5727 -> 5661;
5727 -> 5725;
5728 -> 5725;
5729 -> 5726;
5729 -> 5728;
5729 -> 5725;
5730 -> 5727;
5730 -> 5642;
5730 -> 5726;
5730 -> 5725;
5731 -> 5725;
5732 -> 5727;
5732 -> 5642;
5732 -> 5731;
5732 -> 5725;
5733 -> 5727;
5733 -> 5642;
5733 -> 5726;
5733 -> 5732;
5734 -> 5659;
5735 -> 5733;
5735 -> 5734;
5736 -> 5724;
5736 -> 5735;
5736 -> 5659;
5737 -> 5659;
5738 -> 5659;
5739 -> 5737;
5739 -> 5738;
5740 -> 5661;
5740 -> 5738;
5741 -> 5738;
5742 -> 5739;
5742 -> 5741;
5742 -> 5738;
5743 -> 5740;
5743 -> 5642;
5743 -> 5739;
5743 -> 5738;
5744 -> 5738;
5745 -> 5740;
5745 -> 5642;
5745 -> 5744;
5745 -> 5738;
5746 -> 5740;
5746 -> 5642;
5746 -> 5739;
5746 -> 5745;
5747 -> 5659;
5748 -> 5746;
5748 -> 5747;
5749 -> 5659;
5750 -> 5659;
5751 -> 5749;
5751 -> 5750;
5752 -> 5661;
5752 -> 5750;
5753 -> 5750;
5754 -> 5751;
5754 -> 5753;
5754 -> 5750;
5755 -> 5752;
5755 -> 5642;
5755 -> 5751;
5755 -> 5750;
5756 -> 5750;
5757 -> 5752;
5757 -> 5642;
5757 -> 5756;
5757 -> 5750;
5758 -> 5752;
5758 -> 5642;
5758 -> 5751;
5758 -> 5757;
5759 -> 5659;
5760 -> 5758;
5760 -> 5759;
5761 -> 5659;
5762 -> 5761;
5762 -> 5633;
5763 -> 5633;
5764 -> 5633;
5765 -> 5763;
5765 -> 5764;
5766 -> 5635;
5766 -> 5764;
5767 -> 5764;
5768 -> 5766;
5768 -> 5767;
5769 -> 5768;
5769 -> 5642;
5769 -> 5767;
5770 -> 5769;
5770 -> 5764;
5771 -> 5764;
5772 -> 5770;
5772 -> 5771;
5773 -> 5764;
5774 -> 5766;
5774 -> 5773;
5775 -> 5773;
5776 -> 5774;
5776 -> 5775;
5777 -> 5776;
5777 -> 5642;
5777 -> 5775;
5778 -> 5777;
5778 -> 5773;
5779 -> 5773;
5780 -> 5774;
5780 -> 5779;
5781 -> 5780;
5781 -> 5642;
5781 -> 5779;
5782 -> 5779;
5783 -> 5782;
5783 -> 5780;
5783 -> 5779;
5784 -> 5779;
5785 -> 5780;
5785 -> 5642;
5785 -> 5784;
5785 -> 5779;
5786 -> 5780;
5786 -> 5642;
5786 -> 5779;
5787 -> 5773;
5788 -> 5778;
5788 -> 5773;
5789 -> 5788;
5789 -> 5764;
5790 -> 5765;
5790 -> 5764;
5791 -> 5764;
5792 -> 5790;
5792 -> 5791;
5793 -> 5766;
5793 -> 5791;
5794 -> 5791;
5795 -> 5792;
5795 -> 5791;
5796 -> 5791;
5797 -> 5794;
5797 -> 5796;
5798 -> 5795;
5798 -> 5796;
5799 -> 5793;
5799 -> 5796;
5800 -> 5798;
5800 -> 5796;
5801 -> 0;
5801 -> 5800;
5802 -> 5797;
5802 -> 5796;
5803 -> 5801;
5803 -> 5802;
5803 -> 5799;
5803 -> 5642;
5803 -> 5783;
5803 -> 5780;
5803 -> 5786;
5803 -> 5796;
5804 -> 5796;
5805 -> 5803;
5805 -> 5804;
5806 -> 5803;
5806 -> 5804;
5807 -> 5803;
5807 -> 5804;
5808 -> 5804;
5809 -> 5806;
5809 -> 5808;
5809 -> 5804;
5810 -> 5807;
5810 -> 5803;
5810 -> 5806;
5810 -> 5804;
5811 -> 5804;
5812 -> 5807;
5812 -> 5803;
5812 -> 5811;
5812 -> 5804;
5813 -> 5807;
5813 -> 5803;
5813 -> 5806;
5813 -> 5812;
5814 -> 5803;
5814 -> 5804;
5815 -> 5803;
5815 -> 5804;
5816 -> 5804;
5817 -> 5815;
5817 -> 5816;
5818 -> 5817;
5818 -> 5813;
5818 -> 5816;
5819 -> 5818;
5819 -> 5804;
5820 -> 5804;
5821 -> 5819;
5821 -> 5820;
5822 -> 5804;
5823 -> 5815;
5823 -> 5822;
5824 -> 5822;
5825 -> 5823;
5825 -> 5824;
5826 -> 5825;
5826 -> 5813;
5826 -> 5824;
5827 -> 5826;
5827 -> 5822;
5828 -> 5822;
5829 -> 5827;
5829 -> 5828;
5830 -> 5829;
5831 -> 5823;
5831 -> 5830;
5832 -> 5830;
5833 -> 5831;
5833 -> 5832;
5834 -> 5833;
5834 -> 5830;
5835 -> 5830;
5836 -> 5834;
5836 -> 5835;
5837 -> 5830;
5838 -> 5837;
5838 -> 5829;
5839 -> 5829;
5840 -> 5823;
5840 -> 5839;
5841 -> 5839;
5842 -> 5840;
5842 -> 5841;
5843 -> 5842;
5843 -> 5813;
5843 -> 5841;
5844 -> 5843;
5844 -> 5839;
5845 -> 5844;
5845 -> 5829;
5846 -> 5838;
5846 -> 5845;
5846 -> 5829;
5847 -> 5829;
5848 -> 5823;
5848 -> 5847;
5849 -> 5847;
5850 -> 5848;
5850 -> 5849;
5851 -> 5850;
5851 -> 5847;
5852 -> 5847;
5853 -> 5851;
5853 -> 5852;
5854 -> 5853;
5854 -> 5829;
5855 -> 5846;
5855 -> 5854;
5855 -> 5829;
5856 -> 5855;
5857 -> 5856;
5857 -> 5804;
5858 -> 5821;
5858 -> 5857;
5858 -> 5804;
5859 -> 5804;
5860 -> 5815;
5860 -> 5859;
5861 -> 5859;
5862 -> 5860;
5862 -> 5861;
5863 -> 5862;
5863 -> 5813;
5863 -> 5861;
5864 -> 5863;
5864 -> 5859;
5865 -> 5859;
5866 -> 5860;
5866 -> 5813;
5866 -> 5865;
5867 -> 5865;
5868 -> 5865;
5869 -> 5860;
5869 -> 5813;
5869 -> 5868;
5869 -> 5865;
5870 -> 5860;
5870 -> 5813;
5870 -> 5865;
5871 -> 5859;
5872 -> 5864;
5872 -> 5859;
5873 -> 5872;
5873 -> 5804;
5874 -> 5804;
5875 -> 5815;
5875 -> 5874;
5876 -> 5875;
5876 -> 5813;
5876 -> 5870;
5876 -> 5874;
5877 -> 5875;
5877 -> 5813;
5877 -> 5874;
5878 -> 5875;
5878 -> 5813;
5878 -> 5860;
5878 -> 5870;
5878 -> 5877;
5879 -> 5878;
5879 -> 5804;
5880 -> 5804;
5881 -> 5879;
5881 -> 5880;
5882 -> 0;
5882 -> 5881;
5883 -> 5873;
5883 -> 5882;
5883 -> 5813;
5883 -> 5860;
5883 -> 5878;
5883 -> 5870;
5883 -> 5796;
5884 -> 5873;
5884 -> 5804;
5885 -> 5804;
5886 -> 5884;
5886 -> 5885;
5887 -> 5886;
5887 -> 5883;
5887 -> 5885;
5888 -> 5887;
5888 -> 5804;
5889 -> 5804;
5890 -> 5888;
5890 -> 5889;
5891 -> 5804;
5892 -> 5884;
5892 -> 5891;
5893 -> 5892;
5893 -> 5883;
5893 -> 5891;
5894 -> 5893;
5894 -> 5804;
5895 -> 5804;
5896 -> 5894;
5896 -> 5895;
5897 -> 5890;
5897 -> 5896;
5897 -> 5804;
5898 -> 5873;
5898 -> 5804;
5899 -> 5873;
5899 -> 5804;
5900 -> 5873;
5900 -> 5804;
5901 -> 5804;
5902 -> 5900;
5902 -> 5901;
5903 -> 5902;
5903 -> 5897;
5903 -> 5901;
5904 -> 5903;
5904 -> 5804;
5905 -> 5904;
5905 -> 5898;
5905 -> 5804;
5906 -> 5904;
5906 -> 5905;
5907 -> 5905;
5908 -> 5906;
5908 -> 5907;
5908 -> 5796;
5909 -> 5799;
5909 -> 5801;
5909 -> 5802;
5909 -> 5803;
5909 -> 5813;
5909 -> 5882;
5909 -> 5897;
5909 -> 5907;
5909 -> 5906;
5909 -> 5796;
5910 -> 5909;
5910 -> 0;
5910 -> 5764;
5911 -> 5764;
5912 -> 5766;
5912 -> 5911;
5913 -> 5912;
5913 -> 5909;
5913 -> 5911;
5914 -> 5913;
5914 -> 5764;
5915 -> 5764;
5916 -> 5914;
5916 -> 5915;
5917 -> 5764;
5918 -> 5766;
5918 -> 5917;
5919 -> 5917;
5920 -> 5918;
5920 -> 5919;
5921 -> 5920;
5921 -> 5909;
5921 -> 5919;
5922 -> 5917;
5923 -> 5918;
5923 -> 5922;
5924 -> 5923;
5924 -> 5909;
5924 -> 5922;
5925 -> 5922;
5926 -> 5923;
5926 -> 5909;
5926 -> 5925;
5926 -> 5922;
5927 -> 5923;
5927 -> 5909;
5927 -> 5922;
5928 -> 5917;
5929 -> 5921;
5929 -> 5764;
5930 -> 5909;
5930 -> 5764;
5931 -> 5930;
5932 -> 5931;
5932 -> 5909;
5932 -> 5927;
5933 -> 5931;
5933 -> 5909;
5933 -> 5924;
5933 -> 5923;
5933 -> 5927;
5934 -> 5933;
5934 -> 5930;
5935 -> 5930;
5936 -> 5934;
5936 -> 5935;
5937 -> 5930;
5938 -> 5936;
5938 -> 5937;
5939 -> 5938;
5939 -> 5937;
5940 -> 5939;
5941 -> 5657;
5941 -> 5633;
5942 -> 5633;
5943 -> 5941;
5943 -> 5942;
5944 -> 5635;
5944 -> 5942;
5945 -> 5943;
5945 -> 5653;
5945 -> 5944;
5945 -> 5942;
5946 -> 5943;
5946 -> 5654;
5946 -> 5944;
5946 -> 5942;
5947 -> 5943;
5947 -> 5655;
5947 -> 5944;
5947 -> 5909;
5947 -> 5942;
5948 -> 5943;
5948 -> 5656;
5948 -> 5944;
5948 -> 5909;
5948 -> 5942;
5949 -> 5943;
5949 -> 5652;
5949 -> 5942;
5950 -> 5942;
5951 -> 5949;
5951 -> 5950;
5952 -> 5944;
5952 -> 5950;
5953 -> 5951;
5953 -> 5642;
5953 -> 5952;
5953 -> 5909;
5953 -> 5950;
5954 -> 5950;
5955 -> 5953;
5955 -> 5954;
5955 -> 5950;
5956 -> 5953;
5956 -> 5952;
5956 -> 5909;
5956 -> 5950;
5957 -> 5951;
5957 -> 5642;
5957 -> 5952;
5957 -> 5950;
5958 -> 5950;
5959 -> 5953;
5959 -> 5958;
5959 -> 5950;
5960 -> 5953;
5960 -> 5952;
5960 -> 5909;
5960 -> 5950;
5961 -> 5953;
5961 -> 5952;
5961 -> 5950;
5962 -> 5950;
5963 -> 5962;
5963 -> 5952;
5963 -> 5950;
5964 -> 5950;
5965 -> 5964;
5965 -> 5952;
5965 -> 5950;
5966 -> 5951;
5966 -> 5642;
5966 -> 5952;
5966 -> 5950;
5967 -> 5950;
5968 -> 5952;
5968 -> 5909;
5968 -> 5967;
5968 -> 5950;
5969 -> 5942;
5970 -> 5633;
5971 -> 5634;
5971 -> 5633;
5972 -> 5633;
5973 -> 5971;
5973 -> 5972;
5974 -> 5635;
5974 -> 5972;
5975 -> 5973;
5975 -> 0;
5975 -> 5972;
5976 -> 5972;
5977 -> 5974;
5977 -> 5976;
5978 -> 5977;
5978 -> 5909;
5978 -> 5927;
5978 -> 5961;
5978 -> 5976;
5979 -> 5977;
5979 -> 5909;
5979 -> 5976;
5980 -> 5977;
5980 -> 5909;
5980 -> 5976;
5981 -> 5977;
5981 -> 5909;
5981 -> 5957;
5981 -> 5976;
5982 -> 5977;
5982 -> 5909;
5982 -> 5924;
5982 -> 5966;
5982 -> 5976;
5983 -> 5980;
5983 -> 5981;
5983 -> 5978;
5983 -> 5982;
5983 -> 5909;
5983 -> 5924;
5983 -> 5966;
5983 -> 5923;
5983 -> 5933;
5983 -> 5963;
5983 -> 5927;
5983 -> 5961;
5983 -> 5945;
5983 -> 5946;
5983 -> 5947;
5983 -> 5948;
5983 -> 5957;
5983 -> 5965;
5983 -> 5964;
5983 -> 5976;
5984 -> 5976;
5985 -> 5976;
5986 -> 5984;
5986 -> 5985;
5987 -> 5984;
5987 -> 5972;
5988 -> 5972;
5989 -> 5972;
5990 -> 5989;
5991 -> 5974;
5991 -> 5990;
5992 -> 5990;
5993 -> 5991;
5993 -> 5992;
5994 -> 5993;
5994 -> 5983;
5994 -> 5992;
5995 -> 5993;
5995 -> 5983;
5995 -> 5992;
5996 -> 5990;
5997 -> 5991;
5997 -> 5996;
5998 -> 5997;
5998 -> 5983;
5998 -> 5995;
5998 -> 5996;
5999 -> 5996;
6000 -> 5999;
6000 -> 5997;
6000 -> 5996;
6001 -> 5996;
6002 -> 5997;
6002 -> 5983;
6002 -> 6001;
6002 -> 5996;
6003 -> 5997;
6003 -> 5983;
6003 -> 5996;
6004 -> 5990;
6005 -> 5995;
6005 -> 5989;
6006 -> 5989;
6007 -> 5974;
6007 -> 6006;
6008 -> 6007;
6008 -> 5983;
6008 -> 6003;
6008 -> 6006;
6009 -> 6007;
6009 -> 5983;
6009 -> 6006;
6010 -> 6007;
6010 -> 5983;
6010 -> 5995;
6010 -> 5997;
6010 -> 6000;
6010 -> 6003;
6010 -> 6009;
6011 -> 6010;
6011 -> 5989;
6012 -> 5989;
6013 -> 6011;
6013 -> 6012;
6014 -> 5989;
6015 -> 5974;
6015 -> 6014;
6016 -> 6015;
6016 -> 5983;
6016 -> 5995;
6016 -> 5997;
6016 -> 6010;
6016 -> 6014;
6017 -> 6016;
6017 -> 5989;
6018 -> 5989;
6019 -> 6017;
6019 -> 6018;
6020 -> 5989;
6021 -> 5989;
6022 -> 6020;
6022 -> 6021;
6023 -> 5974;
6023 -> 6021;
6024 -> 6021;
6025 -> 6022;
6025 -> 6021;
6026 -> 6021;
6027 -> 6024;
6027 -> 6026;
6028 -> 6025;
6028 -> 6026;
6029 -> 6023;
6029 -> 6026;
6030 -> 6028;
6030 -> 6026;
6031 -> 5801;
6031 -> 6030;
6032 -> 6027;
6032 -> 6026;
6033 -> 6031;
6033 -> 6032;
6033 -> 6029;
6033 -> 5983;
6033 -> 5995;
6033 -> 5997;
6033 -> 6010;
6033 -> 6000;
6033 -> 6003;
6033 -> 6026;
6034 -> 6026;
6035 -> 6034;
6036 -> 6033;
6036 -> 6035;
6036 -> 6034;
6037 -> 6033;
6037 -> 6034;
6038 -> 6034;
6039 -> 6033;
6039 -> 6034;
6040 -> 6034;
6041 -> 6033;
6041 -> 6040;
6042 -> 6041;
6042 -> 6034;
6043 -> 6034;
6044 -> 6042;
6044 -> 6043;
6045 -> 6034;
6046 -> 6033;
6046 -> 6045;
6047 -> 6045;
6048 -> 6046;
6048 -> 6047;
6049 -> 6048;
6049 -> 6045;
6050 -> 6045;
6051 -> 6049;
6051 -> 6050;
6052 -> 6051;
6053 -> 6046;
6053 -> 6052;
6054 -> 6052;
6055 -> 6053;
6055 -> 6054;
6056 -> 6055;
6056 -> 6052;
6057 -> 6052;
6058 -> 6056;
6058 -> 6057;
6059 -> 6052;
6060 -> 6059;
6060 -> 6051;
6061 -> 6051;
6062 -> 6046;
6062 -> 6061;
6063 -> 6061;
6064 -> 6062;
6064 -> 6063;
6065 -> 6064;
6065 -> 6033;
6065 -> 6063;
6066 -> 6065;
6066 -> 6061;
6067 -> 6066;
6067 -> 6051;
6068 -> 6060;
6068 -> 6067;
6068 -> 6051;
6069 -> 6051;
6070 -> 6046;
6070 -> 6069;
6071 -> 6069;
6072 -> 6070;
6072 -> 6071;
6073 -> 6072;
6073 -> 6069;
6074 -> 6069;
6075 -> 6073;
6075 -> 6074;
6076 -> 6075;
6076 -> 6051;
6077 -> 6068;
6077 -> 6076;
6077 -> 6051;
6078 -> 6077;
6079 -> 6078;
6079 -> 6034;
6080 -> 6044;
6080 -> 6079;
6080 -> 6034;
6081 -> 6034;
6082 -> 6081;
6083 -> 6081;
6084 -> 6033;
6084 -> 6083;
6085 -> 6083;
6086 -> 6083;
6087 -> 6033;
6087 -> 6086;
6087 -> 6083;
6088 -> 6081;
6089 -> 6034;
6090 -> 6033;
6090 -> 6089;
6091 -> 6034;
6092 -> 6034;
6093 -> 6034;
6094 -> 6034;
6095 -> 6034;
6096 -> 6033;
6096 -> 6034;
6097 -> 6034;
6098 -> 5989;
6099 -> 5974;
6099 -> 6098;
6100 -> 6098;
6101 -> 6099;
6101 -> 6100;
6102 -> 6101;
6102 -> 6033;
6102 -> 6100;
6103 -> 6102;
6103 -> 6098;
6104 -> 6098;
6105 -> 6103;
6105 -> 6104;
6106 -> 6098;
6107 -> 6106;
6107 -> 5989;
6108 -> 5989;
6109 -> 5974;
6109 -> 6108;
6110 -> 6109;
6110 -> 6033;
6110 -> 6108;
6111 -> 6110;
6111 -> 5989;
6112 -> 5989;
6113 -> 6111;
6113 -> 6112;
6114 -> 6113;
6115 -> 6113;
6116 -> 6114;
6116 -> 6115;
6117 -> 6115;
6118 -> 6116;
6118 -> 6117;
6118 -> 6115;
6119 -> 6115;
6119 -> 6033;
6119 -> 6116;
6120 -> 6113;
6121 -> 6116;
6121 -> 6120;
6122 -> 5987;
6122 -> 6113;
6123 -> 6113;
6124 -> 6122;
6124 -> 6123;
6125 -> 6123;
6126 -> 6124;
6126 -> 6125;
6126 -> 6123;
6127 -> 6124;
6127 -> 6123;
6127 -> 6033;
6128 -> 6123;
6129 -> 6124;
6129 -> 6128;
6129 -> 6123;
6130 -> 6124;
6130 -> 6123;
6130 -> 6033;
6131 -> 6123;
6132 -> 6113;
6133 -> 6124;
6133 -> 6113;
6134 -> 6113;
6135 -> 6133;
6135 -> 6134;
6136 -> 5974;
6136 -> 6134;
6137 -> 6135;
6137 -> 6124;
6137 -> 6134;
6138 -> 6134;
6139 -> 6137;
6139 -> 6138;
6140 -> 6136;
6140 -> 6138;
6141 -> 6140;
6141 -> 6033;
6141 -> 6139;
6141 -> 5983;
6141 -> 6138;
6142 -> 6140;
6142 -> 6033;
6142 -> 6138;
6143 -> 6138;
6144 -> 6140;
6144 -> 6033;
6144 -> 6142;
6144 -> 6143;
6144 -> 6138;
6145 -> 6134;
6146 -> 6113;
6147 -> 6121;
6147 -> 5633;
6148 -> 5943;
6148 -> 5633;
6149 -> 5633;
6150 -> 6148;
6150 -> 6149;
6151 -> 5635;
6151 -> 6149;
6152 -> 6150;
6152 -> 5653;
6152 -> 6151;
6152 -> 6149;
6153 -> 6150;
6153 -> 5654;
6153 -> 6151;
6153 -> 6149;
6154 -> 6150;
6154 -> 5655;
6154 -> 6151;
6154 -> 6033;
6154 -> 6149;
6155 -> 6150;
6155 -> 5656;
6155 -> 6151;
6155 -> 6033;
6155 -> 6149;
6156 -> 6150;
6156 -> 5951;
6156 -> 6149;
6157 -> 6149;
6158 -> 6151;
6158 -> 6157;
6159 -> 6156;
6159 -> 5642;
6159 -> 6158;
6159 -> 6033;
6159 -> 6157;
6160 -> 6157;
6161 -> 6159;
6161 -> 6160;
6161 -> 6157;
6162 -> 6159;
6162 -> 6158;
6162 -> 6033;
6162 -> 6157;
6163 -> 6156;
6163 -> 5642;
6163 -> 6158;
6163 -> 6157;
6164 -> 6157;
6165 -> 6159;
6165 -> 6164;
6165 -> 6157;
6166 -> 6159;
6166 -> 6158;
6166 -> 6033;
6166 -> 6157;
6167 -> 6157;
6168 -> 6167;
6168 -> 6158;
6168 -> 6157;
6169 -> 6157;
6170 -> 6169;
6170 -> 6158;
6170 -> 6157;
6171 -> 6156;
6171 -> 5642;
6171 -> 6158;
6171 -> 6157;
6172 -> 6157;
6173 -> 6158;
6173 -> 6033;
6173 -> 6172;
6173 -> 6157;
6174 -> 6149;
6175 -> 5633;
6176 -> 0;
6176 -> 5633;
6177 -> 5633;
6178 -> 6176;
6178 -> 6177;
6179 -> 5635;
6179 -> 6177;
6180 -> 6178;
6180 -> 6177;
6181 -> 6177;
6182 -> 6180;
6182 -> 6181;
6183 -> 6182;
6183 -> 0;
6183 -> 6181;
6184 -> 6183;
6185 -> 6179;
6185 -> 6033;
6185 -> 6124;
6185 -> 6159;
6185 -> 6177;
6186 -> 6179;
6186 -> 6033;
6186 -> 6177;
6187 -> 6179;
6187 -> 6033;
6187 -> 6124;
6187 -> 6152;
6187 -> 6153;
6187 -> 6154;
6187 -> 6155;
6187 -> 6163;
6187 -> 6159;
6187 -> 6123;
6187 -> 6168;
6187 -> 6170;
6187 -> 6171;
6187 -> 6142;
6187 -> 6186;
6188 -> 6187;
6188 -> 6178;
6188 -> 6177;
6189 -> 6188;
6189 -> 6033;
6189 -> 6123;
6189 -> 6168;
6189 -> 6187;
6190 -> 6188;
6191 -> 6188;
6192 -> 6187;
6192 -> 6188;
6193 -> 0;
6193 -> 5633;
6194 -> 5633;
6195 -> 5633;
6196 -> 6193;
6196 -> 6195;
6197 -> 6194;
6197 -> 6195;
6198 -> 6194;
6198 -> 6195;
6199 -> 5635;
6199 -> 6195;
6200 -> 6196;
6200 -> 6195;
6201 -> 6198;
6201 -> 6195;
6202 -> 6195;
6203 -> 6200;
6203 -> 6202;
6204 -> 6201;
6204 -> 6202;
6205 -> 6199;
6205 -> 6202;
6206 -> 6202;
6207 -> 6205;
6207 -> 6206;
6208 -> 6207;
6208 -> 6033;
6208 -> 6124;
6208 -> 6152;
6208 -> 6153;
6208 -> 6154;
6208 -> 6155;
6208 -> 6163;
6208 -> 6159;
6208 -> 6188;
6208 -> 6123;
6208 -> 6168;
6208 -> 6187;
6208 -> 6170;
6208 -> 6171;
6208 -> 6142;
6208 -> 6206;
6209 -> 6208;
6209 -> 6202;
6210 -> 6202;
6211 -> 6205;
6211 -> 6210;
6212 -> 6211;
6212 -> 6033;
6212 -> 6124;
6212 -> 6159;
6212 -> 6188;
6212 -> 6210;
6213 -> 6211;
6213 -> 6033;
6213 -> 6142;
6213 -> 6210;
6214 -> 6211;
6214 -> 6033;
6214 -> 6142;
6214 -> 6210;
6215 -> 6211;
6215 -> 6033;
6215 -> 6124;
6215 -> 6163;
6215 -> 6210;
6216 -> 6211;
6216 -> 6033;
6216 -> 6124;
6216 -> 6171;
6216 -> 6188;
6216 -> 6210;
6217 -> 6210;
6218 -> 6210;
6219 -> 6217;
6219 -> 6218;
6220 -> 6217;
6220 -> 6202;
6221 -> 6202;
6222 -> 6205;
6222 -> 6221;
6223 -> 6221;
6224 -> 6222;
6224 -> 6223;
6225 -> 6224;
6225 -> 6212;
6225 -> 6223;
6226 -> 6224;
6226 -> 6212;
6226 -> 6223;
6227 -> 6226;
6227 -> 6221;
6228 -> 6221;
6229 -> 6227;
6229 -> 6228;
6230 -> 6229;
6231 -> 6230;
6231 -> 6202;
6232 -> 6202;
6233 -> 6203;
6233 -> 6202;
6234 -> 6232;
6234 -> 6202;
6235 -> 6233;
6235 -> 6234;
6235 -> 6205;
6235 -> 6212;
6235 -> 6226;
6235 -> 6202;
6236 -> 6202;
6237 -> 6236;
6238 -> 6235;
6238 -> 6237;
6238 -> 6236;
6239 -> 6235;
6239 -> 6236;
6240 -> 6236;
6241 -> 6235;
6241 -> 6236;
6242 -> 6236;
6243 -> 6235;
6243 -> 6242;
6244 -> 6243;
6244 -> 6236;
6245 -> 6236;
6246 -> 6244;
6246 -> 6245;
6247 -> 6236;
6248 -> 6235;
6248 -> 6247;
6249 -> 6247;
6250 -> 6248;
6250 -> 6249;
6251 -> 6250;
6251 -> 6247;
6252 -> 6247;
6253 -> 6251;
6253 -> 6252;
6254 -> 6253;
6255 -> 6248;
6255 -> 6254;
6256 -> 6254;
6257 -> 6255;
6257 -> 6256;
6258 -> 6257;
6258 -> 6254;
6259 -> 6254;
6260 -> 6258;
6260 -> 6259;
6261 -> 6254;
6262 -> 6261;
6262 -> 6253;
6263 -> 6253;
6264 -> 6248;
6264 -> 6263;
6265 -> 6263;
6266 -> 6264;
6266 -> 6265;
6267 -> 6266;
6267 -> 6235;
6267 -> 6265;
6268 -> 6267;
6268 -> 6263;
6269 -> 6268;
6269 -> 6253;
6270 -> 6262;
6270 -> 6269;
6270 -> 6253;
6271 -> 6253;
6272 -> 6248;
6272 -> 6271;
6273 -> 6271;
6274 -> 6272;
6274 -> 6273;
6275 -> 6274;
6275 -> 6271;
6276 -> 6271;
6277 -> 6275;
6277 -> 6276;
6278 -> 6277;
6278 -> 6253;
6279 -> 6270;
6279 -> 6278;
6279 -> 6253;
6280 -> 6279;
6281 -> 6280;
6281 -> 6236;
6282 -> 6246;
6282 -> 6281;
6282 -> 6236;
6283 -> 6236;
6284 -> 6283;
6285 -> 6283;
6286 -> 6235;
6286 -> 6285;
6287 -> 6285;
6288 -> 6285;
6289 -> 6235;
6289 -> 6288;
6289 -> 6285;
6290 -> 6283;
6291 -> 6236;
6292 -> 6235;
6292 -> 6291;
6293 -> 6236;
6294 -> 6236;
6295 -> 6236;
6296 -> 6236;
6297 -> 6236;
6298 -> 6235;
6298 -> 6236;
6299 -> 6236;
6300 -> 6202;
6301 -> 6235;
6301 -> 6300;
6302 -> 6301;
6302 -> 6202;
6303 -> 6202;
6304 -> 6302;
6304 -> 6303;
6305 -> 6231;
6305 -> 6304;
6305 -> 6202;
6306 -> 6204;
6306 -> 6305;
6306 -> 6202;
6307 -> 6202;
6308 -> 6306;
6308 -> 6307;
6309 -> 6205;
6309 -> 6307;
6310 -> 6307;
6311 -> 6309;
6311 -> 6310;
6312 -> 6311;
6312 -> 6235;
6312 -> 6310;
6313 -> 6312;
6313 -> 6307;
6314 -> 6307;
6315 -> 6313;
6315 -> 6314;
6316 -> 6315;
6317 -> 6316;
6317 -> 6202;
6318 -> 6317;
6319 -> 6220;
6319 -> 6317;
6320 -> 6317;
6321 -> 6319;
6321 -> 6320;
6322 -> 6320;
6323 -> 6321;
6323 -> 6322;
6323 -> 6320;
6324 -> 6321;
6324 -> 6320;
6324 -> 6235;
6325 -> 6320;
6326 -> 6321;
6326 -> 6325;
6326 -> 6320;
6327 -> 6321;
6327 -> 6320;
6327 -> 6235;
6328 -> 6320;
6329 -> 6317;
6330 -> 6321;
6330 -> 6317;
6331 -> 6317;
6332 -> 6330;
6332 -> 6331;
6333 -> 6332;
6333 -> 6321;
6333 -> 6331;
6334 -> 6333;
6334 -> 6331;
6335 -> 6331;
6335 -> 6235;
6335 -> 6334;
6335 -> 6212;
6336 -> 6331;
6337 -> 6331;
6338 -> 6317;
6339 -> 6318;
6340 -> 6339;
6340 -> 6235;
6341 -> 6339;
6342 -> 6339;
6343 -> 6339;
6343 -> 6235;
6343 -> 6321;
6344 -> 6339;
6344 -> 6235;
6344 -> 6321;
6344 -> 6320;
6344 -> 6331;
6345 -> 6344;
6345 -> 6339;
6346 -> 6339;
6347 -> 6345;
6347 -> 6346;
6348 -> 6347;
6348 -> 6346;
6349 -> 6348;
6350 -> 6339;
6350 -> 6344;
6351 -> 6344;
6352 -> 6350;
6352 -> 6351;
6353 -> 6352;
6353 -> 6344;
6354 -> 6344;
6355 -> 6353;
6355 -> 6354;
6356 -> 6344;
6357 -> 6344;
6358 -> 6339;
6358 -> 6344;
6359 -> 6344;
6360 -> 6358;
6360 -> 6359;
6361 -> 6360;
6361 -> 6344;
6362 -> 6344;
6363 -> 6361;
6363 -> 6362;
6364 -> 6339;
6364 -> 6354;
6365 -> 6364;
6365 -> 6354;
6366 -> 6365;
6366 -> 6354;
6367 -> 6366;
6367 -> 6354;
6368 -> 6354;
6369 -> 6354;
6369 -> 6368;
6370 -> 6368;
6371 -> 6369;
6371 -> 6370;
6372 -> 6371;
6372 -> 6368;
6373 -> 6368;
6374 -> 6372;
6374 -> 6373;
6375 -> 6374;
6376 -> 6369;
6376 -> 6375;
6377 -> 6375;
6378 -> 6376;
6378 -> 6377;
6379 -> 6378;
6379 -> 6375;
6380 -> 6375;
6381 -> 6379;
6381 -> 6380;
6382 -> 6375;
6383 -> 6382;
6383 -> 6374;
6384 -> 6374;
6385 -> 6369;
6385 -> 6384;
6386 -> 6384;
6387 -> 6385;
6387 -> 6386;
6388 -> 6387;
6388 -> 6235;
6388 -> 6321;
6388 -> 6320;
6388 -> 6344;
6388 -> 6331;
6388 -> 6339;
6388 -> 6386;
6389 -> 6388;
6389 -> 6384;
6390 -> 6389;
6390 -> 6374;
6391 -> 6383;
6391 -> 6390;
6391 -> 6374;
6392 -> 6374;
6393 -> 6369;
6393 -> 6392;
6394 -> 6392;
6395 -> 6393;
6395 -> 6394;
6396 -> 6395;
6396 -> 6392;
6397 -> 6392;
6398 -> 6396;
6398 -> 6397;
6399 -> 6398;
6399 -> 6374;
6400 -> 6391;
6400 -> 6399;
6400 -> 6374;
6401 -> 6400;
6402 -> 6401;
6402 -> 6354;
6403 -> 6402;
6404 -> 6354;
6404 -> 6403;
6405 -> 6403;
6406 -> 6405;
6406 -> 6403;
6407 -> 6403;
6408 -> 6406;
6408 -> 6407;
6409 -> 6404;
6409 -> 6407;
6410 -> 6407;
6411 -> 6408;
6411 -> 6410;
6411 -> 6407;
6412 -> 6409;
6412 -> 6235;
6412 -> 6321;
6412 -> 6408;
6412 -> 6407;
6413 -> 6409;
6413 -> 6235;
6413 -> 6321;
6413 -> 6408;
6414 -> 6403;
6415 -> 6413;
6415 -> 6414;
6416 -> 6403;
6417 -> 6406;
6417 -> 6416;
6418 -> 6404;
6418 -> 6416;
6419 -> 6416;
6420 -> 6417;
6420 -> 6419;
6420 -> 6416;
6421 -> 6418;
6421 -> 6235;
6421 -> 6321;
6421 -> 6417;
6421 -> 6416;
6422 -> 6418;
6422 -> 6235;
6422 -> 6321;
6422 -> 6417;
6423 -> 6403;
6424 -> 6422;
6424 -> 6423;
6425 -> 6415;
6425 -> 6424;
6425 -> 6403;
6426 -> 6405;
6426 -> 6403;
6427 -> 6403;
6428 -> 6426;
6428 -> 6427;
6429 -> 6404;
6429 -> 6427;
6430 -> 6427;
6431 -> 6428;
6431 -> 6430;
6431 -> 6427;
6432 -> 6429;
6432 -> 6235;
6432 -> 6321;
6432 -> 6428;
6432 -> 6427;
6433 -> 6429;
6433 -> 6235;
6433 -> 6321;
6433 -> 6428;
6434 -> 6403;
6435 -> 6433;
6435 -> 6434;
6436 -> 6435;
6436 -> 6402;
6437 -> 6367;
6437 -> 6436;
6438 -> 6436;
6439 -> 6437;
6439 -> 6438;
6440 -> 6354;
6440 -> 6438;
6441 -> 6438;
6442 -> 6440;
6442 -> 6441;
6443 -> 6442;
6443 -> 6438;
6444 -> 6438;
6445 -> 6443;
6445 -> 6444;
6446 -> 6438;
6447 -> 6440;
6447 -> 6446;
6448 -> 6447;
6448 -> 6438;
6449 -> 6438;
6450 -> 6448;
6450 -> 6449;
6451 -> 6440;
6451 -> 6449;
6452 -> 6449;
6453 -> 6450;
6453 -> 6452;
6454 -> 6453;
6454 -> 6449;
6455 -> 6449;
6456 -> 6451;
6456 -> 6455;
6457 -> 6456;
6457 -> 6449;
6458 -> 6454;
6458 -> 6457;
6458 -> 6449;
6459 -> 6445;
6459 -> 6458;
6459 -> 6438;
6460 -> 6439;
6460 -> 0;
6460 -> 6438;
6461 -> 6438;
6462 -> 6438;
6463 -> 6438;
6464 -> 6440;
6464 -> 6463;
6465 -> 6464;
6465 -> 6438;
6466 -> 6438;
6467 -> 6465;
6467 -> 6466;
6468 -> 6467;
6469 -> 6468;
6469 -> 6467;
6470 -> 6467;
6471 -> 6469;
6471 -> 6470;
6472 -> 6471;
6473 -> 6471;
6474 -> 6472;
6474 -> 6438;
6475 -> 6438;
6476 -> 6474;
6476 -> 6475;
6477 -> 6440;
6477 -> 6475;
6478 -> 6475;
6479 -> 6476;
6479 -> 6478;
6479 -> 6475;
6480 -> 6477;
6480 -> 6235;
6480 -> 6321;
6480 -> 6476;
6480 -> 6475;
6481 -> 6438;
6482 -> 6476;
6482 -> 6481;
6483 -> 6472;
6483 -> 6438;
6484 -> 6438;
6485 -> 6483;
6485 -> 6484;
6486 -> 6440;
6486 -> 6484;
6487 -> 6484;
6488 -> 6485;
6488 -> 6487;
6488 -> 6484;
6489 -> 6486;
6489 -> 6235;
6489 -> 6321;
6489 -> 6485;
6489 -> 6484;
6490 -> 6438;
6491 -> 6485;
6491 -> 6490;
6492 -> 6438;
6493 -> 6472;
6493 -> 6492;
6493 -> 6438;
6494 -> 6438;
6495 -> 6493;
6495 -> 6494;
6496 -> 6440;
6496 -> 6494;
6497 -> 6494;
6498 -> 6495;
6498 -> 6497;
6498 -> 6494;
6499 -> 6496;
6499 -> 6235;
6499 -> 6321;
6499 -> 6495;
6499 -> 6494;
6500 -> 6438;
6501 -> 6495;
6501 -> 6500;
6502 -> 6491;
6502 -> 6501;
6502 -> 6438;
6503 -> 6472;
6503 -> 6438;
6504 -> 6438;
6505 -> 6503;
6505 -> 6504;
6506 -> 6440;
6506 -> 6504;
6507 -> 6504;
6508 -> 6505;
6508 -> 6507;
6508 -> 6504;
6509 -> 6506;
6509 -> 6235;
6509 -> 6321;
6509 -> 6505;
6509 -> 6504;
6510 -> 6438;
6511 -> 6505;
6511 -> 6510;
6512 -> 6472;
6512 -> 6438;
6513 -> 6438;
6514 -> 6512;
6514 -> 6513;
6515 -> 6440;
6515 -> 6513;
6516 -> 6513;
6517 -> 6514;
6517 -> 6516;
6517 -> 6513;
6518 -> 6515;
6518 -> 6235;
6518 -> 6321;
6518 -> 6514;
6518 -> 6513;
6519 -> 6438;
6520 -> 6514;
6520 -> 6519;
6521 -> 6520;
6522 -> 6521;
6522 -> 6436;
6523 -> 6367;
6523 -> 6522;
6524 -> 6522;
6525 -> 6523;
6525 -> 6524;
6526 -> 0;
6526 -> 6525;
6527 -> 6525;
6528 -> 6526;
6528 -> 6527;
6529 -> 6354;
6529 -> 6527;
6530 -> 6528;
6530 -> 6527;
6531 -> 6527;
6532 -> 6530;
6532 -> 6531;
6533 -> 6529;
6533 -> 6531;
6534 -> 6531;
6535 -> 6531;
6536 -> 6534;
6536 -> 6535;
6537 -> 6533;
6537 -> 6535;
6538 -> 6535;
6539 -> 6537;
6539 -> 6538;
6540 -> 6538;
6541 -> 6539;
6541 -> 6540;
6542 -> 6541;
6542 -> 6538;
6543 -> 6542;
6544 -> 6543;
6544 -> 6535;
6545 -> 6536;
6545 -> 6535;
6546 -> 6535;
6547 -> 6545;
6547 -> 6546;
6548 -> 6537;
6548 -> 6546;
6549 -> 6546;
6550 -> 6548;
6550 -> 6549;
6551 -> 6550;
6551 -> 6546;
6552 -> 6546;
6553 -> 6551;
6553 -> 6552;
6554 -> 6553;
6554 -> 0;
6554 -> 6546;
6555 -> 6554;
6556 -> 6548;
6556 -> 6555;
6557 -> 6555;
6558 -> 6556;
6558 -> 6557;
6559 -> 6558;
6559 -> 6555;
6560 -> 6555;
6561 -> 6559;
6561 -> 6560;
6562 -> 6555;
6562 -> 6554;
6563 -> 6554;
6564 -> 6563;
6564 -> 6554;
6565 -> 6562;
6565 -> 6564;
6565 -> 6554;
6566 -> 6554;
6567 -> 6566;
6567 -> 6235;
6567 -> 6320;
6567 -> 6344;
6568 -> 6566;
6569 -> 6566;
6570 -> 6566;
6570 -> 6554;
6571 -> 6554;
6572 -> 6548;
6572 -> 6571;
6573 -> 6572;
6573 -> 6235;
6573 -> 6321;
6573 -> 6566;
6573 -> 6320;
6573 -> 6344;
6573 -> 6331;
6573 -> 6339;
6573 -> 6571;
6574 -> 6573;
6574 -> 6554;
6575 -> 6570;
6575 -> 6554;
6576 -> 6575;
6576 -> 6535;
6577 -> 6576;
6577 -> 6535;
6578 -> 6535;
6579 -> 6577;
6579 -> 6578;
6580 -> 6577;
6580 -> 6578;
6581 -> 6579;
6581 -> 6578;
6582 -> 6578;
6583 -> 6582;
6583 -> 6581;
6583 -> 6578;
6584 -> 6582;
6584 -> 6578;
6585 -> 6584;
6585 -> 6583;
6585 -> 6578;
6586 -> 6585;
6586 -> 6531;
6587 -> 6586;
6587 -> 6585;
6587 -> 6531;
6588 -> 6586;
6588 -> 6531;
6589 -> 6531;
6590 -> 6533;
6590 -> 6589;
6591 -> 6590;
6591 -> 6585;
6591 -> 6589;
6592 -> 6590;
6592 -> 6585;
6592 -> 6589;
6593 -> 6592;
6593 -> 6531;
6594 -> 6531;
6595 -> 6593;
6595 -> 6594;
6596 -> 6588;
6596 -> 6531;
6597 -> 6596;
6597 -> 6527;
6598 -> 6527;
6599 -> 6529;
6599 -> 6598;
6600 -> 6599;
6600 -> 6585;
6600 -> 6592;
6600 -> 6598;
6601 -> 6600;
6601 -> 6527;
6602 -> 6527;
6603 -> 6601;
6603 -> 6602;
6604 -> 6597;
6604 -> 6527;
6605 -> 6604;
6605 -> 6525;
6606 -> 6605;
6606 -> 6354;
6606 -> 6585;
6606 -> 6592;
6607 -> 6354;
6608 -> 6606;
6608 -> 6339;
6609 -> 6339;
6610 -> 6339;
6611 -> 6608;
6611 -> 6610;
6612 -> 6609;
6612 -> 6610;
6613 -> 6339;
6613 -> 6610;
6614 -> 6610;
6615 -> 6614;
6616 -> 6613;
6616 -> 6615;
6617 -> 6616;
6617 -> 6606;
6617 -> 6615;
6618 -> 6617;
6618 -> 6614;
6619 -> 6614;
6620 -> 6618;
6620 -> 6619;
6621 -> 6614;
6622 -> 6614;
6623 -> 6620;
6623 -> 6614;
6624 -> 6614;
6625 -> 6623;
6625 -> 6624;
6626 -> 6625;
6626 -> 6624;
6627 -> 6624;
6628 -> 6626;
6628 -> 6627;
6629 -> 6628;
6629 -> 6627;
6630 -> 6627;
6631 -> 6629;
6631 -> 6630;
6632 -> 6631;
6632 -> 6630;
6633 -> 0;
6633 -> 6632;
6634 -> 6620;
6634 -> 6633;
6635 -> 6633;
6636 -> 6634;
6636 -> 6635;
6637 -> 6636;
6637 -> 6635;
6638 -> 6635;
6639 -> 6637;
6639 -> 6638;
6640 -> 6639;
6640 -> 6638;
6641 -> 6640;
6642 -> 6620;
6642 -> 0;
6642 -> 6641;
6643 -> 6620;
6643 -> 0;
6643 -> 6642;
6644 -> 6620;
6644 -> 0;
6644 -> 6643;
6645 -> 6610;
6646 -> 6613;
6646 -> 6645;
6647 -> 6646;
6647 -> 6606;
6647 -> 6645;
6648 -> 6647;
6648 -> 6610;
6649 -> 6610;
6650 -> 6648;
6650 -> 6649;
6651 -> 6611;
6651 -> 6610;
6652 -> 6339;
6653 -> 6339;
6654 -> 6651;
6654 -> 6653;
6655 -> 6654;
6655 -> 6339;
6656 -> 6339;
6657 -> 6655;
6657 -> 6656;
6658 -> 6657;
6658 -> 6656;
6659 -> 0;
6659 -> 6658;
6660 -> 6339;
6660 -> 6606;
6661 -> 6651;
6661 -> 6339;
6662 -> 5633;
6663 -> 5635;
6663 -> 6662;
6664 -> 6663;
6664 -> 6606;
6664 -> 6662;
6665 -> 6664;
6665 -> 5633;
6666 -> 5633;
6667 -> 6665;
6667 -> 6666;
6668 -> 5633;
6669 -> 6661;
6669 -> 6668;
6670 -> 6669;
6670 -> 5633;
6671 -> 5633;
6672 -> 5635;
6672 -> 6671;
6673 -> 6672;
6673 -> 6606;
6673 -> 6671;
6674 -> 6673;
6674 -> 5633;
6675 -> 5633;
6676 -> 6674;
6676 -> 6675;
6677 -> 6670;
6677 -> 6676;
6677 -> 5633;
6678 -> 0;
6678 -> 5633;
6679 -> 5633;
6680 -> 6678;
6680 -> 6679;
6681 -> 5635;
6681 -> 6679;
6682 -> 6680;
6682 -> 6679;
6683 -> 6679;
6684 -> 6682;
6684 -> 6683;
6685 -> 6684;
6685 -> 0;
6685 -> 6683;
6686 -> 6685;
6687 -> 6681;
6687 -> 6606;
6687 -> 6679;
6688 -> 6687;
6688 -> 6680;
6688 -> 6679;
6689 -> 6688;
6690 -> 6688;
6691 -> 6687;
6691 -> 6688;
6692 -> 6192;
6692 -> 5633;
6693 -> 6661;
6693 -> 5633;
6694 -> 6691;
6694 -> 5633;
6695 -> 6692;
6695 -> 6693;
6695 -> 6694;
6695 -> 5635;
6695 -> 6606;
6695 -> 6660;
6695 -> 6688;
6695 -> 5633;
6696 -> 5633;
6697 -> 6695;
6697 -> 6696;
6698 -> 6695;
6698 -> 6696;
6699 -> 6695;
6699 -> 6696;
6700 -> 6695;
6700 -> 6696;
6701 -> 6695;
6701 -> 6696;
6702 -> 6695;
6702 -> 6696;
6703 -> 6697;
6703 -> 6696;
6704 -> 6698;
6704 -> 6696;
6705 -> 6699;
6705 -> 6696;
6706 -> 6700;
6706 -> 6696;
6707 -> 6701;
6707 -> 6696;
6708 -> 6696;
6709 -> 6707;
6709 -> 6708;
6710 -> 6708;
6711 -> 6709;
6711 -> 6695;
6711 -> 6708;
6712 -> 6709;
6712 -> 6695;
6712 -> 6708;
6713 -> 6710;
6713 -> 6708;
6714 -> 6713;
6714 -> 6696;
6715 -> 6702;
6715 -> 6696;
6716 -> 6703;
6716 -> 6704;
6716 -> 6705;
6716 -> 6706;
6716 -> 6714;
6716 -> 6715;
6716 -> 6695;
6716 -> 6696;
6717 -> 6696;
6718 -> 6717;
6718 -> 6696;
6719 -> 6716;
6719 -> 6696;
6720 -> 6716;
6720 -> 6696;
6721 -> 6719;
6721 -> 6696;
6722 -> 6719;
6722 -> 6696;
6723 -> 6150;
6723 -> 5633;
6724 -> 5633;
6725 -> 6723;
6725 -> 6724;
6726 -> 5635;
6726 -> 6724;
6727 -> 6725;
6727 -> 6156;
6727 -> 6724;
6728 -> 6724;
6729 -> 6727;
6729 -> 6728;
6730 -> 6726;
6730 -> 6728;
6731 -> 6730;
6731 -> 6716;
6731 -> 6729;
6731 -> 5642;
6731 -> 6728;
6732 -> 6730;
6732 -> 6716;
6732 -> 6728;
6733 -> 6728;
6734 -> 6730;
6734 -> 6716;
6734 -> 6732;
6734 -> 6733;
6734 -> 6728;
6735 -> 6724;
6736 -> 5633;
6737 -> 6716;
6737 -> 5631;
6738 -> 6737;
6738 -> 5621;
6738 -> 6716;
6738 -> 6732;
6738 -> 5619;
6739 -> 5619;
6740 -> 6738;
6740 -> 6739;
6741 -> 5527;
6741 -> 5526;
6742 -> 5526;
6743 -> 6741;
6743 -> 6742;
6744 -> 5528;
6744 -> 6742;
6745 -> 6742;
6746 -> 6745;
6747 -> 6744;
6747 -> 6746;
6748 -> 6747;
6748 -> 6738;
6748 -> 6746;
6749 -> 6748;
6749 -> 6745;
6750 -> 6745;
6751 -> 6749;
6751 -> 6750;
6752 -> 6750;
6753 -> 6745;
6754 -> 6745;
6755 -> 6751;
6755 -> 6745;
6756 -> 6745;
6757 -> 6755;
6757 -> 6756;
6758 -> 6757;
6758 -> 6756;
6759 -> 6756;
6760 -> 6758;
6760 -> 6759;
6761 -> 6760;
6761 -> 6759;
6762 -> 6759;
6763 -> 6761;
6763 -> 6762;
6764 -> 6763;
6764 -> 6762;
6765 -> 0;
6765 -> 6764;
6766 -> 6751;
6766 -> 6765;
6767 -> 6765;
6768 -> 6766;
6768 -> 6767;
6769 -> 6768;
6769 -> 6767;
6770 -> 6767;
6771 -> 6769;
6771 -> 6770;
6772 -> 6771;
6772 -> 6770;
6773 -> 6772;
6774 -> 6751;
6774 -> 0;
6774 -> 6773;
6775 -> 6751;
6775 -> 0;
6775 -> 6774;
6776 -> 6751;
6776 -> 0;
6776 -> 6775;
6777 -> 6742;
6778 -> 6744;
6778 -> 6777;
6779 -> 6778;
6779 -> 6738;
6779 -> 6777;
6780 -> 6779;
6780 -> 6742;
6781 -> 6742;
6782 -> 6780;
6782 -> 6781;
6783 -> 5520;
6784 -> 5520;
6785 -> 6738;
6785 -> 6784;
6786 -> 6785;
6786 -> 5520;
6787 -> 5520;
6788 -> 6786;
6788 -> 6787;
6789 -> 6788;
6789 -> 6787;
6790 -> 0;
6790 -> 6789;
6791 -> 6738;
6791 -> 5479;
6792 -> 5479;
6793 -> 5479;
6794 -> 5479;
6795 -> 6791;
6795 -> 6794;
6796 -> 6795;
6796 -> 5479;
6797 -> 6791;
6797 -> 6796;
6798 -> 6797;
6798 -> 6738;
6798 -> 6796;
6799 -> 6797;
6799 -> 6738;
6799 -> 6796;
6800 -> 6797;
6800 -> 6738;
6800 -> 6796;
6801 -> 6797;
6801 -> 6738;
6801 -> 6796;
6802 -> 6796;
6803 -> 0;
6803 -> 5479;
6804 -> 5479;
6805 -> 6803;
6805 -> 6804;
6806 -> 5481;
6806 -> 6804;
6807 -> 6805;
6807 -> 6804;
6808 -> 6804;
6809 -> 6807;
6809 -> 6808;
6810 -> 6809;
6810 -> 0;
6810 -> 6808;
6811 -> 6810;
6812 -> 6804;
6813 -> 6806;
6813 -> 6812;
6814 -> 6813;
6814 -> 6801;
6814 -> 6812;
6815 -> 6804;
6816 -> 6814;
6816 -> 6805;
6816 -> 6804;
6817 -> 6816;
6818 -> 6816;
6819 -> 5481;
6819 -> 6801;
6819 -> 6816;
6819 -> 5479;
6820 -> 5479;
6821 -> 5481;
6821 -> 6820;
6822 -> 6820;
6823 -> 6821;
6823 -> 6822;
6824 -> 6823;
6824 -> 6819;
6824 -> 6822;
6825 -> 6823;
6825 -> 6819;
6825 -> 6822;
6826 -> 6825;
6826 -> 6820;
6827 -> 6820;
6828 -> 6826;
6828 -> 6827;
6829 -> 6828;
6829 -> 5479;
6830 -> 6829;
6831 -> 5481;
6831 -> 6830;
6832 -> 6830;
6833 -> 6831;
6833 -> 6832;
6834 -> 6833;
6834 -> 6830;
6835 -> 6831;
6835 -> 6819;
6835 -> 6825;
6835 -> 6830;
6836 -> 6831;
6836 -> 6835;
6836 -> 6830;
6837 -> 6830;
6838 -> 6830;
6839 -> 6830;
6840 -> 6830;
6841 -> 6831;
6841 -> 6840;
6842 -> 6841;
6842 -> 6836;
6842 -> 6840;
6843 -> 6842;
6843 -> 6830;
6844 -> 6830;
6845 -> 6843;
6845 -> 6844;
6846 -> 6845;
6847 -> 6845;
6848 -> 6847;
6849 -> 6847;
6850 -> 6847;
6850 -> 6845;
6851 -> 6845;
6852 -> 6851;
6852 -> 6836;
6852 -> 6847;
6853 -> 6851;
6853 -> 6836;
6853 -> 6847;
6854 -> 6853;
6854 -> 6845;
6855 -> 6845;
6856 -> 6854;
6856 -> 6855;
6857 -> 6856;
6858 -> 6831;
6858 -> 6857;
6859 -> 6857;
6860 -> 6858;
6860 -> 6859;
6861 -> 0;
6861 -> 6859;
6862 -> 6859;
6863 -> 6859;
6864 -> 6861;
6864 -> 6863;
6865 -> 6862;
6865 -> 6863;
6866 -> 6862;
6866 -> 6863;
6867 -> 6860;
6867 -> 6863;
6868 -> 6864;
6868 -> 6863;
6869 -> 6865;
6869 -> 6863;
6870 -> 6866;
6870 -> 6863;
6871 -> 6863;
6872 -> 6868;
6872 -> 6871;
6873 -> 6869;
6873 -> 6871;
6874 -> 6870;
6874 -> 6871;
6875 -> 6867;
6875 -> 6871;
6876 -> 6872;
6876 -> 6871;
6877 -> 6873;
6877 -> 6871;
6878 -> 6874;
6878 -> 6871;
6879 -> 6871;
6880 -> 6876;
6880 -> 6879;
6881 -> 6877;
6881 -> 6879;
6882 -> 6878;
6882 -> 6879;
6883 -> 6875;
6883 -> 6879;
6884 -> 6880;
6884 -> 6879;
6885 -> 6881;
6885 -> 6879;
6886 -> 6882;
6886 -> 6879;
6887 -> 6879;
6888 -> 6884;
6888 -> 6887;
6889 -> 6885;
6889 -> 6887;
6890 -> 6886;
6890 -> 6887;
6891 -> 6883;
6891 -> 6887;
6892 -> 6887;
6893 -> 6891;
6893 -> 6892;
6894 -> 6893;
6894 -> 6887;
6895 -> 6887;
6896 -> 6894;
6896 -> 6895;
6897 -> 6888;
6897 -> 6896;
6898 -> 6889;
6898 -> 6896;
6899 -> 6890;
6899 -> 6896;
6900 -> 6896;
6901 -> 6897;
6901 -> 6900;
6902 -> 6898;
6902 -> 6900;
6903 -> 6899;
6903 -> 6900;
6904 -> 6891;
6904 -> 6900;
6905 -> 6900;
6906 -> 6904;
6906 -> 6905;
6907 -> 6906;
6907 -> 6900;
6908 -> 6900;
6909 -> 6907;
6909 -> 6908;
6910 -> 6909;
6910 -> 6900;
6911 -> 6900;
6912 -> 6904;
6912 -> 6911;
6913 -> 6912;
6913 -> 6900;
6914 -> 6900;
6915 -> 6913;
6915 -> 6914;
6916 -> 6900;
6917 -> 6904;
6917 -> 6916;
6918 -> 6917;
6918 -> 6900;
6919 -> 6900;
6920 -> 6918;
6920 -> 6919;
6921 -> 6900;
6922 -> 6904;
6922 -> 6921;
6923 -> 6921;
6923 -> 6900;
6924 -> 6900;
6925 -> 6900;
6926 -> 6904;
6926 -> 6925;
6927 -> 6925;
6928 -> 6926;
6928 -> 6927;
6929 -> 6928;
6929 -> 6922;
6929 -> 6927;
6930 -> 6929;
6930 -> 6925;
6931 -> 6925;
6932 -> 6930;
6932 -> 6931;
6933 -> 6932;
6933 -> 6925;
6934 -> 6925;
6935 -> 6933;
6935 -> 6934;
6936 -> 6932;
6936 -> 0;
6936 -> 6925;
6937 -> 6925;
6938 -> 6926;
6938 -> 6937;
6939 -> 6938;
6939 -> 6922;
6939 -> 6937;
6940 -> 6939;
6940 -> 6925;
6941 -> 6925;
6942 -> 6940;
6942 -> 6941;
6943 -> 6936;
6943 -> 6942;
6943 -> 6925;
6944 -> 6925;
6945 -> 6926;
6945 -> 6944;
6946 -> 6945;
6946 -> 6922;
6946 -> 6944;
6947 -> 6946;
6947 -> 6925;
6948 -> 6925;
6949 -> 6947;
6949 -> 6948;
6950 -> 6943;
6950 -> 6949;
6950 -> 6925;
6951 -> 6950;
6952 -> 6951;
6952 -> 6900;
6953 -> 6902;
6953 -> 6952;
6954 -> 0;
6954 -> 6953;
6955 -> 6952;
6956 -> 6954;
6956 -> 6955;
6957 -> 6904;
6957 -> 6955;
6958 -> 6955;
6959 -> 6957;
6959 -> 6958;
6960 -> 6959;
6960 -> 6955;
6961 -> 6955;
6962 -> 6960;
6962 -> 6961;
6963 -> 6956;
6963 -> 6955;
6964 -> 6963;
6964 -> 6957;
6964 -> 6922;
6964 -> 6955;
6965 -> 6955;
6966 -> 6964;
6966 -> 6965;
6967 -> 6964;
6967 -> 6965;
6968 -> 6964;
6968 -> 6965;
6969 -> 6965;
6970 -> 6968;
6970 -> 6969;
6971 -> 6970;
6971 -> 6965;
6972 -> 6965;
6973 -> 6971;
6973 -> 6972;
6974 -> 6965;
6975 -> 6973;
6975 -> 6974;
6976 -> 6965;
6977 -> 6968;
6977 -> 6976;
6978 -> 6977;
6979 -> 6977;
6980 -> 6978;
6980 -> 6979;
6981 -> 6980;
6981 -> 6977;
6982 -> 6977;
6983 -> 6981;
6983 -> 6982;
6984 -> 6982;
6984 -> 6965;
6985 -> 6967;
6985 -> 6984;
6986 -> 6984;
6987 -> 6985;
6987 -> 6986;
6988 -> 6968;
6988 -> 6986;
6989 -> 6987;
6989 -> 6986;
6990 -> 6986;
6991 -> 6989;
6991 -> 6990;
6992 -> 6988;
6992 -> 6990;
6993 -> 6991;
6993 -> 6990;
6994 -> 6990;
6995 -> 6990;
6996 -> 6992;
6996 -> 6995;
6997 -> 6995;
6998 -> 6996;
6998 -> 6997;
6999 -> 6998;
6999 -> 6995;
7000 -> 6999;
7001 -> 7000;
7001 -> 6990;
7002 -> 6994;
7002 -> 6990;
7003 -> 6992;
7004 -> 6992;
7004 -> 7003;
7005 -> 7003;
7006 -> 7004;
7006 -> 7005;
7007 -> 7006;
7007 -> 7003;
7008 -> 7003;
7008 -> 6992;
7009 -> 6992;
7010 -> 7009;
7010 -> 6992;
7011 -> 7008;
7011 -> 7010;
7011 -> 6992;
7012 -> 6992;
7012 -> 6964;
7013 -> 6992;
7014 -> 6992;
7015 -> 6992;
7016 -> 6992;
7016 -> 7015;
7017 -> 7016;
7017 -> 6964;
7017 -> 6992;
7017 -> 7015;
7018 -> 7017;
7018 -> 6992;
7019 -> 6992;
7019 -> 6990;
7020 -> 6992;
7020 -> 6990;
7021 -> 6992;
7021 -> 6990;
7022 -> 6990;
7023 -> 7021;
7023 -> 7022;
7024 -> 6990;
7025 -> 6992;
7025 -> 7024;
7026 -> 7025;
7026 -> 6990;
7027 -> 6990;
7028 -> 7026;
7028 -> 7027;
7029 -> 6992;
7029 -> 6986;
7030 -> 6986;
7031 -> 6988;
7031 -> 7030;
7032 -> 7031;
7032 -> 6992;
7032 -> 7030;
7033 -> 7032;
7033 -> 6986;
7034 -> 6986;
7035 -> 6988;
7035 -> 7034;
7036 -> 7035;
7036 -> 6992;
7036 -> 7034;
7037 -> 7036;
7037 -> 6986;
7038 -> 6986;
7039 -> 7037;
7039 -> 7038;
7040 -> 7033;
7040 -> 7039;
7040 -> 6986;
7041 -> 7029;
7041 -> 6986;
7042 -> 7041;
7042 -> 6984;
7043 -> 6964;
7043 -> 6965;
7044 -> 6901;
7044 -> 6952;
7045 -> 6952;
7046 -> 7044;
7046 -> 7045;
7047 -> 6904;
7047 -> 7045;
7048 -> 7045;
7049 -> 7047;
7049 -> 7048;
7050 -> 7049;
7050 -> 7042;
7050 -> 7048;
7051 -> 7050;
7051 -> 7045;
7052 -> 7045;
7053 -> 7051;
7053 -> 7052;
7054 -> 7053;
7055 -> 7053;
7056 -> 7054;
7056 -> 7055;
7057 -> 7056;
7057 -> 7055;
7058 -> 7055;
7059 -> 7057;
7059 -> 7058;
7060 -> 7059;
7060 -> 7058;
7061 -> 0;
7061 -> 7060;
7062 -> 7061;
7062 -> 6952;
7063 -> 7042;
7063 -> 6900;
7064 -> 6901;
7064 -> 6900;
7065 -> 6903;
7065 -> 6900;
7066 -> 6900;
7067 -> 7063;
7067 -> 7066;
7068 -> 7064;
7068 -> 7066;
7069 -> 7065;
7069 -> 7066;
7070 -> 6904;
7070 -> 7066;
7071 -> 7066;
7072 -> 7067;
7072 -> 7071;
7073 -> 7072;
7073 -> 7066;
7074 -> 7067;
7074 -> 7073;
7075 -> 7074;
7075 -> 7042;
7075 -> 7073;
7076 -> 7073;
7077 -> 7075;
7077 -> 7076;
7078 -> 7077;
7078 -> 7073;
7079 -> 7066;
7080 -> 7070;
7080 -> 7079;
7081 -> 7080;
7081 -> 7042;
7081 -> 7079;
7082 -> 7081;
7082 -> 7066;
7083 -> 7066;
7084 -> 7082;
7084 -> 7083;
7085 -> 7066;
7086 -> 7066;
7087 -> 7085;
7087 -> 7086;
7088 -> 7070;
7088 -> 7086;
7089 -> 7086;
7090 -> 7086;
7091 -> 7088;
7091 -> 7090;
7092 -> 7091;
7092 -> 7042;
7092 -> 7090;
7093 -> 7092;
7093 -> 7086;
7094 -> 7086;
7095 -> 7093;
7095 -> 7094;
7096 -> 7086;
7097 -> 7096;
7097 -> 7066;
7098 -> 7066;
7099 -> 7067;
7099 -> 7098;
7099 -> 7066;
7100 -> 7069;
7100 -> 7099;
7101 -> 7099;
7102 -> 7099;
7103 -> 7100;
7103 -> 7102;
7104 -> 7101;
7104 -> 7102;
7105 -> 7070;
7105 -> 7102;
7106 -> 7102;
7107 -> 7102;
7108 -> 7105;
7108 -> 7107;
7109 -> 7107;
7110 -> 7109;
7110 -> 7102;
7111 -> 7102;
7112 -> 7111;
7112 -> 7099;
7113 -> 7067;
7113 -> 7112;
7114 -> 7112;
7115 -> 7112;
7116 -> 7113;
7116 -> 7115;
7117 -> 7114;
7117 -> 7115;
7118 -> 7114;
7118 -> 7115;
7119 -> 7070;
7119 -> 7115;
7120 -> 7115;
7121 -> 7116;
7121 -> 7115;
7122 -> 7116;
7122 -> 7042;
7122 -> 7115;
7123 -> 7119;
7123 -> 7042;
7123 -> 7115;
7124 -> 7121;
7124 -> 7122;
7125 -> 7122;
7126 -> 7124;
7126 -> 7125;
7127 -> 7068;
7127 -> 7125;
7128 -> 7125;
7129 -> 7126;
7129 -> 7128;
7130 -> 7127;
7130 -> 7128;
7131 -> 7070;
7131 -> 7128;
7132 -> 7128;
7133 -> 7132;
7134 -> 7131;
7134 -> 7133;
7135 -> 7134;
7135 -> 7132;
7136 -> 7132;
7137 -> 7135;
7137 -> 7136;
7138 -> 7132;
7139 -> 7132;
7140 -> 7137;
7140 -> 7132;
7141 -> 7132;
7142 -> 7140;
7142 -> 7141;
7143 -> 7142;
7143 -> 7141;
7144 -> 7141;
7145 -> 7143;
7145 -> 7144;
7146 -> 7145;
7146 -> 7144;
7147 -> 7144;
7148 -> 7146;
7148 -> 7147;
7149 -> 7148;
7149 -> 7147;
7150 -> 0;
7150 -> 7149;
7151 -> 7137;
7151 -> 7150;
7152 -> 7150;
7153 -> 7151;
7153 -> 7152;
7154 -> 7153;
7154 -> 7152;
7155 -> 7152;
7156 -> 7154;
7156 -> 7155;
7157 -> 7156;
7157 -> 7155;
7158 -> 7157;
7159 -> 7137;
7159 -> 0;
7159 -> 7158;
7160 -> 7137;
7160 -> 0;
7160 -> 7159;
7161 -> 7137;
7161 -> 0;
7161 -> 7160;
7162 -> 7128;
7163 -> 7131;
7163 -> 7162;
7164 -> 7163;
7164 -> 7128;
7165 -> 7128;
7166 -> 7164;
7166 -> 7165;
7167 -> 7129;
7167 -> 7125;
7168 -> 7167;
7168 -> 7070;
7168 -> 7042;
7168 -> 7125;
7169 -> 7125;
7170 -> 7168;
7170 -> 7169;
7171 -> 7168;
7171 -> 7169;
7172 -> 7168;
7172 -> 7169;
7173 -> 7168;
7173 -> 7169;
7174 -> 7170;
7174 -> 7169;
7175 -> 7171;
7175 -> 7169;
7176 -> 7172;
7176 -> 7169;
7177 -> 7169;
7178 -> 7176;
7178 -> 7177;
7179 -> 7178;
7179 -> 7168;
7179 -> 7177;
7180 -> 7178;
7180 -> 7168;
7180 -> 7177;
7181 -> 7177;
7181 -> 7169;
7182 -> 7173;
7182 -> 7169;
7183 -> 7174;
7183 -> 7175;
7183 -> 7181;
7183 -> 7182;
7183 -> 7168;
7183 -> 7169;
7184 -> 7183;
7184 -> 7169;
7185 -> 7183;
7185 -> 7169;
7186 -> 7184;
7186 -> 7169;
7187 -> 7184;
7187 -> 7169;
7188 -> 6900;
7189 -> 7183;
7189 -> 7188;
7189 -> 6900;
7190 -> 7183;
7190 -> 7189;
7191 -> 6923;
7191 -> 7189;
7192 -> 7189;
7193 -> 7191;
7193 -> 7192;
7194 -> 7193;
7194 -> 6922;
7194 -> 7192;
7195 -> 7194;
7195 -> 7192;
7196 -> 7192;
7196 -> 7183;
7196 -> 7195;
7196 -> 6922;
7197 -> 7192;
7198 -> 7192;
7199 -> 7189;
7200 -> 6879;
7201 -> 6883;
7201 -> 7200;
7202 -> 7201;
7202 -> 7183;
7202 -> 7200;
7203 -> 7202;
7203 -> 6879;
7204 -> 6879;
7205 -> 7203;
7205 -> 7204;
7206 -> 7190;
7206 -> 6879;
7207 -> 6871;
7208 -> 6875;
7208 -> 7207;
7209 -> 7208;
7209 -> 7183;
7209 -> 7207;
7210 -> 7209;
7210 -> 6871;
7211 -> 6871;
7212 -> 7210;
7212 -> 7211;
7213 -> 7206;
7213 -> 6871;
7214 -> 7213;
7214 -> 6859;
7215 -> 7213;
7215 -> 6859;
7216 -> 7215;
7216 -> 6857;
7217 -> 6857;
7218 -> 7216;
7218 -> 7217;
7219 -> 6858;
7219 -> 7217;
7220 -> 7217;
7221 -> 7218;
7221 -> 7220;
7222 -> 7221;
7222 -> 7217;
7223 -> 7218;
7223 -> 7222;
7224 -> 7223;
7224 -> 6856;
7225 -> 6856;
7226 -> 7225;
7226 -> 7183;
7227 -> 7226;
7227 -> 6856;
7228 -> 6856;
7229 -> 7227;
7229 -> 7228;
7230 -> 6856;
7231 -> 7224;
7231 -> 7230;
7232 -> 7231;
7232 -> 6856;
7233 -> 7224;
7233 -> 6856;
7234 -> 0;
7234 -> 7233;
7235 -> 7233;
7236 -> 7234;
7236 -> 7235;
7237 -> 7236;
7237 -> 7235;
7238 -> 7235;
7239 -> 7237;
7239 -> 7238;
7240 -> 7239;
7240 -> 0;
7240 -> 7238;
7241 -> 7240;
7242 -> 7236;
7242 -> 7183;
7243 -> 7236;
7244 -> 7236;
7245 -> 6850;
7245 -> 7233;
7246 -> 7224;
7246 -> 7233;
7247 -> 7236;
7247 -> 7233;
7248 -> 7245;
7248 -> 7246;
7248 -> 7247;
7248 -> 6831;
7248 -> 7183;
7248 -> 7192;
7248 -> 7236;
7248 -> 7233;
7249 -> 7233;
7250 -> 7248;
7250 -> 7249;
7251 -> 7250;
7251 -> 7249;
7252 -> 7251;
7252 -> 7248;
7252 -> 7249;
7253 -> 7251;
7253 -> 7248;
7253 -> 7249;
7254 -> 7250;
7254 -> 7249;
7255 -> 7250;
7255 -> 7249;
7256 -> 7254;
7256 -> 7249;
7257 -> 7254;
7257 -> 7249;
7258 -> 7250;
7258 -> 6830;
7259 -> 6830;
7260 -> 6831;
7260 -> 7259;
7261 -> 7260;
7261 -> 7258;
7261 -> 7259;
7262 -> 7260;
7262 -> 7258;
7262 -> 7259;
7263 -> 7259;
7264 -> 7260;
7264 -> 7263;
7265 -> 7264;
7265 -> 7258;
7265 -> 7262;
7265 -> 7263;
7266 -> 7259;
7267 -> 7265;
7267 -> 7266;
7268 -> 7267;
7268 -> 6830;
7269 -> 6830;
7270 -> 6835;
7270 -> 7258;
7270 -> 7269;
7270 -> 6830;
7271 -> 6835;
7271 -> 7270;
7271 -> 7258;
7271 -> 7262;
7271 -> 6830;
7272 -> 7271;
7272 -> 6830;
7273 -> 6836;
7273 -> 6830;
7274 -> 6830;
7275 -> 6830;
7276 -> 7272;
7276 -> 7275;
7277 -> 7273;
7277 -> 7275;
7278 -> 7274;
7278 -> 7275;
7279 -> 6831;
7279 -> 7275;
7280 -> 7279;
7280 -> 7271;
7280 -> 7275;
7281 -> 7279;
7281 -> 7271;
7281 -> 0;
7281 -> 7275;
7282 -> 7281;
7282 -> 7279;
7282 -> 7275;
7283 -> 7278;
7283 -> 7275;
7284 -> 7279;
7284 -> 7271;
7284 -> 7282;
7284 -> 0;
7284 -> 7283;
7285 -> 7284;
7285 -> 7279;
7285 -> 7283;
7286 -> 7275;
7287 -> 7275;
7288 -> 7279;
7288 -> 7287;
7289 -> 7288;
7289 -> 7271;
7289 -> 7287;
7290 -> 7289;
7290 -> 7275;
7291 -> 7275;
7292 -> 7290;
7292 -> 7291;
7293 -> 7275;
7294 -> 7279;
7294 -> 7293;
7295 -> 7294;
7295 -> 7271;
7295 -> 7293;
7296 -> 7295;
7296 -> 7275;
7297 -> 7275;
7298 -> 7296;
7298 -> 7297;
7299 -> 7292;
7299 -> 7298;
7299 -> 7275;
7300 -> 7275;
7301 -> 7279;
7301 -> 7300;
7302 -> 7301;
7302 -> 7271;
7302 -> 7300;
7303 -> 7300;
7304 -> 7301;
7304 -> 7303;
7305 -> 7304;
7305 -> 7271;
7305 -> 7303;
7306 -> 7300;
7307 -> 7305;
7307 -> 7306;
7308 -> 7307;
7308 -> 7275;
7309 -> 7278;
7309 -> 7308;
7309 -> 7275;
7310 -> 7299;
7310 -> 7309;
7310 -> 7275;
7311 -> 7286;
7311 -> 7275;
7312 -> 7275;
7313 -> 7275;
7314 -> 7311;
7314 -> 7313;
7315 -> 7312;
7315 -> 7313;
7316 -> 7279;
7316 -> 7313;
7317 -> 7316;
7317 -> 7271;
7317 -> 7313;
7318 -> 7317;
7318 -> 7314;
7318 -> 7313;
7319 -> 7310;
7319 -> 7318;
7319 -> 7275;
7320 -> 7319;
7321 -> 7319;
7322 -> 7320;
7322 -> 7321;
7323 -> 7279;
7323 -> 7321;
7324 -> 7321;
7325 -> 7323;
7325 -> 7324;
7326 -> 7325;
7326 -> 7321;
7327 -> 7321;
7328 -> 7326;
7328 -> 7327;
7329 -> 7328;
7329 -> 7321;
7330 -> 7329;
7331 -> 7330;
7331 -> 7319;
7332 -> 7331;
7333 -> 7332;
7333 -> 7271;
7333 -> 7282;
7333 -> 7285;
7334 -> 7333;
7334 -> 7332;
7335 -> 7332;
7336 -> 7334;
7336 -> 7335;
7337 -> 7336;
7337 -> 7332;
7338 -> 7332;
7339 -> 7338;
7339 -> 7332;
7340 -> 7333;
7340 -> 7332;
7341 -> 7339;
7341 -> 7332;
7342 -> 7340;
7342 -> 7332;
7343 -> 7341;
7343 -> 7332;
7344 -> 7332;
7345 -> 7342;
7345 -> 7344;
7346 -> 7343;
7346 -> 7344;
7347 -> 7332;
7347 -> 7344;
7348 -> 7344;
7349 -> 7347;
7349 -> 7348;
7350 -> 7348;
7351 -> 7349;
7351 -> 7350;
7352 -> 7351;
7352 -> 7333;
7352 -> 7350;
7353 -> 7352;
7353 -> 7348;
7354 -> 7353;
7355 -> 7354;
7355 -> 7344;
7356 -> 7355;
7356 -> 7332;
7357 -> 7332;
7358 -> 7332;
7358 -> 7333;
7359 -> 7332;
7360 -> 7340;
7360 -> 7333;
7361 -> 7333;
7362 -> 7361;
7363 -> 7361;
7364 -> 7361;
7364 -> 7333;
7365 -> 7360;
7365 -> 7364;
7365 -> 7332;
7365 -> 7333;
7365 -> 7361;
7366 -> 7333;
7367 -> 7365;
7367 -> 7366;
7368 -> 7365;
7368 -> 7366;
7369 -> 7365;
7369 -> 7366;
7370 -> 7365;
7370 -> 7366;
7371 -> 7365;
7371 -> 7366;
7372 -> 7367;
7372 -> 7366;
7373 -> 7368;
7373 -> 7366;
7374 -> 7369;
7374 -> 7366;
7375 -> 7370;
7375 -> 7366;
7376 -> 7366;
7377 -> 7375;
7377 -> 7376;
7378 -> 7377;
7378 -> 7365;
7378 -> 7376;
7379 -> 7377;
7379 -> 7365;
7379 -> 7376;
7380 -> 7376;
7380 -> 7366;
7381 -> 7371;
7381 -> 7366;
7382 -> 7372;
7382 -> 7373;
7382 -> 7374;
7382 -> 7380;
7382 -> 7381;
7382 -> 7365;
7382 -> 7366;
7383 -> 7382;
7383 -> 7366;
7384 -> 7382;
7384 -> 7366;
7385 -> 7383;
7385 -> 7366;
7386 -> 7383;
7386 -> 7366;
7387 -> 7332;
7387 -> 7382;
7387 -> 7333;
7388 -> 7357;
7388 -> 7333;
7389 -> 7333;
7390 -> 7388;
7390 -> 7389;
7391 -> 7390;
7391 -> 7333;
7391 -> 7389;
7392 -> 7391;
7392 -> 7389;
7393 -> 7389;
7393 -> 7382;
7393 -> 7392;
7393 -> 7333;
7394 -> 7389;
7394 -> 7382;
7395 -> 7389;
7396 -> 7389;
7396 -> 7382;
7396 -> 7394;
7396 -> 7395;
7397 -> 7389;
7398 -> 7333;
7399 -> 7382;
7399 -> 7331;
7400 -> 7331;
7401 -> 7399;
7401 -> 7400;
7401 -> 7331;
7402 -> 7399;
7402 -> 7401;
7403 -> 7277;
7403 -> 7402;
7403 -> 6836;
7403 -> 7382;
7403 -> 7387;
7403 -> 7394;
7403 -> 7401;
7404 -> 7319;
7404 -> 7403;
7405 -> 7280;
7405 -> 7279;
7405 -> 7403;
7406 -> 6830;
7407 -> 6835;
7407 -> 7403;
7407 -> 7406;
7407 -> 6830;
7408 -> 7276;
7408 -> 7407;
7408 -> 6830;
7409 -> 7408;
7409 -> 6830;
7410 -> 6836;
7410 -> 6830;
7411 -> 7409;
7411 -> 7410;
7411 -> 6831;
7411 -> 7403;
7411 -> 6836;
7411 -> 7405;
7411 -> 6830;
7412 -> 6830;
7413 -> 7411;
7413 -> 7412;
7414 -> 7412;
7415 -> 7413;
7415 -> 7414;
7416 -> 7415;
7416 -> 7411;
7416 -> 7414;
7417 -> 7415;
7417 -> 7411;
7417 -> 7414;
7418 -> 7414;
7418 -> 7412;
7419 -> 7413;
7419 -> 7412;
7420 -> 7413;
7420 -> 7412;
7421 -> 7419;
7421 -> 7412;
7422 -> 7419;
7422 -> 7412;
7423 -> 6836;
7423 -> 6830;
7424 -> 6831;
7424 -> 7413;
7424 -> 7423;
7424 -> 6836;
7424 -> 6830;
7425 -> 7408;
7425 -> 6830;
7426 -> 6831;
7426 -> 7424;
7426 -> 7425;
7426 -> 6830;
7427 -> 7413;
7427 -> 6829;
7428 -> 7427;
7428 -> 6829;
7429 -> 6819;
7429 -> 7428;
7429 -> 7426;
7429 -> 6829;
7430 -> 7429;
7431 -> 7430;
7431 -> 7429;
7432 -> 7429;
7433 -> 7429;
7434 -> 7429;
7435 -> 7430;
7436 -> 7430;
7437 -> 7430;
7438 -> 7430;
7438 -> 7429;
7439 -> 7430;
7440 -> 7430;
7441 -> 7439;
7441 -> 7430;
7442 -> 7440;
7442 -> 7430;
7443 -> 7441;
7443 -> 7430;
7444 -> 7442;
7444 -> 7430;
7445 -> 7443;
7445 -> 7430;
7446 -> 7444;
7446 -> 7430;
7447 -> 7445;
7447 -> 7430;
7448 -> 7446;
7448 -> 7430;
7449 -> 7430;
7450 -> 7449;
7450 -> 7430;
7451 -> 7430;
7452 -> 7450;
7452 -> 7451;
7453 -> 7452;
7453 -> 7430;
7454 -> 7430;
7455 -> 7454;
7455 -> 7430;
7456 -> 7430;
7457 -> 7455;
7457 -> 7456;
7458 -> 7430;
7459 -> 7458;
7459 -> 7430;
7460 -> 7430;
7461 -> 7459;
7461 -> 7460;
7462 -> 7430;
7463 -> 7430;
7464 -> 7449;
7464 -> 7430;
7465 -> 7430;
7466 -> 7464;
7466 -> 7465;
7467 -> 7449;
7467 -> 7456;
7468 -> 7445;
7468 -> 7467;
7469 -> 7467;
7470 -> 7469;
7470 -> 7467;
7471 -> 7467;
7472 -> 7470;
7472 -> 7471;
7473 -> 7468;
7473 -> 7467;
7474 -> 7468;
7474 -> 7467;
7475 -> 7467;
7476 -> 7468;
7476 -> 7475;
7477 -> 7476;
7477 -> 7467;
7478 -> 7467;
7479 -> 7477;
7479 -> 7478;
7480 -> 7467;
7481 -> 7479;
7481 -> 7480;
7482 -> 7468;
7483 -> 7468;
7484 -> 7482;
7484 -> 7483;
7485 -> 7484;
7485 -> 7468;
7486 -> 7474;
7486 -> 7468;
7487 -> 7486;
7487 -> 7468;
7488 -> 7487;
7488 -> 7468;
7489 -> 7468;
7490 -> 7468;
7491 -> 7468;
7491 -> 7490;
7492 -> 7490;
7493 -> 7491;
7493 -> 7492;
7494 -> 7493;
7494 -> 7490;
7495 -> 7494;
7496 -> 7495;
7496 -> 7468;
7497 -> 7489;
7497 -> 7468;
7498 -> 7468;
7499 -> 7468;
7499 -> 7498;
7500 -> 7498;
7501 -> 7499;
7501 -> 7500;
7502 -> 7501;
7502 -> 7498;
7503 -> 7498;
7503 -> 7468;
7504 -> 7468;
7505 -> 7504;
7505 -> 7468;
7506 -> 7503;
7506 -> 7505;
7506 -> 7468;
7507 -> 7468;
7508 -> 7468;
7509 -> 7468;
7510 -> 7468;
7511 -> 7468;
7511 -> 7510;
7512 -> 7511;
7512 -> 7468;
7512 -> 7510;
7513 -> 7512;
7513 -> 7468;
7514 -> 7489;
7514 -> 7468;
7515 -> 7468;
7515 -> 7489;
7516 -> 7489;
7516 -> 7468;
7517 -> 7468;
7518 -> 7516;
7518 -> 7517;
7519 -> 7468;
7520 -> 7519;
7520 -> 7489;
7521 -> 7520;
7521 -> 7468;
7522 -> 7468;
7523 -> 7521;
7523 -> 7522;
7524 -> 7468;
7525 -> 7524;
7525 -> 7489;
7526 -> 7525;
7526 -> 7468;
7527 -> 7468;
7528 -> 7527;
7528 -> 7489;
7529 -> 7528;
7529 -> 7468;
7530 -> 7468;
7531 -> 7529;
7531 -> 7530;
7532 -> 7526;
7532 -> 7531;
7532 -> 7468;
7533 -> 7468;
7533 -> 7467;
7534 -> 7447;
7534 -> 7467;
7535 -> 7467;
7536 -> 7534;
7536 -> 7535;
7537 -> 7430;
7537 -> 7535;
7538 -> 7535;
7539 -> 7537;
7539 -> 7538;
7540 -> 7539;
7540 -> 7489;
7540 -> 7538;
7541 -> 7540;
7541 -> 7535;
7542 -> 7535;
7543 -> 7541;
7543 -> 7542;
7544 -> 7543;
7545 -> 7543;
7546 -> 7544;
7546 -> 7545;
7547 -> 7546;
7547 -> 7545;
7548 -> 7545;
7549 -> 7547;
7549 -> 7548;
7550 -> 7549;
7550 -> 7548;
7551 -> 0;
7551 -> 7550;
7552 -> 7551;
7552 -> 7467;
7553 -> 7447;
7553 -> 7430;
7554 -> 7448;
7554 -> 7430;
7555 -> 7430;
7556 -> 7489;
7556 -> 7555;
7557 -> 7556;
7557 -> 7430;
7558 -> 7489;
7558 -> 7557;
7559 -> 7558;
7559 -> 7489;
7559 -> 7557;
7560 -> 7557;
7561 -> 7559;
7561 -> 7560;
7562 -> 7561;
7562 -> 7557;
7563 -> 7430;
7564 -> 7563;
7564 -> 7489;
7565 -> 7564;
7565 -> 7430;
7566 -> 7430;
7567 -> 7565;
7567 -> 7566;
7568 -> 7430;
7569 -> 7430;
7570 -> 7568;
7570 -> 7569;
7571 -> 7430;
7571 -> 7569;
7572 -> 7569;
7573 -> 7569;
7574 -> 7571;
7574 -> 7573;
7575 -> 7574;
7575 -> 7489;
7575 -> 7573;
7576 -> 7575;
7576 -> 7569;
7577 -> 7569;
7578 -> 7576;
7578 -> 7577;
7579 -> 7569;
7580 -> 7579;
7580 -> 7430;
7581 -> 7554;
7581 -> 7489;
7582 -> 7581;
7582 -> 7489;
7583 -> 7489;
7584 -> 7430;
7584 -> 7489;
7585 -> 7489;
7586 -> 7489;
7587 -> 7584;
7587 -> 7586;
7588 -> 7586;
7589 -> 7588;
7589 -> 7489;
7590 -> 7489;
7591 -> 7489;
7592 -> 7430;
7592 -> 7489;
7593 -> 7489;
7594 -> 7553;
7594 -> 7489;
7595 -> 7594;
7595 -> 7489;
7596 -> 7430;
7596 -> 7489;
7597 -> 7489;
7598 -> 7597;
7599 -> 7596;
7599 -> 7598;
7600 -> 7599;
7600 -> 7597;
7601 -> 7597;
7602 -> 7600;
7602 -> 7601;
7603 -> 7597;
7604 -> 7597;
7605 -> 7602;
7605 -> 7597;
7606 -> 7597;
7607 -> 7605;
7607 -> 7606;
7608 -> 7607;
7608 -> 7606;
7609 -> 7606;
7610 -> 7608;
7610 -> 7609;
7611 -> 7610;
7611 -> 7609;
7612 -> 7609;
7613 -> 7611;
7613 -> 7612;
7614 -> 7613;
7614 -> 7612;
7615 -> 0;
7615 -> 7614;
7616 -> 7602;
7616 -> 7615;
7617 -> 7615;
7618 -> 7616;
7618 -> 7617;
7619 -> 7618;
7619 -> 7617;
7620 -> 7617;
7621 -> 7619;
7621 -> 7620;
7622 -> 7621;
7622 -> 7620;
7623 -> 7622;
7624 -> 7602;
7624 -> 0;
7624 -> 7623;
7625 -> 7602;
7625 -> 0;
7625 -> 7624;
7626 -> 7602;
7626 -> 0;
7626 -> 7625;
7627 -> 7489;
7628 -> 7596;
7628 -> 7627;
7629 -> 7628;
7629 -> 7489;
7630 -> 7489;
7631 -> 7629;
7631 -> 7630;
7632 -> 7489;
7633 -> 7632;
7633 -> 7489;
7634 -> 7633;
7634 -> 7489;
7635 -> 7633;
7635 -> 7489;
7636 -> 7632;
7637 -> 7632;
7638 -> 7636;
7638 -> 7632;
7639 -> 7636;
7639 -> 7632;
7640 -> 7462;
7640 -> 7632;
7641 -> 7640;
7641 -> 7632;
7642 -> 7641;
7642 -> 7430;
7642 -> 7632;
7643 -> 7642;
7643 -> 7632;
7644 -> 7632;
7644 -> 7643;
7644 -> 7430;
7645 -> 7632;
7646 -> 7632;
7647 -> 7632;
7648 -> 7430;
7649 -> 7648;
7649 -> 7632;
7650 -> 7649;
7650 -> 7430;
7651 -> 7430;
7652 -> 7650;
7652 -> 7651;
7653 -> 7430;
7654 -> 7653;
7654 -> 7632;
7655 -> 7654;
7655 -> 7430;
7656 -> 7430;
7657 -> 7655;
7657 -> 7656;
7658 -> 7632;
7658 -> 7430;
7659 -> 7430;
7660 -> 7430;
7661 -> 7660;
7661 -> 7632;
7662 -> 7661;
7662 -> 7430;
7663 -> 7430;
7664 -> 7662;
7664 -> 7663;
7665 -> 7430;
7666 -> 7632;
7666 -> 7665;
7667 -> 7666;
7667 -> 7430;
7668 -> 7632;
7669 -> 7632;
7670 -> 7668;
7670 -> 7669;
7671 -> 7670;
7671 -> 0;
7671 -> 7669;
7672 -> 7671;
7673 -> 7632;
7674 -> 7632;
7675 -> 7632;
7676 -> 7632;
7677 -> 7676;
7677 -> 7632;
7678 -> 7676;
7678 -> 7632;
7679 -> 7449;
7679 -> 7632;
7679 -> 7430;
7680 -> 7632;
7680 -> 7429;
7681 -> 7429;
7682 -> 7632;
7683 -> 7632;
7684 -> 7632;
7685 -> 7683;
7685 -> 7684;
7686 -> 7685;
7686 -> 7632;
7687 -> 7632;
7688 -> 7687;
7688 -> 7632;
7689 -> 7688;
7689 -> 7632;
7690 -> 7632;
7691 -> 7689;
7691 -> 7632;
7692 -> 7632;
7693 -> 7690;
7693 -> 7692;
7694 -> 7691;
7694 -> 7692;
7695 -> 7632;
7695 -> 7692;
7696 -> 7692;
7697 -> 7695;
7697 -> 7696;
7698 -> 7696;
7699 -> 7697;
7699 -> 7698;
7700 -> 7699;
7700 -> 7696;
7701 -> 7700;
7702 -> 7701;
7702 -> 7692;
7703 -> 7702;
7703 -> 7632;
7704 -> 7632;
7705 -> 7632;
7706 -> 7632;
7707 -> 7632;
7708 -> 7704;
7708 -> 7632;
7709 -> 7708;
7709 -> 7632;
7710 -> 7709;
7710 -> 7632;
7711 -> 7710;
7711 -> 7632;
7712 -> 7632;
7712 -> 7711;
7713 -> 7632;
7714 -> 7632;
7715 -> 7632;
7715 -> 7429;
7716 -> 7715;
7716 -> 7632;
7716 -> 7429;
7717 -> 7715;
7717 -> 7632;
7717 -> 7429;
7718 -> 7632;
7718 -> 7429;
7719 -> 7632;
7719 -> 7429;
7720 -> 7718;
7720 -> 7429;
7721 -> 7718;
7721 -> 7429;
7722 -> 6820;
7723 -> 6821;
7723 -> 7722;
7724 -> 6820;
7725 -> 0;
7725 -> 5479;
7726 -> 5479;
7727 -> 7725;
7727 -> 7726;
7728 -> 5481;
7728 -> 7726;
7729 -> 7727;
7729 -> 7726;
7730 -> 7726;
7731 -> 7729;
7731 -> 7730;
7732 -> 7731;
7732 -> 0;
7732 -> 7730;
7733 -> 7732;
7734 -> 7726;
7735 -> 7728;
7735 -> 7734;
7736 -> 7735;
7736 -> 7632;
7736 -> 7734;
7737 -> 7726;
7738 -> 7736;
7738 -> 7727;
7738 -> 7726;
7739 -> 7738;
7739 -> 7632;
7740 -> 7738;
7741 -> 7738;
7742 -> 5480;
7742 -> 5479;
7743 -> 5516;
7743 -> 5479;
7744 -> 6798;
7744 -> 5479;
7745 -> 6799;
7745 -> 5479;
7746 -> 6800;
7746 -> 5479;
7747 -> 6816;
7747 -> 5479;
7748 -> 6819;
7748 -> 5479;
7749 -> 7738;
7749 -> 5479;
7750 -> 7742;
7750 -> 7743;
7750 -> 7744;
7750 -> 7745;
7750 -> 7746;
7750 -> 7747;
7750 -> 7748;
7750 -> 7749;
7750 -> 5481;
7750 -> 7632;
7750 -> 5412;
7750 -> 7738;
7750 -> 5479;
7751 -> 5479;
7752 -> 7751;
7753 -> 7752;
7753 -> 7751;
7754 -> 7750;
7754 -> 7751;
7755 -> 7750;
7755 -> 7751;
7756 -> 7754;
7756 -> 7750;
7756 -> 7751;
7757 -> 7754;
7757 -> 7750;
7757 -> 7751;
7758 -> 6819;
7758 -> 5479;
7759 -> 5481;
7759 -> 7750;
7759 -> 7758;
7759 -> 5479;
7760 -> 5467;
7760 -> 5477;
7761 -> 5477;
7762 -> 7760;
7762 -> 7761;
7763 -> 5420;
7763 -> 7761;
7764 -> 7762;
7764 -> 5462;
7764 -> 7761;
7765 -> 7761;
7766 -> 7764;
7766 -> 7765;
7767 -> 7763;
7767 -> 7765;
7768 -> 7767;
7768 -> 7759;
7768 -> 7766;
7768 -> 5451;
7768 -> 7765;
7769 -> 7765;
7770 -> 7767;
7770 -> 7759;
7770 -> 7769;
7770 -> 7765;
7771 -> 7770;
7772 -> 7771;
7772 -> 7767;
7772 -> 7770;
7773 -> 7761;
7774 -> 5477;
7775 -> 7772;
7775 -> 890;
7776 -> 894;
7776 -> 890;
7777 -> 7775;
7777 -> 7776;
7778 -> 7776;
7779 -> 7777;
7779 -> 7778;
7780 -> 5374;
7780 -> 7778;
7781 -> 7778;
7782 -> 7780;
7782 -> 7781;
7783 -> 7781;
7784 -> 7782;
7784 -> 7783;
7785 -> 7784;
7785 -> 7772;
7785 -> 7783;
7786 -> 7783;
7787 -> 7784;
7787 -> 7772;
7787 -> 7786;
7787 -> 7783;
7788 -> 7787;
7788 -> 7778;
7789 -> 7778;
7790 -> 7788;
7790 -> 7789;
7791 -> 7779;
7791 -> 7790;
7792 -> 7791;
7792 -> 890;
7793 -> 7791;
7793 -> 7772;
7793 -> 7787;
7793 -> 890;
7794 -> 890;
7795 -> 7793;
7795 -> 7794;
7796 -> 7793;
7796 -> 7794;
7797 -> 7793;
7797 -> 7794;
7798 -> 7792;
7798 -> 7794;
7799 -> 7795;
7799 -> 7794;
7800 -> 7796;
7800 -> 7794;
7801 -> 7797;
7801 -> 7794;
7802 -> 7794;
7803 -> 7802;
7803 -> 7799;
7803 -> 7800;
7803 -> 7801;
7803 -> 7793;
7803 -> 7794;
7804 -> 7803;
7804 -> 1;
7805 -> 0;
7805 -> 1;
7806 -> 1;
7807 -> 7803;
7807 -> 7806;
7808 -> 7807;
7808 -> 7803;
7808 -> 7806;
7809 -> 7808;
7809 -> 1;
7810 -> 206;
7810 -> 1;
7811 -> 7803;
7811 -> 1;
7812 -> 1;
7813 -> 7811;
7813 -> 7812;
7814 -> 7812;
7815 -> 7811;
7815 -> 7814;
7815 -> 1;
7816 -> 7811;
7816 -> 7812;
7817 -> 7811;
7817 -> 7812;
7818 -> 7811;
7818 -> 7812;
7819 -> 7811;
7819 -> 7812;
7820 -> 7817;
7820 -> 7812;
7821 -> 7812;
7822 -> 7819;
7822 -> 7821;
7823 -> 7821;
7824 -> 7822;
7824 -> 7823;
7825 -> 7824;
7825 -> 7815;
7825 -> 7823;
7826 -> 7825;
7826 -> 7821;
7827 -> 7821;
7828 -> 7826;
7828 -> 7827;
7829 -> 7828;
7829 -> 7827;
7830 -> 7829;
7831 -> 7830;
7831 -> 7812;
7832 -> 7816;
7832 -> 7831;
7832 -> 7815;
7832 -> 7812;
7833 -> 7818;
7833 -> 7812;
7834 -> 7833;
7835 -> 7819;
7835 -> 7834;
7836 -> 7835;
7836 -> 7832;
7836 -> 7834;
7837 -> 7836;
7837 -> 7833;
7838 -> 7833;
7839 -> 7837;
7839 -> 7838;
7839 -> 7833;
7840 -> 7816;
7840 -> 7839;
7841 -> 7839;
7842 -> 7840;
7842 -> 7841;
7843 -> 7841;
7844 -> 7840;
7844 -> 7841;
7845 -> 7840;
7845 -> 7841;
7846 -> 7845;
7846 -> 7843;
7846 -> 7841;
7847 -> 7844;
7847 -> 7846;
7847 -> 7843;
7847 -> 7841;
7848 -> 7820;
7849 -> 7819;
7849 -> 7848;
7850 -> 7848;
7851 -> 7850;
7851 -> 7820;
7852 -> 7820;
7853 -> 7851;
7853 -> 7852;
7853 -> 7820;
7854 -> 7847;
7855 -> 7819;
7855 -> 7834;
7856 -> 7834;
7856 -> 7833;
7857 -> 7856;
7857 -> 7838;
7857 -> 7833;
7858 -> 7819;
7858 -> 7821;
7859 -> 7858;
7859 -> 7854;
7859 -> 7821;
7860 -> 7819;
7860 -> 7848;
7861 -> 7860;
7861 -> 7859;
7861 -> 7848;
7862 -> 7861;
7862 -> 7820;
7863 -> 7862;
7863 -> 7852;
7863 -> 7820;
7864 -> 7859;
7865 -> 7864;
7866 -> 7860;
7866 -> 7864;
7866 -> 7848;
7867 -> 7866;
7867 -> 7820;
7868 -> 7867;
7868 -> 7852;
7868 -> 7820;
7869 -> 7864;
7870 -> 7869;
7871 -> 7860;
7871 -> 7869;
7871 -> 7848;
7872 -> 7871;
7872 -> 7820;
7873 -> 7872;
7873 -> 7852;
7873 -> 7820;
7874 -> 7869;
7875 -> 7874;
7876 -> 7874;
7877 -> 7860;
7877 -> 7876;
7877 -> 7848;
7878 -> 7877;
7878 -> 7820;
7879 -> 7878;
7879 -> 7852;
7879 -> 7820;
7880 -> 7876;
7881 -> 7880;
7882 -> 7860;
7882 -> 7880;
7882 -> 7848;
7883 -> 7882;
7883 -> 7820;
7884 -> 7883;
7884 -> 7852;
7884 -> 7820;
7885 -> 7880;
7886 -> 1;
7887 -> 7803;
7887 -> 1;
7888 -> 1;
7889 -> 7887;
7889 -> 7888;
7890 -> 7889;
7890 -> 7885;
7890 -> 7888;
7891 -> 7888;
7892 -> 7888;
7893 -> 7890;
7893 -> 7892;
7894 -> 7891;
7894 -> 7892;
7895 -> 7892;
7896 -> 7893;
7896 -> 7892;
7897 -> 7896;
7897 -> 7892;
7898 -> 7895;
7898 -> 7892;
7899 -> 7898;
7899 -> 7888;
7900 -> 7899;
7900 -> 1;
7901 -> 7803;
7901 -> 1;
7902 -> 1;
7903 -> 7901;
7903 -> 7896;
7903 -> 1;
7904 -> 1;
7905 -> 7903;
7905 -> 7904;
7906 -> 7904;
7907 -> 7906;
7907 -> 1;
7908 -> 7903;
7908 -> 7907;
7908 -> 1;
7909 -> 0;
7909 -> 1;
7910 -> 7901;
7910 -> 7908;
7910 -> 1;
7911 -> 1;
7912 -> 7910;
7912 -> 7911;
7913 -> 7911;
7914 -> 7913;
7914 -> 1;
7915 -> 7910;
7915 -> 7914;
7915 -> 1;
7916 -> 1;
7917 -> 7901;
7917 -> 7915;
7917 -> 1;
7918 -> 1;
7919 -> 7917;
7919 -> 7918;
7920 -> 7918;
7921 -> 7920;
7921 -> 1;
7922 -> 7917;
7922 -> 7921;
7922 -> 1;
7923 -> 7901;
7923 -> 7922;
7923 -> 1;
7924 -> 1;
7925 -> 7923;
7925 -> 7924;
7926 -> 7923;
7926 -> 7924;
7927 -> 7923;
7927 -> 7924;
7928 -> 7923;
7928 -> 7924;
7929 -> 7924;
7930 -> 1;
7931 -> 1;
7932 -> 7901;
7932 -> 7925;
7932 -> 7931;
7933 -> 7931;
7934 -> 7932;
7934 -> 7925;
7934 -> 7933;
7935 -> 7934;
7935 -> 7931;
7936 -> 7935;
7936 -> 1;
7937 -> 1;
7938 -> 7901;
7938 -> 7925;
7938 -> 1;
7939 -> 1;
7940 -> 7938;
7940 -> 7939;
7941 -> 7939;
7942 -> 7941;
7942 -> 1;
7943 -> 7938;
7943 -> 7942;
7943 -> 1;
7944 -> 1;
7945 -> 7901;
7945 -> 7943;
7945 -> 1;
7946 -> 1;
7947 -> 7945;
7947 -> 7946;
7948 -> 7946;
7949 -> 7948;
7949 -> 1;
7950 -> 7945;
7950 -> 7949;
7950 -> 1;
7951 -> 1;
7952 -> 7901;
7952 -> 7950;
7952 -> 1;
7953 -> 1;
7954 -> 7901;
7954 -> 7950;
7954 -> 7953;
7954 -> 1;
7955 -> 1;
7956 -> 7954;
7956 -> 7955;
7957 -> 7954;
7957 -> 7955;
7958 -> 7954;
7958 -> 7955;
7959 -> 7954;
7959 -> 7955;
7960 -> 7955;
7961 -> 1;
7962 -> 7901;
7962 -> 7956;
7962 -> 7961;
7962 -> 1;
7963 -> 1;
7964 -> 7962;
7964 -> 7963;
7965 -> 7963;
7966 -> 7965;
7966 -> 1;
7967 -> 7962;
7967 -> 7966;
7967 -> 1;
7968 -> 0;
7968 -> 1;
7969 -> 1;
7970 -> 7901;
7970 -> 7967;
7970 -> 7969;
7970 -> 1;
7971 -> 1;
7972 -> 7970;
7972 -> 7971;
7973 -> 7971;
7974 -> 7973;
7974 -> 1;
7975 -> 7970;
7975 -> 7974;
7975 -> 1;
7976 -> 1;
7977 -> 7901;
7977 -> 7975;
7977 -> 7976;
7977 -> 1;
7978 -> 7977;
7978 -> 1;
7979 -> 7977;
7979 -> 1;
7980 -> 1;
7981 -> 7979;
7981 -> 7980;
7982 -> 7979;
7982 -> 7980;
7983 -> 7979;
7983 -> 7980;
7984 -> 7979;
7984 -> 7980;
7985 -> 7980;
7986 -> 1;
7987 -> 1;
7988 -> 7977;
7988 -> 7981;
7988 -> 7987;
7989 -> 7987;
7990 -> 7988;
7990 -> 7981;
7990 -> 7989;
7991 -> 7990;
7991 -> 7987;
7992 -> 7991;
7992 -> 1;
7993 -> 1;
7994 -> 7977;
7994 -> 7981;
7994 -> 1;
7995 -> 1;
7996 -> 7994;
7996 -> 7995;
7997 -> 7995;
7998 -> 7997;
7998 -> 1;
7999 -> 7994;
7999 -> 7998;
7999 -> 1;
8000 -> 1;
8001 -> 7901;
8001 -> 7999;
8001 -> 8000;
8001 -> 1;
8002 -> 1;
8003 -> 8001;
8003 -> 8002;
8004 -> 8001;
8004 -> 8002;
8005 -> 8001;
8005 -> 8002;
8006 -> 8001;
8006 -> 8002;
8007 -> 8002;
8008 -> 1;
8009 -> 7901;
8009 -> 8003;
8009 -> 8008;
8009 -> 1;
8010 -> 8009;
8010 -> 8008;
8011 -> 8008;
8012 -> 8009;
8012 -> 8008;
8013 -> 8012;
8013 -> 8008;
8014 -> 8008;
8015 -> 8014;
8016 -> 8014;
8017 -> 1;
8018 -> 7901;
8018 -> 8009;
8018 -> 8017;
8018 -> 1;
8019 -> 1;
8020 -> 8018;
8020 -> 8019;
8021 -> 8018;
8021 -> 8019;
8022 -> 8018;
8022 -> 8019;
8023 -> 8018;
8023 -> 8019;
8024 -> 8019;
8025 -> 1;
8026 -> 7901;
8026 -> 8020;
8026 -> 8025;
8026 -> 1;
8027 -> 1;
8028 -> 8026;
8028 -> 8027;
8029 -> 8027;
8030 -> 8029;
8030 -> 1;
8031 -> 8026;
8031 -> 8030;
8031 -> 1;
8032 -> 0;
8032 -> 1;
8033 -> 1;
8034 -> 7901;
8034 -> 8031;
8034 -> 8033;
8034 -> 1;
8035 -> 1;
8036 -> 8034;
8036 -> 8035;
8037 -> 8035;
8038 -> 8037;
8038 -> 1;
8039 -> 8034;
8039 -> 8038;
8039 -> 1;
8040 -> 1;
8041 -> 7901;
8041 -> 8039;
8041 -> 8040;
8041 -> 1;
8042 -> 8041;
8042 -> 1;
8043 -> 8041;
8043 -> 1;
8044 -> 1;
8045 -> 8043;
8045 -> 8044;
8046 -> 8043;
8046 -> 8044;
8047 -> 8043;
8047 -> 8044;
8048 -> 8043;
8048 -> 8044;
8049 -> 8044;
8050 -> 1;
8051 -> 1;
8052 -> 8041;
8052 -> 8045;
8052 -> 8051;
8053 -> 8051;
8054 -> 8052;
8054 -> 8045;
8054 -> 8053;
8055 -> 8054;
8055 -> 8051;
8056 -> 8055;
8056 -> 1;
8057 -> 1;
8058 -> 8041;
8058 -> 8045;
8058 -> 1;
8059 -> 1;
8060 -> 8058;
8060 -> 8059;
8061 -> 8059;
8062 -> 8061;
8062 -> 1;
8063 -> 8058;
8063 -> 8062;
8063 -> 1;
8064 -> 1;
8065 -> 7901;
8065 -> 8063;
8065 -> 8064;
8065 -> 1;
8066 -> 1;
8067 -> 8065;
8067 -> 8066;
8068 -> 8065;
8068 -> 8066;
8069 -> 8065;
8069 -> 8066;
8070 -> 8065;
8070 -> 8066;
8071 -> 8066;
8072 -> 1;
8073 -> 7901;
8073 -> 8067;
8073 -> 8072;
8073 -> 1;
8074 -> 8073;
8074 -> 8072;
8075 -> 8072;
8076 -> 8073;
8076 -> 8072;
8077 -> 8076;
8077 -> 8072;
8078 -> 8072;
8079 -> 8078;
8080 -> 8078;
8081 -> 1;
8082 -> 7901;
8082 -> 8073;
8082 -> 1;
8083 -> 1;
8084 -> 8082;
8084 -> 8083;
8085 -> 8083;
8086 -> 8085;
8086 -> 1;
8087 -> 8082;
8087 -> 8086;
8087 -> 1;
}